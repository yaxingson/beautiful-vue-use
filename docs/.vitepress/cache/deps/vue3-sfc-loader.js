import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-7AJPX2AP.js";

// node_modules/.pnpm/vue3-sfc-loader@0.9.5_vue@3.5.12_typescript@5.4.5_/node_modules/vue3-sfc-loader/dist/vue3-sfc-loader.esm.js
var e = [(e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true });
  var n2 = { react: true, assertNode: true, createTypeAnnotationBasedOnTypeof: true, createUnionTypeAnnotation: true, createFlowUnionType: true, createTSUnionType: true, cloneNode: true, clone: true, cloneDeep: true, cloneDeepWithoutLoc: true, cloneWithoutLoc: true, addComment: true, addComments: true, inheritInnerComments: true, inheritLeadingComments: true, inheritsComments: true, inheritTrailingComments: true, removeComments: true, ensureBlock: true, toBindingIdentifierName: true, toBlock: true, toComputedKey: true, toExpression: true, toIdentifier: true, toKeyAlias: true, toStatement: true, valueToNode: true, appendToMemberExpression: true, inherits: true, prependToMemberExpression: true, removeProperties: true, removePropertiesDeep: true, removeTypeDuplicates: true, getBindingIdentifiers: true, getOuterBindingIdentifiers: true, traverse: true, traverseFast: true, shallowEqual: true, is: true, isBinding: true, isBlockScoped: true, isImmutable: true, isLet: true, isNode: true, isNodesEquivalent: true, isPlaceholderType: true, isReferenced: true, isScope: true, isSpecifierDefault: true, isType: true, isValidES3Identifier: true, isValidIdentifier: true, isVar: true, matchesPattern: true, validate: true, buildMatchMemberExpression: true, __internal__deprecationWarning: true };
  Object.defineProperty(t2, "__internal__deprecationWarning", { enumerable: true, get: function() {
    return me.default;
  } }), Object.defineProperty(t2, "addComment", { enumerable: true, get: function() {
    return E.default;
  } }), Object.defineProperty(t2, "addComments", { enumerable: true, get: function() {
    return S.default;
  } }), Object.defineProperty(t2, "appendToMemberExpression", { enumerable: true, get: function() {
    return F.default;
  } }), Object.defineProperty(t2, "assertNode", { enumerable: true, get: function() {
    return a2.default;
  } }), Object.defineProperty(t2, "buildMatchMemberExpression", { enumerable: true, get: function() {
    return fe.default;
  } }), Object.defineProperty(t2, "clone", { enumerable: true, get: function() {
    return y.default;
  } }), Object.defineProperty(t2, "cloneDeep", { enumerable: true, get: function() {
    return g.default;
  } }), Object.defineProperty(t2, "cloneDeepWithoutLoc", { enumerable: true, get: function() {
    return b.default;
  } }), Object.defineProperty(t2, "cloneNode", { enumerable: true, get: function() {
    return m.default;
  } }), Object.defineProperty(t2, "cloneWithoutLoc", { enumerable: true, get: function() {
    return v.default;
  } }), Object.defineProperty(t2, "createFlowUnionType", { enumerable: true, get: function() {
    return u.default;
  } }), Object.defineProperty(t2, "createTSUnionType", { enumerable: true, get: function() {
    return p.default;
  } }), Object.defineProperty(t2, "createTypeAnnotationBasedOnTypeof", { enumerable: true, get: function() {
    return c.default;
  } }), Object.defineProperty(t2, "createUnionTypeAnnotation", { enumerable: true, get: function() {
    return u.default;
  } }), Object.defineProperty(t2, "ensureBlock", { enumerable: true, get: function() {
    return I.default;
  } }), Object.defineProperty(t2, "getBindingIdentifiers", { enumerable: true, get: function() {
    return G.default;
  } }), Object.defineProperty(t2, "getOuterBindingIdentifiers", { enumerable: true, get: function() {
    return H.default;
  } }), Object.defineProperty(t2, "inheritInnerComments", { enumerable: true, get: function() {
    return x.default;
  } }), Object.defineProperty(t2, "inheritLeadingComments", { enumerable: true, get: function() {
    return T.default;
  } }), Object.defineProperty(t2, "inheritTrailingComments", { enumerable: true, get: function() {
    return P.default;
  } }), Object.defineProperty(t2, "inherits", { enumerable: true, get: function() {
    return U.default;
  } }), Object.defineProperty(t2, "inheritsComments", { enumerable: true, get: function() {
    return w.default;
  } }), Object.defineProperty(t2, "is", { enumerable: true, get: function() {
    return J.default;
  } }), Object.defineProperty(t2, "isBinding", { enumerable: true, get: function() {
    return Y.default;
  } }), Object.defineProperty(t2, "isBlockScoped", { enumerable: true, get: function() {
    return Q.default;
  } }), Object.defineProperty(t2, "isImmutable", { enumerable: true, get: function() {
    return Z.default;
  } }), Object.defineProperty(t2, "isLet", { enumerable: true, get: function() {
    return ee.default;
  } }), Object.defineProperty(t2, "isNode", { enumerable: true, get: function() {
    return te.default;
  } }), Object.defineProperty(t2, "isNodesEquivalent", { enumerable: true, get: function() {
    return re.default;
  } }), Object.defineProperty(t2, "isPlaceholderType", { enumerable: true, get: function() {
    return ne.default;
  } }), Object.defineProperty(t2, "isReferenced", { enumerable: true, get: function() {
    return se.default;
  } }), Object.defineProperty(t2, "isScope", { enumerable: true, get: function() {
    return ie.default;
  } }), Object.defineProperty(t2, "isSpecifierDefault", { enumerable: true, get: function() {
    return oe.default;
  } }), Object.defineProperty(t2, "isType", { enumerable: true, get: function() {
    return ae.default;
  } }), Object.defineProperty(t2, "isValidES3Identifier", { enumerable: true, get: function() {
    return le.default;
  } }), Object.defineProperty(t2, "isValidIdentifier", { enumerable: true, get: function() {
    return ce.default;
  } }), Object.defineProperty(t2, "isVar", { enumerable: true, get: function() {
    return ue.default;
  } }), Object.defineProperty(t2, "matchesPattern", { enumerable: true, get: function() {
    return pe.default;
  } }), Object.defineProperty(t2, "prependToMemberExpression", { enumerable: true, get: function() {
    return $.default;
  } }), t2.react = void 0, Object.defineProperty(t2, "removeComments", { enumerable: true, get: function() {
    return A.default;
  } }), Object.defineProperty(t2, "removeProperties", { enumerable: true, get: function() {
    return V.default;
  } }), Object.defineProperty(t2, "removePropertiesDeep", { enumerable: true, get: function() {
    return q.default;
  } }), Object.defineProperty(t2, "removeTypeDuplicates", { enumerable: true, get: function() {
    return W.default;
  } }), Object.defineProperty(t2, "shallowEqual", { enumerable: true, get: function() {
    return X.default;
  } }), Object.defineProperty(t2, "toBindingIdentifierName", { enumerable: true, get: function() {
    return _.default;
  } }), Object.defineProperty(t2, "toBlock", { enumerable: true, get: function() {
    return k.default;
  } }), Object.defineProperty(t2, "toComputedKey", { enumerable: true, get: function() {
    return N.default;
  } }), Object.defineProperty(t2, "toExpression", { enumerable: true, get: function() {
    return D.default;
  } }), Object.defineProperty(t2, "toIdentifier", { enumerable: true, get: function() {
    return j.default;
  } }), Object.defineProperty(t2, "toKeyAlias", { enumerable: true, get: function() {
    return L.default;
  } }), Object.defineProperty(t2, "toStatement", { enumerable: true, get: function() {
    return M.default;
  } }), Object.defineProperty(t2, "traverse", { enumerable: true, get: function() {
    return z.default;
  } }), Object.defineProperty(t2, "traverseFast", { enumerable: true, get: function() {
    return K.default;
  } }), Object.defineProperty(t2, "validate", { enumerable: true, get: function() {
    return de.default;
  } }), Object.defineProperty(t2, "valueToNode", { enumerable: true, get: function() {
    return B.default;
  } });
  var s2 = r2(348), i2 = r2(349), o2 = r2(350), a2 = r2(362), l = r2(363);
  Object.keys(l).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === l[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return l[e3];
    } }));
  });
  var c = r2(364), u = r2(365), p = r2(366), d = r2(4);
  Object.keys(d).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === d[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return d[e3];
    } }));
  });
  var f = r2(368);
  Object.keys(f).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === f[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return f[e3];
    } }));
  });
  var h = r2(369);
  Object.keys(h).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === h[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return h[e3];
    } }));
  });
  var m = r2(27), y = r2(370), g = r2(371), b = r2(372), v = r2(373), E = r2(374), S = r2(172), x = r2(173), T = r2(174), w = r2(175), P = r2(176), A = r2(375), C = r2(376);
  Object.keys(C).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === C[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return C[e3];
    } }));
  });
  var O = r2(26);
  Object.keys(O).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === O[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return O[e3];
    } }));
  });
  var I = r2(377), _ = r2(378), k = r2(177), N = r2(379), D = r2(380), j = r2(178), L = r2(381), M = r2(382), B = r2(383), R = r2(9);
  Object.keys(R).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === R[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return R[e3];
    } }));
  });
  var F = r2(384), U = r2(385), $ = r2(386), V = r2(181), q = r2(179), W = r2(171), G = r2(60), H = r2(387), z = r2(388);
  Object.keys(z).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === z[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return z[e3];
    } }));
  });
  var K = r2(180), X = r2(96), J = r2(42), Y = r2(389), Q = r2(390), Z = r2(391), ee = r2(182), te = r2(170), re = r2(392), ne = r2(168), se = r2(393), ie = r2(394), oe = r2(395), ae = r2(98), le = r2(396), ce = r2(43), ue = r2(397), pe = r2(165), de = r2(97), fe = r2(164), he = r2(2);
  Object.keys(he).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === he[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return he[e3];
    } }));
  });
  var me = r2(58);
  t2.react = { isReactComponent: s2.default, isCompatTag: i2.default, buildChildren: o2.default }, t2.toSequenceExpression = r2(398).default;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.DEFAULT_EXTENSIONS = void 0, Object.defineProperty(t2, "File", { enumerable: true, get: function() {
    return n2.default;
  } }), Object.defineProperty(t2, "buildExternalHelpers", { enumerable: true, get: function() {
    return s2.default;
  } }), Object.defineProperty(t2, "createConfigItem", { enumerable: true, get: function() {
    return p.createConfigItem;
  } }), Object.defineProperty(t2, "createConfigItemAsync", { enumerable: true, get: function() {
    return p.createConfigItemAsync;
  } }), Object.defineProperty(t2, "createConfigItemSync", { enumerable: true, get: function() {
    return p.createConfigItemSync;
  } }), Object.defineProperty(t2, "getEnv", { enumerable: true, get: function() {
    return o2.getEnv;
  } }), Object.defineProperty(t2, "loadOptions", { enumerable: true, get: function() {
    return p.loadOptions;
  } }), Object.defineProperty(t2, "loadOptionsAsync", { enumerable: true, get: function() {
    return p.loadOptionsAsync;
  } }), Object.defineProperty(t2, "loadOptionsSync", { enumerable: true, get: function() {
    return p.loadOptionsSync;
  } }), Object.defineProperty(t2, "loadPartialConfig", { enumerable: true, get: function() {
    return p.loadPartialConfig;
  } }), Object.defineProperty(t2, "loadPartialConfigAsync", { enumerable: true, get: function() {
    return p.loadPartialConfigAsync;
  } }), Object.defineProperty(t2, "loadPartialConfigSync", { enumerable: true, get: function() {
    return p.loadPartialConfigSync;
  } }), Object.defineProperty(t2, "parse", { enumerable: true, get: function() {
    return m.parse;
  } }), Object.defineProperty(t2, "parseAsync", { enumerable: true, get: function() {
    return m.parseAsync;
  } }), Object.defineProperty(t2, "parseSync", { enumerable: true, get: function() {
    return m.parseSync;
  } }), Object.defineProperty(t2, "resolvePlugin", { enumerable: true, get: function() {
    return i2.resolvePlugin;
  } }), Object.defineProperty(t2, "resolvePreset", { enumerable: true, get: function() {
    return i2.resolvePreset;
  } }), Object.defineProperty(t2, "template", { enumerable: true, get: function() {
    return u().default;
  } }), Object.defineProperty(t2, "tokTypes", { enumerable: true, get: function() {
    return l().tokTypes;
  } }), Object.defineProperty(t2, "transform", { enumerable: true, get: function() {
    return d.transform;
  } }), Object.defineProperty(t2, "transformAsync", { enumerable: true, get: function() {
    return d.transformAsync;
  } }), Object.defineProperty(t2, "transformFile", { enumerable: true, get: function() {
    return f.transformFile;
  } }), Object.defineProperty(t2, "transformFileAsync", { enumerable: true, get: function() {
    return f.transformFileAsync;
  } }), Object.defineProperty(t2, "transformFileSync", { enumerable: true, get: function() {
    return f.transformFileSync;
  } }), Object.defineProperty(t2, "transformFromAst", { enumerable: true, get: function() {
    return h.transformFromAst;
  } }), Object.defineProperty(t2, "transformFromAstAsync", { enumerable: true, get: function() {
    return h.transformFromAstAsync;
  } }), Object.defineProperty(t2, "transformFromAstSync", { enumerable: true, get: function() {
    return h.transformFromAstSync;
  } }), Object.defineProperty(t2, "transformSync", { enumerable: true, get: function() {
    return d.transformSync;
  } }), Object.defineProperty(t2, "traverse", { enumerable: true, get: function() {
    return c().default;
  } }), t2.version = t2.types = void 0;
  var n2 = r2(95), s2 = r2(453), i2 = r2(81), o2 = r2(278);
  function a2() {
    const e3 = r2(0);
    return a2 = function() {
      return e3;
    }, e3;
  }
  function l() {
    const e3 = r2(21);
    return l = function() {
      return e3;
    }, e3;
  }
  function c() {
    const e3 = r2(14);
    return c = function() {
      return e3;
    }, e3;
  }
  function u() {
    const e3 = r2(37);
    return u = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "types", { enumerable: true, get: function() {
    return a2();
  } });
  var p = r2(82), d = r2(475), f = r2(488), h = r2(489), m = r2(490);
  r2(1), t2.version = "7.23.9", t2.DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]), t2.OptionManager = class {
    init(e3) {
      return (0, p.loadOptionsSync)(e3);
    }
  }, t2.Plugin = function(e3) {
    throw new Error(`The (${e3}) Babel 5 plugin is being run with an unsupported Babel version.`);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isAccessor = function(e3, t3) {
    return !!e3 && ("ClassAccessorProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3)));
  }, t2.isAnyTypeAnnotation = function(e3, t3) {
    return !!e3 && "AnyTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isArgumentPlaceholder = function(e3, t3) {
    return !!e3 && "ArgumentPlaceholder" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isArrayExpression = function(e3, t3) {
    return !!e3 && "ArrayExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isArrayPattern = function(e3, t3) {
    return !!e3 && "ArrayPattern" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isArrayTypeAnnotation = function(e3, t3) {
    return !!e3 && "ArrayTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isArrowFunctionExpression = function(e3, t3) {
    return !!e3 && "ArrowFunctionExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isAssignmentExpression = function(e3, t3) {
    return !!e3 && "AssignmentExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isAssignmentPattern = function(e3, t3) {
    return !!e3 && "AssignmentPattern" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isAwaitExpression = function(e3, t3) {
    return !!e3 && "AwaitExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBigIntLiteral = function(e3, t3) {
    return !!e3 && "BigIntLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBinary = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isBinaryExpression = function(e3, t3) {
    return !!e3 && "BinaryExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBindExpression = function(e3, t3) {
    return !!e3 && "BindExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBlock = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if ("BlockStatement" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isBlockParent = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if ("BlockStatement" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isBlockStatement = function(e3, t3) {
    return !!e3 && "BlockStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBooleanLiteral = function(e3, t3) {
    return !!e3 && "BooleanLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBooleanLiteralTypeAnnotation = function(e3, t3) {
    return !!e3 && "BooleanLiteralTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBooleanTypeAnnotation = function(e3, t3) {
    return !!e3 && "BooleanTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBreakStatement = function(e3, t3) {
    return !!e3 && "BreakStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isCallExpression = function(e3, t3) {
    return !!e3 && "CallExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isCatchClause = function(e3, t3) {
    return !!e3 && "CatchClause" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClass = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isClassAccessorProperty = function(e3, t3) {
    return !!e3 && "ClassAccessorProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassBody = function(e3, t3) {
    return !!e3 && "ClassBody" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassDeclaration = function(e3, t3) {
    return !!e3 && "ClassDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassExpression = function(e3, t3) {
    return !!e3 && "ClassExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassImplements = function(e3, t3) {
    return !!e3 && "ClassImplements" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassMethod = function(e3, t3) {
    return !!e3 && "ClassMethod" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassPrivateMethod = function(e3, t3) {
    return !!e3 && "ClassPrivateMethod" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassPrivateProperty = function(e3, t3) {
    return !!e3 && "ClassPrivateProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassProperty = function(e3, t3) {
    return !!e3 && "ClassProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isCompletionStatement = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isConditional = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isConditionalExpression = function(e3, t3) {
    return !!e3 && "ConditionalExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isContinueStatement = function(e3, t3) {
    return !!e3 && "ContinueStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDebuggerStatement = function(e3, t3) {
    return !!e3 && "DebuggerStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDecimalLiteral = function(e3, t3) {
    return !!e3 && "DecimalLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclaration = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if ("Declaration" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isDeclareClass = function(e3, t3) {
    return !!e3 && "DeclareClass" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareExportAllDeclaration = function(e3, t3) {
    return !!e3 && "DeclareExportAllDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareExportDeclaration = function(e3, t3) {
    return !!e3 && "DeclareExportDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareFunction = function(e3, t3) {
    return !!e3 && "DeclareFunction" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareInterface = function(e3, t3) {
    return !!e3 && "DeclareInterface" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareModule = function(e3, t3) {
    return !!e3 && "DeclareModule" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareModuleExports = function(e3, t3) {
    return !!e3 && "DeclareModuleExports" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareOpaqueType = function(e3, t3) {
    return !!e3 && "DeclareOpaqueType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareTypeAlias = function(e3, t3) {
    return !!e3 && "DeclareTypeAlias" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareVariable = function(e3, t3) {
    return !!e3 && "DeclareVariable" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclaredPredicate = function(e3, t3) {
    return !!e3 && "DeclaredPredicate" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDecorator = function(e3, t3) {
    return !!e3 && "Decorator" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDirective = function(e3, t3) {
    return !!e3 && "Directive" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDirectiveLiteral = function(e3, t3) {
    return !!e3 && "DirectiveLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDoExpression = function(e3, t3) {
    return !!e3 && "DoExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDoWhileStatement = function(e3, t3) {
    return !!e3 && "DoWhileStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEmptyStatement = function(e3, t3) {
    return !!e3 && "EmptyStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEmptyTypeAnnotation = function(e3, t3) {
    return !!e3 && "EmptyTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumBody = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isEnumBooleanBody = function(e3, t3) {
    return !!e3 && "EnumBooleanBody" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumBooleanMember = function(e3, t3) {
    return !!e3 && "EnumBooleanMember" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumDeclaration = function(e3, t3) {
    return !!e3 && "EnumDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumDefaultedMember = function(e3, t3) {
    return !!e3 && "EnumDefaultedMember" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumMember = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isEnumNumberBody = function(e3, t3) {
    return !!e3 && "EnumNumberBody" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumNumberMember = function(e3, t3) {
    return !!e3 && "EnumNumberMember" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumStringBody = function(e3, t3) {
    return !!e3 && "EnumStringBody" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumStringMember = function(e3, t3) {
    return !!e3 && "EnumStringMember" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumSymbolBody = function(e3, t3) {
    return !!e3 && "EnumSymbolBody" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExistsTypeAnnotation = function(e3, t3) {
    return !!e3 && "ExistsTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExportAllDeclaration = function(e3, t3) {
    return !!e3 && "ExportAllDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExportDeclaration = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isExportDefaultDeclaration = function(e3, t3) {
    return !!e3 && "ExportDefaultDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExportDefaultSpecifier = function(e3, t3) {
    return !!e3 && "ExportDefaultSpecifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExportNamedDeclaration = function(e3, t3) {
    return !!e3 && "ExportNamedDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExportNamespaceSpecifier = function(e3, t3) {
    return !!e3 && "ExportNamespaceSpecifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExportSpecifier = function(e3, t3) {
    return !!e3 && "ExportSpecifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExpression = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e3.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isExpressionStatement = function(e3, t3) {
    return !!e3 && "ExpressionStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExpressionWrapper = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFile = function(e3, t3) {
    return !!e3 && "File" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isFlow = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFlowBaseAnnotation = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFlowDeclaration = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFlowPredicate = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFlowType = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFor = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isForInStatement = function(e3, t3) {
    return !!e3 && "ForInStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isForOfStatement = function(e3, t3) {
    return !!e3 && "ForOfStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isForStatement = function(e3, t3) {
    return !!e3 && "ForStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isForXStatement = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFunction = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFunctionDeclaration = function(e3, t3) {
    return !!e3 && "FunctionDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isFunctionExpression = function(e3, t3) {
    return !!e3 && "FunctionExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isFunctionParent = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFunctionTypeAnnotation = function(e3, t3) {
    return !!e3 && "FunctionTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isFunctionTypeParam = function(e3, t3) {
    return !!e3 && "FunctionTypeParam" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isGenericTypeAnnotation = function(e3, t3) {
    return !!e3 && "GenericTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isIdentifier = function(e3, t3) {
    return !!e3 && "Identifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isIfStatement = function(e3, t3) {
    return !!e3 && "IfStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImmutable = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if ("StringLiteral" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isImport = function(e3, t3) {
    return !!e3 && "Import" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImportAttribute = function(e3, t3) {
    return !!e3 && "ImportAttribute" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImportDeclaration = function(e3, t3) {
    return !!e3 && "ImportDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImportDefaultSpecifier = function(e3, t3) {
    return !!e3 && "ImportDefaultSpecifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImportExpression = function(e3, t3) {
    return !!e3 && "ImportExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImportNamespaceSpecifier = function(e3, t3) {
    return !!e3 && "ImportNamespaceSpecifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImportOrExportDeclaration = i2, t2.isImportSpecifier = function(e3, t3) {
    return !!e3 && "ImportSpecifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isIndexedAccessType = function(e3, t3) {
    return !!e3 && "IndexedAccessType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isInferredPredicate = function(e3, t3) {
    return !!e3 && "InferredPredicate" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isInterfaceDeclaration = function(e3, t3) {
    return !!e3 && "InterfaceDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isInterfaceExtends = function(e3, t3) {
    return !!e3 && "InterfaceExtends" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isInterfaceTypeAnnotation = function(e3, t3) {
    return !!e3 && "InterfaceTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isInterpreterDirective = function(e3, t3) {
    return !!e3 && "InterpreterDirective" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isIntersectionTypeAnnotation = function(e3, t3) {
    return !!e3 && "IntersectionTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSX = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isJSXAttribute = function(e3, t3) {
    return !!e3 && "JSXAttribute" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXClosingElement = function(e3, t3) {
    return !!e3 && "JSXClosingElement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXClosingFragment = function(e3, t3) {
    return !!e3 && "JSXClosingFragment" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXElement = function(e3, t3) {
    return !!e3 && "JSXElement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXEmptyExpression = function(e3, t3) {
    return !!e3 && "JSXEmptyExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXExpressionContainer = function(e3, t3) {
    return !!e3 && "JSXExpressionContainer" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXFragment = function(e3, t3) {
    return !!e3 && "JSXFragment" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXIdentifier = function(e3, t3) {
    return !!e3 && "JSXIdentifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXMemberExpression = function(e3, t3) {
    return !!e3 && "JSXMemberExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXNamespacedName = function(e3, t3) {
    return !!e3 && "JSXNamespacedName" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXOpeningElement = function(e3, t3) {
    return !!e3 && "JSXOpeningElement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXOpeningFragment = function(e3, t3) {
    return !!e3 && "JSXOpeningFragment" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXSpreadAttribute = function(e3, t3) {
    return !!e3 && "JSXSpreadAttribute" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXSpreadChild = function(e3, t3) {
    return !!e3 && "JSXSpreadChild" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXText = function(e3, t3) {
    return !!e3 && "JSXText" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isLVal = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e3.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isLabeledStatement = function(e3, t3) {
    return !!e3 && "LabeledStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isLiteral = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if ("StringLiteral" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isLogicalExpression = function(e3, t3) {
    return !!e3 && "LogicalExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isLoop = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isMemberExpression = function(e3, t3) {
    return !!e3 && "MemberExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isMetaProperty = function(e3, t3) {
    return !!e3 && "MetaProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isMethod = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isMiscellaneous = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isMixedTypeAnnotation = function(e3, t3) {
    return !!e3 && "MixedTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isModuleDeclaration = function(e3, t3) {
    return (0, s2.default)("isModuleDeclaration", "isImportOrExportDeclaration"), i2(e3, t3);
  }, t2.isModuleExpression = function(e3, t3) {
    return !!e3 && "ModuleExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isModuleSpecifier = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isNewExpression = function(e3, t3) {
    return !!e3 && "NewExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNoop = function(e3, t3) {
    return !!e3 && "Noop" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNullLiteral = function(e3, t3) {
    return !!e3 && "NullLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNullLiteralTypeAnnotation = function(e3, t3) {
    return !!e3 && "NullLiteralTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNullableTypeAnnotation = function(e3, t3) {
    return !!e3 && "NullableTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNumberLiteral = function(e3, t3) {
    return (0, s2.default)("isNumberLiteral", "isNumericLiteral"), !!e3 && "NumberLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNumberLiteralTypeAnnotation = function(e3, t3) {
    return !!e3 && "NumberLiteralTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNumberTypeAnnotation = function(e3, t3) {
    return !!e3 && "NumberTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNumericLiteral = function(e3, t3) {
    return !!e3 && "NumericLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectExpression = function(e3, t3) {
    return !!e3 && "ObjectExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectMember = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isObjectMethod = function(e3, t3) {
    return !!e3 && "ObjectMethod" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectPattern = function(e3, t3) {
    return !!e3 && "ObjectPattern" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectProperty = function(e3, t3) {
    return !!e3 && "ObjectProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectTypeAnnotation = function(e3, t3) {
    return !!e3 && "ObjectTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectTypeCallProperty = function(e3, t3) {
    return !!e3 && "ObjectTypeCallProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectTypeIndexer = function(e3, t3) {
    return !!e3 && "ObjectTypeIndexer" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectTypeInternalSlot = function(e3, t3) {
    return !!e3 && "ObjectTypeInternalSlot" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectTypeProperty = function(e3, t3) {
    return !!e3 && "ObjectTypeProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectTypeSpreadProperty = function(e3, t3) {
    return !!e3 && "ObjectTypeSpreadProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isOpaqueType = function(e3, t3) {
    return !!e3 && "OpaqueType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isOptionalCallExpression = function(e3, t3) {
    return !!e3 && "OptionalCallExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isOptionalIndexedAccessType = function(e3, t3) {
    return !!e3 && "OptionalIndexedAccessType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isOptionalMemberExpression = function(e3, t3) {
    return !!e3 && "OptionalMemberExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isParenthesizedExpression = function(e3, t3) {
    return !!e3 && "ParenthesizedExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isPattern = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if ("Pattern" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isPatternLike = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e3.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isPipelineBareFunction = function(e3, t3) {
    return !!e3 && "PipelineBareFunction" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isPipelinePrimaryTopicReference = function(e3, t3) {
    return !!e3 && "PipelinePrimaryTopicReference" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isPipelineTopicExpression = function(e3, t3) {
    return !!e3 && "PipelineTopicExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isPlaceholder = function(e3, t3) {
    return !!e3 && "Placeholder" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isPrivate = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isPrivateName = function(e3, t3) {
    return !!e3 && "PrivateName" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isProgram = function(e3, t3) {
    return !!e3 && "Program" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isProperty = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isPureish = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if ("StringLiteral" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isQualifiedTypeIdentifier = function(e3, t3) {
    return !!e3 && "QualifiedTypeIdentifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isRecordExpression = function(e3, t3) {
    return !!e3 && "RecordExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isRegExpLiteral = function(e3, t3) {
    return !!e3 && "RegExpLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isRegexLiteral = function(e3, t3) {
    return (0, s2.default)("isRegexLiteral", "isRegExpLiteral"), !!e3 && "RegexLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isRestElement = function(e3, t3) {
    return !!e3 && "RestElement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isRestProperty = function(e3, t3) {
    return (0, s2.default)("isRestProperty", "isRestElement"), !!e3 && "RestProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isReturnStatement = function(e3, t3) {
    return !!e3 && "ReturnStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isScopable = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if ("BlockStatement" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isSequenceExpression = function(e3, t3) {
    return !!e3 && "SequenceExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isSpreadElement = function(e3, t3) {
    return !!e3 && "SpreadElement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isSpreadProperty = function(e3, t3) {
    return (0, s2.default)("isSpreadProperty", "isSpreadElement"), !!e3 && "SpreadProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isStandardized = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (e3.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isStatement = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (e3.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isStaticBlock = function(e3, t3) {
    return !!e3 && "StaticBlock" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isStringLiteral = function(e3, t3) {
    return !!e3 && "StringLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isStringLiteralTypeAnnotation = function(e3, t3) {
    return !!e3 && "StringLiteralTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isStringTypeAnnotation = function(e3, t3) {
    return !!e3 && "StringTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isSuper = function(e3, t3) {
    return !!e3 && "Super" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isSwitchCase = function(e3, t3) {
    return !!e3 && "SwitchCase" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isSwitchStatement = function(e3, t3) {
    return !!e3 && "SwitchStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isSymbolTypeAnnotation = function(e3, t3) {
    return !!e3 && "SymbolTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSAnyKeyword = function(e3, t3) {
    return !!e3 && "TSAnyKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSArrayType = function(e3, t3) {
    return !!e3 && "TSArrayType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSAsExpression = function(e3, t3) {
    return !!e3 && "TSAsExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSBaseType = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isTSBigIntKeyword = function(e3, t3) {
    return !!e3 && "TSBigIntKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSBooleanKeyword = function(e3, t3) {
    return !!e3 && "TSBooleanKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSCallSignatureDeclaration = function(e3, t3) {
    return !!e3 && "TSCallSignatureDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSConditionalType = function(e3, t3) {
    return !!e3 && "TSConditionalType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSConstructSignatureDeclaration = function(e3, t3) {
    return !!e3 && "TSConstructSignatureDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSConstructorType = function(e3, t3) {
    return !!e3 && "TSConstructorType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSDeclareFunction = function(e3, t3) {
    return !!e3 && "TSDeclareFunction" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSDeclareMethod = function(e3, t3) {
    return !!e3 && "TSDeclareMethod" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSEntityName = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if ("Identifier" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isTSEnumDeclaration = function(e3, t3) {
    return !!e3 && "TSEnumDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSEnumMember = function(e3, t3) {
    return !!e3 && "TSEnumMember" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSExportAssignment = function(e3, t3) {
    return !!e3 && "TSExportAssignment" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSExpressionWithTypeArguments = function(e3, t3) {
    return !!e3 && "TSExpressionWithTypeArguments" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSExternalModuleReference = function(e3, t3) {
    return !!e3 && "TSExternalModuleReference" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSFunctionType = function(e3, t3) {
    return !!e3 && "TSFunctionType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSImportEqualsDeclaration = function(e3, t3) {
    return !!e3 && "TSImportEqualsDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSImportType = function(e3, t3) {
    return !!e3 && "TSImportType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSIndexSignature = function(e3, t3) {
    return !!e3 && "TSIndexSignature" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSIndexedAccessType = function(e3, t3) {
    return !!e3 && "TSIndexedAccessType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSInferType = function(e3, t3) {
    return !!e3 && "TSInferType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSInstantiationExpression = function(e3, t3) {
    return !!e3 && "TSInstantiationExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSInterfaceBody = function(e3, t3) {
    return !!e3 && "TSInterfaceBody" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSInterfaceDeclaration = function(e3, t3) {
    return !!e3 && "TSInterfaceDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSIntersectionType = function(e3, t3) {
    return !!e3 && "TSIntersectionType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSIntrinsicKeyword = function(e3, t3) {
    return !!e3 && "TSIntrinsicKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSLiteralType = function(e3, t3) {
    return !!e3 && "TSLiteralType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSMappedType = function(e3, t3) {
    return !!e3 && "TSMappedType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSMethodSignature = function(e3, t3) {
    return !!e3 && "TSMethodSignature" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSModuleBlock = function(e3, t3) {
    return !!e3 && "TSModuleBlock" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSModuleDeclaration = function(e3, t3) {
    return !!e3 && "TSModuleDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSNamedTupleMember = function(e3, t3) {
    return !!e3 && "TSNamedTupleMember" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSNamespaceExportDeclaration = function(e3, t3) {
    return !!e3 && "TSNamespaceExportDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSNeverKeyword = function(e3, t3) {
    return !!e3 && "TSNeverKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSNonNullExpression = function(e3, t3) {
    return !!e3 && "TSNonNullExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSNullKeyword = function(e3, t3) {
    return !!e3 && "TSNullKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSNumberKeyword = function(e3, t3) {
    return !!e3 && "TSNumberKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSObjectKeyword = function(e3, t3) {
    return !!e3 && "TSObjectKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSOptionalType = function(e3, t3) {
    return !!e3 && "TSOptionalType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSParameterProperty = function(e3, t3) {
    return !!e3 && "TSParameterProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSParenthesizedType = function(e3, t3) {
    return !!e3 && "TSParenthesizedType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSPropertySignature = function(e3, t3) {
    return !!e3 && "TSPropertySignature" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSQualifiedName = function(e3, t3) {
    return !!e3 && "TSQualifiedName" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSRestType = function(e3, t3) {
    return !!e3 && "TSRestType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSSatisfiesExpression = function(e3, t3) {
    return !!e3 && "TSSatisfiesExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSStringKeyword = function(e3, t3) {
    return !!e3 && "TSStringKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSSymbolKeyword = function(e3, t3) {
    return !!e3 && "TSSymbolKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSThisType = function(e3, t3) {
    return !!e3 && "TSThisType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTupleType = function(e3, t3) {
    return !!e3 && "TSTupleType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSType = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isTSTypeAliasDeclaration = function(e3, t3) {
    return !!e3 && "TSTypeAliasDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeAnnotation = function(e3, t3) {
    return !!e3 && "TSTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeAssertion = function(e3, t3) {
    return !!e3 && "TSTypeAssertion" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeElement = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isTSTypeLiteral = function(e3, t3) {
    return !!e3 && "TSTypeLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeOperator = function(e3, t3) {
    return !!e3 && "TSTypeOperator" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeParameter = function(e3, t3) {
    return !!e3 && "TSTypeParameter" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeParameterDeclaration = function(e3, t3) {
    return !!e3 && "TSTypeParameterDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeParameterInstantiation = function(e3, t3) {
    return !!e3 && "TSTypeParameterInstantiation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypePredicate = function(e3, t3) {
    return !!e3 && "TSTypePredicate" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeQuery = function(e3, t3) {
    return !!e3 && "TSTypeQuery" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeReference = function(e3, t3) {
    return !!e3 && "TSTypeReference" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSUndefinedKeyword = function(e3, t3) {
    return !!e3 && "TSUndefinedKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSUnionType = function(e3, t3) {
    return !!e3 && "TSUnionType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSUnknownKeyword = function(e3, t3) {
    return !!e3 && "TSUnknownKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSVoidKeyword = function(e3, t3) {
    return !!e3 && "TSVoidKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTaggedTemplateExpression = function(e3, t3) {
    return !!e3 && "TaggedTemplateExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTemplateElement = function(e3, t3) {
    return !!e3 && "TemplateElement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTemplateLiteral = function(e3, t3) {
    return !!e3 && "TemplateLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTerminatorless = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isThisExpression = function(e3, t3) {
    return !!e3 && "ThisExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isThisTypeAnnotation = function(e3, t3) {
    return !!e3 && "ThisTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isThrowStatement = function(e3, t3) {
    return !!e3 && "ThrowStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTopicReference = function(e3, t3) {
    return !!e3 && "TopicReference" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTryStatement = function(e3, t3) {
    return !!e3 && "TryStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTupleExpression = function(e3, t3) {
    return !!e3 && "TupleExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTupleTypeAnnotation = function(e3, t3) {
    return !!e3 && "TupleTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeAlias = function(e3, t3) {
    return !!e3 && "TypeAlias" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeAnnotation = function(e3, t3) {
    return !!e3 && "TypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeCastExpression = function(e3, t3) {
    return !!e3 && "TypeCastExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeParameter = function(e3, t3) {
    return !!e3 && "TypeParameter" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeParameterDeclaration = function(e3, t3) {
    return !!e3 && "TypeParameterDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeParameterInstantiation = function(e3, t3) {
    return !!e3 && "TypeParameterInstantiation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeScript = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isTypeofTypeAnnotation = function(e3, t3) {
    return !!e3 && "TypeofTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isUnaryExpression = function(e3, t3) {
    return !!e3 && "UnaryExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isUnaryLike = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isUnionTypeAnnotation = function(e3, t3) {
    return !!e3 && "UnionTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isUpdateExpression = function(e3, t3) {
    return !!e3 && "UpdateExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isUserWhitespacable = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isV8IntrinsicIdentifier = function(e3, t3) {
    return !!e3 && "V8IntrinsicIdentifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isVariableDeclaration = function(e3, t3) {
    return !!e3 && "VariableDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isVariableDeclarator = function(e3, t3) {
    return !!e3 && "VariableDeclarator" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isVariance = function(e3, t3) {
    return !!e3 && "Variance" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isVoidTypeAnnotation = function(e3, t3) {
    return !!e3 && "VoidTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isWhile = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isWhileStatement = function(e3, t3) {
    return !!e3 && "WhileStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isWithStatement = function(e3, t3) {
    return !!e3 && "WithStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isYieldExpression = function(e3, t3) {
    return !!e3 && "YieldExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  };
  var n2 = r2(96), s2 = r2(58);
  function i2(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }
}, (e2, t2, r2) => {
  const n2 = r2(48), { MAX_LENGTH: s2, MAX_SAFE_INTEGER: i2 } = r2(47), { safeRe: o2, t: a2 } = r2(34), l = r2(75), { compareIdentifiers: c } = r2(128);
  class u {
    constructor(e3, t3) {
      if (t3 = l(t3), e3 instanceof u) {
        if (e3.loose === !!t3.loose && e3.includePrerelease === !!t3.includePrerelease) return e3;
        e3 = e3.version;
      } else if ("string" != typeof e3) throw new TypeError(`Invalid version. Must be a string. Got type "${typeof e3}".`);
      if (e3.length > s2) throw new TypeError(`version is longer than ${s2} characters`);
      n2("SemVer", e3, t3), this.options = t3, this.loose = !!t3.loose, this.includePrerelease = !!t3.includePrerelease;
      const r3 = e3.trim().match(t3.loose ? o2[a2.LOOSE] : o2[a2.FULL]);
      if (!r3) throw new TypeError(`Invalid Version: ${e3}`);
      if (this.raw = e3, this.major = +r3[1], this.minor = +r3[2], this.patch = +r3[3], this.major > i2 || this.major < 0) throw new TypeError("Invalid major version");
      if (this.minor > i2 || this.minor < 0) throw new TypeError("Invalid minor version");
      if (this.patch > i2 || this.patch < 0) throw new TypeError("Invalid patch version");
      r3[4] ? this.prerelease = r3[4].split(".").map((e4) => {
        if (/^[0-9]+$/.test(e4)) {
          const t4 = +e4;
          if (t4 >= 0 && t4 < i2) return t4;
        }
        return e4;
      }) : this.prerelease = [], this.build = r3[5] ? r3[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(e3) {
      if (n2("SemVer.compare", this.version, this.options, e3), !(e3 instanceof u)) {
        if ("string" == typeof e3 && e3 === this.version) return 0;
        e3 = new u(e3, this.options);
      }
      return e3.version === this.version ? 0 : this.compareMain(e3) || this.comparePre(e3);
    }
    compareMain(e3) {
      return e3 instanceof u || (e3 = new u(e3, this.options)), c(this.major, e3.major) || c(this.minor, e3.minor) || c(this.patch, e3.patch);
    }
    comparePre(e3) {
      if (e3 instanceof u || (e3 = new u(e3, this.options)), this.prerelease.length && !e3.prerelease.length) return -1;
      if (!this.prerelease.length && e3.prerelease.length) return 1;
      if (!this.prerelease.length && !e3.prerelease.length) return 0;
      let t3 = 0;
      do {
        const r3 = this.prerelease[t3], s3 = e3.prerelease[t3];
        if (n2("prerelease compare", t3, r3, s3), void 0 === r3 && void 0 === s3) return 0;
        if (void 0 === s3) return 1;
        if (void 0 === r3) return -1;
        if (r3 !== s3) return c(r3, s3);
      } while (++t3);
    }
    compareBuild(e3) {
      e3 instanceof u || (e3 = new u(e3, this.options));
      let t3 = 0;
      do {
        const r3 = this.build[t3], s3 = e3.build[t3];
        if (n2("prerelease compare", t3, r3, s3), void 0 === r3 && void 0 === s3) return 0;
        if (void 0 === s3) return 1;
        if (void 0 === r3) return -1;
        if (r3 !== s3) return c(r3, s3);
      } while (++t3);
    }
    inc(e3, t3, r3) {
      switch (e3) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t3, r3);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t3, r3);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", t3, r3), this.inc("pre", t3, r3);
          break;
        case "prerelease":
          0 === this.prerelease.length && this.inc("patch", t3, r3), this.inc("pre", t3, r3);
          break;
        case "major":
          0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          0 === this.prerelease.length && this.patch++, this.prerelease = [];
          break;
        case "pre": {
          const e4 = Number(r3) ? 1 : 0;
          if (!t3 && false === r3) throw new Error("invalid increment argument: identifier is empty");
          if (0 === this.prerelease.length) this.prerelease = [e4];
          else {
            let n3 = this.prerelease.length;
            for (; --n3 >= 0; ) "number" == typeof this.prerelease[n3] && (this.prerelease[n3]++, n3 = -2);
            if (-1 === n3) {
              if (t3 === this.prerelease.join(".") && false === r3) throw new Error("invalid increment argument: identifier already exists");
              this.prerelease.push(e4);
            }
          }
          if (t3) {
            let n3 = [t3, e4];
            false === r3 && (n3 = [t3]), 0 === c(this.prerelease[0], t3) ? isNaN(this.prerelease[1]) && (this.prerelease = n3) : this.prerelease = n3;
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${e3}`);
      }
      return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
    }
  }
  e2.exports = u;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.anyTypeAnnotation = function() {
    return { type: "AnyTypeAnnotation" };
  }, t2.argumentPlaceholder = function() {
    return { type: "ArgumentPlaceholder" };
  }, t2.arrayExpression = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return (0, n2.default)({ type: "ArrayExpression", elements: e3 });
  }, t2.arrayPattern = function(e3) {
    return (0, n2.default)({ type: "ArrayPattern", elements: e3 });
  }, t2.arrayTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "ArrayTypeAnnotation", elementType: e3 });
  }, t2.arrowFunctionExpression = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return (0, n2.default)({ type: "ArrowFunctionExpression", params: e3, body: t3, async: r3, expression: null });
  }, t2.assignmentExpression = function(e3, t3, r3) {
    return (0, n2.default)({ type: "AssignmentExpression", operator: e3, left: t3, right: r3 });
  }, t2.assignmentPattern = function(e3, t3) {
    return (0, n2.default)({ type: "AssignmentPattern", left: e3, right: t3 });
  }, t2.awaitExpression = function(e3) {
    return (0, n2.default)({ type: "AwaitExpression", argument: e3 });
  }, t2.bigIntLiteral = function(e3) {
    return (0, n2.default)({ type: "BigIntLiteral", value: e3 });
  }, t2.binaryExpression = function(e3, t3, r3) {
    return (0, n2.default)({ type: "BinaryExpression", operator: e3, left: t3, right: r3 });
  }, t2.bindExpression = function(e3, t3) {
    return (0, n2.default)({ type: "BindExpression", object: e3, callee: t3 });
  }, t2.blockStatement = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    return (0, n2.default)({ type: "BlockStatement", body: e3, directives: t3 });
  }, t2.booleanLiteral = function(e3) {
    return (0, n2.default)({ type: "BooleanLiteral", value: e3 });
  }, t2.booleanLiteralTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "BooleanLiteralTypeAnnotation", value: e3 });
  }, t2.booleanTypeAnnotation = function() {
    return { type: "BooleanTypeAnnotation" };
  }, t2.breakStatement = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
    return (0, n2.default)({ type: "BreakStatement", label: e3 });
  }, t2.callExpression = function(e3, t3) {
    return (0, n2.default)({ type: "CallExpression", callee: e3, arguments: t3 });
  }, t2.catchClause = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0;
    return (0, n2.default)({ type: "CatchClause", param: e3, body: t3 });
  }, t2.classAccessorProperty = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o3 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
    return (0, n2.default)({ type: "ClassAccessorProperty", key: e3, value: t3, typeAnnotation: r3, decorators: s3, computed: i3, static: o3 });
  }, t2.classBody = function(e3) {
    return (0, n2.default)({ type: "ClassBody", body: e3 });
  }, t2.classDeclaration = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "ClassDeclaration", id: e3, superClass: t3, body: r3, decorators: s3 });
  }, t2.classExpression = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "ClassExpression", id: e3, superClass: t3, body: r3, decorators: s3 });
  }, t2.classImplements = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "ClassImplements", id: e3, typeParameters: t3 });
  }, t2.classMethod = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "method", t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 ? arguments[3] : void 0, i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o3 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5], a3 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], l2 = arguments.length > 7 && void 0 !== arguments[7] && arguments[7];
    return (0, n2.default)({ type: "ClassMethod", kind: e3, key: t3, params: r3, body: s3, computed: i3, static: o3, generator: a3, async: l2 });
  }, t2.classPrivateMethod = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "method", t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 ? arguments[3] : void 0, i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    return (0, n2.default)({ type: "ClassPrivateMethod", kind: e3, key: t3, params: r3, body: s3, static: i3 });
  }, t2.classPrivateProperty = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    return (0, n2.default)({ type: "ClassPrivateProperty", key: e3, value: t3, decorators: r3, static: s3 });
  }, t2.classProperty = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o3 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
    return (0, n2.default)({ type: "ClassProperty", key: e3, value: t3, typeAnnotation: r3, decorators: s3, computed: i3, static: o3 });
  }, t2.conditionalExpression = function(e3, t3, r3) {
    return (0, n2.default)({ type: "ConditionalExpression", test: e3, consequent: t3, alternate: r3 });
  }, t2.continueStatement = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
    return (0, n2.default)({ type: "ContinueStatement", label: e3 });
  }, t2.debuggerStatement = function() {
    return { type: "DebuggerStatement" };
  }, t2.decimalLiteral = function(e3) {
    return (0, n2.default)({ type: "DecimalLiteral", value: e3 });
  }, t2.declareClass = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "DeclareClass", id: e3, typeParameters: t3, extends: r3, body: s3 });
  }, t2.declareExportAllDeclaration = function(e3) {
    return (0, n2.default)({ type: "DeclareExportAllDeclaration", source: e3 });
  }, t2.declareExportDeclaration = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "DeclareExportDeclaration", declaration: e3, specifiers: t3, source: r3 });
  }, t2.declareFunction = function(e3) {
    return (0, n2.default)({ type: "DeclareFunction", id: e3 });
  }, t2.declareInterface = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "DeclareInterface", id: e3, typeParameters: t3, extends: r3, body: s3 });
  }, t2.declareModule = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "DeclareModule", id: e3, body: t3, kind: r3 });
  }, t2.declareModuleExports = function(e3) {
    return (0, n2.default)({ type: "DeclareModuleExports", typeAnnotation: e3 });
  }, t2.declareOpaqueType = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "DeclareOpaqueType", id: e3, typeParameters: t3, supertype: r3 });
  }, t2.declareTypeAlias = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0;
    return (0, n2.default)({ type: "DeclareTypeAlias", id: e3, typeParameters: t3, right: r3 });
  }, t2.declareVariable = function(e3) {
    return (0, n2.default)({ type: "DeclareVariable", id: e3 });
  }, t2.declaredPredicate = function(e3) {
    return (0, n2.default)({ type: "DeclaredPredicate", value: e3 });
  }, t2.decorator = function(e3) {
    return (0, n2.default)({ type: "Decorator", expression: e3 });
  }, t2.directive = function(e3) {
    return (0, n2.default)({ type: "Directive", value: e3 });
  }, t2.directiveLiteral = function(e3) {
    return (0, n2.default)({ type: "DirectiveLiteral", value: e3 });
  }, t2.doExpression = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return (0, n2.default)({ type: "DoExpression", body: e3, async: t3 });
  }, t2.doWhileStatement = function(e3, t3) {
    return (0, n2.default)({ type: "DoWhileStatement", test: e3, body: t3 });
  }, t2.emptyStatement = function() {
    return { type: "EmptyStatement" };
  }, t2.emptyTypeAnnotation = function() {
    return { type: "EmptyTypeAnnotation" };
  }, t2.enumBooleanBody = function(e3) {
    return (0, n2.default)({ type: "EnumBooleanBody", members: e3, explicitType: null, hasUnknownMembers: null });
  }, t2.enumBooleanMember = function(e3) {
    return (0, n2.default)({ type: "EnumBooleanMember", id: e3, init: null });
  }, t2.enumDeclaration = function(e3, t3) {
    return (0, n2.default)({ type: "EnumDeclaration", id: e3, body: t3 });
  }, t2.enumDefaultedMember = function(e3) {
    return (0, n2.default)({ type: "EnumDefaultedMember", id: e3 });
  }, t2.enumNumberBody = function(e3) {
    return (0, n2.default)({ type: "EnumNumberBody", members: e3, explicitType: null, hasUnknownMembers: null });
  }, t2.enumNumberMember = function(e3, t3) {
    return (0, n2.default)({ type: "EnumNumberMember", id: e3, init: t3 });
  }, t2.enumStringBody = function(e3) {
    return (0, n2.default)({ type: "EnumStringBody", members: e3, explicitType: null, hasUnknownMembers: null });
  }, t2.enumStringMember = function(e3, t3) {
    return (0, n2.default)({ type: "EnumStringMember", id: e3, init: t3 });
  }, t2.enumSymbolBody = function(e3) {
    return (0, n2.default)({ type: "EnumSymbolBody", members: e3, hasUnknownMembers: null });
  }, t2.existsTypeAnnotation = function() {
    return { type: "ExistsTypeAnnotation" };
  }, t2.exportAllDeclaration = function(e3) {
    return (0, n2.default)({ type: "ExportAllDeclaration", source: e3 });
  }, t2.exportDefaultDeclaration = function(e3) {
    return (0, n2.default)({ type: "ExportDefaultDeclaration", declaration: e3 });
  }, t2.exportDefaultSpecifier = function(e3) {
    return (0, n2.default)({ type: "ExportDefaultSpecifier", exported: e3 });
  }, t2.exportNamedDeclaration = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "ExportNamedDeclaration", declaration: e3, specifiers: t3, source: r3 });
  }, t2.exportNamespaceSpecifier = function(e3) {
    return (0, n2.default)({ type: "ExportNamespaceSpecifier", exported: e3 });
  }, t2.exportSpecifier = function(e3, t3) {
    return (0, n2.default)({ type: "ExportSpecifier", local: e3, exported: t3 });
  }, t2.expressionStatement = function(e3) {
    return (0, n2.default)({ type: "ExpressionStatement", expression: e3 });
  }, t2.file = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "File", program: e3, comments: t3, tokens: r3 });
  }, t2.forInStatement = function(e3, t3, r3) {
    return (0, n2.default)({ type: "ForInStatement", left: e3, right: t3, body: r3 });
  }, t2.forOfStatement = function(e3, t3, r3) {
    let s3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    return (0, n2.default)({ type: "ForOfStatement", left: e3, right: t3, body: r3, await: s3 });
  }, t2.forStatement = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "ForStatement", init: e3, test: t3, update: r3, body: s3 });
  }, t2.functionDeclaration = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    return (0, n2.default)({ type: "FunctionDeclaration", id: e3, params: t3, body: r3, generator: s3, async: i3 });
  }, t2.functionExpression = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    return (0, n2.default)({ type: "FunctionExpression", id: e3, params: t3, body: r3, generator: s3, async: i3 });
  }, t2.functionTypeAnnotation = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "FunctionTypeAnnotation", typeParameters: e3, params: t3, rest: r3, returnType: s3 });
  }, t2.functionTypeParam = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0;
    return (0, n2.default)({ type: "FunctionTypeParam", name: e3, typeAnnotation: t3 });
  }, t2.genericTypeAnnotation = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "GenericTypeAnnotation", id: e3, typeParameters: t3 });
  }, t2.identifier = function(e3) {
    return (0, n2.default)({ type: "Identifier", name: e3 });
  }, t2.ifStatement = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "IfStatement", test: e3, consequent: t3, alternate: r3 });
  }, t2.import = function() {
    return { type: "Import" };
  }, t2.importAttribute = function(e3, t3) {
    return (0, n2.default)({ type: "ImportAttribute", key: e3, value: t3 });
  }, t2.importDeclaration = function(e3, t3) {
    return (0, n2.default)({ type: "ImportDeclaration", specifiers: e3, source: t3 });
  }, t2.importDefaultSpecifier = function(e3) {
    return (0, n2.default)({ type: "ImportDefaultSpecifier", local: e3 });
  }, t2.importExpression = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "ImportExpression", source: e3, options: t3 });
  }, t2.importNamespaceSpecifier = function(e3) {
    return (0, n2.default)({ type: "ImportNamespaceSpecifier", local: e3 });
  }, t2.importSpecifier = function(e3, t3) {
    return (0, n2.default)({ type: "ImportSpecifier", local: e3, imported: t3 });
  }, t2.indexedAccessType = function(e3, t3) {
    return (0, n2.default)({ type: "IndexedAccessType", objectType: e3, indexType: t3 });
  }, t2.inferredPredicate = function() {
    return { type: "InferredPredicate" };
  }, t2.interfaceDeclaration = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "InterfaceDeclaration", id: e3, typeParameters: t3, extends: r3, body: s3 });
  }, t2.interfaceExtends = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "InterfaceExtends", id: e3, typeParameters: t3 });
  }, t2.interfaceTypeAnnotation = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0;
    return (0, n2.default)({ type: "InterfaceTypeAnnotation", extends: e3, body: t3 });
  }, t2.interpreterDirective = function(e3) {
    return (0, n2.default)({ type: "InterpreterDirective", value: e3 });
  }, t2.intersectionTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "IntersectionTypeAnnotation", types: e3 });
  }, t2.jSXAttribute = t2.jsxAttribute = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "JSXAttribute", name: e3, value: t3 });
  }, t2.jSXClosingElement = t2.jsxClosingElement = function(e3) {
    return (0, n2.default)({ type: "JSXClosingElement", name: e3 });
  }, t2.jSXClosingFragment = t2.jsxClosingFragment = function() {
    return { type: "JSXClosingFragment" };
  }, t2.jSXElement = t2.jsxElement = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "JSXElement", openingElement: e3, closingElement: t3, children: r3, selfClosing: s3 });
  }, t2.jSXEmptyExpression = t2.jsxEmptyExpression = function() {
    return { type: "JSXEmptyExpression" };
  }, t2.jSXExpressionContainer = t2.jsxExpressionContainer = function(e3) {
    return (0, n2.default)({ type: "JSXExpressionContainer", expression: e3 });
  }, t2.jSXFragment = t2.jsxFragment = function(e3, t3, r3) {
    return (0, n2.default)({ type: "JSXFragment", openingFragment: e3, closingFragment: t3, children: r3 });
  }, t2.jSXIdentifier = t2.jsxIdentifier = function(e3) {
    return (0, n2.default)({ type: "JSXIdentifier", name: e3 });
  }, t2.jSXMemberExpression = t2.jsxMemberExpression = function(e3, t3) {
    return (0, n2.default)({ type: "JSXMemberExpression", object: e3, property: t3 });
  }, t2.jSXNamespacedName = t2.jsxNamespacedName = function(e3, t3) {
    return (0, n2.default)({ type: "JSXNamespacedName", namespace: e3, name: t3 });
  }, t2.jSXOpeningElement = t2.jsxOpeningElement = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return (0, n2.default)({ type: "JSXOpeningElement", name: e3, attributes: t3, selfClosing: r3 });
  }, t2.jSXOpeningFragment = t2.jsxOpeningFragment = function() {
    return { type: "JSXOpeningFragment" };
  }, t2.jSXSpreadAttribute = t2.jsxSpreadAttribute = function(e3) {
    return (0, n2.default)({ type: "JSXSpreadAttribute", argument: e3 });
  }, t2.jSXSpreadChild = t2.jsxSpreadChild = function(e3) {
    return (0, n2.default)({ type: "JSXSpreadChild", expression: e3 });
  }, t2.jSXText = t2.jsxText = function(e3) {
    return (0, n2.default)({ type: "JSXText", value: e3 });
  }, t2.labeledStatement = function(e3, t3) {
    return (0, n2.default)({ type: "LabeledStatement", label: e3, body: t3 });
  }, t2.logicalExpression = function(e3, t3, r3) {
    return (0, n2.default)({ type: "LogicalExpression", operator: e3, left: t3, right: r3 });
  }, t2.memberExpression = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "MemberExpression", object: e3, property: t3, computed: r3, optional: s3 });
  }, t2.metaProperty = function(e3, t3) {
    return (0, n2.default)({ type: "MetaProperty", meta: e3, property: t3 });
  }, t2.mixedTypeAnnotation = function() {
    return { type: "MixedTypeAnnotation" };
  }, t2.moduleExpression = function(e3) {
    return (0, n2.default)({ type: "ModuleExpression", body: e3 });
  }, t2.newExpression = function(e3, t3) {
    return (0, n2.default)({ type: "NewExpression", callee: e3, arguments: t3 });
  }, t2.noop = function() {
    return { type: "Noop" };
  }, t2.nullLiteral = function() {
    return { type: "NullLiteral" };
  }, t2.nullLiteralTypeAnnotation = function() {
    return { type: "NullLiteralTypeAnnotation" };
  }, t2.nullableTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "NullableTypeAnnotation", typeAnnotation: e3 });
  }, t2.numberLiteral = function(e3) {
    return (0, s2.default)("NumberLiteral", "NumericLiteral", "The node type "), i2(e3);
  }, t2.numberLiteralTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "NumberLiteralTypeAnnotation", value: e3 });
  }, t2.numberTypeAnnotation = function() {
    return { type: "NumberTypeAnnotation" };
  }, t2.numericLiteral = i2, t2.objectExpression = function(e3) {
    return (0, n2.default)({ type: "ObjectExpression", properties: e3 });
  }, t2.objectMethod = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "method", t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 ? arguments[3] : void 0, i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o3 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5], a3 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
    return (0, n2.default)({ type: "ObjectMethod", kind: e3, key: t3, params: r3, body: s3, computed: i3, generator: o3, async: a3 });
  }, t2.objectPattern = function(e3) {
    return (0, n2.default)({ type: "ObjectPattern", properties: e3 });
  }, t2.objectProperty = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
    return (0, n2.default)({ type: "ObjectProperty", key: e3, value: t3, computed: r3, shorthand: s3, decorators: i3 });
  }, t2.objectTypeAnnotation = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    return (0, n2.default)({ type: "ObjectTypeAnnotation", properties: e3, indexers: t3, callProperties: r3, internalSlots: s3, exact: i3 });
  }, t2.objectTypeCallProperty = function(e3) {
    return (0, n2.default)({ type: "ObjectTypeCallProperty", value: e3, static: null });
  }, t2.objectTypeIndexer = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "ObjectTypeIndexer", id: e3, key: t3, value: r3, variance: s3, static: null });
  }, t2.objectTypeInternalSlot = function(e3, t3, r3, s3, i3) {
    return (0, n2.default)({ type: "ObjectTypeInternalSlot", id: e3, value: t3, optional: r3, static: s3, method: i3 });
  }, t2.objectTypeProperty = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "ObjectTypeProperty", key: e3, value: t3, variance: r3, kind: null, method: null, optional: null, proto: null, static: null });
  }, t2.objectTypeSpreadProperty = function(e3) {
    return (0, n2.default)({ type: "ObjectTypeSpreadProperty", argument: e3 });
  }, t2.opaqueType = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "OpaqueType", id: e3, typeParameters: t3, supertype: r3, impltype: s3 });
  }, t2.optionalCallExpression = function(e3, t3, r3) {
    return (0, n2.default)({ type: "OptionalCallExpression", callee: e3, arguments: t3, optional: r3 });
  }, t2.optionalIndexedAccessType = function(e3, t3) {
    return (0, n2.default)({ type: "OptionalIndexedAccessType", objectType: e3, indexType: t3, optional: null });
  }, t2.optionalMemberExpression = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "OptionalMemberExpression", object: e3, property: t3, computed: r3, optional: s3 });
  }, t2.parenthesizedExpression = function(e3) {
    return (0, n2.default)({ type: "ParenthesizedExpression", expression: e3 });
  }, t2.pipelineBareFunction = function(e3) {
    return (0, n2.default)({ type: "PipelineBareFunction", callee: e3 });
  }, t2.pipelinePrimaryTopicReference = function() {
    return { type: "PipelinePrimaryTopicReference" };
  }, t2.pipelineTopicExpression = function(e3) {
    return (0, n2.default)({ type: "PipelineTopicExpression", expression: e3 });
  }, t2.placeholder = function(e3, t3) {
    return (0, n2.default)({ type: "Placeholder", expectedNode: e3, name: t3 });
  }, t2.privateName = function(e3) {
    return (0, n2.default)({ type: "PrivateName", id: e3 });
  }, t2.program = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "script", s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "Program", body: e3, directives: t3, sourceType: r3, interpreter: s3, sourceFile: null });
  }, t2.qualifiedTypeIdentifier = function(e3, t3) {
    return (0, n2.default)({ type: "QualifiedTypeIdentifier", id: e3, qualification: t3 });
  }, t2.recordExpression = function(e3) {
    return (0, n2.default)({ type: "RecordExpression", properties: e3 });
  }, t2.regExpLiteral = o2, t2.regexLiteral = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    return (0, s2.default)("RegexLiteral", "RegExpLiteral", "The node type "), o2(e3, t3);
  }, t2.restElement = a2, t2.restProperty = function(e3) {
    return (0, s2.default)("RestProperty", "RestElement", "The node type "), a2(e3);
  }, t2.returnStatement = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
    return (0, n2.default)({ type: "ReturnStatement", argument: e3 });
  }, t2.sequenceExpression = function(e3) {
    return (0, n2.default)({ type: "SequenceExpression", expressions: e3 });
  }, t2.spreadElement = l, t2.spreadProperty = function(e3) {
    return (0, s2.default)("SpreadProperty", "SpreadElement", "The node type "), l(e3);
  }, t2.staticBlock = function(e3) {
    return (0, n2.default)({ type: "StaticBlock", body: e3 });
  }, t2.stringLiteral = function(e3) {
    return (0, n2.default)({ type: "StringLiteral", value: e3 });
  }, t2.stringLiteralTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "StringLiteralTypeAnnotation", value: e3 });
  }, t2.stringTypeAnnotation = function() {
    return { type: "StringTypeAnnotation" };
  }, t2.super = function() {
    return { type: "Super" };
  }, t2.switchCase = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0;
    return (0, n2.default)({ type: "SwitchCase", test: e3, consequent: t3 });
  }, t2.switchStatement = function(e3, t3) {
    return (0, n2.default)({ type: "SwitchStatement", discriminant: e3, cases: t3 });
  }, t2.symbolTypeAnnotation = function() {
    return { type: "SymbolTypeAnnotation" };
  }, t2.taggedTemplateExpression = function(e3, t3) {
    return (0, n2.default)({ type: "TaggedTemplateExpression", tag: e3, quasi: t3 });
  }, t2.templateElement = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return (0, n2.default)({ type: "TemplateElement", value: e3, tail: t3 });
  }, t2.templateLiteral = function(e3, t3) {
    return (0, n2.default)({ type: "TemplateLiteral", quasis: e3, expressions: t3 });
  }, t2.thisExpression = function() {
    return { type: "ThisExpression" };
  }, t2.thisTypeAnnotation = function() {
    return { type: "ThisTypeAnnotation" };
  }, t2.throwStatement = function(e3) {
    return (0, n2.default)({ type: "ThrowStatement", argument: e3 });
  }, t2.topicReference = function() {
    return { type: "TopicReference" };
  }, t2.tryStatement = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TryStatement", block: e3, handler: t3, finalizer: r3 });
  }, t2.tSAnyKeyword = t2.tsAnyKeyword = function() {
    return { type: "TSAnyKeyword" };
  }, t2.tSArrayType = t2.tsArrayType = function(e3) {
    return (0, n2.default)({ type: "TSArrayType", elementType: e3 });
  }, t2.tSAsExpression = t2.tsAsExpression = function(e3, t3) {
    return (0, n2.default)({ type: "TSAsExpression", expression: e3, typeAnnotation: t3 });
  }, t2.tSBigIntKeyword = t2.tsBigIntKeyword = function() {
    return { type: "TSBigIntKeyword" };
  }, t2.tSBooleanKeyword = t2.tsBooleanKeyword = function() {
    return { type: "TSBooleanKeyword" };
  }, t2.tSCallSignatureDeclaration = t2.tsCallSignatureDeclaration = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSCallSignatureDeclaration", typeParameters: e3, parameters: t3, typeAnnotation: r3 });
  }, t2.tSConditionalType = t2.tsConditionalType = function(e3, t3, r3, s3) {
    return (0, n2.default)({ type: "TSConditionalType", checkType: e3, extendsType: t3, trueType: r3, falseType: s3 });
  }, t2.tSConstructSignatureDeclaration = t2.tsConstructSignatureDeclaration = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSConstructSignatureDeclaration", typeParameters: e3, parameters: t3, typeAnnotation: r3 });
  }, t2.tSConstructorType = t2.tsConstructorType = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSConstructorType", typeParameters: e3, parameters: t3, typeAnnotation: r3 });
  }, t2.tSDeclareFunction = t2.tsDeclareFunction = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "TSDeclareFunction", id: e3, typeParameters: t3, params: r3, returnType: s3 });
  }, t2.tSDeclareMethod = t2.tsDeclareMethod = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0, i3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
    return (0, n2.default)({ type: "TSDeclareMethod", decorators: e3, key: t3, typeParameters: r3, params: s3, returnType: i3 });
  }, t2.tSEnumDeclaration = t2.tsEnumDeclaration = function(e3, t3) {
    return (0, n2.default)({ type: "TSEnumDeclaration", id: e3, members: t3 });
  }, t2.tSEnumMember = t2.tsEnumMember = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSEnumMember", id: e3, initializer: t3 });
  }, t2.tSExportAssignment = t2.tsExportAssignment = function(e3) {
    return (0, n2.default)({ type: "TSExportAssignment", expression: e3 });
  }, t2.tSExpressionWithTypeArguments = t2.tsExpressionWithTypeArguments = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSExpressionWithTypeArguments", expression: e3, typeParameters: t3 });
  }, t2.tSExternalModuleReference = t2.tsExternalModuleReference = function(e3) {
    return (0, n2.default)({ type: "TSExternalModuleReference", expression: e3 });
  }, t2.tSFunctionType = t2.tsFunctionType = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSFunctionType", typeParameters: e3, parameters: t3, typeAnnotation: r3 });
  }, t2.tSImportEqualsDeclaration = t2.tsImportEqualsDeclaration = function(e3, t3) {
    return (0, n2.default)({ type: "TSImportEqualsDeclaration", id: e3, moduleReference: t3, isExport: null });
  }, t2.tSImportType = t2.tsImportType = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSImportType", argument: e3, qualifier: t3, typeParameters: r3 });
  }, t2.tSIndexSignature = t2.tsIndexSignature = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSIndexSignature", parameters: e3, typeAnnotation: t3 });
  }, t2.tSIndexedAccessType = t2.tsIndexedAccessType = function(e3, t3) {
    return (0, n2.default)({ type: "TSIndexedAccessType", objectType: e3, indexType: t3 });
  }, t2.tSInferType = t2.tsInferType = function(e3) {
    return (0, n2.default)({ type: "TSInferType", typeParameter: e3 });
  }, t2.tSInstantiationExpression = t2.tsInstantiationExpression = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSInstantiationExpression", expression: e3, typeParameters: t3 });
  }, t2.tSInterfaceBody = t2.tsInterfaceBody = function(e3) {
    return (0, n2.default)({ type: "TSInterfaceBody", body: e3 });
  }, t2.tSInterfaceDeclaration = t2.tsInterfaceDeclaration = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "TSInterfaceDeclaration", id: e3, typeParameters: t3, extends: r3, body: s3 });
  }, t2.tSIntersectionType = t2.tsIntersectionType = function(e3) {
    return (0, n2.default)({ type: "TSIntersectionType", types: e3 });
  }, t2.tSIntrinsicKeyword = t2.tsIntrinsicKeyword = function() {
    return { type: "TSIntrinsicKeyword" };
  }, t2.tSLiteralType = t2.tsLiteralType = function(e3) {
    return (0, n2.default)({ type: "TSLiteralType", literal: e3 });
  }, t2.tSMappedType = t2.tsMappedType = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSMappedType", typeParameter: e3, typeAnnotation: t3, nameType: r3 });
  }, t2.tSMethodSignature = t2.tsMethodSignature = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "TSMethodSignature", key: e3, typeParameters: t3, parameters: r3, typeAnnotation: s3, kind: null });
  }, t2.tSModuleBlock = t2.tsModuleBlock = function(e3) {
    return (0, n2.default)({ type: "TSModuleBlock", body: e3 });
  }, t2.tSModuleDeclaration = t2.tsModuleDeclaration = function(e3, t3) {
    return (0, n2.default)({ type: "TSModuleDeclaration", id: e3, body: t3 });
  }, t2.tSNamedTupleMember = t2.tsNamedTupleMember = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return (0, n2.default)({ type: "TSNamedTupleMember", label: e3, elementType: t3, optional: r3 });
  }, t2.tSNamespaceExportDeclaration = t2.tsNamespaceExportDeclaration = function(e3) {
    return (0, n2.default)({ type: "TSNamespaceExportDeclaration", id: e3 });
  }, t2.tSNeverKeyword = t2.tsNeverKeyword = function() {
    return { type: "TSNeverKeyword" };
  }, t2.tSNonNullExpression = t2.tsNonNullExpression = function(e3) {
    return (0, n2.default)({ type: "TSNonNullExpression", expression: e3 });
  }, t2.tSNullKeyword = t2.tsNullKeyword = function() {
    return { type: "TSNullKeyword" };
  }, t2.tSNumberKeyword = t2.tsNumberKeyword = function() {
    return { type: "TSNumberKeyword" };
  }, t2.tSObjectKeyword = t2.tsObjectKeyword = function() {
    return { type: "TSObjectKeyword" };
  }, t2.tSOptionalType = t2.tsOptionalType = function(e3) {
    return (0, n2.default)({ type: "TSOptionalType", typeAnnotation: e3 });
  }, t2.tSParameterProperty = t2.tsParameterProperty = function(e3) {
    return (0, n2.default)({ type: "TSParameterProperty", parameter: e3 });
  }, t2.tSParenthesizedType = t2.tsParenthesizedType = function(e3) {
    return (0, n2.default)({ type: "TSParenthesizedType", typeAnnotation: e3 });
  }, t2.tSPropertySignature = t2.tsPropertySignature = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSPropertySignature", key: e3, typeAnnotation: t3, kind: null });
  }, t2.tSQualifiedName = t2.tsQualifiedName = function(e3, t3) {
    return (0, n2.default)({ type: "TSQualifiedName", left: e3, right: t3 });
  }, t2.tSRestType = t2.tsRestType = function(e3) {
    return (0, n2.default)({ type: "TSRestType", typeAnnotation: e3 });
  }, t2.tSSatisfiesExpression = t2.tsSatisfiesExpression = function(e3, t3) {
    return (0, n2.default)({ type: "TSSatisfiesExpression", expression: e3, typeAnnotation: t3 });
  }, t2.tSStringKeyword = t2.tsStringKeyword = function() {
    return { type: "TSStringKeyword" };
  }, t2.tSSymbolKeyword = t2.tsSymbolKeyword = function() {
    return { type: "TSSymbolKeyword" };
  }, t2.tSThisType = t2.tsThisType = function() {
    return { type: "TSThisType" };
  }, t2.tSTupleType = t2.tsTupleType = function(e3) {
    return (0, n2.default)({ type: "TSTupleType", elementTypes: e3 });
  }, t2.tSTypeAliasDeclaration = t2.tsTypeAliasDeclaration = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0;
    return (0, n2.default)({ type: "TSTypeAliasDeclaration", id: e3, typeParameters: t3, typeAnnotation: r3 });
  }, t2.tSTypeAnnotation = t2.tsTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "TSTypeAnnotation", typeAnnotation: e3 });
  }, t2.tSTypeAssertion = t2.tsTypeAssertion = function(e3, t3) {
    return (0, n2.default)({ type: "TSTypeAssertion", typeAnnotation: e3, expression: t3 });
  }, t2.tSTypeLiteral = t2.tsTypeLiteral = function(e3) {
    return (0, n2.default)({ type: "TSTypeLiteral", members: e3 });
  }, t2.tSTypeOperator = t2.tsTypeOperator = function(e3) {
    return (0, n2.default)({ type: "TSTypeOperator", typeAnnotation: e3, operator: null });
  }, t2.tSTypeParameter = t2.tsTypeParameter = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0;
    return (0, n2.default)({ type: "TSTypeParameter", constraint: e3, default: t3, name: r3 });
  }, t2.tSTypeParameterDeclaration = t2.tsTypeParameterDeclaration = function(e3) {
    return (0, n2.default)({ type: "TSTypeParameterDeclaration", params: e3 });
  }, t2.tSTypeParameterInstantiation = t2.tsTypeParameterInstantiation = function(e3) {
    return (0, n2.default)({ type: "TSTypeParameterInstantiation", params: e3 });
  }, t2.tSTypePredicate = t2.tsTypePredicate = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSTypePredicate", parameterName: e3, typeAnnotation: t3, asserts: r3 });
  }, t2.tSTypeQuery = t2.tsTypeQuery = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSTypeQuery", exprName: e3, typeParameters: t3 });
  }, t2.tSTypeReference = t2.tsTypeReference = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSTypeReference", typeName: e3, typeParameters: t3 });
  }, t2.tSUndefinedKeyword = t2.tsUndefinedKeyword = function() {
    return { type: "TSUndefinedKeyword" };
  }, t2.tSUnionType = t2.tsUnionType = function(e3) {
    return (0, n2.default)({ type: "TSUnionType", types: e3 });
  }, t2.tSUnknownKeyword = t2.tsUnknownKeyword = function() {
    return { type: "TSUnknownKeyword" };
  }, t2.tSVoidKeyword = t2.tsVoidKeyword = function() {
    return { type: "TSVoidKeyword" };
  }, t2.tupleExpression = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return (0, n2.default)({ type: "TupleExpression", elements: e3 });
  }, t2.tupleTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "TupleTypeAnnotation", types: e3 });
  }, t2.typeAlias = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0;
    return (0, n2.default)({ type: "TypeAlias", id: e3, typeParameters: t3, right: r3 });
  }, t2.typeAnnotation = function(e3) {
    return (0, n2.default)({ type: "TypeAnnotation", typeAnnotation: e3 });
  }, t2.typeCastExpression = function(e3, t3) {
    return (0, n2.default)({ type: "TypeCastExpression", expression: e3, typeAnnotation: t3 });
  }, t2.typeParameter = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TypeParameter", bound: e3, default: t3, variance: r3, name: null });
  }, t2.typeParameterDeclaration = function(e3) {
    return (0, n2.default)({ type: "TypeParameterDeclaration", params: e3 });
  }, t2.typeParameterInstantiation = function(e3) {
    return (0, n2.default)({ type: "TypeParameterInstantiation", params: e3 });
  }, t2.typeofTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "TypeofTypeAnnotation", argument: e3 });
  }, t2.unaryExpression = function(e3, t3) {
    let r3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    return (0, n2.default)({ type: "UnaryExpression", operator: e3, argument: t3, prefix: r3 });
  }, t2.unionTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "UnionTypeAnnotation", types: e3 });
  }, t2.updateExpression = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return (0, n2.default)({ type: "UpdateExpression", operator: e3, argument: t3, prefix: r3 });
  }, t2.v8IntrinsicIdentifier = function(e3) {
    return (0, n2.default)({ type: "V8IntrinsicIdentifier", name: e3 });
  }, t2.variableDeclaration = function(e3, t3) {
    return (0, n2.default)({ type: "VariableDeclaration", kind: e3, declarations: t3 });
  }, t2.variableDeclarator = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "VariableDeclarator", id: e3, init: t3 });
  }, t2.variance = function(e3) {
    return (0, n2.default)({ type: "Variance", kind: e3 });
  }, t2.voidTypeAnnotation = function() {
    return { type: "VoidTypeAnnotation" };
  }, t2.whileStatement = function(e3, t3) {
    return (0, n2.default)({ type: "WhileStatement", test: e3, body: t3 });
  }, t2.withStatement = function(e3, t3) {
    return (0, n2.default)({ type: "WithStatement", object: e3, body: t3 });
  }, t2.yieldExpression = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return (0, n2.default)({ type: "YieldExpression", argument: e3, delegate: t3 });
  };
  var n2 = r2(352), s2 = r2(58);
  function i2(e3) {
    return (0, n2.default)({ type: "NumericLiteral", value: e3 });
  }
  function o2(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    return (0, n2.default)({ type: "RegExpLiteral", pattern: e3, flags: t3 });
  }
  function a2(e3) {
    return (0, n2.default)({ type: "RestElement", argument: e3 });
  }
  function l(e3) {
    return (0, n2.default)({ type: "SpreadElement", argument: e3 });
  }
}, function(e2, t2, r2) {
  var n2 = function(e3) {
    return e3 && e3.Math === Math && e3;
  };
  e2.exports = n2("object" == typeof globalThis && globalThis) || n2("object" == typeof window && window) || n2("object" == typeof self && self) || n2("object" == typeof r2.g && r2.g) || n2("object" == typeof this && this) || /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")();
}, (e2) => {
  var t2 = "object" == typeof document && document.all;
  e2.exports = void 0 === t2 && void 0 !== t2 ? function(e3) {
    return "function" == typeof e3 || e3 === t2;
  } : function(e3) {
    return "function" == typeof e3;
  };
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = (e3, t3, r3) => new n2(e3, r3).compare(new n2(t3, r3));
}, (e2, t2, r2) => {
  class n2 {
    constructor(e3, t3) {
      if (t3 = i2(t3), e3 instanceof n2) return e3.loose === !!t3.loose && e3.includePrerelease === !!t3.includePrerelease ? e3 : new n2(e3.raw, t3);
      if (e3 instanceof o2) return this.raw = e3.value, this.set = [[e3]], this.format(), this;
      if (this.options = t3, this.loose = !!t3.loose, this.includePrerelease = !!t3.includePrerelease, this.raw = e3.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((e4) => this.parseRange(e4.trim())).filter((e4) => e4.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const e4 = this.set[0];
        if (this.set = this.set.filter((e5) => !y(e5[0])), 0 === this.set.length) this.set = [e4];
        else if (this.set.length > 1) {
          for (const e5 of this.set) if (1 === e5.length && g(e5[0])) {
            this.set = [e5];
            break;
          }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((e3) => e3.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(e3) {
      const t3 = ((this.options.includePrerelease && h) | (this.options.loose && m)) + ":" + e3, r3 = s2.get(t3);
      if (r3) return r3;
      const n3 = this.options.loose, i3 = n3 ? c[u.HYPHENRANGELOOSE] : c[u.HYPHENRANGE];
      e3 = e3.replace(i3, I(this.options.includePrerelease)), a2("hyphen replace", e3), e3 = e3.replace(c[u.COMPARATORTRIM], p), a2("comparator trim", e3), e3 = e3.replace(c[u.TILDETRIM], d), a2("tilde trim", e3), e3 = e3.replace(c[u.CARETTRIM], f), a2("caret trim", e3);
      let l2 = e3.split(" ").map((e4) => v(e4, this.options)).join(" ").split(/\s+/).map((e4) => O(e4, this.options));
      n3 && (l2 = l2.filter((e4) => (a2("loose invalid filter", e4, this.options), !!e4.match(c[u.COMPARATORLOOSE])))), a2("range list", l2);
      const g2 = /* @__PURE__ */ new Map(), b2 = l2.map((e4) => new o2(e4, this.options));
      for (const e4 of b2) {
        if (y(e4)) return [e4];
        g2.set(e4.value, e4);
      }
      g2.size > 1 && g2.has("") && g2.delete("");
      const E2 = [...g2.values()];
      return s2.set(t3, E2), E2;
    }
    intersects(e3, t3) {
      if (!(e3 instanceof n2)) throw new TypeError("a Range is required");
      return this.set.some((r3) => b(r3, t3) && e3.set.some((e4) => b(e4, t3) && r3.every((r4) => e4.every((e5) => r4.intersects(e5, t3)))));
    }
    test(e3) {
      if (!e3) return false;
      if ("string" == typeof e3) try {
        e3 = new l(e3, this.options);
      } catch (e4) {
        return false;
      }
      for (let t3 = 0; t3 < this.set.length; t3++) if (_(this.set[t3], e3, this.options)) return true;
      return false;
    }
  }
  e2.exports = n2;
  const s2 = new (r2(132))({ max: 1e3 }), i2 = r2(75), o2 = r2(50), a2 = r2(48), l = r2(3), { safeRe: c, t: u, comparatorTrimReplace: p, tildeTrimReplace: d, caretTrimReplace: f } = r2(34), { FLAG_INCLUDE_PRERELEASE: h, FLAG_LOOSE: m } = r2(47), y = (e3) => "<0.0.0-0" === e3.value, g = (e3) => "" === e3.value, b = (e3, t3) => {
    let r3 = true;
    const n3 = e3.slice();
    let s3 = n3.pop();
    for (; r3 && n3.length; ) r3 = n3.every((e4) => s3.intersects(e4, t3)), s3 = n3.pop();
    return r3;
  }, v = (e3, t3) => (a2("comp", e3, t3), e3 = T(e3, t3), a2("caret", e3), e3 = S(e3, t3), a2("tildes", e3), e3 = P(e3, t3), a2("xrange", e3), e3 = C(e3, t3), a2("stars", e3), e3), E = (e3) => !e3 || "x" === e3.toLowerCase() || "*" === e3, S = (e3, t3) => e3.trim().split(/\s+/).map((e4) => x(e4, t3)).join(" "), x = (e3, t3) => {
    const r3 = t3.loose ? c[u.TILDELOOSE] : c[u.TILDE];
    return e3.replace(r3, (t4, r4, n3, s3, i3) => {
      let o3;
      return a2("tilde", e3, t4, r4, n3, s3, i3), E(r4) ? o3 = "" : E(n3) ? o3 = `>=${r4}.0.0 <${+r4 + 1}.0.0-0` : E(s3) ? o3 = `>=${r4}.${n3}.0 <${r4}.${+n3 + 1}.0-0` : i3 ? (a2("replaceTilde pr", i3), o3 = `>=${r4}.${n3}.${s3}-${i3} <${r4}.${+n3 + 1}.0-0`) : o3 = `>=${r4}.${n3}.${s3} <${r4}.${+n3 + 1}.0-0`, a2("tilde return", o3), o3;
    });
  }, T = (e3, t3) => e3.trim().split(/\s+/).map((e4) => w(e4, t3)).join(" "), w = (e3, t3) => {
    a2("caret", e3, t3);
    const r3 = t3.loose ? c[u.CARETLOOSE] : c[u.CARET], n3 = t3.includePrerelease ? "-0" : "";
    return e3.replace(r3, (t4, r4, s3, i3, o3) => {
      let l2;
      return a2("caret", e3, t4, r4, s3, i3, o3), E(r4) ? l2 = "" : E(s3) ? l2 = `>=${r4}.0.0${n3} <${+r4 + 1}.0.0-0` : E(i3) ? l2 = "0" === r4 ? `>=${r4}.${s3}.0${n3} <${r4}.${+s3 + 1}.0-0` : `>=${r4}.${s3}.0${n3} <${+r4 + 1}.0.0-0` : o3 ? (a2("replaceCaret pr", o3), l2 = "0" === r4 ? "0" === s3 ? `>=${r4}.${s3}.${i3}-${o3} <${r4}.${s3}.${+i3 + 1}-0` : `>=${r4}.${s3}.${i3}-${o3} <${r4}.${+s3 + 1}.0-0` : `>=${r4}.${s3}.${i3}-${o3} <${+r4 + 1}.0.0-0`) : (a2("no pr"), l2 = "0" === r4 ? "0" === s3 ? `>=${r4}.${s3}.${i3}${n3} <${r4}.${s3}.${+i3 + 1}-0` : `>=${r4}.${s3}.${i3}${n3} <${r4}.${+s3 + 1}.0-0` : `>=${r4}.${s3}.${i3} <${+r4 + 1}.0.0-0`), a2("caret return", l2), l2;
    });
  }, P = (e3, t3) => (a2("replaceXRanges", e3, t3), e3.split(/\s+/).map((e4) => A(e4, t3)).join(" ")), A = (e3, t3) => {
    e3 = e3.trim();
    const r3 = t3.loose ? c[u.XRANGELOOSE] : c[u.XRANGE];
    return e3.replace(r3, (r4, n3, s3, i3, o3, l2) => {
      a2("xRange", e3, r4, n3, s3, i3, o3, l2);
      const c2 = E(s3), u2 = c2 || E(i3), p2 = u2 || E(o3), d2 = p2;
      return "=" === n3 && d2 && (n3 = ""), l2 = t3.includePrerelease ? "-0" : "", c2 ? r4 = ">" === n3 || "<" === n3 ? "<0.0.0-0" : "*" : n3 && d2 ? (u2 && (i3 = 0), o3 = 0, ">" === n3 ? (n3 = ">=", u2 ? (s3 = +s3 + 1, i3 = 0, o3 = 0) : (i3 = +i3 + 1, o3 = 0)) : "<=" === n3 && (n3 = "<", u2 ? s3 = +s3 + 1 : i3 = +i3 + 1), "<" === n3 && (l2 = "-0"), r4 = `${n3 + s3}.${i3}.${o3}${l2}`) : u2 ? r4 = `>=${s3}.0.0${l2} <${+s3 + 1}.0.0-0` : p2 && (r4 = `>=${s3}.${i3}.0${l2} <${s3}.${+i3 + 1}.0-0`), a2("xRange return", r4), r4;
    });
  }, C = (e3, t3) => (a2("replaceStars", e3, t3), e3.trim().replace(c[u.STAR], "")), O = (e3, t3) => (a2("replaceGTE0", e3, t3), e3.trim().replace(c[t3.includePrerelease ? u.GTE0PRE : u.GTE0], "")), I = (e3) => (t3, r3, n3, s3, i3, o3, a3, l2, c2, u2, p2, d2, f2) => `${r3 = E(n3) ? "" : E(s3) ? `>=${n3}.0.0${e3 ? "-0" : ""}` : E(i3) ? `>=${n3}.${s3}.0${e3 ? "-0" : ""}` : o3 ? `>=${r3}` : `>=${r3}${e3 ? "-0" : ""}`} ${l2 = E(c2) ? "" : E(u2) ? `<${+c2 + 1}.0.0-0` : E(p2) ? `<${c2}.${+u2 + 1}.0-0` : d2 ? `<=${c2}.${u2}.${p2}-${d2}` : e3 ? `<${c2}.${u2}.${+p2 + 1}-0` : `<=${l2}`}`.trim(), _ = (e3, t3, r3) => {
    for (let r4 = 0; r4 < e3.length; r4++) if (!e3[r4].test(t3)) return false;
    if (t3.prerelease.length && !r3.includePrerelease) {
      for (let r4 = 0; r4 < e3.length; r4++) if (a2(e3[r4].semver), e3[r4].semver !== o2.ANY && e3[r4].semver.prerelease.length > 0) {
        const n3 = e3[r4].semver;
        if (n3.major === t3.major && n3.minor === t3.minor && n3.patch === t3.patch) return true;
      }
      return false;
    }
    return true;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "ALIAS_KEYS", { enumerable: true, get: function() {
    return s2.ALIAS_KEYS;
  } }), Object.defineProperty(t2, "BUILDER_KEYS", { enumerable: true, get: function() {
    return s2.BUILDER_KEYS;
  } }), Object.defineProperty(t2, "DEPRECATED_ALIASES", { enumerable: true, get: function() {
    return o2.DEPRECATED_ALIASES;
  } }), Object.defineProperty(t2, "DEPRECATED_KEYS", { enumerable: true, get: function() {
    return s2.DEPRECATED_KEYS;
  } }), Object.defineProperty(t2, "FLIPPED_ALIAS_KEYS", { enumerable: true, get: function() {
    return s2.FLIPPED_ALIAS_KEYS;
  } }), Object.defineProperty(t2, "NODE_FIELDS", { enumerable: true, get: function() {
    return s2.NODE_FIELDS;
  } }), Object.defineProperty(t2, "NODE_PARENT_VALIDATIONS", { enumerable: true, get: function() {
    return s2.NODE_PARENT_VALIDATIONS;
  } }), Object.defineProperty(t2, "PLACEHOLDERS", { enumerable: true, get: function() {
    return i2.PLACEHOLDERS;
  } }), Object.defineProperty(t2, "PLACEHOLDERS_ALIAS", { enumerable: true, get: function() {
    return i2.PLACEHOLDERS_ALIAS;
  } }), Object.defineProperty(t2, "PLACEHOLDERS_FLIPPED_ALIAS", { enumerable: true, get: function() {
    return i2.PLACEHOLDERS_FLIPPED_ALIAS;
  } }), t2.TYPES = void 0, Object.defineProperty(t2, "VISITOR_KEYS", { enumerable: true, get: function() {
    return s2.VISITOR_KEYS;
  } });
  var n2 = r2(166);
  r2(167), r2(356), r2(357), r2(358), r2(359), r2(360);
  var s2 = r2(18), i2 = r2(169), o2 = r2(361);
  Object.keys(o2.DEPRECATED_ALIASES).forEach((e3) => {
    s2.FLIPPED_ALIAS_KEYS[e3] = s2.FLIPPED_ALIAS_KEYS[o2.DEPRECATED_ALIASES[e3]];
  }), n2(s2.VISITOR_KEYS), n2(s2.ALIAS_KEYS), n2(s2.FLIPPED_ALIAS_KEYS), n2(s2.NODE_FIELDS), n2(s2.BUILDER_KEYS), n2(s2.DEPRECATED_KEYS), n2(i2.PLACEHOLDERS_ALIAS), n2(i2.PLACEHOLDERS_FLIPPED_ALIAS), t2.TYPES = [].concat(Object.keys(s2.VISITOR_KEYS), Object.keys(s2.FLIPPED_ALIAS_KEYS), Object.keys(s2.DEPRECATED_KEYS));
}, (e2, t2, r2) => {
  var n2 = r2(17);
  function s2(e3) {
    if ("string" != typeof e3) throw new TypeError("Path must be a string. Received " + JSON.stringify(e3));
  }
  function i2(e3, t3) {
    for (var r3, n3 = "", s3 = 0, i3 = -1, o3 = 0, a2 = 0; a2 <= e3.length; ++a2) {
      if (a2 < e3.length) r3 = e3.charCodeAt(a2);
      else {
        if (47 === r3) break;
        r3 = 47;
      }
      if (47 === r3) {
        if (i3 === a2 - 1 || 1 === o3) ;
        else if (i3 !== a2 - 1 && 2 === o3) {
          if (n3.length < 2 || 2 !== s3 || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
            if (n3.length > 2) {
              var l = n3.lastIndexOf("/");
              if (l !== n3.length - 1) {
                -1 === l ? (n3 = "", s3 = 0) : s3 = (n3 = n3.slice(0, l)).length - 1 - n3.lastIndexOf("/"), i3 = a2, o3 = 0;
                continue;
              }
            } else if (2 === n3.length || 1 === n3.length) {
              n3 = "", s3 = 0, i3 = a2, o3 = 0;
              continue;
            }
          }
          t3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", s3 = 2);
        } else n3.length > 0 ? n3 += "/" + e3.slice(i3 + 1, a2) : n3 = e3.slice(i3 + 1, a2), s3 = a2 - i3 - 1;
        i3 = a2, o3 = 0;
      } else 46 === r3 && -1 !== o3 ? ++o3 : o3 = -1;
    }
    return n3;
  }
  var o2 = { resolve: function() {
    for (var e3, t3 = "", r3 = false, o3 = arguments.length - 1; o3 >= -1 && !r3; o3--) {
      var a2;
      o3 >= 0 ? a2 = arguments[o3] : (void 0 === e3 && (e3 = n2.cwd()), a2 = e3), s2(a2), 0 !== a2.length && (t3 = a2 + "/" + t3, r3 = 47 === a2.charCodeAt(0));
    }
    return t3 = i2(t3, !r3), r3 ? t3.length > 0 ? "/" + t3 : "/" : t3.length > 0 ? t3 : ".";
  }, normalize: function(e3) {
    if (s2(e3), 0 === e3.length) return ".";
    var t3 = 47 === e3.charCodeAt(0), r3 = 47 === e3.charCodeAt(e3.length - 1);
    return 0 !== (e3 = i2(e3, !t3)).length || t3 || (e3 = "."), e3.length > 0 && r3 && (e3 += "/"), t3 ? "/" + e3 : e3;
  }, isAbsolute: function(e3) {
    return s2(e3), e3.length > 0 && 47 === e3.charCodeAt(0);
  }, join: function() {
    if (0 === arguments.length) return ".";
    for (var e3, t3 = 0; t3 < arguments.length; ++t3) {
      var r3 = arguments[t3];
      s2(r3), r3.length > 0 && (void 0 === e3 ? e3 = r3 : e3 += "/" + r3);
    }
    return void 0 === e3 ? "." : o2.normalize(e3);
  }, relative: function(e3, t3) {
    if (s2(e3), s2(t3), e3 === t3) return "";
    if ((e3 = o2.resolve(e3)) === (t3 = o2.resolve(t3))) return "";
    for (var r3 = 1; r3 < e3.length && 47 === e3.charCodeAt(r3); ++r3) ;
    for (var n3 = e3.length, i3 = n3 - r3, a2 = 1; a2 < t3.length && 47 === t3.charCodeAt(a2); ++a2) ;
    for (var l = t3.length - a2, c = i3 < l ? i3 : l, u = -1, p = 0; p <= c; ++p) {
      if (p === c) {
        if (l > c) {
          if (47 === t3.charCodeAt(a2 + p)) return t3.slice(a2 + p + 1);
          if (0 === p) return t3.slice(a2 + p);
        } else i3 > c && (47 === e3.charCodeAt(r3 + p) ? u = p : 0 === p && (u = 0));
        break;
      }
      var d = e3.charCodeAt(r3 + p);
      if (d !== t3.charCodeAt(a2 + p)) break;
      47 === d && (u = p);
    }
    var f = "";
    for (p = r3 + u + 1; p <= n3; ++p) p !== n3 && 47 !== e3.charCodeAt(p) || (0 === f.length ? f += ".." : f += "/..");
    return f.length > 0 ? f + t3.slice(a2 + u) : (a2 += u, 47 === t3.charCodeAt(a2) && ++a2, t3.slice(a2));
  }, _makeLong: function(e3) {
    return e3;
  }, dirname: function(e3) {
    if (s2(e3), 0 === e3.length) return ".";
    for (var t3 = e3.charCodeAt(0), r3 = 47 === t3, n3 = -1, i3 = true, o3 = e3.length - 1; o3 >= 1; --o3) if (47 === (t3 = e3.charCodeAt(o3))) {
      if (!i3) {
        n3 = o3;
        break;
      }
    } else i3 = false;
    return -1 === n3 ? r3 ? "/" : "." : r3 && 1 === n3 ? "//" : e3.slice(0, n3);
  }, basename: function(e3, t3) {
    if (void 0 !== t3 && "string" != typeof t3) throw new TypeError('"ext" argument must be a string');
    s2(e3);
    var r3, n3 = 0, i3 = -1, o3 = true;
    if (void 0 !== t3 && t3.length > 0 && t3.length <= e3.length) {
      if (t3.length === e3.length && t3 === e3) return "";
      var a2 = t3.length - 1, l = -1;
      for (r3 = e3.length - 1; r3 >= 0; --r3) {
        var c = e3.charCodeAt(r3);
        if (47 === c) {
          if (!o3) {
            n3 = r3 + 1;
            break;
          }
        } else -1 === l && (o3 = false, l = r3 + 1), a2 >= 0 && (c === t3.charCodeAt(a2) ? -1 == --a2 && (i3 = r3) : (a2 = -1, i3 = l));
      }
      return n3 === i3 ? i3 = l : -1 === i3 && (i3 = e3.length), e3.slice(n3, i3);
    }
    for (r3 = e3.length - 1; r3 >= 0; --r3) if (47 === e3.charCodeAt(r3)) {
      if (!o3) {
        n3 = r3 + 1;
        break;
      }
    } else -1 === i3 && (o3 = false, i3 = r3 + 1);
    return -1 === i3 ? "" : e3.slice(n3, i3);
  }, extname: function(e3) {
    s2(e3);
    for (var t3 = -1, r3 = 0, n3 = -1, i3 = true, o3 = 0, a2 = e3.length - 1; a2 >= 0; --a2) {
      var l = e3.charCodeAt(a2);
      if (47 !== l) -1 === n3 && (i3 = false, n3 = a2 + 1), 46 === l ? -1 === t3 ? t3 = a2 : 1 !== o3 && (o3 = 1) : -1 !== t3 && (o3 = -1);
      else if (!i3) {
        r3 = a2 + 1;
        break;
      }
    }
    return -1 === t3 || -1 === n3 || 0 === o3 || 1 === o3 && t3 === n3 - 1 && t3 === r3 + 1 ? "" : e3.slice(t3, n3);
  }, format: function(e3) {
    if (null === e3 || "object" != typeof e3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e3);
    return function(e4, t3) {
      var r3 = t3.dir || t3.root, n3 = t3.base || (t3.name || "") + (t3.ext || "");
      return r3 ? r3 === t3.root ? r3 + n3 : r3 + "/" + n3 : n3;
    }(0, e3);
  }, parse: function(e3) {
    s2(e3);
    var t3 = { root: "", dir: "", base: "", ext: "", name: "" };
    if (0 === e3.length) return t3;
    var r3, n3 = e3.charCodeAt(0), i3 = 47 === n3;
    i3 ? (t3.root = "/", r3 = 1) : r3 = 0;
    for (var o3 = -1, a2 = 0, l = -1, c = true, u = e3.length - 1, p = 0; u >= r3; --u) if (47 !== (n3 = e3.charCodeAt(u))) -1 === l && (c = false, l = u + 1), 46 === n3 ? -1 === o3 ? o3 = u : 1 !== p && (p = 1) : -1 !== o3 && (p = -1);
    else if (!c) {
      a2 = u + 1;
      break;
    }
    return -1 === o3 || -1 === l || 0 === p || 1 === p && o3 === l - 1 && o3 === a2 + 1 ? -1 !== l && (t3.base = t3.name = 0 === a2 && i3 ? e3.slice(1, l) : e3.slice(a2, l)) : (0 === a2 && i3 ? (t3.name = e3.slice(1, o3), t3.base = e3.slice(1, l)) : (t3.name = e3.slice(a2, o3), t3.base = e3.slice(a2, l)), t3.ext = e3.slice(o3, l)), a2 > 0 ? t3.dir = e3.slice(0, a2 - 1) : i3 && (t3.dir = "/"), t3;
  }, sep: "/", delimiter: ":", win32: null, posix: null };
  o2.posix = o2, e2.exports = o2;
}, (e2) => {
  e2.exports = function(e3) {
    try {
      return !!e3();
    } catch (e4) {
      return true;
    }
  };
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(66), i2 = r2(206), o2 = r2(218), a2 = r2(221), l = r2(63), c = r2(11), u = n2.RangeError, p = n2.Int8Array, d = p && p.prototype, f = d && d.set, h = i2.aTypedArray, m = i2.exportTypedArrayMethod, y = !c(function() {
    var e3 = new Uint8ClampedArray(2);
    return s2(f, e3, { length: 1, 0: 3 }, 1), 3 !== e3[1];
  }), g = y && i2.NATIVE_ARRAY_BUFFER_VIEWS && c(function() {
    var e3 = new p(2);
    return e3.set(1), e3.set("2", 1), 0 !== e3[0] || 2 !== e3[1];
  });
  m("set", function(e3) {
    h(this);
    var t3 = a2(arguments.length > 1 ? arguments[1] : void 0, 1), r3 = l(e3);
    if (y) return s2(f, this, r3, t3);
    var n3 = this.length, i3 = o2(r3), c2 = 0;
    if (i3 + t3 > n3) throw new u("Wrong length");
    for (; c2 < i3; ) this[t3 + c2] = r3[c2++];
  }, !y || g);
}, (e2) => {
  const t2 = Symbol.for("gensync:v1:start"), r2 = Symbol.for("gensync:v1:suspend"), n2 = "GENSYNC_EXPECTED_START", s2 = "GENSYNC_EXPECTED_SUSPEND", i2 = "GENSYNC_OPTIONS_ERROR", o2 = "GENSYNC_RACE_NONEMPTY";
  function a2(e3, t3, r3, n3) {
    if (typeof r3 === e3 || n3 && void 0 === r3) return;
    let s3;
    throw s3 = n3 ? `Expected opts.${t3} to be either a ${e3}, or undefined.` : `Expected opts.${t3} to be a ${e3}.`, l(s3, i2);
  }
  function l(e3, t3) {
    return Object.assign(new Error(e3), { code: t3 });
  }
  function c(e3) {
    let { name: n3, arity: s3, sync: i3, async: o3 } = e3;
    return m(n3, s3, function* () {
      const e4 = yield t2;
      for (var n4 = arguments.length, s4 = new Array(n4), a3 = 0; a3 < n4; a3++) s4[a3] = arguments[a3];
      if (!e4) return i3.call(this, s4);
      let l2;
      try {
        o3.call(this, s4, (t3) => {
          l2 || (l2 = { value: t3 }, e4());
        }, (t3) => {
          l2 || (l2 = { err: t3 }, e4());
        });
      } catch (t3) {
        l2 = { err: t3 }, e4();
      }
      if (yield r2, l2.hasOwnProperty("err")) throw l2.err;
      return l2.value;
    });
  }
  function u(e3) {
    let t3;
    for (; !({ value: t3 } = e3.next()).done; ) d(t3, e3);
    return t3;
  }
  function p(e3, t3, r3) {
    !function n3() {
      try {
        let r4;
        for (; !({ value: r4 } = e3.next()).done; ) {
          d(r4, e3);
          let t4 = true, s3 = false;
          const i3 = e3.next(() => {
            t4 ? s3 = true : n3();
          });
          if (t4 = false, f(i3, e3), !s3) return;
        }
        return t3(r4);
      } catch (e4) {
        return r3(e4);
      }
    }();
  }
  function d(e3, r3) {
    e3 !== t2 && h(r3, l(`Got unexpected yielded value in gensync generator: ${JSON.stringify(e3)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`, n2));
  }
  function f(e3, t3) {
    let { value: n3, done: i3 } = e3;
    (i3 || n3 !== r2) && h(t3, l(i3 ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(n3)}. If you get this, it is probably a gensync bug.`, s2));
  }
  function h(e3, t3) {
    throw e3.throw && e3.throw(t3), t3;
  }
  function m(e3, t3, r3) {
    if ("string" == typeof e3) {
      const t4 = Object.getOwnPropertyDescriptor(r3, "name");
      t4 && !t4.configurable || Object.defineProperty(r3, "name", Object.assign(t4 || {}, { configurable: true, value: e3 }));
    }
    if ("number" == typeof t3) {
      const e4 = Object.getOwnPropertyDescriptor(r3, "length");
      e4 && !e4.configurable || Object.defineProperty(r3, "length", Object.assign(e4 || {}, { configurable: true, value: t3 }));
    }
    return r3;
  }
  e2.exports = Object.assign(function(e3) {
    let t3 = e3;
    return t3 = "function" != typeof e3 ? function(e4) {
      let { name: t4, arity: r3, sync: n3, async: s3, errback: o3 } = e4;
      if (a2("string", "name", t4, true), a2("number", "arity", r3, true), a2("function", "sync", n3), a2("function", "async", s3, true), a2("function", "errback", o3, true), s3 && o3) throw l("Expected one of either opts.async or opts.errback, but got _both_.", i2);
      if ("string" != typeof t4) {
        let e5;
        o3 && o3.name && "errback" !== o3.name && (e5 = o3.name), s3 && s3.name && "async" !== s3.name && (e5 = s3.name.replace(/Async$/, "")), n3 && n3.name && "sync" !== n3.name && (e5 = n3.name.replace(/Sync$/, "")), "string" == typeof e5 && (t4 = e5);
      }
      return "number" != typeof r3 && (r3 = n3.length), c({ name: t4, arity: r3, sync: function(e5) {
        return n3.apply(this, e5);
      }, async: function(e5, t5, r4) {
        s3 ? s3.apply(this, e5).then(t5, r4) : o3 ? o3.call(this, ...e5, (e6, n4) => {
          null == e6 ? t5(n4) : r4(e6);
        }) : t5(n3.apply(this, e5));
      } });
    }(e3) : function(e4) {
      return m(e4.name, e4.length, function() {
        for (var t4 = arguments.length, r3 = new Array(t4), n3 = 0; n3 < t4; n3++) r3[n3] = arguments[n3];
        return e4.apply(this, r3);
      });
    }(e3), Object.assign(t3, /* @__PURE__ */ function(e4) {
      const t4 = { sync: function() {
        for (var t5 = arguments.length, r3 = new Array(t5), n3 = 0; n3 < t5; n3++) r3[n3] = arguments[n3];
        return u(e4.apply(this, r3));
      }, async: function() {
        for (var t5 = arguments.length, r3 = new Array(t5), n3 = 0; n3 < t5; n3++) r3[n3] = arguments[n3];
        return new Promise((t6, n4) => {
          p(e4.apply(this, r3), t6, n4);
        });
      }, errback: function() {
        for (var t5 = arguments.length, r3 = new Array(t5), n3 = 0; n3 < t5; n3++) r3[n3] = arguments[n3];
        const s3 = r3.pop();
        if ("function" != typeof s3) throw l("Asynchronous function called without callback", "GENSYNC_ERRBACK_NO_CALLBACK");
        let i3;
        try {
          i3 = e4.apply(this, r3);
        } catch (e5) {
          return void s3(e5);
        }
        p(i3, (e5) => s3(void 0, e5), (e5) => s3(e5));
      } };
      return t4;
    }(t3));
  }, { all: c({ name: "all", arity: 1, sync: function(e3) {
    return Array.from(e3[0]).map((e4) => u(e4));
  }, async: function(e3, t3, r3) {
    const n3 = Array.from(e3[0]);
    if (0 === n3.length) return void Promise.resolve().then(() => t3([]));
    let s3 = 0;
    const i3 = n3.map(() => {
    });
    n3.forEach((e4, n4) => {
      p(e4, (e5) => {
        i3[n4] = e5, s3 += 1, s3 === i3.length && t3(i3);
      }, r3);
    });
  } }), race: c({ name: "race", arity: 1, sync: function(e3) {
    const t3 = Array.from(e3[0]);
    if (0 === t3.length) throw l("Must race at least 1 item", o2);
    return u(t3[0]);
  }, async: function(e3, t3, r3) {
    const n3 = Array.from(e3[0]);
    if (0 === n3.length) throw l("Must race at least 1 item", o2);
    for (const e4 of n3) p(e4, t3, r3);
  } }) });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "Hub", { enumerable: true, get: function() {
    return c.default;
  } }), Object.defineProperty(t2, "NodePath", { enumerable: true, get: function() {
    return a2.default;
  } }), Object.defineProperty(t2, "Scope", { enumerable: true, get: function() {
    return l.default;
  } }), t2.visitors = t2.default = void 0;
  var n2 = r2(57);
  t2.visitors = n2;
  var s2 = r2(0), i2 = r2(35), o2 = r2(100), a2 = r2(28), l = r2(183), c = r2(444);
  const { VISITOR_KEYS: u, removeProperties: p, traverseFast: d } = s2;
  function f(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 ? arguments[3] : void 0, i3 = arguments.length > 4 ? arguments[4] : void 0, a3 = arguments.length > 5 ? arguments[5] : void 0;
    if (e3) {
      if (!t3.noScope && !r3 && "Program" !== e3.type && "File" !== e3.type) throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e3.type} node without passing scope and parentPath.`);
      if (!i3 && a3) throw new Error("visitSelf can only be used when providing a NodePath.");
      u[e3.type] && (n2.explode(t3), (0, o2.traverseNode)(e3, t3, r3, s3, i3, null, a3));
    }
  }
  function h(e3, t3) {
    e3.node.type === t3.type && (t3.has = true, e3.stop());
  }
  t2.default = f, f.visitors = n2, f.verify = n2.verify, f.explode = n2.explode, f.cheap = function(e3, t3) {
    d(e3, t3);
  }, f.node = function(e3, t3, r3, n3, s3, i3) {
    (0, o2.traverseNode)(e3, t3, r3, n3, s3, i3);
  }, f.clearNode = function(e3, t3) {
    p(e3, t3);
  }, f.removeProperties = function(e3, t3) {
    return d(e3, f.clearNode, t3), e3;
  }, f.hasType = function(e3, t3, r3) {
    if (null != r3 && r3.includes(e3.type)) return false;
    if (e3.type === t3) return true;
    const n3 = { has: false, type: t3 };
    return f(e3, { noScope: true, denylist: r3, enter: h }, null, n3), n3.has;
  }, f.cache = i2;
}, (e2, t2, r2) => {
  var n2 = r2(11);
  e2.exports = !n2(function() {
    return 7 !== Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1];
  });
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.declare = n2, t2.declarePreset = void 0;
  const r2 = { assertVersion: (e3) => (t3) => {
    !function(e4, t4) {
      if ("number" == typeof e4) {
        if (!Number.isInteger(e4)) throw new Error("Expected string or integer value.");
        e4 = `^${e4}.0.0-0`;
      }
      if ("string" != typeof e4) throw new Error("Expected string or integer value.");
      const r3 = Error.stackTraceLimit;
      let n3;
      throw "number" == typeof r3 && r3 < 25 && (Error.stackTraceLimit = 25), n3 = "7." === t4.slice(0, 2) ? new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${t4}". You'll need to update your @babel/core version.`) : new Error(`Requires Babel "${e4}", but was loaded with "${t4}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), "number" == typeof r3 && (Error.stackTraceLimit = r3), Object.assign(n3, { code: "BABEL_VERSION_UNSUPPORTED", version: t4, range: e4 });
    }(t3, e3.version);
  } };
  function n2(e3) {
    return (t3, n3, s3) => {
      var o3;
      let a2;
      for (const e4 of Object.keys(r2)) t3[e4] || (null != a2 || (a2 = i2(t3)), a2[e4] = r2[e4](a2));
      return e3(null != (o3 = a2) ? o3 : t3, n3 || {}, s3);
    };
  }
  Object.assign(r2, { targets: () => () => ({}), assumption: () => () => {
  } });
  const s2 = n2;
  function i2(e3) {
    let t3 = null;
    return "string" == typeof e3.version && /^7\./.test(e3.version) && (t3 = Object.getPrototypeOf(e3), !t3 || o2(t3, "version") && o2(t3, "transform") && o2(t3, "template") && o2(t3, "types") || (t3 = null)), Object.assign({}, t3, e3);
  }
  function o2(e3, t3) {
    return Object.prototype.hasOwnProperty.call(e3, t3);
  }
  t2.declarePreset = s2;
}, (e2) => {
  var t2, r2, n2 = e2.exports = {};
  function s2() {
    throw new Error("setTimeout has not been defined");
  }
  function i2() {
    throw new Error("clearTimeout has not been defined");
  }
  function o2(e3) {
    if (t2 === setTimeout) return setTimeout(e3, 0);
    if ((t2 === s2 || !t2) && setTimeout) return t2 = setTimeout, setTimeout(e3, 0);
    try {
      return t2(e3, 0);
    } catch (r3) {
      try {
        return t2.call(null, e3, 0);
      } catch (r4) {
        return t2.call(this, e3, 0);
      }
    }
  }
  !function() {
    try {
      t2 = "function" == typeof setTimeout ? setTimeout : s2;
    } catch (e3) {
      t2 = s2;
    }
    try {
      r2 = "function" == typeof clearTimeout ? clearTimeout : i2;
    } catch (e3) {
      r2 = i2;
    }
  }();
  var a2, l = [], c = false, u = -1;
  function p() {
    c && a2 && (c = false, a2.length ? l = a2.concat(l) : u = -1, l.length && d());
  }
  function d() {
    if (!c) {
      var e3 = o2(p);
      c = true;
      for (var t3 = l.length; t3; ) {
        for (a2 = l, l = []; ++u < t3; ) a2 && a2[u].run();
        u = -1, t3 = l.length;
      }
      a2 = null, c = false, function(e4) {
        if (r2 === clearTimeout) return clearTimeout(e4);
        if ((r2 === i2 || !r2) && clearTimeout) return r2 = clearTimeout, clearTimeout(e4);
        try {
          return r2(e4);
        } catch (t4) {
          try {
            return r2.call(null, e4);
          } catch (t5) {
            return r2.call(this, e4);
          }
        }
      }(e3);
    }
  }
  function f(e3, t3) {
    this.fun = e3, this.array = t3;
  }
  function h() {
  }
  n2.nextTick = function(e3) {
    var t3 = new Array(arguments.length - 1);
    if (arguments.length > 1) for (var r3 = 1; r3 < arguments.length; r3++) t3[r3 - 1] = arguments[r3];
    l.push(new f(e3, t3)), 1 !== l.length || c || o2(d);
  }, f.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, n2.title = "browser", n2.browser = true, n2.env = {}, n2.argv = [], n2.version = "", n2.versions = {}, n2.on = h, n2.addListener = h, n2.once = h, n2.off = h, n2.removeListener = h, n2.removeAllListeners = h, n2.emit = h, n2.prependListener = h, n2.prependOnceListener = h, n2.listeners = function(e3) {
    return [];
  }, n2.binding = function(e3) {
    throw new Error("process.binding is not supported");
  }, n2.cwd = function() {
    return "/";
  }, n2.chdir = function(e3) {
    throw new Error("process.chdir is not supported");
  }, n2.umask = function() {
    return 0;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.VISITOR_KEYS = t2.NODE_PARENT_VALIDATIONS = t2.NODE_FIELDS = t2.FLIPPED_ALIAS_KEYS = t2.DEPRECATED_KEYS = t2.BUILDER_KEYS = t2.ALIAS_KEYS = void 0, t2.arrayOf = m, t2.arrayOfType = y, t2.assertEach = g, t2.assertNodeOrValueType = function() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    function i3(e4, r4, i4) {
      for (const o3 of t3) if (d(i4) === o3 || (0, n2.default)(o3, i4)) return void (0, s2.validateChild)(e4, r4, i4);
      throw new TypeError(`Property ${r4} of ${e4.type} expected node to be of a type ${JSON.stringify(t3)} but instead got ${JSON.stringify(null == i4 ? void 0 : i4.type)}`);
    }
    return i3.oneOfNodeOrValueTypes = t3, i3;
  }, t2.assertNodeType = b, t2.assertOneOf = function() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    function n3(e4, r4, n4) {
      if (t3.indexOf(n4) < 0) throw new TypeError(`Property ${r4} expected value to be one of ${JSON.stringify(t3)} but got ${JSON.stringify(n4)}`);
    }
    return n3.oneOf = t3, n3;
  }, t2.assertOptionalChainStart = function() {
    return function(e3) {
      var t3;
      let r3 = e3;
      for (; e3; ) {
        const { type: e4 } = r3;
        if ("OptionalCallExpression" !== e4) {
          if ("OptionalMemberExpression" !== e4) break;
          if (r3.optional) return;
          r3 = r3.object;
        } else {
          if (r3.optional) return;
          r3 = r3.callee;
        }
      }
      throw new TypeError(`Non-optional ${e3.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null == (t3 = r3) ? void 0 : t3.type}`);
    };
  }, t2.assertShape = function(e3) {
    function t3(t4, r3, n3) {
      const i3 = [];
      for (const r4 of Object.keys(e3)) try {
        (0, s2.validateField)(t4, r4, n3[r4], e3[r4]);
      } catch (e4) {
        if (e4 instanceof TypeError) {
          i3.push(e4.message);
          continue;
        }
        throw e4;
      }
      if (i3.length) throw new TypeError(`Property ${r3} of ${t4.type} expected to have the following:
${i3.join("\n")}`);
    }
    return t3.shapeOf = e3, t3;
  }, t2.assertValueType = v, t2.chain = E, t2.default = w, t2.defineAliasedType = function() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    return function(e4) {
      let r4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n3 = r4.aliases;
      var s3;
      n3 || (r4.inherits && (n3 = null == (s3 = T[r4.inherits].aliases) ? void 0 : s3.slice()), null != n3 || (n3 = []), r4.aliases = n3);
      const i3 = t3.filter((e5) => !n3.includes(e5));
      n3.unshift(...i3), w(e4, r4);
    };
  }, t2.typeIs = h, t2.validate = f, t2.validateArrayOfType = function(e3) {
    return f(y(e3));
  }, t2.validateOptional = function(e3) {
    return { validate: e3, optional: true };
  }, t2.validateOptionalType = function(e3) {
    return { validate: h(e3), optional: true };
  }, t2.validateType = function(e3) {
    return f(h(e3));
  };
  var n2 = r2(42), s2 = r2(97);
  const i2 = t2.VISITOR_KEYS = {}, o2 = t2.ALIAS_KEYS = {}, a2 = t2.FLIPPED_ALIAS_KEYS = {}, l = t2.NODE_FIELDS = {}, c = t2.BUILDER_KEYS = {}, u = t2.DEPRECATED_KEYS = {}, p = t2.NODE_PARENT_VALIDATIONS = {};
  function d(e3) {
    return Array.isArray(e3) ? "array" : null === e3 ? "null" : typeof e3;
  }
  function f(e3) {
    return { validate: e3 };
  }
  function h(e3) {
    return "string" == typeof e3 ? b(e3) : b(...e3);
  }
  function m(e3) {
    return E(v("array"), g(e3));
  }
  function y(e3) {
    return m(h(e3));
  }
  function g(e3) {
    function t3(t4, r3, n3) {
      if (Array.isArray(n3)) for (let s3 = 0; s3 < n3.length; s3++) {
        const i3 = `${r3}[${s3}]`, o3 = n3[s3];
        e3(t4, i3, o3);
      }
    }
    return t3.each = e3, t3;
  }
  function b() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    function i3(e4, r4, i4) {
      for (const o3 of t3) if ((0, n2.default)(o3, i4)) return void (0, s2.validateChild)(e4, r4, i4);
      throw new TypeError(`Property ${r4} of ${e4.type} expected node to be of a type ${JSON.stringify(t3)} but instead got ${JSON.stringify(null == i4 ? void 0 : i4.type)}`);
    }
    return i3.oneOfNodeTypes = t3, i3;
  }
  function v(e3) {
    function t3(t4, r3, n3) {
      if (d(n3) !== e3) throw new TypeError(`Property ${r3} expected type of ${e3} but got ${d(n3)}`);
    }
    return t3.type = e3, t3;
  }
  function E() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    function n3() {
      for (const e4 of t3) e4(...arguments);
    }
    if (n3.chainOf = t3, t3.length >= 2 && "type" in t3[0] && "array" === t3[0].type && !("each" in t3[1])) throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return n3;
  }
  const S = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], x = ["default", "optional", "deprecated", "validate"], T = {};
  function w(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const r3 = t3.inherits && T[t3.inherits] || {};
    let n3 = t3.fields;
    if (!n3 && (n3 = {}, r3.fields)) {
      const e4 = Object.getOwnPropertyNames(r3.fields);
      for (const t4 of e4) {
        const e5 = r3.fields[t4], s4 = e5.default;
        if (Array.isArray(s4) ? s4.length > 0 : s4 && "object" == typeof s4) throw new Error("field defaults can only be primitives or empty arrays currently");
        n3[t4] = { default: Array.isArray(s4) ? [] : s4, optional: e5.optional, deprecated: e5.deprecated, validate: e5.validate };
      }
    }
    const s3 = t3.visitor || r3.visitor || [], f2 = t3.aliases || r3.aliases || [], h2 = t3.builder || r3.builder || t3.visitor || [];
    for (const r4 of Object.keys(t3)) if (-1 === S.indexOf(r4)) throw new Error(`Unknown type option "${r4}" on ${e3}`);
    t3.deprecatedAlias && (u[t3.deprecatedAlias] = e3);
    for (const e4 of s3.concat(h2)) n3[e4] = n3[e4] || {};
    for (const t4 of Object.keys(n3)) {
      const r4 = n3[t4];
      void 0 !== r4.default && -1 === h2.indexOf(t4) && (r4.optional = true), void 0 === r4.default ? r4.default = null : r4.validate || null == r4.default || (r4.validate = v(d(r4.default)));
      for (const n4 of Object.keys(r4)) if (-1 === x.indexOf(n4)) throw new Error(`Unknown field key "${n4}" on ${e3}.${t4}`);
    }
    i2[e3] = t3.visitor = s3, c[e3] = t3.builder = h2, l[e3] = t3.fields = n3, o2[e3] = t3.aliases = f2, f2.forEach((t4) => {
      a2[t4] = a2[t4] || [], a2[t4].push(e3);
    }), t3.validate && (p[e3] = t3.validate), T[e3] = t3;
  }
}, (e2, t2, r2) => {
  var n2 = r2(104), s2 = Function.prototype, i2 = s2.call, o2 = n2 && s2.bind.bind(i2, i2);
  e2.exports = n2 ? o2 : function(e3) {
    return function() {
      return i2.apply(e3, arguments);
    };
  };
}, (e2, t2, r2) => {
  var n2 = r2(6);
  e2.exports = function(e3) {
    return "object" == typeof e3 ? null !== e3 : n2(e3);
  };
}, (e2, t2, r2) => {
  function n2(e3, t3) {
    if (null == e3) return {};
    var r3, n3, s3 = {}, i3 = Object.keys(e3);
    for (n3 = 0; n3 < i3.length; n3++) r3 = i3[n3], t3.indexOf(r3) >= 0 || (s3[r3] = e3[r3]);
    return s3;
  }
  r2(44), Object.defineProperty(t2, "__esModule", { value: true });
  class s2 {
    constructor(e3, t3, r3) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e3, this.column = t3, this.index = r3;
    }
  }
  class i2 {
    constructor(e3, t3) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e3, this.end = t3;
    }
  }
  function o2(e3, t3) {
    const { line: r3, column: n3, index: i3 } = e3;
    return new s2(r3, n3 + t3, i3 + t3);
  }
  const a2 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
  var l = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: a2 }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: a2 } };
  const c = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, u = (e3) => {
    let { type: t3, prefix: r3 } = e3;
    return "UpdateExpression" === t3 ? c.UpdateExpression[String(r3)] : c[t3];
  };
  var p = { AccessorIsGenerator: (e3) => {
    let { kind: t3 } = e3;
    return `A ${t3}ter cannot be a generator.`;
  }, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: (e3) => {
    let { kind: t3 } = e3;
    return `Missing initializer in ${t3} declaration.`;
  }, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: (e3) => {
    let { exportName: t3 } = e3;
    return `\`${t3}\` has already been exported. Exported identifiers must be unique.`;
  }, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: (e3) => {
    let { phase: t3 } = e3;
    return `'import.${t3}(...)' can only be parsed when using the 'createImportExpressions' option.`;
  }, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: (e3) => {
    let { localName: t3, exportName: r3 } = e3;
    return `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t3}' as '${r3}' } from 'some-module'\`?`;
  }, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: (e3) => {
    let { type: t3 } = e3;
    return `'${"ForInStatement" === t3 ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`;
  }, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: (e3) => {
    let { type: t3 } = e3;
    return `Unsyntactic ${"BreakStatement" === t3 ? "break" : "continue"}.`;
  }, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: (e3) => {
    let { importName: t3 } = e3;
    return `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t3}" as foo }\`?`;
  }, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: (e3) => {
    let { maxArgumentCount: t3 } = e3;
    return `\`import()\` requires exactly ${1 === t3 ? "one argument" : "one or two arguments"}.`;
  }, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: (e3) => {
    let { radix: t3 } = e3;
    return `Expected number in radix ${t3}.`;
  }, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: (e3) => {
    let { reservedWord: t3 } = e3;
    return `Escape sequence in keyword ${t3}.`;
  }, InvalidIdentifier: (e3) => {
    let { identifierName: t3 } = e3;
    return `Invalid identifier ${t3}.`;
  }, InvalidLhs: (e3) => {
    let { ancestor: t3 } = e3;
    return `Invalid left-hand side in ${u(t3)}.`;
  }, InvalidLhsBinding: (e3) => {
    let { ancestor: t3 } = e3;
    return `Binding invalid left-hand side in ${u(t3)}.`;
  }, InvalidLhsOptionalChaining: (e3) => {
    let { ancestor: t3 } = e3;
    return `Invalid optional chaining in the left-hand side of ${u(t3)}.`;
  }, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: (e3) => {
    let { unexpected: t3 } = e3;
    return `Unexpected character '${t3}'.`;
  }, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: (e3) => {
    let { identifierName: t3 } = e3;
    return `Private name #${t3} is not defined.`;
  }, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: (e3) => {
    let { labelName: t3 } = e3;
    return `Label '${t3}' is already declared.`;
  }, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: (e3) => {
    let { missingPlugin: t3 } = e3;
    return `This experimental syntax requires enabling the parser plugin: ${t3.map((e4) => JSON.stringify(e4)).join(", ")}.`;
  }, MissingOneOfPlugins: (e3) => {
    let { missingPlugin: t3 } = e3;
    return `This experimental syntax requires enabling one of the following parser plugin(s): ${t3.map((e4) => JSON.stringify(e4)).join(", ")}.`;
  }, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: (e3) => {
    let { key: t3 } = e3;
    return `Duplicate key "${t3}" is not allowed in module attributes.`;
  }, ModuleExportNameHasLoneSurrogate: (e3) => {
    let { surrogateCharCode: t3 } = e3;
    return `An export name cannot include a lone surrogate, found '\\u${t3.toString(16)}'.`;
  }, ModuleExportUndefined: (e3) => {
    let { localName: t3 } = e3;
    return `Export '${t3}' is not defined.`;
  }, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: (e3) => {
    let { identifierName: t3 } = e3;
    return `Private names are only allowed in property accesses (\`obj.#${t3}\`) or in \`in\` expressions (\`#${t3} in obj\`).`;
  }, PrivateNameRedeclaration: (e3) => {
    let { identifierName: t3 } = e3;
    return `Duplicate private name #${t3}.`;
  }, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: (e3) => {
    let { keyword: t3 } = e3;
    return `Unexpected keyword '${t3}'.`;
  }, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: (e3) => {
    let { reservedWord: t3 } = e3;
    return `Unexpected reserved word '${t3}'.`;
  }, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: (e3) => {
    let { expected: t3, unexpected: r3 } = e3;
    return `Unexpected token${r3 ? ` '${r3}'.` : ""}${t3 ? `, expected "${t3}"` : ""}`;
  }, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: (e3) => {
    let { target: t3, onlyValidPropertyName: r3 } = e3;
    return `The only valid meta property for ${t3} is ${t3}.${r3}.`;
  }, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: (e3) => {
    let { identifierName: t3 } = e3;
    return `Identifier '${t3}' has already been declared.`;
  }, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." };
  const d = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var f = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: (e3) => {
    let { token: t3 } = e3;
    return `Invalid topic token ${t3}. In order to use ${t3} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${t3}" }.`;
  }, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: (e3) => {
    let { type: t3 } = e3;
    return `Hack-style pipe body cannot be an unparenthesized ${u({ type: t3 })}; please wrap it in parentheses.`;
  }, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' };
  const h = ["toMessage"], m = ["message"];
  function y(e3, t3, r3) {
    Object.defineProperty(e3, t3, { enumerable: false, configurable: true, value: r3 });
  }
  function g(e3) {
    let { toMessage: t3 } = e3, r3 = n2(e3, h);
    return function e4(n3, i3) {
      const o3 = new SyntaxError();
      return Object.assign(o3, r3, { loc: n3, pos: n3.index }), "missingPlugin" in i3 && Object.assign(o3, { missingPlugin: i3.missingPlugin }), y(o3, "clone", function() {
        let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        var r4;
        const { line: o4, column: a3, index: l2 } = null != (r4 = t4.loc) ? r4 : n3;
        return e4(new s2(o4, a3, l2), Object.assign({}, i3, t4.details));
      }), y(o3, "details", i3), Object.defineProperty(o3, "message", { configurable: true, get() {
        const e5 = `${t3(i3)} (${n3.line}:${n3.column})`;
        return this.message = e5, e5;
      }, set(e5) {
        Object.defineProperty(this, "message", { value: e5, writable: true });
      } }), o3;
    };
  }
  function b(e3, t3) {
    if (Array.isArray(e3)) return (t4) => b(t4, e3[0]);
    const r3 = {};
    for (const s3 of Object.keys(e3)) {
      const i3 = e3[s3], o3 = "string" == typeof i3 ? { message: () => i3 } : "function" == typeof i3 ? { message: i3 } : i3, { message: a3 } = o3, l2 = n2(o3, m), c2 = "string" == typeof a3 ? () => a3 : a3;
      r3[s3] = g(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: s3, toMessage: c2 }, t3 ? { syntaxPlugin: t3 } : {}, l2));
    }
    return r3;
  }
  const v = Object.assign({}, b(l), b(p), b({ StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: (e3) => {
    let { referenceName: t3 } = e3;
    return `Assigning to '${t3}' in strict mode.`;
  }, StrictEvalArgumentsBinding: (e3) => {
    let { bindingName: t3 } = e3;
    return `Binding '${t3}' in strict mode.`;
  }, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }), b`pipelineOperator`(f)), { defineProperty: E } = Object, S = (e3, t3) => E(e3, t3, { enumerable: false, value: e3[t3] });
  function x(e3) {
    return e3.loc.start && S(e3.loc.start, "index"), e3.loc.end && S(e3.loc.end, "index"), e3;
  }
  class T {
    constructor(e3, t3) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e3, this.preserveSpace = !!t3;
    }
  }
  const w = { brace: new T("{"), j_oTag: new T("<tag"), j_cTag: new T("</tag"), j_expr: new T("<tag>...</tag>", true) };
  w.template = new T("`", true);
  const P = true, A = true, C = true, O = true, I = true;
  class _ {
    constructor(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e3, this.keyword = t3.keyword, this.beforeExpr = !!t3.beforeExpr, this.startsExpr = !!t3.startsExpr, this.rightAssociative = !!t3.rightAssociative, this.isLoop = !!t3.isLoop, this.isAssign = !!t3.isAssign, this.prefix = !!t3.prefix, this.postfix = !!t3.postfix, this.binop = null != t3.binop ? t3.binop : null, this.updateContext = null;
    }
  }
  const k = /* @__PURE__ */ new Map();
  function N(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    t3.keyword = e3;
    const r3 = $(e3, t3);
    return k.set(e3, r3), r3;
  }
  function D(e3, t3) {
    return $(e3, { beforeExpr: P, binop: t3 });
  }
  let j = -1;
  const L = [], M = [], B = [], R = [], F = [], U = [];
  function $(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var r3, n3, s3, i3;
    return ++j, M.push(e3), B.push(null != (r3 = t3.binop) ? r3 : -1), R.push(null != (n3 = t3.beforeExpr) && n3), F.push(null != (s3 = t3.startsExpr) && s3), U.push(null != (i3 = t3.prefix) && i3), L.push(new _(e3, t3)), j;
  }
  function V(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var r3, n3, s3, i3;
    return ++j, k.set(e3, j), M.push(e3), B.push(null != (r3 = t3.binop) ? r3 : -1), R.push(null != (n3 = t3.beforeExpr) && n3), F.push(null != (s3 = t3.startsExpr) && s3), U.push(null != (i3 = t3.prefix) && i3), L.push(new _("name", t3)), j;
  }
  const q = { bracketL: $("[", { beforeExpr: P, startsExpr: A }), bracketHashL: $("#[", { beforeExpr: P, startsExpr: A }), bracketBarL: $("[|", { beforeExpr: P, startsExpr: A }), bracketR: $("]"), bracketBarR: $("|]"), braceL: $("{", { beforeExpr: P, startsExpr: A }), braceBarL: $("{|", { beforeExpr: P, startsExpr: A }), braceHashL: $("#{", { beforeExpr: P, startsExpr: A }), braceR: $("}"), braceBarR: $("|}"), parenL: $("(", { beforeExpr: P, startsExpr: A }), parenR: $(")"), comma: $(",", { beforeExpr: P }), semi: $(";", { beforeExpr: P }), colon: $(":", { beforeExpr: P }), doubleColon: $("::", { beforeExpr: P }), dot: $("."), question: $("?", { beforeExpr: P }), questionDot: $("?."), arrow: $("=>", { beforeExpr: P }), template: $("template"), ellipsis: $("...", { beforeExpr: P }), backQuote: $("`", { startsExpr: A }), dollarBraceL: $("${", { beforeExpr: P, startsExpr: A }), templateTail: $("...`", { startsExpr: A }), templateNonTail: $("...${", { beforeExpr: P, startsExpr: A }), at: $("@"), hash: $("#", { startsExpr: A }), interpreterDirective: $("#!..."), eq: $("=", { beforeExpr: P, isAssign: O }), assign: $("_=", { beforeExpr: P, isAssign: O }), slashAssign: $("_=", { beforeExpr: P, isAssign: O }), xorAssign: $("_=", { beforeExpr: P, isAssign: O }), moduloAssign: $("_=", { beforeExpr: P, isAssign: O }), incDec: $("++/--", { prefix: I, postfix: true, startsExpr: A }), bang: $("!", { beforeExpr: P, prefix: I, startsExpr: A }), tilde: $("~", { beforeExpr: P, prefix: I, startsExpr: A }), doubleCaret: $("^^", { startsExpr: A }), doubleAt: $("@@", { startsExpr: A }), pipeline: D("|>", 0), nullishCoalescing: D("??", 1), logicalOR: D("||", 1), logicalAND: D("&&", 2), bitwiseOR: D("|", 3), bitwiseXOR: D("^", 4), bitwiseAND: D("&", 5), equality: D("==/!=/===/!==", 6), lt: D("</>/<=/>=", 7), gt: D("</>/<=/>=", 7), relational: D("</>/<=/>=", 7), bitShift: D("<</>>/>>>", 8), bitShiftL: D("<</>>/>>>", 8), bitShiftR: D("<</>>/>>>", 8), plusMin: $("+/-", { beforeExpr: P, binop: 9, prefix: I, startsExpr: A }), modulo: $("%", { binop: 10, startsExpr: A }), star: $("*", { binop: 10 }), slash: D("/", 10), exponent: $("**", { beforeExpr: P, binop: 11, rightAssociative: true }), _in: N("in", { beforeExpr: P, binop: 7 }), _instanceof: N("instanceof", { beforeExpr: P, binop: 7 }), _break: N("break"), _case: N("case", { beforeExpr: P }), _catch: N("catch"), _continue: N("continue"), _debugger: N("debugger"), _default: N("default", { beforeExpr: P }), _else: N("else", { beforeExpr: P }), _finally: N("finally"), _function: N("function", { startsExpr: A }), _if: N("if"), _return: N("return", { beforeExpr: P }), _switch: N("switch"), _throw: N("throw", { beforeExpr: P, prefix: I, startsExpr: A }), _try: N("try"), _var: N("var"), _const: N("const"), _with: N("with"), _new: N("new", { beforeExpr: P, startsExpr: A }), _this: N("this", { startsExpr: A }), _super: N("super", { startsExpr: A }), _class: N("class", { startsExpr: A }), _extends: N("extends", { beforeExpr: P }), _export: N("export"), _import: N("import", { startsExpr: A }), _null: N("null", { startsExpr: A }), _true: N("true", { startsExpr: A }), _false: N("false", { startsExpr: A }), _typeof: N("typeof", { beforeExpr: P, prefix: I, startsExpr: A }), _void: N("void", { beforeExpr: P, prefix: I, startsExpr: A }), _delete: N("delete", { beforeExpr: P, prefix: I, startsExpr: A }), _do: N("do", { isLoop: C, beforeExpr: P }), _for: N("for", { isLoop: C }), _while: N("while", { isLoop: C }), _as: V("as", { startsExpr: A }), _assert: V("assert", { startsExpr: A }), _async: V("async", { startsExpr: A }), _await: V("await", { startsExpr: A }), _defer: V("defer", { startsExpr: A }), _from: V("from", { startsExpr: A }), _get: V("get", { startsExpr: A }), _let: V("let", { startsExpr: A }), _meta: V("meta", { startsExpr: A }), _of: V("of", { startsExpr: A }), _sent: V("sent", { startsExpr: A }), _set: V("set", { startsExpr: A }), _source: V("source", { startsExpr: A }), _static: V("static", { startsExpr: A }), _using: V("using", { startsExpr: A }), _yield: V("yield", { startsExpr: A }), _asserts: V("asserts", { startsExpr: A }), _checks: V("checks", { startsExpr: A }), _exports: V("exports", { startsExpr: A }), _global: V("global", { startsExpr: A }), _implements: V("implements", { startsExpr: A }), _intrinsic: V("intrinsic", { startsExpr: A }), _infer: V("infer", { startsExpr: A }), _is: V("is", { startsExpr: A }), _mixins: V("mixins", { startsExpr: A }), _proto: V("proto", { startsExpr: A }), _require: V("require", { startsExpr: A }), _satisfies: V("satisfies", { startsExpr: A }), _keyof: V("keyof", { startsExpr: A }), _readonly: V("readonly", { startsExpr: A }), _unique: V("unique", { startsExpr: A }), _abstract: V("abstract", { startsExpr: A }), _declare: V("declare", { startsExpr: A }), _enum: V("enum", { startsExpr: A }), _module: V("module", { startsExpr: A }), _namespace: V("namespace", { startsExpr: A }), _interface: V("interface", { startsExpr: A }), _type: V("type", { startsExpr: A }), _opaque: V("opaque", { startsExpr: A }), name: $("name", { startsExpr: A }), string: $("string", { startsExpr: A }), num: $("num", { startsExpr: A }), bigint: $("bigint", { startsExpr: A }), decimal: $("decimal", { startsExpr: A }), regexp: $("regexp", { startsExpr: A }), privateName: $("#name", { startsExpr: A }), eof: $("eof"), jsxName: $("jsxName"), jsxText: $("jsxText", { beforeExpr: true }), jsxTagStart: $("jsxTagStart", { startsExpr: true }), jsxTagEnd: $("jsxTagEnd"), placeholder: $("%%", { startsExpr: true }) };
  function W(e3) {
    return e3 >= 93 && e3 <= 132;
  }
  function G(e3) {
    return e3 >= 58 && e3 <= 132;
  }
  function H(e3) {
    return e3 >= 58 && e3 <= 136;
  }
  function z(e3) {
    return F[e3];
  }
  function K(e3) {
    return e3 >= 129 && e3 <= 131;
  }
  function X(e3) {
    return e3 >= 58 && e3 <= 92;
  }
  function J(e3) {
    return M[e3];
  }
  function Y(e3) {
    return B[e3];
  }
  function Q(e3) {
    return e3 >= 24 && e3 <= 25;
  }
  function Z(e3) {
    return L[e3];
  }
  L[8].updateContext = (e3) => {
    e3.pop();
  }, L[5].updateContext = L[7].updateContext = L[23].updateContext = (e3) => {
    e3.push(w.brace);
  }, L[22].updateContext = (e3) => {
    e3[e3.length - 1] === w.template ? e3.pop() : e3.push(w.template);
  }, L[142].updateContext = (e3) => {
    e3.push(w.j_expr, w.j_oTag);
  };
  let ee = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", te = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
  const re = new RegExp("[" + ee + "]"), ne = new RegExp("[" + ee + te + "]");
  ee = te = null;
  const se = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], ie = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function oe(e3, t3) {
    let r3 = 65536;
    for (let n3 = 0, s3 = t3.length; n3 < s3; n3 += 2) {
      if (r3 += t3[n3], r3 > e3) return false;
      if (r3 += t3[n3 + 1], r3 >= e3) return true;
    }
    return false;
  }
  function ae(e3) {
    return e3 < 65 ? 36 === e3 : e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && re.test(String.fromCharCode(e3)) : oe(e3, se)));
  }
  function le(e3) {
    return e3 < 48 ? 36 === e3 : e3 < 58 || !(e3 < 65) && (e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && ne.test(String.fromCharCode(e3)) : oe(e3, se) || oe(e3, ie))));
  }
  const ce = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), ue = /* @__PURE__ */ new Set(["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"]), pe = /* @__PURE__ */ new Set(["eval", "arguments"]);
  function de(e3, t3) {
    return t3 && "await" === e3 || "enum" === e3;
  }
  function fe(e3, t3) {
    return de(e3, t3) || ue.has(e3);
  }
  function he(e3) {
    return pe.has(e3);
  }
  function me(e3, t3) {
    return fe(e3, t3) || he(e3);
  }
  const ye = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  class ge {
    constructor(e3) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e3;
    }
  }
  class be {
    constructor(e3, t3) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e3, this.inModule = t3;
    }
    get inTopLevel() {
      return (1 & this.currentScope().flags) > 0;
    }
    get inFunction() {
      return (2 & this.currentVarScopeFlags()) > 0;
    }
    get allowSuper() {
      return (16 & this.currentThisScopeFlags()) > 0;
    }
    get allowDirectSuper() {
      return (32 & this.currentThisScopeFlags()) > 0;
    }
    get inClass() {
      return (64 & this.currentThisScopeFlags()) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const e3 = this.currentThisScopeFlags();
      return (64 & e3) > 0 && 0 == (2 & e3);
    }
    get inStaticBlock() {
      for (let e3 = this.scopeStack.length - 1; ; e3--) {
        const { flags: t3 } = this.scopeStack[e3];
        if (128 & t3) return true;
        if (451 & t3) return false;
      }
    }
    get inNonArrowFunction() {
      return (2 & this.currentThisScopeFlags()) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e3) {
      return new ge(e3);
    }
    enter(e3) {
      this.scopeStack.push(this.createScope(e3));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e3) {
      return !!(130 & e3.flags || !this.parser.inModule && 1 & e3.flags);
    }
    declareName(e3, t3, r3) {
      let n3 = this.currentScope();
      if (8 & t3 || 16 & t3) {
        this.checkRedeclarationInScope(n3, e3, t3, r3);
        let s3 = n3.names.get(e3) || 0;
        16 & t3 ? s3 |= 4 : (n3.firstLexicalName || (n3.firstLexicalName = e3), s3 |= 2), n3.names.set(e3, s3), 8 & t3 && this.maybeExportDefined(n3, e3);
      } else if (4 & t3) for (let s3 = this.scopeStack.length - 1; s3 >= 0 && (n3 = this.scopeStack[s3], this.checkRedeclarationInScope(n3, e3, t3, r3), n3.names.set(e3, 1 | (n3.names.get(e3) || 0)), this.maybeExportDefined(n3, e3), !(387 & n3.flags)); --s3) ;
      this.parser.inModule && 1 & n3.flags && this.undefinedExports.delete(e3);
    }
    maybeExportDefined(e3, t3) {
      this.parser.inModule && 1 & e3.flags && this.undefinedExports.delete(t3);
    }
    checkRedeclarationInScope(e3, t3, r3, n3) {
      this.isRedeclaredInScope(e3, t3, r3) && this.parser.raise(v.VarRedeclaration, n3, { identifierName: t3 });
    }
    isRedeclaredInScope(e3, t3, r3) {
      if (!(1 & r3)) return false;
      if (8 & r3) return e3.names.has(t3);
      const n3 = e3.names.get(t3);
      return 16 & r3 ? (2 & n3) > 0 || !this.treatFunctionsAsVarInScope(e3) && (1 & n3) > 0 : (2 & n3) > 0 && !(8 & e3.flags && e3.firstLexicalName === t3) || !this.treatFunctionsAsVarInScope(e3) && (4 & n3) > 0;
    }
    checkLocalExport(e3) {
      const { name: t3 } = e3;
      this.scopeStack[0].names.has(t3) || this.undefinedExports.set(t3, e3.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e3 = this.scopeStack.length - 1; ; e3--) {
        const { flags: t3 } = this.scopeStack[e3];
        if (387 & t3) return t3;
      }
    }
    currentThisScopeFlags() {
      for (let e3 = this.scopeStack.length - 1; ; e3--) {
        const { flags: t3 } = this.scopeStack[e3];
        if (451 & t3 && !(4 & t3)) return t3;
      }
    }
  }
  class ve extends ge {
    constructor() {
      super(...arguments), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }
  class Ee extends be {
    createScope(e3) {
      return new ve(e3);
    }
    declareName(e3, t3, r3) {
      const n3 = this.currentScope();
      if (2048 & t3) return this.checkRedeclarationInScope(n3, e3, t3, r3), this.maybeExportDefined(n3, e3), void n3.declareFunctions.add(e3);
      super.declareName(e3, t3, r3);
    }
    isRedeclaredInScope(e3, t3, r3) {
      if (super.isRedeclaredInScope(e3, t3, r3)) return true;
      if (2048 & r3 && !e3.declareFunctions.has(t3)) {
        const r4 = e3.names.get(t3);
        return (4 & r4) > 0 || (2 & r4) > 0;
      }
      return false;
    }
    checkLocalExport(e3) {
      this.scopeStack[0].declareFunctions.has(e3.name) || super.checkLocalExport(e3);
    }
  }
  class Se {
    constructor() {
      this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(e3) {
      if ("string" == typeof e3) return this.plugins.has(e3);
      {
        const [t3, r3] = e3;
        if (!this.hasPlugin(t3)) return false;
        const n3 = this.plugins.get(t3);
        for (const e4 of Object.keys(r3)) if ((null == n3 ? void 0 : n3[e4]) !== r3[e4]) return false;
        return true;
      }
    }
    getPluginOption(e3, t3) {
      var r3;
      return null == (r3 = this.plugins.get(e3)) ? void 0 : r3[t3];
    }
  }
  function xe(e3, t3) {
    void 0 === e3.trailingComments ? e3.trailingComments = t3 : e3.trailingComments.unshift(...t3);
  }
  function Te(e3, t3) {
    void 0 === e3.innerComments ? e3.innerComments = t3 : e3.innerComments.unshift(...t3);
  }
  function we(e3, t3, r3) {
    let n3 = null, s3 = t3.length;
    for (; null === n3 && s3 > 0; ) n3 = t3[--s3];
    null === n3 || n3.start > r3.start ? Te(e3, r3.comments) : xe(n3, r3.comments);
  }
  class Pe extends Se {
    addComment(e3) {
      this.filename && (e3.loc.filename = this.filename);
      const { commentsLen: t3 } = this.state;
      this.comments.length != t3 && (this.comments.length = t3), this.comments.push(e3), this.state.commentsLen++;
    }
    processComment(e3) {
      const { commentStack: t3 } = this.state, r3 = t3.length;
      if (0 === r3) return;
      let n3 = r3 - 1;
      const s3 = t3[n3];
      s3.start === e3.end && (s3.leadingNode = e3, n3--);
      const { start: i3 } = e3;
      for (; n3 >= 0; n3--) {
        const r4 = t3[n3], s4 = r4.end;
        if (!(s4 > i3)) {
          s4 === i3 && (r4.trailingNode = e3);
          break;
        }
        r4.containingNode = e3, this.finalizeComment(r4), t3.splice(n3, 1);
      }
    }
    finalizeComment(e3) {
      const { comments: t3 } = e3;
      if (null !== e3.leadingNode || null !== e3.trailingNode) null !== e3.leadingNode && xe(e3.leadingNode, t3), null !== e3.trailingNode && function(e4, t4) {
        void 0 === e4.leadingComments ? e4.leadingComments = t4 : e4.leadingComments.unshift(...t4);
      }(e3.trailingNode, t3);
      else {
        const { containingNode: r3, start: n3 } = e3;
        if (44 === this.input.charCodeAt(n3 - 1)) switch (r3.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            we(r3, r3.properties, e3);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
            we(r3, r3.arguments, e3);
            break;
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            we(r3, r3.params, e3);
            break;
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            we(r3, r3.elements, e3);
            break;
          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            we(r3, r3.specifiers, e3);
            break;
          default:
            Te(r3, t3);
        }
        else Te(r3, t3);
      }
    }
    finalizeRemainingComments() {
      const { commentStack: e3 } = this.state;
      for (let t3 = e3.length - 1; t3 >= 0; t3--) this.finalizeComment(e3[t3]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e3) {
      const { commentStack: t3 } = this.state, { length: r3 } = t3;
      if (0 === r3) return;
      const n3 = t3[r3 - 1];
      n3.leadingNode === e3 && (n3.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e3) {
      const { commentStack: t3 } = this.state, { length: r3 } = t3;
      0 !== r3 && (t3[r3 - 1].trailingNode === e3 ? t3[r3 - 1].trailingNode = null : r3 >= 2 && t3[r3 - 2].trailingNode === e3 && (t3[r3 - 2].trailingNode = null));
    }
    takeSurroundingComments(e3, t3, r3) {
      const { commentStack: n3 } = this.state, s3 = n3.length;
      if (0 === s3) return;
      let i3 = s3 - 1;
      for (; i3 >= 0; i3--) {
        const s4 = n3[i3], o3 = s4.end;
        if (s4.start === r3) s4.leadingNode = e3;
        else if (o3 === t3) s4.trailingNode = e3;
        else if (o3 < t3) break;
      }
    }
  }
  const Ae = /\r\n?|[\n\u2028\u2029]/, Ce = new RegExp(Ae.source, "g");
  function Oe(e3) {
    switch (e3) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  }
  const Ie = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, _e = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, ke = new RegExp("(?=(" + _e.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function Ne(e3) {
    switch (e3) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  }
  class De {
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [w.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (1 & this.flags) > 0;
    }
    set strict(e3) {
      e3 ? this.flags |= 1 : this.flags &= -2;
    }
    init(e3) {
      let { strictMode: t3, sourceType: r3, startLine: n3, startColumn: i3 } = e3;
      this.strict = false !== t3 && (true === t3 || "module" === r3), this.curLine = n3, this.lineStart = -i3, this.startLoc = this.endLoc = new s2(n3, i3, 0);
    }
    get maybeInArrowParameters() {
      return (2 & this.flags) > 0;
    }
    set maybeInArrowParameters(e3) {
      e3 ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (4 & this.flags) > 0;
    }
    set inType(e3) {
      e3 ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (8 & this.flags) > 0;
    }
    set noAnonFunctionType(e3) {
      e3 ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (16 & this.flags) > 0;
    }
    set hasFlowComment(e3) {
      e3 ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (32 & this.flags) > 0;
    }
    set isAmbientContext(e3) {
      e3 ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (64 & this.flags) > 0;
    }
    set inAbstractClass(e3) {
      e3 ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (128 & this.flags) > 0;
    }
    set inDisallowConditionalTypesContext(e3) {
      e3 ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (256 & this.flags) > 0;
    }
    set soloAwait(e3) {
      e3 ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (512 & this.flags) > 0;
    }
    set inFSharpPipelineDirectBody(e3) {
      e3 ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (1024 & this.flags) > 0;
    }
    set canStartJSXElement(e3) {
      e3 ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (2048 & this.flags) > 0;
    }
    set containsEsc(e3) {
      e3 ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new s2(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      const e3 = new De();
      return e3.flags = this.flags, e3.curLine = this.curLine, e3.lineStart = this.lineStart, e3.startLoc = this.startLoc, e3.endLoc = this.endLoc, e3.errors = this.errors.slice(), e3.potentialArrowAt = this.potentialArrowAt, e3.noArrowAt = this.noArrowAt.slice(), e3.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), e3.topicContext = this.topicContext, e3.labels = this.labels.slice(), e3.commentsLen = this.commentsLen, e3.commentStack = this.commentStack.slice(), e3.pos = this.pos, e3.type = this.type, e3.value = this.value, e3.start = this.start, e3.end = this.end, e3.lastTokEndLoc = this.lastTokEndLoc, e3.lastTokStartLoc = this.lastTokStartLoc, e3.context = this.context.slice(), e3.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, e3.strictErrors = this.strictErrors, e3.tokensLength = this.tokensLength, e3;
    }
  }
  var je = function(e3) {
    return e3 >= 48 && e3 <= 57;
  };
  const Le = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Me = { bin: (e3) => 48 === e3 || 49 === e3, oct: (e3) => e3 >= 48 && e3 <= 55, dec: (e3) => e3 >= 48 && e3 <= 57, hex: (e3) => e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102 };
  function Be(e3, t3, r3, n3, s3, i3) {
    const o3 = r3, a3 = n3, l2 = s3;
    let c2 = "", u2 = null, p2 = r3;
    const { length: d2 } = t3;
    for (; ; ) {
      if (r3 >= d2) {
        i3.unterminated(o3, a3, l2), c2 += t3.slice(p2, r3);
        break;
      }
      const f2 = t3.charCodeAt(r3);
      if (Re(e3, f2, t3, r3)) {
        c2 += t3.slice(p2, r3);
        break;
      }
      if (92 === f2) {
        c2 += t3.slice(p2, r3);
        const o4 = Fe(t3, r3, n3, s3, "template" === e3, i3);
        null !== o4.ch || u2 ? c2 += o4.ch : u2 = { pos: r3, lineStart: n3, curLine: s3 }, { pos: r3, lineStart: n3, curLine: s3 } = o4, p2 = r3;
      } else 8232 === f2 || 8233 === f2 ? (++s3, n3 = ++r3) : 10 === f2 || 13 === f2 ? "template" === e3 ? (c2 += t3.slice(p2, r3) + "\n", ++r3, 13 === f2 && 10 === t3.charCodeAt(r3) && ++r3, ++s3, p2 = n3 = r3) : i3.unterminated(o3, a3, l2) : ++r3;
    }
    return { pos: r3, str: c2, firstInvalidLoc: u2, lineStart: n3, curLine: s3, containsInvalid: !!u2 };
  }
  function Re(e3, t3, r3, n3) {
    return "template" === e3 ? 96 === t3 || 36 === t3 && 123 === r3.charCodeAt(n3 + 1) : t3 === ("double" === e3 ? 34 : 39);
  }
  function Fe(e3, t3, r3, n3, s3, i3) {
    const o3 = !s3;
    t3++;
    const a3 = (e4) => ({ pos: t3, ch: e4, lineStart: r3, curLine: n3 }), l2 = e3.charCodeAt(t3++);
    switch (l2) {
      case 110:
        return a3("\n");
      case 114:
        return a3("\r");
      case 120: {
        let s4;
        return { code: s4, pos: t3 } = Ue(e3, t3, r3, n3, 2, false, o3, i3), a3(null === s4 ? null : String.fromCharCode(s4));
      }
      case 117: {
        let s4;
        return { code: s4, pos: t3 } = Ve(e3, t3, r3, n3, o3, i3), a3(null === s4 ? null : String.fromCodePoint(s4));
      }
      case 116:
        return a3("	");
      case 98:
        return a3("\b");
      case 118:
        return a3("\v");
      case 102:
        return a3("\f");
      case 13:
        10 === e3.charCodeAt(t3) && ++t3;
      case 10:
        r3 = t3, ++n3;
      case 8232:
      case 8233:
        return a3("");
      case 56:
      case 57:
        if (s3) return a3(null);
        i3.strictNumericEscape(t3 - 1, r3, n3);
      default:
        if (l2 >= 48 && l2 <= 55) {
          const o4 = t3 - 1;
          let l3 = e3.slice(o4, t3 + 2).match(/^[0-7]+/)[0], c2 = parseInt(l3, 8);
          c2 > 255 && (l3 = l3.slice(0, -1), c2 = parseInt(l3, 8)), t3 += l3.length - 1;
          const u2 = e3.charCodeAt(t3);
          if ("0" !== l3 || 56 === u2 || 57 === u2) {
            if (s3) return a3(null);
            i3.strictNumericEscape(o4, r3, n3);
          }
          return a3(String.fromCharCode(c2));
        }
        return a3(String.fromCharCode(l2));
    }
  }
  function Ue(e3, t3, r3, n3, s3, i3, o3, a3) {
    const l2 = t3;
    let c2;
    return { n: c2, pos: t3 } = $e(e3, t3, r3, n3, 16, s3, i3, false, a3, !o3), null === c2 && (o3 ? a3.invalidEscapeSequence(l2, r3, n3) : t3 = l2 - 1), { code: c2, pos: t3 };
  }
  function $e(e3, t3, r3, n3, s3, i3, o3, a3, l2, c2) {
    const u2 = t3, p2 = 16 === s3 ? Le.hex : Le.decBinOct, d2 = 16 === s3 ? Me.hex : 10 === s3 ? Me.dec : 8 === s3 ? Me.oct : Me.bin;
    let f2 = false, h2 = 0;
    for (let u3 = 0, m2 = null == i3 ? 1 / 0 : i3; u3 < m2; ++u3) {
      const i4 = e3.charCodeAt(t3);
      let u4;
      if (95 !== i4 || "bail" === a3) {
        if (u4 = i4 >= 97 ? i4 - 97 + 10 : i4 >= 65 ? i4 - 65 + 10 : je(i4) ? i4 - 48 : 1 / 0, u4 >= s3) {
          if (u4 <= 9 && c2) return { n: null, pos: t3 };
          if (u4 <= 9 && l2.invalidDigit(t3, r3, n3, s3)) u4 = 0;
          else {
            if (!o3) break;
            u4 = 0, f2 = true;
          }
        }
        ++t3, h2 = h2 * s3 + u4;
      } else {
        const s4 = e3.charCodeAt(t3 - 1), i5 = e3.charCodeAt(t3 + 1);
        if (a3) {
          if (Number.isNaN(i5) || !d2(i5) || p2.has(s4) || p2.has(i5)) {
            if (c2) return { n: null, pos: t3 };
            l2.unexpectedNumericSeparator(t3, r3, n3);
          }
        } else {
          if (c2) return { n: null, pos: t3 };
          l2.numericSeparatorInEscapeSequence(t3, r3, n3);
        }
        ++t3;
      }
    }
    return t3 === u2 || null != i3 && t3 - u2 !== i3 || f2 ? { n: null, pos: t3 } : { n: h2, pos: t3 };
  }
  function Ve(e3, t3, r3, n3, s3, i3) {
    let o3;
    if (123 === e3.charCodeAt(t3)) {
      if (++t3, { code: o3, pos: t3 } = Ue(e3, t3, r3, n3, e3.indexOf("}", t3) - t3, true, s3, i3), ++t3, null !== o3 && o3 > 1114111) {
        if (!s3) return { code: null, pos: t3 };
        i3.invalidCodePoint(t3, r3, n3);
      }
    } else ({ code: o3, pos: t3 } = Ue(e3, t3, r3, n3, 4, false, s3, i3));
    return { code: o3, pos: t3 };
  }
  function qe(e3, t3, r3) {
    return new s2(r3, e3 - t3, e3);
  }
  const We = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
  class Ge {
    constructor(e3) {
      this.type = e3.type, this.value = e3.value, this.start = e3.start, this.end = e3.end, this.loc = new i2(e3.startLoc, e3.endLoc);
    }
  }
  class He extends Pe {
    constructor(e3, t3) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (e4, t4, r3, n3) => !!this.options.errorRecovery && (this.raise(v.InvalidDigit, qe(e4, t4, r3), { radix: n3 }), true), numericSeparatorInEscapeSequence: this.errorBuilder(v.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(v.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(v.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(v.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (e4, t4, r3) => {
        this.recordStrictModeErrors(v.StrictNumericEscape, qe(e4, t4, r3));
      }, unterminated: (e4, t4, r3) => {
        throw this.raise(v.UnterminatedString, qe(e4 - 1, t4, r3));
      } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(v.StrictNumericEscape), unterminated: (e4, t4, r3) => {
        throw this.raise(v.UnterminatedTemplate, qe(e4, t4, r3));
      } }), this.state = new De(), this.state.init(e3), this.input = t3, this.length = t3.length, this.comments = [], this.isLookahead = false;
    }
    pushToken(e3) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e3), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Ge(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e3) {
      return !!this.match(e3) && (this.next(), true);
    }
    match(e3) {
      return this.state.type === e3;
    }
    createLookaheadState(e3) {
      return { pos: e3.pos, value: null, type: e3.type, start: e3.start, end: e3.end, context: [this.curContext()], inType: e3.inType, startLoc: e3.startLoc, lastTokEndLoc: e3.lastTokEndLoc, curLine: e3.curLine, lineStart: e3.lineStart, curPosition: e3.curPosition };
    }
    lookahead() {
      const e3 = this.state;
      this.state = this.createLookaheadState(e3), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
      const t3 = this.state;
      return this.state = e3, t3;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e3) {
      return Ie.lastIndex = e3, Ie.test(this.input) ? Ie.lastIndex : e3;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e3) {
      return _e.lastIndex = e3, _e.test(this.input) ? _e.lastIndex : e3;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e3) {
      let t3 = this.input.charCodeAt(e3);
      if (55296 == (64512 & t3) && ++e3 < this.input.length) {
        const r3 = this.input.charCodeAt(e3);
        56320 == (64512 & r3) && (t3 = 65536 + ((1023 & t3) << 10) + (1023 & r3));
      }
      return t3;
    }
    setStrict(e3) {
      this.state.strict = e3, e3 && (this.state.strictErrors.forEach((e4) => {
        let [t3, r3] = e4;
        return this.raise(t3, r3);
      }), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(139) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e3) {
      let t3;
      this.isLookahead || (t3 = this.state.curPosition());
      const r3 = this.state.pos, n3 = this.input.indexOf(e3, r3 + 2);
      if (-1 === n3) throw this.raise(v.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = n3 + e3.length, Ce.lastIndex = r3 + 2; Ce.test(this.input) && Ce.lastIndex <= n3; ) ++this.state.curLine, this.state.lineStart = Ce.lastIndex;
      if (this.isLookahead) return;
      const s3 = { type: "CommentBlock", value: this.input.slice(r3 + 2, n3), start: r3, end: n3 + e3.length, loc: new i2(t3, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(s3), s3;
    }
    skipLineComment(e3) {
      const t3 = this.state.pos;
      let r3;
      this.isLookahead || (r3 = this.state.curPosition());
      let n3 = this.input.charCodeAt(this.state.pos += e3);
      if (this.state.pos < this.length) for (; !Oe(n3) && ++this.state.pos < this.length; ) n3 = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      const s3 = this.state.pos, o3 = { type: "CommentLine", value: this.input.slice(t3 + e3, s3), start: t3, end: s3, loc: new i2(r3, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(o3), o3;
    }
    skipSpace() {
      const e3 = this.state.pos, t3 = [];
      e: for (; this.state.pos < this.length; ) {
        const r3 = this.input.charCodeAt(this.state.pos);
        switch (r3) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const e4 = this.skipBlockComment("*/");
                void 0 !== e4 && (this.addComment(e4), this.options.attachComment && t3.push(e4));
                break;
              }
              case 47: {
                const e4 = this.skipLineComment(2);
                void 0 !== e4 && (this.addComment(e4), this.options.attachComment && t3.push(e4));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (Ne(r3)) ++this.state.pos;
            else if (45 === r3 && !this.inModule && this.options.annexB) {
              const r4 = this.state.pos;
              if (45 !== this.input.charCodeAt(r4 + 1) || 62 !== this.input.charCodeAt(r4 + 2) || !(0 === e3 || this.state.lineStart > e3)) break e;
              {
                const e4 = this.skipLineComment(3);
                void 0 !== e4 && (this.addComment(e4), this.options.attachComment && t3.push(e4));
              }
            } else {
              if (60 !== r3 || this.inModule || !this.options.annexB) break e;
              {
                const e4 = this.state.pos;
                if (33 !== this.input.charCodeAt(e4 + 1) || 45 !== this.input.charCodeAt(e4 + 2) || 45 !== this.input.charCodeAt(e4 + 3)) break e;
                {
                  const e5 = this.skipLineComment(4);
                  void 0 !== e5 && (this.addComment(e5), this.options.attachComment && t3.push(e5));
                }
              }
            }
        }
      }
      if (t3.length > 0) {
        const r3 = { start: e3, end: this.state.pos, comments: t3, leadingNode: null, trailingNode: null, containingNode: null };
        this.state.commentStack.push(r3);
      }
    }
    finishToken(e3, t3) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      const r3 = this.state.type;
      this.state.type = e3, this.state.value = t3, this.isLookahead || this.updateContext(r3);
    }
    replaceToken(e3) {
      this.state.type = e3, this.updateContext();
    }
    readToken_numberSign() {
      if (0 === this.state.pos && this.readToken_interpreter()) return;
      const e3 = this.state.pos + 1, t3 = this.codePointAtPos(e3);
      if (t3 >= 48 && t3 <= 57) throw this.raise(v.UnexpectedDigitAfterHash, this.state.curPosition());
      if (123 === t3 || 91 === t3 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), "bar" === this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(123 === t3 ? v.RecordExpressionHashIncorrectStartSyntaxType : v.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, 123 === t3 ? this.finishToken(7) : this.finishToken(1);
      } else ae(t3) ? (++this.state.pos, this.finishToken(138, this.readWord1(t3))) : 92 === t3 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      const e3 = this.input.charCodeAt(this.state.pos + 1);
      e3 >= 48 && e3 <= 57 ? this.readNumber(true) : 46 === e3 && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (0 !== this.state.pos || this.length < 2) return false;
      let e3 = this.input.charCodeAt(this.state.pos + 1);
      if (33 !== e3) return false;
      const t3 = this.state.pos;
      for (this.state.pos += 1; !Oe(e3) && ++this.state.pos < this.length; ) e3 = this.input.charCodeAt(this.state.pos);
      const r3 = this.input.slice(t3 + 2, this.state.pos);
      return this.finishToken(28, r3), true;
    }
    readToken_mult_modulo(e3) {
      let t3 = 42 === e3 ? 55 : 54, r3 = 1, n3 = this.input.charCodeAt(this.state.pos + 1);
      42 === e3 && 42 === n3 && (r3++, n3 = this.input.charCodeAt(this.state.pos + 2), t3 = 57), 61 !== n3 || this.state.inType || (r3++, t3 = 37 === e3 ? 33 : 30), this.finishOp(t3, r3);
    }
    readToken_pipe_amp(e3) {
      const t3 = this.input.charCodeAt(this.state.pos + 1);
      if (t3 !== e3) {
        if (124 === e3) {
          if (62 === t3) return void this.finishOp(39, 2);
          if (this.hasPlugin("recordAndTuple") && 125 === t3) {
            if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(v.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            return this.state.pos += 2, void this.finishToken(9);
          }
          if (this.hasPlugin("recordAndTuple") && 93 === t3) {
            if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(v.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            return this.state.pos += 2, void this.finishToken(4);
          }
        }
        61 !== t3 ? this.finishOp(124 === e3 ? 43 : 45, 1) : this.finishOp(30, 2);
      } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === e3 ? 41 : 42, 2);
    }
    readToken_caret() {
      const e3 = this.input.charCodeAt(this.state.pos + 1);
      61 !== e3 || this.state.inType ? 94 === e3 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), 94 === this.input.codePointAt(this.state.pos) && this.unexpected()) : this.finishOp(44, 1) : this.finishOp(32, 2);
    }
    readToken_atSign() {
      64 === this.input.charCodeAt(this.state.pos + 1) && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e3) {
      const t3 = this.input.charCodeAt(this.state.pos + 1);
      t3 !== e3 ? 61 === t3 ? this.finishOp(30, 2) : this.finishOp(53, 1) : this.finishOp(34, 2);
    }
    readToken_lt() {
      const { pos: e3 } = this.state, t3 = this.input.charCodeAt(e3 + 1);
      if (60 === t3) return 61 === this.input.charCodeAt(e3 + 2) ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
      61 !== t3 ? this.finishOp(47, 1) : this.finishOp(49, 2);
    }
    readToken_gt() {
      const { pos: e3 } = this.state, t3 = this.input.charCodeAt(e3 + 1);
      if (62 === t3) {
        const t4 = 62 === this.input.charCodeAt(e3 + 2) ? 3 : 2;
        return 61 === this.input.charCodeAt(e3 + t4) ? void this.finishOp(30, t4 + 1) : void this.finishOp(52, t4);
      }
      61 !== t3 ? this.finishOp(48, 1) : this.finishOp(49, 2);
    }
    readToken_eq_excl(e3) {
      const t3 = this.input.charCodeAt(this.state.pos + 1);
      if (61 !== t3) return 61 === e3 && 62 === t3 ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(61 === e3 ? 29 : 35, 1);
      this.finishOp(46, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
    }
    readToken_question() {
      const e3 = this.input.charCodeAt(this.state.pos + 1), t3 = this.input.charCodeAt(this.state.pos + 2);
      63 === e3 ? 61 === t3 ? this.finishOp(30, 3) : this.finishOp(40, 2) : 46 !== e3 || t3 >= 48 && t3 <= 57 ? (++this.state.pos, this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
    }
    getTokenFromCode(e3) {
      switch (e3) {
        case 46:
          return void this.readToken_dot();
        case 40:
          return ++this.state.pos, void this.finishToken(10);
        case 41:
          return ++this.state.pos, void this.finishToken(11);
        case 59:
          return ++this.state.pos, void this.finishToken(13);
        case 44:
          return ++this.state.pos, void this.finishToken(12);
        case 91:
          if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
            if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(v.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          return ++this.state.pos, void this.finishToken(3);
        case 123:
          if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
            if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(v.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          return ++this.state.pos, void this.finishToken(8);
        case 58:
          return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
        case 63:
          return void this.readToken_question();
        case 96:
          return void this.readTemplateToken();
        case 48: {
          const e4 = this.input.charCodeAt(this.state.pos + 1);
          if (120 === e4 || 88 === e4) return void this.readRadixNumber(16);
          if (111 === e4 || 79 === e4) return void this.readRadixNumber(8);
          if (98 === e4 || 66 === e4) return void this.readRadixNumber(2);
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return void this.readNumber(false);
        case 34:
        case 39:
          return void this.readString(e3);
        case 47:
          return void this.readToken_slash();
        case 37:
        case 42:
          return void this.readToken_mult_modulo(e3);
        case 124:
        case 38:
          return void this.readToken_pipe_amp(e3);
        case 94:
          return void this.readToken_caret();
        case 43:
        case 45:
          return void this.readToken_plus_min(e3);
        case 60:
          return void this.readToken_lt();
        case 62:
          return void this.readToken_gt();
        case 61:
        case 33:
          return void this.readToken_eq_excl(e3);
        case 126:
          return void this.finishOp(36, 1);
        case 64:
          return void this.readToken_atSign();
        case 35:
          return void this.readToken_numberSign();
        case 92:
          return void this.readWord();
        default:
          if (ae(e3)) return void this.readWord(e3);
      }
      throw this.raise(v.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(e3) });
    }
    finishOp(e3, t3) {
      const r3 = this.input.slice(this.state.pos, this.state.pos + t3);
      this.state.pos += t3, this.finishToken(e3, r3);
    }
    readRegexp() {
      const e3 = this.state.startLoc, t3 = this.state.start + 1;
      let r3, n3, { pos: s3 } = this.state;
      for (; ; ++s3) {
        if (s3 >= this.length) throw this.raise(v.UnterminatedRegExp, o2(e3, 1));
        const t4 = this.input.charCodeAt(s3);
        if (Oe(t4)) throw this.raise(v.UnterminatedRegExp, o2(e3, 1));
        if (r3) r3 = false;
        else {
          if (91 === t4) n3 = true;
          else if (93 === t4 && n3) n3 = false;
          else if (47 === t4 && !n3) break;
          r3 = 92 === t4;
        }
      }
      const i3 = this.input.slice(t3, s3);
      ++s3;
      let a3 = "";
      const l2 = () => o2(e3, s3 + 2 - t3);
      for (; s3 < this.length; ) {
        const e4 = this.codePointAtPos(s3), t4 = String.fromCharCode(e4);
        if (We.has(e4)) 118 === e4 ? a3.includes("u") && this.raise(v.IncompatibleRegExpUVFlags, l2()) : 117 === e4 && a3.includes("v") && this.raise(v.IncompatibleRegExpUVFlags, l2()), a3.includes(t4) && this.raise(v.DuplicateRegExpFlags, l2());
        else {
          if (!le(e4) && 92 !== e4) break;
          this.raise(v.MalformedRegExpFlags, l2());
        }
        ++s3, a3 += t4;
      }
      this.state.pos = s3, this.finishToken(137, { pattern: i3, flags: a3 });
    }
    readInt(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      const { n: s3, pos: i3 } = $e(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e3, t3, r3, n3, this.errorHandlers_readInt, false);
      return this.state.pos = i3, s3;
    }
    readRadixNumber(e3) {
      const t3 = this.state.curPosition();
      let r3 = false;
      this.state.pos += 2;
      const n3 = this.readInt(e3);
      null == n3 && this.raise(v.InvalidDigit, o2(t3, 2), { radix: e3 });
      const s3 = this.input.charCodeAt(this.state.pos);
      if (110 === s3) ++this.state.pos, r3 = true;
      else if (109 === s3) throw this.raise(v.InvalidDecimal, t3);
      if (ae(this.codePointAtPos(this.state.pos))) throw this.raise(v.NumberIdentifier, this.state.curPosition());
      if (r3) {
        const e4 = this.input.slice(t3.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, e4);
      } else this.finishToken(134, n3);
    }
    readNumber(e3) {
      const t3 = this.state.pos, r3 = this.state.curPosition();
      let n3 = false, s3 = false, i3 = false, a3 = false, l2 = false;
      e3 || null !== this.readInt(10) || this.raise(v.InvalidNumber, this.state.curPosition());
      const c2 = this.state.pos - t3 >= 2 && 48 === this.input.charCodeAt(t3);
      if (c2) {
        const e4 = this.input.slice(t3, this.state.pos);
        if (this.recordStrictModeErrors(v.StrictOctalLiteral, r3), !this.state.strict) {
          const t4 = e4.indexOf("_");
          t4 > 0 && this.raise(v.ZeroDigitNumericSeparator, o2(r3, t4));
        }
        l2 = c2 && !/[89]/.test(e4);
      }
      let u2 = this.input.charCodeAt(this.state.pos);
      if (46 !== u2 || l2 || (++this.state.pos, this.readInt(10), n3 = true, u2 = this.input.charCodeAt(this.state.pos)), 69 !== u2 && 101 !== u2 || l2 || (u2 = this.input.charCodeAt(++this.state.pos), 43 !== u2 && 45 !== u2 || ++this.state.pos, null === this.readInt(10) && this.raise(v.InvalidOrMissingExponent, r3), n3 = true, a3 = true, u2 = this.input.charCodeAt(this.state.pos)), 110 === u2 && ((n3 || c2) && this.raise(v.InvalidBigIntLiteral, r3), ++this.state.pos, s3 = true), 109 === u2 && (this.expectPlugin("decimal", this.state.curPosition()), (a3 || c2) && this.raise(v.InvalidDecimal, r3), ++this.state.pos, i3 = true), ae(this.codePointAtPos(this.state.pos))) throw this.raise(v.NumberIdentifier, this.state.curPosition());
      const p2 = this.input.slice(t3, this.state.pos).replace(/[_mn]/g, "");
      if (s3) return void this.finishToken(135, p2);
      if (i3) return void this.finishToken(136, p2);
      const d2 = l2 ? parseInt(p2, 8) : parseFloat(p2);
      this.finishToken(134, d2);
    }
    readCodePoint(e3) {
      const { code: t3, pos: r3 } = Ve(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e3, this.errorHandlers_readCodePoint);
      return this.state.pos = r3, t3;
    }
    readString(e3) {
      const { str: t3, pos: r3, curLine: n3, lineStart: s3 } = Be(34 === e3 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = r3 + 1, this.state.lineStart = s3, this.state.curLine = n3, this.finishToken(133, t3);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      const e3 = this.input[this.state.pos], { str: t3, firstInvalidLoc: r3, pos: n3, curLine: i3, lineStart: o3 } = Be("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = n3 + 1, this.state.lineStart = o3, this.state.curLine = i3, r3 && (this.state.firstInvalidTemplateEscapePos = new s2(r3.curLine, r3.pos - r3.lineStart, r3.pos)), 96 === this.input.codePointAt(n3) ? this.finishToken(24, r3 ? null : e3 + t3 + "`") : (this.state.pos++, this.finishToken(25, r3 ? null : e3 + t3 + "${"));
    }
    recordStrictModeErrors(e3, t3) {
      const r3 = t3.index;
      this.state.strict && !this.state.strictErrors.has(r3) ? this.raise(e3, t3) : this.state.strictErrors.set(r3, [e3, t3]);
    }
    readWord1(e3) {
      this.state.containsEsc = false;
      let t3 = "";
      const r3 = this.state.pos;
      let n3 = this.state.pos;
      for (void 0 !== e3 && (this.state.pos += e3 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const e4 = this.codePointAtPos(this.state.pos);
        if (le(e4)) this.state.pos += e4 <= 65535 ? 1 : 2;
        else {
          if (92 !== e4) break;
          {
            this.state.containsEsc = true, t3 += this.input.slice(n3, this.state.pos);
            const e5 = this.state.curPosition(), s3 = this.state.pos === r3 ? ae : le;
            if (117 !== this.input.charCodeAt(++this.state.pos)) {
              this.raise(v.MissingUnicodeEscape, this.state.curPosition()), n3 = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const i3 = this.readCodePoint(true);
            null !== i3 && (s3(i3) || this.raise(v.EscapedCharNotAnIdentifier, e5), t3 += String.fromCodePoint(i3)), n3 = this.state.pos;
          }
        }
      }
      return t3 + this.input.slice(n3, this.state.pos);
    }
    readWord(e3) {
      const t3 = this.readWord1(e3), r3 = k.get(t3);
      void 0 !== r3 ? this.finishToken(r3, J(r3)) : this.finishToken(132, t3);
    }
    checkKeywordEscapes() {
      const { type: e3 } = this.state;
      X(e3) && this.state.containsEsc && this.raise(v.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: J(e3) });
    }
    raise(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      const n3 = e3(t3 instanceof s2 ? t3 : t3.loc.start, r3);
      if (!this.options.errorRecovery) throw n3;
      return this.isLookahead || this.state.errors.push(n3), n3;
    }
    raiseOverwrite(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      const n3 = t3 instanceof s2 ? t3 : t3.loc.start, i3 = n3.index, o3 = this.state.errors;
      for (let t4 = o3.length - 1; t4 >= 0; t4--) {
        const s3 = o3[t4];
        if (s3.loc.index === i3) return o3[t4] = e3(n3, r3);
        if (s3.loc.index < i3) break;
      }
      return this.raise(e3, t3, r3);
    }
    updateContext(e3) {
    }
    unexpected(e3, t3) {
      throw this.raise(v.UnexpectedToken, null != e3 ? e3 : this.state.startLoc, { expected: t3 ? J(t3) : null });
    }
    expectPlugin(e3, t3) {
      if (this.hasPlugin(e3)) return true;
      throw this.raise(v.MissingPlugin, null != t3 ? t3 : this.state.startLoc, { missingPlugin: [e3] });
    }
    expectOnePlugin(e3) {
      if (!e3.some((e4) => this.hasPlugin(e4))) throw this.raise(v.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: e3 });
    }
    errorBuilder(e3) {
      return (t3, r3, n3) => {
        this.raise(e3, qe(t3, r3, n3));
      };
    }
  }
  class ze {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }
  class Ke {
    constructor(e3) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e3;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new ze());
    }
    exit() {
      const e3 = this.stack.pop(), t3 = this.current();
      for (const [r3, n3] of Array.from(e3.undefinedPrivateNames)) t3 ? t3.undefinedPrivateNames.has(r3) || t3.undefinedPrivateNames.set(r3, n3) : this.parser.raise(v.InvalidPrivateFieldResolution, n3, { identifierName: r3 });
    }
    declarePrivateName(e3, t3, r3) {
      const { privateNames: n3, loneAccessors: s3, undefinedPrivateNames: i3 } = this.current();
      let o3 = n3.has(e3);
      if (3 & t3) {
        const r4 = o3 && s3.get(e3);
        r4 ? (o3 = (3 & r4) == (3 & t3) || (4 & r4) != (4 & t3), o3 || s3.delete(e3)) : o3 || s3.set(e3, t3);
      }
      o3 && this.parser.raise(v.PrivateNameRedeclaration, r3, { identifierName: e3 }), n3.add(e3), i3.delete(e3);
    }
    usePrivateName(e3, t3) {
      let r3;
      for (r3 of this.stack) if (r3.privateNames.has(e3)) return;
      r3 ? r3.undefinedPrivateNames.set(e3, t3) : this.parser.raise(v.InvalidPrivateFieldResolution, t3, { identifierName: e3 });
    }
  }
  class Xe {
    constructor() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
      this.type = e3;
    }
    canBeArrowParameterDeclaration() {
      return 2 === this.type || 1 === this.type;
    }
    isCertainlyParameterDeclaration() {
      return 3 === this.type;
    }
  }
  class Je extends Xe {
    constructor(e3) {
      super(e3), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e3, t3) {
      const r3 = t3.index;
      this.declarationErrors.set(r3, [e3, t3]);
    }
    clearDeclarationError(e3) {
      this.declarationErrors.delete(e3);
    }
    iterateErrors(e3) {
      this.declarationErrors.forEach(e3);
    }
  }
  class Ye {
    constructor(e3) {
      this.parser = void 0, this.stack = [new Xe()], this.parser = e3;
    }
    enter(e3) {
      this.stack.push(e3);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e3, t3) {
      const r3 = t3.loc.start, { stack: n3 } = this;
      let s3 = n3.length - 1, i3 = n3[s3];
      for (; !i3.isCertainlyParameterDeclaration(); ) {
        if (!i3.canBeArrowParameterDeclaration()) return;
        i3.recordDeclarationError(e3, r3), i3 = n3[--s3];
      }
      this.parser.raise(e3, r3);
    }
    recordArrowParameterBindingError(e3, t3) {
      const { stack: r3 } = this, n3 = r3[r3.length - 1], s3 = t3.loc.start;
      if (n3.isCertainlyParameterDeclaration()) this.parser.raise(e3, s3);
      else {
        if (!n3.canBeArrowParameterDeclaration()) return;
        n3.recordDeclarationError(e3, s3);
      }
    }
    recordAsyncArrowParametersError(e3) {
      const { stack: t3 } = this;
      let r3 = t3.length - 1, n3 = t3[r3];
      for (; n3.canBeArrowParameterDeclaration(); ) 2 === n3.type && n3.recordDeclarationError(v.AwaitBindingIdentifier, e3), n3 = t3[--r3];
    }
    validateAsPattern() {
      const { stack: e3 } = this, t3 = e3[e3.length - 1];
      t3.canBeArrowParameterDeclaration() && t3.iterateErrors((t4) => {
        let [r3, n3] = t4;
        this.parser.raise(r3, n3);
        let s3 = e3.length - 2, i3 = e3[s3];
        for (; i3.canBeArrowParameterDeclaration(); ) i3.clearDeclarationError(n3.index), i3 = e3[--s3];
      });
    }
  }
  function Qe() {
    return new Xe();
  }
  class Ze {
    constructor() {
      this.stacks = [];
    }
    enter(e3) {
      this.stacks.push(e3);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (2 & this.currentFlags()) > 0;
    }
    get hasYield() {
      return (1 & this.currentFlags()) > 0;
    }
    get hasReturn() {
      return (4 & this.currentFlags()) > 0;
    }
    get hasIn() {
      return (8 & this.currentFlags()) > 0;
    }
  }
  function et(e3, t3) {
    return (e3 ? 2 : 0) | (t3 ? 1 : 0);
  }
  class tt extends He {
    addExtra(e3, t3, r3) {
      let n3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      if (!e3) return;
      const s3 = e3.extra = e3.extra || {};
      n3 ? s3[t3] = r3 : Object.defineProperty(s3, t3, { enumerable: n3, value: r3 });
    }
    isContextual(e3) {
      return this.state.type === e3 && !this.state.containsEsc;
    }
    isUnparsedContextual(e3, t3) {
      const r3 = e3 + t3.length;
      if (this.input.slice(e3, r3) === t3) {
        const e4 = this.input.charCodeAt(r3);
        return !(le(e4) || 55296 == (64512 & e4));
      }
      return false;
    }
    isLookaheadContextual(e3) {
      const t3 = this.nextTokenStart();
      return this.isUnparsedContextual(t3, e3);
    }
    eatContextual(e3) {
      return !!this.isContextual(e3) && (this.next(), true);
    }
    expectContextual(e3, t3) {
      if (!this.eatContextual(e3)) {
        if (null != t3) throw this.raise(t3, this.state.startLoc);
        this.unexpected(null, e3);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return Ae.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return ke.lastIndex = this.state.end, ke.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon() {
      (arguments.length > 0 && void 0 !== arguments[0] && !arguments[0] ? this.eat(13) : this.isLineTerminator()) || this.raise(v.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e3, t3) {
      this.eat(e3) || this.unexpected(t3, e3);
    }
    tryParse(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state.clone();
      const r3 = { node: null };
      try {
        const n3 = e3(function() {
          let e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
          throw r3.node = e4, r3;
        });
        if (this.state.errors.length > t3.errors.length) {
          const e4 = this.state;
          return this.state = t3, this.state.tokensLength = e4.tokensLength, { node: n3, error: e4.errors[t3.errors.length], thrown: false, aborted: false, failState: e4 };
        }
        return { node: n3, error: null, thrown: false, aborted: false, failState: null };
      } catch (e4) {
        const n3 = this.state;
        if (this.state = t3, e4 instanceof SyntaxError) return { node: null, error: e4, thrown: true, aborted: false, failState: n3 };
        if (e4 === r3) return { node: r3.node, error: null, thrown: false, aborted: true, failState: n3 };
        throw e4;
      }
    }
    checkExpressionErrors(e3, t3) {
      if (!e3) return false;
      const { shorthandAssignLoc: r3, doubleProtoLoc: n3, privateKeyLoc: s3, optionalParametersLoc: i3 } = e3;
      if (!t3) return !!(r3 || n3 || i3 || s3);
      null != r3 && this.raise(v.InvalidCoverInitializedName, r3), null != n3 && this.raise(v.DuplicateProto, n3), null != s3 && this.raise(v.UnexpectedPrivateField, s3), null != i3 && this.unexpected(i3);
    }
    isLiteralPropertyName() {
      return H(this.state.type);
    }
    isPrivateName(e3) {
      return "PrivateName" === e3.type;
    }
    getPrivateNameSV(e3) {
      return e3.id.name;
    }
    hasPropertyAsPrivateName(e3) {
      return ("MemberExpression" === e3.type || "OptionalMemberExpression" === e3.type) && this.isPrivateName(e3.property);
    }
    isObjectProperty(e3) {
      return "ObjectProperty" === e3.type;
    }
    isObjectMethod(e3) {
      return "ObjectMethod" === e3.type;
    }
    initializeScopes() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "module" === this.options.sourceType;
      const t3 = this.state.labels;
      this.state.labels = [];
      const r3 = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      const n3 = this.inModule;
      this.inModule = e3;
      const s3 = this.scope, i3 = this.getScopeHandler();
      this.scope = new i3(this, e3);
      const o3 = this.prodParam;
      this.prodParam = new Ze();
      const a3 = this.classScope;
      this.classScope = new Ke(this);
      const l2 = this.expressionScope;
      return this.expressionScope = new Ye(this), () => {
        this.state.labels = t3, this.exportedIdentifiers = r3, this.inModule = n3, this.scope = s3, this.prodParam = o3, this.classScope = a3, this.expressionScope = l2;
      };
    }
    enterInitialScopes() {
      let e3 = 0;
      this.inModule && (e3 |= 2), this.scope.enter(1), this.prodParam.enter(e3);
    }
    checkDestructuringPrivate(e3) {
      const { privateKeyLoc: t3 } = e3;
      null !== t3 && this.expectPlugin("destructuringPrivate", t3);
    }
  }
  class rt {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }
  class nt {
    constructor(e3, t3, r3) {
      this.type = "", this.start = t3, this.end = 0, this.loc = new i2(r3), null != e3 && e3.options.ranges && (this.range = [t3, 0]), null != e3 && e3.filename && (this.loc.filename = e3.filename);
    }
  }
  const st = nt.prototype;
  function it(e3) {
    const { type: t3, start: r3, end: n3, loc: s3, range: i3, extra: o3, name: a3 } = e3, l2 = Object.create(st);
    return l2.type = t3, l2.start = r3, l2.end = n3, l2.loc = s3, l2.range = i3, l2.extra = o3, l2.name = a3, "Placeholder" === t3 && (l2.expectedNode = e3.expectedNode), l2;
  }
  st.__clone = function() {
    const e3 = new nt(void 0, this.start, this.loc.start), t3 = Object.keys(this);
    for (let r3 = 0, n3 = t3.length; r3 < n3; r3++) {
      const n4 = t3[r3];
      "leadingComments" !== n4 && "trailingComments" !== n4 && "innerComments" !== n4 && (e3[n4] = this[n4]);
    }
    return e3;
  };
  class ot extends tt {
    startNode() {
      const e3 = this.state.startLoc;
      return new nt(this, e3.index, e3);
    }
    startNodeAt(e3) {
      return new nt(this, e3.index, e3);
    }
    startNodeAtNode(e3) {
      return this.startNodeAt(e3.loc.start);
    }
    finishNode(e3, t3) {
      return this.finishNodeAt(e3, t3, this.state.lastTokEndLoc);
    }
    finishNodeAt(e3, t3, r3) {
      return e3.type = t3, e3.end = r3.index, e3.loc.end = r3, this.options.ranges && (e3.range[1] = r3.index), this.options.attachComment && this.processComment(e3), e3;
    }
    resetStartLocation(e3, t3) {
      e3.start = t3.index, e3.loc.start = t3, this.options.ranges && (e3.range[0] = t3.index);
    }
    resetEndLocation(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state.lastTokEndLoc;
      e3.end = t3.index, e3.loc.end = t3, this.options.ranges && (e3.range[1] = t3.index);
    }
    resetStartLocationFromNode(e3, t3) {
      this.resetStartLocation(e3, t3.loc.start);
    }
  }
  const at = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), lt = b`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: (e3) => {
    let { reservedType: t3 } = e3;
    return `Cannot overwrite reserved type ${t3}.`;
  }, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: (e3) => {
    let { memberName: t3, enumName: r3 } = e3;
    return `Boolean enum members need to be initialized. Use either \`${t3} = true,\` or \`${t3} = false,\` in enum \`${r3}\`.`;
  }, EnumDuplicateMemberName: (e3) => {
    let { memberName: t3, enumName: r3 } = e3;
    return `Enum member names need to be unique, but the name \`${t3}\` has already been used before in enum \`${r3}\`.`;
  }, EnumInconsistentMemberValues: (e3) => {
    let { enumName: t3 } = e3;
    return `Enum \`${t3}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`;
  }, EnumInvalidExplicitType: (e3) => {
    let { invalidEnumType: t3, enumName: r3 } = e3;
    return `Enum type \`${t3}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${r3}\`.`;
  }, EnumInvalidExplicitTypeUnknownSupplied: (e3) => {
    let { enumName: t3 } = e3;
    return `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t3}\`.`;
  }, EnumInvalidMemberInitializerPrimaryType: (e3) => {
    let { enumName: t3, memberName: r3, explicitType: n3 } = e3;
    return `Enum \`${t3}\` has type \`${n3}\`, so the initializer of \`${r3}\` needs to be a ${n3} literal.`;
  }, EnumInvalidMemberInitializerSymbolType: (e3) => {
    let { enumName: t3, memberName: r3 } = e3;
    return `Symbol enum members cannot be initialized. Use \`${r3},\` in enum \`${t3}\`.`;
  }, EnumInvalidMemberInitializerUnknownType: (e3) => {
    let { enumName: t3, memberName: r3 } = e3;
    return `The enum member initializer for \`${r3}\` needs to be a literal (either a boolean, number, or string) in enum \`${t3}\`.`;
  }, EnumInvalidMemberName: (e3) => {
    let { enumName: t3, memberName: r3, suggestion: n3 } = e3;
    return `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${r3}\`, consider using \`${n3}\`, in enum \`${t3}\`.`;
  }, EnumNumberMemberNotInitialized: (e3) => {
    let { enumName: t3, memberName: r3 } = e3;
    return `Number enum members need to be initialized, e.g. \`${r3} = 1\` in enum \`${t3}\`.`;
  }, EnumStringMemberInconsistentlyInitialized: (e3) => {
    let { enumName: t3 } = e3;
    return `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t3}\`.`;
  }, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: (e3) => {
    let { reservedType: t3 } = e3;
    return `Unexpected reserved type ${t3}.`;
  }, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: (e3) => {
    let { unsupportedExportKind: t3, suggestion: r3 } = e3;
    return `\`declare export ${t3}\` is not supported. Use \`${r3}\` instead.`;
  }, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
  function ct(e3) {
    return "type" === e3.importKind || "typeof" === e3.importKind;
  }
  const ut = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" }, pt = /\*?\s*@((?:no)?flow)\b/, dt = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: " ", iexcl: "¡", cent: "¢", pound: "£", curren: "¤", yen: "¥", brvbar: "¦", sect: "§", uml: "¨", copy: "©", ordf: "ª", laquo: "«", not: "¬", shy: "­", reg: "®", macr: "¯", deg: "°", plusmn: "±", sup2: "²", sup3: "³", acute: "´", micro: "µ", para: "¶", middot: "·", cedil: "¸", sup1: "¹", ordm: "º", raquo: "»", frac14: "¼", frac12: "½", frac34: "¾", iquest: "¿", Agrave: "À", Aacute: "Á", Acirc: "Â", Atilde: "Ã", Auml: "Ä", Aring: "Å", AElig: "Æ", Ccedil: "Ç", Egrave: "È", Eacute: "É", Ecirc: "Ê", Euml: "Ë", Igrave: "Ì", Iacute: "Í", Icirc: "Î", Iuml: "Ï", ETH: "Ð", Ntilde: "Ñ", Ograve: "Ò", Oacute: "Ó", Ocirc: "Ô", Otilde: "Õ", Ouml: "Ö", times: "×", Oslash: "Ø", Ugrave: "Ù", Uacute: "Ú", Ucirc: "Û", Uuml: "Ü", Yacute: "Ý", THORN: "Þ", szlig: "ß", agrave: "à", aacute: "á", acirc: "â", atilde: "ã", auml: "ä", aring: "å", aelig: "æ", ccedil: "ç", egrave: "è", eacute: "é", ecirc: "ê", euml: "ë", igrave: "ì", iacute: "í", icirc: "î", iuml: "ï", eth: "ð", ntilde: "ñ", ograve: "ò", oacute: "ó", ocirc: "ô", otilde: "õ", ouml: "ö", divide: "÷", oslash: "ø", ugrave: "ù", uacute: "ú", ucirc: "û", uuml: "ü", yacute: "ý", thorn: "þ", yuml: "ÿ", OElig: "Œ", oelig: "œ", Scaron: "Š", scaron: "š", Yuml: "Ÿ", fnof: "ƒ", circ: "ˆ", tilde: "˜", Alpha: "Α", Beta: "Β", Gamma: "Γ", Delta: "Δ", Epsilon: "Ε", Zeta: "Ζ", Eta: "Η", Theta: "Θ", Iota: "Ι", Kappa: "Κ", Lambda: "Λ", Mu: "Μ", Nu: "Ν", Xi: "Ξ", Omicron: "Ο", Pi: "Π", Rho: "Ρ", Sigma: "Σ", Tau: "Τ", Upsilon: "Υ", Phi: "Φ", Chi: "Χ", Psi: "Ψ", Omega: "Ω", alpha: "α", beta: "β", gamma: "γ", delta: "δ", epsilon: "ε", zeta: "ζ", eta: "η", theta: "θ", iota: "ι", kappa: "κ", lambda: "λ", mu: "μ", nu: "ν", xi: "ξ", omicron: "ο", pi: "π", rho: "ρ", sigmaf: "ς", sigma: "σ", tau: "τ", upsilon: "υ", phi: "φ", chi: "χ", psi: "ψ", omega: "ω", thetasym: "ϑ", upsih: "ϒ", piv: "ϖ", ensp: " ", emsp: " ", thinsp: " ", zwnj: "‌", zwj: "‍", lrm: "‎", rlm: "‏", ndash: "–", mdash: "—", lsquo: "‘", rsquo: "’", sbquo: "‚", ldquo: "“", rdquo: "”", bdquo: "„", dagger: "†", Dagger: "‡", bull: "•", hellip: "…", permil: "‰", prime: "′", Prime: "″", lsaquo: "‹", rsaquo: "›", oline: "‾", frasl: "⁄", euro: "€", image: "ℑ", weierp: "℘", real: "ℜ", trade: "™", alefsym: "ℵ", larr: "←", uarr: "↑", rarr: "→", darr: "↓", harr: "↔", crarr: "↵", lArr: "⇐", uArr: "⇑", rArr: "⇒", dArr: "⇓", hArr: "⇔", forall: "∀", part: "∂", exist: "∃", empty: "∅", nabla: "∇", isin: "∈", notin: "∉", ni: "∋", prod: "∏", sum: "∑", minus: "−", lowast: "∗", radic: "√", prop: "∝", infin: "∞", ang: "∠", and: "∧", or: "∨", cap: "∩", cup: "∪", int: "∫", there4: "∴", sim: "∼", cong: "≅", asymp: "≈", ne: "≠", equiv: "≡", le: "≤", ge: "≥", sub: "⊂", sup: "⊃", nsub: "⊄", sube: "⊆", supe: "⊇", oplus: "⊕", otimes: "⊗", perp: "⊥", sdot: "⋅", lceil: "⌈", rceil: "⌉", lfloor: "⌊", rfloor: "⌋", lang: "〈", rang: "〉", loz: "◊", spades: "♠", clubs: "♣", hearts: "♥", diams: "♦" }, ft = b`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: (e3) => {
    let { openingTagName: t3 } = e3;
    return `Expected corresponding JSX closing tag for <${t3}>.`;
  }, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: (e3) => {
    let { unexpected: t3, HTMLEntity: r3 } = e3;
    return `Unexpected token \`${t3}\`. Did you mean \`${r3}\` or \`{'${t3}'}\`?`;
  }, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
  function ht(e3) {
    return !!e3 && ("JSXOpeningFragment" === e3.type || "JSXClosingFragment" === e3.type);
  }
  function mt(e3) {
    if ("JSXIdentifier" === e3.type) return e3.name;
    if ("JSXNamespacedName" === e3.type) return e3.namespace.name + ":" + e3.name.name;
    if ("JSXMemberExpression" === e3.type) return mt(e3.object) + "." + mt(e3.property);
    throw new Error("Node had unexpected type: " + e3.type);
  }
  class yt extends ge {
    constructor() {
      super(...arguments), this.tsNames = /* @__PURE__ */ new Map();
    }
  }
  class gt extends be {
    constructor() {
      super(...arguments), this.importsStack = [];
    }
    createScope(e3) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new yt(e3);
    }
    enter(e3) {
      256 == e3 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e3);
    }
    exit() {
      const e3 = super.exit();
      return 256 == e3 && this.importsStack.pop(), e3;
    }
    hasImport(e3, t3) {
      const r3 = this.importsStack.length;
      if (this.importsStack[r3 - 1].has(e3)) return true;
      if (!t3 && r3 > 1) {
        for (let t4 = 0; t4 < r3 - 1; t4++) if (this.importsStack[t4].has(e3)) return true;
      }
      return false;
    }
    declareName(e3, t3, r3) {
      if (4096 & t3) return this.hasImport(e3, true) && this.parser.raise(v.VarRedeclaration, r3, { identifierName: e3 }), void this.importsStack[this.importsStack.length - 1].add(e3);
      const n3 = this.currentScope();
      let s3 = n3.tsNames.get(e3) || 0;
      if (1024 & t3) return this.maybeExportDefined(n3, e3), void n3.tsNames.set(e3, 16 | s3);
      super.declareName(e3, t3, r3), 2 & t3 && (1 & t3 || (this.checkRedeclarationInScope(n3, e3, t3, r3), this.maybeExportDefined(n3, e3)), s3 |= 1), 256 & t3 && (s3 |= 2), 512 & t3 && (s3 |= 4), 128 & t3 && (s3 |= 8), s3 && n3.tsNames.set(e3, s3);
    }
    isRedeclaredInScope(e3, t3, r3) {
      const n3 = e3.tsNames.get(t3);
      return (2 & n3) > 0 ? !(256 & r3) || !!(512 & r3) != (4 & n3) > 0 : 128 & r3 && (8 & n3) > 0 ? !!(2 & e3.names.get(t3)) && !!(1 & r3) : !!(2 & r3 && (1 & n3) > 0) || super.isRedeclaredInScope(e3, t3, r3);
    }
    checkLocalExport(e3) {
      const { name: t3 } = e3;
      if (!this.hasImport(t3)) {
        for (let e4 = this.scopeStack.length - 1; e4 >= 0; e4--) {
          const r3 = this.scopeStack[e4].tsNames.get(t3);
          if ((1 & r3) > 0 || (16 & r3) > 0) return;
        }
        super.checkLocalExport(e3);
      }
    }
  }
  const bt = (e3) => "ParenthesizedExpression" === e3.type ? bt(e3.expression) : e3;
  class vt extends ot {
    toAssignable(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      var r3, n3;
      let s3;
      switch (("ParenthesizedExpression" === e3.type || null != (r3 = e3.extra) && r3.parenthesized) && (s3 = bt(e3), t3 ? "Identifier" === s3.type ? this.expressionScope.recordArrowParameterBindingError(v.InvalidParenthesizedAssignment, e3) : "MemberExpression" === s3.type || this.isOptionalMemberExpression(s3) || this.raise(v.InvalidParenthesizedAssignment, e3) : this.raise(v.InvalidParenthesizedAssignment, e3)), e3.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e3.type = "ObjectPattern";
          for (let r4 = 0, n4 = e3.properties.length, s4 = n4 - 1; r4 < n4; r4++) {
            var i3;
            const n5 = e3.properties[r4], o3 = r4 === s4;
            this.toAssignableObjectExpressionProp(n5, o3, t3), o3 && "RestElement" === n5.type && null != (i3 = e3.extra) && i3.trailingCommaLoc && this.raise(v.RestTrailingComma, e3.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          const { key: r4, value: n4 } = e3;
          this.isPrivateName(r4) && this.classScope.usePrivateName(this.getPrivateNameSV(r4), r4.loc.start), this.toAssignable(n4, t3);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          e3.type = "ArrayPattern", this.toAssignableList(e3.elements, null == (n3 = e3.extra) ? void 0 : n3.trailingCommaLoc, t3);
          break;
        case "AssignmentExpression":
          "=" !== e3.operator && this.raise(v.MissingEqInAssignment, e3.left.loc.end), e3.type = "AssignmentPattern", delete e3.operator, this.toAssignable(e3.left, t3);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(s3, t3);
      }
    }
    toAssignableObjectExpressionProp(e3, t3, r3) {
      if ("ObjectMethod" === e3.type) this.raise("get" === e3.kind || "set" === e3.kind ? v.PatternHasAccessor : v.PatternHasMethod, e3.key);
      else if ("SpreadElement" === e3.type) {
        e3.type = "RestElement";
        const n3 = e3.argument;
        this.checkToRestConversion(n3, false), this.toAssignable(n3, r3), t3 || this.raise(v.RestTrailingComma, e3);
      } else this.toAssignable(e3, r3);
    }
    toAssignableList(e3, t3, r3) {
      const n3 = e3.length - 1;
      for (let s3 = 0; s3 <= n3; s3++) {
        const i3 = e3[s3];
        if (i3) {
          if ("SpreadElement" === i3.type) {
            i3.type = "RestElement";
            const e4 = i3.argument;
            this.checkToRestConversion(e4, true), this.toAssignable(e4, r3);
          } else this.toAssignable(i3, r3);
          "RestElement" === i3.type && (s3 < n3 ? this.raise(v.RestTrailingComma, i3) : t3 && this.raise(v.RestTrailingComma, t3));
        }
      }
    }
    isAssignable(e3, t3) {
      switch (e3.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;
        case "ObjectExpression": {
          const t4 = e3.properties.length - 1;
          return e3.properties.every((e4, r3) => "ObjectMethod" !== e4.type && (r3 === t4 || "SpreadElement" !== e4.type) && this.isAssignable(e4));
        }
        case "ObjectProperty":
          return this.isAssignable(e3.value);
        case "SpreadElement":
          return this.isAssignable(e3.argument);
        case "ArrayExpression":
          return e3.elements.every((e4) => null === e4 || this.isAssignable(e4));
        case "AssignmentExpression":
          return "=" === e3.operator;
        case "ParenthesizedExpression":
          return this.isAssignable(e3.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !t3;
        default:
          return false;
      }
    }
    toReferencedList(e3, t3) {
      return e3;
    }
    toReferencedListDeep(e3, t3) {
      this.toReferencedList(e3, t3);
      for (const t4 of e3) "ArrayExpression" === (null == t4 ? void 0 : t4.type) && this.toReferencedListDeep(t4.elements);
    }
    parseSpread(e3) {
      const t3 = this.startNode();
      return this.next(), t3.argument = this.parseMaybeAssignAllowIn(e3, void 0), this.finishNode(t3, "SpreadElement");
    }
    parseRestBinding() {
      const e3 = this.startNode();
      return this.next(), e3.argument = this.parseBindingAtom(), this.finishNode(e3, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const e3 = this.startNode();
          return this.next(), e3.elements = this.parseBindingList(3, 93, 1), this.finishNode(e3, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, true);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e3, t3, r3) {
      const n3 = 1 & r3, s3 = [];
      let i3 = true;
      for (; !this.eat(e3); ) if (i3 ? i3 = false : this.expect(12), n3 && this.match(12)) s3.push(null);
      else {
        if (this.eat(e3)) break;
        if (this.match(21)) {
          if (s3.push(this.parseAssignableListItemTypes(this.parseRestBinding(), r3)), !this.checkCommaAfterRest(t3)) {
            this.expect(e3);
            break;
          }
        } else {
          const e4 = [];
          for (this.match(26) && this.hasPlugin("decorators") && this.raise(v.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) e4.push(this.parseDecorator());
          s3.push(this.parseAssignableListItem(r3, e4));
        }
      }
      return s3;
    }
    parseBindingRestProperty(e3) {
      return this.next(), e3.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e3, "RestElement");
    }
    parseBindingProperty() {
      const e3 = this.startNode(), { type: t3, startLoc: r3 } = this.state;
      return 21 === t3 ? this.parseBindingRestProperty(e3) : (138 === t3 ? (this.expectPlugin("destructuringPrivate", r3), this.classScope.usePrivateName(this.state.value, r3), e3.key = this.parsePrivateName()) : this.parsePropertyName(e3), e3.method = false, this.parseObjPropValue(e3, r3, false, false, true, false));
    }
    parseAssignableListItem(e3, t3) {
      const r3 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(r3, e3);
      const n3 = this.parseMaybeDefault(r3.loc.start, r3);
      return t3.length && (r3.decorators = t3), n3;
    }
    parseAssignableListItemTypes(e3, t3) {
      return e3;
    }
    parseMaybeDefault(e3, t3) {
      var r3;
      if (null != e3 || (e3 = this.state.startLoc), t3 = null != (r3 = t3) ? r3 : this.parseBindingAtom(), !this.eat(29)) return t3;
      const n3 = this.startNodeAt(e3);
      return n3.left = t3, n3.right = this.parseMaybeAssignAllowIn(), this.finishNode(n3, "AssignmentPattern");
    }
    isValidLVal(e3, t3, r3) {
      return n3 = { AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, s3 = e3, Object.hasOwnProperty.call(n3, s3) && n3[s3];
      var n3, s3;
    }
    isOptionalMemberExpression(e3) {
      return "OptionalMemberExpression" === e3.type;
    }
    checkLVal(e3, t3) {
      let { in: r3, binding: n3 = 64, checkClashes: s3 = false, strictModeChanged: i3 = false, hasParenthesizedAncestor: o3 = false } = t3;
      var a3;
      const l2 = e3.type;
      if (this.isObjectMethod(e3)) return;
      const c2 = this.isOptionalMemberExpression(e3);
      if (c2 || "MemberExpression" === l2) return c2 && (this.expectPlugin("optionalChainingAssign", e3.loc.start), "AssignmentExpression" !== r3.type && this.raise(v.InvalidLhsOptionalChaining, e3, { ancestor: r3 })), void (64 !== n3 && this.raise(v.InvalidPropertyBindingPattern, e3));
      if ("Identifier" === l2) {
        this.checkIdentifier(e3, n3, i3);
        const { name: t4 } = e3;
        return void (s3 && (s3.has(t4) ? this.raise(v.ParamDupe, e3) : s3.add(t4)));
      }
      const u2 = this.isValidLVal(l2, !(o3 || null != (a3 = e3.extra) && a3.parenthesized) && "AssignmentExpression" === r3.type, n3);
      if (true === u2) return;
      if (false === u2) {
        const t4 = 64 === n3 ? v.InvalidLhs : v.InvalidLhsBinding;
        return void this.raise(t4, e3, { ancestor: r3 });
      }
      const [p2, d2] = Array.isArray(u2) ? u2 : [u2, "ParenthesizedExpression" === l2], f2 = "ArrayPattern" === l2 || "ObjectPattern" === l2 ? { type: l2 } : r3;
      for (const t4 of [].concat(e3[p2])) t4 && this.checkLVal(t4, { in: f2, binding: n3, checkClashes: s3, strictModeChanged: i3, hasParenthesizedAncestor: d2 });
    }
    checkIdentifier(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      this.state.strict && (r3 ? me(e3.name, this.inModule) : he(e3.name)) && (64 === t3 ? this.raise(v.StrictEvalArguments, e3, { referenceName: e3.name }) : this.raise(v.StrictEvalArgumentsBinding, e3, { bindingName: e3.name })), 8192 & t3 && "let" === e3.name && this.raise(v.LetInLexicalBinding, e3), 64 & t3 || this.declareNameFromIdentifier(e3, t3);
    }
    declareNameFromIdentifier(e3, t3) {
      this.scope.declareName(e3.name, t3, e3.loc.start);
    }
    checkToRestConversion(e3, t3) {
      switch (e3.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e3.expression, t3);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (t3) break;
        default:
          this.raise(v.InvalidRestAssignmentPattern, e3);
      }
    }
    checkCommaAfterRest(e3) {
      return !!this.match(12) && (this.raise(this.lookaheadCharCode() === e3 ? v.RestTrailingComma : v.ElementAfterRest, this.state.startLoc), true);
    }
  }
  function Et(e3) {
    if (!e3) throw new Error("Assert fail");
  }
  const St = b`typescript`({ AbstractMethodHasImplementation: (e3) => {
    let { methodName: t3 } = e3;
    return `Method '${t3}' cannot have an implementation because it is marked abstract.`;
  }, AbstractPropertyHasInitializer: (e3) => {
    let { propertyName: t3 } = e3;
    return `Property '${t3}' cannot have an initializer because it is marked abstract.`;
  }, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: (e3) => {
    let { kind: t3 } = e3;
    return `'declare' is not allowed in ${t3}ters.`;
  }, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: (e3) => {
    let { modifier: t3 } = e3;
    return "Accessibility modifier already seen.";
  }, DuplicateModifier: (e3) => {
    let { modifier: t3 } = e3;
    return `Duplicate modifier: '${t3}'.`;
  }, EmptyHeritageClauseType: (e3) => {
    let { token: t3 } = e3;
    return `'${t3}' list cannot be empty.`;
  }, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: (e3) => {
    let { modifiers: t3 } = e3;
    return `'${t3[0]}' modifier cannot be used with '${t3[1]}' modifier.`;
  }, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: (e3) => {
    let { modifier: t3 } = e3;
    return `Index signatures cannot have an accessibility modifier ('${t3}').`;
  }, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: (e3) => {
    let { modifier: t3 } = e3;
    return `'${t3}' modifier cannot appear on a type member.`;
  }, InvalidModifierOnTypeParameter: (e3) => {
    let { modifier: t3 } = e3;
    return `'${t3}' modifier cannot appear on a type parameter.`;
  }, InvalidModifierOnTypeParameterPositions: (e3) => {
    let { modifier: t3 } = e3;
    return `'${t3}' modifier can only appear on a type parameter of a class, interface or type alias.`;
  }, InvalidModifiersOrder: (e3) => {
    let { orderedModifiers: t3 } = e3;
    return `'${t3[0]}' modifier must precede '${t3[1]}' modifier.`;
  }, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: (e3) => {
    let { modifier: t3 } = e3;
    return `Private elements cannot have an accessibility modifier ('${t3}').`;
  }, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: (e3) => {
    let { typeParameterName: t3 } = e3;
    return `Single type parameter ${t3} should have a trailing comma. Example usage: <${t3},>.`;
  }, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: (e3) => {
    let { type: t3 } = e3;
    return `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t3}.`;
  } });
  function xt(e3) {
    return "private" === e3 || "public" === e3 || "protected" === e3;
  }
  function Tt(e3) {
    return "in" === e3 || "out" === e3;
  }
  function wt(e3) {
    if ("MemberExpression" !== e3.type) return false;
    const { computed: t3, property: r3 } = e3;
    return (!t3 || "StringLiteral" === r3.type || !("TemplateLiteral" !== r3.type || r3.expressions.length > 0)) && Ct(e3.object);
  }
  function Pt(e3, t3) {
    var r3;
    const { type: n3 } = e3;
    if (null != (r3 = e3.extra) && r3.parenthesized) return false;
    if (t3) {
      if ("Literal" === n3) {
        const { value: t4 } = e3;
        if ("string" == typeof t4 || "boolean" == typeof t4) return true;
      }
    } else if ("StringLiteral" === n3 || "BooleanLiteral" === n3) return true;
    return !(!At(e3, t3) && !function(e4, t4) {
      if ("UnaryExpression" === e4.type) {
        const { operator: r4, argument: n4 } = e4;
        if ("-" === r4 && At(n4, t4)) return true;
      }
      return false;
    }(e3, t3)) || "TemplateLiteral" === n3 && 0 === e3.expressions.length || !!wt(e3);
  }
  function At(e3, t3) {
    return t3 ? "Literal" === e3.type && ("number" == typeof e3.value || "bigint" in e3) : "NumericLiteral" === e3.type || "BigIntLiteral" === e3.type;
  }
  function Ct(e3) {
    return "Identifier" === e3.type || "MemberExpression" === e3.type && !e3.computed && Ct(e3.object);
  }
  const Ot = b`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." });
  function It(e3, t3) {
    const [r3, n3] = "string" == typeof t3 ? [t3, {}] : t3, s3 = Object.keys(n3), i3 = 0 === s3.length;
    return e3.some((e4) => {
      if ("string" == typeof e4) return i3 && e4 === r3;
      {
        const [t4, i4] = e4;
        if (t4 !== r3) return false;
        for (const e5 of s3) if (i4[e5] !== n3[e5]) return false;
        return true;
      }
    });
  }
  function _t(e3, t3, r3) {
    const n3 = e3.find((e4) => Array.isArray(e4) ? e4[0] === t3 : e4 === t3);
    return n3 && Array.isArray(n3) && n3.length > 1 ? n3[1][r3] : null;
  }
  const kt = ["minimal", "fsharp", "hack", "smart"], Nt = ["^^", "@@", "^", "%", "#"], Dt = ["hash", "bar"], jt = { estree: (e3) => class extends e3 {
    parse() {
      const e4 = x(super.parse());
      return this.options.tokens && (e4.tokens = e4.tokens.map(x)), e4;
    }
    parseRegExpLiteral(e4) {
      let { pattern: t3, flags: r3 } = e4, n3 = null;
      try {
        n3 = new RegExp(t3, r3);
      } catch (e5) {
      }
      const s3 = this.estreeParseLiteral(n3);
      return s3.regex = { pattern: t3, flags: r3 }, s3;
    }
    parseBigIntLiteral(e4) {
      let t3;
      try {
        t3 = BigInt(e4);
      } catch (e5) {
        t3 = null;
      }
      const r3 = this.estreeParseLiteral(t3);
      return r3.bigint = String(r3.value || e4), r3;
    }
    parseDecimalLiteral(e4) {
      const t3 = this.estreeParseLiteral(null);
      return t3.decimal = String(t3.value || e4), t3;
    }
    estreeParseLiteral(e4) {
      return this.parseLiteral(e4, "Literal");
    }
    parseStringLiteral(e4) {
      return this.estreeParseLiteral(e4);
    }
    parseNumericLiteral(e4) {
      return this.estreeParseLiteral(e4);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(e4) {
      return this.estreeParseLiteral(e4);
    }
    directiveToStmt(e4) {
      const t3 = e4.value;
      delete e4.value, t3.type = "Literal", t3.raw = t3.extra.raw, t3.value = t3.extra.expressionValue;
      const r3 = e4;
      return r3.type = "ExpressionStatement", r3.expression = t3, r3.directive = t3.extra.rawValue, delete t3.extra, r3;
    }
    initFunction(e4, t3) {
      super.initFunction(e4, t3), e4.expression = false;
    }
    checkDeclaration(e4) {
      null != e4 && this.isObjectProperty(e4) ? this.checkDeclaration(e4.value) : super.checkDeclaration(e4);
    }
    getObjectOrClassMethodParams(e4) {
      return e4.value.params;
    }
    isValidDirective(e4) {
      var t3;
      return "ExpressionStatement" === e4.type && "Literal" === e4.expression.type && "string" == typeof e4.expression.value && !(null != (t3 = e4.expression.extra) && t3.parenthesized);
    }
    parseBlockBody(e4, t3, r3, n3, s3) {
      super.parseBlockBody(e4, t3, r3, n3, s3);
      const i3 = e4.directives.map((e5) => this.directiveToStmt(e5));
      e4.body = i3.concat(e4.body), delete e4.directives;
    }
    pushClassMethod(e4, t3, r3, n3, s3, i3) {
      this.parseMethod(t3, r3, n3, s3, i3, "ClassMethod", true), t3.typeParameters && (t3.value.typeParameters = t3.typeParameters, delete t3.typeParameters), e4.body.push(t3);
    }
    parsePrivateName() {
      const e4 = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e4) : e4;
    }
    convertPrivateNameToPrivateIdentifier(e4) {
      const t3 = super.getPrivateNameSV(e4);
      return delete e4.id, e4.name = t3, e4.type = "PrivateIdentifier", e4;
    }
    isPrivateName(e4) {
      return this.getPluginOption("estree", "classFeatures") ? "PrivateIdentifier" === e4.type : super.isPrivateName(e4);
    }
    getPrivateNameSV(e4) {
      return this.getPluginOption("estree", "classFeatures") ? e4.name : super.getPrivateNameSV(e4);
    }
    parseLiteral(e4, t3) {
      const r3 = super.parseLiteral(e4, t3);
      return r3.raw = r3.extra.raw, delete r3.extra, r3;
    }
    parseFunctionBody(e4, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      super.parseFunctionBody(e4, t3, r3), e4.expression = "BlockStatement" !== e4.body.type;
    }
    parseMethod(e4, t3, r3, n3, s3, i3) {
      let o3 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], a3 = this.startNode();
      return a3.kind = e4.kind, a3 = super.parseMethod(a3, t3, r3, n3, s3, i3, o3), a3.type = "FunctionExpression", delete a3.kind, e4.value = a3, "ClassPrivateMethod" === i3 && (e4.computed = false), this.finishNode(e4, "MethodDefinition");
    }
    parseClassProperty() {
      const e4 = super.parseClassProperty(...arguments);
      return this.getPluginOption("estree", "classFeatures") ? (e4.type = "PropertyDefinition", e4) : e4;
    }
    parseClassPrivateProperty() {
      const e4 = super.parseClassPrivateProperty(...arguments);
      return this.getPluginOption("estree", "classFeatures") ? (e4.type = "PropertyDefinition", e4.computed = false, e4) : e4;
    }
    parseObjectMethod(e4, t3, r3, n3, s3) {
      const i3 = super.parseObjectMethod(e4, t3, r3, n3, s3);
      return i3 && (i3.type = "Property", "method" === i3.kind && (i3.kind = "init"), i3.shorthand = false), i3;
    }
    parseObjectProperty(e4, t3, r3, n3) {
      const s3 = super.parseObjectProperty(e4, t3, r3, n3);
      return s3 && (s3.kind = "init", s3.type = "Property"), s3;
    }
    isValidLVal(e4, t3, r3) {
      return "Property" === e4 ? "value" : super.isValidLVal(e4, t3, r3);
    }
    isAssignable(e4, t3) {
      return null != e4 && this.isObjectProperty(e4) ? this.isAssignable(e4.value, t3) : super.isAssignable(e4, t3);
    }
    toAssignable(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      if (null != e4 && this.isObjectProperty(e4)) {
        const { key: r3, value: n3 } = e4;
        this.isPrivateName(r3) && this.classScope.usePrivateName(this.getPrivateNameSV(r3), r3.loc.start), this.toAssignable(n3, t3);
      } else super.toAssignable(e4, t3);
    }
    toAssignableObjectExpressionProp(e4, t3, r3) {
      "get" === e4.kind || "set" === e4.kind ? this.raise(v.PatternHasAccessor, e4.key) : e4.method ? this.raise(v.PatternHasMethod, e4.key) : super.toAssignableObjectExpressionProp(e4, t3, r3);
    }
    finishCallExpression(e4, t3) {
      const r3 = super.finishCallExpression(e4, t3);
      var n3, s3;
      "Import" === r3.callee.type && (r3.type = "ImportExpression", r3.source = r3.arguments[0], (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r3.options = null != (n3 = r3.arguments[1]) ? n3 : null, r3.attributes = null != (s3 = r3.arguments[1]) ? s3 : null), delete r3.arguments, delete r3.callee);
      return r3;
    }
    toReferencedArguments(e4) {
      "ImportExpression" !== e4.type && super.toReferencedArguments(e4);
    }
    parseExport(e4, t3) {
      const r3 = this.state.lastTokStartLoc, n3 = super.parseExport(e4, t3);
      switch (n3.type) {
        case "ExportAllDeclaration":
          n3.exported = null;
          break;
        case "ExportNamedDeclaration":
          1 === n3.specifiers.length && "ExportNamespaceSpecifier" === n3.specifiers[0].type && (n3.type = "ExportAllDeclaration", n3.exported = n3.specifiers[0].exported, delete n3.specifiers);
        case "ExportDefaultDeclaration": {
          var s3;
          const { declaration: e5 } = n3;
          "ClassDeclaration" === (null == e5 ? void 0 : e5.type) && (null == (s3 = e5.decorators) ? void 0 : s3.length) > 0 && e5.start === n3.start && this.resetStartLocation(n3, r3);
        }
      }
      return n3;
    }
    parseSubscript(e4, t3, r3, n3) {
      const s3 = super.parseSubscript(e4, t3, r3, n3);
      if (n3.optionalChainMember) {
        if ("OptionalMemberExpression" !== s3.type && "OptionalCallExpression" !== s3.type || (s3.type = s3.type.substring(8)), n3.stop) {
          const e5 = this.startNodeAtNode(s3);
          return e5.expression = s3, this.finishNode(e5, "ChainExpression");
        }
      } else "MemberExpression" !== s3.type && "CallExpression" !== s3.type || (s3.optional = false);
      return s3;
    }
    isOptionalMemberExpression(e4) {
      return "ChainExpression" === e4.type ? "MemberExpression" === e4.expression.type : super.isOptionalMemberExpression(e4);
    }
    hasPropertyAsPrivateName(e4) {
      return "ChainExpression" === e4.type && (e4 = e4.expression), super.hasPropertyAsPrivateName(e4);
    }
    isObjectProperty(e4) {
      return "Property" === e4.type && "init" === e4.kind && !e4.method;
    }
    isObjectMethod(e4) {
      return e4.method || "get" === e4.kind || "set" === e4.kind;
    }
    finishNodeAt(e4, t3, r3) {
      return x(super.finishNodeAt(e4, t3, r3));
    }
    resetStartLocation(e4, t3) {
      super.resetStartLocation(e4, t3), x(e4);
    }
    resetEndLocation(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state.lastTokEndLoc;
      super.resetEndLocation(e4, t3), x(e4);
    }
  }, jsx: (e3) => class extends e3 {
    jsxReadToken() {
      let e4 = "", t3 = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length) throw this.raise(ft.UnterminatedJsxContent, this.state.startLoc);
        const r3 = this.input.charCodeAt(this.state.pos);
        switch (r3) {
          case 60:
          case 123:
            return this.state.pos === this.state.start ? void (60 === r3 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(r3)) : (e4 += this.input.slice(t3, this.state.pos), void this.finishToken(141, e4));
          case 38:
            e4 += this.input.slice(t3, this.state.pos), e4 += this.jsxReadEntity(), t3 = this.state.pos;
            break;
          default:
            Oe(r3) ? (e4 += this.input.slice(t3, this.state.pos), e4 += this.jsxReadNewLine(true), t3 = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(e4) {
      const t3 = this.input.charCodeAt(this.state.pos);
      let r3;
      return ++this.state.pos, 13 === t3 && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, r3 = e4 ? "\n" : "\r\n") : r3 = String.fromCharCode(t3), ++this.state.curLine, this.state.lineStart = this.state.pos, r3;
    }
    jsxReadString(e4) {
      let t3 = "", r3 = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length) throw this.raise(v.UnterminatedString, this.state.startLoc);
        const n3 = this.input.charCodeAt(this.state.pos);
        if (n3 === e4) break;
        38 === n3 ? (t3 += this.input.slice(r3, this.state.pos), t3 += this.jsxReadEntity(), r3 = this.state.pos) : Oe(n3) ? (t3 += this.input.slice(r3, this.state.pos), t3 += this.jsxReadNewLine(false), r3 = this.state.pos) : ++this.state.pos;
      }
      t3 += this.input.slice(r3, this.state.pos++), this.finishToken(133, t3);
    }
    jsxReadEntity() {
      const e4 = ++this.state.pos;
      if (35 === this.codePointAtPos(this.state.pos)) {
        ++this.state.pos;
        let e5 = 10;
        120 === this.codePointAtPos(this.state.pos) && (e5 = 16, ++this.state.pos);
        const t3 = this.readInt(e5, void 0, false, "bail");
        if (null !== t3 && 59 === this.codePointAtPos(this.state.pos)) return ++this.state.pos, String.fromCodePoint(t3);
      } else {
        let t3 = 0, r3 = false;
        for (; t3++ < 10 && this.state.pos < this.length && !(r3 = 59 == this.codePointAtPos(this.state.pos)); ) ++this.state.pos;
        if (r3) {
          const t4 = this.input.slice(e4, this.state.pos), r4 = dt[t4];
          if (++this.state.pos, r4) return r4;
        }
      }
      return this.state.pos = e4, "&";
    }
    jsxReadWord() {
      let e4;
      const t3 = this.state.pos;
      do {
        e4 = this.input.charCodeAt(++this.state.pos);
      } while (le(e4) || 45 === e4);
      this.finishToken(140, this.input.slice(t3, this.state.pos));
    }
    jsxParseIdentifier() {
      const e4 = this.startNode();
      return this.match(140) ? e4.name = this.state.value : X(this.state.type) ? e4.name = J(this.state.type) : this.unexpected(), this.next(), this.finishNode(e4, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const e4 = this.state.startLoc, t3 = this.jsxParseIdentifier();
      if (!this.eat(14)) return t3;
      const r3 = this.startNodeAt(e4);
      return r3.namespace = t3, r3.name = this.jsxParseIdentifier(), this.finishNode(r3, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const e4 = this.state.startLoc;
      let t3 = this.jsxParseNamespacedName();
      if ("JSXNamespacedName" === t3.type) return t3;
      for (; this.eat(16); ) {
        const r3 = this.startNodeAt(e4);
        r3.object = t3, r3.property = this.jsxParseIdentifier(), t3 = this.finishNode(r3, "JSXMemberExpression");
      }
      return t3;
    }
    jsxParseAttributeValue() {
      let e4;
      switch (this.state.type) {
        case 5:
          return e4 = this.startNode(), this.setContext(w.brace), this.next(), e4 = this.jsxParseExpressionContainer(e4, w.j_oTag), "JSXEmptyExpression" === e4.expression.type && this.raise(ft.AttributeIsEmpty, e4), e4;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(ft.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      const e4 = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(e4, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(e4) {
      return this.next(), e4.expression = this.parseExpression(), this.setContext(w.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e4, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(e4, t3) {
      if (this.match(8)) e4.expression = this.jsxParseEmptyExpression();
      else {
        const t4 = this.parseExpression();
        e4.expression = t4;
      }
      return this.setContext(t3), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e4, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const e4 = this.startNode();
      return this.match(5) ? (this.setContext(w.brace), this.next(), this.expect(21), e4.argument = this.parseMaybeAssignAllowIn(), this.setContext(w.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e4, "JSXSpreadAttribute")) : (e4.name = this.jsxParseNamespacedName(), e4.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e4, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(e4) {
      const t3 = this.startNodeAt(e4);
      return this.eat(143) ? this.finishNode(t3, "JSXOpeningFragment") : (t3.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(t3));
    }
    jsxParseOpeningElementAfterName(e4) {
      const t3 = [];
      for (; !this.match(56) && !this.match(143); ) t3.push(this.jsxParseAttribute());
      return e4.attributes = t3, e4.selfClosing = this.eat(56), this.expect(143), this.finishNode(e4, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(e4) {
      const t3 = this.startNodeAt(e4);
      return this.eat(143) ? this.finishNode(t3, "JSXClosingFragment") : (t3.name = this.jsxParseElementName(), this.expect(143), this.finishNode(t3, "JSXClosingElement"));
    }
    jsxParseElementAt(e4) {
      const t3 = this.startNodeAt(e4), r3 = [], n3 = this.jsxParseOpeningElementAt(e4);
      let s3 = null;
      if (!n3.selfClosing) {
        e: for (; ; ) switch (this.state.type) {
          case 142:
            if (e4 = this.state.startLoc, this.next(), this.eat(56)) {
              s3 = this.jsxParseClosingElementAt(e4);
              break e;
            }
            r3.push(this.jsxParseElementAt(e4));
            break;
          case 141:
            r3.push(this.parseExprAtom());
            break;
          case 5: {
            const e5 = this.startNode();
            this.setContext(w.brace), this.next(), this.match(21) ? r3.push(this.jsxParseSpreadChild(e5)) : r3.push(this.jsxParseExpressionContainer(e5, w.j_expr));
            break;
          }
          default:
            this.unexpected();
        }
        ht(n3) && !ht(s3) && null !== s3 ? this.raise(ft.MissingClosingTagFragment, s3) : !ht(n3) && ht(s3) ? this.raise(ft.MissingClosingTagElement, s3, { openingTagName: mt(n3.name) }) : ht(n3) || ht(s3) || mt(s3.name) !== mt(n3.name) && this.raise(ft.MissingClosingTagElement, s3, { openingTagName: mt(n3.name) });
      }
      if (ht(n3) ? (t3.openingFragment = n3, t3.closingFragment = s3) : (t3.openingElement = n3, t3.closingElement = s3), t3.children = r3, this.match(47)) throw this.raise(ft.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return ht(n3) ? this.finishNode(t3, "JSXFragment") : this.finishNode(t3, "JSXElement");
    }
    jsxParseElement() {
      const e4 = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(e4);
    }
    setContext(e4) {
      const { context: t3 } = this.state;
      t3[t3.length - 1] = e4;
    }
    parseExprAtom(e4) {
      return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(e4);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(e4) {
      const t3 = this.curContext();
      if (t3 !== w.j_expr) {
        if (t3 === w.j_oTag || t3 === w.j_cTag) {
          if (ae(e4)) return void this.jsxReadWord();
          if (62 === e4) return ++this.state.pos, void this.finishToken(143);
          if ((34 === e4 || 39 === e4) && t3 === w.j_oTag) return void this.jsxReadString(e4);
        }
        if (60 === e4 && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1)) return ++this.state.pos, void this.finishToken(142);
        super.getTokenFromCode(e4);
      } else this.jsxReadToken();
    }
    updateContext(e4) {
      const { context: t3, type: r3 } = this.state;
      if (56 === r3 && 142 === e4) t3.splice(-2, 2, w.j_cTag), this.state.canStartJSXElement = false;
      else if (142 === r3) t3.push(w.j_oTag);
      else if (143 === r3) {
        const r4 = t3[t3.length - 1];
        r4 === w.j_oTag && 56 === e4 || r4 === w.j_cTag ? (t3.pop(), this.state.canStartJSXElement = t3[t3.length - 1] === w.j_expr) : (this.setContext(w.j_expr), this.state.canStartJSXElement = true);
      } else this.state.canStartJSXElement = R[r3];
    }
  }, flow: (e3) => class extends e3 {
    constructor() {
      super(...arguments), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return Ee;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || "flow" === this.flowPragma;
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(e4, t3) {
      133 !== e4 && 13 !== e4 && 28 !== e4 && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(e4, t3);
    }
    addComment(e4) {
      if (void 0 === this.flowPragma) {
        const t3 = pt.exec(e4.value);
        if (t3) if ("flow" === t3[1]) this.flowPragma = "flow";
        else {
          if ("noflow" !== t3[1]) throw new Error("Unexpected flow pragma");
          this.flowPragma = "noflow";
        }
      }
      super.addComment(e4);
    }
    flowParseTypeInitialiser(e4) {
      const t3 = this.state.inType;
      this.state.inType = true, this.expect(e4 || 14);
      const r3 = this.flowParseType();
      return this.state.inType = t3, r3;
    }
    flowParsePredicate() {
      const e4 = this.startNode(), t3 = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > t3.index + 1 && this.raise(lt.UnexpectedSpaceBetweenModuloChecks, t3), this.eat(10) ? (e4.value = super.parseExpression(), this.expect(11), this.finishNode(e4, "DeclaredPredicate")) : this.finishNode(e4, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const e4 = this.state.inType;
      this.state.inType = true, this.expect(14);
      let t3 = null, r3 = null;
      return this.match(54) ? (this.state.inType = e4, r3 = this.flowParsePredicate()) : (t3 = this.flowParseType(), this.state.inType = e4, this.match(54) && (r3 = this.flowParsePredicate())), [t3, r3];
    }
    flowParseDeclareClass(e4) {
      return this.next(), this.flowParseInterfaceish(e4, true), this.finishNode(e4, "DeclareClass");
    }
    flowParseDeclareFunction(e4) {
      this.next();
      const t3 = e4.id = this.parseIdentifier(), r3 = this.startNode(), n3 = this.startNode();
      this.match(47) ? r3.typeParameters = this.flowParseTypeParameterDeclaration() : r3.typeParameters = null, this.expect(10);
      const s3 = this.flowParseFunctionTypeParams();
      return r3.params = s3.params, r3.rest = s3.rest, r3.this = s3._this, this.expect(11), [r3.returnType, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), n3.typeAnnotation = this.finishNode(r3, "FunctionTypeAnnotation"), t3.typeAnnotation = this.finishNode(n3, "TypeAnnotation"), this.resetEndLocation(t3), this.semicolon(), this.scope.declareName(e4.id.name, 2048, e4.id.loc.start), this.finishNode(e4, "DeclareFunction");
    }
    flowParseDeclare(e4, t3) {
      return this.match(80) ? this.flowParseDeclareClass(e4) : this.match(68) ? this.flowParseDeclareFunction(e4) : this.match(74) ? this.flowParseDeclareVariable(e4) : this.eatContextual(127) ? this.match(16) ? this.flowParseDeclareModuleExports(e4) : (t3 && this.raise(lt.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e4)) : this.isContextual(130) ? this.flowParseDeclareTypeAlias(e4) : this.isContextual(131) ? this.flowParseDeclareOpaqueType(e4) : this.isContextual(129) ? this.flowParseDeclareInterface(e4) : this.match(82) ? this.flowParseDeclareExportDeclaration(e4, t3) : void this.unexpected();
    }
    flowParseDeclareVariable(e4) {
      return this.next(), e4.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e4.id.name, 5, e4.id.loc.start), this.semicolon(), this.finishNode(e4, "DeclareVariable");
    }
    flowParseDeclareModule(e4) {
      this.scope.enter(0), this.match(133) ? e4.id = super.parseExprAtom() : e4.id = this.parseIdentifier();
      const t3 = e4.body = this.startNode(), r3 = t3.body = [];
      for (this.expect(5); !this.match(8); ) {
        let e5 = this.startNode();
        this.match(83) ? (this.next(), this.isContextual(130) || this.match(87) || this.raise(lt.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(e5)) : (this.expectContextual(125, lt.UnsupportedStatementInDeclareModule), e5 = this.flowParseDeclare(e5, true)), r3.push(e5);
      }
      this.scope.exit(), this.expect(8), this.finishNode(t3, "BlockStatement");
      let n3 = null, s3 = false;
      return r3.forEach((e5) => {
        !function(e6) {
          return "DeclareExportAllDeclaration" === e6.type || "DeclareExportDeclaration" === e6.type && (!e6.declaration || "TypeAlias" !== e6.declaration.type && "InterfaceDeclaration" !== e6.declaration.type);
        }(e5) ? "DeclareModuleExports" === e5.type && (s3 && this.raise(lt.DuplicateDeclareModuleExports, e5), "ES" === n3 && this.raise(lt.AmbiguousDeclareModuleKind, e5), n3 = "CommonJS", s3 = true) : ("CommonJS" === n3 && this.raise(lt.AmbiguousDeclareModuleKind, e5), n3 = "ES");
      }), e4.kind = n3 || "CommonJS", this.finishNode(e4, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(e4, t3) {
      if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? e4.declaration = this.flowParseDeclare(this.startNode()) : (e4.declaration = this.flowParseType(), this.semicolon()), e4.default = true, this.finishNode(e4, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !t3) {
        const e5 = this.state.value;
        throw this.raise(lt.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: e5, suggestion: ut[e5] });
      }
      return this.match(74) || this.match(68) || this.match(80) || this.isContextual(131) ? (e4.declaration = this.flowParseDeclare(this.startNode()), e4.default = false, this.finishNode(e4, "DeclareExportDeclaration")) : this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131) ? ("ExportNamedDeclaration" === (e4 = this.parseExport(e4, null)).type && (e4.type = "ExportDeclaration", e4.default = false, delete e4.exportKind), e4.type = "Declare" + e4.type, e4) : void this.unexpected();
    }
    flowParseDeclareModuleExports(e4) {
      return this.next(), this.expectContextual(111), e4.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e4, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(e4) {
      this.next();
      const t3 = this.flowParseTypeAlias(e4);
      return t3.type = "DeclareTypeAlias", t3;
    }
    flowParseDeclareOpaqueType(e4) {
      this.next();
      const t3 = this.flowParseOpaqueType(e4, true);
      return t3.type = "DeclareOpaqueType", t3;
    }
    flowParseDeclareInterface(e4) {
      return this.next(), this.flowParseInterfaceish(e4, false), this.finishNode(e4, "DeclareInterface");
    }
    flowParseInterfaceish(e4, t3) {
      if (e4.id = this.flowParseRestrictedIdentifier(!t3, true), this.scope.declareName(e4.id.name, t3 ? 17 : 8201, e4.id.loc.start), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.extends = [], this.eat(81)) do {
        e4.extends.push(this.flowParseInterfaceExtends());
      } while (!t3 && this.eat(12));
      if (t3) {
        if (e4.implements = [], e4.mixins = [], this.eatContextual(117)) do {
          e4.mixins.push(this.flowParseInterfaceExtends());
        } while (this.eat(12));
        if (this.eatContextual(113)) do {
          e4.implements.push(this.flowParseInterfaceExtends());
        } while (this.eat(12));
      }
      e4.body = this.flowParseObjectType({ allowStatic: t3, allowExact: false, allowSpread: false, allowProto: t3, allowInexact: false });
    }
    flowParseInterfaceExtends() {
      const e4 = this.startNode();
      return e4.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterInstantiation() : e4.typeParameters = null, this.finishNode(e4, "InterfaceExtends");
    }
    flowParseInterface(e4) {
      return this.flowParseInterfaceish(e4, false), this.finishNode(e4, "InterfaceDeclaration");
    }
    checkNotUnderscore(e4) {
      "_" === e4 && this.raise(lt.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(e4, t3, r3) {
      at.has(e4) && this.raise(r3 ? lt.AssignReservedType : lt.UnexpectedReservedType, t3, { reservedType: e4 });
    }
    flowParseRestrictedIdentifier(e4, t3) {
      return this.checkReservedType(this.state.value, this.state.startLoc, t3), this.parseIdentifier(e4);
    }
    flowParseTypeAlias(e4) {
      return e4.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e4.id.name, 8201, e4.id.loc.start), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e4, "TypeAlias");
    }
    flowParseOpaqueType(e4, t3) {
      return this.expectContextual(130), e4.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e4.id.name, 8201, e4.id.loc.start), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.supertype = null, this.match(14) && (e4.supertype = this.flowParseTypeInitialiser(14)), e4.impltype = null, t3 || (e4.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e4, "OpaqueType");
    }
    flowParseTypeParameter() {
      let e4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      const t3 = this.state.startLoc, r3 = this.startNode(), n3 = this.flowParseVariance(), s3 = this.flowParseTypeAnnotatableIdentifier();
      return r3.name = s3.name, r3.variance = n3, r3.bound = s3.typeAnnotation, this.match(29) ? (this.eat(29), r3.default = this.flowParseType()) : e4 && this.raise(lt.MissingTypeParamDefault, t3), this.finishNode(r3, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const e4 = this.state.inType, t3 = this.startNode();
      t3.params = [], this.state.inType = true, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let r3 = false;
      do {
        const e5 = this.flowParseTypeParameter(r3);
        t3.params.push(e5), e5.default && (r3 = true), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = e4, this.finishNode(t3, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const e4 = this.startNode(), t3 = this.state.inType;
      e4.params = [], this.state.inType = true, this.expect(47);
      const r3 = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = false; !this.match(48); ) e4.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = r3, this.expect(48), this.state.inType = t3, this.finishNode(e4, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const e4 = this.startNode(), t3 = this.state.inType;
      for (e4.params = [], this.state.inType = true, this.expect(47); !this.match(48); ) e4.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = t3, this.finishNode(e4, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const e4 = this.startNode();
      if (this.expectContextual(129), e4.extends = [], this.eat(81)) do {
        e4.extends.push(this.flowParseInterfaceExtends());
      } while (this.eat(12));
      return e4.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e4, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(e4, t3, r3) {
      return e4.static = t3, 14 === this.lookahead().type ? (e4.id = this.flowParseObjectPropertyKey(), e4.key = this.flowParseTypeInitialiser()) : (e4.id = null, e4.key = this.flowParseType()), this.expect(3), e4.value = this.flowParseTypeInitialiser(), e4.variance = r3, this.finishNode(e4, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(e4, t3) {
      return e4.static = t3, e4.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e4.method = true, e4.optional = false, e4.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e4.loc.start))) : (e4.method = false, this.eat(17) && (e4.optional = true), e4.value = this.flowParseTypeInitialiser()), this.finishNode(e4, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(e4) {
      for (e4.params = [], e4.rest = null, e4.typeParameters = null, e4.this = null, this.match(47) && (e4.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e4.this = this.flowParseFunctionTypeParam(true), e4.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e4.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (e4.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e4.returnType = this.flowParseTypeInitialiser(), this.finishNode(e4, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(e4, t3) {
      const r3 = this.startNode();
      return e4.static = t3, e4.value = this.flowParseObjectTypeMethodish(r3), this.finishNode(e4, "ObjectTypeCallProperty");
    }
    flowParseObjectType(e4) {
      let { allowStatic: t3, allowExact: r3, allowSpread: n3, allowProto: s3, allowInexact: i3 } = e4;
      const o3 = this.state.inType;
      this.state.inType = true;
      const a3 = this.startNode();
      let l2, c2;
      a3.callProperties = [], a3.properties = [], a3.indexers = [], a3.internalSlots = [];
      let u2 = false;
      for (r3 && this.match(6) ? (this.expect(6), l2 = 9, c2 = true) : (this.expect(5), l2 = 8, c2 = false), a3.exact = c2; !this.match(l2); ) {
        let e5 = false, r4 = null, o4 = null;
        const l3 = this.startNode();
        if (s3 && this.isContextual(118)) {
          const e6 = this.lookahead();
          14 !== e6.type && 17 !== e6.type && (this.next(), r4 = this.state.startLoc, t3 = false);
        }
        if (t3 && this.isContextual(106)) {
          const t4 = this.lookahead();
          14 !== t4.type && 17 !== t4.type && (this.next(), e5 = true);
        }
        const p3 = this.flowParseVariance();
        if (this.eat(0)) null != r4 && this.unexpected(r4), this.eat(0) ? (p3 && this.unexpected(p3.loc.start), a3.internalSlots.push(this.flowParseObjectTypeInternalSlot(l3, e5))) : a3.indexers.push(this.flowParseObjectTypeIndexer(l3, e5, p3));
        else if (this.match(10) || this.match(47)) null != r4 && this.unexpected(r4), p3 && this.unexpected(p3.loc.start), a3.callProperties.push(this.flowParseObjectTypeCallProperty(l3, e5));
        else {
          let t4 = "init";
          (this.isContextual(99) || this.isContextual(104)) && H(this.lookahead().type) && (t4 = this.state.value, this.next());
          const s4 = this.flowParseObjectTypeProperty(l3, e5, r4, p3, t4, n3, null != i3 ? i3 : !c2);
          null === s4 ? (u2 = true, o4 = this.state.lastTokStartLoc) : a3.properties.push(s4);
        }
        this.flowObjectTypeSemicolon(), !o4 || this.match(8) || this.match(9) || this.raise(lt.UnexpectedExplicitInexactInObject, o4);
      }
      this.expect(l2), n3 && (a3.inexact = u2);
      const p2 = this.finishNode(a3, "ObjectTypeAnnotation");
      return this.state.inType = o3, p2;
    }
    flowParseObjectTypeProperty(e4, t3, r3, n3, s3, i3, o3) {
      if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (i3 ? o3 || this.raise(lt.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(lt.InexactInsideNonObject, this.state.lastTokStartLoc), n3 && this.raise(lt.InexactVariance, n3), null) : (i3 || this.raise(lt.UnexpectedSpreadType, this.state.lastTokStartLoc), null != r3 && this.unexpected(r3), n3 && this.raise(lt.SpreadVariance, n3), e4.argument = this.flowParseType(), this.finishNode(e4, "ObjectTypeSpreadProperty"));
      {
        e4.key = this.flowParseObjectPropertyKey(), e4.static = t3, e4.proto = null != r3, e4.kind = s3;
        let o4 = false;
        return this.match(47) || this.match(10) ? (e4.method = true, null != r3 && this.unexpected(r3), n3 && this.unexpected(n3.loc.start), e4.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e4.loc.start)), "get" !== s3 && "set" !== s3 || this.flowCheckGetterSetterParams(e4), !i3 && "constructor" === e4.key.name && e4.value.this && this.raise(lt.ThisParamBannedInConstructor, e4.value.this)) : ("init" !== s3 && this.unexpected(), e4.method = false, this.eat(17) && (o4 = true), e4.value = this.flowParseTypeInitialiser(), e4.variance = n3), e4.optional = o4, this.finishNode(e4, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(e4) {
      const t3 = "get" === e4.kind ? 0 : 1, r3 = e4.value.params.length + (e4.value.rest ? 1 : 0);
      e4.value.this && this.raise("get" === e4.kind ? lt.GetterMayNotHaveThisParam : lt.SetterMayNotHaveThisParam, e4.value.this), r3 !== t3 && this.raise("get" === e4.kind ? v.BadGetterArity : v.BadSetterArity, e4), "set" === e4.kind && e4.value.rest && this.raise(v.BadSetterRestParameter, e4);
    }
    flowObjectTypeSemicolon() {
      this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(e4, t3) {
      null != e4 || (e4 = this.state.startLoc);
      let r3 = t3 || this.flowParseRestrictedIdentifier(true);
      for (; this.eat(16); ) {
        const t4 = this.startNodeAt(e4);
        t4.qualification = r3, t4.id = this.flowParseRestrictedIdentifier(true), r3 = this.finishNode(t4, "QualifiedTypeIdentifier");
      }
      return r3;
    }
    flowParseGenericType(e4, t3) {
      const r3 = this.startNodeAt(e4);
      return r3.typeParameters = null, r3.id = this.flowParseQualifiedTypeIdentifier(e4, t3), this.match(47) && (r3.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r3, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const e4 = this.startNode();
      return this.expect(87), e4.argument = this.flowParsePrimaryType(), this.finishNode(e4, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const e4 = this.startNode();
      for (e4.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e4.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
      return this.expect(3), this.finishNode(e4, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(e4) {
      let t3 = null, r3 = false, n3 = null;
      const s3 = this.startNode(), i3 = this.lookahead(), o3 = 78 === this.state.type;
      return 14 === i3.type || 17 === i3.type ? (o3 && !e4 && this.raise(lt.ThisParamMustBeFirst, s3), t3 = this.parseIdentifier(o3), this.eat(17) && (r3 = true, o3 && this.raise(lt.ThisParamMayNotBeOptional, s3)), n3 = this.flowParseTypeInitialiser()) : n3 = this.flowParseType(), s3.name = t3, s3.optional = r3, s3.typeAnnotation = n3, this.finishNode(s3, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(e4) {
      const t3 = this.startNodeAt(e4.loc.start);
      return t3.name = null, t3.optional = false, t3.typeAnnotation = e4, this.finishNode(t3, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams() {
      let e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t3 = null, r3 = null;
      for (this.match(78) && (r3 = this.flowParseFunctionTypeParam(true), r3.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e4.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (t3 = this.flowParseFunctionTypeParam(false)), { params: e4, rest: t3, _this: r3 };
    }
    flowIdentToTypeAnnotation(e4, t3, r3) {
      switch (r3.name) {
        case "any":
          return this.finishNode(t3, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(t3, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(t3, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(t3, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(t3, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(t3, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(t3, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(r3.name), this.flowParseGenericType(e4, r3);
      }
    }
    flowParsePrimaryType() {
      const e4 = this.state.startLoc, t3 = this.startNode();
      let r3, n3, s3 = false;
      const i3 = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
        case 6:
          return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
        case 0:
          return this.state.noAnonFunctionType = false, n3 = this.flowParseTupleType(), this.state.noAnonFunctionType = i3, n3;
        case 47:
          return t3.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), r3 = this.flowParseFunctionTypeParams(), t3.params = r3.params, t3.rest = r3.rest, t3.this = r3._this, this.expect(11), this.expect(19), t3.returnType = this.flowParseType(), this.finishNode(t3, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21)) if (W(this.state.type) || this.match(78)) {
            const e5 = this.lookahead().type;
            s3 = 17 !== e5 && 14 !== e5;
          } else s3 = true;
          if (s3) {
            if (this.state.noAnonFunctionType = false, n3 = this.flowParseType(), this.state.noAnonFunctionType = i3, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && 19 === this.lookahead().type)) return this.expect(11), n3;
            this.eat(12);
          }
          return r3 = n3 ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(n3)]) : this.flowParseFunctionTypeParams(), t3.params = r3.params, t3.rest = r3.rest, t3.this = r3._this, this.expect(11), this.expect(19), t3.returnType = this.flowParseType(), t3.typeParameters = null, this.finishNode(t3, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return t3.value = this.match(85), this.next(), this.finishNode(t3, "BooleanLiteralTypeAnnotation");
        case 53:
          if ("-" === this.state.value) {
            if (this.next(), this.match(134)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", t3);
            if (this.match(135)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", t3);
            throw this.raise(lt.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          return void this.unexpected();
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(t3, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(t3, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(t3, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(t3, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (X(this.state.type)) {
            const e5 = J(this.state.type);
            return this.next(), super.createIdentifier(t3, e5);
          }
          if (W(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e4, t3, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      const e4 = this.state.startLoc;
      let t3 = this.flowParsePrimaryType(), r3 = false;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        const n3 = this.startNodeAt(e4), s3 = this.eat(18);
        r3 = r3 || s3, this.expect(0), !s3 && this.match(3) ? (n3.elementType = t3, this.next(), t3 = this.finishNode(n3, "ArrayTypeAnnotation")) : (n3.objectType = t3, n3.indexType = this.flowParseType(), this.expect(3), r3 ? (n3.optional = s3, t3 = this.finishNode(n3, "OptionalIndexedAccessType")) : t3 = this.finishNode(n3, "IndexedAccessType"));
      }
      return t3;
    }
    flowParsePrefixType() {
      const e4 = this.startNode();
      return this.eat(17) ? (e4.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e4, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const e4 = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const t3 = this.startNodeAt(e4.loc.start);
        return t3.params = [this.reinterpretTypeAsFunctionTypeParam(e4)], t3.rest = null, t3.this = null, t3.returnType = this.flowParseType(), t3.typeParameters = null, this.finishNode(t3, "FunctionTypeAnnotation");
      }
      return e4;
    }
    flowParseIntersectionType() {
      const e4 = this.startNode();
      this.eat(45);
      const t3 = this.flowParseAnonFunctionWithoutParens();
      for (e4.types = [t3]; this.eat(45); ) e4.types.push(this.flowParseAnonFunctionWithoutParens());
      return 1 === e4.types.length ? t3 : this.finishNode(e4, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const e4 = this.startNode();
      this.eat(43);
      const t3 = this.flowParseIntersectionType();
      for (e4.types = [t3]; this.eat(43); ) e4.types.push(this.flowParseIntersectionType());
      return 1 === e4.types.length ? t3 : this.finishNode(e4, "UnionTypeAnnotation");
    }
    flowParseType() {
      const e4 = this.state.inType;
      this.state.inType = true;
      const t3 = this.flowParseUnionType();
      return this.state.inType = e4, t3;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (132 === this.state.type && "_" === this.state.value) {
        const e4 = this.state.startLoc, t3 = this.parseIdentifier();
        return this.flowParseGenericType(e4, t3);
      }
      return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const e4 = this.startNode();
      return e4.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e4, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(e4) {
      const t3 = e4 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (t3.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t3)), t3;
    }
    typeCastToParameter(e4) {
      return e4.expression.typeAnnotation = e4.typeAnnotation, this.resetEndLocation(e4.expression, e4.typeAnnotation.loc.end), e4.expression;
    }
    flowParseVariance() {
      let e4 = null;
      return this.match(53) ? (e4 = this.startNode(), "+" === this.state.value ? e4.kind = "plus" : e4.kind = "minus", this.next(), this.finishNode(e4, "Variance")) : e4;
    }
    parseFunctionBody(e4, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      t3 ? this.forwardNoArrowParamsConversionAt(e4, () => super.parseFunctionBody(e4, true, r3)) : super.parseFunctionBody(e4, false, r3);
    }
    parseFunctionBodyAndFinish(e4, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      if (this.match(14)) {
        const t4 = this.startNode();
        [t4.typeAnnotation, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), e4.returnType = t4.typeAnnotation ? this.finishNode(t4, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(e4, t3, r3);
    }
    parseStatementLike(e4) {
      if (this.state.strict && this.isContextual(129)) {
        if (G(this.lookahead().type)) {
          const e5 = this.startNode();
          return this.next(), this.flowParseInterface(e5);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        const e5 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e5);
      }
      const t3 = super.parseStatementLike(e4);
      return void 0 !== this.flowPragma || this.isValidDirective(t3) || (this.flowPragma = null), t3;
    }
    parseExpressionStatement(e4, t3, r3) {
      if ("Identifier" === t3.type) {
        if ("declare" === t3.name) {
          if (this.match(80) || W(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e4);
        } else if (W(this.state.type)) {
          if ("interface" === t3.name) return this.flowParseInterface(e4);
          if ("type" === t3.name) return this.flowParseTypeAlias(e4);
          if ("opaque" === t3.name) return this.flowParseOpaqueType(e4, false);
        }
      }
      return super.parseExpressionStatement(e4, t3, r3);
    }
    shouldParseExportDeclaration() {
      const { type: e4 } = this.state;
      return K(e4) || this.shouldParseEnums() && 126 === e4 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const { type: e4 } = this.state;
      return K(e4) || this.shouldParseEnums() && 126 === e4 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        const e4 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e4);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(e4, t3, r3) {
      if (!this.match(17)) return e4;
      if (this.state.maybeInArrowParameters) {
        const t4 = this.lookaheadCharCode();
        if (44 === t4 || 61 === t4 || 58 === t4 || 41 === t4) return this.setOptionalParametersError(r3), e4;
      }
      this.expect(17);
      const n3 = this.state.clone(), s3 = this.state.noArrowAt, i3 = this.startNodeAt(t3);
      let { consequent: o3, failed: a3 } = this.tryParseConditionalConsequent(), [l2, c2] = this.getArrowLikeExpressions(o3);
      if (a3 || c2.length > 0) {
        const e5 = [...s3];
        if (c2.length > 0) {
          this.state = n3, this.state.noArrowAt = e5;
          for (let t4 = 0; t4 < c2.length; t4++) e5.push(c2[t4].start);
          ({ consequent: o3, failed: a3 } = this.tryParseConditionalConsequent()), [l2, c2] = this.getArrowLikeExpressions(o3);
        }
        a3 && l2.length > 1 && this.raise(lt.AmbiguousConditionalArrow, n3.startLoc), a3 && 1 === l2.length && (this.state = n3, e5.push(l2[0].start), this.state.noArrowAt = e5, { consequent: o3, failed: a3 } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(o3, true), this.state.noArrowAt = s3, this.expect(14), i3.test = e4, i3.consequent = o3, i3.alternate = this.forwardNoArrowParamsConversionAt(i3, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(i3, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const e4 = this.parseMaybeAssignAllowIn(), t3 = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), { consequent: e4, failed: t3 };
    }
    getArrowLikeExpressions(e4, t3) {
      const r3 = [e4], n3 = [];
      for (; 0 !== r3.length; ) {
        const e5 = r3.pop();
        "ArrowFunctionExpression" === e5.type ? (e5.typeParameters || !e5.returnType ? this.finishArrowValidation(e5) : n3.push(e5), r3.push(e5.body)) : "ConditionalExpression" === e5.type && (r3.push(e5.consequent), r3.push(e5.alternate));
      }
      return t3 ? (n3.forEach((e5) => this.finishArrowValidation(e5)), [n3, []]) : function(e5, t4) {
        const r4 = [], n4 = [];
        for (let s3 = 0; s3 < e5.length; s3++) (t4(e5[s3]) ? r4 : n4).push(e5[s3]);
        return [r4, n4];
      }(n3, (e5) => e5.params.every((e6) => this.isAssignable(e6, true)));
    }
    finishArrowValidation(e4) {
      var t3;
      this.toAssignableList(e4.params, null == (t3 = e4.extra) ? void 0 : t3.trailingCommaLoc, false), this.scope.enter(6), super.checkParams(e4, false, true), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(e4, t3) {
      let r3;
      return -1 !== this.state.noArrowParamsConversionAt.indexOf(e4.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), r3 = t3(), this.state.noArrowParamsConversionAt.pop()) : r3 = t3(), r3;
    }
    parseParenItem(e4, t3) {
      if (e4 = super.parseParenItem(e4, t3), this.eat(17) && (e4.optional = true, this.resetEndLocation(e4)), this.match(14)) {
        const r3 = this.startNodeAt(t3);
        return r3.expression = e4, r3.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r3, "TypeCastExpression");
      }
      return e4;
    }
    assertModuleNodeAllowed(e4) {
      "ImportDeclaration" === e4.type && ("type" === e4.importKind || "typeof" === e4.importKind) || "ExportNamedDeclaration" === e4.type && "type" === e4.exportKind || "ExportAllDeclaration" === e4.type && "type" === e4.exportKind || super.assertModuleNodeAllowed(e4);
    }
    parseExportDeclaration(e4) {
      if (this.isContextual(130)) {
        e4.exportKind = "type";
        const t3 = this.startNode();
        return this.next(), this.match(5) ? (e4.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e4), null) : this.flowParseTypeAlias(t3);
      }
      if (this.isContextual(131)) {
        e4.exportKind = "type";
        const t3 = this.startNode();
        return this.next(), this.flowParseOpaqueType(t3, false);
      }
      if (this.isContextual(129)) {
        e4.exportKind = "type";
        const t3 = this.startNode();
        return this.next(), this.flowParseInterface(t3);
      }
      if (this.shouldParseEnums() && this.isContextual(126)) {
        e4.exportKind = "value";
        const t3 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(t3);
      }
      return super.parseExportDeclaration(e4);
    }
    eatExportStar(e4) {
      return !!super.eatExportStar(e4) || !(!this.isContextual(130) || 55 !== this.lookahead().type) && (e4.exportKind = "type", this.next(), this.next(), true);
    }
    maybeParseExportNamespaceSpecifier(e4) {
      const { startLoc: t3 } = this.state, r3 = super.maybeParseExportNamespaceSpecifier(e4);
      return r3 && "type" === e4.exportKind && this.unexpected(t3), r3;
    }
    parseClassId(e4, t3, r3) {
      super.parseClassId(e4, t3, r3), this.match(47) && (e4.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(e4, t3, r3) {
      const { startLoc: n3 } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(e4, t3)) return;
        t3.declare = true;
      }
      super.parseClassMember(e4, t3, r3), t3.declare && ("ClassProperty" !== t3.type && "ClassPrivateProperty" !== t3.type && "PropertyDefinition" !== t3.type ? this.raise(lt.DeclareClassElement, n3) : t3.value && this.raise(lt.DeclareClassFieldInitializer, t3.value));
    }
    isIterator(e4) {
      return "iterator" === e4 || "asyncIterator" === e4;
    }
    readIterator() {
      const e4 = super.readWord1(), t3 = "@@" + e4;
      this.isIterator(e4) && this.state.inType || this.raise(v.InvalidIdentifier, this.state.curPosition(), { identifierName: t3 }), this.finishToken(132, t3);
    }
    getTokenFromCode(e4) {
      const t3 = this.input.charCodeAt(this.state.pos + 1);
      123 === e4 && 124 === t3 ? this.finishOp(6, 2) : !this.state.inType || 62 !== e4 && 60 !== e4 ? this.state.inType && 63 === e4 ? 46 === t3 ? this.finishOp(18, 2) : this.finishOp(17, 1) : function(e5, t4, r3) {
        return 64 === e5 && 64 === t4 && ae(r3);
      }(e4, t3, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e4) : this.finishOp(62 === e4 ? 48 : 47, 1);
    }
    isAssignable(e4, t3) {
      return "TypeCastExpression" === e4.type ? this.isAssignable(e4.expression, t3) : super.isAssignable(e4, t3);
    }
    toAssignable(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      t3 || "AssignmentExpression" !== e4.type || "TypeCastExpression" !== e4.left.type || (e4.left = this.typeCastToParameter(e4.left)), super.toAssignable(e4, t3);
    }
    toAssignableList(e4, t3, r3) {
      for (let t4 = 0; t4 < e4.length; t4++) {
        const r4 = e4[t4];
        "TypeCastExpression" === (null == r4 ? void 0 : r4.type) && (e4[t4] = this.typeCastToParameter(r4));
      }
      super.toAssignableList(e4, t3, r3);
    }
    toReferencedList(e4, t3) {
      for (let n3 = 0; n3 < e4.length; n3++) {
        var r3;
        const s3 = e4[n3];
        !s3 || "TypeCastExpression" !== s3.type || null != (r3 = s3.extra) && r3.parenthesized || !(e4.length > 1) && t3 || this.raise(lt.TypeCastInPattern, s3.typeAnnotation);
      }
      return e4;
    }
    parseArrayLike(e4, t3, r3, n3) {
      const s3 = super.parseArrayLike(e4, t3, r3, n3);
      return t3 && !this.state.maybeInArrowParameters && this.toReferencedList(s3.elements), s3;
    }
    isValidLVal(e4, t3, r3) {
      return "TypeCastExpression" === e4 || super.isValidLVal(e4, t3, r3);
    }
    parseClassProperty(e4) {
      return this.match(14) && (e4.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e4);
    }
    parseClassPrivateProperty(e4) {
      return this.match(14) && (e4.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e4);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(e4) {
      return !this.match(14) && super.isNonstaticConstructor(e4);
    }
    pushClassMethod(e4, t3, r3, n3, s3, i3) {
      if (t3.variance && this.unexpected(t3.variance.loc.start), delete t3.variance, this.match(47) && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e4, t3, r3, n3, s3, i3), t3.params && s3) {
        const e5 = t3.params;
        e5.length > 0 && this.isThisParam(e5[0]) && this.raise(lt.ThisParamBannedInConstructor, t3);
      } else if ("MethodDefinition" === t3.type && s3 && t3.value.params) {
        const e5 = t3.value.params;
        e5.length > 0 && this.isThisParam(e5[0]) && this.raise(lt.ThisParamBannedInConstructor, t3);
      }
    }
    pushClassPrivateMethod(e4, t3, r3, n3) {
      t3.variance && this.unexpected(t3.variance.loc.start), delete t3.variance, this.match(47) && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e4, t3, r3, n3);
    }
    parseClassSuper(e4) {
      if (super.parseClassSuper(e4), e4.superClass && this.match(47) && (e4.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
        this.next();
        const t3 = e4.implements = [];
        do {
          const e5 = this.startNode();
          e5.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? e5.typeParameters = this.flowParseTypeParameterInstantiation() : e5.typeParameters = null, t3.push(this.finishNode(e5, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(e4) {
      super.checkGetterSetterParams(e4);
      const t3 = this.getObjectOrClassMethodParams(e4);
      if (t3.length > 0) {
        const r3 = t3[0];
        this.isThisParam(r3) && "get" === e4.kind ? this.raise(lt.GetterMayNotHaveThisParam, r3) : this.isThisParam(r3) && this.raise(lt.SetterMayNotHaveThisParam, r3);
      }
    }
    parsePropertyNamePrefixOperator(e4) {
      e4.variance = this.flowParseVariance();
    }
    parseObjPropValue(e4, t3, r3, n3, s3, i3, o3) {
      let a3;
      e4.variance && this.unexpected(e4.variance.loc.start), delete e4.variance, this.match(47) && !i3 && (a3 = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      const l2 = super.parseObjPropValue(e4, t3, r3, n3, s3, i3, o3);
      return a3 && ((l2.value || l2).typeParameters = a3), l2;
    }
    parseAssignableListItemTypes(e4) {
      return this.eat(17) && ("Identifier" !== e4.type && this.raise(lt.PatternIsOptional, e4), this.isThisParam(e4) && this.raise(lt.ThisParamMayNotBeOptional, e4), e4.optional = true), this.match(14) ? e4.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e4) && this.raise(lt.ThisParamAnnotationRequired, e4), this.match(29) && this.isThisParam(e4) && this.raise(lt.ThisParamNoDefault, e4), this.resetEndLocation(e4), e4;
    }
    parseMaybeDefault(e4, t3) {
      const r3 = super.parseMaybeDefault(e4, t3);
      return "AssignmentPattern" === r3.type && r3.typeAnnotation && r3.right.start < r3.typeAnnotation.start && this.raise(lt.TypeBeforeInitializer, r3.typeAnnotation), r3;
    }
    checkImportReflection(e4) {
      super.checkImportReflection(e4), e4.module && "value" !== e4.importKind && this.raise(lt.ImportReflectionHasImportType, e4.specifiers[0].loc.start);
    }
    parseImportSpecifierLocal(e4, t3, r3) {
      t3.local = ct(e4) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e4.specifiers.push(this.finishImportSpecifier(t3, r3));
    }
    isPotentialImportPhase(e4) {
      if (super.isPotentialImportPhase(e4)) return true;
      if (this.isContextual(130)) {
        if (!e4) return true;
        const t3 = this.lookaheadCharCode();
        return 123 === t3 || 42 === t3;
      }
      return !e4 && this.isContextual(87);
    }
    applyImportPhase(e4, t3, r3, n3) {
      if (super.applyImportPhase(e4, t3, r3, n3), t3) {
        if (!r3 && this.match(65)) return;
        e4.exportKind = "type" === r3 ? r3 : "value";
      } else "type" === r3 && this.match(55) && this.unexpected(), e4.importKind = "type" === r3 || "typeof" === r3 ? r3 : "value";
    }
    parseImportSpecifier(e4, t3, r3, n3, s3) {
      const i3 = e4.imported;
      let o3 = null;
      "Identifier" === i3.type && ("type" === i3.name ? o3 = "type" : "typeof" === i3.name && (o3 = "typeof"));
      let a3 = false;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const t4 = this.parseIdentifier(true);
        null === o3 || G(this.state.type) ? (e4.imported = i3, e4.importKind = null, e4.local = this.parseIdentifier()) : (e4.imported = t4, e4.importKind = o3, e4.local = it(t4));
      } else {
        if (null !== o3 && G(this.state.type)) e4.imported = this.parseIdentifier(true), e4.importKind = o3;
        else {
          if (t3) throw this.raise(v.ImportBindingIsString, e4, { importName: i3.value });
          e4.imported = i3, e4.importKind = null;
        }
        this.eatContextual(93) ? e4.local = this.parseIdentifier() : (a3 = true, e4.local = it(e4.imported));
      }
      const l2 = ct(e4);
      return r3 && l2 && this.raise(lt.ImportTypeShorthandOnlyInPureImport, e4), (r3 || l2) && this.checkReservedType(e4.local.name, e4.local.loc.start, true), !a3 || r3 || l2 || this.checkReservedWord(e4.local.name, e4.loc.start, true, true), this.finishImportSpecifier(e4, "ImportSpecifier");
    }
    parseBindingAtom() {
      return 78 === this.state.type ? this.parseIdentifier(true) : super.parseBindingAtom();
    }
    parseFunctionParams(e4, t3) {
      const r3 = e4.kind;
      "get" !== r3 && "set" !== r3 && this.match(47) && (e4.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e4, t3);
    }
    parseVarId(e4, t3) {
      super.parseVarId(e4, t3), this.match(14) && (e4.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e4.id));
    }
    parseAsyncArrowFromCallExpression(e4, t3) {
      if (this.match(14)) {
        const t4 = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true, e4.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = t4;
      }
      return super.parseAsyncArrowFromCallExpression(e4, t3);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(e4, t3) {
      var r3;
      let n3, s3 = null;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (s3 = this.state.clone(), n3 = this.tryParse(() => super.parseMaybeAssign(e4, t3), s3), !n3.error) return n3.node;
        const { context: r4 } = this.state, i4 = r4[r4.length - 1];
        i4 !== w.j_oTag && i4 !== w.j_expr || r4.pop();
      }
      if (null != (r3 = n3) && r3.error || this.match(47)) {
        var i3, o3;
        let r4;
        s3 = s3 || this.state.clone();
        const a3 = this.tryParse((n4) => {
          var s4;
          r4 = this.flowParseTypeParameterDeclaration();
          const i4 = this.forwardNoArrowParamsConversionAt(r4, () => {
            const n5 = super.parseMaybeAssign(e4, t3);
            return this.resetStartLocationFromNode(n5, r4), n5;
          });
          null != (s4 = i4.extra) && s4.parenthesized && n4();
          const o4 = this.maybeUnwrapTypeCastExpression(i4);
          return "ArrowFunctionExpression" !== o4.type && n4(), o4.typeParameters = r4, this.resetStartLocationFromNode(o4, r4), i4;
        }, s3);
        let l2 = null;
        if (a3.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(a3.node).type) {
          if (!a3.error && !a3.aborted) return a3.node.async && this.raise(lt.UnexpectedTypeParameterBeforeAsyncArrowFunction, r4), a3.node;
          l2 = a3.node;
        }
        if (null != (i3 = n3) && i3.node) return this.state = n3.failState, n3.node;
        if (l2) return this.state = a3.failState, l2;
        if (null != (o3 = n3) && o3.thrown) throw n3.error;
        if (a3.thrown) throw a3.error;
        throw this.raise(lt.UnexpectedTokenAfterTypeParameter, r4);
      }
      return super.parseMaybeAssign(e4, t3);
    }
    parseArrow(e4) {
      if (this.match(14)) {
        const t3 = this.tryParse(() => {
          const t4 = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const r3 = this.startNode();
          return [r3.typeAnnotation, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = t4, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r3;
        });
        if (t3.thrown) return null;
        t3.error && (this.state = t3.failState), e4.returnType = t3.node.typeAnnotation ? this.finishNode(t3.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(e4);
    }
    shouldParseArrow(e4) {
      return this.match(14) || super.shouldParseArrow(e4);
    }
    setArrowFunctionParameters(e4, t3) {
      -1 !== this.state.noArrowParamsConversionAt.indexOf(e4.start) ? e4.params = t3 : super.setArrowFunctionParameters(e4, t3);
    }
    checkParams(e4, t3, r3) {
      let n3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      if (!r3 || -1 === this.state.noArrowParamsConversionAt.indexOf(e4.start)) {
        for (let t4 = 0; t4 < e4.params.length; t4++) this.isThisParam(e4.params[t4]) && t4 > 0 && this.raise(lt.ThisParamMustBeFirst, e4.params[t4]);
        super.checkParams(e4, t3, r3, n3);
      }
    }
    parseParenAndDistinguishExpression(e4) {
      return super.parseParenAndDistinguishExpression(e4 && -1 === this.state.noArrowAt.indexOf(this.state.start));
    }
    parseSubscripts(e4, t3, r3) {
      if ("Identifier" === e4.type && "async" === e4.name && -1 !== this.state.noArrowAt.indexOf(t3.index)) {
        this.next();
        const r4 = this.startNodeAt(t3);
        r4.callee = e4, r4.arguments = super.parseCallExpressionArguments(11, false), e4 = this.finishNode(r4, "CallExpression");
      } else if ("Identifier" === e4.type && "async" === e4.name && this.match(47)) {
        const n3 = this.state.clone(), s3 = this.tryParse((e5) => this.parseAsyncArrowWithTypeParameters(t3) || e5(), n3);
        if (!s3.error && !s3.aborted) return s3.node;
        const i3 = this.tryParse(() => super.parseSubscripts(e4, t3, r3), n3);
        if (i3.node && !i3.error) return i3.node;
        if (s3.node) return this.state = s3.failState, s3.node;
        if (i3.node) return this.state = i3.failState, i3.node;
        throw s3.error || i3.error;
      }
      return super.parseSubscripts(e4, t3, r3);
    }
    parseSubscript(e4, t3, r3, n3) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (n3.optionalChainMember = true, r3) return n3.stop = true, e4;
        this.next();
        const s3 = this.startNodeAt(t3);
        return s3.callee = e4, s3.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), s3.arguments = this.parseCallExpressionArguments(11, false), s3.optional = true, this.finishCallExpression(s3, true);
      }
      if (!r3 && this.shouldParseTypes() && this.match(47)) {
        const r4 = this.startNodeAt(t3);
        r4.callee = e4;
        const s3 = this.tryParse(() => (r4.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), r4.arguments = super.parseCallExpressionArguments(11, false), n3.optionalChainMember && (r4.optional = false), this.finishCallExpression(r4, n3.optionalChainMember)));
        if (s3.node) return s3.error && (this.state = s3.failState), s3.node;
      }
      return super.parseSubscript(e4, t3, r3, n3);
    }
    parseNewCallee(e4) {
      super.parseNewCallee(e4);
      let t3 = null;
      this.shouldParseTypes() && this.match(47) && (t3 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e4.typeArguments = t3;
    }
    parseAsyncArrowWithTypeParameters(e4) {
      const t3 = this.startNodeAt(e4);
      if (this.parseFunctionParams(t3, false), this.parseArrow(t3)) return super.parseArrowExpression(t3, void 0, true);
    }
    readToken_mult_modulo(e4) {
      const t3 = this.input.charCodeAt(this.state.pos + 1);
      if (42 === e4 && 47 === t3 && this.state.hasFlowComment) return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
      super.readToken_mult_modulo(e4);
    }
    readToken_pipe_amp(e4) {
      const t3 = this.input.charCodeAt(this.state.pos + 1);
      124 !== e4 || 125 !== t3 ? super.readToken_pipe_amp(e4) : this.finishOp(9, 2);
    }
    parseTopLevel(e4, t3) {
      const r3 = super.parseTopLevel(e4, t3);
      return this.state.hasFlowComment && this.raise(lt.UnterminatedFlowComment, this.state.curPosition()), r3;
    }
    skipBlockComment() {
      if (!this.hasPlugin("flowComments") || !this.skipFlowComment()) return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
      {
        if (this.state.hasFlowComment) throw this.raise(lt.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        const e4 = this.skipFlowComment();
        e4 && (this.state.pos += e4, this.state.hasFlowComment = true);
      }
    }
    skipFlowComment() {
      const { pos: e4 } = this.state;
      let t3 = 2;
      for (; [32, 9].includes(this.input.charCodeAt(e4 + t3)); ) t3++;
      const r3 = this.input.charCodeAt(t3 + e4), n3 = this.input.charCodeAt(t3 + e4 + 1);
      return 58 === r3 && 58 === n3 ? t3 + 2 : "flow-include" === this.input.slice(t3 + e4, t3 + e4 + 12) ? t3 + 12 : 58 === r3 && 58 !== n3 && t3;
    }
    hasFlowCommentCompletion() {
      if (-1 === this.input.indexOf("*/", this.state.pos)) throw this.raise(v.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(e4, t3) {
      let { enumName: r3, memberName: n3 } = t3;
      this.raise(lt.EnumBooleanMemberNotInitialized, e4, { memberName: n3, enumName: r3 });
    }
    flowEnumErrorInvalidMemberInitializer(e4, t3) {
      return this.raise(t3.explicitType ? "symbol" === t3.explicitType ? lt.EnumInvalidMemberInitializerSymbolType : lt.EnumInvalidMemberInitializerPrimaryType : lt.EnumInvalidMemberInitializerUnknownType, e4, t3);
    }
    flowEnumErrorNumberMemberNotInitialized(e4, t3) {
      this.raise(lt.EnumNumberMemberNotInitialized, e4, t3);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(e4, t3) {
      this.raise(lt.EnumStringMemberInconsistentlyInitialized, e4, t3);
    }
    flowEnumMemberInit() {
      const e4 = this.state.startLoc, t3 = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 134: {
          const r3 = this.parseNumericLiteral(this.state.value);
          return t3() ? { type: "number", loc: r3.loc.start, value: r3 } : { type: "invalid", loc: e4 };
        }
        case 133: {
          const r3 = this.parseStringLiteral(this.state.value);
          return t3() ? { type: "string", loc: r3.loc.start, value: r3 } : { type: "invalid", loc: e4 };
        }
        case 85:
        case 86: {
          const r3 = this.parseBooleanLiteral(this.match(85));
          return t3() ? { type: "boolean", loc: r3.loc.start, value: r3 } : { type: "invalid", loc: e4 };
        }
        default:
          return { type: "invalid", loc: e4 };
      }
    }
    flowEnumMemberRaw() {
      const e4 = this.state.startLoc;
      return { id: this.parseIdentifier(true), init: this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e4 } };
    }
    flowEnumCheckExplicitTypeMismatch(e4, t3, r3) {
      const { explicitType: n3 } = t3;
      null !== n3 && n3 !== r3 && this.flowEnumErrorInvalidMemberInitializer(e4, t3);
    }
    flowEnumMembers(e4) {
      let { enumName: t3, explicitType: r3 } = e4;
      const n3 = /* @__PURE__ */ new Set(), s3 = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
      let i3 = false;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          i3 = true;
          break;
        }
        const e5 = this.startNode(), { id: o3, init: a3 } = this.flowEnumMemberRaw(), l2 = o3.name;
        if ("" === l2) continue;
        /^[a-z]/.test(l2) && this.raise(lt.EnumInvalidMemberName, o3, { memberName: l2, suggestion: l2[0].toUpperCase() + l2.slice(1), enumName: t3 }), n3.has(l2) && this.raise(lt.EnumDuplicateMemberName, o3, { memberName: l2, enumName: t3 }), n3.add(l2);
        const c2 = { enumName: t3, explicitType: r3, memberName: l2 };
        switch (e5.id = o3, a3.type) {
          case "boolean":
            this.flowEnumCheckExplicitTypeMismatch(a3.loc, c2, "boolean"), e5.init = a3.value, s3.booleanMembers.push(this.finishNode(e5, "EnumBooleanMember"));
            break;
          case "number":
            this.flowEnumCheckExplicitTypeMismatch(a3.loc, c2, "number"), e5.init = a3.value, s3.numberMembers.push(this.finishNode(e5, "EnumNumberMember"));
            break;
          case "string":
            this.flowEnumCheckExplicitTypeMismatch(a3.loc, c2, "string"), e5.init = a3.value, s3.stringMembers.push(this.finishNode(e5, "EnumStringMember"));
            break;
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(a3.loc, c2);
          case "none":
            switch (r3) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(a3.loc, c2);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(a3.loc, c2);
                break;
              default:
                s3.defaultedMembers.push(this.finishNode(e5, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return { members: s3, hasUnknownMembers: i3 };
    }
    flowEnumStringMembers(e4, t3, r3) {
      let { enumName: n3 } = r3;
      if (0 === e4.length) return t3;
      if (0 === t3.length) return e4;
      if (t3.length > e4.length) {
        for (const t4 of e4) this.flowEnumErrorStringMemberInconsistentlyInitialized(t4, { enumName: n3 });
        return t3;
      }
      for (const e5 of t3) this.flowEnumErrorStringMemberInconsistentlyInitialized(e5, { enumName: n3 });
      return e4;
    }
    flowEnumParseExplicitType(e4) {
      let { enumName: t3 } = e4;
      if (!this.eatContextual(102)) return null;
      if (!W(this.state.type)) throw this.raise(lt.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: t3 });
      const { value: r3 } = this.state;
      return this.next(), "boolean" !== r3 && "number" !== r3 && "string" !== r3 && "symbol" !== r3 && this.raise(lt.EnumInvalidExplicitType, this.state.startLoc, { enumName: t3, invalidEnumType: r3 }), r3;
    }
    flowEnumBody(e4, t3) {
      const r3 = t3.name, n3 = t3.loc.start, s3 = this.flowEnumParseExplicitType({ enumName: r3 });
      this.expect(5);
      const { members: i3, hasUnknownMembers: o3 } = this.flowEnumMembers({ enumName: r3, explicitType: s3 });
      switch (e4.hasUnknownMembers = o3, s3) {
        case "boolean":
          return e4.explicitType = true, e4.members = i3.booleanMembers, this.expect(8), this.finishNode(e4, "EnumBooleanBody");
        case "number":
          return e4.explicitType = true, e4.members = i3.numberMembers, this.expect(8), this.finishNode(e4, "EnumNumberBody");
        case "string":
          return e4.explicitType = true, e4.members = this.flowEnumStringMembers(i3.stringMembers, i3.defaultedMembers, { enumName: r3 }), this.expect(8), this.finishNode(e4, "EnumStringBody");
        case "symbol":
          return e4.members = i3.defaultedMembers, this.expect(8), this.finishNode(e4, "EnumSymbolBody");
        default: {
          const t4 = () => (e4.members = [], this.expect(8), this.finishNode(e4, "EnumStringBody"));
          e4.explicitType = false;
          const s4 = i3.booleanMembers.length, o4 = i3.numberMembers.length, a3 = i3.stringMembers.length, l2 = i3.defaultedMembers.length;
          if (s4 || o4 || a3 || l2) {
            if (s4 || o4) {
              if (!o4 && !a3 && s4 >= l2) {
                for (const e5 of i3.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(e5.loc.start, { enumName: r3, memberName: e5.id.name });
                return e4.members = i3.booleanMembers, this.expect(8), this.finishNode(e4, "EnumBooleanBody");
              }
              if (!s4 && !a3 && o4 >= l2) {
                for (const e5 of i3.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(e5.loc.start, { enumName: r3, memberName: e5.id.name });
                return e4.members = i3.numberMembers, this.expect(8), this.finishNode(e4, "EnumNumberBody");
              }
              return this.raise(lt.EnumInconsistentMemberValues, n3, { enumName: r3 }), t4();
            }
            return e4.members = this.flowEnumStringMembers(i3.stringMembers, i3.defaultedMembers, { enumName: r3 }), this.expect(8), this.finishNode(e4, "EnumStringBody");
          }
          return t4();
        }
      }
    }
    flowParseEnumDeclaration(e4) {
      const t3 = this.parseIdentifier();
      return e4.id = t3, e4.body = this.flowEnumBody(this.startNode(), t3), this.finishNode(e4, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const e4 = this.nextTokenStart();
      if (60 === this.input.charCodeAt(e4)) {
        const t3 = this.input.charCodeAt(e4 + 1);
        return 60 !== t3 && 61 !== t3;
      }
      return false;
    }
    maybeUnwrapTypeCastExpression(e4) {
      return "TypeCastExpression" === e4.type ? e4.expression : e4;
    }
  }, typescript: (e3) => class extends e3 {
    constructor() {
      super(...arguments), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: St.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: St.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: St.InvalidModifierOnTypeParameter });
    }
    getScopeHandler() {
      return gt;
    }
    tsIsIdentifier() {
      return W(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(e4, t3) {
      if (!W(this.state.type) && 58 !== this.state.type && 75 !== this.state.type) return;
      const r3 = this.state.value;
      if (-1 !== e4.indexOf(r3)) {
        if (t3 && this.tsIsStartOfStaticBlocks()) return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return r3;
      }
    }
    tsParseModifiers(e4, t3) {
      let { allowedModifiers: r3, disallowedModifiers: n3, stopOnStartOfClassStaticBlock: s3, errorTemplate: i3 = St.InvalidModifierOnTypeMember } = e4;
      const o3 = (e5, r4, n4, s4) => {
        r4 === n4 && t3[s4] && this.raise(St.InvalidModifiersOrder, e5, { orderedModifiers: [n4, s4] });
      }, a3 = (e5, r4, n4, s4) => {
        (t3[n4] && r4 === s4 || t3[s4] && r4 === n4) && this.raise(St.IncompatibleModifiers, e5, { modifiers: [n4, s4] });
      };
      for (; ; ) {
        const { startLoc: e5 } = this.state, l2 = this.tsParseModifier(r3.concat(null != n3 ? n3 : []), s3);
        if (!l2) break;
        xt(l2) ? t3.accessibility ? this.raise(St.DuplicateAccessibilityModifier, e5, { modifier: l2 }) : (o3(e5, l2, l2, "override"), o3(e5, l2, l2, "static"), o3(e5, l2, l2, "readonly"), t3.accessibility = l2) : Tt(l2) ? (t3[l2] && this.raise(St.DuplicateModifier, e5, { modifier: l2 }), t3[l2] = true, o3(e5, l2, "in", "out")) : (Object.hasOwnProperty.call(t3, l2) ? this.raise(St.DuplicateModifier, e5, { modifier: l2 }) : (o3(e5, l2, "static", "readonly"), o3(e5, l2, "static", "override"), o3(e5, l2, "override", "readonly"), o3(e5, l2, "abstract", "override"), a3(e5, l2, "declare", "override"), a3(e5, l2, "static", "abstract")), t3[l2] = true), null != n3 && n3.includes(l2) && this.raise(i3, e5, { modifier: l2 });
      }
    }
    tsIsListTerminator(e4) {
      switch (e4) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(e4, t3) {
      const r3 = [];
      for (; !this.tsIsListTerminator(e4); ) r3.push(t3());
      return r3;
    }
    tsParseDelimitedList(e4, t3, r3) {
      return function(e5) {
        if (null == e5) throw new Error(`Unexpected ${e5} value.`);
        return e5;
      }(this.tsParseDelimitedListWorker(e4, t3, true, r3));
    }
    tsParseDelimitedListWorker(e4, t3, r3, n3) {
      const s3 = [];
      let i3 = -1;
      for (; !this.tsIsListTerminator(e4); ) {
        i3 = -1;
        const n4 = t3();
        if (null == n4) return;
        if (s3.push(n4), !this.eat(12)) {
          if (this.tsIsListTerminator(e4)) break;
          return void (r3 && this.expect(12));
        }
        i3 = this.state.lastTokStartLoc.index;
      }
      return n3 && (n3.value = i3), s3;
    }
    tsParseBracketedList(e4, t3, r3, n3, s3) {
      n3 || (r3 ? this.expect(0) : this.expect(47));
      const i3 = this.tsParseDelimitedList(e4, t3, s3);
      return r3 ? this.expect(3) : this.expect(48), i3;
    }
    tsParseImportType() {
      const e4 = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(St.UnsupportedImportTypeArgument, this.state.startLoc), e4.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (e4.qualifier = this.tsParseEntityName()), this.match(47) && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSImportType");
    }
    tsParseEntityName() {
      let e4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], t3 = this.parseIdentifier(e4);
      for (; this.eat(16); ) {
        const r3 = this.startNodeAtNode(t3);
        r3.left = t3, r3.right = this.parseIdentifier(e4), t3 = this.finishNode(r3, "TSQualifiedName");
      }
      return t3;
    }
    tsParseTypeReference() {
      const e4 = this.startNode();
      return e4.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSTypeReference");
    }
    tsParseThisTypePredicate(e4) {
      this.next();
      const t3 = this.startNodeAtNode(e4);
      return t3.parameterName = e4, t3.typeAnnotation = this.tsParseTypeAnnotation(false), t3.asserts = false, this.finishNode(t3, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const e4 = this.startNode();
      return this.next(), this.finishNode(e4, "TSThisType");
    }
    tsParseTypeQuery() {
      const e4 = this.startNode();
      return this.expect(87), this.match(83) ? e4.exprName = this.tsParseImportType() : e4.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSTypeQuery");
    }
    tsParseTypeParameter(e4) {
      const t3 = this.startNode();
      return e4(t3), t3.name = this.tsParseTypeParameterName(), t3.constraint = this.tsEatThenParseType(81), t3.default = this.tsEatThenParseType(29), this.finishNode(t3, "TSTypeParameter");
    }
    tsTryParseTypeParameters(e4) {
      if (this.match(47)) return this.tsParseTypeParameters(e4);
    }
    tsParseTypeParameters(e4) {
      const t3 = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      const r3 = { value: -1 };
      return t3.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e4), false, true, r3), 0 === t3.params.length && this.raise(St.EmptyTypeParameters, t3), -1 !== r3.value && this.addExtra(t3, "trailingComma", r3.value), this.finishNode(t3, "TSTypeParameterDeclaration");
    }
    tsFillSignature(e4, t3) {
      const r3 = 19 === e4;
      t3.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), t3.parameters = this.tsParseBindingListForSignature(), (r3 || this.match(e4)) && (t3.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(e4));
    }
    tsParseBindingListForSignature() {
      const e4 = super.parseBindingList(11, 41, 2);
      for (const t3 of e4) {
        const { type: e5 } = t3;
        "AssignmentPattern" !== e5 && "TSParameterProperty" !== e5 || this.raise(St.UnsupportedSignatureParameterKind, t3, { type: e5 });
      }
      return e4;
    }
    tsParseTypeMemberSemicolon() {
      this.eat(12) || this.isLineTerminator() || this.expect(13);
    }
    tsParseSignatureMember(e4, t3) {
      return this.tsFillSignature(14, t3), this.tsParseTypeMemberSemicolon(), this.finishNode(t3, e4);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), !!W(this.state.type) && (this.next(), this.match(14));
    }
    tsTryParseIndexSignature(e4) {
      if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
      this.expect(0);
      const t3 = this.parseIdentifier();
      t3.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t3), this.expect(3), e4.parameters = [t3];
      const r3 = this.tsTryParseTypeAnnotation();
      return r3 && (e4.typeAnnotation = r3), this.tsParseTypeMemberSemicolon(), this.finishNode(e4, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(e4, t3) {
      this.eat(17) && (e4.optional = true);
      const r3 = e4;
      if (this.match(10) || this.match(47)) {
        t3 && this.raise(St.ReadonlyForMethodSignature, e4);
        const n3 = r3;
        n3.kind && this.match(47) && this.raise(St.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, n3), this.tsParseTypeMemberSemicolon();
        const s3 = "parameters", i3 = "typeAnnotation";
        if ("get" === n3.kind) n3[s3].length > 0 && (this.raise(v.BadGetterArity, this.state.curPosition()), this.isThisParam(n3[s3][0]) && this.raise(St.AccesorCannotDeclareThisParameter, this.state.curPosition()));
        else if ("set" === n3.kind) {
          if (1 !== n3[s3].length) this.raise(v.BadSetterArity, this.state.curPosition());
          else {
            const e5 = n3[s3][0];
            this.isThisParam(e5) && this.raise(St.AccesorCannotDeclareThisParameter, this.state.curPosition()), "Identifier" === e5.type && e5.optional && this.raise(St.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), "RestElement" === e5.type && this.raise(St.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          n3[i3] && this.raise(St.SetAccesorCannotHaveReturnType, n3[i3]);
        } else n3.kind = "method";
        return this.finishNode(n3, "TSMethodSignature");
      }
      {
        const e5 = r3;
        t3 && (e5.readonly = true);
        const n3 = this.tsTryParseTypeAnnotation();
        return n3 && (e5.typeAnnotation = n3), this.tsParseTypeMemberSemicolon(), this.finishNode(e5, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const e4 = this.startNode();
      if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", e4);
      if (this.match(77)) {
        const t3 = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e4) : (e4.key = this.createIdentifier(t3, "new"), this.tsParsePropertyOrMethodSignature(e4, false));
      }
      this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, e4);
      return this.tsTryParseIndexSignature(e4) || (super.parsePropertyName(e4), e4.computed || "Identifier" !== e4.key.type || "get" !== e4.key.name && "set" !== e4.key.name || !this.tsTokenCanFollowModifier() || (e4.kind = e4.key.name, super.parsePropertyName(e4)), this.tsParsePropertyOrMethodSignature(e4, !!e4.readonly));
    }
    tsParseTypeLiteral() {
      const e4 = this.startNode();
      return e4.members = this.tsParseObjectTypeMembers(), this.finishNode(e4, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const e4 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), e4;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(58))));
    }
    tsParseMappedTypeParameter() {
      const e4 = this.startNode();
      return e4.name = this.tsParseTypeParameterName(), e4.constraint = this.tsExpectThenParseType(58), this.finishNode(e4, "TSTypeParameter");
    }
    tsParseMappedType() {
      const e4 = this.startNode();
      return this.expect(5), this.match(53) ? (e4.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e4.readonly = true), this.expect(0), e4.typeParameter = this.tsParseMappedTypeParameter(), e4.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e4.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e4.optional = true), e4.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e4, "TSMappedType");
    }
    tsParseTupleType() {
      const e4 = this.startNode();
      e4.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let t3 = false;
      return e4.elementTypes.forEach((e5) => {
        const { type: r3 } = e5;
        !t3 || "TSRestType" === r3 || "TSOptionalType" === r3 || "TSNamedTupleMember" === r3 && e5.optional || this.raise(St.OptionalTypeBeforeRequired, e5), t3 || (t3 = "TSNamedTupleMember" === r3 && e5.optional || "TSOptionalType" === r3);
      }), this.finishNode(e4, "TSTupleType");
    }
    tsParseTupleElementType() {
      const { startLoc: e4 } = this.state, t3 = this.eat(21);
      let r3, n3, s3, i3;
      const o3 = G(this.state.type) ? this.lookaheadCharCode() : null;
      if (58 === o3) r3 = true, s3 = false, n3 = this.parseIdentifier(true), this.expect(14), i3 = this.tsParseType();
      else if (63 === o3) {
        s3 = true;
        const e5 = this.state.startLoc, t4 = this.state.value, o4 = this.tsParseNonArrayType();
        58 === this.lookaheadCharCode() ? (r3 = true, n3 = this.createIdentifier(this.startNodeAt(e5), t4), this.expect(17), this.expect(14), i3 = this.tsParseType()) : (r3 = false, i3 = o4, this.expect(17));
      } else i3 = this.tsParseType(), s3 = this.eat(17), r3 = this.eat(14);
      if (r3) {
        let e5;
        n3 ? (e5 = this.startNodeAtNode(n3), e5.optional = s3, e5.label = n3, e5.elementType = i3, this.eat(17) && (e5.optional = true, this.raise(St.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (e5 = this.startNodeAtNode(i3), e5.optional = s3, this.raise(St.InvalidTupleMemberLabel, i3), e5.label = i3, e5.elementType = this.tsParseType()), i3 = this.finishNode(e5, "TSNamedTupleMember");
      } else if (s3) {
        const e5 = this.startNodeAtNode(i3);
        e5.typeAnnotation = i3, i3 = this.finishNode(e5, "TSOptionalType");
      }
      if (t3) {
        const t4 = this.startNodeAt(e4);
        t4.typeAnnotation = i3, i3 = this.finishNode(t4, "TSRestType");
      }
      return i3;
    }
    tsParseParenthesizedType() {
      const e4 = this.startNode();
      return this.expect(10), e4.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e4, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(e4, t3) {
      const r3 = this.startNode();
      return "TSConstructorType" === e4 && (r3.abstract = !!t3, t3 && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, r3)), this.finishNode(r3, e4);
    }
    tsParseLiteralTypeNode() {
      const e4 = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          e4.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(e4, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const e4 = this.startNode();
      return e4.literal = super.parseTemplate(false), this.finishNode(e4, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const e4 = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e4) : e4;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if ("-" === this.state.value) {
            const e4 = this.startNode(), t3 = this.lookahead();
            return 134 !== t3.type && 135 !== t3.type && this.unexpected(), e4.literal = this.parseMaybeUnary(), this.finishNode(e4, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const { type: e4 } = this.state;
          if (W(e4) || 88 === e4 || 84 === e4) {
            const t3 = 88 === e4 ? "TSVoidKeyword" : 84 === e4 ? "TSNullKeyword" : function(e5) {
              switch (e5) {
                case "any":
                  return "TSAnyKeyword";
                case "boolean":
                  return "TSBooleanKeyword";
                case "bigint":
                  return "TSBigIntKeyword";
                case "never":
                  return "TSNeverKeyword";
                case "number":
                  return "TSNumberKeyword";
                case "object":
                  return "TSObjectKeyword";
                case "string":
                  return "TSStringKeyword";
                case "symbol":
                  return "TSSymbolKeyword";
                case "undefined":
                  return "TSUndefinedKeyword";
                case "unknown":
                  return "TSUnknownKeyword";
                default:
                  return;
              }
            }(this.state.value);
            if (void 0 !== t3 && 46 !== this.lookaheadCharCode()) {
              const e5 = this.startNode();
              return this.next(), this.finishNode(e5, t3);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let e4 = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); ) if (this.match(3)) {
        const t3 = this.startNodeAtNode(e4);
        t3.elementType = e4, this.expect(3), e4 = this.finishNode(t3, "TSArrayType");
      } else {
        const t3 = this.startNodeAtNode(e4);
        t3.objectType = e4, t3.indexType = this.tsParseType(), this.expect(3), e4 = this.finishNode(t3, "TSIndexedAccessType");
      }
      return e4;
    }
    tsParseTypeOperator() {
      const e4 = this.startNode(), t3 = this.state.value;
      return this.next(), e4.operator = t3, e4.typeAnnotation = this.tsParseTypeOperatorOrHigher(), "readonly" === t3 && this.tsCheckTypeAnnotationForReadOnly(e4), this.finishNode(e4, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(e4) {
      switch (e4.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(St.UnexpectedReadonly, e4);
      }
    }
    tsParseInferType() {
      const e4 = this.startNode();
      this.expectContextual(115);
      const t3 = this.startNode();
      return t3.name = this.tsParseTypeParameterName(), t3.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e4.typeParameter = this.finishNode(t3, "TSTypeParameter"), this.finishNode(e4, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const e4 = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e4;
      }
    }
    tsParseTypeOperatorOrHigher() {
      var e4;
      return (e4 = this.state.type) >= 121 && e4 <= 123 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(e4, t3, r3) {
      const n3 = this.startNode(), s3 = this.eat(r3), i3 = [];
      do {
        i3.push(t3());
      } while (this.eat(r3));
      return 1 !== i3.length || s3 ? (n3.types = i3, this.finishNode(n3, e4)) : i3[0];
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return !!this.match(47) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (W(this.state.type) || this.match(78)) return this.next(), true;
      if (this.match(5)) {
        const { errors: e4 } = this.state, t3 = e4.length;
        try {
          return this.parseObjectLike(8, true), e4.length === t3;
        } catch (e5) {
          return false;
        }
      }
      if (this.match(0)) {
        this.next();
        const { errors: e4 } = this.state, t3 = e4.length;
        try {
          return super.parseBindingList(3, 93, 1), e4.length === t3;
        } catch (e5) {
          return false;
        }
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      if (this.next(), this.match(11) || this.match(21)) return true;
      if (this.tsSkipParameterStart()) {
        if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) return true;
        if (this.match(11) && (this.next(), this.match(19))) return true;
      }
      return false;
    }
    tsParseTypeOrTypePredicateAnnotation(e4) {
      return this.tsInType(() => {
        const t3 = this.startNode();
        this.expect(e4);
        const r3 = this.startNode(), n3 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (n3 && this.match(78)) {
          let e5 = this.tsParseThisTypeOrThisTypePredicate();
          return "TSThisType" === e5.type ? (r3.parameterName = e5, r3.asserts = true, r3.typeAnnotation = null, e5 = this.finishNode(r3, "TSTypePredicate")) : (this.resetStartLocationFromNode(e5, r3), e5.asserts = true), t3.typeAnnotation = e5, this.finishNode(t3, "TSTypeAnnotation");
        }
        const s3 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!s3) return n3 ? (r3.parameterName = this.parseIdentifier(), r3.asserts = n3, r3.typeAnnotation = null, t3.typeAnnotation = this.finishNode(r3, "TSTypePredicate"), this.finishNode(t3, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t3);
        const i3 = this.tsParseTypeAnnotation(false);
        return r3.parameterName = s3, r3.typeAnnotation = i3, r3.asserts = n3, t3.typeAnnotation = this.finishNode(r3, "TSTypePredicate"), this.finishNode(t3, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14)) return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const e4 = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), e4;
    }
    tsParseTypePredicateAsserts() {
      if (109 !== this.state.type) return false;
      const e4 = this.state.containsEsc;
      return this.next(), !(!W(this.state.type) && !this.match(78) || (e4 && this.raise(v.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), 0));
    }
    tsParseTypeAnnotation() {
      let e4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.startNode();
      return this.tsInType(() => {
        e4 && this.expect(14), t3.typeAnnotation = this.tsParseType();
      }), this.finishNode(t3, "TSTypeAnnotation");
    }
    tsParseType() {
      Et(this.state.inType);
      const e4 = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e4;
      const t3 = this.startNodeAtNode(e4);
      return t3.checkType = e4, t3.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), t3.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), t3.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(t3, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && 77 === this.lookahead().type;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(St.ReservedTypeAssertion, this.state.startLoc);
      const e4 = this.startNode();
      return e4.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e4.expression = this.parseMaybeUnary(), this.finishNode(e4, "TSTypeAssertion");
    }
    tsParseHeritageClause(e4) {
      const t3 = this.state.startLoc, r3 = this.tsParseDelimitedList("HeritageClauseElement", () => {
        const e5 = this.startNode();
        return e5.expression = this.tsParseEntityName(), this.match(47) && (e5.typeParameters = this.tsParseTypeArguments()), this.finishNode(e5, "TSExpressionWithTypeArguments");
      });
      return r3.length || this.raise(St.EmptyHeritageClauseType, t3, { token: e4 }), r3;
    }
    tsParseInterfaceDeclaration(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), t3.declare && (e4.declare = true), W(this.state.type) ? (e4.id = this.parseIdentifier(), this.checkIdentifier(e4.id, 130)) : (e4.id = null, this.raise(St.MissingInterfaceName, this.state.startLoc)), e4.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e4.extends = this.tsParseHeritageClause("extends"));
      const r3 = this.startNode();
      return r3.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e4.body = this.finishNode(r3, "TSInterfaceBody"), this.finishNode(e4, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(e4) {
      return e4.id = this.parseIdentifier(), this.checkIdentifier(e4.id, 2), e4.typeAnnotation = this.tsInType(() => {
        if (e4.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && 16 !== this.lookahead().type) {
          const e5 = this.startNode();
          return this.next(), this.finishNode(e5, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(e4, "TSTypeAliasDeclaration");
    }
    tsInNoContext(e4) {
      const t3 = this.state.context;
      this.state.context = [t3[0]];
      try {
        return e4();
      } finally {
        this.state.context = t3;
      }
    }
    tsInType(e4) {
      const t3 = this.state.inType;
      this.state.inType = true;
      try {
        return e4();
      } finally {
        this.state.inType = t3;
      }
    }
    tsInDisallowConditionalTypesContext(e4) {
      const t3 = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = true;
      try {
        return e4();
      } finally {
        this.state.inDisallowConditionalTypesContext = t3;
      }
    }
    tsInAllowConditionalTypesContext(e4) {
      const t3 = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = false;
      try {
        return e4();
      } finally {
        this.state.inDisallowConditionalTypesContext = t3;
      }
    }
    tsEatThenParseType(e4) {
      if (this.match(e4)) return this.tsNextThenParseType();
    }
    tsExpectThenParseType(e4) {
      return this.tsInType(() => (this.expect(e4), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      const e4 = this.startNode();
      return e4.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e4.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e4, "TSEnumMember");
    }
    tsParseEnumDeclaration(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3.const && (e4.const = true), t3.declare && (e4.declare = true), this.expectContextual(126), e4.id = this.parseIdentifier(), this.checkIdentifier(e4.id, e4.const ? 8971 : 8459), this.expect(5), e4.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e4, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const e4 = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(e4.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e4, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      if (e4.id = this.parseIdentifier(), t3 || this.checkIdentifier(e4.id, 1024), this.eat(16)) {
        const t4 = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(t4, true), e4.body = t4;
      } else this.scope.enter(256), this.prodParam.enter(0), e4.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(e4, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(e4) {
      return this.isContextual(112) ? (e4.global = true, e4.id = this.parseIdentifier()) : this.match(133) ? e4.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), e4.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e4, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(e4, t3, r3) {
      e4.isExport = r3 || false, e4.id = t3 || this.parseIdentifier(), this.checkIdentifier(e4.id, 4096), this.expect(29);
      const n3 = this.tsParseModuleReference();
      return "type" === e4.importKind && "TSExternalModuleReference" !== n3.type && this.raise(St.ImportAliasHasImportType, n3), e4.moduleReference = n3, this.semicolon(), this.finishNode(e4, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && 40 === this.lookaheadCharCode();
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }
    tsParseExternalModuleReference() {
      const e4 = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), e4.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = true, this.finishNode(e4, "TSExternalModuleReference");
    }
    tsLookAhead(e4) {
      const t3 = this.state.clone(), r3 = e4();
      return this.state = t3, r3;
    }
    tsTryParseAndCatch(e4) {
      const t3 = this.tryParse((t4) => e4() || t4());
      if (!t3.aborted && t3.node) return t3.error && (this.state = t3.failState), t3.node;
    }
    tsTryParse(e4) {
      const t3 = this.state.clone(), r3 = e4();
      if (void 0 !== r3 && false !== r3) return r3;
      this.state = t3;
    }
    tsTryParseDeclare(e4) {
      if (this.isLineTerminator()) return;
      let t3, r3 = this.state.type;
      return this.isContextual(100) && (r3 = 74, t3 = "let"), this.tsInAmbientContext(() => {
        switch (r3) {
          case 68:
            return e4.declare = true, super.parseFunctionStatement(e4, false, false);
          case 80:
            return e4.declare = true, this.parseClass(e4, true, false);
          case 126:
            return this.tsParseEnumDeclaration(e4, { declare: true });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(e4);
          case 75:
          case 74:
            return this.match(75) && this.isLookaheadContextual("enum") ? (this.expect(75), this.tsParseEnumDeclaration(e4, { const: true, declare: true })) : (e4.declare = true, this.parseVarStatement(e4, t3 || this.state.value, true));
          case 129: {
            const t4 = this.tsParseInterfaceDeclaration(e4, { declare: true });
            if (t4) return t4;
          }
          default:
            if (W(r3)) return this.tsParseDeclaration(e4, this.state.value, true, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
    }
    tsParseExpressionStatement(e4, t3, r3) {
      switch (t3.name) {
        case "declare": {
          const t4 = this.tsTryParseDeclare(e4);
          return t4 && (t4.declare = true), t4;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            const r4 = e4;
            return r4.global = true, r4.id = t3, r4.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r4, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(e4, t3.name, false, r3);
      }
    }
    tsParseDeclaration(e4, t3, r3, n3) {
      switch (t3) {
        case "abstract":
          if (this.tsCheckLineTerminator(r3) && (this.match(80) || W(this.state.type))) return this.tsParseAbstractDeclaration(e4, n3);
          break;
        case "module":
          if (this.tsCheckLineTerminator(r3)) {
            if (this.match(133)) return this.tsParseAmbientExternalModuleDeclaration(e4);
            if (W(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e4);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(r3) && W(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e4);
          break;
        case "type":
          if (this.tsCheckLineTerminator(r3) && W(this.state.type)) return this.tsParseTypeAliasDeclaration(e4);
      }
    }
    tsCheckLineTerminator(e4) {
      return e4 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(e4) {
      if (!this.match(47)) return;
      const t3 = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      const r3 = this.tsTryParseAndCatch(() => {
        const t4 = this.startNodeAt(e4);
        return t4.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(t4), t4.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), t4;
      });
      return this.state.maybeInArrowParameters = t3, r3 ? super.parseArrowExpression(r3, null, true) : void 0;
    }
    tsParseTypeArgumentsInExpression() {
      if (47 === this.reScan_lt()) return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const e4 = this.startNode();
      return e4.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), 0 === e4.params.length ? this.raise(St.EmptyTypeArguments, e4) : this.state.inType || this.curContext() !== w.brace || this.reScan_lt_gt(), this.expect(48), this.finishNode(e4, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return (e4 = this.state.type) >= 124 && e4 <= 130;
      var e4;
    }
    isExportDefaultSpecifier() {
      return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(e4, t3) {
      const r3 = this.state.startLoc, n3 = {};
      this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, n3);
      const s3 = n3.accessibility, i3 = n3.override, o3 = n3.readonly;
      4 & e4 || !(s3 || o3 || i3) || this.raise(St.UnexpectedParameterModifier, r3);
      const a3 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(a3, e4);
      const l2 = this.parseMaybeDefault(a3.loc.start, a3);
      if (s3 || o3 || i3) {
        const e5 = this.startNodeAt(r3);
        return t3.length && (e5.decorators = t3), s3 && (e5.accessibility = s3), o3 && (e5.readonly = o3), i3 && (e5.override = i3), "Identifier" !== l2.type && "AssignmentPattern" !== l2.type && this.raise(St.UnsupportedParameterPropertyKind, e5), e5.parameter = l2, this.finishNode(e5, "TSParameterProperty");
      }
      return t3.length && (a3.decorators = t3), l2;
    }
    isSimpleParameter(e4) {
      return "TSParameterProperty" === e4.type && super.isSimpleParameter(e4.parameter) || super.isSimpleParameter(e4);
    }
    tsDisallowOptionalPattern(e4) {
      for (const t3 of e4.params) "Identifier" !== t3.type && t3.optional && !this.state.isAmbientContext && this.raise(St.PatternIsOptional, t3);
    }
    setArrowFunctionParameters(e4, t3, r3) {
      super.setArrowFunctionParameters(e4, t3, r3), this.tsDisallowOptionalPattern(e4);
    }
    parseFunctionBodyAndFinish(e4, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      this.match(14) && (e4.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      const n3 = "FunctionDeclaration" === t3 ? "TSDeclareFunction" : "ClassMethod" === t3 || "ClassPrivateMethod" === t3 ? "TSDeclareMethod" : void 0;
      return n3 && !this.match(5) && this.isLineTerminator() ? this.finishNode(e4, n3) : "TSDeclareFunction" === n3 && this.state.isAmbientContext && (this.raise(St.DeclareFunctionHasImplementation, e4), e4.declare) ? super.parseFunctionBodyAndFinish(e4, n3, r3) : (this.tsDisallowOptionalPattern(e4), super.parseFunctionBodyAndFinish(e4, t3, r3));
    }
    registerFunctionStatementId(e4) {
      !e4.body && e4.id ? this.checkIdentifier(e4.id, 1024) : super.registerFunctionStatementId(e4);
    }
    tsCheckForInvalidTypeCasts(e4) {
      e4.forEach((e5) => {
        "TSTypeCastExpression" === (null == e5 ? void 0 : e5.type) && this.raise(St.UnexpectedTypeAnnotation, e5.typeAnnotation);
      });
    }
    toReferencedList(e4, t3) {
      return this.tsCheckForInvalidTypeCasts(e4), e4;
    }
    parseArrayLike(e4, t3, r3, n3) {
      const s3 = super.parseArrayLike(e4, t3, r3, n3);
      return "ArrayExpression" === s3.type && this.tsCheckForInvalidTypeCasts(s3.elements), s3;
    }
    parseSubscript(e4, t3, r3, n3) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = false, this.next();
        const r4 = this.startNodeAt(t3);
        return r4.expression = e4, this.finishNode(r4, "TSNonNullExpression");
      }
      let s3 = false;
      if (this.match(18) && 60 === this.lookaheadCharCode()) {
        if (r3) return n3.stop = true, e4;
        n3.optionalChainMember = s3 = true, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let i3;
        const o3 = this.tsTryParseAndCatch(() => {
          if (!r3 && this.atPossibleAsyncArrow(e4)) {
            const e5 = this.tsTryParseGenericAsyncArrowFunction(t3);
            if (e5) return e5;
          }
          const o4 = this.tsParseTypeArgumentsInExpression();
          if (!o4) return;
          if (s3 && !this.match(10)) return void (i3 = this.state.curPosition());
          if (Q(this.state.type)) {
            const r4 = super.parseTaggedTemplateExpression(e4, t3, n3);
            return r4.typeParameters = o4, r4;
          }
          if (!r3 && this.eat(10)) {
            const r4 = this.startNodeAt(t3);
            return r4.callee = e4, r4.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(r4.arguments), r4.typeParameters = o4, n3.optionalChainMember && (r4.optional = s3), this.finishCallExpression(r4, n3.optionalChainMember);
          }
          const a3 = this.state.type;
          if (48 === a3 || 52 === a3 || 10 !== a3 && z(a3) && !this.hasPrecedingLineBreak()) return;
          const l2 = this.startNodeAt(t3);
          return l2.expression = e4, l2.typeParameters = o4, this.finishNode(l2, "TSInstantiationExpression");
        });
        if (i3 && this.unexpected(i3, 10), o3) return "TSInstantiationExpression" === o3.type && (this.match(16) || this.match(18) && 40 !== this.lookaheadCharCode()) && this.raise(St.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), o3;
      }
      return super.parseSubscript(e4, t3, r3, n3);
    }
    parseNewCallee(e4) {
      var t3;
      super.parseNewCallee(e4);
      const { callee: r3 } = e4;
      "TSInstantiationExpression" !== r3.type || null != (t3 = r3.extra) && t3.parenthesized || (e4.typeParameters = r3.typeParameters, e4.callee = r3.expression);
    }
    parseExprOp(e4, t3, r3) {
      let n3;
      if (Y(58) > r3 && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n3 = this.isContextual(120)))) {
        const s3 = this.startNodeAt(t3);
        return s3.expression = e4, s3.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (n3 && this.raise(v.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(s3, n3 ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(s3, t3, r3);
      }
      return super.parseExprOp(e4, t3, r3);
    }
    checkReservedWord(e4, t3, r3, n3) {
      this.state.isAmbientContext || super.checkReservedWord(e4, t3, r3, n3);
    }
    checkImportReflection(e4) {
      super.checkImportReflection(e4), e4.module && "value" !== e4.importKind && this.raise(St.ImportReflectionHasImportType, e4.specifiers[0].loc.start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(e4) {
      if (super.isPotentialImportPhase(e4)) return true;
      if (this.isContextual(130)) {
        const t3 = this.lookaheadCharCode();
        return e4 ? 123 === t3 || 42 === t3 : 61 !== t3;
      }
      return !e4 && this.isContextual(87);
    }
    applyImportPhase(e4, t3, r3, n3) {
      super.applyImportPhase(e4, t3, r3, n3), t3 ? e4.exportKind = "type" === r3 ? "type" : "value" : e4.importKind = "type" === r3 || "typeof" === r3 ? r3 : "value";
    }
    parseImport(e4) {
      if (this.match(133)) return e4.importKind = "value", super.parseImport(e4);
      let t3;
      if (W(this.state.type) && 61 === this.lookaheadCharCode()) return e4.importKind = "value", this.tsParseImportEqualsDeclaration(e4);
      if (this.isContextual(130)) {
        const r3 = this.parseMaybeImportPhase(e4, false);
        if (61 === this.lookaheadCharCode()) return this.tsParseImportEqualsDeclaration(e4, r3);
        t3 = super.parseImportSpecifiersAndAfter(e4, r3);
      } else t3 = super.parseImport(e4);
      return "type" === t3.importKind && t3.specifiers.length > 1 && "ImportDefaultSpecifier" === t3.specifiers[0].type && this.raise(St.TypeImportCannotSpecifyDefaultAndNamed, t3), t3;
    }
    parseExport(e4, t3) {
      if (this.match(83)) {
        this.next();
        let t4 = null;
        return this.isContextual(130) && this.isPotentialImportPhase(false) ? t4 = this.parseMaybeImportPhase(e4, false) : e4.importKind = "value", this.tsParseImportEqualsDeclaration(e4, t4, true);
      }
      if (this.eat(29)) {
        const t4 = e4;
        return t4.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(t4, "TSExportAssignment");
      }
      if (this.eatContextual(93)) {
        const t4 = e4;
        return this.expectContextual(128), t4.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t4, "TSNamespaceExportDeclaration");
      }
      return super.parseExport(e4, t3);
    }
    isAbstractClass() {
      return this.isContextual(124) && 80 === this.lookahead().type;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const e4 = this.startNode();
        return this.next(), e4.abstract = true, this.parseClass(e4, true, true);
      }
      if (this.match(129)) {
        const e4 = this.tsParseInterfaceDeclaration(this.startNode());
        if (e4) return e4;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(e4, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      const { isAmbientContext: n3 } = this.state, s3 = super.parseVarStatement(e4, t3, r3 || n3);
      if (!n3) return s3;
      for (const { id: e5, init: r4 } of s3.declarations) r4 && ("const" !== t3 || e5.typeAnnotation ? this.raise(St.InitializerNotAllowedInAmbientContext, r4) : Pt(r4, this.hasPlugin("estree")) || this.raise(St.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, r4));
      return s3;
    }
    parseStatementContent(e4, t3) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        const e5 = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(e5, { const: true });
      }
      if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        const e5 = this.tsParseInterfaceDeclaration(this.startNode());
        if (e5) return e5;
      }
      return super.parseStatementContent(e4, t3);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(e4, t3) {
      return t3.some((t4) => xt(t4) ? e4.accessibility === t4 : !!e4[t4]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && 123 === this.lookaheadCharCode();
    }
    parseClassMember(e4, t3, r3) {
      const n3 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({ allowedModifiers: n3, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: St.InvalidModifierOnTypeParameterPositions }, t3);
      const s3 = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t3, n3) && this.raise(St.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e4, t3)) : this.parseClassMemberWithIsStatic(e4, t3, r3, !!t3.static);
      };
      t3.declare ? this.tsInAmbientContext(s3) : s3();
    }
    parseClassMemberWithIsStatic(e4, t3, r3, n3) {
      const s3 = this.tsTryParseIndexSignature(t3);
      if (s3) return e4.body.push(s3), t3.abstract && this.raise(St.IndexSignatureHasAbstract, t3), t3.accessibility && this.raise(St.IndexSignatureHasAccessibility, t3, { modifier: t3.accessibility }), t3.declare && this.raise(St.IndexSignatureHasDeclare, t3), void (t3.override && this.raise(St.IndexSignatureHasOverride, t3));
      !this.state.inAbstractClass && t3.abstract && this.raise(St.NonAbstractClassHasAbstractMethod, t3), t3.override && (r3.hadSuperClass || this.raise(St.OverrideNotInSubClass, t3)), super.parseClassMemberWithIsStatic(e4, t3, r3, n3);
    }
    parsePostMemberNameModifiers(e4) {
      this.eat(17) && (e4.optional = true), e4.readonly && this.match(10) && this.raise(St.ClassMethodHasReadonly, e4), e4.declare && this.match(10) && this.raise(St.ClassMethodHasDeclare, e4);
    }
    parseExpressionStatement(e4, t3, r3) {
      return ("Identifier" === t3.type ? this.tsParseExpressionStatement(e4, t3, r3) : void 0) || super.parseExpressionStatement(e4, t3, r3);
    }
    shouldParseExportDeclaration() {
      return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
    }
    parseConditional(e4, t3, r3) {
      if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(e4, t3, r3);
      const n3 = this.tryParse(() => super.parseConditional(e4, t3));
      return n3.node ? (n3.error && (this.state = n3.failState), n3.node) : (n3.error && super.setOptionalParametersError(r3, n3.error), e4);
    }
    parseParenItem(e4, t3) {
      if (e4 = super.parseParenItem(e4, t3), this.eat(17) && (e4.optional = true, this.resetEndLocation(e4)), this.match(14)) {
        const r3 = this.startNodeAt(t3);
        return r3.expression = e4, r3.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r3, "TSTypeCastExpression");
      }
      return e4;
    }
    parseExportDeclaration(e4) {
      if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e4));
      const t3 = this.state.startLoc, r3 = this.eatContextual(125);
      if (r3 && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(St.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      const n3 = W(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e4);
      return n3 ? (("TSInterfaceDeclaration" === n3.type || "TSTypeAliasDeclaration" === n3.type || r3) && (e4.exportKind = "type"), r3 && (this.resetStartLocation(n3, t3), n3.declare = true), n3) : null;
    }
    parseClassId(e4, t3, r3, n3) {
      if ((!t3 || r3) && this.isContextual(113)) return;
      super.parseClassId(e4, t3, r3, e4.declare ? 1024 : 8331);
      const s3 = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      s3 && (e4.typeParameters = s3);
    }
    parseClassPropertyAnnotation(e4) {
      e4.optional || (this.eat(35) ? e4.definite = true : this.eat(17) && (e4.optional = true));
      const t3 = this.tsTryParseTypeAnnotation();
      t3 && (e4.typeAnnotation = t3);
    }
    parseClassProperty(e4) {
      if (this.parseClassPropertyAnnotation(e4), this.state.isAmbientContext && (!e4.readonly || e4.typeAnnotation) && this.match(29) && this.raise(St.DeclareClassFieldHasInitializer, this.state.startLoc), e4.abstract && this.match(29)) {
        const { key: t3 } = e4;
        this.raise(St.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: "Identifier" !== t3.type || e4.computed ? `[${this.input.slice(t3.start, t3.end)}]` : t3.name });
      }
      return super.parseClassProperty(e4);
    }
    parseClassPrivateProperty(e4) {
      return e4.abstract && this.raise(St.PrivateElementHasAbstract, e4), e4.accessibility && this.raise(St.PrivateElementHasAccessibility, e4, { modifier: e4.accessibility }), this.parseClassPropertyAnnotation(e4), super.parseClassPrivateProperty(e4);
    }
    parseClassAccessorProperty(e4) {
      return this.parseClassPropertyAnnotation(e4), e4.optional && this.raise(St.AccessorCannotBeOptional, e4), super.parseClassAccessorProperty(e4);
    }
    pushClassMethod(e4, t3, r3, n3, s3, i3) {
      const o3 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o3 && s3 && this.raise(St.ConstructorHasTypeParameters, o3);
      const { declare: a3 = false, kind: l2 } = t3;
      !a3 || "get" !== l2 && "set" !== l2 || this.raise(St.DeclareAccessor, t3, { kind: l2 }), o3 && (t3.typeParameters = o3), super.pushClassMethod(e4, t3, r3, n3, s3, i3);
    }
    pushClassPrivateMethod(e4, t3, r3, n3) {
      const s3 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      s3 && (t3.typeParameters = s3), super.pushClassPrivateMethod(e4, t3, r3, n3);
    }
    declareClassPrivateMethodInScope(e4, t3) {
      "TSDeclareMethod" !== e4.type && ("MethodDefinition" !== e4.type || e4.value.body) && super.declareClassPrivateMethodInScope(e4, t3);
    }
    parseClassSuper(e4) {
      super.parseClassSuper(e4), e4.superClass && (this.match(47) || this.match(51)) && (e4.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e4.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(e4, t3, r3, n3, s3, i3, o3) {
      const a3 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return a3 && (e4.typeParameters = a3), super.parseObjPropValue(e4, t3, r3, n3, s3, i3, o3);
    }
    parseFunctionParams(e4, t3) {
      const r3 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      r3 && (e4.typeParameters = r3), super.parseFunctionParams(e4, t3);
    }
    parseVarId(e4, t3) {
      super.parseVarId(e4, t3), "Identifier" === e4.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (e4.definite = true);
      const r3 = this.tsTryParseTypeAnnotation();
      r3 && (e4.id.typeAnnotation = r3, this.resetEndLocation(e4.id));
    }
    parseAsyncArrowFromCallExpression(e4, t3) {
      return this.match(14) && (e4.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e4, t3);
    }
    parseMaybeAssign(e4, t3) {
      var r3, n3, s3, i3, o3;
      let a3, l2, c2, u2;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (a3 = this.state.clone(), l2 = this.tryParse(() => super.parseMaybeAssign(e4, t3), a3), !l2.error) return l2.node;
        const { context: r4 } = this.state, n4 = r4[r4.length - 1];
        n4 !== w.j_oTag && n4 !== w.j_expr || r4.pop();
      }
      if (!(null != (r3 = l2) && r3.error || this.match(47))) return super.parseMaybeAssign(e4, t3);
      a3 && a3 !== this.state || (a3 = this.state.clone());
      const p2 = this.tryParse((r4) => {
        var n4, s4;
        u2 = this.tsParseTypeParameters(this.tsParseConstModifier);
        const i4 = super.parseMaybeAssign(e4, t3);
        return ("ArrowFunctionExpression" !== i4.type || null != (n4 = i4.extra) && n4.parenthesized) && r4(), 0 !== (null == (s4 = u2) ? void 0 : s4.params.length) && this.resetStartLocationFromNode(i4, u2), i4.typeParameters = u2, i4;
      }, a3);
      if (!p2.error && !p2.aborted) return u2 && this.reportReservedArrowTypeParam(u2), p2.node;
      if (!l2 && (Et(!this.hasPlugin("jsx")), c2 = this.tryParse(() => super.parseMaybeAssign(e4, t3), a3), !c2.error)) return c2.node;
      if (null != (n3 = l2) && n3.node) return this.state = l2.failState, l2.node;
      if (p2.node) return this.state = p2.failState, u2 && this.reportReservedArrowTypeParam(u2), p2.node;
      if (null != (s3 = c2) && s3.node) return this.state = c2.failState, c2.node;
      throw (null == (i3 = l2) ? void 0 : i3.error) || p2.error || (null == (o3 = c2) ? void 0 : o3.error);
    }
    reportReservedArrowTypeParam(e4) {
      var t3;
      1 !== e4.params.length || e4.params[0].constraint || null != (t3 = e4.extra) && t3.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(St.ReservedArrowTypeParam, e4);
    }
    parseMaybeUnary(e4, t3) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e4, t3);
    }
    parseArrow(e4) {
      if (this.match(14)) {
        const t3 = this.tryParse((e5) => {
          const t4 = this.tsParseTypeOrTypePredicateAnnotation(14);
          return !this.canInsertSemicolon() && this.match(19) || e5(), t4;
        });
        if (t3.aborted) return;
        t3.thrown || (t3.error && (this.state = t3.failState), e4.returnType = t3.node);
      }
      return super.parseArrow(e4);
    }
    parseAssignableListItemTypes(e4, t3) {
      if (!(2 & t3)) return e4;
      this.eat(17) && (e4.optional = true);
      const r3 = this.tsTryParseTypeAnnotation();
      return r3 && (e4.typeAnnotation = r3), this.resetEndLocation(e4), e4;
    }
    isAssignable(e4, t3) {
      switch (e4.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(e4.expression, t3);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(e4, t3);
      }
    }
    toAssignable(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      switch (e4.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(e4, t3);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          t3 ? this.expressionScope.recordArrowParameterBindingError(St.UnexpectedTypeCastInParameter, e4) : this.raise(St.UnexpectedTypeCastInParameter, e4), this.toAssignable(e4.expression, t3);
          break;
        case "AssignmentExpression":
          t3 || "TSTypeCastExpression" !== e4.left.type || (e4.left = this.typeCastToParameter(e4.left));
        default:
          super.toAssignable(e4, t3);
      }
    }
    toAssignableParenthesizedExpression(e4, t3) {
      switch (e4.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(e4.expression, t3);
          break;
        default:
          super.toAssignable(e4, t3);
      }
    }
    checkToRestConversion(e4, t3) {
      switch (e4.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(e4.expression, false);
          break;
        default:
          super.checkToRestConversion(e4, t3);
      }
    }
    isValidLVal(e4, t3, r3) {
      return n3 = { TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (64 !== r3 || !t3) && ["expression", true], TSSatisfiesExpression: (64 !== r3 || !t3) && ["expression", true], TSTypeAssertion: (64 !== r3 || !t3) && ["expression", true] }, s3 = e4, Object.hasOwnProperty.call(n3, s3) && n3[s3] || super.isValidLVal(e4, t3, r3);
      var n3, s3;
    }
    parseBindingAtom() {
      return 78 === this.state.type ? this.parseIdentifier(true) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(e4) {
      if (this.match(47) || this.match(51)) {
        const t3 = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const r3 = super.parseMaybeDecoratorArguments(e4);
          return r3.typeParameters = t3, r3;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(e4);
    }
    checkCommaAfterRest(e4) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e4 ? (this.next(), false) : super.checkCommaAfterRest(e4);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(e4, t3) {
      const r3 = super.parseMaybeDefault(e4, t3);
      return "AssignmentPattern" === r3.type && r3.typeAnnotation && r3.right.start < r3.typeAnnotation.start && this.raise(St.TypeAnnotationAfterAssign, r3.typeAnnotation), r3;
    }
    getTokenFromCode(e4) {
      if (this.state.inType) {
        if (62 === e4) return void this.finishOp(48, 1);
        if (60 === e4) return void this.finishOp(47, 1);
      }
      super.getTokenFromCode(e4);
    }
    reScan_lt_gt() {
      const { type: e4 } = this.state;
      47 === e4 ? (this.state.pos -= 1, this.readToken_lt()) : 48 === e4 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      const { type: e4 } = this.state;
      return 51 === e4 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e4;
    }
    toAssignableList(e4, t3, r3) {
      for (let t4 = 0; t4 < e4.length; t4++) {
        const r4 = e4[t4];
        "TSTypeCastExpression" === (null == r4 ? void 0 : r4.type) && (e4[t4] = this.typeCastToParameter(r4));
      }
      super.toAssignableList(e4, t3, r3);
    }
    typeCastToParameter(e4) {
      return e4.expression.typeAnnotation = e4.typeAnnotation, this.resetEndLocation(e4.expression, e4.typeAnnotation.loc.end), e4.expression;
    }
    shouldParseArrow(e4) {
      return this.match(14) ? e4.every((e5) => this.isAssignable(e5, true)) : super.shouldParseArrow(e4);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(e4) {
      if (this.match(47) || this.match(51)) {
        const t3 = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        t3 && (e4.typeParameters = t3);
      }
      return super.jsxParseOpeningElementAfterName(e4);
    }
    getGetterSetterExpectedParamCount(e4) {
      const t3 = super.getGetterSetterExpectedParamCount(e4), r3 = this.getObjectOrClassMethodParams(e4)[0];
      return r3 && this.isThisParam(r3) ? t3 + 1 : t3;
    }
    parseCatchClauseParam() {
      const e4 = super.parseCatchClauseParam(), t3 = this.tsTryParseTypeAnnotation();
      return t3 && (e4.typeAnnotation = t3, this.resetEndLocation(e4)), e4;
    }
    tsInAmbientContext(e4) {
      const t3 = this.state.isAmbientContext;
      this.state.isAmbientContext = true;
      try {
        return e4();
      } finally {
        this.state.isAmbientContext = t3;
      }
    }
    parseClass(e4, t3, r3) {
      const n3 = this.state.inAbstractClass;
      this.state.inAbstractClass = !!e4.abstract;
      try {
        return super.parseClass(e4, t3, r3);
      } finally {
        this.state.inAbstractClass = n3;
      }
    }
    tsParseAbstractDeclaration(e4, t3) {
      if (this.match(80)) return e4.abstract = true, this.maybeTakeDecorators(t3, this.parseClass(e4, true, false));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak()) return e4.abstract = true, this.raise(St.NonClassMethodPropertyHasAbstractModifer, e4), this.tsParseInterfaceDeclaration(e4);
      } else this.unexpected(null, 80);
    }
    parseMethod(e4, t3, r3, n3, s3, i3, o3) {
      const a3 = super.parseMethod(e4, t3, r3, n3, s3, i3, o3);
      if (a3.abstract && (this.hasPlugin("estree") ? a3.value.body : a3.body)) {
        const { key: e5 } = a3;
        this.raise(St.AbstractMethodHasImplementation, a3, { methodName: "Identifier" !== e5.type || a3.computed ? `[${this.input.slice(e5.start, e5.end)}]` : e5.name });
      }
      return a3;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
    }
    parseExportSpecifier(e4, t3, r3, n3) {
      return !t3 && n3 ? (this.parseTypeOnlyImportExportSpecifier(e4, false, r3), this.finishNode(e4, "ExportSpecifier")) : (e4.exportKind = "value", super.parseExportSpecifier(e4, t3, r3, n3));
    }
    parseImportSpecifier(e4, t3, r3, n3, s3) {
      return !t3 && n3 ? (this.parseTypeOnlyImportExportSpecifier(e4, true, r3), this.finishNode(e4, "ImportSpecifier")) : (e4.importKind = "value", super.parseImportSpecifier(e4, t3, r3, n3, r3 ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(e4, t3, r3) {
      const n3 = t3 ? "imported" : "local", s3 = t3 ? "local" : "exported";
      let i3, o3 = e4[n3], a3 = false, l2 = true;
      const c2 = o3.loc.start;
      if (this.isContextual(93)) {
        const e5 = this.parseIdentifier();
        if (this.isContextual(93)) {
          const r4 = this.parseIdentifier();
          G(this.state.type) ? (a3 = true, o3 = e5, i3 = t3 ? this.parseIdentifier() : this.parseModuleExportName(), l2 = false) : (i3 = r4, l2 = false);
        } else G(this.state.type) ? (l2 = false, i3 = t3 ? this.parseIdentifier() : this.parseModuleExportName()) : (a3 = true, o3 = e5);
      } else G(this.state.type) && (a3 = true, t3 ? (o3 = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(o3.name, o3.loc.start, true, true)) : o3 = this.parseModuleExportName());
      a3 && r3 && this.raise(t3 ? St.TypeModifierIsUsedInTypeImports : St.TypeModifierIsUsedInTypeExports, c2), e4[n3] = o3, e4[s3] = i3, e4[t3 ? "importKind" : "exportKind"] = a3 ? "type" : "value", l2 && this.eatContextual(93) && (e4[s3] = t3 ? this.parseIdentifier() : this.parseModuleExportName()), e4[s3] || (e4[s3] = it(e4[n3])), t3 && this.checkIdentifier(e4[s3], a3 ? 4098 : 4096);
    }
  }, v8intrinsic: (e3) => class extends e3 {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const e4 = this.state.startLoc, t3 = this.startNode();
        if (this.next(), W(this.state.type)) {
          const e5 = this.parseIdentifierName(), r3 = this.createIdentifier(t3, e5);
          if (r3.type = "V8IntrinsicIdentifier", this.match(10)) return r3;
        }
        this.unexpected(e4);
      }
    }
    parseExprAtom(e4) {
      return this.parseV8Intrinsic() || super.parseExprAtom(e4);
    }
  }, placeholders: (e3) => class extends e3 {
    parsePlaceholder(e4) {
      if (this.match(144)) {
        const t3 = this.startNode();
        return this.next(), this.assertNoSpace(), t3.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(t3, e4);
      }
    }
    finishPlaceholder(e4, t3) {
      const r3 = !(!e4.expectedNode || "Placeholder" !== e4.type);
      return e4.expectedNode = t3, r3 ? e4 : this.finishNode(e4, "Placeholder");
    }
    getTokenFromCode(e4) {
      37 === e4 && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(144, 2) : super.getTokenFromCode(e4);
    }
    parseExprAtom(e4) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(e4);
    }
    parseIdentifier(e4) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(e4);
    }
    checkReservedWord(e4, t3, r3, n3) {
      void 0 !== e4 && super.checkReservedWord(e4, t3, r3, n3);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(e4, t3, r3) {
      return "Placeholder" === e4 || super.isValidLVal(e4, t3, r3);
    }
    toAssignable(e4, t3) {
      e4 && "Placeholder" === e4.type && "Expression" === e4.expectedNode ? e4.expectedNode = "Pattern" : super.toAssignable(e4, t3);
    }
    chStartsBindingIdentifier(e4, t3) {
      return !!super.chStartsBindingIdentifier(e4, t3) || 144 === this.lookahead().type;
    }
    verifyBreakContinue(e4, t3) {
      e4.label && "Placeholder" === e4.label.type || super.verifyBreakContinue(e4, t3);
    }
    parseExpressionStatement(e4, t3) {
      var r3;
      if ("Placeholder" !== t3.type || null != (r3 = t3.extra) && r3.parenthesized) return super.parseExpressionStatement(e4, t3);
      if (this.match(14)) {
        const r4 = e4;
        return r4.label = this.finishPlaceholder(t3, "Identifier"), this.next(), r4.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(r4, "LabeledStatement");
      }
      return this.semicolon(), e4.name = t3.name, this.finishPlaceholder(e4, "Statement");
    }
    parseBlock(e4, t3, r3) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(e4, t3, r3);
    }
    parseFunctionId(e4) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(e4);
    }
    parseClass(e4, t3, r3) {
      const n3 = t3 ? "ClassDeclaration" : "ClassExpression";
      this.next();
      const s3 = this.state.strict, i3 = this.parsePlaceholder("Identifier");
      if (i3) {
        if (!(this.match(81) || this.match(144) || this.match(5))) {
          if (r3 || !t3) return e4.id = null, e4.body = this.finishPlaceholder(i3, "ClassBody"), this.finishNode(e4, n3);
          throw this.raise(Ot.ClassNameIsRequired, this.state.startLoc);
        }
        e4.id = i3;
      } else this.parseClassId(e4, t3, r3);
      return super.parseClassSuper(e4), e4.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e4.superClass, s3), this.finishNode(e4, n3);
    }
    parseExport(e4, t3) {
      const r3 = this.parsePlaceholder("Identifier");
      if (!r3) return super.parseExport(e4, t3);
      if (!this.isContextual(98) && !this.match(12)) return e4.specifiers = [], e4.source = null, e4.declaration = this.finishPlaceholder(r3, "Declaration"), this.finishNode(e4, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const n3 = this.startNode();
      return n3.exported = r3, e4.specifiers = [this.finishNode(n3, "ExportDefaultSpecifier")], super.parseExport(e4, t3);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const e4 = this.nextTokenStart();
        if (this.isUnparsedContextual(e4, "from") && this.input.startsWith(J(144), this.nextTokenStartSince(e4 + 4))) return true;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(e4, t3) {
      var r3;
      return !(null == (r3 = e4.specifiers) || !r3.length) || super.maybeParseExportDefaultSpecifier(e4, t3);
    }
    checkExport(e4) {
      const { specifiers: t3 } = e4;
      null != t3 && t3.length && (e4.specifiers = t3.filter((e5) => "Placeholder" === e5.exported.type)), super.checkExport(e4), e4.specifiers = t3;
    }
    parseImport(e4) {
      const t3 = this.parsePlaceholder("Identifier");
      if (!t3) return super.parseImport(e4);
      if (e4.specifiers = [], !this.isContextual(98) && !this.match(12)) return e4.source = this.finishPlaceholder(t3, "StringLiteral"), this.semicolon(), this.finishNode(e4, "ImportDeclaration");
      const r3 = this.startNodeAtNode(t3);
      return r3.local = t3, e4.specifiers.push(this.finishNode(r3, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e4) || this.parseNamedImportSpecifiers(e4)), this.expectContextual(98), e4.source = this.parseImportSource(), this.semicolon(), this.finishNode(e4, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(Ot.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  } }, Lt = Object.keys(jt), Mt = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createImportExpressions: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
  class Bt extends vt {
    checkProto(e3, t3, r3, n3) {
      if ("SpreadElement" === e3.type || this.isObjectMethod(e3) || e3.computed || e3.shorthand) return;
      const s3 = e3.key;
      if ("__proto__" === ("Identifier" === s3.type ? s3.name : s3.value)) {
        if (t3) return void this.raise(v.RecordNoProto, s3);
        r3.used && (n3 ? null === n3.doubleProtoLoc && (n3.doubleProtoLoc = s3.loc.start) : this.raise(v.DuplicateProto, s3)), r3.used = true;
      }
    }
    shouldExitDescending(e3, t3) {
      return "ArrowFunctionExpression" === e3.type && e3.start === t3;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      const e3 = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), e3.comments = this.comments, e3.errors = this.state.errors, this.options.tokens && (e3.tokens = this.tokens), e3;
    }
    parseExpression(e3, t3) {
      return e3 ? this.disallowInAnd(() => this.parseExpressionBase(t3)) : this.allowInAnd(() => this.parseExpressionBase(t3));
    }
    parseExpressionBase(e3) {
      const t3 = this.state.startLoc, r3 = this.parseMaybeAssign(e3);
      if (this.match(12)) {
        const n3 = this.startNodeAt(t3);
        for (n3.expressions = [r3]; this.eat(12); ) n3.expressions.push(this.parseMaybeAssign(e3));
        return this.toReferencedList(n3.expressions), this.finishNode(n3, "SequenceExpression");
      }
      return r3;
    }
    parseMaybeAssignDisallowIn(e3, t3) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e3, t3));
    }
    parseMaybeAssignAllowIn(e3, t3) {
      return this.allowInAnd(() => this.parseMaybeAssign(e3, t3));
    }
    setOptionalParametersError(e3, t3) {
      var r3;
      e3.optionalParametersLoc = null != (r3 = null == t3 ? void 0 : t3.loc) ? r3 : this.state.startLoc;
    }
    parseMaybeAssign(e3, t3) {
      const r3 = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let e4 = this.parseYield();
        return t3 && (e4 = t3.call(this, e4, r3)), e4;
      }
      let n3;
      e3 ? n3 = false : (e3 = new rt(), n3 = true);
      const { type: s3 } = this.state;
      (10 === s3 || W(s3)) && (this.state.potentialArrowAt = this.state.start);
      let i3 = this.parseMaybeConditional(e3);
      if (t3 && (i3 = t3.call(this, i3, r3)), (o3 = this.state.type) >= 29 && o3 <= 33) {
        const t4 = this.startNodeAt(r3), n4 = this.state.value;
        if (t4.operator = n4, this.match(29)) {
          this.toAssignable(i3, true), t4.left = i3;
          const n5 = r3.index;
          null != e3.doubleProtoLoc && e3.doubleProtoLoc.index >= n5 && (e3.doubleProtoLoc = null), null != e3.shorthandAssignLoc && e3.shorthandAssignLoc.index >= n5 && (e3.shorthandAssignLoc = null), null != e3.privateKeyLoc && e3.privateKeyLoc.index >= n5 && (this.checkDestructuringPrivate(e3), e3.privateKeyLoc = null);
        } else t4.left = i3;
        return this.next(), t4.right = this.parseMaybeAssign(), this.checkLVal(i3, { in: this.finishNode(t4, "AssignmentExpression") }), t4;
      }
      var o3;
      return n3 && this.checkExpressionErrors(e3, true), i3;
    }
    parseMaybeConditional(e3) {
      const t3 = this.state.startLoc, r3 = this.state.potentialArrowAt, n3 = this.parseExprOps(e3);
      return this.shouldExitDescending(n3, r3) ? n3 : this.parseConditional(n3, t3, e3);
    }
    parseConditional(e3, t3, r3) {
      if (this.eat(17)) {
        const r4 = this.startNodeAt(t3);
        return r4.test = e3, r4.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), r4.alternate = this.parseMaybeAssign(), this.finishNode(r4, "ConditionalExpression");
      }
      return e3;
    }
    parseMaybeUnaryOrPrivate(e3) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(e3);
    }
    parseExprOps(e3) {
      const t3 = this.state.startLoc, r3 = this.state.potentialArrowAt, n3 = this.parseMaybeUnaryOrPrivate(e3);
      return this.shouldExitDescending(n3, r3) ? n3 : this.parseExprOp(n3, t3, -1);
    }
    parseExprOp(e3, t3, r3) {
      if (this.isPrivateName(e3)) {
        const t4 = this.getPrivateNameSV(e3);
        (r3 >= Y(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(v.PrivateInExpectedIn, e3, { identifierName: t4 }), this.classScope.usePrivateName(t4, e3.loc.start);
      }
      const n3 = this.state.type;
      if ((s3 = n3) >= 39 && s3 <= 59 && (this.prodParam.hasIn || !this.match(58))) {
        let s4 = Y(n3);
        if (s4 > r3) {
          if (39 === n3) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return e3;
            this.checkPipelineAtInfixOperator(e3, t3);
          }
          const i3 = this.startNodeAt(t3);
          i3.left = e3, i3.operator = this.state.value;
          const o3 = 41 === n3 || 42 === n3, a3 = 40 === n3;
          if (a3 && (s4 = Y(42)), this.next(), 39 === n3 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && 96 === this.state.type && this.prodParam.hasAwait) throw this.raise(v.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          i3.right = this.parseExprOpRightExpr(n3, s4);
          const l2 = this.finishNode(i3, o3 || a3 ? "LogicalExpression" : "BinaryExpression"), c2 = this.state.type;
          if (a3 && (41 === c2 || 42 === c2) || o3 && 40 === c2) throw this.raise(v.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(l2, t3, r3);
        }
      }
      var s3;
      return e3;
    }
    parseExprOpRightExpr(e3, t3) {
      const r3 = this.state.startLoc;
      if (39 === e3) switch (this.getPluginOption("pipelineOperator", "proposal")) {
        case "hack":
          return this.withTopicBindingContext(() => this.parseHackPipeBody());
        case "smart":
          return this.withTopicBindingContext(() => {
            if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(v.PipeBodyIsTighter, this.state.startLoc);
            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e3, t3), r3);
          });
        case "fsharp":
          return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t3));
      }
      return this.parseExprOpBaseRightExpr(e3, t3);
    }
    parseExprOpBaseRightExpr(e3, t3) {
      const r3 = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r3, 57 === e3 ? t3 - 1 : t3);
    }
    parseHackPipeBody() {
      var e3;
      const { startLoc: t3 } = this.state, r3 = this.parseMaybeAssign();
      return !d.has(r3.type) || null != (e3 = r3.extra) && e3.parenthesized || this.raise(v.PipeUnparenthesizedBody, t3, { type: r3.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(v.PipeTopicUnused, t3), r3;
    }
    checkExponentialAfterUnary(e3) {
      this.match(57) && this.raise(v.UnexpectedTokenUnaryExponentiation, e3.argument);
    }
    parseMaybeUnary(e3, t3) {
      const r3 = this.state.startLoc, n3 = this.isContextual(96);
      if (n3 && this.isAwaitAllowed()) {
        this.next();
        const e4 = this.parseAwait(r3);
        return t3 || this.checkExponentialAfterUnary(e4), e4;
      }
      const s3 = this.match(34), i3 = this.startNode();
      if (o3 = this.state.type, U[o3]) {
        i3.operator = this.state.value, i3.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
        const r4 = this.match(89);
        if (this.next(), i3.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e3, true), this.state.strict && r4) {
          const e4 = i3.argument;
          "Identifier" === e4.type ? this.raise(v.StrictDelete, i3) : this.hasPropertyAsPrivateName(e4) && this.raise(v.DeletePrivateField, i3);
        }
        if (!s3) return t3 || this.checkExponentialAfterUnary(i3), this.finishNode(i3, "UnaryExpression");
      }
      var o3;
      const a3 = this.parseUpdate(i3, s3, e3);
      if (n3) {
        const { type: e4 } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? z(e4) : z(e4) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(v.AwaitNotInAsyncContext, r3), this.parseAwait(r3);
      }
      return a3;
    }
    parseUpdate(e3, t3, r3) {
      if (t3) {
        const t4 = e3;
        return this.checkLVal(t4.argument, { in: this.finishNode(t4, "UpdateExpression") }), e3;
      }
      const n3 = this.state.startLoc;
      let s3 = this.parseExprSubscripts(r3);
      if (this.checkExpressionErrors(r3, false)) return s3;
      for (; 34 === this.state.type && !this.canInsertSemicolon(); ) {
        const e4 = this.startNodeAt(n3);
        e4.operator = this.state.value, e4.prefix = false, e4.argument = s3, this.next(), this.checkLVal(s3, { in: s3 = this.finishNode(e4, "UpdateExpression") });
      }
      return s3;
    }
    parseExprSubscripts(e3) {
      const t3 = this.state.startLoc, r3 = this.state.potentialArrowAt, n3 = this.parseExprAtom(e3);
      return this.shouldExitDescending(n3, r3) ? n3 : this.parseSubscripts(n3, t3);
    }
    parseSubscripts(e3, t3, r3) {
      const n3 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(e3), stop: false };
      do {
        e3 = this.parseSubscript(e3, t3, r3, n3), n3.maybeAsyncArrow = false;
      } while (!n3.stop);
      return e3;
    }
    parseSubscript(e3, t3, r3, n3) {
      const { type: s3 } = this.state;
      if (!r3 && 15 === s3) return this.parseBind(e3, t3, r3, n3);
      if (Q(s3)) return this.parseTaggedTemplateExpression(e3, t3, n3);
      let i3 = false;
      if (18 === s3) {
        if (r3 && (this.raise(v.OptionalChainingNoNew, this.state.startLoc), 40 === this.lookaheadCharCode())) return n3.stop = true, e3;
        n3.optionalChainMember = i3 = true, this.next();
      }
      if (!r3 && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(e3, t3, n3, i3);
      {
        const r4 = this.eat(0);
        return r4 || i3 || this.eat(16) ? this.parseMember(e3, t3, n3, r4, i3) : (n3.stop = true, e3);
      }
    }
    parseMember(e3, t3, r3, n3, s3) {
      const i3 = this.startNodeAt(t3);
      return i3.object = e3, i3.computed = n3, n3 ? (i3.property = this.parseExpression(), this.expect(3)) : this.match(138) ? ("Super" === e3.type && this.raise(v.SuperPrivateField, t3), this.classScope.usePrivateName(this.state.value, this.state.startLoc), i3.property = this.parsePrivateName()) : i3.property = this.parseIdentifier(true), r3.optionalChainMember ? (i3.optional = s3, this.finishNode(i3, "OptionalMemberExpression")) : this.finishNode(i3, "MemberExpression");
    }
    parseBind(e3, t3, r3, n3) {
      const s3 = this.startNodeAt(t3);
      return s3.object = e3, this.next(), s3.callee = this.parseNoCallExpr(), n3.stop = true, this.parseSubscripts(this.finishNode(s3, "BindExpression"), t3, r3);
    }
    parseCoverCallAndAsyncArrowHead(e3, t3, r3, n3) {
      const s3 = this.state.maybeInArrowParameters;
      let i3 = null;
      this.state.maybeInArrowParameters = true, this.next();
      const o3 = this.startNodeAt(t3);
      o3.callee = e3;
      const { maybeAsyncArrow: a3, optionalChainMember: l2 } = r3;
      a3 && (this.expressionScope.enter(new Je(2)), i3 = new rt()), l2 && (o3.optional = n3), o3.arguments = n3 ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, "Import" === e3.type, "Super" !== e3.type, o3, i3);
      let c2 = this.finishCallExpression(o3, l2);
      return a3 && this.shouldParseAsyncArrow() && !n3 ? (r3.stop = true, this.checkDestructuringPrivate(i3), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), c2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t3), c2)) : (a3 && (this.checkExpressionErrors(i3, true), this.expressionScope.exit()), this.toReferencedArguments(c2)), this.state.maybeInArrowParameters = s3, c2;
    }
    toReferencedArguments(e3, t3) {
      this.toReferencedListDeep(e3.arguments, t3);
    }
    parseTaggedTemplateExpression(e3, t3, r3) {
      const n3 = this.startNodeAt(t3);
      return n3.tag = e3, n3.quasi = this.parseTemplate(true), r3.optionalChainMember && this.raise(v.OptionalChainingNoTemplate, t3), this.finishNode(n3, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e3) {
      return "Identifier" === e3.type && "async" === e3.name && this.state.lastTokEndLoc.index === e3.end && !this.canInsertSemicolon() && e3.end - e3.start == 5 && e3.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(e3, t3) {
      if ("Import" === e3.callee.type) if (2 === e3.arguments.length && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), 0 === e3.arguments.length || e3.arguments.length > 2) this.raise(v.ImportCallArity, e3, { maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
      else for (const t4 of e3.arguments) "SpreadElement" === t4.type && this.raise(v.ImportCallSpreadArgument, t4);
      return this.finishNode(e3, t3 ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e3, t3, r3, n3, s3) {
      const i3 = [];
      let o3 = true;
      const a3 = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = false; !this.eat(e3); ) {
        if (o3) o3 = false;
        else if (this.expect(12), this.match(e3)) {
          !t3 || this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(v.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), n3 && this.addTrailingCommaExtraToNode(n3), this.next();
          break;
        }
        i3.push(this.parseExprListItem(false, s3, r3));
      }
      return this.state.inFSharpPipelineDirectBody = a3, i3;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e3, t3) {
      var r3;
      return this.resetPreviousNodeTrailingComments(t3), this.expect(19), this.parseArrowExpression(e3, t3.arguments, true, null == (r3 = t3.extra) ? void 0 : r3.trailingCommaLoc), t3.innerComments && Te(e3, t3.innerComments), t3.callee.trailingComments && Te(e3, t3.callee.trailingComments), e3;
    }
    parseNoCallExpr() {
      const e3 = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e3, true);
    }
    parseExprAtom(e3) {
      let t3, r3 = null;
      const { type: n3 } = this.state;
      switch (n3) {
        case 79:
          return this.parseSuper();
        case 83:
          return t3 = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(t3) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(t3) : this.finishNode(t3, "Import") : (this.raise(v.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(t3, "Import"));
        case 78:
          return t3 = this.startNode(), this.next(), this.finishNode(t3, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), false);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(true);
        case 86:
          return this.parseBooleanLiteral(false);
        case 10: {
          const e4 = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(e4);
        }
        case 2:
        case 1:
          return this.parseArrayLike(2 === this.state.type ? 4 : 3, false, true);
        case 0:
          return this.parseArrayLike(3, true, false, e3);
        case 6:
        case 7:
          return this.parseObjectLike(6 === this.state.type ? 9 : 8, false, true);
        case 5:
          return this.parseObjectLike(8, false, false, e3);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          r3 = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(r3, this.startNode()), false);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(false);
        case 15: {
          t3 = this.startNode(), this.next(), t3.object = null;
          const e4 = t3.callee = this.parseNoCallExpr();
          if ("MemberExpression" === e4.type) return this.finishNode(t3, "BindExpression");
          throw this.raise(v.UnsupportedBind, e4);
        }
        case 138:
          return this.raise(v.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          const e4 = this.getPluginOption("pipelineOperator", "proposal");
          if (e4) return this.parseTopicReference(e4);
          this.unexpected();
          break;
        }
        case 47: {
          const e4 = this.input.codePointAt(this.nextTokenStart());
          ae(e4) || 62 === e4 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (W(n3)) {
            if (this.isContextual(127) && 123 === this.lookaheadInLineCharCode()) return this.parseModuleExpression();
            const e4 = this.state.potentialArrowAt === this.state.start, t4 = this.state.containsEsc, r4 = this.parseIdentifier();
            if (!t4 && "async" === r4.name && !this.canInsertSemicolon()) {
              const { type: e5 } = this.state;
              if (68 === e5) return this.resetPreviousNodeTrailingComments(r4), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(r4));
              if (W(e5)) return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(r4)) : r4;
              if (90 === e5) return this.resetPreviousNodeTrailingComments(r4), this.parseDo(this.startNodeAtNode(r4), true);
            }
            return e4 && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(r4), [r4], false)) : r4;
          }
          this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e3, t3) {
      const r3 = this.getPluginOption("pipelineOperator", "proposal");
      if (r3) return this.state.type = e3, this.state.value = t3, this.state.pos--, this.state.end--, this.state.endLoc = o2(this.state.endLoc, -1), this.parseTopicReference(r3);
      this.unexpected();
    }
    parseTopicReference(e3) {
      const t3 = this.startNode(), r3 = this.state.startLoc, n3 = this.state.type;
      return this.next(), this.finishTopicReference(t3, r3, e3, n3);
    }
    finishTopicReference(e3, t3, r3, n3) {
      if (this.testTopicReferenceConfiguration(r3, t3, n3)) {
        const n4 = "smart" === r3 ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise("smart" === r3 ? v.PrimaryTopicNotAllowed : v.PipeTopicUnbound, t3), this.registerTopicReference(), this.finishNode(e3, n4);
      }
      throw this.raise(v.PipeTopicUnconfiguredToken, t3, { token: J(n3) });
    }
    testTopicReferenceConfiguration(e3, t3, r3) {
      switch (e3) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", { topicToken: J(r3) }]);
        case "smart":
          return 27 === r3;
        default:
          throw this.raise(v.PipeTopicRequiresHackPipes, t3);
      }
    }
    parseAsyncArrowUnaryFunction(e3) {
      this.prodParam.enter(et(true, this.prodParam.hasYield));
      const t3 = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(v.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(e3, t3, true);
    }
    parseDo(e3, t3) {
      this.expectPlugin("doExpressions"), t3 && this.expectPlugin("asyncDoExpressions"), e3.async = t3, this.next();
      const r3 = this.state.labels;
      return this.state.labels = [], t3 ? (this.prodParam.enter(2), e3.body = this.parseBlock(), this.prodParam.exit()) : e3.body = this.parseBlock(), this.state.labels = r3, this.finishNode(e3, "DoExpression");
    }
    parseSuper() {
      const e3 = this.startNode();
      return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(v.UnexpectedSuper, e3) : this.raise(v.SuperNotAllowed, e3), this.match(10) || this.match(0) || this.match(16) || this.raise(v.UnsupportedSuper, e3), this.finishNode(e3, "Super");
    }
    parsePrivateName() {
      const e3 = this.startNode(), t3 = this.startNodeAt(o2(this.state.startLoc, 1)), r3 = this.state.value;
      return this.next(), e3.id = this.createIdentifier(t3, r3), this.finishNode(e3, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const e3 = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        const t3 = this.createIdentifier(this.startNodeAtNode(e3), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(e3, t3, "sent");
      }
      return this.parseFunction(e3);
    }
    parseMetaProperty(e3, t3, r3) {
      e3.meta = t3;
      const n3 = this.state.containsEsc;
      return e3.property = this.parseIdentifier(true), (e3.property.name !== r3 || n3) && this.raise(v.UnsupportedMetaProperty, e3.property, { target: t3.name, onlyValidPropertyName: r3 }), this.finishNode(e3, "MetaProperty");
    }
    parseImportMetaProperty(e3) {
      const t3 = this.createIdentifier(this.startNodeAtNode(e3), "import");
      if (this.next(), this.isContextual(101)) this.inModule || this.raise(v.ImportMetaOutsideModule, t3), this.sawUnambiguousESM = true;
      else if (this.isContextual(105) || this.isContextual(97)) {
        const t4 = this.isContextual(105);
        if (t4 || this.unexpected(), this.expectPlugin(t4 ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions) throw this.raise(v.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
        return this.next(), e3.phase = t4 ? "source" : "defer", this.parseImportCall(e3);
      }
      return this.parseMetaProperty(e3, t3, "meta");
    }
    parseLiteralAtNode(e3, t3, r3) {
      return this.addExtra(r3, "rawValue", e3), this.addExtra(r3, "raw", this.input.slice(r3.start, this.state.end)), r3.value = e3, this.next(), this.finishNode(r3, t3);
    }
    parseLiteral(e3, t3) {
      const r3 = this.startNode();
      return this.parseLiteralAtNode(e3, t3, r3);
    }
    parseStringLiteral(e3) {
      return this.parseLiteral(e3, "StringLiteral");
    }
    parseNumericLiteral(e3) {
      return this.parseLiteral(e3, "NumericLiteral");
    }
    parseBigIntLiteral(e3) {
      return this.parseLiteral(e3, "BigIntLiteral");
    }
    parseDecimalLiteral(e3) {
      return this.parseLiteral(e3, "DecimalLiteral");
    }
    parseRegExpLiteral(e3) {
      const t3 = this.parseLiteral(e3.value, "RegExpLiteral");
      return t3.pattern = e3.pattern, t3.flags = e3.flags, t3;
    }
    parseBooleanLiteral(e3) {
      const t3 = this.startNode();
      return t3.value = e3, this.next(), this.finishNode(t3, "BooleanLiteral");
    }
    parseNullLiteral() {
      const e3 = this.startNode();
      return this.next(), this.finishNode(e3, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e3) {
      const t3 = this.state.startLoc;
      let r3;
      this.next(), this.expressionScope.enter(new Je(1));
      const n3 = this.state.maybeInArrowParameters, s3 = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
      const i3 = this.state.startLoc, o3 = [], a3 = new rt();
      let l2, c2, u2 = true;
      for (; !this.match(11); ) {
        if (u2) u2 = false;
        else if (this.expect(12, null === a3.optionalParametersLoc ? null : a3.optionalParametersLoc), this.match(11)) {
          c2 = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          const e4 = this.state.startLoc;
          if (l2 = this.state.startLoc, o3.push(this.parseParenItem(this.parseRestBinding(), e4)), !this.checkCommaAfterRest(41)) break;
        } else o3.push(this.parseMaybeAssignAllowIn(a3, this.parseParenItem));
      }
      const p2 = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = n3, this.state.inFSharpPipelineDirectBody = s3;
      let d2 = this.startNodeAt(t3);
      return e3 && this.shouldParseArrow(o3) && (d2 = this.parseArrow(d2)) ? (this.checkDestructuringPrivate(a3), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(d2, o3, false), d2) : (this.expressionScope.exit(), o3.length || this.unexpected(this.state.lastTokStartLoc), c2 && this.unexpected(c2), l2 && this.unexpected(l2), this.checkExpressionErrors(a3, true), this.toReferencedListDeep(o3, true), o3.length > 1 ? (r3 = this.startNodeAt(i3), r3.expressions = o3, this.finishNode(r3, "SequenceExpression"), this.resetEndLocation(r3, p2)) : r3 = o3[0], this.wrapParenthesis(t3, r3));
    }
    wrapParenthesis(e3, t3) {
      if (!this.options.createParenthesizedExpressions) return this.addExtra(t3, "parenthesized", true), this.addExtra(t3, "parenStart", e3.index), this.takeSurroundingComments(t3, e3.index, this.state.lastTokEndLoc.index), t3;
      const r3 = this.startNodeAt(e3);
      return r3.expression = t3, this.finishNode(r3, "ParenthesizedExpression");
    }
    shouldParseArrow(e3) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e3) {
      if (this.eat(19)) return e3;
    }
    parseParenItem(e3, t3) {
      return e3;
    }
    parseNewOrNewTarget() {
      const e3 = this.startNode();
      if (this.next(), this.match(16)) {
        const t3 = this.createIdentifier(this.startNodeAtNode(e3), "new");
        this.next();
        const r3 = this.parseMetaProperty(e3, t3, "target");
        return this.scope.inNonArrowFunction || this.scope.inClass || this.options.allowNewTargetOutsideFunction || this.raise(v.UnexpectedNewTarget, r3), r3;
      }
      return this.parseNew(e3);
    }
    parseNew(e3) {
      if (this.parseNewCallee(e3), this.eat(10)) {
        const t3 = this.parseExprList(11);
        this.toReferencedList(t3), e3.arguments = t3;
      } else e3.arguments = [];
      return this.finishNode(e3, "NewExpression");
    }
    parseNewCallee(e3) {
      const t3 = this.match(83), r3 = this.parseNoCallExpr();
      e3.callee = r3, !t3 || "Import" !== r3.type && "ImportExpression" !== r3.type || this.raise(v.ImportCallNotNewExpression, r3);
    }
    parseTemplateElement(e3) {
      const { start: t3, startLoc: r3, end: n3, value: s3 } = this.state, i3 = t3 + 1, a3 = this.startNodeAt(o2(r3, 1));
      null === s3 && (e3 || this.raise(v.InvalidEscapeSequenceTemplate, o2(this.state.firstInvalidTemplateEscapePos, 1)));
      const l2 = this.match(24), c2 = l2 ? -1 : -2, u2 = n3 + c2;
      a3.value = { raw: this.input.slice(i3, u2).replace(/\r\n?/g, "\n"), cooked: null === s3 ? null : s3.slice(1, c2) }, a3.tail = l2, this.next();
      const p2 = this.finishNode(a3, "TemplateElement");
      return this.resetEndLocation(p2, o2(this.state.lastTokEndLoc, c2)), p2;
    }
    parseTemplate(e3) {
      const t3 = this.startNode();
      t3.expressions = [];
      let r3 = this.parseTemplateElement(e3);
      for (t3.quasis = [r3]; !r3.tail; ) t3.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), t3.quasis.push(r3 = this.parseTemplateElement(e3));
      return this.finishNode(t3, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e3, t3, r3, n3) {
      r3 && this.expectPlugin("recordAndTuple");
      const s3 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const i3 = /* @__PURE__ */ Object.create(null);
      let o3 = true;
      const a3 = this.startNode();
      for (a3.properties = [], this.next(); !this.match(e3); ) {
        if (o3) o3 = false;
        else if (this.expect(12), this.match(e3)) {
          this.addTrailingCommaExtraToNode(a3);
          break;
        }
        let s4;
        t3 ? s4 = this.parseBindingProperty() : (s4 = this.parsePropertyDefinition(n3), this.checkProto(s4, r3, i3, n3)), r3 && !this.isObjectProperty(s4) && "SpreadElement" !== s4.type && this.raise(v.InvalidRecordProperty, s4), s4.shorthand && this.addExtra(s4, "shorthand", true), a3.properties.push(s4);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = s3;
      let l2 = "ObjectExpression";
      return t3 ? l2 = "ObjectPattern" : r3 && (l2 = "RecordExpression"), this.finishNode(a3, l2);
    }
    addTrailingCommaExtraToNode(e3) {
      this.addExtra(e3, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e3, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    }
    maybeAsyncOrAccessorProp(e3) {
      return !e3.computed && "Identifier" === e3.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e3) {
      let t3 = [];
      if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(v.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) t3.push(this.parseDecorator());
      const r3 = this.startNode();
      let n3, s3 = false, i3 = false;
      if (this.match(21)) return t3.length && this.unexpected(), this.parseSpread();
      t3.length && (r3.decorators = t3, t3 = []), r3.method = false, e3 && (n3 = this.state.startLoc);
      let o3 = this.eat(55);
      this.parsePropertyNamePrefixOperator(r3);
      const a3 = this.state.containsEsc, l2 = this.parsePropertyName(r3, e3);
      if (!o3 && !a3 && this.maybeAsyncOrAccessorProp(r3)) {
        const e4 = l2.name;
        "async" !== e4 || this.hasPrecedingLineBreak() || (s3 = true, this.resetPreviousNodeTrailingComments(l2), o3 = this.eat(55), this.parsePropertyName(r3)), "get" !== e4 && "set" !== e4 || (i3 = true, this.resetPreviousNodeTrailingComments(l2), r3.kind = e4, this.match(55) && (o3 = true, this.raise(v.AccessorIsGenerator, this.state.curPosition(), { kind: e4 }), this.next()), this.parsePropertyName(r3));
      }
      return this.parseObjPropValue(r3, n3, o3, s3, false, i3, e3);
    }
    getGetterSetterExpectedParamCount(e3) {
      return "get" === e3.kind ? 0 : 1;
    }
    getObjectOrClassMethodParams(e3) {
      return e3.params;
    }
    checkGetterSetterParams(e3) {
      var t3;
      const r3 = this.getGetterSetterExpectedParamCount(e3), n3 = this.getObjectOrClassMethodParams(e3);
      n3.length !== r3 && this.raise("get" === e3.kind ? v.BadGetterArity : v.BadSetterArity, e3), "set" === e3.kind && "RestElement" === (null == (t3 = n3[n3.length - 1]) ? void 0 : t3.type) && this.raise(v.BadSetterRestParameter, e3);
    }
    parseObjectMethod(e3, t3, r3, n3, s3) {
      if (s3) {
        const r4 = this.parseMethod(e3, t3, false, false, false, "ObjectMethod");
        return this.checkGetterSetterParams(r4), r4;
      }
      if (r3 || t3 || this.match(10)) return n3 && this.unexpected(), e3.kind = "method", e3.method = true, this.parseMethod(e3, t3, r3, false, false, "ObjectMethod");
    }
    parseObjectProperty(e3, t3, r3, n3) {
      if (e3.shorthand = false, this.eat(14)) return e3.value = r3 ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n3), this.finishNode(e3, "ObjectProperty");
      if (!e3.computed && "Identifier" === e3.key.type) {
        if (this.checkReservedWord(e3.key.name, e3.key.loc.start, true, false), r3) e3.value = this.parseMaybeDefault(t3, it(e3.key));
        else if (this.match(29)) {
          const r4 = this.state.startLoc;
          null != n3 ? null === n3.shorthandAssignLoc && (n3.shorthandAssignLoc = r4) : this.raise(v.InvalidCoverInitializedName, r4), e3.value = this.parseMaybeDefault(t3, it(e3.key));
        } else e3.value = it(e3.key);
        return e3.shorthand = true, this.finishNode(e3, "ObjectProperty");
      }
    }
    parseObjPropValue(e3, t3, r3, n3, s3, i3, o3) {
      const a3 = this.parseObjectMethod(e3, r3, n3, s3, i3) || this.parseObjectProperty(e3, t3, s3, o3);
      return a3 || this.unexpected(), a3;
    }
    parsePropertyName(e3, t3) {
      if (this.eat(0)) e3.computed = true, e3.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        const { type: r3, value: n3 } = this.state;
        let s3;
        if (G(r3)) s3 = this.parseIdentifier(true);
        else switch (r3) {
          case 134:
            s3 = this.parseNumericLiteral(n3);
            break;
          case 133:
            s3 = this.parseStringLiteral(n3);
            break;
          case 135:
            s3 = this.parseBigIntLiteral(n3);
            break;
          case 136:
            s3 = this.parseDecimalLiteral(n3);
            break;
          case 138: {
            const e4 = this.state.startLoc;
            null != t3 ? null === t3.privateKeyLoc && (t3.privateKeyLoc = e4) : this.raise(v.UnexpectedPrivateField, e4), s3 = this.parsePrivateName();
            break;
          }
          default:
            this.unexpected();
        }
        e3.key = s3, 138 !== r3 && (e3.computed = false);
      }
      return e3.key;
    }
    initFunction(e3, t3) {
      e3.id = null, e3.generator = false, e3.async = t3;
    }
    parseMethod(e3, t3, r3, n3, s3, i3) {
      let o3 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
      this.initFunction(e3, r3), e3.generator = t3, this.scope.enter(18 | (o3 ? 64 : 0) | (s3 ? 32 : 0)), this.prodParam.enter(et(r3, e3.generator)), this.parseFunctionParams(e3, n3);
      const a3 = this.parseFunctionBodyAndFinish(e3, i3, true);
      return this.prodParam.exit(), this.scope.exit(), a3;
    }
    parseArrayLike(e3, t3, r3, n3) {
      r3 && this.expectPlugin("recordAndTuple");
      const s3 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const i3 = this.startNode();
      return this.next(), i3.elements = this.parseExprList(e3, !r3, n3, i3), this.state.inFSharpPipelineDirectBody = s3, this.finishNode(i3, r3 ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e3, t3, r3, n3) {
      this.scope.enter(6);
      let s3 = et(r3, false);
      !this.match(5) && this.prodParam.hasIn && (s3 |= 8), this.prodParam.enter(s3), this.initFunction(e3, r3);
      const i3 = this.state.maybeInArrowParameters;
      return t3 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(e3, t3, n3)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(e3, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = i3, this.finishNode(e3, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(e3, t3, r3) {
      this.toAssignableList(t3, r3, false), e3.params = t3;
    }
    parseFunctionBodyAndFinish(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      return this.parseFunctionBody(e3, false, r3), this.finishNode(e3, t3);
    }
    parseFunctionBody(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      const n3 = t3 && !this.match(5);
      if (this.expressionScope.enter(Qe()), n3) e3.body = this.parseMaybeAssign(), this.checkParams(e3, false, t3, false);
      else {
        const n4 = this.state.strict, s3 = this.state.labels;
        this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), e3.body = this.parseBlock(true, false, (s4) => {
          const i3 = !this.isSimpleParamList(e3.params);
          s4 && i3 && this.raise(v.IllegalLanguageModeDirective, "method" !== e3.kind && "constructor" !== e3.kind || !e3.key ? e3 : e3.key.loc.end);
          const o3 = !n4 && this.state.strict;
          this.checkParams(e3, !(this.state.strict || t3 || r3 || i3), t3, o3), this.state.strict && e3.id && this.checkIdentifier(e3.id, 65, o3);
        }), this.prodParam.exit(), this.state.labels = s3;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e3) {
      return "Identifier" === e3.type;
    }
    isSimpleParamList(e3) {
      for (let t3 = 0, r3 = e3.length; t3 < r3; t3++) if (!this.isSimpleParameter(e3[t3])) return false;
      return true;
    }
    checkParams(e3, t3, r3) {
      let n3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      const s3 = !t3 && /* @__PURE__ */ new Set(), i3 = { type: "FormalParameters" };
      for (const t4 of e3.params) this.checkLVal(t4, { in: i3, binding: 5, checkClashes: s3, strictModeChanged: n3 });
    }
    parseExprList(e3, t3, r3, n3) {
      const s3 = [];
      let i3 = true;
      for (; !this.eat(e3); ) {
        if (i3) i3 = false;
        else if (this.expect(12), this.match(e3)) {
          n3 && this.addTrailingCommaExtraToNode(n3), this.next();
          break;
        }
        s3.push(this.parseExprListItem(t3, r3));
      }
      return s3;
    }
    parseExprListItem(e3, t3, r3) {
      let n3;
      if (this.match(12)) e3 || this.raise(v.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), n3 = null;
      else if (this.match(21)) {
        const e4 = this.state.startLoc;
        n3 = this.parseParenItem(this.parseSpread(t3), e4);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), r3 || this.raise(v.UnexpectedArgumentPlaceholder, this.state.startLoc);
        const e4 = this.startNode();
        this.next(), n3 = this.finishNode(e4, "ArgumentPlaceholder");
      } else n3 = this.parseMaybeAssignAllowIn(t3, this.parseParenItem);
      return n3;
    }
    parseIdentifier(e3) {
      const t3 = this.startNode(), r3 = this.parseIdentifierName(e3);
      return this.createIdentifier(t3, r3);
    }
    createIdentifier(e3, t3) {
      return e3.name = t3, e3.loc.identifierName = t3, this.finishNode(e3, "Identifier");
    }
    parseIdentifierName(e3) {
      let t3;
      const { startLoc: r3, type: n3 } = this.state;
      G(n3) ? t3 = this.state.value : this.unexpected();
      const s3 = n3 <= 92;
      return e3 ? s3 && this.replaceToken(132) : this.checkReservedWord(t3, r3, s3, false), this.next(), t3;
    }
    checkReservedWord(e3, t3, r3, n3) {
      if (!(e3.length > 10) && function(e4) {
        return ye.has(e4);
      }(e3)) {
        if (r3 && function(e4) {
          return ce.has(e4);
        }(e3)) this.raise(v.UnexpectedKeyword, t3, { keyword: e3 });
        else if ((this.state.strict ? n3 ? me : fe : de)(e3, this.inModule)) this.raise(v.UnexpectedReservedWord, t3, { reservedWord: e3 });
        else if ("yield" === e3) {
          if (this.prodParam.hasYield) return void this.raise(v.YieldBindingIdentifier, t3);
        } else if ("await" === e3) {
          if (this.prodParam.hasAwait) return void this.raise(v.AwaitBindingIdentifier, t3);
          if (this.scope.inStaticBlock) return void this.raise(v.AwaitBindingIdentifierInStaticBlock, t3);
          this.expressionScope.recordAsyncArrowParametersError(t3);
        } else if ("arguments" === e3 && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(v.ArgumentsInClass, t3);
      }
    }
    isAwaitAllowed() {
      return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
    }
    parseAwait(e3) {
      const t3 = this.startNodeAt(e3);
      return this.expressionScope.recordParameterInitializerError(v.AwaitExpressionFormalParameter, t3), this.eat(55) && this.raise(v.ObsoleteAwaitStar, t3), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (t3.argument = this.parseMaybeUnary(null, true)), this.finishNode(t3, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return true;
      const { type: e3 } = this.state;
      return 53 === e3 || 10 === e3 || 0 === e3 || Q(e3) || 102 === e3 && !this.state.containsEsc || 137 === e3 || 56 === e3 || this.hasPlugin("v8intrinsic") && 54 === e3;
    }
    parseYield() {
      const e3 = this.startNode();
      this.expressionScope.recordParameterInitializerError(v.YieldInParameter, e3), this.next();
      let t3 = false, r3 = null;
      if (!this.hasPrecedingLineBreak()) switch (t3 = this.eat(55), this.state.type) {
        case 13:
        case 139:
        case 8:
        case 11:
        case 3:
        case 9:
        case 14:
        case 12:
          if (!t3) break;
        default:
          r3 = this.parseMaybeAssign();
      }
      return e3.delegate = t3, e3.argument = r3, this.finishNode(e3, "YieldExpression");
    }
    parseImportCall(e3) {
      return this.next(), e3.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (e3.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e3.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(e3, "ImportExpression");
    }
    checkPipelineAtInfixOperator(e3, t3) {
      this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && "SequenceExpression" === e3.type && this.raise(v.PipelineHeadSequenceExpression, t3);
    }
    parseSmartPipelineBodyInStyle(e3, t3) {
      if (this.isSimpleReference(e3)) {
        const r3 = this.startNodeAt(t3);
        return r3.callee = e3, this.finishNode(r3, "PipelineBareFunction");
      }
      {
        const r3 = this.startNodeAt(t3);
        return this.checkSmartPipeTopicBodyEarlyErrors(t3), r3.expression = e3, this.finishNode(r3, "PipelineTopicExpression");
      }
    }
    isSimpleReference(e3) {
      switch (e3.type) {
        case "MemberExpression":
          return !e3.computed && this.isSimpleReference(e3.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e3) {
      if (this.match(19)) throw this.raise(v.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(v.PipelineTopicUnused, e3);
    }
    withTopicBindingContext(e3) {
      const t3 = this.state.topicContext;
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
      try {
        return e3();
      } finally {
        this.state.topicContext = t3;
      }
    }
    withSmartMixTopicForbiddingContext(e3) {
      if (!this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) return e3();
      {
        const t3 = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
        try {
          return e3();
        } finally {
          this.state.topicContext = t3;
        }
      }
    }
    withSoloAwaitPermittingContext(e3) {
      const t3 = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return e3();
      } finally {
        this.state.soloAwait = t3;
      }
    }
    allowInAnd(e3) {
      const t3 = this.prodParam.currentFlags();
      if (8 & ~t3) {
        this.prodParam.enter(8 | t3);
        try {
          return e3();
        } finally {
          this.prodParam.exit();
        }
      }
      return e3();
    }
    disallowInAnd(e3) {
      const t3 = this.prodParam.currentFlags();
      if (8 & t3) {
        this.prodParam.enter(-9 & t3);
        try {
          return e3();
        } finally {
          this.prodParam.exit();
        }
      }
      return e3();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e3) {
      const t3 = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const r3 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const n3 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t3, e3);
      return this.state.inFSharpPipelineDirectBody = r3, n3;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const e3 = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      const t3 = this.startNodeAt(this.state.endLoc);
      this.next();
      const r3 = this.initializeScopes(true);
      this.enterInitialScopes();
      try {
        e3.body = this.parseProgram(t3, 8, "module");
      } finally {
        r3();
      }
      return this.finishNode(e3, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e3) {
    }
  }
  const Rt = { kind: 1 }, Ft = { kind: 2 }, Ut = /[\uD800-\uDFFF]/u, $t = /in(?:stanceof)?/y;
  class Vt extends Bt {
    parseTopLevel(e3, t3) {
      return e3.program = this.parseProgram(t3), e3.comments = this.comments, this.options.tokens && (e3.tokens = function(e4, t4) {
        for (let r3 = 0; r3 < e4.length; r3++) {
          const n3 = e4[r3], { type: s3 } = n3;
          if ("number" == typeof s3) {
            if (138 === s3) {
              const { loc: t5, start: s4, value: i3, end: a3 } = n3, l2 = s4 + 1, c2 = o2(t5.start, 1);
              e4.splice(r3, 1, new Ge({ type: Z(27), value: "#", start: s4, end: l2, startLoc: t5.start, endLoc: c2 }), new Ge({ type: Z(132), value: i3, start: l2, end: a3, startLoc: c2, endLoc: t5.end })), r3++;
              continue;
            }
            if (Q(s3)) {
              const { loc: i3, start: a3, value: l2, end: c2 } = n3, u2 = a3 + 1, p2 = o2(i3.start, 1);
              let d2, f2, h2, m2, y2;
              d2 = 96 === t4.charCodeAt(a3) ? new Ge({ type: Z(22), value: "`", start: a3, end: u2, startLoc: i3.start, endLoc: p2 }) : new Ge({ type: Z(8), value: "}", start: a3, end: u2, startLoc: i3.start, endLoc: p2 }), 24 === s3 ? (h2 = c2 - 1, m2 = o2(i3.end, -1), f2 = null === l2 ? null : l2.slice(1, -1), y2 = new Ge({ type: Z(22), value: "`", start: h2, end: c2, startLoc: m2, endLoc: i3.end })) : (h2 = c2 - 2, m2 = o2(i3.end, -2), f2 = null === l2 ? null : l2.slice(1, -2), y2 = new Ge({ type: Z(23), value: "${", start: h2, end: c2, startLoc: m2, endLoc: i3.end })), e4.splice(r3, 1, d2, new Ge({ type: Z(20), value: f2, start: u2, end: h2, startLoc: p2, endLoc: m2 }), y2), r3 += 2;
              continue;
            }
            n3.type = Z(s3);
          }
        }
        return e4;
      }(this.tokens, this.input)), this.finishNode(e3, "File");
    }
    parseProgram(e3) {
      let t3, r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 139, n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.options.sourceType;
      if (e3.sourceType = n3, e3.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e3, true, true, r3), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (const [e4, t4] of Array.from(this.scope.undefinedExports)) this.raise(v.ModuleExportUndefined, t4, { localName: e4 });
      return t3 = 139 === r3 ? this.finishNode(e3, "Program") : this.finishNodeAt(e3, "Program", o2(this.state.startLoc, -1)), t3;
    }
    stmtToDirective(e3) {
      const t3 = e3;
      t3.type = "Directive", t3.value = t3.expression, delete t3.expression;
      const r3 = t3.value, n3 = r3.value, s3 = this.input.slice(r3.start, r3.end), i3 = r3.value = s3.slice(1, -1);
      return this.addExtra(r3, "raw", s3), this.addExtra(r3, "rawValue", i3), this.addExtra(r3, "expressionValue", n3), r3.type = "DirectiveLiteral", t3;
    }
    parseInterpreterDirective() {
      if (!this.match(28)) return null;
      const e3 = this.startNode();
      return e3.value = this.state.value, this.next(), this.finishNode(e3, "InterpreterDirective");
    }
    isLet() {
      return !!this.isContextual(100) && this.hasFollowingBindingAtom();
    }
    chStartsBindingIdentifier(e3, t3) {
      if (ae(e3)) {
        if ($t.lastIndex = t3, $t.test(this.input)) {
          const e4 = this.codePointAtPos($t.lastIndex);
          if (!le(e4) && 92 !== e4) return false;
        }
        return true;
      }
      return 92 === e3;
    }
    chStartsBindingPattern(e3) {
      return 91 === e3 || 123 === e3;
    }
    hasFollowingBindingAtom() {
      const e3 = this.nextTokenStart(), t3 = this.codePointAtPos(e3);
      return this.chStartsBindingPattern(t3) || this.chStartsBindingIdentifier(t3, e3);
    }
    hasInLineFollowingBindingIdentifier() {
      const e3 = this.nextTokenInLineStart(), t3 = this.codePointAtPos(e3);
      return this.chStartsBindingIdentifier(t3, e3);
    }
    startsUsingForOf() {
      const { type: e3, containsEsc: t3 } = this.lookahead();
      return !(102 === e3 && !t3) && (W(e3) && !this.hasFollowingLineBreak() ? (this.expectPlugin("explicitResourceManagement"), true) : void 0);
    }
    startsAwaitUsing() {
      let e3 = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e3, "using")) {
        e3 = this.nextTokenInLineStartSince(e3 + 5);
        const t3 = this.codePointAtPos(e3);
        if (this.chStartsBindingIdentifier(t3, e3)) return this.expectPlugin("explicitResourceManagement"), true;
      }
      return false;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t3 = 0;
      return this.options.annexB && !this.state.strict && (t3 |= 4, e3 && (t3 |= 8)), this.parseStatementLike(t3);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(e3) {
      let t3 = null;
      return this.match(26) && (t3 = this.parseDecorators(true)), this.parseStatementContent(e3, t3);
    }
    parseStatementContent(e3, t3) {
      const r3 = this.state.type, n3 = this.startNode(), s3 = !!(2 & e3), i3 = !!(4 & e3), o3 = 1 & e3;
      switch (r3) {
        case 60:
          return this.parseBreakContinueStatement(n3, true);
        case 63:
          return this.parseBreakContinueStatement(n3, false);
        case 64:
          return this.parseDebuggerStatement(n3);
        case 90:
          return this.parseDoWhileStatement(n3);
        case 91:
          return this.parseForStatement(n3);
        case 68:
          if (46 === this.lookaheadCharCode()) break;
          return i3 || this.raise(this.state.strict ? v.StrictFunction : this.options.annexB ? v.SloppyFunctionAnnexB : v.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(n3, false, !s3 && i3);
        case 80:
          return s3 || this.unexpected(), this.parseClass(this.maybeTakeDecorators(t3, n3), true);
        case 69:
          return this.parseIfStatement(n3);
        case 70:
          return this.parseReturnStatement(n3);
        case 71:
          return this.parseSwitchStatement(n3);
        case 72:
          return this.parseThrowStatement(n3);
        case 73:
          return this.parseTryStatement(n3);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing()) return this.isAwaitAllowed() ? s3 || this.raise(v.UnexpectedLexicalDeclaration, n3) : this.raise(v.AwaitUsingNotInAsyncContext, n3), this.next(), this.parseVarStatement(n3, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(v.UnexpectedUsingDeclaration, this.state.startLoc) : s3 || this.raise(v.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(n3, "using");
        case 100: {
          if (this.state.containsEsc) break;
          const e4 = this.nextTokenStart(), t4 = this.codePointAtPos(e4);
          if (91 !== t4) {
            if (!s3 && this.hasFollowingLineBreak()) break;
            if (!this.chStartsBindingIdentifier(t4, e4) && 123 !== t4) break;
          }
        }
        case 75:
          s3 || this.raise(v.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          const e4 = this.state.value;
          return this.parseVarStatement(n3, e4);
        }
        case 92:
          return this.parseWhileStatement(n3);
        case 76:
          return this.parseWithStatement(n3);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(n3);
        case 83: {
          const e4 = this.lookaheadCharCode();
          if (40 === e4 || 46 === e4) break;
        }
        case 82: {
          let e4;
          return this.options.allowImportExportEverywhere || o3 || this.raise(v.UnexpectedImportExport, this.state.startLoc), this.next(), 83 === r3 ? (e4 = this.parseImport(n3), "ImportDeclaration" !== e4.type || e4.importKind && "value" !== e4.importKind || (this.sawUnambiguousESM = true)) : (e4 = this.parseExport(n3, t3), ("ExportNamedDeclaration" !== e4.type || e4.exportKind && "value" !== e4.exportKind) && ("ExportAllDeclaration" !== e4.type || e4.exportKind && "value" !== e4.exportKind) && "ExportDefaultDeclaration" !== e4.type || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(e4), e4;
        }
        default:
          if (this.isAsyncFunction()) return s3 || this.raise(v.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(n3, true, !s3 && i3);
      }
      const a3 = this.state.value, l2 = this.parseExpression();
      return W(r3) && "Identifier" === l2.type && this.eat(14) ? this.parseLabeledStatement(n3, a3, l2, e3) : this.parseExpressionStatement(n3, l2, t3);
    }
    assertModuleNodeAllowed(e3) {
      this.options.allowImportExportEverywhere || this.inModule || this.raise(v.ImportOutsideModule, e3);
    }
    decoratorsEnabledBeforeExport() {
      return !!this.hasPlugin("decorators-legacy") || this.hasPlugin("decorators") && false !== this.getPluginOption("decorators", "decoratorsBeforeExport");
    }
    maybeTakeDecorators(e3, t3, r3) {
      return e3 && (t3.decorators && t3.decorators.length > 0 ? ("boolean" != typeof this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(v.DecoratorsBeforeAfterExport, t3.decorators[0]), t3.decorators.unshift(...e3)) : t3.decorators = e3, this.resetStartLocationFromNode(t3, e3[0]), r3 && this.resetStartLocationFromNode(r3, t3)), t3;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e3) {
      const t3 = [];
      do {
        t3.push(this.parseDecorator());
      } while (this.match(26));
      if (this.match(82)) e3 || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(v.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator()) throw this.raise(v.UnexpectedLeadingDecorator, this.state.startLoc);
      return t3;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const e3 = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        const t3 = this.state.startLoc;
        let r3;
        if (this.match(10)) {
          const t4 = this.state.startLoc;
          this.next(), r3 = this.parseExpression(), this.expect(11), r3 = this.wrapParenthesis(t4, r3);
          const n3 = this.state.startLoc;
          e3.expression = this.parseMaybeDecoratorArguments(r3), false === this.getPluginOption("decorators", "allowCallParenthesized") && e3.expression !== r3 && this.raise(v.DecoratorArgumentsOutsideParentheses, n3);
        } else {
          for (r3 = this.parseIdentifier(false); this.eat(16); ) {
            const e4 = this.startNodeAt(t3);
            e4.object = r3, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), e4.property = this.parsePrivateName()) : e4.property = this.parseIdentifier(true), e4.computed = false, r3 = this.finishNode(e4, "MemberExpression");
          }
          e3.expression = this.parseMaybeDecoratorArguments(r3);
        }
      } else e3.expression = this.parseExprSubscripts();
      return this.finishNode(e3, "Decorator");
    }
    parseMaybeDecoratorArguments(e3) {
      if (this.eat(10)) {
        const t3 = this.startNodeAtNode(e3);
        return t3.callee = e3, t3.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(t3.arguments), this.finishNode(t3, "CallExpression");
      }
      return e3;
    }
    parseBreakContinueStatement(e3, t3) {
      return this.next(), this.isLineTerminator() ? e3.label = null : (e3.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e3, t3), this.finishNode(e3, t3 ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e3, t3) {
      let r3;
      for (r3 = 0; r3 < this.state.labels.length; ++r3) {
        const n3 = this.state.labels[r3];
        if (null == e3.label || n3.name === e3.label.name) {
          if (null != n3.kind && (t3 || 1 === n3.kind)) break;
          if (e3.label && t3) break;
        }
      }
      if (r3 === this.state.labels.length) {
        const r4 = t3 ? "BreakStatement" : "ContinueStatement";
        this.raise(v.IllegalBreakContinue, e3, { type: r4 });
      }
    }
    parseDebuggerStatement(e3) {
      return this.next(), this.semicolon(), this.finishNode(e3, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const e3 = this.parseExpression();
      return this.expect(11), e3;
    }
    parseDoWhileStatement(e3) {
      return this.next(), this.state.labels.push(Rt), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), e3.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e3, "DoWhileStatement");
    }
    parseForStatement(e3) {
      this.next(), this.state.labels.push(Rt);
      let t3 = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (t3 = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13)) return null !== t3 && this.unexpected(t3), this.parseFor(e3, null);
      const r3 = this.isContextual(100);
      {
        const n4 = this.isContextual(96) && this.startsAwaitUsing(), s4 = n4 || this.isContextual(107) && this.startsUsingForOf(), i4 = r3 && this.hasFollowingBindingAtom() || s4;
        if (this.match(74) || this.match(75) || i4) {
          const r4 = this.startNode();
          let i5;
          n4 ? (i5 = "await using", this.isAwaitAllowed() || this.raise(v.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : i5 = this.state.value, this.next(), this.parseVar(r4, true, i5);
          const o4 = this.finishNode(r4, "VariableDeclaration"), a3 = this.match(58);
          return a3 && s4 && this.raise(v.ForInUsing, o4), (a3 || this.isContextual(102)) && 1 === o4.declarations.length ? this.parseForIn(e3, o4, t3) : (null !== t3 && this.unexpected(t3), this.parseFor(e3, o4));
        }
      }
      const n3 = this.isContextual(95), s3 = new rt(), i3 = this.parseExpression(true, s3), o3 = this.isContextual(102);
      if (o3 && (r3 && this.raise(v.ForOfLet, i3), null === t3 && n3 && "Identifier" === i3.type && this.raise(v.ForOfAsync, i3)), o3 || this.match(58)) {
        this.checkDestructuringPrivate(s3), this.toAssignable(i3, true);
        const r4 = o3 ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(i3, { in: { type: r4 } }), this.parseForIn(e3, i3, t3);
      }
      return this.checkExpressionErrors(s3, true), null !== t3 && this.unexpected(t3), this.parseFor(e3, i3);
    }
    parseFunctionStatement(e3, t3, r3) {
      return this.next(), this.parseFunction(e3, 1 | (r3 ? 2 : 0) | (t3 ? 8 : 0));
    }
    parseIfStatement(e3) {
      return this.next(), e3.test = this.parseHeaderExpression(), e3.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e3.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e3, "IfStatement");
    }
    parseReturnStatement(e3) {
      return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(v.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? e3.argument = null : (e3.argument = this.parseExpression(), this.semicolon()), this.finishNode(e3, "ReturnStatement");
    }
    parseSwitchStatement(e3) {
      this.next(), e3.discriminant = this.parseHeaderExpression();
      const t3 = e3.cases = [];
      let r3;
      this.expect(5), this.state.labels.push(Ft), this.scope.enter(0);
      for (let e4; !this.match(8); ) if (this.match(61) || this.match(65)) {
        const n3 = this.match(61);
        r3 && this.finishNode(r3, "SwitchCase"), t3.push(r3 = this.startNode()), r3.consequent = [], this.next(), n3 ? r3.test = this.parseExpression() : (e4 && this.raise(v.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), e4 = true, r3.test = null), this.expect(14);
      } else r3 ? r3.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), r3 && this.finishNode(r3, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e3, "SwitchStatement");
    }
    parseThrowStatement(e3) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(v.NewlineAfterThrow, this.state.lastTokEndLoc), e3.argument = this.parseExpression(), this.semicolon(), this.finishNode(e3, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const e3 = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && "Identifier" === e3.type ? 8 : 0), this.checkLVal(e3, { in: { type: "CatchClause" }, binding: 9 }), e3;
    }
    parseTryStatement(e3) {
      if (this.next(), e3.block = this.parseBlock(), e3.handler = null, this.match(62)) {
        const t3 = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), t3.param = this.parseCatchClauseParam(), this.expect(11)) : (t3.param = null, this.scope.enter(0)), t3.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), e3.handler = this.finishNode(t3, "CatchClause");
      }
      return e3.finalizer = this.eat(67) ? this.parseBlock() : null, e3.handler || e3.finalizer || this.raise(v.NoCatchOrFinally, e3), this.finishNode(e3, "TryStatement");
    }
    parseVarStatement(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      return this.next(), this.parseVar(e3, false, t3, r3), this.semicolon(), this.finishNode(e3, "VariableDeclaration");
    }
    parseWhileStatement(e3) {
      return this.next(), e3.test = this.parseHeaderExpression(), this.state.labels.push(Rt), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(e3, "WhileStatement");
    }
    parseWithStatement(e3) {
      return this.state.strict && this.raise(v.StrictWith, this.state.startLoc), this.next(), e3.object = this.parseHeaderExpression(), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e3, "WithStatement");
    }
    parseEmptyStatement(e3) {
      return this.next(), this.finishNode(e3, "EmptyStatement");
    }
    parseLabeledStatement(e3, t3, r3, n3) {
      for (const e4 of this.state.labels) e4.name === t3 && this.raise(v.LabelRedeclaration, r3, { labelName: t3 });
      const s3 = (i3 = this.state.type) >= 90 && i3 <= 92 ? 1 : this.match(71) ? 2 : null;
      var i3;
      for (let t4 = this.state.labels.length - 1; t4 >= 0; t4--) {
        const r4 = this.state.labels[t4];
        if (r4.statementStart !== e3.start) break;
        r4.statementStart = this.state.start, r4.kind = s3;
      }
      return this.state.labels.push({ name: t3, kind: s3, statementStart: this.state.start }), e3.body = 8 & n3 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), e3.label = r3, this.finishNode(e3, "LabeledStatement");
    }
    parseExpressionStatement(e3, t3, r3) {
      return e3.expression = t3, this.semicolon(), this.finishNode(e3, "ExpressionStatement");
    }
    parseBlock() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], r3 = arguments.length > 2 ? arguments[2] : void 0;
      const n3 = this.startNode();
      return e3 && this.state.strictErrors.clear(), this.expect(5), t3 && this.scope.enter(0), this.parseBlockBody(n3, e3, false, 8, r3), t3 && this.scope.exit(), this.finishNode(n3, "BlockStatement");
    }
    isValidDirective(e3) {
      return "ExpressionStatement" === e3.type && "StringLiteral" === e3.expression.type && !e3.expression.extra.parenthesized;
    }
    parseBlockBody(e3, t3, r3, n3, s3) {
      const i3 = e3.body = [], o3 = e3.directives = [];
      this.parseBlockOrModuleBlockBody(i3, t3 ? o3 : void 0, r3, n3, s3);
    }
    parseBlockOrModuleBlockBody(e3, t3, r3, n3, s3) {
      const i3 = this.state.strict;
      let o3 = false, a3 = false;
      for (; !this.match(n3); ) {
        const n4 = r3 ? this.parseModuleItem() : this.parseStatementListItem();
        if (t3 && !a3) {
          if (this.isValidDirective(n4)) {
            const e4 = this.stmtToDirective(n4);
            t3.push(e4), o3 || "use strict" !== e4.value.value || (o3 = true, this.setStrict(true));
            continue;
          }
          a3 = true, this.state.strictErrors.clear();
        }
        e3.push(n4);
      }
      null == s3 || s3.call(this, o3), i3 || this.setStrict(false), this.next();
    }
    parseFor(e3, t3) {
      return e3.init = t3, this.semicolon(false), e3.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), e3.update = this.match(11) ? null : this.parseExpression(), this.expect(11), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e3, "ForStatement");
    }
    parseForIn(e3, t3, r3) {
      const n3 = this.match(58);
      return this.next(), n3 ? null !== r3 && this.unexpected(r3) : e3.await = null !== r3, "VariableDeclaration" !== t3.type || null == t3.declarations[0].init || n3 && this.options.annexB && !this.state.strict && "var" === t3.kind && "Identifier" === t3.declarations[0].id.type || this.raise(v.ForInOfLoopInitializer, t3, { type: n3 ? "ForInStatement" : "ForOfStatement" }), "AssignmentPattern" === t3.type && this.raise(v.InvalidLhs, t3, { ancestor: { type: "ForStatement" } }), e3.left = t3, e3.right = n3 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e3, n3 ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e3, t3, r3) {
      let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
      const s3 = e3.declarations = [];
      for (e3.kind = r3; ; ) {
        const e4 = this.startNode();
        if (this.parseVarId(e4, r3), e4.init = this.eat(29) ? t3 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, null !== e4.init || n3 || ("Identifier" === e4.id.type || t3 && (this.match(58) || this.isContextual(102)) ? "const" !== r3 || this.match(58) || this.isContextual(102) || this.raise(v.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "const" }) : this.raise(v.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" })), s3.push(this.finishNode(e4, "VariableDeclarator")), !this.eat(12)) break;
      }
      return e3;
    }
    parseVarId(e3, t3) {
      const r3 = this.parseBindingAtom();
      this.checkLVal(r3, { in: { type: "VariableDeclarator" }, binding: "var" === t3 ? 5 : 8201 }), e3.id = r3;
    }
    parseAsyncFunctionExpression(e3) {
      return this.parseFunction(e3, 8);
    }
    parseFunction(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      const r3 = 2 & t3, n3 = !!(1 & t3), s3 = n3 && !(4 & t3), i3 = !!(8 & t3);
      this.initFunction(e3, i3), this.match(55) && (r3 && this.raise(v.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e3.generator = true), n3 && (e3.id = this.parseFunctionId(s3));
      const o3 = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(et(i3, e3.generator)), n3 || (e3.id = this.parseFunctionId()), this.parseFunctionParams(e3, false), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e3, n3 ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), n3 && !r3 && this.registerFunctionStatementId(e3), this.state.maybeInArrowParameters = o3, e3;
    }
    parseFunctionId(e3) {
      return e3 || W(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e3, t3) {
      this.expect(10), this.expressionScope.enter(new Xe(3)), e3.params = this.parseBindingList(11, 41, 2 | (t3 ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(e3) {
      e3.id && this.scope.declareName(e3.id.name, !this.options.annexB || this.state.strict || e3.generator || e3.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, e3.id.loc.start);
    }
    parseClass(e3, t3, r3) {
      this.next();
      const n3 = this.state.strict;
      return this.state.strict = true, this.parseClassId(e3, t3, r3), this.parseClassSuper(e3), e3.body = this.parseClassBody(!!e3.superClass, n3), this.finishNode(e3, t3 ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(e3) {
      return !(e3.computed || e3.static || "constructor" !== e3.key.name && "constructor" !== e3.key.value);
    }
    parseClassBody(e3, t3) {
      this.classScope.enter();
      const r3 = { hadConstructor: false, hadSuperClass: e3 };
      let n3 = [];
      const s3 = this.startNode();
      if (s3.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (n3.length > 0) throw this.raise(v.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            n3.push(this.parseDecorator());
            continue;
          }
          const e4 = this.startNode();
          n3.length && (e4.decorators = n3, this.resetStartLocationFromNode(e4, n3[0]), n3 = []), this.parseClassMember(s3, e4, r3), "constructor" === e4.kind && e4.decorators && e4.decorators.length > 0 && this.raise(v.DecoratorConstructor, e4);
        }
      }), this.state.strict = t3, this.next(), n3.length) throw this.raise(v.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(s3, "ClassBody");
    }
    parseClassMemberFromModifier(e3, t3) {
      const r3 = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        const n3 = t3;
        return n3.kind = "method", n3.computed = false, n3.key = r3, n3.static = false, this.pushClassMethod(e3, n3, false, false, false, false), true;
      }
      if (this.isClassProperty()) {
        const n3 = t3;
        return n3.computed = false, n3.key = r3, n3.static = false, e3.body.push(this.parseClassProperty(n3)), true;
      }
      return this.resetPreviousNodeTrailingComments(r3), false;
    }
    parseClassMember(e3, t3, r3) {
      const n3 = this.isContextual(106);
      if (n3) {
        if (this.parseClassMemberFromModifier(e3, t3)) return;
        if (this.eat(5)) return void this.parseClassStaticBlock(e3, t3);
      }
      this.parseClassMemberWithIsStatic(e3, t3, r3, n3);
    }
    parseClassMemberWithIsStatic(e3, t3, r3, n3) {
      const s3 = t3, i3 = t3, o3 = t3, a3 = t3, l2 = t3, c2 = s3, u2 = s3;
      if (t3.static = n3, this.parsePropertyNamePrefixOperator(t3), this.eat(55)) {
        c2.kind = "method";
        const t4 = this.match(138);
        return this.parseClassElementName(c2), t4 ? void this.pushClassPrivateMethod(e3, i3, true, false) : (this.isNonstaticConstructor(s3) && this.raise(v.ConstructorIsGenerator, s3.key), void this.pushClassMethod(e3, s3, true, false, false, false));
      }
      const p2 = W(this.state.type) && !this.state.containsEsc, d2 = this.match(138), f2 = this.parseClassElementName(t3), h2 = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(u2), this.isClassMethod()) {
        if (c2.kind = "method", d2) return void this.pushClassPrivateMethod(e3, i3, false, false);
        const n4 = this.isNonstaticConstructor(s3);
        let o4 = false;
        n4 && (s3.kind = "constructor", r3.hadConstructor && !this.hasPlugin("typescript") && this.raise(v.DuplicateConstructor, f2), n4 && this.hasPlugin("typescript") && t3.override && this.raise(v.OverrideOnConstructor, f2), r3.hadConstructor = true, o4 = r3.hadSuperClass), this.pushClassMethod(e3, s3, false, false, n4, o4);
      } else if (this.isClassProperty()) d2 ? this.pushClassPrivateProperty(e3, a3) : this.pushClassProperty(e3, o3);
      else if (p2 && "async" === f2.name && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(f2);
        const t4 = this.eat(55);
        u2.optional && this.unexpected(h2), c2.kind = "method";
        const r4 = this.match(138);
        this.parseClassElementName(c2), this.parsePostMemberNameModifiers(u2), r4 ? this.pushClassPrivateMethod(e3, i3, t4, true) : (this.isNonstaticConstructor(s3) && this.raise(v.ConstructorIsAsync, s3.key), this.pushClassMethod(e3, s3, t4, true, false, false));
      } else if (!p2 || "get" !== f2.name && "set" !== f2.name || this.match(55) && this.isLineTerminator()) if (p2 && "accessor" === f2.name && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(f2);
        const t4 = this.match(138);
        this.parseClassElementName(o3), this.pushClassAccessorProperty(e3, l2, t4);
      } else this.isLineTerminator() ? d2 ? this.pushClassPrivateProperty(e3, a3) : this.pushClassProperty(e3, o3) : this.unexpected();
      else {
        this.resetPreviousNodeTrailingComments(f2), c2.kind = f2.name;
        const t4 = this.match(138);
        this.parseClassElementName(s3), t4 ? this.pushClassPrivateMethod(e3, i3, false, false) : (this.isNonstaticConstructor(s3) && this.raise(v.ConstructorIsAccessor, s3.key), this.pushClassMethod(e3, s3, false, false, false, false)), this.checkGetterSetterParams(s3);
      }
    }
    parseClassElementName(e3) {
      const { type: t3, value: r3 } = this.state;
      if (132 !== t3 && 133 !== t3 || !e3.static || "prototype" !== r3 || this.raise(v.StaticPrototype, this.state.startLoc), 138 === t3) {
        "constructor" === r3 && this.raise(v.ConstructorClassPrivateField, this.state.startLoc);
        const t4 = this.parsePrivateName();
        return e3.key = t4, t4;
      }
      return this.parsePropertyName(e3);
    }
    parseClassStaticBlock(e3, t3) {
      var r3;
      this.scope.enter(208);
      const n3 = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      const s3 = t3.body = [];
      this.parseBlockOrModuleBlockBody(s3, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = n3, e3.body.push(this.finishNode(t3, "StaticBlock")), null != (r3 = t3.decorators) && r3.length && this.raise(v.DecoratorStaticBlock, t3);
    }
    pushClassProperty(e3, t3) {
      t3.computed || "constructor" !== t3.key.name && "constructor" !== t3.key.value || this.raise(v.ConstructorClassField, t3.key), e3.body.push(this.parseClassProperty(t3));
    }
    pushClassPrivateProperty(e3, t3) {
      const r3 = this.parseClassPrivateProperty(t3);
      e3.body.push(r3), this.classScope.declarePrivateName(this.getPrivateNameSV(r3.key), 0, r3.key.loc.start);
    }
    pushClassAccessorProperty(e3, t3, r3) {
      if (!r3 && !t3.computed) {
        const e4 = t3.key;
        "constructor" !== e4.name && "constructor" !== e4.value || this.raise(v.ConstructorClassField, e4);
      }
      const n3 = this.parseClassAccessorProperty(t3);
      e3.body.push(n3), r3 && this.classScope.declarePrivateName(this.getPrivateNameSV(n3.key), 0, n3.key.loc.start);
    }
    pushClassMethod(e3, t3, r3, n3, s3, i3) {
      e3.body.push(this.parseMethod(t3, r3, n3, s3, i3, "ClassMethod", true));
    }
    pushClassPrivateMethod(e3, t3, r3, n3) {
      const s3 = this.parseMethod(t3, r3, n3, false, false, "ClassPrivateMethod", true);
      e3.body.push(s3);
      const i3 = "get" === s3.kind ? s3.static ? 6 : 2 : "set" === s3.kind ? s3.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(s3, i3);
    }
    declareClassPrivateMethodInScope(e3, t3) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e3.key), t3, e3.key.loc.start);
    }
    parsePostMemberNameModifiers(e3) {
    }
    parseClassPrivateProperty(e3) {
      return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassPrivateProperty");
    }
    parseClassProperty(e3) {
      return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassProperty");
    }
    parseClassAccessorProperty(e3) {
      return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassAccessorProperty");
    }
    parseInitializer(e3) {
      this.scope.enter(80), this.expressionScope.enter(Qe()), this.prodParam.enter(0), e3.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e3, t3, r3) {
      let n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8331;
      if (W(this.state.type)) e3.id = this.parseIdentifier(), t3 && this.declareNameFromIdentifier(e3.id, n3);
      else {
        if (!r3 && t3) throw this.raise(v.MissingClassName, this.state.startLoc);
        e3.id = null;
      }
    }
    parseClassSuper(e3) {
      e3.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e3, t3) {
      const r3 = this.parseMaybeImportPhase(e3, true), n3 = this.maybeParseExportDefaultSpecifier(e3, r3), s3 = !n3 || this.eat(12), i3 = s3 && this.eatExportStar(e3), o3 = i3 && this.maybeParseExportNamespaceSpecifier(e3), a3 = s3 && (!o3 || this.eat(12)), l2 = n3 || i3;
      if (i3 && !o3) {
        if (n3 && this.unexpected(), t3) throw this.raise(v.UnsupportedDecoratorExport, e3);
        return this.parseExportFrom(e3, true), this.finishNode(e3, "ExportAllDeclaration");
      }
      const c2 = this.maybeParseExportNamedSpecifiers(e3);
      let u2;
      if (n3 && s3 && !i3 && !c2 && this.unexpected(null, 5), o3 && a3 && this.unexpected(null, 98), l2 || c2) {
        if (u2 = false, t3) throw this.raise(v.UnsupportedDecoratorExport, e3);
        this.parseExportFrom(e3, l2);
      } else u2 = this.maybeParseExportDeclaration(e3);
      if (l2 || c2 || u2) {
        var p2;
        const r4 = e3;
        if (this.checkExport(r4, true, false, !!r4.source), "ClassDeclaration" === (null == (p2 = r4.declaration) ? void 0 : p2.type)) this.maybeTakeDecorators(t3, r4.declaration, r4);
        else if (t3) throw this.raise(v.UnsupportedDecoratorExport, e3);
        return this.finishNode(r4, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        const r4 = e3, n4 = this.parseExportDefaultExpression();
        if (r4.declaration = n4, "ClassDeclaration" === n4.type) this.maybeTakeDecorators(t3, n4, r4);
        else if (t3) throw this.raise(v.UnsupportedDecoratorExport, e3);
        return this.checkExport(r4, true, true), this.finishNode(r4, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(e3) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e3, t3) {
      if (t3 || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", null == t3 ? void 0 : t3.loc.start);
        const r3 = t3 || this.parseIdentifier(true), n3 = this.startNodeAtNode(r3);
        return n3.exported = r3, e3.specifiers = [this.finishNode(n3, "ExportDefaultSpecifier")], true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(e3) {
      if (this.isContextual(93)) {
        e3.specifiers || (e3.specifiers = []);
        const t3 = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), t3.exported = this.parseModuleExportName(), e3.specifiers.push(this.finishNode(t3, "ExportNamespaceSpecifier")), true;
      }
      return false;
    }
    maybeParseExportNamedSpecifiers(e3) {
      if (this.match(5)) {
        e3.specifiers || (e3.specifiers = []);
        const t3 = "type" === e3.exportKind;
        return e3.specifiers.push(...this.parseExportSpecifiers(t3)), e3.source = null, e3.declaration = null, this.hasPlugin("importAssertions") && (e3.assertions = []), true;
      }
      return false;
    }
    maybeParseExportDeclaration(e3) {
      return !!this.shouldParseExportDeclaration() && (e3.specifiers = [], e3.source = null, this.hasPlugin("importAssertions") && (e3.assertions = []), e3.declaration = this.parseExportDeclaration(e3), true);
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return false;
      const e3 = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e3, "function");
    }
    parseExportDefaultExpression() {
      const e3 = this.startNode();
      if (this.match(68)) return this.next(), this.parseFunction(e3, 5);
      if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(e3, 13);
      if (this.match(80)) return this.parseClass(e3, true, true);
      if (this.match(26)) return this.hasPlugin("decorators") && true === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(v.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
      if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(v.UnsupportedDefaultExport, this.state.startLoc);
      const t3 = this.parseMaybeAssignAllowIn();
      return this.semicolon(), t3;
    }
    parseExportDeclaration(e3) {
      return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      const { type: e3 } = this.state;
      if (W(e3)) {
        if (95 === e3 && !this.state.containsEsc || 100 === e3) return false;
        if ((130 === e3 || 129 === e3) && !this.state.containsEsc) {
          const { type: e4 } = this.lookahead();
          if (W(e4) && 98 !== e4 || 5 === e4) return this.expectOnePlugin(["flow", "typescript"]), false;
        }
      } else if (!this.match(65)) return false;
      const t3 = this.nextTokenStart(), r3 = this.isUnparsedContextual(t3, "from");
      if (44 === this.input.charCodeAt(t3) || W(this.state.type) && r3) return true;
      if (this.match(65) && r3) {
        const e4 = this.input.charCodeAt(this.nextTokenStartSince(t3 + 4));
        return 34 === e4 || 39 === e4;
      }
      return false;
    }
    parseExportFrom(e3, t3) {
      this.eatContextual(98) ? (e3.source = this.parseImportSource(), this.checkExport(e3), this.maybeParseImportAttributes(e3), this.checkJSONModuleImport(e3)) : t3 && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      const { type: e3 } = this.state;
      return 26 === e3 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (true === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(v.DecoratorBeforeExport, this.state.startLoc), true) : 74 === e3 || 75 === e3 || 68 === e3 || 80 === e3 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e3, t3, r3, n3) {
      var s3;
      if (t3) {
        if (r3) {
          if (this.checkDuplicateExports(e3, "default"), this.hasPlugin("exportDefaultFrom")) {
            var i3;
            const t4 = e3.declaration;
            "Identifier" !== t4.type || "from" !== t4.name || t4.end - t4.start != 4 || null != (i3 = t4.extra) && i3.parenthesized || this.raise(v.ExportDefaultFromAsIdentifier, t4);
          }
        } else if (null != (s3 = e3.specifiers) && s3.length) for (const t4 of e3.specifiers) {
          const { exported: e4 } = t4, r4 = "Identifier" === e4.type ? e4.name : e4.value;
          if (this.checkDuplicateExports(t4, r4), !n3 && t4.local) {
            const { local: e5 } = t4;
            "Identifier" !== e5.type ? this.raise(v.ExportBindingIsString, t4, { localName: e5.value, exportName: r4 }) : (this.checkReservedWord(e5.name, e5.loc.start, true, false), this.scope.checkLocalExport(e5));
          }
        }
        else if (e3.declaration) {
          if ("FunctionDeclaration" === e3.declaration.type || "ClassDeclaration" === e3.declaration.type) {
            const t4 = e3.declaration.id;
            if (!t4) throw new Error("Assertion failure");
            this.checkDuplicateExports(e3, t4.name);
          } else if ("VariableDeclaration" === e3.declaration.type) for (const t4 of e3.declaration.declarations) this.checkDeclaration(t4.id);
        }
      }
    }
    checkDeclaration(e3) {
      if ("Identifier" === e3.type) this.checkDuplicateExports(e3, e3.name);
      else if ("ObjectPattern" === e3.type) for (const t3 of e3.properties) this.checkDeclaration(t3);
      else if ("ArrayPattern" === e3.type) for (const t3 of e3.elements) t3 && this.checkDeclaration(t3);
      else "ObjectProperty" === e3.type ? this.checkDeclaration(e3.value) : "RestElement" === e3.type ? this.checkDeclaration(e3.argument) : "AssignmentPattern" === e3.type && this.checkDeclaration(e3.left);
    }
    checkDuplicateExports(e3, t3) {
      this.exportedIdentifiers.has(t3) && ("default" === t3 ? this.raise(v.DuplicateDefaultExport, e3) : this.raise(v.DuplicateExport, e3, { exportName: t3 })), this.exportedIdentifiers.add(t3);
    }
    parseExportSpecifiers(e3) {
      const t3 = [];
      let r3 = true;
      for (this.expect(5); !this.eat(8); ) {
        if (r3) r3 = false;
        else if (this.expect(12), this.eat(8)) break;
        const n3 = this.isContextual(130), s3 = this.match(133), i3 = this.startNode();
        i3.local = this.parseModuleExportName(), t3.push(this.parseExportSpecifier(i3, s3, e3, n3));
      }
      return t3;
    }
    parseExportSpecifier(e3, t3, r3, n3) {
      return this.eatContextual(93) ? e3.exported = this.parseModuleExportName() : t3 ? e3.exported = function(e4) {
        const { type: t4, start: r4, end: n4, loc: s3, range: i3, extra: o3 } = e4;
        if ("Placeholder" === t4) return function(e5) {
          return it(e5);
        }(e4);
        const a3 = Object.create(st);
        return a3.type = t4, a3.start = r4, a3.end = n4, a3.loc = s3, a3.range = i3, void 0 !== e4.raw ? a3.raw = e4.raw : a3.extra = o3, a3.value = e4.value, a3;
      }(e3.local) : e3.exported || (e3.exported = it(e3.local)), this.finishNode(e3, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        const e3 = this.parseStringLiteral(this.state.value), t3 = e3.value.match(Ut);
        return t3 && this.raise(v.ModuleExportNameHasLoneSurrogate, e3, { surrogateCharCode: t3[0].charCodeAt(0) }), e3;
      }
      return this.parseIdentifier(true);
    }
    isJSONModuleImport(e3) {
      return null != e3.assertions && e3.assertions.some((e4) => {
        let { key: t3, value: r3 } = e4;
        return "json" === r3.value && ("Identifier" === t3.type ? "type" === t3.name : "type" === t3.value);
      });
    }
    checkImportReflection(e3) {
      const { specifiers: t3 } = e3, r3 = 1 === t3.length ? t3[0].type : null;
      if ("source" === e3.phase) "ImportDefaultSpecifier" !== r3 && this.raise(v.SourcePhaseImportRequiresDefault, t3[0].loc.start);
      else if ("defer" === e3.phase) "ImportNamespaceSpecifier" !== r3 && this.raise(v.DeferImportRequiresNamespace, t3[0].loc.start);
      else if (e3.module) {
        var n3;
        "ImportDefaultSpecifier" !== r3 && this.raise(v.ImportReflectionNotBinding, t3[0].loc.start), (null == (n3 = e3.assertions) ? void 0 : n3.length) > 0 && this.raise(v.ImportReflectionHasAssertion, t3[0].loc.start);
      }
    }
    checkJSONModuleImport(e3) {
      if (this.isJSONModuleImport(e3) && "ExportAllDeclaration" !== e3.type) {
        const { specifiers: t3 } = e3;
        if (null != t3) {
          const e4 = t3.find((e5) => {
            let t4;
            if ("ExportSpecifier" === e5.type ? t4 = e5.local : "ImportSpecifier" === e5.type && (t4 = e5.imported), void 0 !== t4) return "Identifier" === t4.type ? "default" !== t4.name : "default" !== t4.value;
          });
          void 0 !== e4 && this.raise(v.ImportJSONBindingNotDefault, e4.loc.start);
        }
      }
    }
    isPotentialImportPhase(e3) {
      return !e3 && (this.isContextual(105) || this.isContextual(97) || this.isContextual(127));
    }
    applyImportPhase(e3, t3, r3, n3) {
      t3 || ("module" === r3 ? (this.expectPlugin("importReflection", n3), e3.module = true) : this.hasPlugin("importReflection") && (e3.module = false), "source" === r3 ? (this.expectPlugin("sourcePhaseImports", n3), e3.phase = "source") : "defer" === r3 ? (this.expectPlugin("deferredImportEvaluation", n3), e3.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e3.phase = null));
    }
    parseMaybeImportPhase(e3, t3) {
      if (!this.isPotentialImportPhase(t3)) return this.applyImportPhase(e3, t3, null), null;
      const r3 = this.parseIdentifier(true), { type: n3 } = this.state;
      return (G(n3) ? 98 !== n3 || 102 === this.lookaheadCharCode() : 12 !== n3) ? (this.resetPreviousIdentifierLeadingComments(r3), this.applyImportPhase(e3, t3, r3.name, r3.loc.start), null) : (this.applyImportPhase(e3, t3, null), r3);
    }
    isPrecedingIdImportPhase(e3) {
      const { type: t3 } = this.state;
      return W(t3) ? 98 !== t3 || 102 === this.lookaheadCharCode() : 12 !== t3;
    }
    parseImport(e3) {
      return this.match(133) ? this.parseImportSourceAndAttributes(e3) : this.parseImportSpecifiersAndAfter(e3, this.parseMaybeImportPhase(e3, false));
    }
    parseImportSpecifiersAndAfter(e3, t3) {
      e3.specifiers = [];
      const r3 = !this.maybeParseDefaultImportSpecifier(e3, t3) || this.eat(12), n3 = r3 && this.maybeParseStarImportSpecifier(e3);
      return r3 && !n3 && this.parseNamedImportSpecifiers(e3), this.expectContextual(98), this.parseImportSourceAndAttributes(e3);
    }
    parseImportSourceAndAttributes(e3) {
      return null != e3.specifiers || (e3.specifiers = []), e3.source = this.parseImportSource(), this.maybeParseImportAttributes(e3), this.checkImportReflection(e3), this.checkJSONModuleImport(e3), this.semicolon(), this.finishNode(e3, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(e3, t3, r3) {
      t3.local = this.parseIdentifier(), e3.specifiers.push(this.finishImportSpecifier(t3, r3));
    }
    finishImportSpecifier(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8201;
      return this.checkLVal(e3.local, { in: { type: t3 }, binding: r3 }), this.finishNode(e3, t3);
    }
    parseImportAttributes() {
      this.expect(5);
      const e3 = [], t3 = /* @__PURE__ */ new Set();
      do {
        if (this.match(8)) break;
        const r3 = this.startNode(), n3 = this.state.value;
        if (t3.has(n3) && this.raise(v.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: n3 }), t3.add(n3), this.match(133) ? r3.key = this.parseStringLiteral(n3) : r3.key = this.parseIdentifier(true), this.expect(14), !this.match(133)) throw this.raise(v.ModuleAttributeInvalidValue, this.state.startLoc);
        r3.value = this.parseStringLiteral(this.state.value), e3.push(this.finishNode(r3, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), e3;
    }
    parseModuleAttributes() {
      const e3 = [], t3 = /* @__PURE__ */ new Set();
      do {
        const r3 = this.startNode();
        if (r3.key = this.parseIdentifier(true), "type" !== r3.key.name && this.raise(v.ModuleAttributeDifferentFromType, r3.key), t3.has(r3.key.name) && this.raise(v.ModuleAttributesWithDuplicateKeys, r3.key, { key: r3.key.name }), t3.add(r3.key.name), this.expect(14), !this.match(133)) throw this.raise(v.ModuleAttributeInvalidValue, this.state.startLoc);
        r3.value = this.parseStringLiteral(this.state.value), e3.push(this.finishNode(r3, "ImportAttribute"));
      } while (this.eat(12));
      return e3;
    }
    maybeParseImportAttributes(e3) {
      let t3, r3 = false;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && 40 === this.lookaheadCharCode()) return;
        this.next(), this.hasPlugin("moduleAttributes") ? t3 = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), t3 = this.parseImportAttributes()), r3 = true;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) this.hasPlugin("importAttributes") ? (true !== this.getPluginOption("importAttributes", "deprecatedAssertSyntax") && this.raise(v.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(e3, "deprecatedAssertSyntax", true)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), t3 = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) t3 = [];
      else {
        if (!this.hasPlugin("moduleAttributes")) return;
        t3 = [];
      }
      !r3 && this.hasPlugin("importAssertions") ? e3.assertions = t3 : e3.attributes = t3;
    }
    maybeParseDefaultImportSpecifier(e3, t3) {
      if (t3) {
        const r3 = this.startNodeAtNode(t3);
        return r3.local = t3, e3.specifiers.push(this.finishImportSpecifier(r3, "ImportDefaultSpecifier")), true;
      }
      return !!G(this.state.type) && (this.parseImportSpecifierLocal(e3, this.startNode(), "ImportDefaultSpecifier"), true);
    }
    maybeParseStarImportSpecifier(e3) {
      if (this.match(55)) {
        const t3 = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e3, t3, "ImportNamespaceSpecifier"), true;
      }
      return false;
    }
    parseNamedImportSpecifiers(e3) {
      let t3 = true;
      for (this.expect(5); !this.eat(8); ) {
        if (t3) t3 = false;
        else {
          if (this.eat(14)) throw this.raise(v.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        const r3 = this.startNode(), n3 = this.match(133), s3 = this.isContextual(130);
        r3.imported = this.parseModuleExportName();
        const i3 = this.parseImportSpecifier(r3, n3, "type" === e3.importKind || "typeof" === e3.importKind, s3, void 0);
        e3.specifiers.push(i3);
      }
    }
    parseImportSpecifier(e3, t3, r3, n3, s3) {
      if (this.eatContextual(93)) e3.local = this.parseIdentifier();
      else {
        const { imported: r4 } = e3;
        if (t3) throw this.raise(v.ImportBindingIsString, e3, { importName: r4.value });
        this.checkReservedWord(r4.name, e3.loc.start, true, true), e3.local || (e3.local = it(r4));
      }
      return this.finishImportSpecifier(e3, "ImportSpecifier", s3);
    }
    isThisParam(e3) {
      return "Identifier" === e3.type && "this" === e3.name;
    }
  }
  class qt extends Vt {
    constructor(e3, t3) {
      super(e3 = function(e4) {
        if (null == e4) return Object.assign({}, Mt);
        if (null != e4.annexB && false !== e4.annexB) throw new Error("The `annexB` option can only be set to `false`.");
        const t4 = {};
        for (const n3 of Object.keys(Mt)) {
          var r3;
          t4[n3] = null != (r3 = e4[n3]) ? r3 : Mt[n3];
        }
        return t4;
      }(e3), t3), this.options = e3, this.initializeScopes(), this.plugins = function(e4) {
        const t4 = /* @__PURE__ */ new Map();
        for (const r3 of e4) {
          const [e5, n3] = Array.isArray(r3) ? r3 : [r3, {}];
          t4.has(e5) || t4.set(e5, n3 || {});
        }
        return t4;
      }(this.options.plugins), this.filename = e3.sourceFilename;
    }
    getScopeHandler() {
      return be;
    }
    parse() {
      this.enterInitialScopes();
      const e3 = this.startNode(), t3 = this.startNode();
      return this.nextToken(), e3.errors = null, this.parseTopLevel(e3, t3), e3.errors = this.state.errors, e3.comments.length = this.state.commentsLen, e3;
    }
  }
  const Wt = function(e3) {
    const t3 = {};
    for (const r3 of Object.keys(e3)) t3[r3] = Z(e3[r3]);
    return t3;
  }(q);
  function Gt(e3, t3) {
    let r3 = qt;
    return null != e3 && e3.plugins && (function(e4) {
      if (It(e4, "decorators")) {
        if (It(e4, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        const t4 = _t(e4, "decorators", "decoratorsBeforeExport");
        if (null != t4 && "boolean" != typeof t4) throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        const r4 = _t(e4, "decorators", "allowCallParenthesized");
        if (null != r4 && "boolean" != typeof r4) throw new Error("'allowCallParenthesized' must be a boolean.");
      }
      if (It(e4, "flow") && It(e4, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
      if (It(e4, "placeholders") && It(e4, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      if (It(e4, "pipelineOperator")) {
        const t4 = _t(e4, "pipelineOperator", "proposal");
        if (!kt.includes(t4)) {
          const e5 = kt.map((e6) => `"${e6}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e5}.`);
        }
        const r4 = It(e4, ["recordAndTuple", { syntaxType: "hash" }]);
        if ("hack" === t4) {
          if (It(e4, "placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          if (It(e4, "v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          const t5 = _t(e4, "pipelineOperator", "topicToken");
          if (!Nt.includes(t5)) {
            const e5 = Nt.map((e6) => `"${e6}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e5}.`);
          }
          if ("#" === t5 && r4) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        } else if ("smart" === t4 && r4) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      }
      if (It(e4, "moduleAttributes")) {
        if (It(e4, "importAssertions") || It(e4, "importAttributes")) throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
        if ("may-2020" !== _t(e4, "moduleAttributes", "version")) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
      }
      if (It(e4, "importAssertions") && It(e4, "importAttributes")) throw new Error("Cannot combine importAssertions and importAttributes plugins.");
      if (It(e4, "recordAndTuple") && null != _t(e4, "recordAndTuple", "syntaxType") && !Dt.includes(_t(e4, "recordAndTuple", "syntaxType"))) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + Dt.map((e5) => `'${e5}'`).join(", "));
      if (It(e4, "asyncDoExpressions") && !It(e4, "doExpressions")) {
        const e5 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        throw e5.missingPlugins = "doExpressions", e5;
      }
      if (It(e4, "optionalChainingAssign") && "2023-07" !== _t(e4, "optionalChainingAssign", "version")) throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
    }(e3.plugins), r3 = function(e4) {
      const t4 = Lt.filter((t5) => It(e4, t5)), r4 = t4.join("/");
      let n3 = Ht[r4];
      if (!n3) {
        n3 = qt;
        for (const e5 of t4) n3 = jt[e5](n3);
        Ht[r4] = n3;
      }
      return n3;
    }(e3.plugins)), new r3(e3, t3);
  }
  const Ht = {};
  t2.parse = function(e3, t3) {
    var r3;
    if ("unambiguous" !== (null == (r3 = t3) ? void 0 : r3.sourceType)) return Gt(t3, e3).parse();
    t3 = Object.assign({}, t3);
    try {
      t3.sourceType = "module";
      const r4 = Gt(t3, e3), n3 = r4.parse();
      if (r4.sawUnambiguousESM) return n3;
      if (r4.ambiguousScriptDifferentAst) try {
        return t3.sourceType = "script", Gt(t3, e3).parse();
      } catch (e4) {
      }
      else n3.program.sourceType = "script";
      return n3;
    } catch (r4) {
      try {
        return t3.sourceType = "script", Gt(t3, e3).parse();
      } catch (e4) {
      }
      throw r4;
    }
  }, t2.parseExpression = function(e3, t3) {
    const r3 = Gt(t3, e3);
    return r3.options.strictMode && (r3.state.strict = true), r3.getExpression();
  }, t2.tokTypes = Wt;
}, (e2, t2, r2) => {
  var n2;
  r2(12);
  var s2 = SyntaxError, i2 = Function, o2 = TypeError, a2 = function(e3) {
    try {
      return i2('"use strict"; return (' + e3 + ").constructor;")();
    } catch (e4) {
    }
  }, l = Object.getOwnPropertyDescriptor;
  if (l) try {
    l({}, "");
  } catch (e3) {
    l = null;
  }
  var c = function() {
    throw new o2();
  }, u = l ? function() {
    try {
      return c;
    } catch (e3) {
      try {
        return l(arguments, "callee").get;
      } catch (e4) {
        return c;
      }
    }
  }() : c, p = r2(230)(), d = r2(231)(), f = Object.getPrototypeOf || (d ? function(e3) {
    return e3.__proto__;
  } : null), h = {}, m = "undefined" != typeof Uint8Array && f ? f(Uint8Array) : n2, y = { "%AggregateError%": "undefined" == typeof AggregateError ? n2 : AggregateError, "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? n2 : ArrayBuffer, "%ArrayIteratorPrototype%": p && f ? f([][Symbol.iterator]()) : n2, "%AsyncFromSyncIteratorPrototype%": n2, "%AsyncFunction%": h, "%AsyncGenerator%": h, "%AsyncGeneratorFunction%": h, "%AsyncIteratorPrototype%": h, "%Atomics%": "undefined" == typeof Atomics ? n2 : Atomics, "%BigInt%": "undefined" == typeof BigInt ? n2 : BigInt, "%BigInt64Array%": "undefined" == typeof BigInt64Array ? n2 : BigInt64Array, "%BigUint64Array%": "undefined" == typeof BigUint64Array ? n2 : BigUint64Array, "%Boolean%": Boolean, "%DataView%": "undefined" == typeof DataView ? n2 : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": "undefined" == typeof Float32Array ? n2 : Float32Array, "%Float64Array%": "undefined" == typeof Float64Array ? n2 : Float64Array, "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? n2 : FinalizationRegistry, "%Function%": i2, "%GeneratorFunction%": h, "%Int8Array%": "undefined" == typeof Int8Array ? n2 : Int8Array, "%Int16Array%": "undefined" == typeof Int16Array ? n2 : Int16Array, "%Int32Array%": "undefined" == typeof Int32Array ? n2 : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": p && f ? f(f([][Symbol.iterator]())) : n2, "%JSON%": "object" == typeof JSON ? JSON : n2, "%Map%": "undefined" == typeof Map ? n2 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && p && f ? f((/* @__PURE__ */ new Map())[Symbol.iterator]()) : n2, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? n2 : Promise, "%Proxy%": "undefined" == typeof Proxy ? n2 : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": "undefined" == typeof Reflect ? n2 : Reflect, "%RegExp%": RegExp, "%Set%": "undefined" == typeof Set ? n2 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && p && f ? f((/* @__PURE__ */ new Set())[Symbol.iterator]()) : n2, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? n2 : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": p && f ? f(""[Symbol.iterator]()) : n2, "%Symbol%": p ? Symbol : n2, "%SyntaxError%": s2, "%ThrowTypeError%": u, "%TypedArray%": m, "%TypeError%": o2, "%Uint8Array%": "undefined" == typeof Uint8Array ? n2 : Uint8Array, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? n2 : Uint8ClampedArray, "%Uint16Array%": "undefined" == typeof Uint16Array ? n2 : Uint16Array, "%Uint32Array%": "undefined" == typeof Uint32Array ? n2 : Uint32Array, "%URIError%": URIError, "%WeakMap%": "undefined" == typeof WeakMap ? n2 : WeakMap, "%WeakRef%": "undefined" == typeof WeakRef ? n2 : WeakRef, "%WeakSet%": "undefined" == typeof WeakSet ? n2 : WeakSet };
  if (f) try {
    null.error;
  } catch (e3) {
    var g = f(f(e3));
    y["%Error.prototype%"] = g;
  }
  var b = function e3(t3) {
    var r3;
    if ("%AsyncFunction%" === t3) r3 = a2("async function () {}");
    else if ("%GeneratorFunction%" === t3) r3 = a2("function* () {}");
    else if ("%AsyncGeneratorFunction%" === t3) r3 = a2("async function* () {}");
    else if ("%AsyncGenerator%" === t3) {
      var n3 = e3("%AsyncGeneratorFunction%");
      n3 && (r3 = n3.prototype);
    } else if ("%AsyncIteratorPrototype%" === t3) {
      var s3 = e3("%AsyncGenerator%");
      s3 && f && (r3 = f(s3.prototype));
    }
    return y[t3] = r3, r3;
  }, v = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, E = r2(71), S = r2(233), x = E.call(Function.call, Array.prototype.concat), T = E.call(Function.apply, Array.prototype.splice), w = E.call(Function.call, String.prototype.replace), P = E.call(Function.call, String.prototype.slice), A = E.call(Function.call, RegExp.prototype.exec), C = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, O = /\\(\\)?/g, I = function(e3, t3) {
    var r3, n3 = e3;
    if (S(v, n3) && (n3 = "%" + (r3 = v[n3])[0] + "%"), S(y, n3)) {
      var i3 = y[n3];
      if (i3 === h && (i3 = b(n3)), void 0 === i3 && !t3) throw new o2("intrinsic " + e3 + " exists, but is not available. Please file an issue!");
      return { alias: r3, name: n3, value: i3 };
    }
    throw new s2("intrinsic " + e3 + " does not exist!");
  };
  e2.exports = function(e3, t3) {
    if ("string" != typeof e3 || 0 === e3.length) throw new o2("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && "boolean" != typeof t3) throw new o2('"allowMissing" argument must be a boolean');
    if (null === A(/^%?[^%]*%?$/, e3)) throw new s2("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var r3 = function(e4) {
      var t4 = P(e4, 0, 1), r4 = P(e4, -1);
      if ("%" === t4 && "%" !== r4) throw new s2("invalid intrinsic syntax, expected closing `%`");
      if ("%" === r4 && "%" !== t4) throw new s2("invalid intrinsic syntax, expected opening `%`");
      var n4 = [];
      return w(e4, C, function(e5, t5, r5, s3) {
        n4[n4.length] = r5 ? w(s3, O, "$1") : t5 || e5;
      }), n4;
    }(e3), n3 = r3.length > 0 ? r3[0] : "", i3 = I("%" + n3 + "%", t3), a3 = i3.name, c2 = i3.value, u2 = false, p2 = i3.alias;
    p2 && (n3 = p2[0], T(r3, x([0, 1], p2)));
    for (var d2 = 1, f2 = true; d2 < r3.length; d2 += 1) {
      var h2 = r3[d2], m2 = P(h2, 0, 1), g2 = P(h2, -1);
      if (('"' === m2 || "'" === m2 || "`" === m2 || '"' === g2 || "'" === g2 || "`" === g2) && m2 !== g2) throw new s2("property names with quotes must have matching quotes");
      if ("constructor" !== h2 && f2 || (u2 = true), S(y, a3 = "%" + (n3 += "." + h2) + "%")) c2 = y[a3];
      else if (null != c2) {
        if (!(h2 in c2)) {
          if (!t3) throw new o2("base intrinsic for " + e3 + " exists, but the property is not available.");
          return;
        }
        if (l && d2 + 1 >= r3.length) {
          var b2 = l(c2, h2);
          c2 = (f2 = !!b2) && "get" in b2 && !("originalValue" in b2.get) ? b2.get : c2[h2];
        } else f2 = S(c2, h2), c2 = c2[h2];
        f2 && !u2 && (y[a3] = c2);
      }
    }
    return c2;
  };
}, (e2, t2, r2) => {
  const n2 = r2(34), s2 = r2(47), i2 = r2(3), o2 = r2(128), a2 = r2(30), l = r2(253), c = r2(254), u = r2(255), p = r2(256), d = r2(257), f = r2(258), h = r2(259), m = r2(260), y = r2(7), g = r2(261), b = r2(262), v = r2(76), E = r2(263), S = r2(264), x = r2(49), T = r2(77), w = r2(129), P = r2(130), A = r2(78), C = r2(79), O = r2(131), I = r2(265), _ = r2(50), k = r2(8), N = r2(51), D = r2(268), j = r2(269), L = r2(270), M = r2(271), B = r2(272), R = r2(80), F = r2(273), U = r2(274), $ = r2(275), V = r2(276), q = r2(277);
  e2.exports = { parse: a2, valid: l, clean: c, inc: u, diff: p, major: d, minor: f, patch: h, prerelease: m, compare: y, rcompare: g, compareLoose: b, compareBuild: v, sort: E, rsort: S, gt: x, lt: T, eq: w, neq: P, gte: A, lte: C, cmp: O, coerce: I, Comparator: _, Range: k, satisfies: N, toComparators: D, maxSatisfying: j, minSatisfying: L, minVersion: M, validRange: B, outside: R, gtr: F, ltr: U, intersects: $, simplifyRange: V, subset: q, SemVer: i2, re: n2.re, src: n2.src, tokens: n2.t, SEMVER_SPEC_VERSION: s2.SEMVER_SPEC_VERSION, RELEASE_TYPES: s2.RELEASE_TYPES, compareIdentifiers: o2.compareIdentifiers, rcompareIdentifiers: o2.rcompareIdentifiers };
}, (e2, t2, r2) => {
  let n2, s2, i2, o2, { isClean: a2, my: l } = r2(145), c = r2(52), u = r2(56), p = r2(53);
  function d(e3) {
    return e3.map((e4) => (e4.nodes && (e4.nodes = d(e4.nodes)), delete e4.source, e4));
  }
  function f(e3) {
    if (e3[a2] = false, e3.proxyOf.nodes) for (let t3 of e3.proxyOf.nodes) f(t3);
  }
  class h extends p {
    append() {
      for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
      for (let e4 of t3) {
        let t4 = this.normalize(e4, this.last);
        for (let e5 of t4) this.proxyOf.nodes.push(e5);
      }
      return this.markDirty(), this;
    }
    cleanRaws(e3) {
      if (super.cleanRaws(e3), this.nodes) for (let t3 of this.nodes) t3.cleanRaws(e3);
    }
    each(e3) {
      if (!this.proxyOf.nodes) return;
      let t3, r3, n3 = this.getIterator();
      for (; this.indexes[n3] < this.proxyOf.nodes.length && (t3 = this.indexes[n3], r3 = e3(this.proxyOf.nodes[t3], t3), false !== r3); ) this.indexes[n3] += 1;
      return delete this.indexes[n3], r3;
    }
    every(e3) {
      return this.nodes.every(e3);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let e3 = this.lastEach;
      return this.indexes[e3] = 0, e3;
    }
    getProxyProcessor() {
      return { get: (e3, t3) => "proxyOf" === t3 ? e3 : e3[t3] ? "each" === t3 || "string" == typeof t3 && t3.startsWith("walk") ? function() {
        for (var r3 = arguments.length, n3 = new Array(r3), s3 = 0; s3 < r3; s3++) n3[s3] = arguments[s3];
        return e3[t3](...n3.map((e4) => "function" == typeof e4 ? (t4, r4) => e4(t4.toProxy(), r4) : e4));
      } : "every" === t3 || "some" === t3 ? (r3) => e3[t3](function(e4) {
        for (var t4 = arguments.length, n3 = new Array(t4 > 1 ? t4 - 1 : 0), s3 = 1; s3 < t4; s3++) n3[s3 - 1] = arguments[s3];
        return r3(e4.toProxy(), ...n3);
      }) : "root" === t3 ? () => e3.root().toProxy() : "nodes" === t3 ? e3.nodes.map((e4) => e4.toProxy()) : "first" === t3 || "last" === t3 ? e3[t3].toProxy() : e3[t3] : e3[t3], set: (e3, t3, r3) => (e3[t3] === r3 || (e3[t3] = r3, "name" !== t3 && "params" !== t3 && "selector" !== t3 || e3.markDirty()), true) };
    }
    index(e3) {
      return "number" == typeof e3 ? e3 : (e3.proxyOf && (e3 = e3.proxyOf), this.proxyOf.nodes.indexOf(e3));
    }
    insertAfter(e3, t3) {
      let r3, n3 = this.index(e3), s3 = this.normalize(t3, this.proxyOf.nodes[n3]).reverse();
      n3 = this.index(e3);
      for (let e4 of s3) this.proxyOf.nodes.splice(n3 + 1, 0, e4);
      for (let e4 in this.indexes) r3 = this.indexes[e4], n3 < r3 && (this.indexes[e4] = r3 + s3.length);
      return this.markDirty(), this;
    }
    insertBefore(e3, t3) {
      let r3, n3 = this.index(e3), s3 = 0 === n3 && "prepend", i3 = this.normalize(t3, this.proxyOf.nodes[n3], s3).reverse();
      n3 = this.index(e3);
      for (let e4 of i3) this.proxyOf.nodes.splice(n3, 0, e4);
      for (let e4 in this.indexes) r3 = this.indexes[e4], n3 <= r3 && (this.indexes[e4] = r3 + i3.length);
      return this.markDirty(), this;
    }
    normalize(e3, t3) {
      if ("string" == typeof e3) e3 = d(n2(e3).nodes);
      else if (Array.isArray(e3)) {
        e3 = e3.slice(0);
        for (let t4 of e3) t4.parent && t4.parent.removeChild(t4, "ignore");
      } else if ("root" === e3.type && "document" !== this.type) {
        e3 = e3.nodes.slice(0);
        for (let t4 of e3) t4.parent && t4.parent.removeChild(t4, "ignore");
      } else if (e3.type) e3 = [e3];
      else if (e3.prop) {
        if (void 0 === e3.value) throw new Error("Value field is missed in node creation");
        "string" != typeof e3.value && (e3.value = String(e3.value)), e3 = [new c(e3)];
      } else if (e3.selector) e3 = [new s2(e3)];
      else if (e3.name) e3 = [new i2(e3)];
      else {
        if (!e3.text) throw new Error("Unknown node type in node creation");
        e3 = [new u(e3)];
      }
      return e3.map((e4) => (e4[l] || h.rebuild(e4), (e4 = e4.proxyOf).parent && e4.parent.removeChild(e4), e4[a2] && f(e4), void 0 === e4.raws.before && t3 && void 0 !== t3.raws.before && (e4.raws.before = t3.raws.before.replace(/\S/g, "")), e4.parent = this.proxyOf, e4));
    }
    prepend() {
      for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
      t3 = t3.reverse();
      for (let e4 of t3) {
        let t4 = this.normalize(e4, this.first, "prepend").reverse();
        for (let e5 of t4) this.proxyOf.nodes.unshift(e5);
        for (let e5 in this.indexes) this.indexes[e5] = this.indexes[e5] + t4.length;
      }
      return this.markDirty(), this;
    }
    push(e3) {
      return e3.parent = this, this.proxyOf.nodes.push(e3), this;
    }
    removeAll() {
      for (let e3 of this.proxyOf.nodes) e3.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(e3) {
      let t3;
      e3 = this.index(e3), this.proxyOf.nodes[e3].parent = void 0, this.proxyOf.nodes.splice(e3, 1);
      for (let r3 in this.indexes) t3 = this.indexes[r3], t3 >= e3 && (this.indexes[r3] = t3 - 1);
      return this.markDirty(), this;
    }
    replaceValues(e3, t3, r3) {
      return r3 || (r3 = t3, t3 = {}), this.walkDecls((n3) => {
        t3.props && !t3.props.includes(n3.prop) || t3.fast && !n3.value.includes(t3.fast) || (n3.value = n3.value.replace(e3, r3));
      }), this.markDirty(), this;
    }
    some(e3) {
      return this.nodes.some(e3);
    }
    walk(e3) {
      return this.each((t3, r3) => {
        let n3;
        try {
          n3 = e3(t3, r3);
        } catch (e4) {
          throw t3.addToError(e4);
        }
        return false !== n3 && t3.walk && (n3 = t3.walk(e3)), n3;
      });
    }
    walkAtRules(e3, t3) {
      return t3 ? e3 instanceof RegExp ? this.walk((r3, n3) => {
        if ("atrule" === r3.type && e3.test(r3.name)) return t3(r3, n3);
      }) : this.walk((r3, n3) => {
        if ("atrule" === r3.type && r3.name === e3) return t3(r3, n3);
      }) : (t3 = e3, this.walk((e4, r3) => {
        if ("atrule" === e4.type) return t3(e4, r3);
      }));
    }
    walkComments(e3) {
      return this.walk((t3, r3) => {
        if ("comment" === t3.type) return e3(t3, r3);
      });
    }
    walkDecls(e3, t3) {
      return t3 ? e3 instanceof RegExp ? this.walk((r3, n3) => {
        if ("decl" === r3.type && e3.test(r3.prop)) return t3(r3, n3);
      }) : this.walk((r3, n3) => {
        if ("decl" === r3.type && r3.prop === e3) return t3(r3, n3);
      }) : (t3 = e3, this.walk((e4, r3) => {
        if ("decl" === e4.type) return t3(e4, r3);
      }));
    }
    walkRules(e3, t3) {
      return t3 ? e3 instanceof RegExp ? this.walk((r3, n3) => {
        if ("rule" === r3.type && e3.test(r3.selector)) return t3(r3, n3);
      }) : this.walk((r3, n3) => {
        if ("rule" === r3.type && r3.selector === e3) return t3(r3, n3);
      }) : (t3 = e3, this.walk((e4, r3) => {
        if ("rule" === e4.type) return t3(e4, r3);
      }));
    }
    get first() {
      if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
  }
  h.registerParse = (e3) => {
    n2 = e3;
  }, h.registerRule = (e3) => {
    s2 = e3;
  }, h.registerAtRule = (e3) => {
    i2 = e3;
  }, h.registerRoot = (e3) => {
    o2 = e3;
  }, e2.exports = h, h.default = h, h.rebuild = (e3) => {
    "atrule" === e3.type ? Object.setPrototypeOf(e3, i2.prototype) : "rule" === e3.type ? Object.setPrototypeOf(e3, s2.prototype) : "decl" === e3.type ? Object.setPrototypeOf(e3, c.prototype) : "comment" === e3.type ? Object.setPrototypeOf(e3, u.prototype) : "root" === e3.type && Object.setPrototypeOf(e3, o2.prototype), e3[l] = true, e3.nodes && e3.nodes.forEach((e4) => {
      h.rebuild(e4);
    });
  };
}, (e2, t2, r2) => {
  var n2 = r2(17);
  function s2(e3) {
    return s2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
      return typeof e4;
    } : function(e4) {
      return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
    }, s2(e3);
  }
  function i2(e3, t3) {
    for (var r3 = 0; r3 < t3.length; r3++) {
      var n3 = t3[r3];
      n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, (void 0, i3 = function(e4, t4) {
        if ("object" !== s2(e4) || null === e4) return e4;
        var r4 = e4[Symbol.toPrimitive];
        if (void 0 !== r4) {
          var n4 = r4.call(e4, "string");
          if ("object" !== s2(n4)) return n4;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return String(e4);
      }(n3.key), "symbol" === s2(i3) ? i3 : String(i3)), n3);
    }
    var i3;
  }
  function o2(e3, t3, r3) {
    return t3 && i2(e3.prototype, t3), r3 && i2(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
  }
  var a2, l, c = r2(227).codes, u = c.ERR_AMBIGUOUS_ARGUMENT, p = c.ERR_INVALID_ARG_TYPE, d = c.ERR_INVALID_ARG_VALUE, f = c.ERR_INVALID_RETURN_VALUE, h = c.ERR_MISSING_ARGS, m = r2(241), y = r2(32).inspect, g = r2(32).types, b = g.isPromise, v = g.isRegExp, E = r2(242)(), S = r2(74)(), x = r2(38)("RegExp.prototype.test");
  function T() {
    var e3 = r2(245);
    a2 = e3.isDeepEqual, l = e3.isDeepStrictEqual;
  }
  /* @__PURE__ */ new Map();
  var w = false, P = e2.exports = I, A = {};
  function C(e3) {
    if (e3.message instanceof Error) throw e3.message;
    throw new m(e3);
  }
  function O(e3, t3, r3, n3) {
    if (!r3) {
      var s3 = false;
      if (0 === t3) s3 = true, n3 = "No value argument passed to `assert.ok()`";
      else if (n3 instanceof Error) throw n3;
      var i3 = new m({ actual: r3, expected: true, message: n3, operator: "==", stackStartFn: e3 });
      throw i3.generatedMessage = s3, i3;
    }
  }
  function I() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    O.apply(void 0, [I, t3.length].concat(t3));
  }
  P.fail = function e3(t3, r3, s3, i3, o3) {
    var a3, l2 = arguments.length;
    if (0 === l2 ? a3 = "Failed" : 1 === l2 ? (s3 = t3, t3 = void 0) : (false === w && (w = true, (n2.emitWarning ? n2.emitWarning : void 0)("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094")), 2 === l2 && (i3 = "!=")), s3 instanceof Error) throw s3;
    var c2 = { actual: t3, expected: r3, operator: void 0 === i3 ? "fail" : i3, stackStartFn: o3 || e3 };
    void 0 !== s3 && (c2.message = s3);
    var u2 = new m(c2);
    throw a3 && (u2.message = a3, u2.generatedMessage = true), u2;
  }, P.AssertionError = m, P.ok = I, P.equal = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    t3 != r3 && C({ actual: t3, expected: r3, message: n3, operator: "==", stackStartFn: e3 });
  }, P.notEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    t3 == r3 && C({ actual: t3, expected: r3, message: n3, operator: "!=", stackStartFn: e3 });
  }, P.deepEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    void 0 === a2 && T(), a2(t3, r3) || C({ actual: t3, expected: r3, message: n3, operator: "deepEqual", stackStartFn: e3 });
  }, P.notDeepEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    void 0 === a2 && T(), a2(t3, r3) && C({ actual: t3, expected: r3, message: n3, operator: "notDeepEqual", stackStartFn: e3 });
  }, P.deepStrictEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    void 0 === a2 && T(), l(t3, r3) || C({ actual: t3, expected: r3, message: n3, operator: "deepStrictEqual", stackStartFn: e3 });
  }, P.notDeepStrictEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    void 0 === a2 && T(), l(t3, r3) && C({ actual: t3, expected: r3, message: n3, operator: "notDeepStrictEqual", stackStartFn: e3 });
  }, P.strictEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    S(t3, r3) || C({ actual: t3, expected: r3, message: n3, operator: "strictEqual", stackStartFn: e3 });
  }, P.notStrictEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    S(t3, r3) && C({ actual: t3, expected: r3, message: n3, operator: "notStrictEqual", stackStartFn: e3 });
  };
  var _ = o2(function e3(t3, r3, n3) {
    var s3 = this;
    !function(e4, t4) {
      if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
    }(this, e3), r3.forEach(function(e4) {
      e4 in t3 && (void 0 !== n3 && "string" == typeof n3[e4] && v(t3[e4]) && x(t3[e4], n3[e4]) ? s3[e4] = n3[e4] : s3[e4] = t3[e4]);
    });
  });
  function k(e3, t3, r3, n3) {
    if ("function" != typeof t3) {
      if (v(t3)) return x(t3, e3);
      if (2 === arguments.length) throw new p("expected", ["Function", "RegExp"], t3);
      if ("object" !== s2(e3) || null === e3) {
        var i3 = new m({ actual: e3, expected: t3, message: r3, operator: "deepStrictEqual", stackStartFn: n3 });
        throw i3.operator = n3.name, i3;
      }
      var o3 = Object.keys(t3);
      if (t3 instanceof Error) o3.push("name", "message");
      else if (0 === o3.length) throw new d("error", t3, "may not be an empty object");
      return void 0 === a2 && T(), o3.forEach(function(s3) {
        "string" == typeof e3[s3] && v(t3[s3]) && x(t3[s3], e3[s3]) || function(e4, t4, r4, n4, s4, i4) {
          if (!(r4 in e4) || !l(e4[r4], t4[r4])) {
            if (!n4) {
              var o4 = new _(e4, s4), a3 = new _(t4, s4, e4), c2 = new m({ actual: o4, expected: a3, operator: "deepStrictEqual", stackStartFn: i4 });
              throw c2.actual = e4, c2.expected = t4, c2.operator = i4.name, c2;
            }
            C({ actual: e4, expected: t4, message: n4, operator: i4.name, stackStartFn: i4 });
          }
        }(e3, t3, s3, r3, o3, n3);
      }), true;
    }
    return void 0 !== t3.prototype && e3 instanceof t3 || !Error.isPrototypeOf(t3) && true === t3.call({}, e3);
  }
  function N(e3) {
    if ("function" != typeof e3) throw new p("fn", "Function", e3);
    try {
      e3();
    } catch (e4) {
      return e4;
    }
    return A;
  }
  function D(e3) {
    return b(e3) || null !== e3 && "object" === s2(e3) && "function" == typeof e3.then && "function" == typeof e3.catch;
  }
  function j(e3) {
    return Promise.resolve().then(function() {
      var t3;
      if ("function" == typeof e3) {
        if (!D(t3 = e3())) throw new f("instance of Promise", "promiseFn", t3);
      } else {
        if (!D(e3)) throw new p("promiseFn", ["Function", "Promise"], e3);
        t3 = e3;
      }
      return Promise.resolve().then(function() {
        return t3;
      }).then(function() {
        return A;
      }).catch(function(e4) {
        return e4;
      });
    });
  }
  function L(e3, t3, r3, n3) {
    if ("string" == typeof r3) {
      if (4 === arguments.length) throw new p("error", ["Object", "Error", "Function", "RegExp"], r3);
      if ("object" === s2(t3) && null !== t3) {
        if (t3.message === r3) throw new u("error/message", 'The error message "'.concat(t3.message, '" is identical to the message.'));
      } else if (t3 === r3) throw new u("error/message", 'The error "'.concat(t3, '" is identical to the message.'));
      n3 = r3, r3 = void 0;
    } else if (null != r3 && "object" !== s2(r3) && "function" != typeof r3) throw new p("error", ["Object", "Error", "Function", "RegExp"], r3);
    if (t3 === A) {
      var i3 = "";
      r3 && r3.name && (i3 += " (".concat(r3.name, ")")), i3 += n3 ? ": ".concat(n3) : ".";
      var o3 = "rejects" === e3.name ? "rejection" : "exception";
      C({ actual: void 0, expected: r3, operator: e3.name, message: "Missing expected ".concat(o3).concat(i3), stackStartFn: e3 });
    }
    if (r3 && !k(t3, r3, n3, e3)) throw t3;
  }
  function M(e3, t3, r3, n3) {
    if (t3 !== A) {
      if ("string" == typeof r3 && (n3 = r3, r3 = void 0), !r3 || k(t3, r3)) {
        var s3 = n3 ? ": ".concat(n3) : ".", i3 = "doesNotReject" === e3.name ? "rejection" : "exception";
        C({ actual: t3, expected: r3, operator: e3.name, message: "Got unwanted ".concat(i3).concat(s3, "\n") + 'Actual message: "'.concat(t3 && t3.message, '"'), stackStartFn: e3 });
      }
      throw t3;
    }
  }
  function B(e3, t3, r3, n3, i3) {
    if (!v(t3)) throw new p("regexp", "RegExp", t3);
    var o3 = "match" === i3;
    if ("string" != typeof e3 || x(t3, e3) !== o3) {
      if (r3 instanceof Error) throw r3;
      var a3 = !r3;
      r3 = r3 || ("string" != typeof e3 ? 'The "string" argument must be of type string. Received type ' + "".concat(s2(e3), " (").concat(y(e3), ")") : (o3 ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(y(t3), ". Input:\n\n").concat(y(e3), "\n"));
      var l2 = new m({ actual: e3, expected: t3, message: r3, operator: i3, stackStartFn: n3 });
      throw l2.generatedMessage = a3, l2;
    }
  }
  function R() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    O.apply(void 0, [R, t3.length].concat(t3));
  }
  P.throws = function e3(t3) {
    for (var r3 = arguments.length, n3 = new Array(r3 > 1 ? r3 - 1 : 0), s3 = 1; s3 < r3; s3++) n3[s3 - 1] = arguments[s3];
    L.apply(void 0, [e3, N(t3)].concat(n3));
  }, P.rejects = function e3(t3) {
    for (var r3 = arguments.length, n3 = new Array(r3 > 1 ? r3 - 1 : 0), s3 = 1; s3 < r3; s3++) n3[s3 - 1] = arguments[s3];
    return j(t3).then(function(t4) {
      return L.apply(void 0, [e3, t4].concat(n3));
    });
  }, P.doesNotThrow = function e3(t3) {
    for (var r3 = arguments.length, n3 = new Array(r3 > 1 ? r3 - 1 : 0), s3 = 1; s3 < r3; s3++) n3[s3 - 1] = arguments[s3];
    M.apply(void 0, [e3, N(t3)].concat(n3));
  }, P.doesNotReject = function e3(t3) {
    for (var r3 = arguments.length, n3 = new Array(r3 > 1 ? r3 - 1 : 0), s3 = 1; s3 < r3; s3++) n3[s3 - 1] = arguments[s3];
    return j(t3).then(function(t4) {
      return M.apply(void 0, [e3, t4].concat(n3));
    });
  }, P.ifError = function e3(t3) {
    if (null != t3) {
      var r3 = "ifError got unwanted exception: ";
      "object" === s2(t3) && "string" == typeof t3.message ? 0 === t3.message.length && t3.constructor ? r3 += t3.constructor.name : r3 += t3.message : r3 += y(t3);
      var n3 = new m({ actual: t3, expected: null, operator: "ifError", message: r3, stackStartFn: e3 }), i3 = t3.stack;
      if ("string" == typeof i3) {
        var o3 = i3.split("\n");
        o3.shift();
        for (var a3 = n3.stack.split("\n"), l2 = 0; l2 < o3.length; l2++) {
          var c2 = a3.indexOf(o3[l2]);
          if (-1 !== c2) {
            a3 = a3.slice(0, c2);
            break;
          }
        }
        n3.stack = "".concat(a3.join("\n"), "\n").concat(o3.join("\n"));
      }
      throw n3;
    }
  }, P.match = function e3(t3, r3, n3) {
    B(t3, r3, n3, e3, "match");
  }, P.doesNotMatch = function e3(t3, r3, n3) {
    B(t3, r3, n3, e3, "doesNotMatch");
  }, P.strict = E(R, P, { equal: P.strictEqual, deepEqual: P.deepStrictEqual, notEqual: P.notStrictEqual, notDeepEqual: P.notDeepStrictEqual }), P.strict.strict = P.strict;
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.UPDATE_OPERATORS = t2.UNARY_OPERATORS = t2.STRING_UNARY_OPERATORS = t2.STATEMENT_OR_BLOCK_KEYS = t2.NUMBER_UNARY_OPERATORS = t2.NUMBER_BINARY_OPERATORS = t2.NOT_LOCAL_BINDING = t2.LOGICAL_OPERATORS = t2.INHERIT_KEYS = t2.FOR_INIT_KEYS = t2.FLATTENABLE_KEYS = t2.EQUALITY_BINARY_OPERATORS = t2.COMPARISON_BINARY_OPERATORS = t2.COMMENT_KEYS = t2.BOOLEAN_UNARY_OPERATORS = t2.BOOLEAN_NUMBER_BINARY_OPERATORS = t2.BOOLEAN_BINARY_OPERATORS = t2.BLOCK_SCOPED_SYMBOL = t2.BINARY_OPERATORS = t2.ASSIGNMENT_OPERATORS = void 0, t2.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], t2.FLATTENABLE_KEYS = ["body", "expressions"], t2.FOR_INIT_KEYS = ["left", "init"], t2.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  const r2 = t2.LOGICAL_OPERATORS = ["||", "&&", "??"], n2 = (t2.UPDATE_OPERATORS = ["++", "--"], t2.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="]), s2 = t2.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], i2 = t2.COMPARISON_BINARY_OPERATORS = [...s2, "in", "instanceof"], o2 = t2.BOOLEAN_BINARY_OPERATORS = [...i2, ...n2], a2 = t2.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], l = (t2.BINARY_OPERATORS = ["+", ...a2, ...o2, "|>"], t2.ASSIGNMENT_OPERATORS = ["=", "+=", ...a2.map((e3) => e3 + "="), ...r2.map((e3) => e3 + "=")], t2.BOOLEAN_UNARY_OPERATORS = ["delete", "!"]), c = t2.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], u = t2.STRING_UNARY_OPERATORS = ["typeof"];
  t2.UNARY_OPERATORS = ["void", "throw", ...l, ...c, ...u], t2.INHERIT_KEYS = { optional: ["typeAnnotation", "typeParameters", "returnType"], force: ["start", "loc", "end"] }, t2.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), t2.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return l(e3, !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2], /* @__PURE__ */ new Map());
  };
  var n2 = r2(9), s2 = r2(2);
  const i2 = Function.call.bind(Object.prototype.hasOwnProperty);
  function o2(e3, t3, r3, n3) {
    return e3 && "string" == typeof e3.type ? l(e3, t3, r3, n3) : e3;
  }
  function a2(e3, t3, r3, n3) {
    return Array.isArray(e3) ? e3.map((e4) => o2(e4, t3, r3, n3)) : o2(e3, t3, r3, n3);
  }
  function l(e3) {
    let t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], o3 = arguments.length > 3 ? arguments[3] : void 0;
    if (!e3) return e3;
    const { type: l2 } = e3, u = { type: e3.type };
    if ((0, s2.isIdentifier)(e3)) u.name = e3.name, i2(e3, "optional") && "boolean" == typeof e3.optional && (u.optional = e3.optional), i2(e3, "typeAnnotation") && (u.typeAnnotation = t3 ? a2(e3.typeAnnotation, true, r3, o3) : e3.typeAnnotation);
    else {
      if (!i2(n2.NODE_FIELDS, l2)) throw new Error(`Unknown node type: "${l2}"`);
      for (const p of Object.keys(n2.NODE_FIELDS[l2])) i2(e3, p) && (u[p] = t3 ? (0, s2.isFile)(e3) && "comments" === p ? c(e3.comments, t3, r3, o3) : a2(e3[p], true, r3, o3) : e3[p]);
    }
    return i2(e3, "loc") && (u.loc = r3 ? null : e3.loc), i2(e3, "leadingComments") && (u.leadingComments = c(e3.leadingComments, t3, r3, o3)), i2(e3, "innerComments") && (u.innerComments = c(e3.innerComments, t3, r3, o3)), i2(e3, "trailingComments") && (u.trailingComments = c(e3.trailingComments, t3, r3, o3)), i2(e3, "extra") && (u.extra = Object.assign({}, e3.extra)), u;
  }
  function c(e3, t3, r3, n3) {
    return e3 && t3 ? e3.map((e4) => {
      const t4 = n3.get(e4);
      if (t4) return t4;
      const { type: s3, value: i3, loc: o3 } = e4, a3 = { type: s3, value: i3, loc: o3 };
      return r3 && (a3.loc = null), n3.set(e4, a3), a3;
    }) : e3;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = t2.SHOULD_STOP = t2.SHOULD_SKIP = t2.REMOVED = void 0;
  var n2 = r2(162), s2 = r2(61), i2 = r2(14), o2 = r2(183), a2 = r2(0), l = a2, c = r2(35), u = r2(101), p = r2(423), d = r2(424), f = r2(427), h = r2(430), m = r2(431), y = r2(436), g = r2(437), b = r2(438), v = r2(440), E = r2(442), S = r2(443), x = r2(163);
  const { validate: T } = a2, w = s2("babel"), P = t2.REMOVED = 1, A = t2.SHOULD_STOP = 2, C = t2.SHOULD_SKIP = 4;
  class O {
    constructor(e3, t3) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = t3, this.hub = e3, this.data = null, this.context = null, this.scope = null;
    }
    static get(e3) {
      let { hub: t3, parentPath: r3, parent: n3, container: s3, listKey: i3, key: o3 } = e3;
      if (!t3 && r3 && (t3 = r3.hub), !n3) throw new Error("To get a node path the parent needs to exist");
      const a3 = s3[o3], l2 = c.getOrCreateCachedPaths(t3, n3);
      let u2 = l2.get(a3);
      return u2 || (u2 = new O(t3, n3), a3 && l2.set(a3, u2)), u2.setup(r3, s3, i3, o3), u2;
    }
    getScope(e3) {
      return this.isScope() ? new o2.default(this) : e3;
    }
    setData(e3, t3) {
      return null == this.data && (this.data = /* @__PURE__ */ Object.create(null)), this.data[e3] = t3;
    }
    getData(e3, t3) {
      null == this.data && (this.data = /* @__PURE__ */ Object.create(null));
      let r3 = this.data[e3];
      return void 0 === r3 && void 0 !== t3 && (r3 = this.data[e3] = t3), r3;
    }
    hasNode() {
      return null != this.node;
    }
    buildCodeFrameError(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : SyntaxError;
      return this.hub.buildError(this.node, e3, t3);
    }
    traverse(e3, t3) {
      (0, i2.default)(this.node, e3, this.scope, t3, this);
    }
    set(e3, t3) {
      T(this.node, e3, t3), this.node[e3] = t3;
    }
    getPathLocation() {
      const e3 = [];
      let t3 = this;
      do {
        let r3 = t3.key;
        t3.inList && (r3 = `${t3.listKey}[${r3}]`), e3.unshift(r3);
      } while (t3 = t3.parentPath);
      return e3.join(".");
    }
    debug(e3) {
      w.enabled && w(`${this.getPathLocation()} ${this.type}: ${e3}`);
    }
    toString() {
      return (0, u.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(e3) {
      e3 || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
    get shouldSkip() {
      return !!(this._traverseFlags & C);
    }
    set shouldSkip(e3) {
      e3 ? this._traverseFlags |= C : this._traverseFlags &= ~C;
    }
    get shouldStop() {
      return !!(this._traverseFlags & A);
    }
    set shouldStop(e3) {
      e3 ? this._traverseFlags |= A : this._traverseFlags &= ~A;
    }
    get removed() {
      return !!(this._traverseFlags & P);
    }
    set removed(e3) {
      e3 ? this._traverseFlags |= P : this._traverseFlags &= ~P;
    }
  }
  Object.assign(O.prototype, p, d, f, h, m, y, g, b, v, E, S), O.prototype._guessExecutionStatusRelativeToDifferentFunctions = y._guessExecutionStatusRelativeTo;
  for (const e3 of l.TYPES) {
    const t3 = `is${e3}`, r3 = l[t3];
    O.prototype[t3] = function(e4) {
      return r3(this.node, e4);
    }, O.prototype[`assert${e3}`] = function(t4) {
      if (!r3(this.node, t4)) throw new TypeError(`Expected node path of type ${e3}`);
    };
  }
  Object.assign(O.prototype, x);
  for (const e3 of Object.keys(n2)) "_" !== e3[0] && (l.TYPES.includes(e3) || l.TYPES.push(e3));
  t2.default = O;
}, (e2, t2, r2) => {
  var n2 = r2(19), s2 = r2(63), i2 = n2({}.hasOwnProperty);
  e2.exports = Object.hasOwn || function(e3, t3) {
    return i2(s2(e3), t3);
  };
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (e3 instanceof n2) return e3;
    try {
      return new n2(e3, t3);
    } catch (e4) {
      if (!r3) return null;
      throw e4;
    }
  };
}, (e2, t2, r2) => {
  r2(12);
  const n2 = r2(417), s2 = r2(418), i2 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
  t2.a = l, t2.b = 50;
  const o2 = 2147483647;
  function a2(e3) {
    if (e3 > o2) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
    const t3 = new Uint8Array(e3);
    return Object.setPrototypeOf(t3, l.prototype), t3;
  }
  function l(e3, t3, r3) {
    if ("number" == typeof e3) {
      if ("string" == typeof t3) throw new TypeError('The "string" argument must be of type string. Received type number');
      return p(e3);
    }
    return c(e3, t3, r3);
  }
  function c(e3, t3, r3) {
    if ("string" == typeof e3) return function(e4, t4) {
      if ("string" == typeof t4 && "" !== t4 || (t4 = "utf8"), !l.isEncoding(t4)) throw new TypeError("Unknown encoding: " + t4);
      const r4 = 0 | m(e4, t4);
      let n4 = a2(r4);
      const s4 = n4.write(e4, t4);
      return s4 !== r4 && (n4 = n4.slice(0, s4)), n4;
    }(e3, t3);
    if (ArrayBuffer.isView(e3)) return function(e4) {
      if (X(e4, Uint8Array)) {
        const t4 = new Uint8Array(e4);
        return f(t4.buffer, t4.byteOffset, t4.byteLength);
      }
      return d(e4);
    }(e3);
    if (null == e3) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
    if (X(e3, ArrayBuffer) || e3 && X(e3.buffer, ArrayBuffer)) return f(e3, t3, r3);
    if ("undefined" != typeof SharedArrayBuffer && (X(e3, SharedArrayBuffer) || e3 && X(e3.buffer, SharedArrayBuffer))) return f(e3, t3, r3);
    if ("number" == typeof e3) throw new TypeError('The "value" argument must not be of type number. Received type number');
    const n3 = e3.valueOf && e3.valueOf();
    if (null != n3 && n3 !== e3) return l.from(n3, t3, r3);
    const s3 = function(e4) {
      if (l.isBuffer(e4)) {
        const t4 = 0 | h(e4.length), r4 = a2(t4);
        return 0 === r4.length || e4.copy(r4, 0, 0, t4), r4;
      }
      return void 0 !== e4.length ? "number" != typeof e4.length || J(e4.length) ? a2(0) : d(e4) : "Buffer" === e4.type && Array.isArray(e4.data) ? d(e4.data) : void 0;
    }(e3);
    if (s3) return s3;
    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e3[Symbol.toPrimitive]) return l.from(e3[Symbol.toPrimitive]("string"), t3, r3);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
  }
  function u(e3) {
    if ("number" != typeof e3) throw new TypeError('"size" argument must be of type number');
    if (e3 < 0) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
  }
  function p(e3) {
    return u(e3), a2(e3 < 0 ? 0 : 0 | h(e3));
  }
  function d(e3) {
    const t3 = e3.length < 0 ? 0 : 0 | h(e3.length), r3 = a2(t3);
    for (let n3 = 0; n3 < t3; n3 += 1) r3[n3] = 255 & e3[n3];
    return r3;
  }
  function f(e3, t3, r3) {
    if (t3 < 0 || e3.byteLength < t3) throw new RangeError('"offset" is outside of buffer bounds');
    if (e3.byteLength < t3 + (r3 || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let n3;
    return n3 = void 0 === t3 && void 0 === r3 ? new Uint8Array(e3) : void 0 === r3 ? new Uint8Array(e3, t3) : new Uint8Array(e3, t3, r3), Object.setPrototypeOf(n3, l.prototype), n3;
  }
  function h(e3) {
    if (e3 >= o2) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o2.toString(16) + " bytes");
    return 0 | e3;
  }
  function m(e3, t3) {
    if (l.isBuffer(e3)) return e3.length;
    if (ArrayBuffer.isView(e3) || X(e3, ArrayBuffer)) return e3.byteLength;
    if ("string" != typeof e3) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e3);
    const r3 = e3.length, n3 = arguments.length > 2 && true === arguments[2];
    if (!n3 && 0 === r3) return 0;
    let s3 = false;
    for (; ; ) switch (t3) {
      case "ascii":
      case "latin1":
      case "binary":
        return r3;
      case "utf8":
      case "utf-8":
        return H(e3).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * r3;
      case "hex":
        return r3 >>> 1;
      case "base64":
        return z(e3).length;
      default:
        if (s3) return n3 ? -1 : H(e3).length;
        t3 = ("" + t3).toLowerCase(), s3 = true;
    }
  }
  function y(e3, t3, r3) {
    let n3 = false;
    if ((void 0 === t3 || t3 < 0) && (t3 = 0), t3 > this.length) return "";
    if ((void 0 === r3 || r3 > this.length) && (r3 = this.length), r3 <= 0) return "";
    if ((r3 >>>= 0) <= (t3 >>>= 0)) return "";
    for (e3 || (e3 = "utf8"); ; ) switch (e3) {
      case "hex":
        return _(this, t3, r3);
      case "utf8":
      case "utf-8":
        return A(this, t3, r3);
      case "ascii":
        return O(this, t3, r3);
      case "latin1":
      case "binary":
        return I(this, t3, r3);
      case "base64":
        return P(this, t3, r3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return k(this, t3, r3);
      default:
        if (n3) throw new TypeError("Unknown encoding: " + e3);
        e3 = (e3 + "").toLowerCase(), n3 = true;
    }
  }
  function g(e3, t3, r3) {
    const n3 = e3[t3];
    e3[t3] = e3[r3], e3[r3] = n3;
  }
  function b(e3, t3, r3, n3, s3) {
    if (0 === e3.length) return -1;
    if ("string" == typeof r3 ? (n3 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), J(r3 = +r3) && (r3 = s3 ? 0 : e3.length - 1), r3 < 0 && (r3 = e3.length + r3), r3 >= e3.length) {
      if (s3) return -1;
      r3 = e3.length - 1;
    } else if (r3 < 0) {
      if (!s3) return -1;
      r3 = 0;
    }
    if ("string" == typeof t3 && (t3 = l.from(t3, n3)), l.isBuffer(t3)) return 0 === t3.length ? -1 : v(e3, t3, r3, n3, s3);
    if ("number" == typeof t3) return t3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? s3 ? Uint8Array.prototype.indexOf.call(e3, t3, r3) : Uint8Array.prototype.lastIndexOf.call(e3, t3, r3) : v(e3, [t3], r3, n3, s3);
    throw new TypeError("val must be string, number or Buffer");
  }
  function v(e3, t3, r3, n3, s3) {
    let i3, o3 = 1, a3 = e3.length, l2 = t3.length;
    if (void 0 !== n3 && ("ucs2" === (n3 = String(n3).toLowerCase()) || "ucs-2" === n3 || "utf16le" === n3 || "utf-16le" === n3)) {
      if (e3.length < 2 || t3.length < 2) return -1;
      o3 = 2, a3 /= 2, l2 /= 2, r3 /= 2;
    }
    function c2(e4, t4) {
      return 1 === o3 ? e4[t4] : e4.readUInt16BE(t4 * o3);
    }
    if (s3) {
      let n4 = -1;
      for (i3 = r3; i3 < a3; i3++) if (c2(e3, i3) === c2(t3, -1 === n4 ? 0 : i3 - n4)) {
        if (-1 === n4 && (n4 = i3), i3 - n4 + 1 === l2) return n4 * o3;
      } else -1 !== n4 && (i3 -= i3 - n4), n4 = -1;
    } else for (r3 + l2 > a3 && (r3 = a3 - l2), i3 = r3; i3 >= 0; i3--) {
      let r4 = true;
      for (let n4 = 0; n4 < l2; n4++) if (c2(e3, i3 + n4) !== c2(t3, n4)) {
        r4 = false;
        break;
      }
      if (r4) return i3;
    }
    return -1;
  }
  function E(e3, t3, r3, n3) {
    r3 = Number(r3) || 0;
    const s3 = e3.length - r3;
    n3 ? (n3 = Number(n3)) > s3 && (n3 = s3) : n3 = s3;
    const i3 = t3.length;
    let o3;
    for (n3 > i3 / 2 && (n3 = i3 / 2), o3 = 0; o3 < n3; ++o3) {
      const n4 = parseInt(t3.substr(2 * o3, 2), 16);
      if (J(n4)) return o3;
      e3[r3 + o3] = n4;
    }
    return o3;
  }
  function S(e3, t3, r3, n3) {
    return K(H(t3, e3.length - r3), e3, r3, n3);
  }
  function x(e3, t3, r3, n3) {
    return K(function(e4) {
      const t4 = [];
      for (let r4 = 0; r4 < e4.length; ++r4) t4.push(255 & e4.charCodeAt(r4));
      return t4;
    }(t3), e3, r3, n3);
  }
  function T(e3, t3, r3, n3) {
    return K(z(t3), e3, r3, n3);
  }
  function w(e3, t3, r3, n3) {
    return K(function(e4, t4) {
      let r4, n4, s3;
      const i3 = [];
      for (let o3 = 0; o3 < e4.length && !((t4 -= 2) < 0); ++o3) r4 = e4.charCodeAt(o3), n4 = r4 >> 8, s3 = r4 % 256, i3.push(s3), i3.push(n4);
      return i3;
    }(t3, e3.length - r3), e3, r3, n3);
  }
  function P(e3, t3, r3) {
    return 0 === t3 && r3 === e3.length ? n2.fromByteArray(e3) : n2.fromByteArray(e3.slice(t3, r3));
  }
  function A(e3, t3, r3) {
    r3 = Math.min(e3.length, r3);
    const n3 = [];
    let s3 = t3;
    for (; s3 < r3; ) {
      const t4 = e3[s3];
      let i3 = null, o3 = t4 > 239 ? 4 : t4 > 223 ? 3 : t4 > 191 ? 2 : 1;
      if (s3 + o3 <= r3) {
        let r4, n4, a3, l2;
        switch (o3) {
          case 1:
            t4 < 128 && (i3 = t4);
            break;
          case 2:
            r4 = e3[s3 + 1], 128 == (192 & r4) && (l2 = (31 & t4) << 6 | 63 & r4, l2 > 127 && (i3 = l2));
            break;
          case 3:
            r4 = e3[s3 + 1], n4 = e3[s3 + 2], 128 == (192 & r4) && 128 == (192 & n4) && (l2 = (15 & t4) << 12 | (63 & r4) << 6 | 63 & n4, l2 > 2047 && (l2 < 55296 || l2 > 57343) && (i3 = l2));
            break;
          case 4:
            r4 = e3[s3 + 1], n4 = e3[s3 + 2], a3 = e3[s3 + 3], 128 == (192 & r4) && 128 == (192 & n4) && 128 == (192 & a3) && (l2 = (15 & t4) << 18 | (63 & r4) << 12 | (63 & n4) << 6 | 63 & a3, l2 > 65535 && l2 < 1114112 && (i3 = l2));
        }
      }
      null === i3 ? (i3 = 65533, o3 = 1) : i3 > 65535 && (i3 -= 65536, n3.push(i3 >>> 10 & 1023 | 55296), i3 = 56320 | 1023 & i3), n3.push(i3), s3 += o3;
    }
    return function(e4) {
      const t4 = e4.length;
      if (t4 <= C) return String.fromCharCode.apply(String, e4);
      let r4 = "", n4 = 0;
      for (; n4 < t4; ) r4 += String.fromCharCode.apply(String, e4.slice(n4, n4 += C));
      return r4;
    }(n3);
  }
  l.TYPED_ARRAY_SUPPORT = function() {
    try {
      const e3 = new Uint8Array(1), t3 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(t3, Uint8Array.prototype), Object.setPrototypeOf(e3, t3), 42 === e3.foo();
    } catch (e3) {
      return false;
    }
  }(), !l.TYPED_ARRAY_SUPPORT && "undefined" != typeof console && console.error, Object.defineProperty(l.prototype, "parent", { enumerable: true, get: function() {
    if (l.isBuffer(this)) return this.buffer;
  } }), Object.defineProperty(l.prototype, "offset", { enumerable: true, get: function() {
    if (l.isBuffer(this)) return this.byteOffset;
  } }), l.poolSize = 8192, l.from = function(e3, t3, r3) {
    return c(e3, t3, r3);
  }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array), l.alloc = function(e3, t3, r3) {
    return function(e4, t4, r4) {
      return u(e4), e4 <= 0 ? a2(e4) : void 0 !== t4 ? "string" == typeof r4 ? a2(e4).fill(t4, r4) : a2(e4).fill(t4) : a2(e4);
    }(e3, t3, r3);
  }, l.allocUnsafe = function(e3) {
    return p(e3);
  }, l.allocUnsafeSlow = function(e3) {
    return p(e3);
  }, l.isBuffer = function(e3) {
    return null != e3 && true === e3._isBuffer && e3 !== l.prototype;
  }, l.compare = function(e3, t3) {
    if (X(e3, Uint8Array) && (e3 = l.from(e3, e3.offset, e3.byteLength)), X(t3, Uint8Array) && (t3 = l.from(t3, t3.offset, t3.byteLength)), !l.isBuffer(e3) || !l.isBuffer(t3)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (e3 === t3) return 0;
    let r3 = e3.length, n3 = t3.length;
    for (let s3 = 0, i3 = Math.min(r3, n3); s3 < i3; ++s3) if (e3[s3] !== t3[s3]) {
      r3 = e3[s3], n3 = t3[s3];
      break;
    }
    return r3 < n3 ? -1 : n3 < r3 ? 1 : 0;
  }, l.isEncoding = function(e3) {
    switch (String(e3).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, l.concat = function(e3, t3) {
    if (!Array.isArray(e3)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (0 === e3.length) return l.alloc(0);
    let r3;
    if (void 0 === t3) for (t3 = 0, r3 = 0; r3 < e3.length; ++r3) t3 += e3[r3].length;
    const n3 = l.allocUnsafe(t3);
    let s3 = 0;
    for (r3 = 0; r3 < e3.length; ++r3) {
      let t4 = e3[r3];
      if (X(t4, Uint8Array)) s3 + t4.length > n3.length ? (l.isBuffer(t4) || (t4 = l.from(t4)), t4.copy(n3, s3)) : Uint8Array.prototype.set.call(n3, t4, s3);
      else {
        if (!l.isBuffer(t4)) throw new TypeError('"list" argument must be an Array of Buffers');
        t4.copy(n3, s3);
      }
      s3 += t4.length;
    }
    return n3;
  }, l.byteLength = m, l.prototype._isBuffer = true, l.prototype.swap16 = function() {
    const e3 = this.length;
    if (e3 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t3 = 0; t3 < e3; t3 += 2) g(this, t3, t3 + 1);
    return this;
  }, l.prototype.swap32 = function() {
    const e3 = this.length;
    if (e3 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t3 = 0; t3 < e3; t3 += 4) g(this, t3, t3 + 3), g(this, t3 + 1, t3 + 2);
    return this;
  }, l.prototype.swap64 = function() {
    const e3 = this.length;
    if (e3 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t3 = 0; t3 < e3; t3 += 8) g(this, t3, t3 + 7), g(this, t3 + 1, t3 + 6), g(this, t3 + 2, t3 + 5), g(this, t3 + 3, t3 + 4);
    return this;
  }, l.prototype.toString = function() {
    const e3 = this.length;
    return 0 === e3 ? "" : 0 === arguments.length ? A(this, 0, e3) : y.apply(this, arguments);
  }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(e3) {
    if (!l.isBuffer(e3)) throw new TypeError("Argument must be a Buffer");
    return this === e3 || 0 === l.compare(this, e3);
  }, l.prototype.inspect = function() {
    let e3 = "";
    const r3 = t2.b;
    return e3 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (e3 += " ... "), "<Buffer " + e3 + ">";
  }, i2 && (l.prototype[i2] = l.prototype.inspect), l.prototype.compare = function(e3, t3, r3, n3, s3) {
    if (X(e3, Uint8Array) && (e3 = l.from(e3, e3.offset, e3.byteLength)), !l.isBuffer(e3)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
    if (void 0 === t3 && (t3 = 0), void 0 === r3 && (r3 = e3 ? e3.length : 0), void 0 === n3 && (n3 = 0), void 0 === s3 && (s3 = this.length), t3 < 0 || r3 > e3.length || n3 < 0 || s3 > this.length) throw new RangeError("out of range index");
    if (n3 >= s3 && t3 >= r3) return 0;
    if (n3 >= s3) return -1;
    if (t3 >= r3) return 1;
    if (this === e3) return 0;
    let i3 = (s3 >>>= 0) - (n3 >>>= 0), o3 = (r3 >>>= 0) - (t3 >>>= 0);
    const a3 = Math.min(i3, o3), c2 = this.slice(n3, s3), u2 = e3.slice(t3, r3);
    for (let e4 = 0; e4 < a3; ++e4) if (c2[e4] !== u2[e4]) {
      i3 = c2[e4], o3 = u2[e4];
      break;
    }
    return i3 < o3 ? -1 : o3 < i3 ? 1 : 0;
  }, l.prototype.includes = function(e3, t3, r3) {
    return -1 !== this.indexOf(e3, t3, r3);
  }, l.prototype.indexOf = function(e3, t3, r3) {
    return b(this, e3, t3, r3, true);
  }, l.prototype.lastIndexOf = function(e3, t3, r3) {
    return b(this, e3, t3, r3, false);
  }, l.prototype.write = function(e3, t3, r3, n3) {
    if (void 0 === t3) n3 = "utf8", r3 = this.length, t3 = 0;
    else if (void 0 === r3 && "string" == typeof t3) n3 = t3, r3 = this.length, t3 = 0;
    else {
      if (!isFinite(t3)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      t3 >>>= 0, isFinite(r3) ? (r3 >>>= 0, void 0 === n3 && (n3 = "utf8")) : (n3 = r3, r3 = void 0);
    }
    const s3 = this.length - t3;
    if ((void 0 === r3 || r3 > s3) && (r3 = s3), e3.length > 0 && (r3 < 0 || t3 < 0) || t3 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    n3 || (n3 = "utf8");
    let i3 = false;
    for (; ; ) switch (n3) {
      case "hex":
        return E(this, e3, t3, r3);
      case "utf8":
      case "utf-8":
        return S(this, e3, t3, r3);
      case "ascii":
      case "latin1":
      case "binary":
        return x(this, e3, t3, r3);
      case "base64":
        return T(this, e3, t3, r3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return w(this, e3, t3, r3);
      default:
        if (i3) throw new TypeError("Unknown encoding: " + n3);
        n3 = ("" + n3).toLowerCase(), i3 = true;
    }
  }, l.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const C = 4096;
  function O(e3, t3, r3) {
    let n3 = "";
    r3 = Math.min(e3.length, r3);
    for (let s3 = t3; s3 < r3; ++s3) n3 += String.fromCharCode(127 & e3[s3]);
    return n3;
  }
  function I(e3, t3, r3) {
    let n3 = "";
    r3 = Math.min(e3.length, r3);
    for (let s3 = t3; s3 < r3; ++s3) n3 += String.fromCharCode(e3[s3]);
    return n3;
  }
  function _(e3, t3, r3) {
    const n3 = e3.length;
    (!t3 || t3 < 0) && (t3 = 0), (!r3 || r3 < 0 || r3 > n3) && (r3 = n3);
    let s3 = "";
    for (let n4 = t3; n4 < r3; ++n4) s3 += Y[e3[n4]];
    return s3;
  }
  function k(e3, t3, r3) {
    const n3 = e3.slice(t3, r3);
    let s3 = "";
    for (let e4 = 0; e4 < n3.length - 1; e4 += 2) s3 += String.fromCharCode(n3[e4] + 256 * n3[e4 + 1]);
    return s3;
  }
  function N(e3, t3, r3) {
    if (e3 % 1 != 0 || e3 < 0) throw new RangeError("offset is not uint");
    if (e3 + t3 > r3) throw new RangeError("Trying to access beyond buffer length");
  }
  function D(e3, t3, r3, n3, s3, i3) {
    if (!l.isBuffer(e3)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t3 > s3 || t3 < i3) throw new RangeError('"value" argument is out of bounds');
    if (r3 + n3 > e3.length) throw new RangeError("Index out of range");
  }
  function j(e3, t3, r3, n3, s3) {
    V(t3, n3, s3, e3, r3, 7);
    let i3 = Number(t3 & BigInt(4294967295));
    e3[r3++] = i3, i3 >>= 8, e3[r3++] = i3, i3 >>= 8, e3[r3++] = i3, i3 >>= 8, e3[r3++] = i3;
    let o3 = Number(t3 >> BigInt(32) & BigInt(4294967295));
    return e3[r3++] = o3, o3 >>= 8, e3[r3++] = o3, o3 >>= 8, e3[r3++] = o3, o3 >>= 8, e3[r3++] = o3, r3;
  }
  function L(e3, t3, r3, n3, s3) {
    V(t3, n3, s3, e3, r3, 7);
    let i3 = Number(t3 & BigInt(4294967295));
    e3[r3 + 7] = i3, i3 >>= 8, e3[r3 + 6] = i3, i3 >>= 8, e3[r3 + 5] = i3, i3 >>= 8, e3[r3 + 4] = i3;
    let o3 = Number(t3 >> BigInt(32) & BigInt(4294967295));
    return e3[r3 + 3] = o3, o3 >>= 8, e3[r3 + 2] = o3, o3 >>= 8, e3[r3 + 1] = o3, o3 >>= 8, e3[r3] = o3, r3 + 8;
  }
  function M(e3, t3, r3, n3, s3, i3) {
    if (r3 + n3 > e3.length) throw new RangeError("Index out of range");
    if (r3 < 0) throw new RangeError("Index out of range");
  }
  function B(e3, t3, r3, n3, i3) {
    return t3 = +t3, r3 >>>= 0, i3 || M(e3, 0, r3, 4), s2.write(e3, t3, r3, n3, 23, 4), r3 + 4;
  }
  function R(e3, t3, r3, n3, i3) {
    return t3 = +t3, r3 >>>= 0, i3 || M(e3, 0, r3, 8), s2.write(e3, t3, r3, n3, 52, 8), r3 + 8;
  }
  l.prototype.slice = function(e3, t3) {
    const r3 = this.length;
    (e3 = ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), (t3 = void 0 === t3 ? r3 : ~~t3) < 0 ? (t3 += r3) < 0 && (t3 = 0) : t3 > r3 && (t3 = r3), t3 < e3 && (t3 = e3);
    const n3 = this.subarray(e3, t3);
    return Object.setPrototypeOf(n3, l.prototype), n3;
  }, l.prototype.readUintLE = l.prototype.readUIntLE = function(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || N(e3, t3, this.length);
    let n3 = this[e3], s3 = 1, i3 = 0;
    for (; ++i3 < t3 && (s3 *= 256); ) n3 += this[e3 + i3] * s3;
    return n3;
  }, l.prototype.readUintBE = l.prototype.readUIntBE = function(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || N(e3, t3, this.length);
    let n3 = this[e3 + --t3], s3 = 1;
    for (; t3 > 0 && (s3 *= 256); ) n3 += this[e3 + --t3] * s3;
    return n3;
  }, l.prototype.readUint8 = l.prototype.readUInt8 = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 1, this.length), this[e3];
  }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
  }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
  }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
  }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
  }, l.prototype.readBigUInt64LE = Q(function(e3) {
    q(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || W(e3, this.length - 8);
    const n3 = t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24, s3 = this[++e3] + 256 * this[++e3] + 65536 * this[++e3] + r3 * 2 ** 24;
    return BigInt(n3) + (BigInt(s3) << BigInt(32));
  }), l.prototype.readBigUInt64BE = Q(function(e3) {
    q(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || W(e3, this.length - 8);
    const n3 = t3 * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + this[++e3], s3 = this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3;
    return (BigInt(n3) << BigInt(32)) + BigInt(s3);
  }), l.prototype.readIntLE = function(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || N(e3, t3, this.length);
    let n3 = this[e3], s3 = 1, i3 = 0;
    for (; ++i3 < t3 && (s3 *= 256); ) n3 += this[e3 + i3] * s3;
    return s3 *= 128, n3 >= s3 && (n3 -= Math.pow(2, 8 * t3)), n3;
  }, l.prototype.readIntBE = function(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || N(e3, t3, this.length);
    let n3 = t3, s3 = 1, i3 = this[e3 + --n3];
    for (; n3 > 0 && (s3 *= 256); ) i3 += this[e3 + --n3] * s3;
    return s3 *= 128, i3 >= s3 && (i3 -= Math.pow(2, 8 * t3)), i3;
  }, l.prototype.readInt8 = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
  }, l.prototype.readInt16LE = function(e3, t3) {
    e3 >>>= 0, t3 || N(e3, 2, this.length);
    const r3 = this[e3] | this[e3 + 1] << 8;
    return 32768 & r3 ? 4294901760 | r3 : r3;
  }, l.prototype.readInt16BE = function(e3, t3) {
    e3 >>>= 0, t3 || N(e3, 2, this.length);
    const r3 = this[e3 + 1] | this[e3] << 8;
    return 32768 & r3 ? 4294901760 | r3 : r3;
  }, l.prototype.readInt32LE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
  }, l.prototype.readInt32BE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
  }, l.prototype.readBigInt64LE = Q(function(e3) {
    q(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || W(e3, this.length - 8);
    const n3 = this[e3 + 4] + 256 * this[e3 + 5] + 65536 * this[e3 + 6] + (r3 << 24);
    return (BigInt(n3) << BigInt(32)) + BigInt(t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24);
  }), l.prototype.readBigInt64BE = Q(function(e3) {
    q(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || W(e3, this.length - 8);
    const n3 = (t3 << 24) + 65536 * this[++e3] + 256 * this[++e3] + this[++e3];
    return (BigInt(n3) << BigInt(32)) + BigInt(this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3);
  }), l.prototype.readFloatLE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 4, this.length), s2.read(this, e3, true, 23, 4);
  }, l.prototype.readFloatBE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 4, this.length), s2.read(this, e3, false, 23, 4);
  }, l.prototype.readDoubleLE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 8, this.length), s2.read(this, e3, true, 52, 8);
  }, l.prototype.readDoubleBE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 8, this.length), s2.read(this, e3, false, 52, 8);
  }, l.prototype.writeUintLE = l.prototype.writeUIntLE = function(e3, t3, r3, n3) {
    e3 = +e3, t3 >>>= 0, r3 >>>= 0, n3 || D(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
    let s3 = 1, i3 = 0;
    for (this[t3] = 255 & e3; ++i3 < r3 && (s3 *= 256); ) this[t3 + i3] = e3 / s3 & 255;
    return t3 + r3;
  }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(e3, t3, r3, n3) {
    e3 = +e3, t3 >>>= 0, r3 >>>= 0, n3 || D(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
    let s3 = r3 - 1, i3 = 1;
    for (this[t3 + s3] = 255 & e3; --s3 >= 0 && (i3 *= 256); ) this[t3 + s3] = e3 / i3 & 255;
    return t3 + r3;
  }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 1, 255, 0), this[t3] = 255 & e3, t3 + 1;
  }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 2, 65535, 0), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
  }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 2, 65535, 0), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
  }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 4, 4294967295, 0), this[t3 + 3] = e3 >>> 24, this[t3 + 2] = e3 >>> 16, this[t3 + 1] = e3 >>> 8, this[t3] = 255 & e3, t3 + 4;
  }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 4, 4294967295, 0), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
  }, l.prototype.writeBigUInt64LE = Q(function(e3) {
    return j(this, e3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l.prototype.writeBigUInt64BE = Q(function(e3) {
    return L(this, e3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l.prototype.writeIntLE = function(e3, t3, r3, n3) {
    if (e3 = +e3, t3 >>>= 0, !n3) {
      const n4 = Math.pow(2, 8 * r3 - 1);
      D(this, e3, t3, r3, n4 - 1, -n4);
    }
    let s3 = 0, i3 = 1, o3 = 0;
    for (this[t3] = 255 & e3; ++s3 < r3 && (i3 *= 256); ) e3 < 0 && 0 === o3 && 0 !== this[t3 + s3 - 1] && (o3 = 1), this[t3 + s3] = (e3 / i3 >> 0) - o3 & 255;
    return t3 + r3;
  }, l.prototype.writeIntBE = function(e3, t3, r3, n3) {
    if (e3 = +e3, t3 >>>= 0, !n3) {
      const n4 = Math.pow(2, 8 * r3 - 1);
      D(this, e3, t3, r3, n4 - 1, -n4);
    }
    let s3 = r3 - 1, i3 = 1, o3 = 0;
    for (this[t3 + s3] = 255 & e3; --s3 >= 0 && (i3 *= 256); ) e3 < 0 && 0 === o3 && 0 !== this[t3 + s3 + 1] && (o3 = 1), this[t3 + s3] = (e3 / i3 >> 0) - o3 & 255;
    return t3 + r3;
  }, l.prototype.writeInt8 = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 1, 127, -128), e3 < 0 && (e3 = 255 + e3 + 1), this[t3] = 255 & e3, t3 + 1;
  }, l.prototype.writeInt16LE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 2, 32767, -32768), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
  }, l.prototype.writeInt16BE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 2, 32767, -32768), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
  }, l.prototype.writeInt32LE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 4, 2147483647, -2147483648), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, this[t3 + 2] = e3 >>> 16, this[t3 + 3] = e3 >>> 24, t3 + 4;
  }, l.prototype.writeInt32BE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
  }, l.prototype.writeBigInt64LE = Q(function(e3) {
    return j(this, e3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), l.prototype.writeBigInt64BE = Q(function(e3) {
    return L(this, e3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), l.prototype.writeFloatLE = function(e3, t3, r3) {
    return B(this, e3, t3, true, r3);
  }, l.prototype.writeFloatBE = function(e3, t3, r3) {
    return B(this, e3, t3, false, r3);
  }, l.prototype.writeDoubleLE = function(e3, t3, r3) {
    return R(this, e3, t3, true, r3);
  }, l.prototype.writeDoubleBE = function(e3, t3, r3) {
    return R(this, e3, t3, false, r3);
  }, l.prototype.copy = function(e3, t3, r3, n3) {
    if (!l.isBuffer(e3)) throw new TypeError("argument should be a Buffer");
    if (r3 || (r3 = 0), n3 || 0 === n3 || (n3 = this.length), t3 >= e3.length && (t3 = e3.length), t3 || (t3 = 0), n3 > 0 && n3 < r3 && (n3 = r3), n3 === r3) return 0;
    if (0 === e3.length || 0 === this.length) return 0;
    if (t3 < 0) throw new RangeError("targetStart out of bounds");
    if (r3 < 0 || r3 >= this.length) throw new RangeError("Index out of range");
    if (n3 < 0) throw new RangeError("sourceEnd out of bounds");
    n3 > this.length && (n3 = this.length), e3.length - t3 < n3 - r3 && (n3 = e3.length - t3 + r3);
    const s3 = n3 - r3;
    return this === e3 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t3, r3, n3) : Uint8Array.prototype.set.call(e3, this.subarray(r3, n3), t3), s3;
  }, l.prototype.fill = function(e3, t3, r3, n3) {
    if ("string" == typeof e3) {
      if ("string" == typeof t3 ? (n3 = t3, t3 = 0, r3 = this.length) : "string" == typeof r3 && (n3 = r3, r3 = this.length), void 0 !== n3 && "string" != typeof n3) throw new TypeError("encoding must be a string");
      if ("string" == typeof n3 && !l.isEncoding(n3)) throw new TypeError("Unknown encoding: " + n3);
      if (1 === e3.length) {
        const t4 = e3.charCodeAt(0);
        ("utf8" === n3 && t4 < 128 || "latin1" === n3) && (e3 = t4);
      }
    } else "number" == typeof e3 ? e3 &= 255 : "boolean" == typeof e3 && (e3 = Number(e3));
    if (t3 < 0 || this.length < t3 || this.length < r3) throw new RangeError("Out of range index");
    if (r3 <= t3) return this;
    let s3;
    if (t3 >>>= 0, r3 = void 0 === r3 ? this.length : r3 >>> 0, e3 || (e3 = 0), "number" == typeof e3) for (s3 = t3; s3 < r3; ++s3) this[s3] = e3;
    else {
      const i3 = l.isBuffer(e3) ? e3 : l.from(e3, n3), o3 = i3.length;
      if (0 === o3) throw new TypeError('The value "' + e3 + '" is invalid for argument "value"');
      for (s3 = 0; s3 < r3 - t3; ++s3) this[s3 + t3] = i3[s3 % o3];
    }
    return this;
  };
  const F = {};
  function U(e3, t3, r3) {
    F[e3] = class extends r3 {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: t3.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e3}]`, this.stack, delete this.name;
      }
      get code() {
        return e3;
      }
      set code(e4) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e4, writable: true });
      }
      toString() {
        return `${this.name} [${e3}]: ${this.message}`;
      }
    };
  }
  function $(e3) {
    let t3 = "", r3 = e3.length;
    const n3 = "-" === e3[0] ? 1 : 0;
    for (; r3 >= n3 + 4; r3 -= 3) t3 = `_${e3.slice(r3 - 3, r3)}${t3}`;
    return `${e3.slice(0, r3)}${t3}`;
  }
  function V(e3, t3, r3, n3, s3, i3) {
    if (e3 > r3 || e3 < t3) {
      const n4 = "bigint" == typeof t3 ? "n" : "";
      let s4;
      throw s4 = i3 > 3 ? 0 === t3 || t3 === BigInt(0) ? `>= 0${n4} and < 2${n4} ** ${8 * (i3 + 1)}${n4}` : `>= -(2${n4} ** ${8 * (i3 + 1) - 1}${n4}) and < 2 ** ${8 * (i3 + 1) - 1}${n4}` : `>= ${t3}${n4} and <= ${r3}${n4}`, new F.ERR_OUT_OF_RANGE("value", s4, e3);
    }
    !function(e4, t4, r4) {
      q(t4, "offset"), void 0 !== e4[t4] && void 0 !== e4[t4 + r4] || W(t4, e4.length - (r4 + 1));
    }(n3, s3, i3);
  }
  function q(e3, t3) {
    if ("number" != typeof e3) throw new F.ERR_INVALID_ARG_TYPE(t3, "number", e3);
  }
  function W(e3, t3, r3) {
    if (Math.floor(e3) !== e3) throw q(e3, r3), new F.ERR_OUT_OF_RANGE(r3 || "offset", "an integer", e3);
    if (t3 < 0) throw new F.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new F.ERR_OUT_OF_RANGE(r3 || "offset", `>= ${r3 ? 1 : 0} and <= ${t3}`, e3);
  }
  U("ERR_BUFFER_OUT_OF_BOUNDS", function(e3) {
    return e3 ? `${e3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), U("ERR_INVALID_ARG_TYPE", function(e3, t3) {
    return `The "${e3}" argument must be of type number. Received type ${typeof t3}`;
  }, TypeError), U("ERR_OUT_OF_RANGE", function(e3, t3, r3) {
    let n3 = `The value of "${e3}" is out of range.`, s3 = r3;
    return Number.isInteger(r3) && Math.abs(r3) > 2 ** 32 ? s3 = $(String(r3)) : "bigint" == typeof r3 && (s3 = String(r3), (r3 > BigInt(2) ** BigInt(32) || r3 < -(BigInt(2) ** BigInt(32))) && (s3 = $(s3)), s3 += "n"), n3 += ` It must be ${t3}. Received ${s3}`, n3;
  }, RangeError);
  const G = /[^+/0-9A-Za-z-_]/g;
  function H(e3, t3) {
    let r3;
    t3 = t3 || 1 / 0;
    const n3 = e3.length;
    let s3 = null;
    const i3 = [];
    for (let o3 = 0; o3 < n3; ++o3) {
      if (r3 = e3.charCodeAt(o3), r3 > 55295 && r3 < 57344) {
        if (!s3) {
          if (r3 > 56319) {
            (t3 -= 3) > -1 && i3.push(239, 191, 189);
            continue;
          }
          if (o3 + 1 === n3) {
            (t3 -= 3) > -1 && i3.push(239, 191, 189);
            continue;
          }
          s3 = r3;
          continue;
        }
        if (r3 < 56320) {
          (t3 -= 3) > -1 && i3.push(239, 191, 189), s3 = r3;
          continue;
        }
        r3 = 65536 + (s3 - 55296 << 10 | r3 - 56320);
      } else s3 && (t3 -= 3) > -1 && i3.push(239, 191, 189);
      if (s3 = null, r3 < 128) {
        if ((t3 -= 1) < 0) break;
        i3.push(r3);
      } else if (r3 < 2048) {
        if ((t3 -= 2) < 0) break;
        i3.push(r3 >> 6 | 192, 63 & r3 | 128);
      } else if (r3 < 65536) {
        if ((t3 -= 3) < 0) break;
        i3.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
      } else {
        if (!(r3 < 1114112)) throw new Error("Invalid code point");
        if ((t3 -= 4) < 0) break;
        i3.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
      }
    }
    return i3;
  }
  function z(e3) {
    return n2.toByteArray(function(e4) {
      if ((e4 = (e4 = e4.split("=")[0]).trim().replace(G, "")).length < 2) return "";
      for (; e4.length % 4 != 0; ) e4 += "=";
      return e4;
    }(e3));
  }
  function K(e3, t3, r3, n3) {
    let s3;
    for (s3 = 0; s3 < n3 && !(s3 + r3 >= t3.length || s3 >= e3.length); ++s3) t3[s3 + r3] = e3[s3];
    return s3;
  }
  function X(e3, t3) {
    return e3 instanceof t3 || null != e3 && null != e3.constructor && null != e3.constructor.name && e3.constructor.name === t3.name;
  }
  function J(e3) {
    return e3 != e3;
  }
  const Y = function() {
    const e3 = "0123456789abcdef", t3 = new Array(256);
    for (let r3 = 0; r3 < 16; ++r3) {
      const n3 = 16 * r3;
      for (let s3 = 0; s3 < 16; ++s3) t3[n3 + s3] = e3[r3] + e3[s3];
    }
    return t3;
  }();
  function Q(e3) {
    return "undefined" == typeof BigInt ? Z : e3;
  }
  function Z() {
    throw new Error("BigInt not supported");
  }
}, (e2, t2, r2) => {
  var n2 = r2(17), s2 = Object.getOwnPropertyDescriptors || function(e3) {
    for (var t3 = Object.keys(e3), r3 = {}, n3 = 0; n3 < t3.length; n3++) r3[t3[n3]] = Object.getOwnPropertyDescriptor(e3, t3[n3]);
    return r3;
  }, i2 = /%[sdj%]/g;
  t2.format = function(e3) {
    if (!b(e3)) {
      for (var t3 = [], r3 = 0; r3 < arguments.length; r3++) t3.push(l(arguments[r3]));
      return t3.join(" ");
    }
    r3 = 1;
    for (var n3 = arguments, s3 = n3.length, o3 = String(e3).replace(i2, function(e4) {
      if ("%%" === e4) return "%";
      if (r3 >= s3) return e4;
      switch (e4) {
        case "%s":
          return String(n3[r3++]);
        case "%d":
          return Number(n3[r3++]);
        case "%j":
          try {
            return JSON.stringify(n3[r3++]);
          } catch (e5) {
            return "[Circular]";
          }
        default:
          return e4;
      }
    }), a3 = n3[r3]; r3 < s3; a3 = n3[++r3]) y(a3) || !S(a3) ? o3 += " " + a3 : o3 += " " + l(a3);
    return o3;
  }, t2.deprecate = function(e3, r3) {
    if (void 0 !== n2 && true === n2.noDeprecation) return e3;
    if (void 0 === n2) return function() {
      return t2.deprecate(e3, r3).apply(this, arguments);
    };
    var s3 = false;
    return function() {
      if (!s3) {
        if (n2.throwDeprecation) throw new Error(r3);
        n2.traceDeprecation, s3 = true;
      }
      return e3.apply(this, arguments);
    };
  };
  var o2 = {}, a2 = /^$/;
  function l(e3, r3) {
    var n3 = { seen: [], stylize: u };
    return arguments.length >= 3 && (n3.depth = arguments[2]), arguments.length >= 4 && (n3.colors = arguments[3]), m(r3) ? n3.showHidden = r3 : r3 && t2._extend(n3, r3), v(n3.showHidden) && (n3.showHidden = false), v(n3.depth) && (n3.depth = 2), v(n3.colors) && (n3.colors = false), v(n3.customInspect) && (n3.customInspect = true), n3.colors && (n3.stylize = c), p(n3, e3, n3.depth);
  }
  function c(e3, t3) {
    var r3 = l.styles[t3];
    return r3 ? "\x1B[" + l.colors[r3][0] + "m" + e3 + "\x1B[" + l.colors[r3][1] + "m" : e3;
  }
  function u(e3, t3) {
    return e3;
  }
  function p(e3, r3, n3) {
    if (e3.customInspect && r3 && w(r3.inspect) && r3.inspect !== t2.inspect && (!r3.constructor || r3.constructor.prototype !== r3)) {
      var s3 = r3.inspect(n3, e3);
      return b(s3) || (s3 = p(e3, s3, n3)), s3;
    }
    var i3 = function(e4, t3) {
      if (v(t3)) return e4.stylize("undefined", "undefined");
      if (b(t3)) {
        var r4 = "'" + JSON.stringify(t3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e4.stylize(r4, "string");
      }
      return g(t3) ? e4.stylize("" + t3, "number") : m(t3) ? e4.stylize("" + t3, "boolean") : y(t3) ? e4.stylize("null", "null") : void 0;
    }(e3, r3);
    if (i3) return i3;
    var o3 = Object.keys(r3), a3 = function(e4) {
      var t3 = {};
      return e4.forEach(function(e5, r4) {
        t3[e5] = true;
      }), t3;
    }(o3);
    if (e3.showHidden && (o3 = Object.getOwnPropertyNames(r3)), T(r3) && (o3.indexOf("message") >= 0 || o3.indexOf("description") >= 0)) return d(r3);
    if (0 === o3.length) {
      if (w(r3)) {
        var l2 = r3.name ? ": " + r3.name : "";
        return e3.stylize("[Function" + l2 + "]", "special");
      }
      if (E(r3)) return e3.stylize(RegExp.prototype.toString.call(r3), "regexp");
      if (x(r3)) return e3.stylize(Date.prototype.toString.call(r3), "date");
      if (T(r3)) return d(r3);
    }
    var c2, u2 = "", S2 = false, P2 = ["{", "}"];
    return h(r3) && (S2 = true, P2 = ["[", "]"]), w(r3) && (u2 = " [Function" + (r3.name ? ": " + r3.name : "") + "]"), E(r3) && (u2 = " " + RegExp.prototype.toString.call(r3)), x(r3) && (u2 = " " + Date.prototype.toUTCString.call(r3)), T(r3) && (u2 = " " + d(r3)), 0 !== o3.length || S2 && 0 != r3.length ? n3 < 0 ? E(r3) ? e3.stylize(RegExp.prototype.toString.call(r3), "regexp") : e3.stylize("[Object]", "special") : (e3.seen.push(r3), c2 = S2 ? function(e4, t3, r4, n4, s4) {
      for (var i4 = [], o4 = 0, a4 = t3.length; o4 < a4; ++o4) A(t3, String(o4)) ? i4.push(f(e4, t3, r4, n4, String(o4), true)) : i4.push("");
      return s4.forEach(function(s5) {
        s5.match(/^\d+$/) || i4.push(f(e4, t3, r4, n4, s5, true));
      }), i4;
    }(e3, r3, n3, a3, o3) : o3.map(function(t3) {
      return f(e3, r3, n3, a3, t3, S2);
    }), e3.seen.pop(), function(e4, t3, r4) {
      return e4.reduce(function(e5, t4) {
        return t4.indexOf("\n"), e5 + t4.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0) > 60 ? r4[0] + ("" === t3 ? "" : t3 + "\n ") + " " + e4.join(",\n  ") + " " + r4[1] : r4[0] + t3 + " " + e4.join(", ") + " " + r4[1];
    }(c2, u2, P2)) : P2[0] + u2 + P2[1];
  }
  function d(e3) {
    return "[" + Error.prototype.toString.call(e3) + "]";
  }
  function f(e3, t3, r3, n3, s3, i3) {
    var o3, a3, l2;
    if ((l2 = Object.getOwnPropertyDescriptor(t3, s3) || { value: t3[s3] }).get ? a3 = l2.set ? e3.stylize("[Getter/Setter]", "special") : e3.stylize("[Getter]", "special") : l2.set && (a3 = e3.stylize("[Setter]", "special")), A(n3, s3) || (o3 = "[" + s3 + "]"), a3 || (e3.seen.indexOf(l2.value) < 0 ? (a3 = y(r3) ? p(e3, l2.value, null) : p(e3, l2.value, r3 - 1)).indexOf("\n") > -1 && (a3 = i3 ? a3.split("\n").map(function(e4) {
      return "  " + e4;
    }).join("\n").slice(2) : "\n" + a3.split("\n").map(function(e4) {
      return "   " + e4;
    }).join("\n")) : a3 = e3.stylize("[Circular]", "special")), v(o3)) {
      if (i3 && s3.match(/^\d+$/)) return a3;
      (o3 = JSON.stringify("" + s3)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o3 = o3.slice(1, -1), o3 = e3.stylize(o3, "name")) : (o3 = o3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o3 = e3.stylize(o3, "string"));
    }
    return o3 + ": " + a3;
  }
  function h(e3) {
    return Array.isArray(e3);
  }
  function m(e3) {
    return "boolean" == typeof e3;
  }
  function y(e3) {
    return null === e3;
  }
  function g(e3) {
    return "number" == typeof e3;
  }
  function b(e3) {
    return "string" == typeof e3;
  }
  function v(e3) {
    return void 0 === e3;
  }
  function E(e3) {
    return S(e3) && "[object RegExp]" === P(e3);
  }
  function S(e3) {
    return "object" == typeof e3 && null !== e3;
  }
  function x(e3) {
    return S(e3) && "[object Date]" === P(e3);
  }
  function T(e3) {
    return S(e3) && ("[object Error]" === P(e3) || e3 instanceof Error);
  }
  function w(e3) {
    return "function" == typeof e3;
  }
  function P(e3) {
    return Object.prototype.toString.call(e3);
  }
  function A(e3, t3) {
    return Object.prototype.hasOwnProperty.call(e3, t3);
  }
  t2.debuglog = function(e3) {
    return e3 = e3.toUpperCase(), o2[e3] || (a2.test(e3) ? (n2.pid, o2[e3] = function() {
      t2.format.apply(t2, arguments);
    }) : o2[e3] = function() {
    }), o2[e3];
  }, t2.inspect = l, l.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, l.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, t2.types = r2(228), t2.isArray = h, t2.isBoolean = m, t2.isNull = y, t2.isNullOrUndefined = function(e3) {
    return null == e3;
  }, t2.isNumber = g, t2.isString = b, t2.isSymbol = function(e3) {
    return "symbol" == typeof e3;
  }, t2.isUndefined = v, t2.isRegExp = E, t2.types.isRegExp = E, t2.isObject = S, t2.isDate = x, t2.types.isDate = x, t2.isError = T, t2.types.isNativeError = T, t2.isFunction = w, t2.isPrimitive = function(e3) {
    return null === e3 || "boolean" == typeof e3 || "number" == typeof e3 || "string" == typeof e3 || "symbol" == typeof e3 || void 0 === e3;
  }, t2.isBuffer = r2(240), t2.log = function() {
  }, t2.inherits = r2(158), t2._extend = function(e3, t3) {
    if (!t3 || !S(t3)) return e3;
    for (var r3 = Object.keys(t3), n3 = r3.length; n3--; ) e3[r3[n3]] = t3[r3[n3]];
    return e3;
  };
  var C = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
  function O(e3, t3) {
    if (!e3) {
      var r3 = new Error("Promise was rejected with a falsy value");
      r3.reason = e3, e3 = r3;
    }
    return t3(e3);
  }
  t2.promisify = function(e3) {
    if ("function" != typeof e3) throw new TypeError('The "original" argument must be of type Function');
    if (C && e3[C]) {
      var t3;
      if ("function" != typeof (t3 = e3[C])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(t3, C, { value: t3, enumerable: false, writable: false, configurable: true }), t3;
    }
    function t3() {
      for (var t4, r3, n3 = new Promise(function(e4, n4) {
        t4 = e4, r3 = n4;
      }), s3 = [], i3 = 0; i3 < arguments.length; i3++) s3.push(arguments[i3]);
      s3.push(function(e4, n4) {
        e4 ? r3(e4) : t4(n4);
      });
      try {
        e3.apply(this, s3);
      } catch (e4) {
        r3(e4);
      }
      return n3;
    }
    return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), C && Object.defineProperty(t3, C, { value: t3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t3, s2(e3));
  }, t2.promisify.custom = C, t2.callbackify = function(e3) {
    if ("function" != typeof e3) throw new TypeError('The "original" argument must be of type Function');
    function t3() {
      for (var t4 = [], r3 = 0; r3 < arguments.length; r3++) t4.push(arguments[r3]);
      var s3 = t4.pop();
      if ("function" != typeof s3) throw new TypeError("The last argument must be of type Function");
      var i3 = this, o3 = function() {
        return s3.apply(i3, arguments);
      };
      e3.apply(this, t4).then(function(e4) {
        n2.nextTick(o3.bind(null, null, e4));
      }, function(e4) {
        n2.nextTick(O.bind(null, e4, o3));
      });
    }
    return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), Object.defineProperties(t3, s2(e3)), t3;
  };
}, (e2, t2) => {
  function r2(e3) {
    const { context: t3, node: r3 } = e3;
    if (r3.computed && t3.maybeQueue(e3.get("key")), r3.decorators) for (const r4 of e3.get("decorators")) t3.maybeQueue(r4);
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.requeueComputedKeyAndDecorators = r2, t2.skipAllButComputedKey = function(e3) {
    e3.skip(), e3.node.computed && e3.context.maybeQueue(e3.get("key"));
  };
  var n2 = { FunctionParent(e3) {
    e3.isArrowFunctionExpression() || (e3.skip(), e3.isMethod() && r2(e3));
  }, Property(e3) {
    e3.isObjectProperty() || (e3.skip(), r2(e3));
  } };
  t2.default = n2;
}, (e2, t2, r2) => {
  const { MAX_SAFE_COMPONENT_LENGTH: n2, MAX_SAFE_BUILD_LENGTH: s2, MAX_LENGTH: i2 } = r2(47), o2 = r2(48), a2 = (t2 = e2.exports = {}).re = [], l = t2.safeRe = [], c = t2.src = [], u = t2.t = {};
  let p = 0;
  const d = "[a-zA-Z0-9-]", f = [["\\s", 1], ["\\d", i2], [d, s2]], h = (e3, t3, r3) => {
    const n3 = ((e4) => {
      for (const [t4, r4] of f) e4 = e4.split(`${t4}*`).join(`${t4}{0,${r4}}`).split(`${t4}+`).join(`${t4}{1,${r4}}`);
      return e4;
    })(t3), s3 = p++;
    o2(e3, s3, t3), u[e3] = s3, c[s3] = t3, a2[s3] = new RegExp(t3, r3 ? "g" : void 0), l[s3] = new RegExp(n3, r3 ? "g" : void 0);
  };
  h("NUMERICIDENTIFIER", "0|[1-9]\\d*"), h("NUMERICIDENTIFIERLOOSE", "\\d+"), h("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${d}*`), h("MAINVERSION", `(${c[u.NUMERICIDENTIFIER]})\\.(${c[u.NUMERICIDENTIFIER]})\\.(${c[u.NUMERICIDENTIFIER]})`), h("MAINVERSIONLOOSE", `(${c[u.NUMERICIDENTIFIERLOOSE]})\\.(${c[u.NUMERICIDENTIFIERLOOSE]})\\.(${c[u.NUMERICIDENTIFIERLOOSE]})`), h("PRERELEASEIDENTIFIER", `(?:${c[u.NUMERICIDENTIFIER]}|${c[u.NONNUMERICIDENTIFIER]})`), h("PRERELEASEIDENTIFIERLOOSE", `(?:${c[u.NUMERICIDENTIFIERLOOSE]}|${c[u.NONNUMERICIDENTIFIER]})`), h("PRERELEASE", `(?:-(${c[u.PRERELEASEIDENTIFIER]}(?:\\.${c[u.PRERELEASEIDENTIFIER]})*))`), h("PRERELEASELOOSE", `(?:-?(${c[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[u.PRERELEASEIDENTIFIERLOOSE]})*))`), h("BUILDIDENTIFIER", `${d}+`), h("BUILD", `(?:\\+(${c[u.BUILDIDENTIFIER]}(?:\\.${c[u.BUILDIDENTIFIER]})*))`), h("FULLPLAIN", `v?${c[u.MAINVERSION]}${c[u.PRERELEASE]}?${c[u.BUILD]}?`), h("FULL", `^${c[u.FULLPLAIN]}$`), h("LOOSEPLAIN", `[v=\\s]*${c[u.MAINVERSIONLOOSE]}${c[u.PRERELEASELOOSE]}?${c[u.BUILD]}?`), h("LOOSE", `^${c[u.LOOSEPLAIN]}$`), h("GTLT", "((?:<|>)?=?)"), h("XRANGEIDENTIFIERLOOSE", `${c[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), h("XRANGEIDENTIFIER", `${c[u.NUMERICIDENTIFIER]}|x|X|\\*`), h("XRANGEPLAIN", `[v=\\s]*(${c[u.XRANGEIDENTIFIER]})(?:\\.(${c[u.XRANGEIDENTIFIER]})(?:\\.(${c[u.XRANGEIDENTIFIER]})(?:${c[u.PRERELEASE]})?${c[u.BUILD]}?)?)?`), h("XRANGEPLAINLOOSE", `[v=\\s]*(${c[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[u.XRANGEIDENTIFIERLOOSE]})(?:${c[u.PRERELEASELOOSE]})?${c[u.BUILD]}?)?)?`), h("XRANGE", `^${c[u.GTLT]}\\s*${c[u.XRANGEPLAIN]}$`), h("XRANGELOOSE", `^${c[u.GTLT]}\\s*${c[u.XRANGEPLAINLOOSE]}$`), h("COERCE", `(^|[^\\d])(\\d{1,${n2}})(?:\\.(\\d{1,${n2}}))?(?:\\.(\\d{1,${n2}}))?(?:$|[^\\d])`), h("COERCERTL", c[u.COERCE], true), h("LONETILDE", "(?:~>?)"), h("TILDETRIM", `(\\s*)${c[u.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", h("TILDE", `^${c[u.LONETILDE]}${c[u.XRANGEPLAIN]}$`), h("TILDELOOSE", `^${c[u.LONETILDE]}${c[u.XRANGEPLAINLOOSE]}$`), h("LONECARET", "(?:\\^)"), h("CARETTRIM", `(\\s*)${c[u.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", h("CARET", `^${c[u.LONECARET]}${c[u.XRANGEPLAIN]}$`), h("CARETLOOSE", `^${c[u.LONECARET]}${c[u.XRANGEPLAINLOOSE]}$`), h("COMPARATORLOOSE", `^${c[u.GTLT]}\\s*(${c[u.LOOSEPLAIN]})$|^$`), h("COMPARATOR", `^${c[u.GTLT]}\\s*(${c[u.FULLPLAIN]})$|^$`), h("COMPARATORTRIM", `(\\s*)${c[u.GTLT]}\\s*(${c[u.LOOSEPLAIN]}|${c[u.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", h("HYPHENRANGE", `^\\s*(${c[u.XRANGEPLAIN]})\\s+-\\s+(${c[u.XRANGEPLAIN]})\\s*$`), h("HYPHENRANGELOOSE", `^\\s*(${c[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[u.XRANGEPLAINLOOSE]})\\s*$`), h("STAR", "(<|>)?=?\\s*\\*"), h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.clear = function() {
    s2(), i2();
  }, t2.clearPath = s2, t2.clearScope = i2, t2.getCachedPaths = function(e3, t3) {
    var n3;
    return null == (n3 = r2.get(o2)) ? void 0 : n3.get(t3);
  }, t2.getOrCreateCachedPaths = function(e3, t3) {
    let n3 = r2.get(o2);
    n3 || r2.set(o2, n3 = /* @__PURE__ */ new WeakMap());
    let s3 = n3.get(t3);
    return s3 || n3.set(t3, s3 = /* @__PURE__ */ new Map()), s3;
  }, t2.scope = t2.path = void 0;
  let r2 = t2.path = /* @__PURE__ */ new WeakMap(), n2 = t2.scope = /* @__PURE__ */ new WeakMap();
  function s2() {
    t2.path = r2 = /* @__PURE__ */ new WeakMap();
  }
  function i2() {
    t2.scope = n2 = /* @__PURE__ */ new WeakMap();
  }
  const o2 = Object.freeze({});
}, (e2, t2, r2) => {
  var n2 = r2(17);
  Object.defineProperty(t2, "__esModule", { value: true }), t2.codeFrameColumns = u, t2.default = function(e3, t3, r3) {
    let s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
    if (!l) {
      l = true;
      const e4 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      n2.emitWarning ? n2.emitWarning(e4, "DeprecationWarning") : new Error(e4).name = "DeprecationWarning";
    }
    return u(e3, { start: { column: r3 = Math.max(r3, 0), line: t3 } }, s3);
  };
  var s2 = r2(428), i2 = function(e3, t3) {
    if (null === e3 || "object" != typeof e3 && "function" != typeof e3) return { default: e3 };
    var r3 = o2(true);
    if (r3 && r3.has(e3)) return r3.get(e3);
    var n3 = { __proto__: null }, s3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var i3 in e3) if ("default" !== i3 && Object.prototype.hasOwnProperty.call(e3, i3)) {
      var a3 = s3 ? Object.getOwnPropertyDescriptor(e3, i3) : null;
      a3 && (a3.get || a3.set) ? Object.defineProperty(n3, i3, a3) : n3[i3] = e3[i3];
    }
    return n3.default = e3, r3 && r3.set(e3, n3), n3;
  }(r2(224));
  function o2(e3) {
    if ("function" != typeof WeakMap) return null;
    var t3 = /* @__PURE__ */ new WeakMap(), r3 = /* @__PURE__ */ new WeakMap();
    return (o2 = function(e4) {
      return e4 ? r3 : t3;
    })(e3);
  }
  let a2, l = false;
  const c = /\r\n|[\n\r\u2028\u2029]/;
  function u(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    const n3 = (r3.highlightCode || r3.forceColor) && (0, s2.shouldHighlight)(r3), o3 = r3.forceColor ? (null != a2 || (a2 = new i2.default.constructor({ enabled: true, level: 1 })), a2) : i2.default, l2 = function(e4) {
      return { gutter: e4.grey, marker: e4.red.bold, message: e4.red.bold };
    }(o3), u2 = (e4, t4) => n3 ? e4(t4) : t4, p = e3.split(c), { start: d, end: f, markerLines: h } = function(e4, t4, r4) {
      const n4 = Object.assign({ column: 0, line: -1 }, e4.start), s3 = Object.assign({}, n4, e4.end), { linesAbove: i3 = 2, linesBelow: o4 = 3 } = r4 || {}, a3 = n4.line, l3 = n4.column, c2 = s3.line, u3 = s3.column;
      let p2 = Math.max(a3 - (i3 + 1), 0), d2 = Math.min(t4.length, c2 + o4);
      -1 === a3 && (p2 = 0), -1 === c2 && (d2 = t4.length);
      const f2 = c2 - a3, h2 = {};
      if (f2) for (let e5 = 0; e5 <= f2; e5++) {
        const r5 = e5 + a3;
        if (l3) if (0 === e5) {
          const e6 = t4[r5 - 1].length;
          h2[r5] = [l3, e6 - l3 + 1];
        } else if (e5 === f2) h2[r5] = [0, u3];
        else {
          const n5 = t4[r5 - e5].length;
          h2[r5] = [0, n5];
        }
        else h2[r5] = true;
      }
      else h2[a3] = l3 === u3 ? !l3 || [l3, 0] : [l3, u3 - l3];
      return { start: p2, end: d2, markerLines: h2 };
    }(t3, p, r3), m = t3.start && "number" == typeof t3.start.column, y = String(f).length;
    let g = (n3 ? (0, s2.default)(e3, r3) : e3).split(c, f).slice(d, f).map((e4, t4) => {
      const n4 = d + 1 + t4, s3 = ` ${` ${n4}`.slice(-y)} |`, i3 = h[n4], o4 = !h[n4 + 1];
      if (i3) {
        let t5 = "";
        if (Array.isArray(i3)) {
          const n5 = e4.slice(0, Math.max(i3[0] - 1, 0)).replace(/[^\t]/g, " "), a3 = i3[1] || 1;
          t5 = ["\n ", u2(l2.gutter, s3.replace(/\d/g, " ")), " ", n5, u2(l2.marker, "^").repeat(a3)].join(""), o4 && r3.message && (t5 += " " + u2(l2.message, r3.message));
        }
        return [u2(l2.marker, ">"), u2(l2.gutter, s3), e4.length > 0 ? ` ${e4}` : "", t5].join("");
      }
      return ` ${u2(l2.gutter, s3)}${e4.length > 0 ? ` ${e4}` : ""}`;
    }).join("\n");
    return r3.message && !m && (g = `${" ".repeat(y + 1)}${r3.message}
${g}`), n3 ? o3.reset(g) : g;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.statements = t2.statement = t2.smart = t2.program = t2.expression = t2.default = void 0;
  var n2 = r2(432), s2 = r2(433);
  const i2 = (0, s2.default)(n2.smart);
  t2.smart = i2;
  const o2 = (0, s2.default)(n2.statement);
  t2.statement = o2;
  const a2 = (0, s2.default)(n2.statements);
  t2.statements = a2;
  const l = (0, s2.default)(n2.expression);
  t2.expression = l;
  const c = (0, s2.default)(n2.program);
  t2.program = c;
  var u = Object.assign(i2.bind(void 0), { smart: i2, statement: o2, statements: a2, expression: l, program: c, ast: i2.ast });
  t2.default = u;
}, (e2, t2, r2) => {
  var n2 = r2(22), s2 = r2(41), i2 = s2(n2("String.prototype.indexOf"));
  e2.exports = function(e3, t3) {
    var r3 = n2(e3, !!t3);
    return "function" == typeof r3 && i2(e3, ".prototype.") > -1 ? s2(r3) : r3;
  };
}, (e2, t2) => {
  var r2;
  Object.defineProperty(t2, "__esModule", { value: true }), t2.beginHiddenCallStack = function(e3) {
    return s2 ? Object.defineProperty(function() {
      return c(), e3(...arguments);
    }, "name", { value: o2 }) : e3;
  }, t2.endHiddenCallStack = function(e3) {
    return s2 ? Object.defineProperty(function() {
      return e3(...arguments);
    }, "name", { value: i2 }) : e3;
  }, t2.expectedError = function(e3) {
    if (s2) return a2.add(e3), e3;
  }, t2.injectVirtualStackFrame = function(e3, t3) {
    if (!s2) return;
    let r3 = l.get(e3);
    return r3 || l.set(e3, r3 = []), r3.push(/* @__PURE__ */ function(e4) {
      return /* @__PURE__ */ Object.create({ isNative: () => false, isConstructor: () => false, isToplevel: () => true, getFileName: () => e4, getLineNumber: () => {
      }, getColumnNumber: () => {
      }, getFunctionName: () => {
      }, getMethodName: () => {
      }, getTypeName: () => {
      }, toString: () => e4 });
    }(t3)), e3;
  };
  const n2 = Function.call.bind(Error.prototype.toString), s2 = !!Error.captureStackTrace && true === (null == (r2 = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) ? void 0 : r2.writable), i2 = "startHiding - secret - don't use this - v1", o2 = "stopHiding - secret - don't use this - v1", a2 = /* @__PURE__ */ new WeakSet(), l = /* @__PURE__ */ new WeakMap();
  function c() {
    c = () => {
    };
    const { prepareStackTrace: e3 = u } = Error;
    Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, 50)), Error.prepareStackTrace = function(t3, r3) {
      let n3 = [], s3 = a2.has(t3) ? "hiding" : "unknown";
      for (let e4 = 0; e4 < r3.length; e4++) {
        const a3 = r3[e4].getFunctionName();
        if (a3 === i2) s3 = "hiding";
        else if (a3 === o2) {
          if ("hiding" === s3) s3 = "showing", l.has(t3) && n3.unshift(...l.get(t3));
          else if ("unknown" === s3) {
            n3 = r3;
            break;
          }
        } else "hiding" !== s3 && n3.push(r3[e4]);
      }
      return e3(t3, n3);
    };
  }
  function u(e3, t3) {
    return 0 === t3.length ? n2(e3) : `${n2(e3)}
    at ${t3.join("\n    at ")}`;
  }
}, (e2, t2, r2) => {
  let n2, s2, i2 = r2(24);
  class o2 extends i2 {
    constructor(e3) {
      super(e3), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(e3, t3, r3) {
      let n3 = super.normalize(e3);
      if (t3) {
        if ("prepend" === r3) this.nodes.length > 1 ? t3.raws.before = this.nodes[1].raws.before : delete t3.raws.before;
        else if (this.first !== t3) for (let e4 of n3) e4.raws.before = t3.raws.before;
      }
      return n3;
    }
    removeChild(e3, t3) {
      let r3 = this.index(e3);
      return !t3 && 0 === r3 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r3].raws.before), super.removeChild(e3);
    }
    toResult() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return new n2(new s2(), this, e3).stringify();
    }
  }
  o2.registerLazyResult = (e3) => {
    n2 = e3;
  }, o2.registerProcessor = (e3) => {
    s2 = e3;
  }, e2.exports = o2, o2.default = o2, i2.registerRoot(o2);
}, (e2, t2, r2) => {
  var n2 = r2(71), s2 = r2(22), i2 = r2(234), o2 = s2("%TypeError%"), a2 = s2("%Function.prototype.apply%"), l = s2("%Function.prototype.call%"), c = s2("%Reflect.apply%", true) || n2.call(l, a2), u = s2("%Object.defineProperty%", true), p = s2("%Math.max%");
  if (u) try {
    u({}, "a", { value: 1 });
  } catch (e3) {
    u = null;
  }
  e2.exports = function(e3) {
    if ("function" != typeof e3) throw new o2("a function is required");
    var t3 = c(n2, l, arguments);
    return i2(t3, 1 + p(0, e3.length - (arguments.length - 1)), true);
  };
  var d = function() {
    return c(n2, a2, arguments);
  };
  u ? u(e2.exports, "apply", { value: d }) : e2.exports.apply = d;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    return !!t3 && ((0, s2.default)(t3.type, e3) ? void 0 === r3 || (0, n2.default)(t3, r3) : !r3 && "Placeholder" === t3.type && e3 in o2.FLIPPED_ALIAS_KEYS && (0, i2.default)(t3.expectedNode, e3));
  };
  var n2 = r2(96), s2 = r2(98), i2 = r2(168), o2 = r2(9);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return "string" == typeof e3 && ((!(!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) || !(0, n2.isKeyword)(e3) && !(0, n2.isStrictReservedWord)(e3, true)) && (0, n2.isIdentifierName)(e3));
  };
  var n2 = r2(59);
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(15), i2 = r2(102), o2 = r2(204), a2 = r2(11), l = n2.RegExp, c = l.prototype;
  s2 && a2(function() {
    var e3 = true;
    try {
      l(".", "d");
    } catch (t4) {
      e3 = false;
    }
    var t3 = {}, r3 = "", n3 = e3 ? "dgimsy" : "gimsy", s3 = function(e4, n4) {
      Object.defineProperty(t3, e4, { get: function() {
        return r3 += n4, true;
      } });
    }, i3 = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
    for (var o3 in e3 && (i3.hasIndices = "d"), i3) s3(o3, i3[o3]);
    return Object.getOwnPropertyDescriptor(c, "flags").get.call(t3) !== n3 || r3 !== n3;
  }) && i2(c, "flags", { configurable: true, get: o2 });
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(116), i2 = r2(29), o2 = r2(67), a2 = r2(113), l = r2(112), c = n2.Symbol, u = s2("wks"), p = l ? c.for || c : c && c.withoutSetter || o2;
  e2.exports = function(e3) {
    return i2(u, e3) || (u[e3] = a2 && i2(c, e3) ? c[e3] : p("Symbol." + e3)), u[e3];
  };
}, (e2, t2, r2) => {
  var n2 = r2(123), s2 = "function" == typeof Symbol && "symbol" == typeof Symbol("foo"), i2 = Object.prototype.toString, o2 = Array.prototype.concat, a2 = r2(121), l = r2(72)(), c = function(e3, t3, r3, n3) {
    if (t3 in e3) {
      if (true === n3) {
        if (e3[t3] === r3) return;
      } else if ("function" != typeof (s3 = n3) || "[object Function]" !== i2.call(s3) || !n3()) return;
    }
    var s3;
    l ? a2(e3, t3, r3, true) : a2(e3, t3, r3);
  }, u = function(e3, t3) {
    var r3 = arguments.length > 2 ? arguments[2] : {}, i3 = n2(t3);
    s2 && (i3 = o2.call(i3, Object.getOwnPropertySymbols(t3)));
    for (var a3 = 0; a3 < i3.length; a3 += 1) c(e3, i3[a3], t3[i3[a3]], r3[i3[a3]]);
  };
  u.supportsDescriptors = !!l, e2.exports = u;
}, (e2) => {
  const t2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  e2.exports = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: t2, RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"], SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
}, (e2, t2, r2) => {
  var n2 = r2(17);
  const s2 = ("object" == typeof n2 && n2.env, () => {
  });
  e2.exports = s2;
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => n2(e3, t3, r3) > 0;
}, (e2, t2, r2) => {
  const n2 = Symbol("SemVer ANY");
  class s2 {
    static get ANY() {
      return n2;
    }
    constructor(e3, t3) {
      if (t3 = i2(t3), e3 instanceof s2) {
        if (e3.loose === !!t3.loose) return e3;
        e3 = e3.value;
      }
      e3 = e3.trim().split(/\s+/).join(" "), c("comparator", e3, t3), this.options = t3, this.loose = !!t3.loose, this.parse(e3), this.semver === n2 ? this.value = "" : this.value = this.operator + this.semver.version, c("comp", this);
    }
    parse(e3) {
      const t3 = this.options.loose ? o2[a2.COMPARATORLOOSE] : o2[a2.COMPARATOR], r3 = e3.match(t3);
      if (!r3) throw new TypeError(`Invalid comparator: ${e3}`);
      this.operator = void 0 !== r3[1] ? r3[1] : "", "=" === this.operator && (this.operator = ""), r3[2] ? this.semver = new u(r3[2], this.options.loose) : this.semver = n2;
    }
    toString() {
      return this.value;
    }
    test(e3) {
      if (c("Comparator.test", e3, this.options.loose), this.semver === n2 || e3 === n2) return true;
      if ("string" == typeof e3) try {
        e3 = new u(e3, this.options);
      } catch (e4) {
        return false;
      }
      return l(e3, this.operator, this.semver, this.options);
    }
    intersects(e3, t3) {
      if (!(e3 instanceof s2)) throw new TypeError("a Comparator is required");
      return "" === this.operator ? "" === this.value || new p(e3.value, t3).test(this.value) : "" === e3.operator ? "" === e3.value || new p(this.value, t3).test(e3.semver) : !((t3 = i2(t3)).includePrerelease && ("<0.0.0-0" === this.value || "<0.0.0-0" === e3.value) || !t3.includePrerelease && (this.value.startsWith("<0.0.0") || e3.value.startsWith("<0.0.0")) || (!this.operator.startsWith(">") || !e3.operator.startsWith(">")) && (!this.operator.startsWith("<") || !e3.operator.startsWith("<")) && (this.semver.version !== e3.semver.version || !this.operator.includes("=") || !e3.operator.includes("=")) && !(l(this.semver, "<", e3.semver, t3) && this.operator.startsWith(">") && e3.operator.startsWith("<")) && !(l(this.semver, ">", e3.semver, t3) && this.operator.startsWith("<") && e3.operator.startsWith(">")));
    }
  }
  e2.exports = s2;
  const i2 = r2(75), { safeRe: o2, t: a2 } = r2(34), l = r2(131), c = r2(48), u = r2(3), p = r2(8);
}, (e2, t2, r2) => {
  const n2 = r2(8);
  e2.exports = (e3, t3, r3) => {
    try {
      t3 = new n2(t3, r3);
    } catch (e4) {
      return false;
    }
    return t3.test(e3);
  };
}, (e2, t2, r2) => {
  let n2 = r2(53);
  class s2 extends n2 {
    constructor(e3) {
      e3 && void 0 !== e3.value && "string" != typeof e3.value && (e3 = { ...e3, value: String(e3.value) }), super(e3), this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || "$" === this.prop[0];
    }
  }
  e2.exports = s2, s2.default = s2;
}, (e2, t2, r2) => {
  let { isClean: n2, my: s2 } = r2(145), i2 = r2(87), o2 = r2(146), a2 = r2(54);
  function l(e3, t3) {
    let r3 = new e3.constructor();
    for (let n3 in e3) {
      if (!Object.prototype.hasOwnProperty.call(e3, n3)) continue;
      if ("proxyCache" === n3) continue;
      let s3 = e3[n3], i3 = typeof s3;
      "parent" === n3 && "object" === i3 ? t3 && (r3[n3] = t3) : "source" === n3 ? r3[n3] = s3 : Array.isArray(s3) ? r3[n3] = s3.map((e4) => l(e4, r3)) : ("object" === i3 && null !== s3 && (s3 = l(s3)), r3[n3] = s3);
    }
    return r3;
  }
  class c {
    constructor() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.raws = {}, this[n2] = false, this[s2] = true;
      for (let t3 in e3) if ("nodes" === t3) {
        this.nodes = [];
        for (let r3 of e3[t3]) "function" == typeof r3.clone ? this.append(r3.clone()) : this.append(r3);
      } else this[t3] = e3[t3];
    }
    addToError(e3) {
      if (e3.postcssNode = this, e3.stack && this.source && /\n\s{4}at /.test(e3.stack)) {
        let t3 = this.source;
        e3.stack = e3.stack.replace(/\n\s{4}at /, `$&${t3.input.from}:${t3.start.line}:${t3.start.column}$&`);
      }
      return e3;
    }
    after(e3) {
      return this.parent.insertAfter(this, e3), this;
    }
    assign() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      for (let t3 in e3) this[t3] = e3[t3];
      return this;
    }
    before(e3) {
      return this.parent.insertBefore(this, e3), this;
    }
    cleanRaws(e3) {
      delete this.raws.before, delete this.raws.after, e3 || delete this.raws.between;
    }
    clone() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = l(this);
      for (let r3 in e3) t3[r3] = e3[r3];
      return t3;
    }
    cloneAfter() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = this.clone(e3);
      return this.parent.insertAfter(this, t3), t3;
    }
    cloneBefore() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = this.clone(e3);
      return this.parent.insertBefore(this, t3), t3;
    }
    error(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      if (this.source) {
        let { end: r3, start: n3 } = this.rangeBy(t3);
        return this.source.input.error(e3, { column: n3.column, line: n3.line }, { column: r3.column, line: r3.line }, t3);
      }
      return new i2(e3);
    }
    getProxyProcessor() {
      return { get: (e3, t3) => "proxyOf" === t3 ? e3 : "root" === t3 ? () => e3.root().toProxy() : e3[t3], set: (e3, t3, r3) => (e3[t3] === r3 || (e3[t3] = r3, "prop" !== t3 && "value" !== t3 && "name" !== t3 && "params" !== t3 && "important" !== t3 && "text" !== t3 || e3.markDirty()), true) };
    }
    markDirty() {
      if (this[n2]) {
        this[n2] = false;
        let e3 = this;
        for (; e3 = e3.parent; ) e3[n2] = false;
      }
    }
    next() {
      if (!this.parent) return;
      let e3 = this.parent.index(this);
      return this.parent.nodes[e3 + 1];
    }
    positionBy(e3, t3) {
      let r3 = this.source.start;
      if (e3.index) r3 = this.positionInside(e3.index, t3);
      else if (e3.word) {
        let n3 = (t3 = this.toString()).indexOf(e3.word);
        -1 !== n3 && (r3 = this.positionInside(n3, t3));
      }
      return r3;
    }
    positionInside(e3, t3) {
      let r3 = t3 || this.toString(), n3 = this.source.start.column, s3 = this.source.start.line;
      for (let t4 = 0; t4 < e3; t4++) "\n" === r3[t4] ? (n3 = 1, s3 += 1) : n3 += 1;
      return { column: n3, line: s3 };
    }
    prev() {
      if (!this.parent) return;
      let e3 = this.parent.index(this);
      return this.parent.nodes[e3 - 1];
    }
    rangeBy(e3) {
      let t3 = { column: this.source.start.column, line: this.source.start.line }, r3 = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: t3.column + 1, line: t3.line };
      if (e3.word) {
        let n3 = this.toString(), s3 = n3.indexOf(e3.word);
        -1 !== s3 && (t3 = this.positionInside(s3, n3), r3 = this.positionInside(s3 + e3.word.length, n3));
      } else e3.start ? t3 = { column: e3.start.column, line: e3.start.line } : e3.index && (t3 = this.positionInside(e3.index)), e3.end ? r3 = { column: e3.end.column, line: e3.end.line } : e3.endIndex ? r3 = this.positionInside(e3.endIndex) : e3.index && (r3 = this.positionInside(e3.index + 1));
      return (r3.line < t3.line || r3.line === t3.line && r3.column <= t3.column) && (r3 = { column: t3.column + 1, line: t3.line }), { end: r3, start: t3 };
    }
    raw(e3, t3) {
      return new o2().raw(this, e3, t3);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith() {
      if (this.parent) {
        let n3 = this, s3 = false;
        for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
        for (let e4 of t3) e4 === this ? s3 = true : s3 ? (this.parent.insertAfter(n3, e4), n3 = e4) : this.parent.insertBefore(n3, e4);
        s3 || this.remove();
      }
      return this;
    }
    root() {
      let e3 = this;
      for (; e3.parent && "document" !== e3.parent.type; ) e3 = e3.parent;
      return e3;
    }
    toJSON(e3, t3) {
      let r3 = {}, n3 = null == t3;
      t3 = t3 || /* @__PURE__ */ new Map();
      let s3 = 0;
      for (let e4 in this) {
        if (!Object.prototype.hasOwnProperty.call(this, e4)) continue;
        if ("parent" === e4 || "proxyCache" === e4) continue;
        let n4 = this[e4];
        if (Array.isArray(n4)) r3[e4] = n4.map((e5) => "object" == typeof e5 && e5.toJSON ? e5.toJSON(null, t3) : e5);
        else if ("object" == typeof n4 && n4.toJSON) r3[e4] = n4.toJSON(null, t3);
        else if ("source" === e4) {
          let i3 = t3.get(n4.input);
          null == i3 && (i3 = s3, t3.set(n4.input, s3), s3++), r3[e4] = { end: n4.end, inputId: i3, start: n4.start };
        } else r3[e4] = n4;
      }
      return n3 && (r3.inputs = [...t3.keys()].map((e4) => e4.toJSON())), r3;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a2;
      e3.stringify && (e3 = e3.stringify);
      let t3 = "";
      return e3(this, (e4) => {
        t3 += e4;
      }), t3;
    }
    warn(e3, t3, r3) {
      let n3 = { node: this };
      for (let e4 in r3) n3[e4] = r3[e4];
      return e3.warn(t3, n3);
    }
    get proxyOf() {
      return this;
    }
  }
  e2.exports = c, c.default = c;
}, (e2, t2, r2) => {
  let n2 = r2(146);
  function s2(e3, t3) {
    new n2(t3).stringify(e3);
  }
  e2.exports = s2, s2.default = s2;
}, (e2, t2, r2) => {
  let { SourceMapConsumer: n2, SourceMapGenerator: s2 } = r2(149), { fileURLToPath: i2, pathToFileURL: o2 } = r2(318), { isAbsolute: a2, resolve: l } = r2(150), { nanoid: c } = r2(319), u = r2(317), p = r2(87), d = r2(151), f = Symbol("fromOffsetCache"), h = Boolean(n2 && s2), m = Boolean(l && a2);
  class y {
    constructor(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      if (null == e3 || "object" == typeof e3 && !e3.toString) throw new Error(`PostCSS received ${e3} instead of CSS string`);
      if (this.css = e3.toString(), "\uFEFF" === this.css[0] || "￾" === this.css[0] ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, t3.from && (!m || /^\w+:\/\//.test(t3.from) || a2(t3.from) ? this.file = t3.from : this.file = l(t3.from)), m && h) {
        let e4 = new d(this.css, t3);
        if (e4.text) {
          this.map = e4;
          let t4 = e4.consumer().file;
          !this.file && t4 && (this.file = this.mapResolve(t4));
        }
      }
      this.file || (this.id = "<input css " + c(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(e3, t3, r3) {
      let n3, s3, i3, a3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
      if (t3 && "object" == typeof t3) {
        let e4 = t3, n4 = r3;
        if ("number" == typeof e4.offset) {
          let n5 = this.fromOffset(e4.offset);
          t3 = n5.line, r3 = n5.col;
        } else t3 = e4.line, r3 = e4.column;
        if ("number" == typeof n4.offset) {
          let e5 = this.fromOffset(n4.offset);
          s3 = e5.line, i3 = e5.col;
        } else s3 = n4.line, i3 = n4.column;
      } else if (!r3) {
        let e4 = this.fromOffset(t3);
        t3 = e4.line, r3 = e4.col;
      }
      let l2 = this.origin(t3, r3, s3, i3);
      return n3 = l2 ? new p(e3, void 0 === l2.endLine ? l2.line : { column: l2.column, line: l2.line }, void 0 === l2.endLine ? l2.column : { column: l2.endColumn, line: l2.endLine }, l2.source, l2.file, a3.plugin) : new p(e3, void 0 === s3 ? t3 : { column: r3, line: t3 }, void 0 === s3 ? r3 : { column: i3, line: s3 }, this.css, this.file, a3.plugin), n3.input = { column: r3, endColumn: i3, endLine: s3, line: t3, source: this.css }, this.file && (o2 && (n3.input.url = o2(this.file).toString()), n3.input.file = this.file), n3;
    }
    fromOffset(e3) {
      let t3, r3;
      if (this[f]) r3 = this[f];
      else {
        let e4 = this.css.split("\n");
        r3 = new Array(e4.length);
        let t4 = 0;
        for (let n4 = 0, s3 = e4.length; n4 < s3; n4++) r3[n4] = t4, t4 += e4[n4].length + 1;
        this[f] = r3;
      }
      t3 = r3[r3.length - 1];
      let n3 = 0;
      if (e3 >= t3) n3 = r3.length - 1;
      else {
        let t4, s3 = r3.length - 2;
        for (; n3 < s3; ) if (t4 = n3 + (s3 - n3 >> 1), e3 < r3[t4]) s3 = t4 - 1;
        else {
          if (!(e3 >= r3[t4 + 1])) {
            n3 = t4;
            break;
          }
          n3 = t4 + 1;
        }
      }
      return { col: e3 - r3[n3] + 1, line: n3 + 1 };
    }
    mapResolve(e3) {
      return /^\w+:\/\//.test(e3) ? e3 : l(this.map.consumer().sourceRoot || this.map.root || ".", e3);
    }
    origin(e3, t3, r3, n3) {
      if (!this.map) return false;
      let s3, l2, c2 = this.map.consumer(), u2 = c2.originalPositionFor({ column: t3, line: e3 });
      if (!u2.source) return false;
      "number" == typeof r3 && (s3 = c2.originalPositionFor({ column: n3, line: r3 })), l2 = a2(u2.source) ? o2(u2.source) : new URL(u2.source, this.map.consumer().sourceRoot || o2(this.map.mapFile));
      let p2 = { column: u2.column, endColumn: s3 && s3.column, endLine: s3 && s3.line, line: u2.line, url: l2.toString() };
      if ("file:" === l2.protocol) {
        if (!i2) throw new Error("file: protocol is not available in this PostCSS build");
        p2.file = i2(l2);
      }
      let d2 = c2.sourceContentFor(u2.source);
      return d2 && (p2.source = d2), p2;
    }
    toJSON() {
      let e3 = {};
      for (let t3 of ["hasBOM", "css", "file", "id"]) null != this[t3] && (e3[t3] = this[t3]);
      return this.map && (e3.map = { ...this.map }, e3.map.consumerCache && (e3.map.consumerCache = void 0)), e3;
    }
    get from() {
      return this.file || this.id;
    }
  }
  e2.exports = y, y.default = y, u && u.registerInput && u.registerInput(y);
}, (e2, t2, r2) => {
  let n2 = r2(53);
  class s2 extends n2 {
    constructor(e3) {
      super(e3), this.type = "comment";
    }
  }
  e2.exports = s2, s2.default = s2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.explode = d, t2.isExplodedVisitor = p, t2.merge = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], r3 = arguments.length > 2 ? arguments[2] : void 0;
    const n3 = {};
    for (let s3 = 0; s3 < e3.length; s3++) {
      const i3 = d(e3[s3]), o3 = t3[s3];
      let a3 = i3;
      (o3 || r3) && (a3 = m(a3, o3, r3)), v(n3, a3);
      for (const e4 of Object.keys(i3)) {
        if (b(e4)) continue;
        let t4 = i3[e4];
        (o3 || r3) && (t4 = m(t4, o3, r3)), v(n3[e4] || (n3[e4] = {}), t4);
      }
    }
    return n3;
  }, t2.verify = f;
  var n2 = r2(162), s2 = r2(163), i2 = r2(0);
  const { DEPRECATED_KEYS: o2, DEPRECATED_ALIASES: a2, FLIPPED_ALIAS_KEYS: l, TYPES: c, __internal__deprecationWarning: u } = i2;
  function p(e3) {
    return null == e3 ? void 0 : e3._exploded;
  }
  function d(e3) {
    if (p(e3)) return e3;
    e3._exploded = true;
    for (const t3 of Object.keys(e3)) {
      if (b(t3)) continue;
      const r3 = t3.split("|");
      if (1 === r3.length) continue;
      const n3 = e3[t3];
      delete e3[t3];
      for (const t4 of r3) e3[t4] = n3;
    }
    f(e3), delete e3.__esModule, function(e4) {
      for (const t3 of Object.keys(e4)) {
        if (b(t3)) continue;
        const r3 = e4[t3];
        "function" == typeof r3 && (e4[t3] = { enter: r3 });
      }
    }(e3), y(e3);
    for (const t3 of Object.keys(e3)) {
      if (b(t3)) continue;
      if (!(t3 in n2)) continue;
      const r3 = e3[t3];
      for (const e4 of Object.keys(r3)) r3[e4] = g(t3, r3[e4]);
      delete e3[t3];
      const s3 = n2[t3];
      if (null !== s3) for (const t4 of s3) e3[t4] ? v(e3[t4], r3) : e3[t4] = r3;
      else v(e3, r3);
    }
    for (const t3 of Object.keys(e3)) {
      if (b(t3)) continue;
      let r3 = l[t3];
      if (t3 in o2) {
        const e4 = o2[t3];
        u(t3, e4, "Visitor "), r3 = [e4];
      } else if (t3 in a2) {
        const e4 = a2[t3];
        u(t3, e4, "Visitor "), r3 = l[e4];
      }
      if (!r3) continue;
      const n3 = e3[t3];
      delete e3[t3];
      for (const t4 of r3) {
        const r4 = e3[t4];
        r4 ? v(r4, n3) : e3[t4] = Object.assign({}, n3);
      }
    }
    for (const t3 of Object.keys(e3)) b(t3) || y(e3[t3]);
    return e3;
  }
  function f(e3) {
    if (!e3._verified) {
      if ("function" == typeof e3) throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
      for (const t3 of Object.keys(e3)) {
        if ("enter" !== t3 && "exit" !== t3 || h(t3, e3[t3]), b(t3)) continue;
        if (c.indexOf(t3) < 0) throw new Error(`You gave us a visitor for the node type ${t3} but it's not a valid type`);
        const r3 = e3[t3];
        if ("object" == typeof r3) for (const e4 of Object.keys(r3)) {
          if ("enter" !== e4 && "exit" !== e4) throw new Error(`You passed \`traverse()\` a visitor object with the property ${t3} that has the invalid property ${e4}`);
          h(`${t3}.${e4}`, r3[e4]);
        }
      }
      e3._verified = true;
    }
  }
  function h(e3, t3) {
    const r3 = [].concat(t3);
    for (const t4 of r3) if ("function" != typeof t4) throw new TypeError(`Non-function found defined in ${e3} with type ${typeof t4}`);
  }
  function m(e3, t3, r3) {
    const n3 = {};
    for (const s3 of ["enter", "exit"]) {
      let i3 = e3[s3];
      Array.isArray(i3) && (i3 = i3.map(function(e4) {
        let n4 = e4;
        return t3 && (n4 = function(r4) {
          e4.call(t3, r4, t3);
        }), r3 && (n4 = r3(null == t3 ? void 0 : t3.key, s3, n4)), n4 !== e4 && (n4.toString = () => e4.toString()), n4;
      }), n3[s3] = i3);
    }
    return n3;
  }
  function y(e3) {
    e3.enter && !Array.isArray(e3.enter) && (e3.enter = [e3.enter]), e3.exit && !Array.isArray(e3.exit) && (e3.exit = [e3.exit]);
  }
  function g(e3, t3) {
    const r3 = s2[`is${e3}`], n3 = function(e4) {
      if (r3.call(e4)) return t3.apply(this, arguments);
    };
    return n3.toString = () => t3.toString(), n3;
  }
  function b(e3) {
    return "_" === e3[0] || "enter" === e3 || "exit" === e3 || "shouldSkip" === e3 || "denylist" === e3 || "noScope" === e3 || "skipKeys" === e3 || "blacklist" === e3;
  }
  function v(e3, t3) {
    for (const r3 of ["enter", "exit"]) t3[r3] && (e3[r3] = [].concat(e3[r3] || [], t3[r3]));
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if (r2.has(e3)) return;
    r2.add(e3);
    const { internal: n2, trace: s2 } = function(e4, t4) {
      const { stackTraceLimit: r3, prepareStackTrace: n3 } = Error;
      let s3;
      if (Error.stackTraceLimit = 4, Error.prepareStackTrace = function(e5, t5) {
        s3 = t5;
      }, new Error().stack, Error.stackTraceLimit = r3, Error.prepareStackTrace = n3, !s3) return { internal: false, trace: "" };
      const i2 = s3.slice(2, 4);
      return { internal: /[\\/]@babel[\\/]/.test(i2[1].getFileName()), trace: i2.map((e5) => `    at ${e5}`).join("\n") };
    }();
  };
  const r2 = /* @__PURE__ */ new Set();
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "isIdentifierChar", { enumerable: true, get: function() {
    return n2.isIdentifierChar;
  } }), Object.defineProperty(t2, "isIdentifierName", { enumerable: true, get: function() {
    return n2.isIdentifierName;
  } }), Object.defineProperty(t2, "isIdentifierStart", { enumerable: true, get: function() {
    return n2.isIdentifierStart;
  } }), Object.defineProperty(t2, "isKeyword", { enumerable: true, get: function() {
    return s2.isKeyword;
  } }), Object.defineProperty(t2, "isReservedWord", { enumerable: true, get: function() {
    return s2.isReservedWord;
  } }), Object.defineProperty(t2, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
    return s2.isStrictBindOnlyReservedWord;
  } }), Object.defineProperty(t2, "isStrictBindReservedWord", { enumerable: true, get: function() {
    return s2.isStrictBindReservedWord;
  } }), Object.defineProperty(t2, "isStrictReservedWord", { enumerable: true, get: function() {
    return s2.isStrictReservedWord;
  } });
  var n2 = r2(353), s2 = r2(354);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = s2;
  var n2 = r2(2);
  function s2(e3, t3, r3, i2) {
    const o2 = [].concat(e3), a2 = /* @__PURE__ */ Object.create(null);
    for (; o2.length; ) {
      const e4 = o2.shift();
      if (!e4) continue;
      if (i2 && ((0, n2.isAssignmentExpression)(e4) || (0, n2.isUnaryExpression)(e4))) continue;
      const l = s2.keys[e4.type];
      if ((0, n2.isIdentifier)(e4)) t3 ? (a2[e4.name] = a2[e4.name] || []).push(e4) : a2[e4.name] = e4;
      else if (!(0, n2.isExportDeclaration)(e4) || (0, n2.isExportAllDeclaration)(e4)) {
        if (r3) {
          if ((0, n2.isFunctionDeclaration)(e4)) {
            o2.push(e4.id);
            continue;
          }
          if ((0, n2.isFunctionExpression)(e4)) continue;
        }
        if (l) for (let t4 = 0; t4 < l.length; t4++) {
          const r4 = e4[l[t4]];
          r4 && (Array.isArray(r4) ? o2.push(...r4) : o2.push(r4));
        }
      } else (0, n2.isDeclaration)(e4.declaration) && o2.push(e4.declaration);
    }
    return a2;
  }
  s2.keys = { DeclareClass: ["id"], DeclareFunction: ["id"], DeclareModule: ["id"], DeclareVariable: ["id"], DeclareInterface: ["id"], DeclareTypeAlias: ["id"], DeclareOpaqueType: ["id"], InterfaceDeclaration: ["id"], TypeAlias: ["id"], OpaqueType: ["id"], CatchClause: ["param"], LabeledStatement: ["label"], UnaryExpression: ["argument"], AssignmentExpression: ["left"], ImportSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportDefaultSpecifier: ["local"], ImportDeclaration: ["specifiers"], ExportSpecifier: ["exported"], ExportNamespaceSpecifier: ["exported"], ExportDefaultSpecifier: ["exported"], FunctionDeclaration: ["id", "params"], FunctionExpression: ["id", "params"], ArrowFunctionExpression: ["params"], ObjectMethod: ["params"], ClassMethod: ["params"], ClassPrivateMethod: ["params"], ForInStatement: ["left"], ForOfStatement: ["left"], ClassDeclaration: ["id"], ClassExpression: ["id"], RestElement: ["argument"], UpdateExpression: ["argument"], ObjectProperty: ["value"], AssignmentPattern: ["left"], ArrayPattern: ["elements"], ObjectPattern: ["properties"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id"] };
}, (e2) => {
  e2.exports = function() {
    return function() {
    };
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    if (!e3.isExportDeclaration() || e3.isExportAllDeclaration()) throw new Error("Only default and named export declarations can be split.");
    if (e3.isExportDefaultDeclaration()) {
      const t4 = e3.get("declaration"), r4 = t4.isFunctionDeclaration() || t4.isClassDeclaration(), n4 = t4.isFunctionExpression() || t4.isClassExpression(), u2 = t4.isScope() ? t4.scope.parent : t4.scope;
      let p = t4.node.id, d = false;
      p ? n4 && u2.hasBinding(p.name) && (d = true, p = u2.generateUidIdentifier(p.name)) : (d = true, p = u2.generateUidIdentifier("default"), (r4 || n4) && (t4.node.id = s2(p)));
      const f = r4 ? t4.node : l("var", [c(s2(p), t4.node)]), h = i2(null, [o2(s2(p), a2("default"))]);
      return e3.insertAfter(h), e3.replaceWith(f), d && u2.registerDeclaration(e3), e3;
    }
    if (e3.get("specifiers").length > 0) throw new Error("It doesn't make sense to split exported specifiers.");
    const t3 = e3.get("declaration"), r3 = t3.getOuterBindingIdentifiers(), n3 = Object.keys(r3).map((e4) => o2(a2(e4), a2(e4))), u = i2(null, n3);
    return e3.insertAfter(u), e3.replaceWith(t3.node), e3;
  };
  var n2 = r2(0);
  const { cloneNode: s2, exportNamedDeclaration: i2, exportSpecifier: o2, identifier: a2, variableDeclaration: l, variableDeclarator: c } = n2;
}, (e2, t2, r2) => {
  var n2 = r2(187), s2 = Object;
  e2.exports = function(e3) {
    return s2(n2(e3));
  };
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(106), i2 = "__core-js_shared__", o2 = n2[i2] || s2(i2, {});
  e2.exports = o2;
}, (e2, t2, r2) => {
  var n2 = r2(20), s2 = String, i2 = TypeError;
  e2.exports = function(e3) {
    if (n2(e3)) return e3;
    throw new i2(s2(e3) + " is not an object");
  };
}, (e2, t2, r2) => {
  var n2 = r2(104), s2 = Function.prototype.call;
  e2.exports = n2 ? s2.bind(s2) : function() {
    return s2.apply(s2, arguments);
  };
}, (e2, t2, r2) => {
  var n2 = r2(19), s2 = 0, i2 = Math.random(), o2 = n2(1 .toString);
  e2.exports = function(e3) {
    return "Symbol(" + (void 0 === e3 ? "" : e3) + ")_" + o2(++s2 + i2, 36);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "buildDynamicImport", { enumerable: true, get: function() {
    return u.buildDynamicImport;
  } }), t2.buildNamespaceInitStatements = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : c.wrapReference;
    var i3;
    const o3 = [], a3 = b(t3.name);
    for (const e4 of t3.importsNamespace) e4 !== t3.name && o3.push(s2.template.statement`var NAME = SOURCE;`({ NAME: e4, SOURCE: h(a3) }));
    const l2 = null != (i3 = n3(a3, t3.wrap)) ? i3 : a3;
    r3 && o3.push(...A(e3, t3, true, n3));
    for (const r4 of t3.reexportNamespace) o3.push((s2.types.isIdentifier(l2) ? s2.template.statement`EXPORTS.NAME = NAMESPACE;` : s2.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({ EXPORTS: e3.exportName, NAME: r4, NAMESPACE: h(l2) }));
    if (t3.reexportAll) {
      const n4 = function(e4, t4, r4) {
        return (r4 ? s2.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : s2.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({ NAMESPACE: t4, EXPORTS: e4.exportName, VERIFY_NAME_LIST: e4.exportNameListName ? s2.template`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({ EXPORTS_LIST: e4.exportNameListName }) : null });
      }(e3, h(l2), r3);
      n4.loc = t3.reexportAll.loc, o3.push(n4);
    }
    return o3;
  }, t2.ensureStatementsHoisted = function(e3) {
    e3.forEach((e4) => {
      e4._blockHoist = 3;
    });
  }, Object.defineProperty(t2, "getModuleName", { enumerable: true, get: function() {
    return p.default;
  } }), Object.defineProperty(t2, "hasExports", { enumerable: true, get: function() {
    return l.hasExports;
  } }), Object.defineProperty(t2, "isModule", { enumerable: true, get: function() {
    return i2.isModule;
  } }), Object.defineProperty(t2, "isSideEffectImport", { enumerable: true, get: function() {
    return l.isSideEffectImport;
  } }), t2.rewriteModuleStatementsAndPrepareHeader = function(e3, t3) {
    let { exportName: r3, strict: u2, allowTopLevelThis: p2, strictMode: d2, noInterop: f2, importInterop: h2 = f2 ? "none" : "babel", lazy: g2, getWrapperPayload: v2 = c.toGetWrapperPayload(null != g2 && g2), wrapReference: E2 = c.wrapReference, esNamespaceOnly: S2, filename: P2, constantReexports: C2 = arguments[1].loose, enumerableModuleMeta: I = arguments[1].loose, noIncompleteNsImportDetection: _ } = t3;
    (0, l.validateImportInteropOption)(h2), n2((0, i2.isModule)(e3), "Cannot process module statements in a script"), e3.node.sourceType = "script";
    const k = (0, l.default)(e3, r3, { importInterop: h2, initializeReexports: C2, getWrapperPayload: v2, esNamespaceOnly: S2, filename: P2 });
    if (p2 || (0, o2.default)(e3), (0, a2.default)(e3, k, E2), false !== d2) {
      const t4 = e3.node.directives.some((e4) => "use strict" === e4.value.value);
      t4 || e3.unshiftContainer("directives", m(y("use strict")));
    }
    const N = [];
    (0, l.hasExports)(k) && !u2 && N.push(function(e4) {
      return (arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? s2.template.statement`
        EXPORTS.__esModule = true;
      ` : s2.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({ EXPORTS: e4.exportName });
    }(k, I));
    const D = function(e4, t4) {
      const r4 = /* @__PURE__ */ Object.create(null);
      for (const e5 of t4.local.values()) for (const t5 of e5.names) r4[t5] = true;
      let n3 = false;
      for (const e5 of t4.source.values()) {
        for (const t5 of e5.reexports.keys()) r4[t5] = true;
        for (const t5 of e5.reexportNamespace) r4[t5] = true;
        n3 = n3 || !!e5.reexportAll;
      }
      if (!n3 || 0 === Object.keys(r4).length) return null;
      const s3 = e4.scope.generateUidIdentifier("exportNames");
      return delete r4.default, { name: s3.name, statement: T("var", [w(s3, x(r4))]) };
    }(e3, k);
    return D && (k.exportNameListName = D.name, N.push(D.statement)), N.push(...function(e4, t4, r4) {
      let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], s3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
      const i3 = [];
      for (const [e5, r5] of t4.local) if ("import" === r5.kind) ;
      else if ("hoisted" === r5.kind) i3.push([r5.names[0], O(t4, r5.names, b(e5))]);
      else if (!s3) for (const e6 of r5.names) i3.push([e6, null]);
      for (const e5 of t4.source.values()) {
        if (!n3) {
          const n4 = A(t4, e5, false, r4), s4 = [...e5.reexports.keys()];
          for (let e6 = 0; e6 < n4.length; e6++) i3.push([s4[e6], n4[e6]]);
        }
        if (!s3) for (const t5 of e5.reexportNamespace) i3.push([t5, null]);
      }
      i3.sort((e5, t5) => {
        let [r5] = e5, [n4] = t5;
        return r5 < n4 ? -1 : n4 < r5 ? 1 : 0;
      });
      const o3 = [];
      if (s3) for (const [, e5] of i3) o3.push(e5);
      else {
        const r5 = 100;
        for (let n4 = 0; n4 < i3.length; n4 += r5) {
          let s4 = [];
          for (let a3 = 0; a3 < r5 && n4 + a3 < i3.length; a3++) {
            const [r6, l2] = i3[n4 + a3];
            null !== l2 ? (s4.length > 0 && (o3.push(O(t4, s4, e4.scope.buildUndefinedNode())), s4 = []), o3.push(l2)) : s4.push(r6);
          }
          s4.length > 0 && o3.push(O(t4, s4, e4.scope.buildUndefinedNode()));
        }
      }
      return o3;
    }(e3, k, E2, C2, _)), { meta: k, headers: N };
  }, Object.defineProperty(t2, "rewriteThis", { enumerable: true, get: function() {
    return o2.default;
  } }), t2.wrapInterop = function(e3, t3, r3) {
    if ("none" === r3) return null;
    if ("node-namespace" === r3) return f(e3.hub.addHelper("interopRequireWildcard"), [t3, d(true)]);
    if ("node-default" === r3) return null;
    let n3;
    if ("default" === r3) n3 = "interopRequireDefault";
    else {
      if ("namespace" !== r3) throw new Error(`Unknown interop: ${r3}`);
      n3 = "interopRequireWildcard";
    }
    return f(e3.hub.addHelper(n3), [t3]);
  };
  var n2 = r2(25), s2 = r2(1), i2 = r2(93), o2 = r2(449), a2 = r2(450), l = r2(252), c = r2(451), u = r2(330), p = r2(452);
  const { booleanLiteral: d, callExpression: f, cloneNode: h, directive: m, directiveLiteral: y, expressionStatement: g, identifier: b, isIdentifier: v, memberExpression: E, stringLiteral: S, valueToNode: x, variableDeclaration: T, variableDeclarator: w } = s2.types;
  t2.getDynamicImportSource = r2(330).getDynamicImportSource;
  const P = { constant: s2.template.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`, constantComputed: s2.template.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`, spec: s2.template.statement`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() {
        return NAMESPACE_IMPORT;
      },
    });
    ` };
  function A(e3, t3, r3, n3) {
    var s3;
    let i3 = b(t3.name);
    i3 = null != (s3 = n3(i3, t3.wrap)) ? s3 : i3;
    const { stringSpecifiers: o3 } = e3;
    return Array.from(t3.reexports, (n4) => {
      let [s4, a3] = n4, l2 = h(i3);
      "default" === a3 && "node-default" === t3.interop || (l2 = o3.has(a3) ? E(l2, S(a3), true) : E(l2, b(a3)));
      const c2 = { EXPORTS: e3.exportName, EXPORT_NAME: s4, NAMESPACE_IMPORT: l2 };
      return r3 || v(l2) ? o3.has(s4) ? P.constantComputed(c2) : P.constant(c2) : P.spec(c2);
    });
  }
  const C = { computed: s2.template.expression`EXPORTS["NAME"] = VALUE`, default: s2.template.expression`EXPORTS.NAME = VALUE`, define: s2.template.expression`Object.defineProperty(EXPORTS, "NAME", { enumerable:true, value: void 0, writable: true })["NAME"] = VALUE` };
  function O(e3, t3, r3) {
    const { stringSpecifiers: n3, exportName: s3 } = e3;
    return g(t3.reduce((e4, t4) => {
      const r4 = { EXPORTS: s3, NAME: t4, VALUE: e4 };
      return "__proto__" === t4 ? C.define(r4) : n3.has(t4) ? C.computed(r4) : C.default(r4);
    }, r3));
  }
}, (e2, t2, r2) => {
  var n2 = r2(70);
  e2.exports = function() {
    return n2() && !!Symbol.toStringTag;
  };
}, (e2) => {
  e2.exports = function() {
    if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return false;
    if ("symbol" == typeof Symbol.iterator) return true;
    var e3 = {}, t2 = Symbol("test"), r2 = Object(t2);
    if ("string" == typeof t2) return false;
    if ("[object Symbol]" !== Object.prototype.toString.call(t2)) return false;
    if ("[object Symbol]" !== Object.prototype.toString.call(r2)) return false;
    for (t2 in e3[t2] = 42, e3) return false;
    if ("function" == typeof Object.keys && 0 !== Object.keys(e3).length) return false;
    if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e3).length) return false;
    var n2 = Object.getOwnPropertySymbols(e3);
    if (1 !== n2.length || n2[0] !== t2) return false;
    if (!Object.prototype.propertyIsEnumerable.call(e3, t2)) return false;
    if ("function" == typeof Object.getOwnPropertyDescriptor) {
      var s2 = Object.getOwnPropertyDescriptor(e3, t2);
      if (42 !== s2.value || true !== s2.enumerable) return false;
    }
    return true;
  };
}, (e2, t2, r2) => {
  var n2 = r2(232);
  e2.exports = Function.prototype.bind || n2;
}, (e2, t2, r2) => {
  var n2 = r2(22)("%Object.defineProperty%", true), s2 = function() {
    if (n2) try {
      return n2({}, "a", { value: 1 }), true;
    } catch (e3) {
      return false;
    }
    return false;
  };
  s2.hasArrayLengthDefineBug = function() {
    if (!s2()) return null;
    try {
      return 1 !== n2([], "length", { value: 1 }).length;
    } catch (e3) {
      return true;
    }
  }, e2.exports = s2;
}, (e2, t2, r2) => {
  var n2 = r2(22)("%Object.getOwnPropertyDescriptor%", true);
  if (n2) try {
    n2([], "length");
  } catch (e3) {
    n2 = null;
  }
  e2.exports = n2;
}, (e2, t2, r2) => {
  var n2 = r2(125);
  e2.exports = function() {
    return "function" == typeof Object.is ? Object.is : n2;
  };
}, (e2) => {
  const t2 = Object.freeze({ loose: true }), r2 = Object.freeze({});
  e2.exports = (e3) => e3 ? "object" != typeof e3 ? t2 : e3 : r2;
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = (e3, t3, r3) => {
    const s2 = new n2(e3, r3), i2 = new n2(t3, r3);
    return s2.compare(i2) || s2.compareBuild(i2);
  };
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => n2(e3, t3, r3) < 0;
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => n2(e3, t3, r3) >= 0;
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => n2(e3, t3, r3) <= 0;
}, (e2, t2, r2) => {
  const n2 = r2(3), s2 = r2(50), { ANY: i2 } = s2, o2 = r2(8), a2 = r2(51), l = r2(49), c = r2(77), u = r2(79), p = r2(78);
  e2.exports = (e3, t3, r3, d) => {
    let f, h, m, y, g;
    switch (e3 = new n2(e3, d), t3 = new o2(t3, d), r3) {
      case ">":
        f = l, h = u, m = c, y = ">", g = ">=";
        break;
      case "<":
        f = c, h = p, m = l, y = "<", g = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (a2(e3, t3, d)) return false;
    for (let r4 = 0; r4 < t3.set.length; ++r4) {
      const n3 = t3.set[r4];
      let o3 = null, a3 = null;
      if (n3.forEach((e4) => {
        e4.semver === i2 && (e4 = new s2(">=0.0.0")), o3 = o3 || e4, a3 = a3 || e4, f(e4.semver, o3.semver, d) ? o3 = e4 : m(e4.semver, a3.semver, d) && (a3 = e4);
      }), o3.operator === y || o3.operator === g) return false;
      if ((!a3.operator || a3.operator === y) && h(e3, a3.semver)) return false;
      if (a3.operator === g && m(e3, a3.semver)) return false;
    }
    return true;
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ROOT_CONFIG_FILENAMES = void 0, t2.findConfigUpwards = function(e3) {
    return null;
  }, t2.findPackageData = function* (e3) {
    return { filepath: e3, directories: [], pkg: null, isPackage: false };
  }, t2.findRelativeConfig = function* (e3, t3, r2) {
    return { config: null, ignore: null };
  }, t2.findRootConfig = function* (e3, t3, r2) {
    return null;
  }, t2.loadConfig = function* (e3, t3, r2, n2) {
    throw new Error(`Cannot load ${e3} relative to ${t3} in a browser`);
  }, t2.loadPlugin = function(e3, t3) {
    throw new Error(`Cannot load plugin ${e3} relative to ${t3} in a browser`);
  }, t2.loadPreset = function(e3, t3) {
    throw new Error(`Cannot load preset ${e3} relative to ${t3} in a browser`);
  }, t2.resolvePlugin = function(e3, t3) {
    return null;
  }, t2.resolvePreset = function(e3, t3) {
    return null;
  }, t2.resolveShowConfigPath = function* (e3) {
    return null;
  }, t2.ROOT_CONFIG_FILENAMES = [];
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.createConfigItem = function(e3, t3, r3) {
    if (void 0 !== r3) (0, a2.beginHiddenCallStack)(d.errback)(e3, t3, r3);
    else {
      if ("function" != typeof t3) return f(e3, t3);
      (0, a2.beginHiddenCallStack)(d.errback)(e3, void 0, r3);
    }
  }, t2.createConfigItemAsync = function() {
    return (0, a2.beginHiddenCallStack)(d.async)(...arguments);
  }, t2.createConfigItemSync = f, Object.defineProperty(t2, "default", { enumerable: true, get: function() {
    return s2.default;
  } }), t2.loadOptions = function(e3, t3) {
    if (void 0 !== t3) (0, a2.beginHiddenCallStack)(u.errback)(e3, t3);
    else {
      if ("function" != typeof e3) return p(e3);
      (0, a2.beginHiddenCallStack)(u.errback)(void 0, e3);
    }
  }, t2.loadOptionsAsync = function() {
    return (0, a2.beginHiddenCallStack)(u.async)(...arguments);
  }, t2.loadOptionsSync = p, t2.loadPartialConfig = function(e3, t3) {
    if (void 0 !== t3) (0, a2.beginHiddenCallStack)(l.errback)(e3, t3);
    else {
      if ("function" != typeof e3) return c(e3);
      (0, a2.beginHiddenCallStack)(l.errback)(void 0, e3);
    }
  }, t2.loadPartialConfigAsync = function() {
    return (0, a2.beginHiddenCallStack)(l.async)(...arguments);
  }, t2.loadPartialConfigSync = c;
  var s2 = r2(454), i2 = r2(294), o2 = r2(83), a2 = r2(39);
  const l = n2()(i2.loadPartialConfig);
  function c() {
    return (0, a2.beginHiddenCallStack)(l.sync)(...arguments);
  }
  const u = n2()(function* (e3) {
    var t3;
    const r3 = yield* (0, s2.default)(e3);
    return null != (t3 = null == r3 ? void 0 : r3.options) ? t3 : null;
  });
  function p() {
    return (0, a2.beginHiddenCallStack)(u.sync)(...arguments);
  }
  const d = n2()(o2.createConfigItem);
  function f() {
    return (0, a2.beginHiddenCallStack)(d.sync)(...arguments);
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(10);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.createConfigItem = function(e3) {
    let { dirname: t3 = ".", type: r3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return function* () {
      return i2(yield* (0, s2.createDescriptor)(e3, n2().resolve(t3), { type: r3, alias: "programmatic item" }));
    }();
  }, t2.createItemFromDescriptor = i2, t2.getItemDescriptor = function(e3) {
    if (null != e3 && e3[o2]) return e3._descriptor;
  };
  var s2 = r2(279);
  function i2(e3) {
    return new a2(e3);
  }
  const o2 = Symbol.for("@babel/core@7 - ConfigItem");
  class a2 {
    constructor(e3) {
      this._descriptor = void 0, this[o2] = true, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.file = void 0, this._descriptor = e3, Object.defineProperty(this, "_descriptor", { enumerable: false }), Object.defineProperty(this, o2, { enumerable: false }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name = this._descriptor.name, this.file = this._descriptor.file ? { request: this._descriptor.file.request, resolved: this._descriptor.file.resolved } : void 0, Object.freeze(this);
    }
  }
  Object.freeze(a2.prototype);
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.assertSimpleType = h, t2.makeStrongCache = c, t2.makeStrongCacheSync = function(e3) {
    return o2(c(e3));
  }, t2.makeWeakCache = l, t2.makeWeakCacheSync = function(e3) {
    return o2(l(e3));
  };
  var s2 = r2(133), i2 = r2(134);
  const o2 = (e3) => n2()(e3).sync;
  function* a2() {
    return true;
  }
  function l(e3) {
    return u(WeakMap, e3);
  }
  function c(e3) {
    return u(Map, e3);
  }
  function u(e3, t3) {
    const r3 = new e3(), n3 = new e3(), o3 = new e3();
    return function* (e4, a3) {
      const l2 = yield* (0, s2.isAsync)(), c2 = l2 ? n3 : r3, u2 = yield* function* (e5, t4, r4, n4, i3) {
        const o4 = yield* p(t4, n4, i3);
        if (o4.valid) return o4;
        if (e5) {
          const e6 = yield* p(r4, n4, i3);
          if (e6.valid) return { valid: true, value: yield* (0, s2.waitFor)(e6.value.promise) };
        }
        return { valid: false, value: null };
      }(l2, c2, o3, e4, a3);
      if (u2.valid) return u2.value;
      const h2 = new f(a3), y = t3(e4, h2);
      let g, b;
      return b = (0, i2.isIterableIterator)(y) ? yield* (0, s2.onFirstPause)(y, () => {
        g = function(e5, t4, r4) {
          const n4 = new m();
          return d(t4, e5, r4, n4), n4;
        }(h2, o3, e4);
      }) : y, d(c2, h2, e4, b), g && (o3.delete(e4), g.release(b)), b;
    };
  }
  function* p(e3, t3, r3) {
    const n3 = e3.get(t3);
    if (n3) {
      for (const { value: e4, valid: t4 } of n3) if (yield* t4(r3)) return { valid: true, value: e4 };
    }
    return { valid: false, value: null };
  }
  function d(e3, t3, r3, n3) {
    t3.configured() || t3.forever();
    let s3 = e3.get(r3);
    switch (t3.deactivate(), t3.mode()) {
      case "forever":
        s3 = [{ value: n3, valid: a2 }], e3.set(r3, s3);
        break;
      case "invalidate":
        s3 = [{ value: n3, valid: t3.validator() }], e3.set(r3, s3);
        break;
      case "valid":
        s3 ? s3.push({ value: n3, valid: t3.validator() }) : (s3 = [{ value: n3, valid: t3.validator() }], e3.set(r3, s3));
    }
  }
  class f {
    constructor(e3) {
      this._active = true, this._never = false, this._forever = false, this._invalidate = false, this._configured = false, this._pairs = [], this._data = void 0, this._data = e3;
    }
    simple() {
      return function(e3) {
        function t3(t4) {
          if ("boolean" != typeof t4) return e3.using(() => h(t4()));
          t4 ? e3.forever() : e3.never();
        }
        return t3.forever = () => e3.forever(), t3.never = () => e3.never(), t3.using = (t4) => e3.using(() => h(t4())), t3.invalidate = (t4) => e3.invalidate(() => h(t4())), t3;
      }(this);
    }
    mode() {
      return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
    }
    forever() {
      if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never) throw new Error("Caching has already been configured with .never()");
      this._forever = true, this._configured = true;
    }
    never() {
      if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
      if (this._forever) throw new Error("Caching has already been configured with .forever()");
      this._never = true, this._configured = true;
    }
    using(e3) {
      if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never || this._forever) throw new Error("Caching has already been configured with .never or .forever()");
      this._configured = true;
      const t3 = e3(this._data), r3 = (0, s2.maybeAsync)(e3, "You appear to be using an async cache handler, but Babel has been called synchronously");
      return (0, s2.isThenable)(t3) ? t3.then((e4) => (this._pairs.push([e4, r3]), e4)) : (this._pairs.push([t3, r3]), t3);
    }
    invalidate(e3) {
      return this._invalidate = true, this.using(e3);
    }
    validator() {
      const e3 = this._pairs;
      return function* (t3) {
        for (const [r3, n3] of e3) if (r3 !== (yield* n3(t3))) return false;
        return true;
      };
    }
    deactivate() {
      this._active = false;
    }
    configured() {
      return this._configured;
    }
  }
  function h(e3) {
    if ((0, s2.isThenable)(e3)) throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");
    if (null != e3 && "string" != typeof e3 && "boolean" != typeof e3 && "number" != typeof e3) throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
    return e3;
  }
  class m {
    constructor() {
      this.released = false, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((e3) => {
        this._resolve = e3;
      });
    }
    release(e3) {
      this.released = true, this._resolve(e3);
    }
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.assumptionsNames = void 0, t2.checkNoUnwrappedItemOptionPairs = function(e3, t3, r3, n3) {
    if (0 === t3) return;
    const s3 = e3[t3 - 1], i3 = e3[t3];
    s3.file && void 0 === s3.options && "object" == typeof i3.value && (n3.message += `
- Maybe you meant to use
"${r3}s": [
  ["${s3.file.request}", ${JSON.stringify(i3.value, void 0, 2)}]
]
To be a valid ${r3}, its name and options should be wrapped in a pair of brackets`);
  }, t2.validate = function(e3, t3, r3) {
    try {
      return p({ type: "root", source: e3 }, t3);
    } catch (e4) {
      const t4 = new i2.default(e4.message, r3);
      throw e4.code && (t4.code = e4.code), t4;
    }
  };
  var n2 = r2(470), s2 = r2(293), i2 = r2(140);
  const o2 = { cwd: s2.assertString, root: s2.assertString, rootMode: s2.assertRootMode, configFile: s2.assertConfigFileSearch, caller: s2.assertCallerMetadata, filename: s2.assertString, filenameRelative: s2.assertString, code: s2.assertBoolean, ast: s2.assertBoolean, cloneInputAst: s2.assertBoolean, envName: s2.assertString }, a2 = { babelrc: s2.assertBoolean, babelrcRoots: s2.assertBabelrcSearch }, l = { extends: s2.assertString, ignore: s2.assertIgnoreList, only: s2.assertIgnoreList, targets: s2.assertTargets, browserslistConfigFile: s2.assertConfigFileSearch, browserslistEnv: s2.assertString }, c = { inputSourceMap: s2.assertInputSourceMap, presets: s2.assertPluginList, plugins: s2.assertPluginList, passPerPreset: s2.assertBoolean, assumptions: s2.assertAssumptions, env: function(e3, t3) {
    if ("env" === e3.parent.type) throw new Error(`${(0, s2.msg)(e3)} is not allowed inside of another .env block`);
    const r3 = e3.parent, n3 = (0, s2.assertObject)(e3, t3);
    if (n3) for (const t4 of Object.keys(n3)) {
      const i3 = (0, s2.assertObject)((0, s2.access)(e3, t4), n3[t4]);
      i3 && p({ type: "env", name: t4, parent: r3 }, i3);
    }
    return n3;
  }, overrides: function(e3, t3) {
    if ("env" === e3.parent.type) throw new Error(`${(0, s2.msg)(e3)} is not allowed inside an .env block`);
    if ("overrides" === e3.parent.type) throw new Error(`${(0, s2.msg)(e3)} is not allowed inside an .overrides block`);
    const r3 = e3.parent, n3 = (0, s2.assertArray)(e3, t3);
    if (n3) for (const [t4, i3] of n3.entries()) {
      const n4 = (0, s2.access)(e3, t4), o3 = (0, s2.assertObject)(n4, i3);
      if (!o3) throw new Error(`${(0, s2.msg)(n4)} must be an object`);
      p({ type: "overrides", index: t4, parent: r3 }, o3);
    }
    return n3;
  }, test: s2.assertConfigApplicableTest, include: s2.assertConfigApplicableTest, exclude: s2.assertConfigApplicableTest, retainLines: s2.assertBoolean, comments: s2.assertBoolean, shouldPrintComment: s2.assertFunction, compact: s2.assertCompact, minified: s2.assertBoolean, auxiliaryCommentBefore: s2.assertString, auxiliaryCommentAfter: s2.assertString, sourceType: s2.assertSourceType, wrapPluginVisitorMethod: s2.assertFunction, highlightCode: s2.assertBoolean, sourceMaps: s2.assertSourceMaps, sourceMap: s2.assertSourceMaps, sourceFileName: s2.assertString, sourceRoot: s2.assertString, parserOpts: s2.assertObject, generatorOpts: s2.assertObject };
  function u(e3) {
    return "root" === e3.type ? e3.source : u(e3.parent);
  }
  function p(e3, t3) {
    const r3 = u(e3);
    return function(e4) {
      if (f(e4, "sourceMap") && f(e4, "sourceMaps")) throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
    }(t3), Object.keys(t3).forEach((n3) => {
      const i3 = { type: "option", name: n3, parent: e3 };
      if ("preset" === r3 && l[n3]) throw new Error(`${(0, s2.msg)(i3)} is not allowed in preset options`);
      if ("arguments" !== r3 && o2[n3]) throw new Error(`${(0, s2.msg)(i3)} is only allowed in root programmatic options`);
      if ("arguments" !== r3 && "configfile" !== r3 && a2[n3]) {
        if ("babelrcfile" === r3 || "extendsfile" === r3) throw new Error(`${(0, s2.msg)(i3)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`);
        throw new Error(`${(0, s2.msg)(i3)} is only allowed in root programmatic options, or babel.config.js/config file options`);
      }
      (c[n3] || l[n3] || a2[n3] || o2[n3] || d)(i3, t3[n3]);
    }), t3;
  }
  function d(e3) {
    const t3 = e3.name;
    if (n2.default[t3]) {
      const { message: r3, version: i3 = 5 } = n2.default[t3];
      throw new Error(`Using removed Babel ${i3} option: ${(0, s2.msg)(e3)} - ${r3}`);
    }
    {
      const t4 = new Error(`Unknown option: ${(0, s2.msg)(e3)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
      throw t4.code = "BABEL_UNKNOWN_OPTION", t4;
    }
  }
  function f(e3, t3) {
    return Object.prototype.hasOwnProperty.call(e3, t3);
  }
  Object.assign(c, { getModuleId: s2.assertFunction, moduleRoot: s2.assertString, moduleIds: s2.assertBoolean, moduleId: s2.assertString }), t2.assumptionsNames = /* @__PURE__ */ new Set(["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"]);
}, (e2) => {
  var t2 = String.prototype.replace, r2 = /%20/g, n2 = "RFC3986";
  e2.exports = { default: n2, formatters: { RFC1738: function(e3) {
    return t2.call(e3, r2, "+");
  }, RFC3986: function(e3) {
    return String(e3);
  } }, RFC1738: "RFC1738", RFC3986: n2 };
}, (e2, t2, r2) => {
  let n2 = r2(316), s2 = r2(317);
  class i2 extends Error {
    constructor(e3, t3, r3, n3, s3, o2) {
      super(e3), this.name = "CssSyntaxError", this.reason = e3, s3 && (this.file = s3), n3 && (this.source = n3), o2 && (this.plugin = o2), void 0 !== t3 && void 0 !== r3 && ("number" == typeof t3 ? (this.line = t3, this.column = r3) : (this.line = t3.line, this.column = t3.column, this.endLine = r3.line, this.endColumn = r3.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, i2);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", void 0 !== this.line && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(e3) {
      if (!this.source) return "";
      let t3 = this.source;
      null == e3 && (e3 = n2.isColorSupported), s2 && e3 && (t3 = s2(t3));
      let r3, i3, o2 = t3.split(/\r?\n/), a2 = Math.max(this.line - 3, 0), l = Math.min(this.line + 2, o2.length), c = String(l).length;
      if (e3) {
        let { bold: e4, gray: t4, red: s3 } = n2.createColors(true);
        r3 = (t5) => e4(s3(t5)), i3 = (e5) => t4(e5);
      } else r3 = i3 = (e4) => e4;
      return o2.slice(a2, l).map((e4, t4) => {
        let n3 = a2 + 1 + t4, s3 = " " + (" " + n3).slice(-c) + " | ";
        if (n3 === this.line) {
          let t5 = i3(s3.replace(/\d/g, " ")) + e4.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return r3(">") + i3(s3) + e4 + "\n " + t5 + r3("^");
        }
        return " " + i3(s3) + e4;
      }).join("\n");
    }
    toString() {
      let e3 = this.showSourceCode();
      return e3 && (e3 = "\n\n" + e3 + "\n"), this.name + ": " + this.message + e3;
    }
  }
  e2.exports = i2, i2.default = i2;
}, (e2, t2, r2) => {
  let n2, s2, i2 = r2(24);
  class o2 extends i2 {
    constructor(e3) {
      super({ type: "document", ...e3 }), this.nodes || (this.nodes = []);
    }
    toResult() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return new n2(new s2(), this, e3).stringify();
    }
  }
  o2.registerLazyResult = (e3) => {
    n2 = e3;
  }, o2.registerProcessor = (e3) => {
    s2 = e3;
  }, e2.exports = o2, o2.default = o2;
}, (e2, t2, r2) => {
  let n2 = r2(153);
  class s2 {
    constructor(e3, t3, r3) {
      this.processor = e3, this.messages = [], this.root = t3, this.opts = r3, this.css = void 0, this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      t3.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t3.plugin = this.lastPlugin.postcssPlugin);
      let r3 = new n2(e3, t3);
      return this.messages.push(r3), r3;
    }
    warnings() {
      return this.messages.filter((e3) => "warning" === e3.type);
    }
    get content() {
      return this.css;
    }
  }
  e2.exports = s2, s2.default = s2;
}, (e2, t2, r2) => {
  let n2 = r2(24), s2 = r2(320), i2 = r2(55);
  function o2(e3, t3) {
    let r3 = new i2(e3, t3), n3 = new s2(r3);
    try {
      n3.parse();
    } catch (e4) {
      throw e4;
    }
    return n3.root;
  }
  e2.exports = o2, o2.default = o2, n2.registerParse(o2);
}, (e2, t2, r2) => {
  let n2 = r2(24);
  class s2 extends n2 {
    constructor(e3) {
      super(e3), this.type = "atrule";
    }
    append() {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...arguments);
    }
    prepend() {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...arguments);
    }
  }
  e2.exports = s2, s2.default = s2, n2.registerAtRule(s2);
}, (e2, t2, r2) => {
  let n2 = r2(24), s2 = r2(154);
  class i2 extends n2 {
    constructor(e3) {
      super(e3), this.type = "rule", this.nodes || (this.nodes = []);
    }
    get selectors() {
      return s2.comma(this.selector);
    }
    set selectors(e3) {
      let t3 = this.selector ? this.selector.match(/,\s*/) : null, r3 = t3 ? t3[0] : "," + this.raw("between", "beforeOpen");
      this.selector = e3.join(r3);
    }
  }
  e2.exports = i2, i2.default = i2, n2.registerRule(i2);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "ImportInjector", { enumerable: true, get: function() {
    return n2.default;
  } }), t2.addDefault = function(e3, t3, r3) {
    return new n2.default(e3).addDefault(t3, r3);
  }, t2.addNamed = function(e3, t3, r3, s3) {
    return new n2.default(e3).addNamed(t3, r3, s3);
  }, t2.addNamespace = function(e3, t3, r3) {
    return new n2.default(e3).addNamespace(t3, r3);
  }, t2.addSideEffect = function(e3, t3, r3) {
    return new n2.default(e3).addSideEffect(t3, r3);
  }, Object.defineProperty(t2, "isModule", { enumerable: true, get: function() {
    return s2.default;
  } });
  var n2 = r2(447), s2 = r2(250);
}, function(e2, t2) {
  !function(e3) {
    class t3 {
      constructor() {
        this.should_skip = false, this.should_remove = false, this.replacement = null, this.context = { skip: () => this.should_skip = true, remove: () => this.should_remove = true, replace: (e4) => this.replacement = e4 };
      }
      replace(e4, t4, r3, n3) {
        e4 && (null !== r3 ? e4[t4][r3] = n3 : e4[t4] = n3);
      }
      remove(e4, t4, r3) {
        e4 && (null !== r3 ? e4[t4].splice(r3, 1) : delete e4[t4]);
      }
    }
    class r2 extends t3 {
      constructor(e4, t4) {
        super(), this.enter = e4, this.leave = t4;
      }
      visit(e4, t4, r3, n3) {
        if (e4) {
          if (this.enter) {
            const s2 = this.should_skip, i2 = this.should_remove, o2 = this.replacement;
            this.should_skip = false, this.should_remove = false, this.replacement = null, this.enter.call(this.context, e4, t4, r3, n3), this.replacement && (e4 = this.replacement, this.replace(t4, r3, n3, e4)), this.should_remove && this.remove(t4, r3, n3);
            const a2 = this.should_skip, l = this.should_remove;
            if (this.should_skip = s2, this.should_remove = i2, this.replacement = o2, a2) return e4;
            if (l) return null;
          }
          for (const t5 in e4) {
            const r4 = e4[t5];
            if ("object" == typeof r4) if (Array.isArray(r4)) for (let n4 = 0; n4 < r4.length; n4 += 1) null !== r4[n4] && "string" == typeof r4[n4].type && (this.visit(r4[n4], e4, t5, n4) || n4--);
            else null !== r4 && "string" == typeof r4.type && this.visit(r4, e4, t5, null);
          }
          if (this.leave) {
            const s2 = this.replacement, i2 = this.should_remove;
            this.replacement = null, this.should_remove = false, this.leave.call(this.context, e4, t4, r3, n3), this.replacement && (e4 = this.replacement, this.replace(t4, r3, n3, e4)), this.should_remove && this.remove(t4, r3, n3);
            const o2 = this.should_remove;
            if (this.replacement = s2, this.should_remove = i2, o2) return null;
          }
        }
        return e4;
      }
    }
    class n2 extends t3 {
      constructor(e4, t4) {
        super(), this.enter = e4, this.leave = t4;
      }
      async visit(e4, t4, r3, n3) {
        if (e4) {
          if (this.enter) {
            const s2 = this.should_skip, i2 = this.should_remove, o2 = this.replacement;
            this.should_skip = false, this.should_remove = false, this.replacement = null, await this.enter.call(this.context, e4, t4, r3, n3), this.replacement && (e4 = this.replacement, this.replace(t4, r3, n3, e4)), this.should_remove && this.remove(t4, r3, n3);
            const a2 = this.should_skip, l = this.should_remove;
            if (this.should_skip = s2, this.should_remove = i2, this.replacement = o2, a2) return e4;
            if (l) return null;
          }
          for (const t5 in e4) {
            const r4 = e4[t5];
            if ("object" == typeof r4) if (Array.isArray(r4)) for (let n4 = 0; n4 < r4.length; n4 += 1) null !== r4[n4] && "string" == typeof r4[n4].type && (await this.visit(r4[n4], e4, t5, n4) || n4--);
            else null !== r4 && "string" == typeof r4.type && await this.visit(r4, e4, t5, null);
          }
          if (this.leave) {
            const s2 = this.replacement, i2 = this.should_remove;
            this.replacement = null, this.should_remove = false, await this.leave.call(this.context, e4, t4, r3, n3), this.replacement && (e4 = this.replacement, this.replace(t4, r3, n3, e4)), this.should_remove && this.remove(t4, r3, n3);
            const o2 = this.should_remove;
            if (this.replacement = s2, this.should_remove = i2, o2) return null;
          }
        }
        return e4;
      }
    }
    e3.asyncWalk = async function(e4, t4) {
      let { enter: r3, leave: s2 } = t4;
      const i2 = new n2(r3, s2);
      return await i2.visit(e4, null);
    }, e3.walk = function(e4, t4) {
      let { enter: n3, leave: s2 } = t4;
      return new r2(n3, s2).visit(e4, null);
    }, Object.defineProperty(e3, "__esModule", { value: true });
  }(t2);
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(161);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2() {
    const e3 = r2(14);
    return s2 = function() {
      return e3;
    }, e3;
  }
  function i2() {
    const e3 = r2(36);
    return i2 = function() {
      return e3;
    }, e3;
  }
  function o2() {
    const e3 = r2(0);
    return o2 = function() {
      return e3;
    }, e3;
  }
  function a2() {
    const e3 = r2(68);
    return a2 = function() {
      return e3;
    }, e3;
  }
  function l() {
    const e3 = r2(23);
    return l = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  const { cloneNode: c, interpreterDirective: u } = o2(), p = { enter(e3, t3) {
    const r3 = e3.node.loc;
    r3 && (t3.loc = r3, e3.stop());
  } };
  class d {
    constructor(e3, t3) {
      let { code: r3, ast: n3, inputMap: i3 } = t3;
      this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope = void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = { file: this, getCode: () => this.code, getScope: () => this.scope, addHelper: this.addHelper.bind(this), buildError: this.buildCodeFrameError.bind(this) }, this.opts = e3, this.code = r3, this.ast = n3, this.inputMap = i3, this.path = s2().NodePath.get({ hub: this.hub, parentPath: null, parent: this.ast, container: this.ast, key: "program" }).setContext(), this.scope = this.path.scope;
    }
    get shebang() {
      const { interpreter: e3 } = this.path.node;
      return e3 ? e3.value : "";
    }
    set shebang(e3) {
      e3 ? this.path.get("interpreter").replaceWith(u(e3)) : this.path.get("interpreter").remove();
    }
    set(e3, t3) {
      if ("helpersNamespace" === e3) throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
      this._map.set(e3, t3);
    }
    get(e3) {
      return this._map.get(e3);
    }
    has(e3) {
      return this._map.has(e3);
    }
    getModuleName() {
      return (0, a2().getModuleName)(this.opts, this.opts);
    }
    addImport() {
      throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
    }
    availableHelper(e3, t3) {
      let r3;
      try {
        r3 = n2().minVersion(e3);
      } catch (e4) {
        if ("BABEL_HELPER_UNKNOWN" !== e4.code) throw e4;
        return false;
      }
      return "string" != typeof t3 || (l().valid(t3) && (t3 = `^${t3}`), !l().intersects(`<${r3}`, t3) && !l().intersects(">=8.0.0", t3));
    }
    addHelper(e3) {
      const t3 = this.declarations[e3];
      if (t3) return c(t3);
      const r3 = this.get("helperGenerator");
      if (r3) {
        const t4 = r3(e3);
        if (t4) return t4;
      }
      n2().ensure(e3, d);
      const s3 = this.declarations[e3] = this.scope.generateUidIdentifier(e3), i3 = {};
      for (const t4 of n2().getDependencies(e3)) i3[t4] = this.addHelper(t4);
      const { nodes: o3, globals: a3 } = n2().get(e3, (e4) => i3[e4], s3, Object.keys(this.scope.getAllBindings()));
      return a3.forEach((e4) => {
        this.path.scope.hasBinding(e4, true) && this.path.scope.rename(e4);
      }), o3.forEach((e4) => {
        e4._compact = true;
      }), this.path.unshiftContainer("body", o3), this.path.get("body").forEach((e4) => {
        -1 !== o3.indexOf(e4.node) && e4.isVariableDeclaration() && this.scope.registerDeclaration(e4);
      }), s3;
    }
    addTemplateObject() {
      throw new Error("This function has been moved into the template literal transform itself.");
    }
    buildCodeFrameError(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : SyntaxError, n3 = e3 && (e3.loc || e3._loc);
      if (!n3 && e3) {
        const r4 = { loc: null };
        (0, s2().default)(e3, p, this.scope, r4), n3 = r4.loc;
        let i3 = "This is an error on an internal node. Probably an internal error.";
        n3 && (i3 += " Location has been estimated."), t3 += ` (${i3})`;
      }
      if (n3) {
        const { highlightCode: e4 = true } = this.opts;
        t3 += "\n" + (0, i2().codeFrameColumns)(this.code, { start: { line: n3.start.line, column: n3.start.column + 1 }, end: n3.end && n3.start.line === n3.end.line ? { line: n3.end.line, column: n3.end.column + 1 } : void 0 }, { highlightCode: e4 });
      }
      return new r3(t3);
    }
  }
  t2.default = d;
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const r2 = Object.keys(t3);
    for (const n2 of r2) if (e3[n2] !== t3[n2]) return false;
    return true;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    if (!e3) return;
    const o2 = n2.NODE_FIELDS[e3.type];
    if (!o2) return;
    s2(e3, t3, r3, o2[t3]), i2(e3, t3, r3);
  }, t2.validateChild = i2, t2.validateField = s2;
  var n2 = r2(9);
  function s2(e3, t3, r3, n3) {
    null != n3 && n3.validate && (n3.optional && null == r3 || n3.validate(e3, t3, r3));
  }
  function i2(e3, t3, r3) {
    if (null == r3) return;
    const s3 = n2.NODE_PARENT_VALIDATIONS[r3.type];
    s3 && s3(e3, t3, r3);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if (e3 === t3) return true;
    if (null == e3) return false;
    if (n2.ALIAS_KEYS[t3]) return false;
    const r3 = n2.FLIPPED_ALIAS_KEYS[t3];
    if (r3) {
      if (r3[0] === e3) return true;
      for (const t4 of r3) if (e3 === t4) return true;
    }
    return false;
  };
  var n2 = r2(9);
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r2) {
    t3 && r2 && (t3[e3] = Array.from(new Set([].concat(t3[e3], r2[e3]).filter(Boolean))));
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.traverseNode = function(e3, t3, r3, s3, o2, a2, l) {
    const c = i2[e3.type];
    if (!c) return false;
    const u = new n2.default(r3, t3, s3, o2);
    if (l) return (null == a2 || !a2[o2.parentKey]) && u.visitQueue([o2]);
    for (const t4 of c) if ((null == a2 || !a2[t4]) && u.visit(e3, t4)) return true;
    return false;
  };
  var n2 = r2(400), s2 = r2(0);
  const { VISITOR_KEYS: i2 } = s2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = arguments.length > 2 ? arguments[2] : void 0;
    const o2 = i2(r3, t3), a2 = t3.sourceMaps ? new n2.default(t3, r3) : null;
    return new s2.default(o2, a2).generate(e3);
  };
  var n2 = r2(405), s2 = r2(408);
  function i2(e3, t3) {
    var r3;
    const n3 = { auxiliaryCommentBefore: t3.auxiliaryCommentBefore, auxiliaryCommentAfter: t3.auxiliaryCommentAfter, shouldPrintComment: t3.shouldPrintComment, retainLines: t3.retainLines, retainFunctionParens: t3.retainFunctionParens, comments: null == t3.comments || t3.comments, compact: t3.compact, minified: t3.minified, concise: t3.concise, indent: { adjustMultilineComment: true, style: "  " }, jsescOption: Object.assign({ quotes: "double", wrap: true, minimal: false }, t3.jsescOption), recordAndTupleSyntaxType: null != (r3 = t3.recordAndTupleSyntaxType) ? r3 : "hash", topicToken: t3.topicToken, importAttributesKeyword: t3.importAttributesKeyword };
    n3.decoratorsBeforeExport = t3.decoratorsBeforeExport, n3.jsescOption.json = t3.jsonCompatibleStrings, n3.minified ? (n3.compact = true, n3.shouldPrintComment = n3.shouldPrintComment || (() => n3.comments)) : n3.shouldPrintComment = n3.shouldPrintComment || ((e4) => n3.comments || e4.includes("@license") || e4.includes("@preserve")), "auto" === n3.compact && (n3.compact = "string" == typeof e3 && e3.length > 5e5, n3.compact), n3.compact && (n3.indent.adjustMultilineComment = false);
    const { auxiliaryCommentBefore: s3, auxiliaryCommentAfter: i3, shouldPrintComment: o2 } = n3;
    return s3 && !o2(s3) && (n3.auxiliaryCommentBefore = void 0), i3 && !o2(i3) && (n3.auxiliaryCommentAfter = void 0), n3;
  }
  t2.CodeGenerator = class {
    constructor(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = arguments.length > 2 ? arguments[2] : void 0;
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = e3, this._format = i2(r3, t3), this._map = t3.sourceMaps ? new n2.default(t3, r3) : null;
    }
    generate() {
      return new s2.default(this._format, this._map).generate(this._ast);
    }
  };
}, (e2, t2, r2) => {
  var n2 = r2(103), s2 = r2(109);
  e2.exports = function(e3, t3, r3) {
    return r3.get && n2(r3.get, t3, { getter: true }), r3.set && n2(r3.set, t3, { setter: true }), s2.f(e3, t3, r3);
  };
}, (e2, t2, r2) => {
  var n2 = r2(19), s2 = r2(11), i2 = r2(6), o2 = r2(29), a2 = r2(15), l = r2(188).CONFIGURABLE, c = r2(189), u = r2(107), p = u.enforce, d = u.get, f = String, h = Object.defineProperty, m = n2("".slice), y = n2("".replace), g = n2([].join), b = a2 && !s2(function() {
    return 8 !== h(function() {
    }, "length", { value: 8 }).length;
  }), v = String(String).split("String"), E = e2.exports = function(e3, t3, r3) {
    "Symbol(" === m(f(t3), 0, 7) && (t3 = "[" + y(f(t3), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), r3 && r3.getter && (t3 = "get " + t3), r3 && r3.setter && (t3 = "set " + t3), (!o2(e3, "name") || l && e3.name !== t3) && (a2 ? h(e3, "name", { value: t3, configurable: true }) : e3.name = t3), b && r3 && o2(r3, "arity") && e3.length !== r3.arity && h(e3, "length", { value: r3.arity });
    try {
      r3 && o2(r3, "constructor") && r3.constructor ? a2 && h(e3, "prototype", { writable: false }) : e3.prototype && (e3.prototype = void 0);
    } catch (e4) {
    }
    var n3 = p(e3);
    return o2(n3, "source") || (n3.source = g(v, "string" == typeof t3 ? t3 : "")), e3;
  };
  Function.prototype.toString = E(function() {
    return i2(this) && d(this).source || c(this);
  }, "toString");
}, (e2, t2, r2) => {
  var n2 = r2(11);
  e2.exports = !n2(function() {
    var e3 = (function() {
    }).bind();
    return "function" != typeof e3 || e3.hasOwnProperty("prototype");
  });
}, (e2) => {
  e2.exports = function(e3) {
    return null == e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = Object.defineProperty;
  e2.exports = function(e3, t3) {
    try {
      s2(n2, e3, { value: t3, configurable: true, writable: true });
    } catch (r3) {
      n2[e3] = t3;
    }
    return t3;
  };
}, (e2, t2, r2) => {
  var n2, s2, i2, o2 = r2(190), a2 = r2(5), l = r2(20), c = r2(108), u = r2(29), p = r2(64), d = r2(117), f = r2(203), h = "Object already initialized", m = a2.TypeError, y = a2.WeakMap;
  if (o2 || p.state) {
    var g = p.state || (p.state = new y());
    g.get = g.get, g.has = g.has, g.set = g.set, n2 = function(e3, t3) {
      if (g.has(e3)) throw new m(h);
      return t3.facade = e3, g.set(e3, t3), t3;
    }, s2 = function(e3) {
      return g.get(e3) || {};
    }, i2 = function(e3) {
      return g.has(e3);
    };
  } else {
    var b = d("state");
    f[b] = true, n2 = function(e3, t3) {
      if (u(e3, b)) throw new m(h);
      return t3.facade = e3, c(e3, b, t3), t3;
    }, s2 = function(e3) {
      return u(e3, b) ? e3[b] : {};
    }, i2 = function(e3) {
      return u(e3, b);
    };
  }
  e2.exports = { set: n2, get: s2, has: i2, enforce: function(e3) {
    return i2(e3) ? s2(e3) : n2(e3, {});
  }, getterFor: function(e3) {
    return function(t3) {
      var r3;
      if (!l(t3) || (r3 = s2(t3)).type !== e3) throw new m("Incompatible receiver, " + e3 + " required");
      return r3;
    };
  } };
}, (e2, t2, r2) => {
  var n2 = r2(15), s2 = r2(109), i2 = r2(202);
  e2.exports = n2 ? function(e3, t3, r3) {
    return s2.f(e3, t3, i2(1, r3));
  } : function(e3, t3, r3) {
    return e3[t3] = r3, e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(15), s2 = r2(191), i2 = r2(193), o2 = r2(65), a2 = r2(194), l = TypeError, c = Object.defineProperty, u = Object.getOwnPropertyDescriptor, p = "enumerable", d = "configurable", f = "writable";
  t2.f = n2 ? i2 ? function(e3, t3, r3) {
    if (o2(e3), t3 = a2(t3), o2(r3), "function" == typeof e3 && "prototype" === t3 && "value" in r3 && f in r3 && !r3[f]) {
      var n3 = u(e3, t3);
      n3 && n3[f] && (e3[t3] = r3.value, r3 = { configurable: d in r3 ? r3[d] : n3[d], enumerable: p in r3 ? r3[p] : n3[p], writable: false });
    }
    return c(e3, t3, r3);
  } : c : function(e3, t3, r3) {
    if (o2(e3), t3 = a2(t3), o2(r3), s2) try {
      return c(e3, t3, r3);
    } catch (e4) {
    }
    if ("get" in r3 || "set" in r3) throw new l("Accessors not supported");
    return "value" in r3 && (e3[t3] = r3.value), e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(196), s2 = r2(6), i2 = r2(111), o2 = r2(112), a2 = Object;
  e2.exports = o2 ? function(e3) {
    return "symbol" == typeof e3;
  } : function(e3) {
    var t3 = n2("Symbol");
    return s2(t3) && i2(t3.prototype, a2(e3));
  };
}, (e2, t2, r2) => {
  var n2 = r2(19);
  e2.exports = n2({}.isPrototypeOf);
}, (e2, t2, r2) => {
  var n2 = r2(113);
  e2.exports = n2 && !Symbol.sham && "symbol" == typeof Symbol.iterator;
}, (e2, t2, r2) => {
  var n2 = r2(197), s2 = r2(11), i2 = r2(5).String;
  e2.exports = !!Object.getOwnPropertySymbols && !s2(function() {
    var e3 = Symbol("symbol detection");
    return !i2(e3) || !(Object(e3) instanceof Symbol) || !Symbol.sham && n2 && n2 < 41;
  });
}, (e2, t2, r2) => {
  var n2 = r2(6), s2 = r2(115), i2 = TypeError;
  e2.exports = function(e3) {
    if (n2(e3)) return e3;
    throw new i2(s2(e3) + " is not a function");
  };
}, (e2) => {
  var t2 = String;
  e2.exports = function(e3) {
    try {
      return t2(e3);
    } catch (e4) {
      return "Object";
    }
  };
}, (e2, t2, r2) => {
  var n2 = r2(201), s2 = r2(64);
  (e2.exports = function(e3, t3) {
    return s2[e3] || (s2[e3] = void 0 !== t3 ? t3 : {});
  })("versions", []).push({ version: "3.35.1", mode: n2 ? "pure" : "global", copyright: "© 2014-2024 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.35.1/LICENSE", source: "https://github.com/zloirock/core-js" });
}, (e2, t2, r2) => {
  var n2 = r2(116), s2 = r2(67), i2 = n2("keys");
  e2.exports = function(e3) {
    return i2[e3] || (i2[e3] = s2(e3));
  };
}, (e2, t2, r2) => {
  var n2 = r2(220);
  e2.exports = function(e3) {
    var t3 = +e3;
    return t3 != t3 || 0 === t3 ? 0 : n2(t3);
  };
}, (e2, t2, r2) => {
  r2(44), Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    let t3, { node: r3, parent: n3, scope: s3, id: w } = e3, P = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], A = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (r3.id) return;
    if (!m(n3) && !h(n3, { kind: "method" }) || n3.computed && !d(n3.key)) {
      if (v(n3)) {
        if (w = n3.id, p(w) && !P) {
          const e4 = s3.parent.getBinding(w.name);
          if (e4 && e4.constant && s3.getBinding(w.name) === e4) return r3.id = o2(w), void (r3.id[i2] = true);
        }
      } else if (l(n3, { operator: "=" })) w = n3.left;
      else if (!w) return;
    } else w = n3.key;
    if (w && d(w) ? t3 = function(e4) {
      return f(e4) ? "null" : y(e4) ? `_${e4.pattern}_${e4.flags}` : b(e4) ? e4.quasis.map((e5) => e5.value.raw).join("") : void 0 !== e4.value ? e4.value + "" : "";
    }(w) : w && p(w) && (t3 = w.name), void 0 === t3) return;
    if (!A && u(r3) && /[\uD800-\uDFFF]/.test(t3)) return;
    t3 = E(t3);
    const C = a2(t3);
    return C[i2] = true, function(e4, t4, r4, n4) {
      if (e4.selfReference) {
        if (!n4.hasBinding(r4.name) || n4.hasGlobal(r4.name)) {
          if (!u(t4)) return;
          let e5 = S;
          t4.generator && (e5 = x);
          const s4 = e5({ FUNCTION: t4, FUNCTION_ID: r4, FUNCTION_KEY: n4.generateUidIdentifier(r4.name) }).expression, i3 = s4.callee.body.body[0].params;
          for (let e6 = 0, r5 = function(e7) {
            const t5 = e7.params.findIndex((e8) => c(e8) || g(e8));
            return -1 === t5 ? e7.params.length : t5;
          }(t4); e6 < r5; e6++) i3.push(n4.generateUidIdentifier("x"));
          return s4;
        }
        n4.rename(r4.name);
      }
      t4.id = r4, n4.getProgramParent().references[r4.name] = true;
    }(function(e4, t4, r4) {
      const n4 = { selfAssignment: false, selfReference: false, outerDeclar: r4.getBindingIdentifier(t4), name: t4 }, s4 = r4.getOwnBinding(t4);
      return s4 ? "param" === s4.kind && (n4.selfReference = true) : (n4.outerDeclar || r4.hasGlobal(t4)) && r4.traverse(e4, T, n4), n4;
    }(r3, t3, s3), r3, C, s3) || r3;
  };
  var n2 = r2(37), s2 = r2(0);
  const { NOT_LOCAL_BINDING: i2, cloneNode: o2, identifier: a2, isAssignmentExpression: l, isAssignmentPattern: c, isFunction: u, isIdentifier: p, isLiteral: d, isNullLiteral: f, isObjectMethod: h, isObjectProperty: m, isRegExpLiteral: y, isRestElement: g, isTemplateLiteral: b, isVariableDeclarator: v, toBindingIdentifierName: E } = s2, S = n2.default.statement("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), x = n2.default.statement("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), T = { "ReferencedIdentifier|BindingIdentifier"(e3, t3) {
    e3.node.name === t3.name && e3.scope.getBindingIdentifier(t3.name) === t3.outerDeclar && (t3.selfReference = true, e3.stop());
  } };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.merge = function(e3, t3) {
    const { placeholderWhitelist: r3 = e3.placeholderWhitelist, placeholderPattern: n2 = e3.placeholderPattern, preserveComments: s2 = e3.preserveComments, syntacticPlaceholders: i2 = e3.syntacticPlaceholders } = t3;
    return { parser: Object.assign({}, e3.parser, t3.parser), placeholderWhitelist: r3, placeholderPattern: n2, preserveComments: s2, syntacticPlaceholders: i2 };
  }, t2.normalizeReplacements = function(e3) {
    if (Array.isArray(e3)) return e3.reduce((e4, t3, r3) => (e4["$" + r3] = t3, e4), {});
    if ("object" == typeof e3 || null == e3) return e3 || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }, t2.validate = function(e3) {
    if (null != e3 && "object" != typeof e3) throw new Error("Unknown template options.");
    const t3 = e3 || {}, { placeholderWhitelist: n2, placeholderPattern: s2, preserveComments: i2, syntacticPlaceholders: o2 } = t3, a2 = function(e4, t4) {
      if (null == e4) return {};
      var r3, n3, s3 = {}, i3 = Object.keys(e4);
      for (n3 = 0; n3 < i3.length; n3++) r3 = i3[n3], t4.indexOf(r3) >= 0 || (s3[r3] = e4[r3]);
      return s3;
    }(t3, r2);
    if (null != n2 && !(n2 instanceof Set)) throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (null != s2 && !(s2 instanceof RegExp) && false !== s2) throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (null != i2 && "boolean" != typeof i2) throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (null != o2 && "boolean" != typeof o2) throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (true === o2 && (null != n2 || null != s2)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return { parser: a2, placeholderWhitelist: n2 || void 0, placeholderPattern: null == s2 ? void 0 : s2, preserveComments: null == i2 ? void 0 : i2, syntacticPlaceholders: null == o2 ? void 0 : o2 };
  };
  const r2 = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
}, (e2, t2, r2) => {
  var n2 = r2(72)(), s2 = r2(22), i2 = n2 && s2("%Object.defineProperty%", true);
  if (i2) try {
    i2({}, "a", { value: 1 });
  } catch (e3) {
    i2 = false;
  }
  var o2 = s2("%SyntaxError%"), a2 = s2("%TypeError%"), l = r2(73);
  e2.exports = function(e3, t3, r3) {
    if (!e3 || "object" != typeof e3 && "function" != typeof e3) throw new a2("`obj` must be an object or a function`");
    if ("string" != typeof t3 && "symbol" != typeof t3) throw new a2("`property` must be a string or a symbol`");
    if (arguments.length > 3 && "boolean" != typeof arguments[3] && null !== arguments[3]) throw new a2("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && "boolean" != typeof arguments[4] && null !== arguments[4]) throw new a2("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && "boolean" != typeof arguments[5] && null !== arguments[5]) throw new a2("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && "boolean" != typeof arguments[6]) throw new a2("`loose`, if provided, must be a boolean");
    var n3 = arguments.length > 3 ? arguments[3] : null, s3 = arguments.length > 4 ? arguments[4] : null, c = arguments.length > 5 ? arguments[5] : null, u = arguments.length > 6 && arguments[6], p = !!l && l(e3, t3);
    if (i2) i2(e3, t3, { configurable: null === c && p ? p.configurable : !c, enumerable: null === n3 && p ? p.enumerable : !n3, value: r3, writable: null === s3 && p ? p.writable : !s3 });
    else {
      if (!u && (n3 || s3 || c)) throw new o2("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      e3[t3] = r3;
    }
  };
}, (e2, t2, r2) => {
  var n2 = r2(236), s2 = r2(238), i2 = r2(41), o2 = r2(38), a2 = r2(73), l = o2("Object.prototype.toString"), c = r2(69)(), u = "undefined" == typeof globalThis ? r2.g : globalThis, p = s2(), d = o2("String.prototype.slice"), f = Object.getPrototypeOf, h = o2("Array.prototype.indexOf", true) || function(e3, t3) {
    for (var r3 = 0; r3 < e3.length; r3 += 1) if (e3[r3] === t3) return r3;
    return -1;
  }, m = { __proto__: null };
  n2(p, c && a2 && f ? function(e3) {
    var t3 = new u[e3]();
    if (Symbol.toStringTag in t3) {
      var r3 = f(t3), n3 = a2(r3, Symbol.toStringTag);
      if (!n3) {
        var s3 = f(r3);
        n3 = a2(s3, Symbol.toStringTag);
      }
      m["$" + e3] = i2(n3.get);
    }
  } : function(e3) {
    var t3 = new u[e3](), r3 = t3.slice || t3.set;
    r3 && (m["$" + e3] = i2(r3));
  }), e2.exports = function(e3) {
    if (!e3 || "object" != typeof e3) return false;
    if (!c) {
      var t3 = d(l(e3), 8, -1);
      return h(p, t3) > -1 ? t3 : "Object" === t3 && function(e4) {
        var t4 = false;
        return n2(m, function(r3, n3) {
          if (!t4) try {
            r3(e4), t4 = d(n3, 1);
          } catch (e5) {
          }
        }), t4;
      }(e3);
    }
    return a2 ? function(e4) {
      var t4 = false;
      return n2(m, function(r3, n3) {
        if (!t4) try {
          "$" + r3(e4) === n3 && (t4 = d(n3, 1));
        } catch (e5) {
        }
      }), t4;
    }(e3) : null;
  };
}, (e2, t2, r2) => {
  var n2 = Array.prototype.slice, s2 = r2(124), i2 = Object.keys, o2 = i2 ? function(e3) {
    return i2(e3);
  } : r2(244), a2 = Object.keys;
  o2.shim = function() {
    if (Object.keys) {
      var e3 = function() {
        var e4 = Object.keys(arguments);
        return e4 && e4.length === arguments.length;
      }(1, 2);
      e3 || (Object.keys = function(e4) {
        return s2(e4) ? a2(n2.call(e4)) : a2(e4);
      });
    } else Object.keys = o2;
    return Object.keys || o2;
  }, e2.exports = o2;
}, (e2) => {
  var t2 = Object.prototype.toString;
  e2.exports = function(e3) {
    var r2 = t2.call(e3), n2 = "[object Arguments]" === r2;
    return n2 || (n2 = "[object Array]" !== r2 && null !== e3 && "object" == typeof e3 && "number" == typeof e3.length && e3.length >= 0 && "[object Function]" === t2.call(e3.callee)), n2;
  };
}, (e2) => {
  var t2 = function(e3) {
    return e3 != e3;
  };
  e2.exports = function(e3, r2) {
    return 0 === e3 && 0 === r2 ? 1 / e3 == 1 / r2 : e3 === r2 || !(!t2(e3) || !t2(r2));
  };
}, (e2) => {
  e2.exports = function(e3) {
    return e3 != e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(126);
  e2.exports = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : n2;
  };
}, (e2) => {
  const t2 = /^[0-9]+$/, r2 = (e3, r3) => {
    const n2 = t2.test(e3), s2 = t2.test(r3);
    return n2 && s2 && (e3 = +e3, r3 = +r3), e3 === r3 ? 0 : n2 && !s2 ? -1 : s2 && !n2 ? 1 : e3 < r3 ? -1 : 1;
  };
  e2.exports = { compareIdentifiers: r2, rcompareIdentifiers: (e3, t3) => r2(t3, e3) };
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => 0 === n2(e3, t3, r3);
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => 0 !== n2(e3, t3, r3);
}, (e2, t2, r2) => {
  const n2 = r2(129), s2 = r2(130), i2 = r2(49), o2 = r2(78), a2 = r2(77), l = r2(79);
  e2.exports = (e3, t3, r3, c) => {
    switch (t3) {
      case "===":
        return "object" == typeof e3 && (e3 = e3.version), "object" == typeof r3 && (r3 = r3.version), e3 === r3;
      case "!==":
        return "object" == typeof e3 && (e3 = e3.version), "object" == typeof r3 && (r3 = r3.version), e3 !== r3;
      case "":
      case "=":
      case "==":
        return n2(e3, r3, c);
      case "!=":
        return s2(e3, r3, c);
      case ">":
        return i2(e3, r3, c);
      case ">=":
        return o2(e3, r3, c);
      case "<":
        return a2(e3, r3, c);
      case "<=":
        return l(e3, r3, c);
      default:
        throw new TypeError(`Invalid operator: ${t3}`);
    }
  };
}, (e2, t2, r2) => {
  const n2 = r2(266), s2 = Symbol("max"), i2 = Symbol("length"), o2 = Symbol("lengthCalculator"), a2 = Symbol("allowStale"), l = Symbol("maxAge"), c = Symbol("dispose"), u = Symbol("noDisposeOnSet"), p = Symbol("lruList"), d = Symbol("cache"), f = Symbol("updateAgeOnGet"), h = () => 1, m = (e3, t3, r3) => {
    const n3 = e3[d].get(t3);
    if (n3) {
      const t4 = n3.value;
      if (y(e3, t4)) {
        if (b(e3, n3), !e3[a2]) return;
      } else r3 && (e3[f] && (n3.value.now = Date.now()), e3[p].unshiftNode(n3));
      return t4.value;
    }
  }, y = (e3, t3) => {
    if (!t3 || !t3.maxAge && !e3[l]) return false;
    const r3 = Date.now() - t3.now;
    return t3.maxAge ? r3 > t3.maxAge : e3[l] && r3 > e3[l];
  }, g = (e3) => {
    if (e3[i2] > e3[s2]) for (let t3 = e3[p].tail; e3[i2] > e3[s2] && null !== t3; ) {
      const r3 = t3.prev;
      b(e3, t3), t3 = r3;
    }
  }, b = (e3, t3) => {
    if (t3) {
      const r3 = t3.value;
      e3[c] && e3[c](r3.key, r3.value), e3[i2] -= r3.length, e3[d].delete(r3.key), e3[p].removeNode(t3);
    }
  };
  class v {
    constructor(e3, t3, r3, n3, s3) {
      this.key = e3, this.value = t3, this.length = r3, this.now = n3, this.maxAge = s3 || 0;
    }
  }
  const E = (e3, t3, r3, n3) => {
    let s3 = r3.value;
    y(e3, s3) && (b(e3, r3), e3[a2] || (s3 = void 0)), s3 && t3.call(n3, s3.value, s3.key, e3);
  };
  e2.exports = class {
    constructor(e3) {
      if ("number" == typeof e3 && (e3 = { max: e3 }), e3 || (e3 = {}), e3.max && ("number" != typeof e3.max || e3.max < 0)) throw new TypeError("max must be a non-negative number");
      this[s2] = e3.max || 1 / 0;
      const t3 = e3.length || h;
      if (this[o2] = "function" != typeof t3 ? h : t3, this[a2] = e3.stale || false, e3.maxAge && "number" != typeof e3.maxAge) throw new TypeError("maxAge must be a number");
      this[l] = e3.maxAge || 0, this[c] = e3.dispose, this[u] = e3.noDisposeOnSet || false, this[f] = e3.updateAgeOnGet || false, this.reset();
    }
    set max(e3) {
      if ("number" != typeof e3 || e3 < 0) throw new TypeError("max must be a non-negative number");
      this[s2] = e3 || 1 / 0, g(this);
    }
    get max() {
      return this[s2];
    }
    set allowStale(e3) {
      this[a2] = !!e3;
    }
    get allowStale() {
      return this[a2];
    }
    set maxAge(e3) {
      if ("number" != typeof e3) throw new TypeError("maxAge must be a non-negative number");
      this[l] = e3, g(this);
    }
    get maxAge() {
      return this[l];
    }
    set lengthCalculator(e3) {
      "function" != typeof e3 && (e3 = h), e3 !== this[o2] && (this[o2] = e3, this[i2] = 0, this[p].forEach((e4) => {
        e4.length = this[o2](e4.value, e4.key), this[i2] += e4.length;
      })), g(this);
    }
    get lengthCalculator() {
      return this[o2];
    }
    get length() {
      return this[i2];
    }
    get itemCount() {
      return this[p].length;
    }
    rforEach(e3, t3) {
      t3 = t3 || this;
      for (let r3 = this[p].tail; null !== r3; ) {
        const n3 = r3.prev;
        E(this, e3, r3, t3), r3 = n3;
      }
    }
    forEach(e3, t3) {
      t3 = t3 || this;
      for (let r3 = this[p].head; null !== r3; ) {
        const n3 = r3.next;
        E(this, e3, r3, t3), r3 = n3;
      }
    }
    keys() {
      return this[p].toArray().map((e3) => e3.key);
    }
    values() {
      return this[p].toArray().map((e3) => e3.value);
    }
    reset() {
      this[c] && this[p] && this[p].length && this[p].forEach((e3) => this[c](e3.key, e3.value)), this[d] = /* @__PURE__ */ new Map(), this[p] = new n2(), this[i2] = 0;
    }
    dump() {
      return this[p].map((e3) => !y(this, e3) && { k: e3.key, v: e3.value, e: e3.now + (e3.maxAge || 0) }).toArray().filter((e3) => e3);
    }
    dumpLru() {
      return this[p];
    }
    set(e3, t3, r3) {
      if ((r3 = r3 || this[l]) && "number" != typeof r3) throw new TypeError("maxAge must be a number");
      const n3 = r3 ? Date.now() : 0, a3 = this[o2](t3, e3);
      if (this[d].has(e3)) {
        if (a3 > this[s2]) return b(this, this[d].get(e3)), false;
        const o3 = this[d].get(e3).value;
        return this[c] && (this[u] || this[c](e3, o3.value)), o3.now = n3, o3.maxAge = r3, o3.value = t3, this[i2] += a3 - o3.length, o3.length = a3, this.get(e3), g(this), true;
      }
      const f2 = new v(e3, t3, a3, n3, r3);
      return f2.length > this[s2] ? (this[c] && this[c](e3, t3), false) : (this[i2] += f2.length, this[p].unshift(f2), this[d].set(e3, this[p].head), g(this), true);
    }
    has(e3) {
      if (!this[d].has(e3)) return false;
      const t3 = this[d].get(e3).value;
      return !y(this, t3);
    }
    get(e3) {
      return m(this, e3, true);
    }
    peek(e3) {
      return m(this, e3, false);
    }
    pop() {
      const e3 = this[p].tail;
      return e3 ? (b(this, e3), e3.value) : null;
    }
    del(e3) {
      b(this, this[d].get(e3));
    }
    load(e3) {
      this.reset();
      const t3 = Date.now();
      for (let r3 = e3.length - 1; r3 >= 0; r3--) {
        const n3 = e3[r3], s3 = n3.e || 0;
        if (0 === s3) this.set(n3.k, n3.v);
        else {
          const e4 = s3 - t3;
          e4 > 0 && this.set(n3.k, n3.v, e4);
        }
      }
    }
    prune() {
      this[d].forEach((e3, t3) => m(this, t3, false));
    }
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2(e3, t3, r3, n3, s3, i3, o3) {
    try {
      var a3 = e3[i3](o3), l2 = a3.value;
    } catch (e4) {
      return void r3(e4);
    }
    a3.done ? t3(l2) : Promise.resolve(l2).then(n3, s3);
  }
  function i2(e3) {
    return function() {
      var t3 = this, r3 = arguments;
      return new Promise(function(n3, i3) {
        var o3 = e3.apply(t3, r3);
        function a3(e4) {
          s2(o3, n3, i3, a3, l2, "next", e4);
        }
        function l2(e4) {
          s2(o3, n3, i3, a3, l2, "throw", e4);
        }
        a3(void 0);
      });
    };
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.forwardAsync = function(e3, t3) {
    const r3 = n2()(e3);
    return a2((e4) => {
      const n3 = r3[e4];
      return t3(n3);
    });
  }, t2.isAsync = void 0, t2.isThenable = u, t2.maybeAsync = function(e3, t3) {
    return n2()({ sync() {
      for (var r3 = arguments.length, n3 = new Array(r3), s3 = 0; s3 < r3; s3++) n3[s3] = arguments[s3];
      const i3 = e3.apply(this, n3);
      if (u(i3)) throw new Error(t3);
      return i3;
    }, async() {
      for (var t4 = arguments.length, r3 = new Array(t4), n3 = 0; n3 < t4; n3++) r3[n3] = arguments[n3];
      return Promise.resolve(e3.apply(this, r3));
    } });
  }, t2.waitFor = t2.onFirstPause = void 0;
  const o2 = n2()(function* (e3) {
    return yield* e3;
  });
  t2.isAsync = n2()({ sync: () => false, errback: (e3) => e3(null, true) });
  const a2 = n2()({ sync: (e3) => e3("sync"), async: (l = i2(function* (e3) {
    return e3("async");
  }), function(e3) {
    return l.apply(this, arguments);
  }) });
  var l, c;
  function u(e3) {
    return !(!e3 || "object" != typeof e3 && "function" != typeof e3 || !e3.then || "function" != typeof e3.then);
  }
  t2.onFirstPause = n2()({ name: "onFirstPause", arity: 2, sync: function(e3) {
    return o2.sync(e3);
  }, errback: function(e3, t3, r3) {
    let n3 = false;
    o2.errback(e3, (e4, t4) => {
      n3 = true, r3(e4, t4);
    }), n3 || t3();
  } }), t2.waitFor = n2()({ sync: (e3) => e3, async: (c = i2(function* (e3) {
    return e3;
  }), function(e3) {
    return c.apply(this, arguments);
  }) });
}, (e2, t2) => {
  function r2(e3, t3) {
    for (const r3 of Object.keys(t3)) {
      const n2 = t3[r3];
      void 0 !== n2 && (e3[r3] = n2);
    }
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isIterableIterator = function(e3) {
    return !!e3 && "function" == typeof e3.next && "function" == typeof e3[Symbol.iterator];
  }, t2.mergeOptions = function(e3, t3) {
    for (const n2 of Object.keys(t3)) if ("parserOpts" !== n2 && "generatorOpts" !== n2 && "assumptions" !== n2 || !t3[n2]) {
      const r3 = t3[n2];
      void 0 !== r3 && (e3[n2] = r3);
    } else {
      const s2 = t3[n2];
      r2(e3[n2] || (e3[n2] = {}), s2);
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(136);
  t2.default = class {
    constructor(e3, t3, r3) {
      let s2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : (0, n2.finalize)([]);
      this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride = void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = e3.name || r3, this.manipulateOptions = e3.manipulateOptions, this.post = e3.post, this.pre = e3.pre, this.visitor = e3.visitor || {}, this.parserOverride = e3.parserOverride, this.generatorOverride = e3.generatorOverride, this.options = t3, this.externalDependencies = s2;
    }
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.finalize = function(e3) {
    return Object.freeze(e3);
  }, t2.flattenToSet = function(e3) {
    const t3 = /* @__PURE__ */ new Set(), r2 = [e3];
    for (; r2.length > 0; ) for (const e4 of r2.pop()) Array.isArray(e4) ? r2.push(e4) : t3.add(e4);
    return t3;
  };
}, (e2) => {
  function t2(e3) {
    this.name = "BrowserslistError", this.message = e3, this.browserslist = true, Error.captureStackTrace && Error.captureStackTrace(this, t2);
  }
  t2.prototype = Error.prototype, e2.exports = t2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.getHighestUnreleased = function(e3, t3, r3) {
    return c(e3, t3, r3) === e3 ? t3 : e3;
  }, t2.getLowestImplementedVersion = function(e3, t3) {
    const r3 = e3[t3];
    return r3 || "android" !== t3 ? r3 : e3.chrome;
  }, t2.getLowestUnreleased = c, t2.isUnreleasedVersion = function(e3, t3) {
    const r3 = i2.unreleasedLabels[t3];
    return !!r3 && r3 === e3.toString().toLowerCase();
  }, t2.semverMin = l, t2.semverify = function(e3) {
    if ("string" == typeof e3 && n2.valid(e3)) return e3;
    a2.invariant("number" == typeof e3 || "string" == typeof e3 && o2.test(e3), `'${e3}' is not a valid version`), e3 = e3.toString();
    let t3 = 0, r3 = 0;
    for (; (t3 = e3.indexOf(".", t3 + 1)) > 0; ) r3++;
    return e3 + ".0".repeat(2 - r3);
  };
  var n2 = r2(23), s2 = r2(289), i2 = r2(139);
  const o2 = /^(\d+|\d+.\d+)$/, a2 = new s2.OptionValidator("@babel/helper-compilation-targets");
  function l(e3, t3) {
    return e3 && n2.lt(e3, t3) ? e3 : t3;
  }
  function c(e3, t3, r3) {
    const n3 = i2.unreleasedLabels[r3];
    return e3 === n3 ? t3 : t3 === n3 ? e3 : l(e3, t3);
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.unreleasedLabels = t2.browserNameMap = void 0, t2.unreleasedLabels = { safari: "tp" }, t2.browserNameMap = { and_chr: "chrome", and_ff: "firefox", android: "android", chrome: "chrome", edge: "edge", firefox: "firefox", ie: "ie", ie_mob: "ie", ios_saf: "ios", node: "node", deno: "deno", op_mob: "opera_mobile", opera: "opera", safari: "safari", samsung: "samsung" };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(39);
  class s2 extends Error {
    constructor(e3, t3) {
      super(e3), (0, n2.expectedError)(this), t3 && (0, n2.injectVirtualStackFrame)(this, t3);
    }
  }
  t2.default = s2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(33), s2 = r2(299), i2 = r2(300), o2 = r2(1);
  const { assignmentExpression: a2, booleanLiteral: l, callExpression: c, cloneNode: u, identifier: p, memberExpression: d, sequenceExpression: f, stringLiteral: h, thisExpression: m } = o2.types;
  {
    const e3 = r2(33);
    t2.environmentVisitor = e3.default, t2.skipAllButComputedKey = e3.skipAllButComputedKey;
  }
  function y(e3, t3, r3, n3) {
    e3 = u(e3);
    const s3 = t3 || n3 ? e3 : d(e3, p("prototype"));
    return c(r3.addHelper("getPrototypeOf"), [s3]);
  }
  const g = o2.traverse.visitors.merge([n2.default, { Super(e3, t3) {
    const { node: r3, parentPath: n3 } = e3;
    n3.isMemberExpression({ object: r3 }) && t3.handle(n3);
  } }]), b = o2.traverse.visitors.merge([n2.default, { Scopable(e3, t3) {
    let { refName: r3 } = t3;
    const n3 = e3.scope.getOwnBinding(r3);
    n3 && n3.identifier.name === r3 && e3.scope.rename(r3);
  } }]), v = { memoise(e3, t3) {
    const { scope: r3, node: n3 } = e3, { computed: s3, property: i3 } = n3;
    if (!s3) return;
    const o3 = r3.maybeGenerateMemoised(i3);
    o3 && this.memoiser.set(i3, o3, t3);
  }, prop(e3) {
    const { computed: t3, property: r3 } = e3.node;
    return this.memoiser.has(r3) ? u(this.memoiser.get(r3)) : t3 ? u(r3) : h(r3.name);
  }, get(e3) {
    return this._get(e3, this._getThisRefs());
  }, _get(e3, t3) {
    const r3 = y(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return c(this.file.addHelper("get"), [t3.memo ? f([t3.memo, r3]) : r3, this.prop(e3), t3.this]);
  }, _getThisRefs() {
    if (!this.isDerivedConstructor) return { this: m() };
    const e3 = this.scope.generateDeclaredUidIdentifier("thisSuper");
    return { memo: a2("=", e3, m()), this: u(e3) };
  }, set(e3, t3) {
    const r3 = this._getThisRefs(), n3 = y(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return c(this.file.addHelper("set"), [r3.memo ? f([r3.memo, n3]) : n3, this.prop(e3), t3, r3.this, l(e3.isInStrictMode())]);
  }, destructureSet(e3) {
    throw e3.buildCodeFrameError("Destructuring to a super field is not supported yet.");
  }, call(e3, t3) {
    const r3 = this._getThisRefs();
    return (0, i2.default)(this._get(e3, r3), u(r3.this), t3, false);
  }, optionalCall(e3, t3) {
    const r3 = this._getThisRefs();
    return (0, i2.default)(this._get(e3, r3), u(r3.this), t3, true);
  }, delete(e3) {
    return e3.node.computed ? f([c(this.file.addHelper("toPropertyKey"), [u(e3.node.property)]), o2.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : o2.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
  } }, E = Object.assign({}, v, { prop(e3) {
    const { property: t3 } = e3.node;
    return this.memoiser.has(t3) ? u(this.memoiser.get(t3)) : u(t3);
  }, get(e3) {
    const { isStatic: t3, getSuperRef: r3 } = this, { computed: n3 } = e3.node, s3 = this.prop(e3);
    let i3;
    var o3, a3;
    return i3 = t3 ? null != (o3 = r3()) ? o3 : d(p("Function"), p("prototype")) : d(null != (a3 = r3()) ? a3 : p("Object"), p("prototype")), d(i3, s3, n3);
  }, set(e3, t3) {
    const { computed: r3 } = e3.node, n3 = this.prop(e3);
    return a2("=", d(m(), n3, r3), t3);
  }, destructureSet(e3) {
    const { computed: t3 } = e3.node, r3 = this.prop(e3);
    return d(m(), r3, t3);
  }, call(e3, t3) {
    return (0, i2.default)(this.get(e3), m(), t3, false);
  }, optionalCall(e3, t3) {
    return (0, i2.default)(this.get(e3), m(), t3, true);
  } });
  t2.default = class {
    constructor(e3) {
      var t3;
      const r3 = e3.methodPath;
      this.methodPath = r3, this.isDerivedConstructor = r3.isClassMethod({ kind: "constructor" }) && !!e3.superRef, this.isStatic = r3.isObjectMethod() || r3.node.static || (null == r3.isStaticBlock ? void 0 : r3.isStaticBlock()), this.isPrivateMethod = r3.isPrivate() && r3.isMethod(), this.file = e3.file, this.constantSuper = null != (t3 = e3.constantSuper) ? t3 : e3.isLoose, this.opts = e3;
    }
    getObjectRef() {
      return u(this.opts.objectRef || this.opts.getObjectRef());
    }
    getSuperRef() {
      return this.opts.superRef ? u(this.opts.superRef) : this.opts.getSuperRef ? u(this.opts.getSuperRef()) : void 0;
    }
    replace() {
      this.opts.refToPreserve && this.methodPath.traverse(b, { refName: this.opts.refToPreserve.name });
      const e3 = this.constantSuper ? E : v;
      (0, s2.default)(this.methodPath, g, Object.assign({ file: this.file, scope: this.methodPath.scope, isDerivedConstructor: this.isDerivedConstructor, isStatic: this.isStatic, isPrivateMethod: this.isPrivateMethod, getObjectRef: this.getObjectRef.bind(this), getSuperRef: this.getSuperRef.bind(this), boundGet: e3.get }, e3));
    }
  };
}, (e2, t2, r2) => {
  e2.exports = r2(503);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true });
  var n2 = r2(309), s2 = r2(142);
  const i2 = Symbol(""), o2 = Symbol(""), a2 = Symbol(""), l = Symbol(""), c = Symbol(""), u = Symbol(""), p = Symbol(""), d = Symbol(""), f = Symbol(""), h = Symbol("");
  n2.registerRuntimeHelpers({ [i2]: "vModelRadio", [o2]: "vModelCheckbox", [a2]: "vModelText", [l]: "vModelSelect", [c]: "vModelDynamic", [u]: "withModifiers", [p]: "withKeys", [d]: "vShow", [f]: "Transition", [h]: "TransitionGroup" });
  const m = { parseMode: "html", isVoidTag: s2.isVoidTag, isNativeTag: (e3) => s2.isHTMLTag(e3) || s2.isSVGTag(e3) || s2.isMathMLTag(e3), isPreTag: (e3) => "pre" === e3, decodeEntities: void 0, isBuiltInComponent: (e3) => "Transition" === e3 || "transition" === e3 ? f : "TransitionGroup" === e3 || "transition-group" === e3 ? h : void 0, getNamespace(e3, t3, r3) {
    let n3 = t3 ? t3.ns : r3;
    if (t3 && 2 === n3) if ("annotation-xml" === t3.tag) {
      if ("svg" === e3) return 1;
      t3.props.some((e4) => 6 === e4.type && "encoding" === e4.name && null != e4.value && ("text/html" === e4.value.content || "application/xhtml+xml" === e4.value.content)) && (n3 = 0);
    } else /^m(?:[ions]|text)$/.test(t3.tag) && "mglyph" !== e3 && "malignmark" !== e3 && (n3 = 0);
    else t3 && 1 === n3 && ("foreignObject" !== t3.tag && "desc" !== t3.tag && "title" !== t3.tag || (n3 = 0));
    if (0 === n3) {
      if ("svg" === e3) return 1;
      if ("math" === e3) return 2;
    }
    return n3;
  } }, y = (e3) => {
    1 === e3.type && e3.props.forEach((t3, r3) => {
      6 === t3.type && "style" === t3.name && t3.value && (e3.props[r3] = { type: 7, name: "bind", arg: n2.createSimpleExpression("style", true, t3.loc), exp: g(t3.value.content, t3.loc), modifiers: [], loc: t3.loc });
    });
  }, g = (e3, t3) => {
    const r3 = s2.parseStringStyle(e3);
    return n2.createSimpleExpression(JSON.stringify(r3), false, t3, 3);
  };
  function b(e3, t3) {
    return n2.createCompilerError(e3, t3, v);
  }
  const v = { 53: "v-html is missing expression.", 54: "v-html will override element children.", 55: "v-text is missing expression.", 56: "v-text will override element children.", 57: "v-model can only be used on <input>, <textarea> and <select> elements.", 58: "v-model argument is not supported on plain elements.", 59: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.", 60: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.", 61: "v-show is missing expression.", 62: "<Transition> expects exactly one child element or component.", 63: "Tags with side effect (<script> and <style>) are ignored in client component templates." }, E = s2.makeMap("passive,once,capture"), S = s2.makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"), x = s2.makeMap("left,right"), T = s2.makeMap("onkeyup,onkeydown,onkeypress", true), w = (e3, t3) => n2.isStaticExp(e3) && "onclick" === e3.content.toLowerCase() ? n2.createSimpleExpression(t3, true) : 4 !== e3.type ? n2.createCompoundExpression(["(", e3, `) === "onClick" ? "${t3}" : (`, e3, ")"]) : e3, P = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g, A = (e3, t3, r3) => {
    if (t3.scopes.vSlot > 0) return;
    let s3 = 0, i3 = 0;
    const o3 = [], a3 = (r4) => {
      if (s3 >= 20 || i3 >= 5) {
        const s4 = n2.createCallExpression(t3.helper(n2.CREATE_STATIC), [JSON.stringify(o3.map((e4) => D(e4, t3)).join("")).replace(P, '" + $1 + "'), String(o3.length)]);
        if (_(o3[0], s4, t3), o3.length > 1) {
          for (let e4 = 1; e4 < o3.length; e4++) _(o3[e4], null, t3);
          const n3 = o3.length - 1;
          return e3.splice(r4 - o3.length + 1, n3), n3;
        }
      }
      return 0;
    };
    let l2 = 0;
    for (; l2 < e3.length; l2++) {
      const t4 = e3[l2];
      if (C(t4)) {
        const e4 = t4, r4 = N(e4);
        if (r4) {
          s3 += r4[0], i3 += r4[1], o3.push(e4);
          continue;
        }
      }
      l2 -= a3(l2), s3 = 0, i3 = 0, o3.length = 0;
    }
    a3(l2);
  }, C = (e3) => (1 === e3.type && 0 === e3.tagType || 12 == e3.type) && e3.codegenNode && 4 === e3.codegenNode.type && e3.codegenNode.hoisted, O = /^(data|aria)-/, I = (e3, t3) => (0 === t3 ? s2.isKnownHtmlAttr(e3) : 1 === t3 && s2.isKnownSvgAttr(e3)) || O.test(e3), _ = (e3, t3, r3) => {
    const n3 = e3.codegenNode.hoisted;
    r3.hoists[r3.hoists.indexOf(n3)] = t3;
  }, k = s2.makeMap("caption,thead,tr,th,tbody,td,tfoot,colgroup,col");
  function N(e3) {
    if (1 === e3.type && k(e3.tag)) return false;
    if (12 === e3.type) return [1, 0];
    let t3 = 1, r3 = e3.props.length > 0 ? 1 : 0, n3 = false;
    const s3 = () => (n3 = true, false);
    return !!function e4(i3) {
      for (let e5 = 0; e5 < i3.props.length; e5++) {
        const t4 = i3.props[e5];
        if (6 === t4.type && !I(t4.name, i3.ns)) return s3();
        if (7 === t4.type && "bind" === t4.name) {
          if (t4.arg && (8 === t4.arg.type || t4.arg.isStatic && !I(t4.arg.content, i3.ns))) return s3();
          if (t4.exp && (8 === t4.exp.type || t4.exp.constType < 3)) return s3();
        }
      }
      for (let s4 = 0; s4 < i3.children.length; s4++) {
        t3++;
        const o3 = i3.children[s4];
        if (1 === o3.type && (o3.props.length > 0 && r3++, e4(o3), n3)) return false;
      }
      return true;
    }(e3) && [t3, r3];
  }
  function D(e3, t3) {
    if (s2.isString(e3)) return e3;
    if (s2.isSymbol(e3)) return "";
    switch (e3.type) {
      case 1:
        return function(e4, t4) {
          let r3 = `<${e4.tag}`, n3 = "";
          for (let t5 = 0; t5 < e4.props.length; t5++) {
            const i3 = e4.props[t5];
            if (6 === i3.type) r3 += ` ${i3.name}`, i3.value && (r3 += `="${s2.escapeHtml(i3.value.content)}"`);
            else if (7 === i3.type) if ("bind" === i3.name) {
              const e5 = i3.exp;
              if ("_" === e5.content[0]) {
                r3 += ` ${i3.arg.content}="__VUE_EXP_START__${e5.content}__VUE_EXP_END__"`;
                continue;
              }
              if (s2.isBooleanAttr(i3.arg.content) && "false" === e5.content) continue;
              let t6 = j(e5);
              if (null != t6) {
                const e6 = i3.arg && i3.arg.content;
                "class" === e6 ? t6 = s2.normalizeClass(t6) : "style" === e6 && (t6 = s2.stringifyStyle(s2.normalizeStyle(t6))), r3 += ` ${i3.arg.content}="${s2.escapeHtml(t6)}"`;
              }
            } else "html" === i3.name ? n3 = j(i3.exp) : "text" === i3.name && (n3 = s2.escapeHtml(s2.toDisplayString(j(i3.exp))));
          }
          if (t4.scopeId && (r3 += ` ${t4.scopeId}`), r3 += ">", n3) r3 += n3;
          else for (let n4 = 0; n4 < e4.children.length; n4++) r3 += D(e4.children[n4], t4);
          return s2.isVoidTag(e4.tag) || (r3 += `</${e4.tag}>`), r3;
        }(e3, t3);
      case 2:
        return s2.escapeHtml(e3.content);
      case 3:
        return `<!--${s2.escapeHtml(e3.content)}-->`;
      case 5:
        return s2.escapeHtml(s2.toDisplayString(j(e3.content)));
      case 8:
        return s2.escapeHtml(j(e3));
      case 12:
        return D(e3.content, t3);
      default:
        return "";
    }
  }
  function j(e3) {
    if (4 === e3.type) return new Function(`return (${e3.content})`)();
    {
      let t3 = "";
      return e3.children.forEach((e4) => {
        s2.isString(e4) || s2.isSymbol(e4) || (2 === e4.type ? t3 += e4.content : 5 === e4.type ? t3 += s2.toDisplayString(j(e4.content)) : t3 += j(e4));
      }), t3;
    }
  }
  const L = (e3, t3) => {
    1 !== e3.type || 0 !== e3.tagType || "script" !== e3.tag && "style" !== e3.tag || t3.removeNode();
  }, M = [y], B = { cloak: n2.noopDirectiveTransform, html: (e3, t3, r3) => {
    const { exp: s3, loc: i3 } = e3;
    return s3 || r3.onError(b(53, i3)), t3.children.length && (r3.onError(b(54, i3)), t3.children.length = 0), { props: [n2.createObjectProperty(n2.createSimpleExpression("innerHTML", true, i3), s3 || n2.createSimpleExpression("", true))] };
  }, text: (e3, t3, r3) => {
    const { exp: s3, loc: i3 } = e3;
    return s3 || r3.onError(b(55, i3)), t3.children.length && (r3.onError(b(56, i3)), t3.children.length = 0), { props: [n2.createObjectProperty(n2.createSimpleExpression("textContent", true), s3 ? n2.getConstantType(s3, r3) > 0 ? s3 : n2.createCallExpression(r3.helperString(n2.TO_DISPLAY_STRING), [s3], i3) : n2.createSimpleExpression("", true))] };
  }, model: (e3, t3, r3) => {
    const s3 = n2.transformModel(e3, t3, r3);
    if (!s3.props.length || 1 === t3.tagType) return s3;
    e3.arg && r3.onError(b(58, e3.arg.loc));
    const { tag: u2 } = t3, p2 = r3.isCustomElement(u2);
    if ("input" === u2 || "textarea" === u2 || "select" === u2 || p2) {
      let d2 = a2, f2 = false;
      if ("input" === u2 || p2) {
        const s4 = n2.findProp(t3, "type");
        if (s4) {
          if (7 === s4.type) d2 = c;
          else if (s4.value) switch (s4.value.content) {
            case "radio":
              d2 = i2;
              break;
            case "checkbox":
              d2 = o2;
              break;
            case "file":
              f2 = true, r3.onError(b(59, e3.loc));
          }
        } else n2.hasDynamicKeyVBind(t3) && (d2 = c);
      } else "select" === u2 && (d2 = l);
      f2 || (s3.needRuntime = r3.helper(d2));
    } else r3.onError(b(57, e3.loc));
    return s3.props = s3.props.filter((e4) => !(4 === e4.key.type && "modelValue" === e4.key.content)), s3;
  }, on: (e3, t3, r3) => n2.transformOn(e3, t3, r3, (t4) => {
    const { modifiers: i3 } = e3;
    if (!i3.length) return t4;
    let { key: o3, value: a3 } = t4.props[0];
    const { keyModifiers: l2, nonKeyModifiers: c2, eventOptionModifiers: d2 } = ((e4, t5, r4, s3) => {
      const i4 = [], o4 = [], a4 = [];
      for (let l3 = 0; l3 < t5.length; l3++) {
        const c3 = t5[l3];
        "native" === c3 && n2.checkCompatEnabled("COMPILER_V_ON_NATIVE", r4, s3) || E(c3) ? a4.push(c3) : x(c3) ? n2.isStaticExp(e4) ? T(e4.content) ? i4.push(c3) : o4.push(c3) : (i4.push(c3), o4.push(c3)) : S(c3) ? o4.push(c3) : i4.push(c3);
      }
      return { keyModifiers: i4, nonKeyModifiers: o4, eventOptionModifiers: a4 };
    })(o3, i3, r3, e3.loc);
    if (c2.includes("right") && (o3 = w(o3, "onContextmenu")), c2.includes("middle") && (o3 = w(o3, "onMouseup")), c2.length && (a3 = n2.createCallExpression(r3.helper(u), [a3, JSON.stringify(c2)])), !l2.length || n2.isStaticExp(o3) && !T(o3.content) || (a3 = n2.createCallExpression(r3.helper(p), [a3, JSON.stringify(l2)])), d2.length) {
      const e4 = d2.map(s2.capitalize).join("");
      o3 = n2.isStaticExp(o3) ? n2.createSimpleExpression(`${o3.content}${e4}`, true) : n2.createCompoundExpression(["(", o3, `) + "${e4}"`]);
    }
    return { props: [n2.createObjectProperty(o3, a3)] };
  }), show: (e3, t3, r3) => {
    const { exp: n3, loc: s3 } = e3;
    return n3 || r3.onError(b(61, s3)), { props: [], needRuntime: r3.helper(d) };
  } };
  t2.DOMDirectiveTransforms = B, t2.DOMErrorCodes = { X_V_HTML_NO_EXPRESSION: 53, 53: "X_V_HTML_NO_EXPRESSION", X_V_HTML_WITH_CHILDREN: 54, 54: "X_V_HTML_WITH_CHILDREN", X_V_TEXT_NO_EXPRESSION: 55, 55: "X_V_TEXT_NO_EXPRESSION", X_V_TEXT_WITH_CHILDREN: 56, 56: "X_V_TEXT_WITH_CHILDREN", X_V_MODEL_ON_INVALID_ELEMENT: 57, 57: "X_V_MODEL_ON_INVALID_ELEMENT", X_V_MODEL_ARG_ON_ELEMENT: 58, 58: "X_V_MODEL_ARG_ON_ELEMENT", X_V_MODEL_ON_FILE_INPUT_ELEMENT: 59, 59: "X_V_MODEL_ON_FILE_INPUT_ELEMENT", X_V_MODEL_UNNECESSARY_VALUE: 60, 60: "X_V_MODEL_UNNECESSARY_VALUE", X_V_SHOW_NO_EXPRESSION: 61, 61: "X_V_SHOW_NO_EXPRESSION", X_TRANSITION_INVALID_CHILDREN: 62, 62: "X_TRANSITION_INVALID_CHILDREN", X_IGNORED_SIDE_EFFECT_TAG: 63, 63: "X_IGNORED_SIDE_EFFECT_TAG", __EXTEND_POINT__: 64, 64: "__EXTEND_POINT__" }, t2.DOMErrorMessages = v, t2.DOMNodeTransforms = M, t2.TRANSITION = f, t2.TRANSITION_GROUP = h, t2.V_MODEL_CHECKBOX = o2, t2.V_MODEL_DYNAMIC = c, t2.V_MODEL_RADIO = i2, t2.V_MODEL_SELECT = l, t2.V_MODEL_TEXT = a2, t2.V_ON_WITH_KEYS = p, t2.V_ON_WITH_MODIFIERS = u, t2.V_SHOW = d, t2.compile = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return n2.baseCompile(e3, s2.extend({}, m, t3, { nodeTransforms: [L, ...M, ...t3.nodeTransforms || []], directiveTransforms: s2.extend({}, B, t3.directiveTransforms || {}), transformHoist: A }));
  }, t2.createDOMCompilerError = b, t2.parse = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return n2.baseParse(e3, s2.extend({}, m, t3));
  }, t2.parserOptions = m, t2.transformStyle = y, Object.keys(n2).forEach(function(e3) {
    "default" === e3 || Object.prototype.hasOwnProperty.call(t2, e3) || (t2[e3] = n2[e3]);
  });
}, (e2, t2, r2) => {
  var n2 = r2(86), s2 = Object.prototype.hasOwnProperty, i2 = Array.isArray, o2 = function() {
    for (var e3 = [], t3 = 0; t3 < 256; ++t3) e3.push("%" + ((t3 < 16 ? "0" : "") + t3.toString(16)).toUpperCase());
    return e3;
  }(), a2 = function(e3, t3) {
    for (var r3 = t3 && t3.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, n3 = 0; n3 < e3.length; ++n3) void 0 !== e3[n3] && (r3[n3] = e3[n3]);
    return r3;
  };
  e2.exports = { arrayToObject: a2, assign: function(e3, t3) {
    return Object.keys(t3).reduce(function(e4, r3) {
      return e4[r3] = t3[r3], e4;
    }, e3);
  }, combine: function(e3, t3) {
    return [].concat(e3, t3);
  }, compact: function(e3) {
    for (var t3 = [{ obj: { o: e3 }, prop: "o" }], r3 = [], n3 = 0; n3 < t3.length; ++n3) for (var s3 = t3[n3], o3 = s3.obj[s3.prop], a3 = Object.keys(o3), l = 0; l < a3.length; ++l) {
      var c = a3[l], u = o3[c];
      "object" == typeof u && null !== u && -1 === r3.indexOf(u) && (t3.push({ obj: o3, prop: c }), r3.push(u));
    }
    return function(e4) {
      for (; e4.length > 1; ) {
        var t4 = e4.pop(), r4 = t4.obj[t4.prop];
        if (i2(r4)) {
          for (var n4 = [], s4 = 0; s4 < r4.length; ++s4) void 0 !== r4[s4] && n4.push(r4[s4]);
          t4.obj[t4.prop] = n4;
        }
      }
    }(t3), e3;
  }, decode: function(e3, t3, r3) {
    var n3 = e3.replace(/\+/g, " ");
    if ("iso-8859-1" === r3) return n3.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(n3);
    } catch (e4) {
      return n3;
    }
  }, encode: function(e3, t3, r3, s3, i3) {
    if (0 === e3.length) return e3;
    var a3 = e3;
    if ("symbol" == typeof e3 ? a3 = Symbol.prototype.toString.call(e3) : "string" != typeof e3 && (a3 = String(e3)), "iso-8859-1" === r3) return escape(a3).replace(/%u[0-9a-f]{4}/gi, function(e4) {
      return "%26%23" + parseInt(e4.slice(2), 16) + "%3B";
    });
    for (var l = "", c = 0; c < a3.length; ++c) {
      var u = a3.charCodeAt(c);
      45 === u || 46 === u || 95 === u || 126 === u || u >= 48 && u <= 57 || u >= 65 && u <= 90 || u >= 97 && u <= 122 || i3 === n2.RFC1738 && (40 === u || 41 === u) ? l += a3.charAt(c) : u < 128 ? l += o2[u] : u < 2048 ? l += o2[192 | u >> 6] + o2[128 | 63 & u] : u < 55296 || u >= 57344 ? l += o2[224 | u >> 12] + o2[128 | u >> 6 & 63] + o2[128 | 63 & u] : (c += 1, u = 65536 + ((1023 & u) << 10 | 1023 & a3.charCodeAt(c)), l += o2[240 | u >> 18] + o2[128 | u >> 12 & 63] + o2[128 | u >> 6 & 63] + o2[128 | 63 & u]);
    }
    return l;
  }, isBuffer: function(e3) {
    return !(!e3 || "object" != typeof e3 || !(e3.constructor && e3.constructor.isBuffer && e3.constructor.isBuffer(e3)));
  }, isRegExp: function(e3) {
    return "[object RegExp]" === Object.prototype.toString.call(e3);
  }, maybeMap: function(e3, t3) {
    if (i2(e3)) {
      for (var r3 = [], n3 = 0; n3 < e3.length; n3 += 1) r3.push(t3(e3[n3]));
      return r3;
    }
    return t3(e3);
  }, merge: function e3(t3, r3, n3) {
    if (!r3) return t3;
    if ("object" != typeof r3) {
      if (i2(t3)) t3.push(r3);
      else {
        if (!t3 || "object" != typeof t3) return [t3, r3];
        (n3 && (n3.plainObjects || n3.allowPrototypes) || !s2.call(Object.prototype, r3)) && (t3[r3] = true);
      }
      return t3;
    }
    if (!t3 || "object" != typeof t3) return [t3].concat(r3);
    var o3 = t3;
    return i2(t3) && !i2(r3) && (o3 = a2(t3, n3)), i2(t3) && i2(r3) ? (r3.forEach(function(r4, i3) {
      if (s2.call(t3, i3)) {
        var o4 = t3[i3];
        o4 && "object" == typeof o4 && r4 && "object" == typeof r4 ? t3[i3] = e3(o4, r4, n3) : t3.push(r4);
      } else t3[i3] = r4;
    }), t3) : Object.keys(r3).reduce(function(t4, i3) {
      var o4 = r3[i3];
      return s2.call(t4, i3) ? t4[i3] = e3(t4[i3], o4, n3) : t4[i3] = o4, t4;
    }, o3);
  } };
}, (e2) => {
  e2.exports.isClean = Symbol("isClean"), e2.exports.my = Symbol("my");
}, (e2) => {
  const t2 = { after: "\n", beforeClose: "\n", beforeComment: "\n", beforeDecl: "\n", beforeOpen: " ", beforeRule: "\n", colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: false };
  class r2 {
    constructor(e3) {
      this.builder = e3;
    }
    atrule(e3, t3) {
      let r3 = "@" + e3.name, n2 = e3.params ? this.rawValue(e3, "params") : "";
      if (void 0 !== e3.raws.afterName ? r3 += e3.raws.afterName : n2 && (r3 += " "), e3.nodes) this.block(e3, r3 + n2);
      else {
        let s2 = (e3.raws.between || "") + (t3 ? ";" : "");
        this.builder(r3 + n2 + s2, e3);
      }
    }
    beforeAfter(e3, t3) {
      let r3;
      r3 = "decl" === e3.type ? this.raw(e3, null, "beforeDecl") : "comment" === e3.type ? this.raw(e3, null, "beforeComment") : "before" === t3 ? this.raw(e3, null, "beforeRule") : this.raw(e3, null, "beforeClose");
      let n2 = e3.parent, s2 = 0;
      for (; n2 && "root" !== n2.type; ) s2 += 1, n2 = n2.parent;
      if (r3.includes("\n")) {
        let t4 = this.raw(e3, null, "indent");
        if (t4.length) for (let e4 = 0; e4 < s2; e4++) r3 += t4;
      }
      return r3;
    }
    block(e3, t3) {
      let r3, n2 = this.raw(e3, "between", "beforeOpen");
      this.builder(t3 + n2 + "{", e3, "start"), e3.nodes && e3.nodes.length ? (this.body(e3), r3 = this.raw(e3, "after")) : r3 = this.raw(e3, "after", "emptyBody"), r3 && this.builder(r3), this.builder("}", e3, "end");
    }
    body(e3) {
      let t3 = e3.nodes.length - 1;
      for (; t3 > 0 && "comment" === e3.nodes[t3].type; ) t3 -= 1;
      let r3 = this.raw(e3, "semicolon");
      for (let n2 = 0; n2 < e3.nodes.length; n2++) {
        let s2 = e3.nodes[n2], i2 = this.raw(s2, "before");
        i2 && this.builder(i2), this.stringify(s2, t3 !== n2 || r3);
      }
    }
    comment(e3) {
      let t3 = this.raw(e3, "left", "commentLeft"), r3 = this.raw(e3, "right", "commentRight");
      this.builder("/*" + t3 + e3.text + r3 + "*/", e3);
    }
    decl(e3, t3) {
      let r3 = this.raw(e3, "between", "colon"), n2 = e3.prop + r3 + this.rawValue(e3, "value");
      e3.important && (n2 += e3.raws.important || " !important"), t3 && (n2 += ";"), this.builder(n2, e3);
    }
    document(e3) {
      this.body(e3);
    }
    raw(e3, r3, n2) {
      let s2;
      if (n2 || (n2 = r3), r3 && (s2 = e3.raws[r3], void 0 !== s2)) return s2;
      let i2 = e3.parent;
      if ("before" === n2) {
        if (!i2 || "root" === i2.type && i2.first === e3) return "";
        if (i2 && "document" === i2.type) return "";
      }
      if (!i2) return t2[n2];
      let o2 = e3.root();
      if (o2.rawCache || (o2.rawCache = {}), void 0 !== o2.rawCache[n2]) return o2.rawCache[n2];
      if ("before" === n2 || "after" === n2) return this.beforeAfter(e3, n2);
      {
        let t3 = "raw" + ((a2 = n2)[0].toUpperCase() + a2.slice(1));
        this[t3] ? s2 = this[t3](o2, e3) : o2.walk((e4) => {
          if (s2 = e4.raws[r3], void 0 !== s2) return false;
        });
      }
      var a2;
      return void 0 === s2 && (s2 = t2[n2]), o2.rawCache[n2] = s2, s2;
    }
    rawBeforeClose(e3) {
      let t3;
      return e3.walk((e4) => {
        if (e4.nodes && e4.nodes.length > 0 && void 0 !== e4.raws.after) return t3 = e4.raws.after, t3.includes("\n") && (t3 = t3.replace(/[^\n]+$/, "")), false;
      }), t3 && (t3 = t3.replace(/\S/g, "")), t3;
    }
    rawBeforeComment(e3, t3) {
      let r3;
      return e3.walkComments((e4) => {
        if (void 0 !== e4.raws.before) return r3 = e4.raws.before, r3.includes("\n") && (r3 = r3.replace(/[^\n]+$/, "")), false;
      }), void 0 === r3 ? r3 = this.raw(t3, null, "beforeDecl") : r3 && (r3 = r3.replace(/\S/g, "")), r3;
    }
    rawBeforeDecl(e3, t3) {
      let r3;
      return e3.walkDecls((e4) => {
        if (void 0 !== e4.raws.before) return r3 = e4.raws.before, r3.includes("\n") && (r3 = r3.replace(/[^\n]+$/, "")), false;
      }), void 0 === r3 ? r3 = this.raw(t3, null, "beforeRule") : r3 && (r3 = r3.replace(/\S/g, "")), r3;
    }
    rawBeforeOpen(e3) {
      let t3;
      return e3.walk((e4) => {
        if ("decl" !== e4.type && (t3 = e4.raws.between, void 0 !== t3)) return false;
      }), t3;
    }
    rawBeforeRule(e3) {
      let t3;
      return e3.walk((r3) => {
        if (r3.nodes && (r3.parent !== e3 || e3.first !== r3) && void 0 !== r3.raws.before) return t3 = r3.raws.before, t3.includes("\n") && (t3 = t3.replace(/[^\n]+$/, "")), false;
      }), t3 && (t3 = t3.replace(/\S/g, "")), t3;
    }
    rawColon(e3) {
      let t3;
      return e3.walkDecls((e4) => {
        if (void 0 !== e4.raws.between) return t3 = e4.raws.between.replace(/[^\s:]/g, ""), false;
      }), t3;
    }
    rawEmptyBody(e3) {
      let t3;
      return e3.walk((e4) => {
        if (e4.nodes && 0 === e4.nodes.length && (t3 = e4.raws.after, void 0 !== t3)) return false;
      }), t3;
    }
    rawIndent(e3) {
      if (e3.raws.indent) return e3.raws.indent;
      let t3;
      return e3.walk((r3) => {
        let n2 = r3.parent;
        if (n2 && n2 !== e3 && n2.parent && n2.parent === e3 && void 0 !== r3.raws.before) {
          let e4 = r3.raws.before.split("\n");
          return t3 = e4[e4.length - 1], t3 = t3.replace(/\S/g, ""), false;
        }
      }), t3;
    }
    rawSemicolon(e3) {
      let t3;
      return e3.walk((e4) => {
        if (e4.nodes && e4.nodes.length && "decl" === e4.last.type && (t3 = e4.raws.semicolon, void 0 !== t3)) return false;
      }), t3;
    }
    rawValue(e3, t3) {
      let r3 = e3[t3], n2 = e3.raws[t3];
      return n2 && n2.value === r3 ? n2.raw : r3;
    }
    root(e3) {
      this.body(e3), e3.raws.after && this.builder(e3.raws.after);
    }
    rule(e3) {
      this.block(e3, this.rawValue(e3, "selector")), e3.raws.ownSemicolon && this.builder(e3.raws.ownSemicolon, e3, "end");
    }
    stringify(e3, t3) {
      if (!this[e3.type]) throw new Error("Unknown AST node type " + e3.type + ". Maybe you need to change PostCSS stringifier.");
      this[e3.type](e3, t3);
    }
  }
  e2.exports = r2, r2.default = r2;
}, (e2, t2, r2) => {
  let { isClean: n2, my: s2 } = r2(145), i2 = r2(148), o2 = r2(54), a2 = r2(24), l = r2(88), c = (r2(152), r2(89)), u = r2(90), p = r2(40);
  const d = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, f = { AtRule: true, AtRuleExit: true, Comment: true, CommentExit: true, Declaration: true, DeclarationExit: true, Document: true, DocumentExit: true, Once: true, OnceExit: true, postcssPlugin: true, prepare: true, Root: true, RootExit: true, Rule: true, RuleExit: true }, h = { Once: true, postcssPlugin: true, prepare: true }, m = 0;
  function y(e3) {
    return "object" == typeof e3 && "function" == typeof e3.then;
  }
  function g(e3) {
    let t3 = false, r3 = d[e3.type];
    return "decl" === e3.type ? t3 = e3.prop.toLowerCase() : "atrule" === e3.type && (t3 = e3.name.toLowerCase()), t3 && e3.append ? [r3, r3 + "-" + t3, m, r3 + "Exit", r3 + "Exit-" + t3] : t3 ? [r3, r3 + "-" + t3, r3 + "Exit", r3 + "Exit-" + t3] : e3.append ? [r3, m, r3 + "Exit"] : [r3, r3 + "Exit"];
  }
  function b(e3) {
    let t3;
    return t3 = "document" === e3.type ? ["Document", m, "DocumentExit"] : "root" === e3.type ? ["Root", m, "RootExit"] : g(e3), { eventIndex: 0, events: t3, iterator: 0, node: e3, visitorIndex: 0, visitors: [] };
  }
  function v(e3) {
    return e3[n2] = false, e3.nodes && e3.nodes.forEach((e4) => v(e4)), e3;
  }
  let E = {};
  class S {
    constructor(e3, t3, r3) {
      let n3;
      if (this.stringified = false, this.processed = false, "object" != typeof t3 || null === t3 || "root" !== t3.type && "document" !== t3.type) if (t3 instanceof S || t3 instanceof c) n3 = v(t3.root), t3.map && (void 0 === r3.map && (r3.map = {}), r3.map.inline || (r3.map.inline = false), r3.map.prev = t3.map);
      else {
        let e4 = u;
        r3.syntax && (e4 = r3.syntax.parse), r3.parser && (e4 = r3.parser), e4.parse && (e4 = e4.parse);
        try {
          n3 = e4(t3, r3);
        } catch (e5) {
          this.processed = true, this.error = e5;
        }
        n3 && !n3[s2] && a2.rebuild(n3);
      }
      else n3 = v(t3);
      this.result = new c(e3, n3, r3), this.helpers = { ...E, postcss: E, result: this.result }, this.plugins = this.processor.plugins.map((e4) => "object" == typeof e4 && e4.prepare ? { ...e4, ...e4.prepare(this.result) } : e4);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(e3) {
      return this.async().catch(e3);
    }
    finally(e3) {
      return this.async().then(e3, e3);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(e3, t3) {
      let r3 = this.result.lastPlugin;
      try {
        t3 && t3.addToError(e3), this.error = e3, "CssSyntaxError" !== e3.name || e3.plugin ? r3.postcssVersion : (e3.plugin = r3.postcssPlugin, e3.setMessage());
      } catch (e4) {
        console && console.error;
      }
      return e3;
    }
    prepareVisitors() {
      this.listeners = {};
      let e3 = (e4, t3, r3) => {
        this.listeners[t3] || (this.listeners[t3] = []), this.listeners[t3].push([e4, r3]);
      };
      for (let t3 of this.plugins) if ("object" == typeof t3) for (let r3 in t3) {
        if (!f[r3] && /^[A-Z]/.test(r3)) throw new Error(`Unknown event ${r3} in ${t3.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
        if (!h[r3]) if ("object" == typeof t3[r3]) for (let n3 in t3[r3]) e3(t3, "*" === n3 ? r3 : r3 + "-" + n3.toLowerCase(), t3[r3][n3]);
        else "function" == typeof t3[r3] && e3(t3, r3, t3[r3]);
      }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let e3 = 0; e3 < this.plugins.length; e3++) {
        let t3 = this.plugins[e3], r3 = this.runOnRoot(t3);
        if (y(r3)) try {
          await r3;
        } catch (e4) {
          throw this.handleError(e4);
        }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e3 = this.result.root;
        for (; !e3[n2]; ) {
          e3[n2] = true;
          let t3 = [b(e3)];
          for (; t3.length > 0; ) {
            let e4 = this.visitTick(t3);
            if (y(e4)) try {
              await e4;
            } catch (e5) {
              let r3 = t3[t3.length - 1].node;
              throw this.handleError(e5, r3);
            }
          }
        }
        if (this.listeners.OnceExit) for (let [t3, r3] of this.listeners.OnceExit) {
          this.result.lastPlugin = t3;
          try {
            if ("document" === e3.type) {
              let t4 = e3.nodes.map((e4) => r3(e4, this.helpers));
              await Promise.all(t4);
            } else await r3(e3, this.helpers);
          } catch (e4) {
            throw this.handleError(e4);
          }
        }
      }
      return this.processed = true, this.stringify();
    }
    runOnRoot(e3) {
      this.result.lastPlugin = e3;
      try {
        if ("object" == typeof e3 && e3.Once) {
          if ("document" === this.result.root.type) {
            let t3 = this.result.root.nodes.map((t4) => e3.Once(t4, this.helpers));
            return y(t3[0]) ? Promise.all(t3) : t3;
          }
          return e3.Once(this.result.root, this.helpers);
        }
        if ("function" == typeof e3) return e3(this.result.root, this.result);
      } catch (e4) {
        throw this.handleError(e4);
      }
    }
    stringify() {
      if (this.error) throw this.error;
      if (this.stringified) return this.result;
      this.stringified = true, this.sync();
      let e3 = this.result.opts, t3 = o2;
      e3.syntax && (t3 = e3.syntax.stringify), e3.stringifier && (t3 = e3.stringifier), t3.stringify && (t3 = t3.stringify);
      let r3 = new i2(t3, this.result.root, this.result.opts).generate();
      return this.result.css = r3[0], this.result.map = r3[1], this.result;
    }
    sync() {
      if (this.error) throw this.error;
      if (this.processed) return this.result;
      if (this.processed = true, this.processing) throw this.getAsyncError();
      for (let e3 of this.plugins) if (y(this.runOnRoot(e3))) throw this.getAsyncError();
      if (this.prepareVisitors(), this.hasListener) {
        let e3 = this.result.root;
        for (; !e3[n2]; ) e3[n2] = true, this.walkSync(e3);
        if (this.listeners.OnceExit) if ("document" === e3.type) for (let t3 of e3.nodes) this.visitSync(this.listeners.OnceExit, t3);
        else this.visitSync(this.listeners.OnceExit, e3);
      }
      return this.result;
    }
    then(e3, t3) {
      return this.async().then(e3, t3);
    }
    toString() {
      return this.css;
    }
    visitSync(e3, t3) {
      for (let [r3, n3] of e3) {
        let e4;
        this.result.lastPlugin = r3;
        try {
          e4 = n3(t3, this.helpers);
        } catch (e5) {
          throw this.handleError(e5, t3.proxyOf);
        }
        if ("root" !== t3.type && "document" !== t3.type && !t3.parent) return true;
        if (y(e4)) throw this.getAsyncError();
      }
    }
    visitTick(e3) {
      let t3 = e3[e3.length - 1], { node: r3, visitors: s3 } = t3;
      if ("root" !== r3.type && "document" !== r3.type && !r3.parent) return void e3.pop();
      if (s3.length > 0 && t3.visitorIndex < s3.length) {
        let [e4, n3] = s3[t3.visitorIndex];
        t3.visitorIndex += 1, t3.visitorIndex === s3.length && (t3.visitors = [], t3.visitorIndex = 0), this.result.lastPlugin = e4;
        try {
          return n3(r3.toProxy(), this.helpers);
        } catch (e5) {
          throw this.handleError(e5, r3);
        }
      }
      if (0 !== t3.iterator) {
        let s4, i4 = t3.iterator;
        for (; s4 = r3.nodes[r3.indexes[i4]]; ) if (r3.indexes[i4] += 1, !s4[n2]) return s4[n2] = true, void e3.push(b(s4));
        t3.iterator = 0, delete r3.indexes[i4];
      }
      let i3 = t3.events;
      for (; t3.eventIndex < i3.length; ) {
        let e4 = i3[t3.eventIndex];
        if (t3.eventIndex += 1, e4 === m) return void (r3.nodes && r3.nodes.length && (r3[n2] = true, t3.iterator = r3.getIterator()));
        if (this.listeners[e4]) return void (t3.visitors = this.listeners[e4]);
      }
      e3.pop();
    }
    walkSync(e3) {
      e3[n2] = true;
      let t3 = g(e3);
      for (let r3 of t3) if (r3 === m) e3.nodes && e3.each((e4) => {
        e4[n2] || this.walkSync(e4);
      });
      else {
        let t4 = this.listeners[r3];
        if (t4 && this.visitSync(t4, e3.toProxy())) return;
      }
    }
    warnings() {
      return this.sync().warnings();
    }
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
  }
  S.registerPostcss = (e3) => {
    E = e3;
  }, e2.exports = S, S.default = S, p.registerLazyResult(S), l.registerLazyResult(S);
}, (e2, t2, r2) => {
  var n2 = r2(31).a;
  let { SourceMapConsumer: s2, SourceMapGenerator: i2 } = r2(149), { dirname: o2, relative: a2, resolve: l, sep: c } = r2(150), { pathToFileURL: u } = r2(318), p = r2(55), d = Boolean(s2 && i2), f = Boolean(o2 && l && a2 && c);
  e2.exports = class {
    constructor(e3, t3, r3, n3) {
      this.stringify = e3, this.mapOpts = r3.map || {}, this.root = t3, this.opts = r3, this.css = n3, this.originalCSS = n3, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
    }
    addAnnotation() {
      let e3;
      e3 = this.isInline() ? "data:application/json;base64," + this.toBase64(this.map.toString()) : "string" == typeof this.mapOpts.annotation ? this.mapOpts.annotation : "function" == typeof this.mapOpts.annotation ? this.mapOpts.annotation(this.opts.to, this.root) : this.outputFile() + ".map";
      let t3 = "\n";
      this.css.includes("\r\n") && (t3 = "\r\n"), this.css += t3 + "/*# sourceMappingURL=" + e3 + " */";
    }
    applyPrevMaps() {
      for (let e3 of this.previous()) {
        let t3, r3 = this.toUrl(this.path(e3.file)), n3 = e3.root || o2(e3.file);
        false === this.mapOpts.sourcesContent ? (t3 = new s2(e3.text), t3.sourcesContent && (t3.sourcesContent = t3.sourcesContent.map(() => null))) : t3 = e3.consumer(), this.map.applySourceMap(t3, r3, this.toUrl(this.path(n3)));
      }
    }
    clearAnnotation() {
      if (false !== this.mapOpts.annotation) if (this.root) {
        let e3;
        for (let t3 = this.root.nodes.length - 1; t3 >= 0; t3--) e3 = this.root.nodes[t3], "comment" === e3.type && 0 === e3.text.indexOf("# sourceMappingURL=") && this.root.removeChild(t3);
      } else this.css && (this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), f && d && this.isMap()) return this.generateMap();
      {
        let e3 = "";
        return this.stringify(this.root, (t3) => {
          e3 += t3;
        }), [e3];
      }
    }
    generateMap() {
      if (this.root) this.generateString();
      else if (1 === this.previous().length) {
        let e3 = this.previous()[0].consumer();
        e3.file = this.outputFile(), this.map = i2.fromSourceMap(e3);
      } else this.map = new i2({ file: this.outputFile() }), this.map.addMapping({ generated: { column: 0, line: 1 }, original: { column: 0, line: 1 }, source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>" });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new i2({ file: this.outputFile() });
      let e3, t3, r3 = 1, n3 = 1, s3 = "<no source>", o3 = { generated: { column: 0, line: 0 }, original: { column: 0, line: 0 }, source: "" };
      this.stringify(this.root, (i3, a3, l2) => {
        if (this.css += i3, a3 && "end" !== l2 && (o3.generated.line = r3, o3.generated.column = n3 - 1, a3.source && a3.source.start ? (o3.source = this.sourcePath(a3), o3.original.line = a3.source.start.line, o3.original.column = a3.source.start.column - 1, this.map.addMapping(o3)) : (o3.source = s3, o3.original.line = 1, o3.original.column = 0, this.map.addMapping(o3))), e3 = i3.match(/\n/g), e3 ? (r3 += e3.length, t3 = i3.lastIndexOf("\n"), n3 = i3.length - t3) : n3 += i3.length, a3 && "start" !== l2) {
          let e4 = a3.parent || { raws: {} };
          ("decl" === a3.type || "atrule" === a3.type && !a3.nodes) && a3 === e4.last && !e4.raws.semicolon || (a3.source && a3.source.end ? (o3.source = this.sourcePath(a3), o3.original.line = a3.source.end.line, o3.original.column = a3.source.end.column - 1, o3.generated.line = r3, o3.generated.column = n3 - 2, this.map.addMapping(o3)) : (o3.source = s3, o3.original.line = 1, o3.original.column = 0, o3.generated.line = r3, o3.generated.column = n3 - 1, this.map.addMapping(o3)));
        }
      });
    }
    isAnnotation() {
      return !!this.isInline() || (void 0 !== this.mapOpts.annotation ? this.mapOpts.annotation : !this.previous().length || this.previous().some((e3) => e3.annotation));
    }
    isInline() {
      if (void 0 !== this.mapOpts.inline) return this.mapOpts.inline;
      let e3 = this.mapOpts.annotation;
      return (void 0 === e3 || true === e3) && (!this.previous().length || this.previous().some((e4) => e4.inline));
    }
    isMap() {
      return void 0 !== this.opts.map ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return void 0 !== this.mapOpts.sourcesContent ? this.mapOpts.sourcesContent : !this.previous().length || this.previous().some((e3) => e3.withContent());
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(e3) {
      if (this.mapOpts.absolute) return e3;
      if (60 === e3.charCodeAt(0)) return e3;
      if (/^\w+:\/\//.test(e3)) return e3;
      let t3 = this.memoizedPaths.get(e3);
      if (t3) return t3;
      let r3 = this.opts.to ? o2(this.opts.to) : ".";
      "string" == typeof this.mapOpts.annotation && (r3 = o2(l(r3, this.mapOpts.annotation)));
      let n3 = a2(r3, e3);
      return this.memoizedPaths.set(e3, n3), n3;
    }
    previous() {
      if (!this.previousMaps) if (this.previousMaps = [], this.root) this.root.walk((e3) => {
        if (e3.source && e3.source.input.map) {
          let t3 = e3.source.input.map;
          this.previousMaps.includes(t3) || this.previousMaps.push(t3);
        }
      });
      else {
        let e3 = new p(this.originalCSS, this.opts);
        e3.map && this.previousMaps.push(e3.map);
      }
      return this.previousMaps;
    }
    setSourcesContent() {
      let e3 = {};
      if (this.root) this.root.walk((t3) => {
        if (t3.source) {
          let r3 = t3.source.input.from;
          if (r3 && !e3[r3]) {
            e3[r3] = true;
            let n3 = this.usesFileUrls ? this.toFileUrl(r3) : this.toUrl(this.path(r3));
            this.map.setSourceContent(n3, t3.source.input.css);
          }
        }
      });
      else if (this.css) {
        let e4 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(e4, this.css);
      }
    }
    sourcePath(e3) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e3.source.input.from) : this.toUrl(this.path(e3.source.input.from));
    }
    toBase64(e3) {
      return n2 ? n2.from(e3).toString("base64") : window.btoa(unescape(encodeURIComponent(e3)));
    }
    toFileUrl(e3) {
      let t3 = this.memoizedFileURLs.get(e3);
      if (t3) return t3;
      if (u) {
        let t4 = u(e3).toString();
        return this.memoizedFileURLs.set(e3, t4), t4;
      }
      throw new Error("`map.absolute` option is not available in this PostCSS build");
    }
    toUrl(e3) {
      let t3 = this.memoizedURLs.get(e3);
      if (t3) return t3;
      "\\" === c && (e3 = e3.replace(/\\/g, "/"));
      let r3 = encodeURI(e3).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(e3, r3), r3;
    }
  };
}, () => {
}, () => {
}, (e2, t2, r2) => {
  var n2 = r2(31).a;
  let { SourceMapConsumer: s2, SourceMapGenerator: i2 } = r2(149), { existsSync: o2, readFileSync: a2 } = r2(512), { dirname: l, join: c } = r2(150);
  class u {
    constructor(e3, t3) {
      if (false === t3.map) return;
      this.loadAnnotation(e3), this.inline = this.startWith(this.annotation, "data:");
      let r3 = t3.map ? t3.map.prev : void 0, n3 = this.loadMap(t3.from, r3);
      !this.mapFile && t3.from && (this.mapFile = t3.from), this.mapFile && (this.root = l(this.mapFile)), n3 && (this.text = n3);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new s2(this.text)), this.consumerCache;
    }
    decodeInline(e3) {
      if (/^data:application\/json;charset=utf-?8,/.test(e3) || /^data:application\/json,/.test(e3)) return decodeURIComponent(e3.substr(RegExp.lastMatch.length));
      if (/^data:application\/json;charset=utf-?8;base64,/.test(e3) || /^data:application\/json;base64,/.test(e3)) return t3 = e3.substr(RegExp.lastMatch.length), n2 ? n2.from(t3, "base64").toString() : window.atob(t3);
      var t3;
      let r3 = e3.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + r3);
    }
    getAnnotationURL(e3) {
      return e3.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(e3) {
      return "object" == typeof e3 && ("string" == typeof e3.mappings || "string" == typeof e3._mappings || Array.isArray(e3.sections));
    }
    loadAnnotation(e3) {
      let t3 = e3.match(/\/\*\s*# sourceMappingURL=/gm);
      if (!t3) return;
      let r3 = e3.lastIndexOf(t3.pop()), n3 = e3.indexOf("*/", r3);
      r3 > -1 && n3 > -1 && (this.annotation = this.getAnnotationURL(e3.substring(r3, n3)));
    }
    loadFile(e3) {
      if (this.root = l(e3), o2(e3)) return this.mapFile = e3, a2(e3, "utf-8").toString().trim();
    }
    loadMap(e3, t3) {
      if (false === t3) return false;
      if (t3) {
        if ("string" == typeof t3) return t3;
        if ("function" != typeof t3) {
          if (t3 instanceof s2) return i2.fromSourceMap(t3).toString();
          if (t3 instanceof i2) return t3.toString();
          if (this.isMap(t3)) return JSON.stringify(t3);
          throw new Error("Unsupported previous source map format: " + t3.toString());
        }
        {
          let r3 = t3(e3);
          if (r3) {
            let e4 = this.loadFile(r3);
            if (!e4) throw new Error("Unable to load previous source map: " + r3.toString());
            return e4;
          }
        }
      } else {
        if (this.inline) return this.decodeInline(this.annotation);
        if (this.annotation) {
          let t4 = this.annotation;
          return e3 && (t4 = c(l(e3), t4)), this.loadFile(t4);
        }
      }
    }
    startWith(e3, t3) {
      return !!e3 && e3.substr(0, t3.length) === t3;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  }
  e2.exports = u, u.default = u;
}, (e2) => {
  let t2 = {};
  e2.exports = function(e3) {
    t2[e3] || (t2[e3] = true, "undefined" != typeof console && console.warn);
  };
}, (e2) => {
  class t2 {
    constructor(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      if (this.type = "warning", this.text = e3, t3.node && t3.node.source) {
        let e4 = t3.node.rangeBy(t3);
        this.line = e4.start.line, this.column = e4.start.column, this.endLine = e4.end.line, this.endColumn = e4.end.column;
      }
      for (let e4 in t3) this[e4] = t3[e4];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  }
  e2.exports = t2, t2.default = t2;
}, (e2) => {
  let t2 = { comma: (e3) => t2.split(e3, [","], true), space: (e3) => t2.split(e3, [" ", "\n", "	"]), split(e3, t3, r2) {
    let n2 = [], s2 = "", i2 = false, o2 = 0, a2 = false, l = "", c = false;
    for (let r3 of e3) c ? c = false : "\\" === r3 ? c = true : a2 ? r3 === l && (a2 = false) : '"' === r3 || "'" === r3 ? (a2 = true, l = r3) : "(" === r3 ? o2 += 1 : ")" === r3 ? o2 > 0 && (o2 -= 1) : 0 === o2 && t3.includes(r3) && (i2 = true), i2 ? ("" !== s2 && n2.push(s2.trim()), s2 = "", i2 = false) : s2 += r3;
    return (r2 || "" !== s2) && n2.push(s2.trim()), n2;
  } };
  e2.exports = t2, t2.default = t2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true });
  var n2 = r2(412);
  Object.keys(n2).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === n2[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return n2[e3];
    } }));
  });
  var s2 = r2(413);
  Object.keys(s2).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === s2[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return s2[e3];
    } }));
  });
  var i2 = r2(414);
  Object.keys(i2).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === i2[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return i2[e3];
    } }));
  });
  var o2 = r2(415);
  Object.keys(o2).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === o2[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return o2[e3];
    } }));
  });
  var a2 = r2(416);
  Object.keys(a2).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === a2[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return a2[e3];
    } }));
  });
  var l = r2(185);
  Object.keys(l).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === l[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return l[e3];
    } }));
  });
  var c = r2(186);
  Object.keys(c).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === c[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return c[e3];
    } }));
  });
  var u = r2(419);
  Object.keys(u).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === u[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return u[e3];
    } }));
  });
  var p = r2(420);
  Object.keys(p).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === p[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return p[e3];
    } }));
  });
  var d = r2(421);
  Object.keys(d).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === d[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return d[e3];
    } }));
  });
  var f = r2(422);
  Object.keys(f).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === f[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return f[e3];
    } }));
  });
}, function(e2, t2, r2) {
  var n2 = this && this.__createBinding || (Object.create ? function(e3, t3, r3, n3) {
    void 0 === n3 && (n3 = r3);
    var s3 = Object.getOwnPropertyDescriptor(t3, r3);
    s3 && !("get" in s3 ? !t3.__esModule : s3.writable || s3.configurable) || (s3 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, n3, s3);
  } : function(e3, t3, r3, n3) {
    void 0 === n3 && (n3 = r3), e3[n3] = t3[r3];
  }), s2 = this && this.__setModuleDefault || (Object.create ? function(e3, t3) {
    Object.defineProperty(e3, "default", { enumerable: true, value: t3 });
  } : function(e3, t3) {
    e3.default = t3;
  }), i2 = this && this.__importStar || function(e3) {
    if (e3 && e3.__esModule) return e3;
    var t3 = {};
    if (null != e3) for (var r3 in e3) "default" !== r3 && Object.prototype.hasOwnProperty.call(e3, r3) && n2(t3, e3, r3);
    return s2(t3, e3), t3;
  }, o2 = this && this.__importDefault || function(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  };
  Object.defineProperty(t2, "__esModule", { value: true }), t2.decodeXML = t2.decodeHTMLStrict = t2.decodeHTMLAttribute = t2.decodeHTML = t2.determineBranch = t2.EntityDecoder = t2.DecodingMode = t2.BinTrieFlags = t2.fromCodePoint = t2.replaceCodePoint = t2.decodeCodePoint = t2.xmlDecodeTree = t2.htmlDecodeTree = void 0;
  var a2 = o2(r2(504));
  t2.htmlDecodeTree = a2.default;
  var l = o2(r2(505));
  t2.xmlDecodeTree = l.default;
  var c = i2(r2(160));
  t2.decodeCodePoint = c.default;
  var u, p, d, f, h = r2(160);
  function m(e3) {
    return e3 >= u.ZERO && e3 <= u.NINE;
  }
  Object.defineProperty(t2, "replaceCodePoint", { enumerable: true, get: function() {
    return h.replaceCodePoint;
  } }), Object.defineProperty(t2, "fromCodePoint", { enumerable: true, get: function() {
    return h.fromCodePoint;
  } }), function(e3) {
    e3[e3.NUM = 35] = "NUM", e3[e3.SEMI = 59] = "SEMI", e3[e3.EQUALS = 61] = "EQUALS", e3[e3.ZERO = 48] = "ZERO", e3[e3.NINE = 57] = "NINE", e3[e3.LOWER_A = 97] = "LOWER_A", e3[e3.LOWER_F = 102] = "LOWER_F", e3[e3.LOWER_X = 120] = "LOWER_X", e3[e3.LOWER_Z = 122] = "LOWER_Z", e3[e3.UPPER_A = 65] = "UPPER_A", e3[e3.UPPER_F = 70] = "UPPER_F", e3[e3.UPPER_Z = 90] = "UPPER_Z";
  }(u || (u = {})), function(e3) {
    e3[e3.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e3[e3.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e3[e3.JUMP_TABLE = 127] = "JUMP_TABLE";
  }(p = t2.BinTrieFlags || (t2.BinTrieFlags = {})), function(e3) {
    e3[e3.EntityStart = 0] = "EntityStart", e3[e3.NumericStart = 1] = "NumericStart", e3[e3.NumericDecimal = 2] = "NumericDecimal", e3[e3.NumericHex = 3] = "NumericHex", e3[e3.NamedEntity = 4] = "NamedEntity";
  }(d || (d = {})), function(e3) {
    e3[e3.Legacy = 0] = "Legacy", e3[e3.Strict = 1] = "Strict", e3[e3.Attribute = 2] = "Attribute";
  }(f = t2.DecodingMode || (t2.DecodingMode = {}));
  var y = function() {
    function e3(e4, t3, r3) {
      this.decodeTree = e4, this.emitCodePoint = t3, this.errors = r3, this.state = d.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = f.Strict;
    }
    return e3.prototype.startEntity = function(e4) {
      this.decodeMode = e4, this.state = d.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
    }, e3.prototype.write = function(e4, t3) {
      switch (this.state) {
        case d.EntityStart:
          return e4.charCodeAt(t3) === u.NUM ? (this.state = d.NumericStart, this.consumed += 1, this.stateNumericStart(e4, t3 + 1)) : (this.state = d.NamedEntity, this.stateNamedEntity(e4, t3));
        case d.NumericStart:
          return this.stateNumericStart(e4, t3);
        case d.NumericDecimal:
          return this.stateNumericDecimal(e4, t3);
        case d.NumericHex:
          return this.stateNumericHex(e4, t3);
        case d.NamedEntity:
          return this.stateNamedEntity(e4, t3);
      }
    }, e3.prototype.stateNumericStart = function(e4, t3) {
      return t3 >= e4.length ? -1 : (32 | e4.charCodeAt(t3)) === u.LOWER_X ? (this.state = d.NumericHex, this.consumed += 1, this.stateNumericHex(e4, t3 + 1)) : (this.state = d.NumericDecimal, this.stateNumericDecimal(e4, t3));
    }, e3.prototype.addToNumericResult = function(e4, t3, r3, n3) {
      if (t3 !== r3) {
        var s3 = r3 - t3;
        this.result = this.result * Math.pow(n3, s3) + parseInt(e4.substr(t3, s3), n3), this.consumed += s3;
      }
    }, e3.prototype.stateNumericHex = function(e4, t3) {
      for (var r3, n3 = t3; t3 < e4.length; ) {
        var s3 = e4.charCodeAt(t3);
        if (!(m(s3) || (r3 = s3, r3 >= u.UPPER_A && r3 <= u.UPPER_F || r3 >= u.LOWER_A && r3 <= u.LOWER_F))) return this.addToNumericResult(e4, n3, t3, 16), this.emitNumericEntity(s3, 3);
        t3 += 1;
      }
      return this.addToNumericResult(e4, n3, t3, 16), -1;
    }, e3.prototype.stateNumericDecimal = function(e4, t3) {
      for (var r3 = t3; t3 < e4.length; ) {
        var n3 = e4.charCodeAt(t3);
        if (!m(n3)) return this.addToNumericResult(e4, r3, t3, 10), this.emitNumericEntity(n3, 2);
        t3 += 1;
      }
      return this.addToNumericResult(e4, r3, t3, 10), -1;
    }, e3.prototype.emitNumericEntity = function(e4, t3) {
      var r3;
      if (this.consumed <= t3) return null === (r3 = this.errors) || void 0 === r3 || r3.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      if (e4 === u.SEMI) this.consumed += 1;
      else if (this.decodeMode === f.Strict) return 0;
      return this.emitCodePoint((0, c.replaceCodePoint)(this.result), this.consumed), this.errors && (e4 !== u.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
    }, e3.prototype.stateNamedEntity = function(e4, t3) {
      for (var r3 = this.decodeTree, n3 = r3[this.treeIndex], s3 = (n3 & p.VALUE_LENGTH) >> 14; t3 < e4.length; t3++, this.excess++) {
        var i3 = e4.charCodeAt(t3);
        if (this.treeIndex = b(r3, n3, this.treeIndex + Math.max(1, s3), i3), this.treeIndex < 0) return 0 === this.result || this.decodeMode === f.Attribute && (0 === s3 || ((o3 = i3) === u.EQUALS || function(e5) {
          return e5 >= u.UPPER_A && e5 <= u.UPPER_Z || e5 >= u.LOWER_A && e5 <= u.LOWER_Z || m(e5);
        }(o3))) ? 0 : this.emitNotTerminatedNamedEntity();
        if (0 != (s3 = ((n3 = r3[this.treeIndex]) & p.VALUE_LENGTH) >> 14)) {
          if (i3 === u.SEMI) return this.emitNamedEntityData(this.treeIndex, s3, this.consumed + this.excess);
          this.decodeMode !== f.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
        }
      }
      var o3;
      return -1;
    }, e3.prototype.emitNotTerminatedNamedEntity = function() {
      var e4, t3 = this.result, r3 = (this.decodeTree[t3] & p.VALUE_LENGTH) >> 14;
      return this.emitNamedEntityData(t3, r3, this.consumed), null === (e4 = this.errors) || void 0 === e4 || e4.missingSemicolonAfterCharacterReference(), this.consumed;
    }, e3.prototype.emitNamedEntityData = function(e4, t3, r3) {
      var n3 = this.decodeTree;
      return this.emitCodePoint(1 === t3 ? n3[e4] & ~p.VALUE_LENGTH : n3[e4 + 1], r3), 3 === t3 && this.emitCodePoint(n3[e4 + 2], r3), r3;
    }, e3.prototype.end = function() {
      var e4;
      switch (this.state) {
        case d.NamedEntity:
          return 0 === this.result || this.decodeMode === f.Attribute && this.result !== this.treeIndex ? 0 : this.emitNotTerminatedNamedEntity();
        case d.NumericDecimal:
          return this.emitNumericEntity(0, 2);
        case d.NumericHex:
          return this.emitNumericEntity(0, 3);
        case d.NumericStart:
          return null === (e4 = this.errors) || void 0 === e4 || e4.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
        case d.EntityStart:
          return 0;
      }
    }, e3;
  }();
  function g(e3) {
    var t3 = "", r3 = new y(e3, function(e4) {
      return t3 += (0, c.fromCodePoint)(e4);
    });
    return function(e4, n3) {
      for (var s3 = 0, i3 = 0; (i3 = e4.indexOf("&", i3)) >= 0; ) {
        t3 += e4.slice(s3, i3), r3.startEntity(n3);
        var o3 = r3.write(e4, i3 + 1);
        if (o3 < 0) {
          s3 = i3 + r3.end();
          break;
        }
        s3 = i3 + o3, i3 = 0 === o3 ? s3 + 1 : s3;
      }
      var a3 = t3 + e4.slice(s3);
      return t3 = "", a3;
    };
  }
  function b(e3, t3, r3, n3) {
    var s3 = (t3 & p.BRANCH_LENGTH) >> 7, i3 = t3 & p.JUMP_TABLE;
    if (0 === s3) return 0 !== i3 && n3 === i3 ? r3 : -1;
    if (i3) {
      var o3 = n3 - i3;
      return o3 < 0 || o3 >= s3 ? -1 : e3[r3 + o3] - 1;
    }
    for (var a3 = r3, l2 = a3 + s3 - 1; a3 <= l2; ) {
      var c2 = a3 + l2 >>> 1, u2 = e3[c2];
      if (u2 < n3) a3 = c2 + 1;
      else {
        if (!(u2 > n3)) return e3[c2 + s3];
        l2 = c2 - 1;
      }
    }
    return -1;
  }
  t2.EntityDecoder = y, t2.determineBranch = b;
  var v = g(a2.default), E = g(l.default);
  t2.decodeHTML = function(e3, t3) {
    return void 0 === t3 && (t3 = f.Legacy), v(e3, t3);
  }, t2.decodeHTMLAttribute = function(e3) {
    return v(e3, f.Attribute);
  }, t2.decodeHTMLStrict = function(e3) {
    return v(e3, f.Strict);
  }, t2.decodeXML = function(e3) {
    return E(e3, f.Strict);
  };
}, function(e2, t2, r2) {
  var n2;
  e2 = r2.nmd(e2), function(s2) {
    t2 && t2.nodeType, e2 && e2.nodeType;
    var i2 = "object" == typeof r2.g && r2.g;
    i2.global !== i2 && i2.window !== i2 && i2.self;
    var o2, a2 = 2147483647, l = 36, c = 26, u = 38, p = 700, d = /^xn--/, f = /[^\x20-\x7E]/, h = /[\x2E\u3002\uFF0E\uFF61]/g, m = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, y = l - 1, g = Math.floor, b = String.fromCharCode;
    function v(e3) {
      throw new RangeError(m[e3]);
    }
    function E(e3, t3) {
      for (var r3 = e3.length, n3 = []; r3--; ) n3[r3] = t3(e3[r3]);
      return n3;
    }
    function S(e3, t3) {
      var r3 = e3.split("@"), n3 = "";
      return r3.length > 1 && (n3 = r3[0] + "@", e3 = r3[1]), n3 + E((e3 = e3.replace(h, ".")).split("."), t3).join(".");
    }
    function x(e3) {
      for (var t3, r3, n3 = [], s3 = 0, i3 = e3.length; s3 < i3; ) (t3 = e3.charCodeAt(s3++)) >= 55296 && t3 <= 56319 && s3 < i3 ? 56320 == (64512 & (r3 = e3.charCodeAt(s3++))) ? n3.push(((1023 & t3) << 10) + (1023 & r3) + 65536) : (n3.push(t3), s3--) : n3.push(t3);
      return n3;
    }
    function T(e3) {
      return E(e3, function(e4) {
        var t3 = "";
        return e4 > 65535 && (t3 += b((e4 -= 65536) >>> 10 & 1023 | 55296), e4 = 56320 | 1023 & e4), t3 + b(e4);
      }).join("");
    }
    function w(e3, t3) {
      return e3 + 22 + 75 * (e3 < 26) - ((0 != t3) << 5);
    }
    function P(e3, t3, r3) {
      var n3 = 0;
      for (e3 = r3 ? g(e3 / p) : e3 >> 1, e3 += g(e3 / t3); e3 > y * c >> 1; n3 += l) e3 = g(e3 / y);
      return g(n3 + (y + 1) * e3 / (e3 + u));
    }
    function A(e3) {
      var t3, r3, n3, s3, i3, o3, u2, p2, d2, f2, h2, m2 = [], y2 = e3.length, b2 = 0, E2 = 128, S2 = 72;
      for ((r3 = e3.lastIndexOf("-")) < 0 && (r3 = 0), n3 = 0; n3 < r3; ++n3) e3.charCodeAt(n3) >= 128 && v("not-basic"), m2.push(e3.charCodeAt(n3));
      for (s3 = r3 > 0 ? r3 + 1 : 0; s3 < y2; ) {
        for (i3 = b2, o3 = 1, u2 = l; s3 >= y2 && v("invalid-input"), ((p2 = (h2 = e3.charCodeAt(s3++)) - 48 < 10 ? h2 - 22 : h2 - 65 < 26 ? h2 - 65 : h2 - 97 < 26 ? h2 - 97 : l) >= l || p2 > g((a2 - b2) / o3)) && v("overflow"), b2 += p2 * o3, !(p2 < (d2 = u2 <= S2 ? 1 : u2 >= S2 + c ? c : u2 - S2)); u2 += l) o3 > g(a2 / (f2 = l - d2)) && v("overflow"), o3 *= f2;
        S2 = P(b2 - i3, t3 = m2.length + 1, 0 == i3), g(b2 / t3) > a2 - E2 && v("overflow"), E2 += g(b2 / t3), b2 %= t3, m2.splice(b2++, 0, E2);
      }
      return T(m2);
    }
    function C(e3) {
      var t3, r3, n3, s3, i3, o3, u2, p2, d2, f2, h2, m2, y2, E2, S2, T2 = [];
      for (m2 = (e3 = x(e3)).length, t3 = 128, r3 = 0, i3 = 72, o3 = 0; o3 < m2; ++o3) (h2 = e3[o3]) < 128 && T2.push(b(h2));
      for (n3 = s3 = T2.length, s3 && T2.push("-"); n3 < m2; ) {
        for (u2 = a2, o3 = 0; o3 < m2; ++o3) (h2 = e3[o3]) >= t3 && h2 < u2 && (u2 = h2);
        for (u2 - t3 > g((a2 - r3) / (y2 = n3 + 1)) && v("overflow"), r3 += (u2 - t3) * y2, t3 = u2, o3 = 0; o3 < m2; ++o3) if ((h2 = e3[o3]) < t3 && ++r3 > a2 && v("overflow"), h2 == t3) {
          for (p2 = r3, d2 = l; !(p2 < (f2 = d2 <= i3 ? 1 : d2 >= i3 + c ? c : d2 - i3)); d2 += l) S2 = p2 - f2, E2 = l - f2, T2.push(b(w(f2 + S2 % E2, 0))), p2 = g(S2 / E2);
          T2.push(b(w(p2, 0))), i3 = P(r3, y2, n3 == s3), r3 = 0, ++n3;
        }
        ++r3, ++t3;
      }
      return T2.join("");
    }
    o2 = { version: "1.4.1", ucs2: { decode: x, encode: T }, decode: A, encode: C, toASCII: function(e3) {
      return S(e3, function(e4) {
        return f.test(e4) ? "xn--" + C(e4) : e4;
      });
    }, toUnicode: function(e3) {
      return S(e3, function(e4) {
        return d.test(e4) ? A(e4.slice(4).toLowerCase()) : e4;
      });
    } }, void 0 === (n2 = (function() {
      return o2;
    }).call(t2, r2, t2, e2)) || (e2.exports = n2);
  }();
}, (e2) => {
  "function" == typeof Object.create ? e2.exports = function(e3, t2) {
    t2 && (e3.super_ = t2, e3.prototype = Object.create(t2.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } }));
  } : e2.exports = function(e3, t2) {
    if (t2) {
      e3.super_ = t2;
      var r2 = function() {
      };
      r2.prototype = t2.prototype, e3.prototype = new r2(), e3.prototype.constructor = e3;
    }
  };
}, function(e2, t2, r2) {
  e2.exports = function(e3, t3) {
    const r3 = s2("", -1, -1, "", null), n2 = [];
    function s2(e4, t4, r4, n3, s3) {
      return { source: e4, line: t4, column: r4, name: n3, content: s3 };
    }
    function i2(e4, t4, r4, n3) {
      return { map: e4, sources: t4, source: r4, content: n3 };
    }
    function o2(e4, t4) {
      return i2(e4, t4, "", null);
    }
    function a2(t4, n3, i3, o3) {
      if (!t4.map) return s2(t4.source, n3, i3, o3, t4.content);
      const l2 = e3.traceSegment(t4.map, n3, i3);
      return null == l2 ? null : 1 === l2.length ? r3 : a2(t4.sources[l2[1]], l2[2], l2[3], 5 === l2.length ? t4.map.names[l2[4]] : o3);
    }
    function l(t4, r4) {
      const n3 = (i3 = t4, Array.isArray(i3) ? i3 : [i3]).map((t5) => new e3.TraceMap(t5, "")), s3 = n3.pop();
      var i3;
      for (let e4 = 0; e4 < n3.length; e4++) if (n3[e4].sources.length > 1) throw new Error(`Transformation map ${e4} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
      let a3 = c(s3, r4, "", 0);
      for (let e4 = n3.length - 1; e4 >= 0; e4--) a3 = o2(n3[e4], [a3]);
      return a3;
    }
    function c(t4, r4, s3, a3) {
      const { resolvedSources: l2, sourcesContent: u2 } = t4, p = a3 + 1;
      return o2(t4, l2.map((t5, o3) => {
        const a4 = { importer: s3, depth: p, source: t5 || "", content: void 0 }, l3 = r4(a4.source, a4), { source: d, content: f } = a4;
        return l3 ? c(new e3.TraceMap(l3, d), r4, d, p) : function(e4, t6) {
          return i2(null, n2, e4, t6);
        }(d, void 0 !== f ? f : u2 ? u2[o3] : null);
      }));
    }
    class u {
      constructor(e4, r4) {
        const n3 = r4.decodedMappings ? t3.toDecodedMap(e4) : t3.toEncodedMap(e4);
        this.version = n3.version, this.file = n3.file, this.mappings = n3.mappings, this.names = n3.names, this.sourceRoot = n3.sourceRoot, this.sources = n3.sources, r4.excludeContent || (this.sourcesContent = n3.sourcesContent);
      }
      toString() {
        return JSON.stringify(this);
      }
    }
    return function(n3, s3, i3) {
      const o3 = "object" == typeof i3 ? i3 : { excludeContent: !!i3, decodedMappings: false }, c2 = l(n3, s3);
      return new u(function(n4) {
        const s4 = new t3.GenMapping({ file: n4.map.file }), { sources: i4, map: o4 } = n4, l2 = o4.names, c3 = e3.decodedMappings(o4);
        for (let e4 = 0; e4 < c3.length; e4++) {
          const n5 = c3[e4];
          for (let o5 = 0; o5 < n5.length; o5++) {
            const c4 = n5[o5], u2 = c4[0];
            let p = r3;
            if (1 !== c4.length && (p = a2(i4[c4[1]], c4[2], c4[3], 5 === c4.length ? l2[c4[4]] : ""), null == p)) continue;
            const { column: d, line: f, name: h, content: m, source: y } = p;
            t3.maybeAddSegment(s4, e4, u2, y, f, d, h), y && null != m && t3.setSourceContent(s4, y, m);
          }
        }
        return s4;
      }(c2), o3);
    };
  }(r2(486), r2(487));
}, (e2, t2) => {
  var r2;
  Object.defineProperty(t2, "__esModule", { value: true }), t2.replaceCodePoint = t2.fromCodePoint = void 0;
  var n2 = /* @__PURE__ */ new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]);
  function s2(e3) {
    var t3;
    return e3 >= 55296 && e3 <= 57343 || e3 > 1114111 ? 65533 : null !== (t3 = n2.get(e3)) && void 0 !== t3 ? t3 : e3;
  }
  t2.fromCodePoint = null !== (r2 = String.fromCodePoint) && void 0 !== r2 ? r2 : function(e3) {
    var t3 = "";
    return e3 > 65535 && (e3 -= 65536, t3 += String.fromCharCode(e3 >>> 10 & 1023 | 55296), e3 = 56320 | 1023 & e3), t3 + String.fromCharCode(e3);
  }, t2.replaceCodePoint = s2, t2.default = function(e3) {
    return (0, t2.fromCodePoint)(s2(e3));
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.ensure = function(e3, t3) {
    d || (d = t3), m(e3);
  }, t2.get = y, t2.getDependencies = function(e3) {
    return m(e3).getDependencies();
  }, t2.list = void 0, t2.minVersion = function(e3) {
    return m(e3).minVersion;
  };
  var n2 = r2(14), s2 = r2(0), i2 = r2(445);
  const { assignmentExpression: o2, cloneNode: a2, expressionStatement: l, file: c, identifier: u } = s2;
  function p(e3) {
    const t3 = [];
    for (; e3.parentPath; e3 = e3.parentPath) t3.push(e3.key), e3.inList && t3.push(e3.listKey);
    return t3.reverse().join(".");
  }
  let d;
  function f(e3) {
    const t3 = /* @__PURE__ */ new Set(), r3 = /* @__PURE__ */ new Set(), s3 = /* @__PURE__ */ new Map();
    let o3, a3;
    const l2 = [], c2 = [], u2 = [], d2 = { ImportDeclaration(e4) {
      const t4 = e4.node.source.value;
      if (!i2.default[t4]) throw e4.buildCodeFrameError(`Unknown helper ${t4}`);
      if (1 !== e4.get("specifiers").length || !e4.get("specifiers.0").isImportDefaultSpecifier()) throw e4.buildCodeFrameError("Helpers can only import a default value");
      const r4 = e4.node.specifiers[0].local;
      s3.set(r4, t4), c2.push(p(e4));
    }, ExportDefaultDeclaration(e4) {
      const t4 = e4.get("declaration");
      if (!t4.isFunctionDeclaration() || !t4.node.id) throw t4.buildCodeFrameError("Helpers can only export named function declarations");
      o3 = t4.node.id.name, a3 = p(e4);
    }, ExportAllDeclaration(e4) {
      throw e4.buildCodeFrameError("Helpers can only export default");
    }, ExportNamedDeclaration(e4) {
      throw e4.buildCodeFrameError("Helpers can only export default");
    }, Statement(e4) {
      e4.isImportDeclaration() || e4.isExportDeclaration() || e4.skip();
    } }, f2 = { Program(e4) {
      const t4 = e4.scope.getAllBindings();
      Object.keys(t4).forEach((e5) => {
        e5 !== o3 && (s3.has(t4[e5].identifier) || r3.add(e5));
      });
    }, ReferencedIdentifier(e4) {
      const r4 = e4.node.name, n3 = e4.scope.getBinding(r4);
      n3 ? s3.has(n3.identifier) && u2.push(p(e4)) : t3.add(r4);
    }, AssignmentExpression(e4) {
      const t4 = e4.get("left");
      if (!(o3 in t4.getBindingIdentifiers())) return;
      if (!t4.isIdentifier()) throw t4.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
      const r4 = e4.scope.getBinding(o3);
      null != r4 && r4.scope.path.isProgram() && l2.push(p(e4));
    } };
    if ((0, n2.default)(e3.ast, d2, e3.scope), (0, n2.default)(e3.ast, f2, e3.scope), !a3) throw new Error("Helpers must have a default export.");
    return l2.reverse(), { globals: Array.from(t3), localBindingNames: Array.from(r3), dependencies: s3, exportBindingAssignments: l2, exportPath: a3, exportName: o3, importBindingsReferences: u2, importPaths: c2 };
  }
  const h = /* @__PURE__ */ Object.create(null);
  function m(e3) {
    if (!h[e3]) {
      const t3 = i2.default[e3];
      if (!t3) throw Object.assign(new ReferenceError(`Unknown helper ${e3}`), { code: "BABEL_HELPER_UNKNOWN", helper: e3 });
      const r3 = () => {
        if (!d) {
          const e4 = { ast: c(t3.ast()), path: null };
          return (0, n2.default)(e4.ast, { Program: (t4) => (e4.path = t4).stop() }), e4;
        }
        return new d({ filename: `babel-helper://${e3}` }, { ast: c(t3.ast()), code: "[internal Babel helper code]", inputMap: null });
      };
      let s3 = null;
      h[e3] = { minVersion: t3.minVersion, build(e4, t4, n3) {
        const i3 = r3();
        return s3 || (s3 = f(i3)), function(e5, t5, r4, n4, s4) {
          if (n4 && !r4) throw new Error("Unexpected local bindings for module-based helpers.");
          if (!r4) return;
          const { localBindingNames: i4, dependencies: c2, exportBindingAssignments: p2, exportPath: d2, exportName: f2, importBindingsReferences: h2, importPaths: m2 } = t5, y2 = {};
          c2.forEach((e6, t6) => {
            y2[t6.name] = "function" == typeof s4 && s4(e6) || t6;
          });
          const g = {}, b = new Set(n4 || []);
          "Identifier" === r4.type && b.add(r4.name), i4.forEach((e6) => {
            let t6 = e6;
            for (; b.has(t6); ) t6 = "_" + t6;
            t6 !== e6 && (g[e6] = t6);
          }), "Identifier" === r4.type && f2 !== r4.name && (g[f2] = r4.name);
          const { path: v } = e5, E = v.get(d2), S = m2.map((e6) => v.get(e6)), x = h2.map((e6) => v.get(e6)), T = E.get("declaration");
          if ("Identifier" === r4.type) E.replaceWith(T);
          else {
            if ("MemberExpression" !== r4.type) throw new Error("Unexpected helper format.");
            p2.forEach((e6) => {
              const t6 = v.get(e6);
              t6.replaceWith(o2("=", r4, t6.node));
            }), E.replaceWith(T), v.pushContainer("body", l(o2("=", r4, u(f2))));
          }
          Object.keys(g).forEach((e6) => {
            v.scope.rename(e6, g[e6]);
          });
          for (const e6 of S) e6.remove();
          for (const e6 of x) {
            const t6 = a2(y2[e6.node.name]);
            e6.replaceWith(t6);
          }
        }(i3, s3, t4, n3, e4), { nodes: i3.ast.program.body, globals: s3.globals };
      }, getDependencies: () => (s3 || (s3 = f(r3())), Array.from(s3.dependencies.values())) };
    }
    return h[e3];
  }
  function y(e3, t3, r3, n3) {
    return m(e3).build(t3, r3, n3);
  }
  t2.list = Object.keys(i2.default).map((e3) => e3.replace(/^_/, "")), t2.default = y;
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.Var = t2.User = t2.Statement = t2.SpreadProperty = t2.Scope = t2.RestProperty = t2.ReferencedMemberExpression = t2.ReferencedIdentifier = t2.Referenced = t2.Pure = t2.NumericLiteralTypeAnnotation = t2.Generated = t2.ForAwaitStatement = t2.Flow = t2.Expression = t2.ExistentialTypeParam = t2.BlockScoped = t2.BindingIdentifier = void 0, t2.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], t2.ReferencedMemberExpression = ["MemberExpression"], t2.BindingIdentifier = ["Identifier"], t2.Statement = ["Statement"], t2.Expression = ["Expression"], t2.Scope = ["Scopable", "Pattern"], t2.Referenced = null, t2.BlockScoped = null, t2.Var = ["VariableDeclaration"], t2.User = null, t2.Generated = null, t2.Pure = null, t2.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], t2.RestProperty = ["RestElement"], t2.SpreadProperty = ["RestElement"], t2.ExistentialTypeParam = ["ExistsTypeAnnotation"], t2.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"], t2.ForAwaitStatement = ["ForOfStatement"];
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isBindingIdentifier = function() {
    const { node: e3, parent: t3 } = this, r3 = this.parentPath.parent;
    return p(e3) && s2(e3, t3, r3);
  }, t2.isBlockScoped = function() {
    return i2(this.node);
  }, t2.isExpression = function() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : a2(this.node);
  }, t2.isFlow = function() {
    const { node: e3 } = this;
    return !(!l(e3) && (d(e3) ? "type" !== e3.importKind && "typeof" !== e3.importKind : o2(e3) ? "type" !== e3.exportKind : !f(e3) || "type" !== e3.importKind && "typeof" !== e3.importKind));
  }, t2.isForAwaitStatement = function() {
    return w(this.node, { await: true });
  }, t2.isGenerated = function() {
    return !this.isUser();
  }, t2.isPure = function(e3) {
    return this.scope.isPure(this.node, e3);
  }, t2.isReferenced = function() {
    return b(this.node, this.parent);
  }, t2.isReferencedIdentifier = function(e3) {
    const { node: t3, parent: r3 } = this;
    if (!p(t3, e3) && !m(r3, e3)) {
      if (!h(t3, e3)) return false;
      if (P(t3.name)) return false;
    }
    return b(t3, r3, this.parentPath.parent);
  }, t2.isReferencedMemberExpression = function() {
    const { node: e3, parent: t3 } = this;
    return y(e3) && b(e3, t3);
  }, t2.isRestProperty = function() {
    return g(this.node) && this.parentPath && this.parentPath.isObjectPattern();
  }, t2.isScope = function() {
    return v(this.node, this.parent);
  }, t2.isSpreadProperty = function() {
    return g(this.node) && this.parentPath && this.parentPath.isObjectExpression();
  }, t2.isStatement = function() {
    const { node: e3, parent: t3 } = this;
    if (E(e3)) {
      if (x(e3)) {
        if (u(t3, { left: e3 })) return false;
        if (c(t3, { init: e3 })) return false;
      }
      return true;
    }
    return false;
  }, t2.isUser = function() {
    return this.node && !!this.node.loc;
  }, t2.isVar = function() {
    return S(this.node);
  };
  var n2 = r2(0);
  const { isBinding: s2, isBlockScoped: i2, isExportDeclaration: o2, isExpression: a2, isFlow: l, isForStatement: c, isForXStatement: u, isIdentifier: p, isImportDeclaration: d, isImportSpecifier: f, isJSXIdentifier: h, isJSXMemberExpression: m, isMemberExpression: y, isRestElement: g, isReferenced: b, isScope: v, isStatement: E, isVar: S, isVariableDeclaration: x, react: T, isForOfStatement: w } = n2, { isCompatTag: P } = T;
  t2.isExistentialTypeParam = function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, t2.isNumericLiteralTypeAnnotation = function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const r3 = e3.split(".");
    return (e4) => (0, n2.default)(e4, r3, t3);
  };
  var n2 = r2(165);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    if (!(0, n2.isMemberExpression)(e3)) return false;
    const s2 = Array.isArray(t3) ? t3 : t3.split("."), i2 = [];
    let o2;
    for (o2 = e3; (0, n2.isMemberExpression)(o2); o2 = o2.object) i2.push(o2.property);
    if (i2.push(o2), i2.length < s2.length) return false;
    if (!r3 && i2.length > s2.length) return false;
    for (let e4 = 0, t4 = i2.length - 1; e4 < s2.length; e4++, t4--) {
      const r4 = i2[t4];
      let o3;
      if ((0, n2.isIdentifier)(r4)) o3 = r4.name;
      else if ((0, n2.isStringLiteral)(r4)) o3 = r4.value;
      else {
        if (!(0, n2.isThisExpression)(r4)) return false;
        o3 = "this";
      }
      if (s2[e4] !== o3) return false;
    }
    return true;
  };
  var n2 = r2(2);
}, (e2) => {
  let t2 = null;
  function r2(e3) {
    if (null !== t2 && (t2.property, 1)) {
      const e4 = t2;
      return t2 = r2.prototype = null, e4;
    }
    return t2 = r2.prototype = null == e3 ? /* @__PURE__ */ Object.create(null) : e3, new r2();
  }
  r2(), e2.exports = function(e3) {
    return r2(e3);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.patternLikeCommon = t2.functionTypeAnnotationCommon = t2.functionDeclarationCommon = t2.functionCommon = t2.classMethodOrPropertyCommon = t2.classMethodOrDeclareMethodCommon = void 0, r2(42), r2(43), r2(59);
  var n2 = r2(355), s2 = r2(26), i2 = r2(18);
  const o2 = (0, i2.defineAliasedType)("Standardized");
  o2("ArrayExpression", { fields: { elements: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeOrValueType)("null", "Expression", "SpreadElement"))), default: [] } }, visitor: ["elements"], aliases: ["Expression"] }), o2("AssignmentExpression", { fields: { operator: { validate: (0, i2.assertValueType)("string") }, left: { validate: (0, i2.assertNodeType)("LVal", "OptionalMemberExpression") }, right: { validate: (0, i2.assertNodeType)("Expression") } }, builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Expression"] }), o2("BinaryExpression", { builder: ["operator", "left", "right"], fields: { operator: { validate: (0, i2.assertOneOf)(...s2.BINARY_OPERATORS) }, left: { validate: function() {
    const e3 = (0, i2.assertNodeType)("Expression"), t3 = (0, i2.assertNodeType)("Expression", "PrivateName");
    return Object.assign(function(r3, n3, s3) {
      ("in" === r3.operator ? t3 : e3)(r3, n3, s3);
    }, { oneOfNodeTypes: ["Expression", "PrivateName"] });
  }() }, right: { validate: (0, i2.assertNodeType)("Expression") } }, visitor: ["left", "right"], aliases: ["Binary", "Expression"] }), o2("InterpreterDirective", { builder: ["value"], fields: { value: { validate: (0, i2.assertValueType)("string") } } }), o2("Directive", { visitor: ["value"], fields: { value: { validate: (0, i2.assertNodeType)("DirectiveLiteral") } } }), o2("DirectiveLiteral", { builder: ["value"], fields: { value: { validate: (0, i2.assertValueType)("string") } } }), o2("BlockStatement", { builder: ["body", "directives"], visitor: ["directives", "body"], fields: { directives: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block", "Statement"] }), o2("BreakStatement", { visitor: ["label"], fields: { label: { validate: (0, i2.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), o2("CallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments"], aliases: ["Expression"], fields: Object.assign({ callee: { validate: (0, i2.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier") }, arguments: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) } }, { optional: { validate: (0, i2.assertOneOf)(true, false), optional: true } }, { typeArguments: { validate: (0, i2.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, i2.assertNodeType)("TSTypeParameterInstantiation"), optional: true } }) }), o2("CatchClause", { visitor: ["param", "body"], fields: { param: { validate: (0, i2.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), optional: true }, body: { validate: (0, i2.assertNodeType)("BlockStatement") } }, aliases: ["Scopable", "BlockParent"] }), o2("ConditionalExpression", { visitor: ["test", "consequent", "alternate"], fields: { test: { validate: (0, i2.assertNodeType)("Expression") }, consequent: { validate: (0, i2.assertNodeType)("Expression") }, alternate: { validate: (0, i2.assertNodeType)("Expression") } }, aliases: ["Expression", "Conditional"] }), o2("ContinueStatement", { visitor: ["label"], fields: { label: { validate: (0, i2.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), o2("DebuggerStatement", { aliases: ["Statement"] }), o2("DoWhileStatement", { visitor: ["test", "body"], fields: { test: { validate: (0, i2.assertNodeType)("Expression") }, body: { validate: (0, i2.assertNodeType)("Statement") } }, aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"] }), o2("EmptyStatement", { aliases: ["Statement"] }), o2("ExpressionStatement", { visitor: ["expression"], fields: { expression: { validate: (0, i2.assertNodeType)("Expression") } }, aliases: ["Statement", "ExpressionWrapper"] }), o2("File", { builder: ["program", "comments", "tokens"], visitor: ["program"], fields: { program: { validate: (0, i2.assertNodeType)("Program") }, comments: { validate: Object.assign(() => {
  }, { each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] } }), optional: true }, tokens: { validate: (0, i2.assertEach)(Object.assign(() => {
  }, { type: "any" })), optional: true } } }), o2("ForInStatement", { visitor: ["left", "right", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: (0, i2.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, i2.assertNodeType)("Expression") }, body: { validate: (0, i2.assertNodeType)("Statement") } } }), o2("ForStatement", { visitor: ["init", "test", "update", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"], fields: { init: { validate: (0, i2.assertNodeType)("VariableDeclaration", "Expression"), optional: true }, test: { validate: (0, i2.assertNodeType)("Expression"), optional: true }, update: { validate: (0, i2.assertNodeType)("Expression"), optional: true }, body: { validate: (0, i2.assertNodeType)("Statement") } } });
  const a2 = () => ({ params: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Identifier", "Pattern", "RestElement"))) }, generator: { default: false }, async: { default: false } });
  t2.functionCommon = a2;
  const l = () => ({ returnType: { validate: (0, i2.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, i2.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true } });
  t2.functionTypeAnnotationCommon = l;
  const c = () => Object.assign({}, a2(), { declare: { validate: (0, i2.assertValueType)("boolean"), optional: true }, id: { validate: (0, i2.assertNodeType)("Identifier"), optional: true } });
  t2.functionDeclarationCommon = c, o2("FunctionDeclaration", { builder: ["id", "params", "body", "generator", "async"], visitor: ["id", "params", "body", "returnType", "typeParameters"], fields: Object.assign({}, c(), l(), { body: { validate: (0, i2.assertNodeType)("BlockStatement") }, predicate: { validate: (0, i2.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }), aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"], validate: () => {
  } }), o2("FunctionExpression", { inherits: "FunctionDeclaration", aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, a2(), l(), { id: { validate: (0, i2.assertNodeType)("Identifier"), optional: true }, body: { validate: (0, i2.assertNodeType)("BlockStatement") }, predicate: { validate: (0, i2.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) });
  const u = () => ({ typeAnnotation: { validate: (0, i2.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, optional: { validate: (0, i2.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true } });
  t2.patternLikeCommon = u, o2("Identifier", { builder: ["name"], visitor: ["typeAnnotation", "decorators"], aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"], fields: Object.assign({}, u(), { name: { validate: (0, i2.chain)((0, i2.assertValueType)("string"), Object.assign(function(e3, t3, r3) {
  }, { type: "string" })) } }), validate(e3, t3, r3) {
  } }), o2("IfStatement", { visitor: ["test", "consequent", "alternate"], aliases: ["Statement", "Conditional"], fields: { test: { validate: (0, i2.assertNodeType)("Expression") }, consequent: { validate: (0, i2.assertNodeType)("Statement") }, alternate: { optional: true, validate: (0, i2.assertNodeType)("Statement") } } }), o2("LabeledStatement", { visitor: ["label", "body"], aliases: ["Statement"], fields: { label: { validate: (0, i2.assertNodeType)("Identifier") }, body: { validate: (0, i2.assertNodeType)("Statement") } } }), o2("StringLiteral", { builder: ["value"], fields: { value: { validate: (0, i2.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), o2("NumericLiteral", { builder: ["value"], deprecatedAlias: "NumberLiteral", fields: { value: { validate: (0, i2.chain)((0, i2.assertValueType)("number"), Object.assign(function(e3, t3, r3) {
    (1 / r3 < 0 || !Number.isFinite(r3)) && new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r3}) instead.`);
  }, { type: "number" })) } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), o2("NullLiteral", { aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), o2("BooleanLiteral", { builder: ["value"], fields: { value: { validate: (0, i2.assertValueType)("boolean") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), o2("RegExpLiteral", { builder: ["pattern", "flags"], deprecatedAlias: "RegexLiteral", aliases: ["Expression", "Pureish", "Literal"], fields: { pattern: { validate: (0, i2.assertValueType)("string") }, flags: { validate: (0, i2.chain)((0, i2.assertValueType)("string"), Object.assign(function(e3, t3, r3) {
  }, { type: "string" })), default: "" } } }), o2("LogicalExpression", { builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Binary", "Expression"], fields: { operator: { validate: (0, i2.assertOneOf)(...s2.LOGICAL_OPERATORS) }, left: { validate: (0, i2.assertNodeType)("Expression") }, right: { validate: (0, i2.assertNodeType)("Expression") } } }), o2("MemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression", "LVal"], fields: Object.assign({ object: { validate: (0, i2.assertNodeType)("Expression", "Super") }, property: { validate: function() {
    const e3 = (0, i2.assertNodeType)("Identifier", "PrivateName"), t3 = (0, i2.assertNodeType)("Expression"), r3 = function(r4, n3, s3) {
      (r4.computed ? t3 : e3)(r4, n3, s3);
    };
    return r3.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r3;
  }() }, computed: { default: false } }, { optional: { validate: (0, i2.assertOneOf)(true, false), optional: true } }) }), o2("NewExpression", { inherits: "CallExpression" }), o2("Program", { visitor: ["directives", "body"], builder: ["body", "directives", "sourceType", "interpreter"], fields: { sourceFile: { validate: (0, i2.assertValueType)("string") }, sourceType: { validate: (0, i2.assertOneOf)("script", "module"), default: "script" }, interpreter: { validate: (0, i2.assertNodeType)("InterpreterDirective"), default: null, optional: true }, directives: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block"] }), o2("ObjectExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement"))) } } }), o2("ObjectMethod", { builder: ["kind", "key", "params", "body", "computed", "generator", "async"], fields: Object.assign({}, a2(), l(), { kind: Object.assign({ validate: (0, i2.assertOneOf)("method", "get", "set") }, { default: "method" }), computed: { default: false }, key: { validate: function() {
    const e3 = (0, i2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t3 = (0, i2.assertNodeType)("Expression"), r3 = function(r4, n3, s3) {
      (r4.computed ? t3 : e3)(r4, n3, s3);
    };
    return r3.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r3;
  }() }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true }, body: { validate: (0, i2.assertNodeType)("BlockStatement") } }), visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"] }), o2("ObjectProperty", { builder: ["key", "value", "computed", "shorthand", "decorators"], fields: { computed: { default: false }, key: { validate: function() {
    const e3 = (0, i2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), t3 = (0, i2.assertNodeType)("Expression");
    return Object.assign(function(r3, n3, s3) {
      (r3.computed ? t3 : e3)(r3, n3, s3);
    }, { oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"] });
  }() }, value: { validate: (0, i2.assertNodeType)("Expression", "PatternLike") }, shorthand: { validate: (0, i2.chain)((0, i2.assertValueType)("boolean"), Object.assign(function(e3, t3, r3) {
  }, { type: "boolean" }), function(e3, t3, r3) {
  }), default: false }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true } }, visitor: ["key", "value", "decorators"], aliases: ["UserWhitespacable", "Property", "ObjectMember"], validate: ((0, i2.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), (0, i2.assertNodeType)("Expression"), function(e3, t3, r3) {
  }) }), o2("RestElement", { visitor: ["argument", "typeAnnotation"], builder: ["argument"], aliases: ["LVal", "PatternLike"], deprecatedAlias: "RestProperty", fields: Object.assign({}, u(), { argument: { validate: (0, i2.assertNodeType)("LVal") } }), validate(e3, t3) {
  } }), o2("ReturnStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, i2.assertNodeType)("Expression"), optional: true } } }), o2("SequenceExpression", { visitor: ["expressions"], fields: { expressions: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Expression"))) } }, aliases: ["Expression"] }), o2("ParenthesizedExpression", { visitor: ["expression"], aliases: ["Expression", "ExpressionWrapper"], fields: { expression: { validate: (0, i2.assertNodeType)("Expression") } } }), o2("SwitchCase", { visitor: ["test", "consequent"], fields: { test: { validate: (0, i2.assertNodeType)("Expression"), optional: true }, consequent: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Statement"))) } } }), o2("SwitchStatement", { visitor: ["discriminant", "cases"], aliases: ["Statement", "BlockParent", "Scopable"], fields: { discriminant: { validate: (0, i2.assertNodeType)("Expression") }, cases: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("SwitchCase"))) } } }), o2("ThisExpression", { aliases: ["Expression"] }), o2("ThrowStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, i2.assertNodeType)("Expression") } } }), o2("TryStatement", { visitor: ["block", "handler", "finalizer"], aliases: ["Statement"], fields: { block: { validate: (0, i2.chain)((0, i2.assertNodeType)("BlockStatement"), Object.assign(function(e3) {
  }, { oneOfNodeTypes: ["BlockStatement"] })) }, handler: { optional: true, validate: (0, i2.assertNodeType)("CatchClause") }, finalizer: { optional: true, validate: (0, i2.assertNodeType)("BlockStatement") } } }), o2("UnaryExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: true }, argument: { validate: (0, i2.assertNodeType)("Expression") }, operator: { validate: (0, i2.assertOneOf)(...s2.UNARY_OPERATORS) } }, visitor: ["argument"], aliases: ["UnaryLike", "Expression"] }), o2("UpdateExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: false }, argument: { validate: (0, i2.assertNodeType)("Expression") }, operator: { validate: (0, i2.assertOneOf)(...s2.UPDATE_OPERATORS) } }, visitor: ["argument"], aliases: ["Expression"] }), o2("VariableDeclaration", { builder: ["kind", "declarations"], visitor: ["declarations"], aliases: ["Statement", "Declaration"], fields: { declare: { validate: (0, i2.assertValueType)("boolean"), optional: true }, kind: { validate: (0, i2.assertOneOf)("var", "let", "const", "using", "await using") }, declarations: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("VariableDeclarator"))) } }, validate(e3, t3, r3) {
  } }), o2("VariableDeclarator", { visitor: ["id", "init"], fields: { id: { validate: (0, i2.assertNodeType)("LVal") }, definite: { optional: true, validate: (0, i2.assertValueType)("boolean") }, init: { optional: true, validate: (0, i2.assertNodeType)("Expression") } } }), o2("WhileStatement", { visitor: ["test", "body"], aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"], fields: { test: { validate: (0, i2.assertNodeType)("Expression") }, body: { validate: (0, i2.assertNodeType)("Statement") } } }), o2("WithStatement", { visitor: ["object", "body"], aliases: ["Statement"], fields: { object: { validate: (0, i2.assertNodeType)("Expression") }, body: { validate: (0, i2.assertNodeType)("Statement") } } }), o2("AssignmentPattern", { visitor: ["left", "right", "decorators"], builder: ["left", "right"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, u(), { left: { validate: (0, i2.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") }, right: { validate: (0, i2.assertNodeType)("Expression") }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true } }) }), o2("ArrayPattern", { visitor: ["elements", "typeAnnotation"], builder: ["elements"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, u(), { elements: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeOrValueType)("null", "PatternLike", "LVal"))) } }) }), o2("ArrowFunctionExpression", { builder: ["params", "body", "async"], visitor: ["params", "body", "returnType", "typeParameters"], aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, a2(), l(), { expression: { validate: (0, i2.assertValueType)("boolean") }, body: { validate: (0, i2.assertNodeType)("BlockStatement", "Expression") }, predicate: { validate: (0, i2.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) }), o2("ClassBody", { visitor: ["body"], fields: { body: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock"))) } } }), o2("ClassExpression", { builder: ["id", "superClass", "body", "decorators"], visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"], aliases: ["Scopable", "Class", "Expression"], fields: { id: { validate: (0, i2.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, i2.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, i2.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, i2.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, i2.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, i2.assertNodeType)("InterfaceExtends"), optional: true } } }), o2("ClassDeclaration", { inherits: "ClassExpression", aliases: ["Scopable", "Class", "Statement", "Declaration"], fields: { id: { validate: (0, i2.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, i2.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, i2.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, i2.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, i2.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, i2.assertNodeType)("InterfaceExtends"), optional: true }, declare: { validate: (0, i2.assertValueType)("boolean"), optional: true }, abstract: { validate: (0, i2.assertValueType)("boolean"), optional: true } }, validate: ((0, i2.assertNodeType)("Identifier"), function(e3, t3, r3) {
  }) }), o2("ExportAllDeclaration", { builder: ["source"], visitor: ["source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { source: { validate: (0, i2.assertNodeType)("StringLiteral") }, exportKind: (0, i2.validateOptional)((0, i2.assertOneOf)("type", "value")), attributes: { optional: true, validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportAttribute"))) } } }), o2("ExportDefaultDeclaration", { visitor: ["declaration"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { validate: (0, i2.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression") }, exportKind: (0, i2.validateOptional)((0, i2.assertOneOf)("value")) } }), o2("ExportNamedDeclaration", { builder: ["declaration", "specifiers", "source"], visitor: ["declaration", "specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { optional: true, validate: (0, i2.chain)((0, i2.assertNodeType)("Declaration"), Object.assign(function(e3, t3, r3) {
  }, { oneOfNodeTypes: ["Declaration"] }), function(e3, t3, r3) {
  }) }, attributes: { optional: true, validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportAttribute"))) }, specifiers: { default: [], validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)(function() {
    const e3 = (0, i2.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
    return (0, i2.assertNodeType)("ExportSpecifier"), e3;
  }())) }, source: { validate: (0, i2.assertNodeType)("StringLiteral"), optional: true }, exportKind: (0, i2.validateOptional)((0, i2.assertOneOf)("type", "value")) } }), o2("ExportSpecifier", { visitor: ["local", "exported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, i2.assertNodeType)("Identifier") }, exported: { validate: (0, i2.assertNodeType)("Identifier", "StringLiteral") }, exportKind: { validate: (0, i2.assertOneOf)("type", "value"), optional: true } } }), o2("ForOfStatement", { visitor: ["left", "right", "body"], builder: ["left", "right", "body", "await"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: (0, i2.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, i2.assertNodeType)("Expression") }, body: { validate: (0, i2.assertNodeType)("Statement") }, await: { default: false } } }), o2("ImportDeclaration", { builder: ["specifiers", "source"], visitor: ["specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"], fields: { attributes: { optional: true, validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportAttribute"))) }, module: { optional: true, validate: (0, i2.assertValueType)("boolean") }, phase: { default: null, validate: (0, i2.assertOneOf)("source", "defer") }, specifiers: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"))) }, source: { validate: (0, i2.assertNodeType)("StringLiteral") }, importKind: { validate: (0, i2.assertOneOf)("type", "typeof", "value"), optional: true } } }), o2("ImportDefaultSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, i2.assertNodeType)("Identifier") } } }), o2("ImportNamespaceSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, i2.assertNodeType)("Identifier") } } }), o2("ImportSpecifier", { visitor: ["local", "imported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, i2.assertNodeType)("Identifier") }, imported: { validate: (0, i2.assertNodeType)("Identifier", "StringLiteral") }, importKind: { validate: (0, i2.assertOneOf)("type", "typeof", "value"), optional: true } } }), o2("ImportExpression", { visitor: ["source", "options"], aliases: ["Expression"], fields: { phase: { default: null, validate: (0, i2.assertOneOf)("source", "defer") }, source: { validate: (0, i2.assertNodeType)("Expression") }, options: { validate: (0, i2.assertNodeType)("Expression"), optional: true } } }), o2("MetaProperty", { visitor: ["meta", "property"], aliases: ["Expression"], fields: { meta: { validate: (0, i2.chain)((0, i2.assertNodeType)("Identifier"), Object.assign(function(e3, t3, r3) {
  }, { oneOfNodeTypes: ["Identifier"] })) }, property: { validate: (0, i2.assertNodeType)("Identifier") } } });
  const p = () => ({ abstract: { validate: (0, i2.assertValueType)("boolean"), optional: true }, accessibility: { validate: (0, i2.assertOneOf)("public", "private", "protected"), optional: true }, static: { default: false }, override: { default: false }, computed: { default: false }, optional: { validate: (0, i2.assertValueType)("boolean"), optional: true }, key: { validate: (0, i2.chain)(function() {
    const e3 = (0, i2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t3 = (0, i2.assertNodeType)("Expression");
    return function(r3, n3, s3) {
      (r3.computed ? t3 : e3)(r3, n3, s3);
    };
  }(), (0, i2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression")) } });
  t2.classMethodOrPropertyCommon = p;
  const d = () => Object.assign({}, a2(), p(), { params: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"))) }, kind: { validate: (0, i2.assertOneOf)("get", "set", "method", "constructor"), default: "method" }, access: { validate: (0, i2.chain)((0, i2.assertValueType)("string"), (0, i2.assertOneOf)("public", "private", "protected")), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true } });
  t2.classMethodOrDeclareMethodCommon = d, o2("ClassMethod", { aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"], builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], fields: Object.assign({}, d(), l(), { body: { validate: (0, i2.assertNodeType)("BlockStatement") } }) }), o2("ObjectPattern", { visitor: ["properties", "typeAnnotation", "decorators"], builder: ["properties"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, u(), { properties: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("RestElement", "ObjectProperty"))) } }) }), o2("SpreadElement", { visitor: ["argument"], aliases: ["UnaryLike"], deprecatedAlias: "SpreadProperty", fields: { argument: { validate: (0, i2.assertNodeType)("Expression") } } }), o2("Super", { aliases: ["Expression"] }), o2("TaggedTemplateExpression", { visitor: ["tag", "quasi", "typeParameters"], builder: ["tag", "quasi"], aliases: ["Expression"], fields: { tag: { validate: (0, i2.assertNodeType)("Expression") }, quasi: { validate: (0, i2.assertNodeType)("TemplateLiteral") }, typeParameters: { validate: (0, i2.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), o2("TemplateElement", { builder: ["value", "tail"], fields: { value: { validate: (0, i2.chain)((0, i2.assertShape)({ raw: { validate: (0, i2.assertValueType)("string") }, cooked: { validate: (0, i2.assertValueType)("string"), optional: true } }), function(e3) {
    const t3 = e3.value.raw;
    let r3 = false;
    const s3 = () => {
      throw new Error("Internal @babel/types error.");
    }, { str: i3, firstInvalidLoc: o3 } = (0, n2.readStringContents)("template", t3, 0, 0, 0, { unterminated() {
      r3 = true;
    }, strictNumericEscape: s3, invalidEscapeSequence: s3, numericSeparatorInEscapeSequence: s3, unexpectedNumericSeparator: s3, invalidDigit: s3, invalidCodePoint: s3 });
    if (!r3) throw new Error("Invalid raw");
    e3.value.cooked = o3 ? null : i3;
  }) }, tail: { default: false } } }), o2("TemplateLiteral", { visitor: ["quasis", "expressions"], aliases: ["Expression", "Literal"], fields: { quasis: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("TemplateElement"))) }, expressions: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Expression", "TSType")), function(e3, t3, r3) {
    if (e3.quasis.length !== r3.length + 1) throw new TypeError(`Number of ${e3.type} quasis should be exactly one more than the number of expressions.
Expected ${r3.length + 1} quasis but got ${e3.quasis.length}`);
  }) } } }), o2("YieldExpression", { builder: ["argument", "delegate"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { delegate: { validate: (0, i2.chain)((0, i2.assertValueType)("boolean"), Object.assign(function(e3, t3, r3) {
  }, { type: "boolean" })), default: false }, argument: { optional: true, validate: (0, i2.assertNodeType)("Expression") } } }), o2("AwaitExpression", { builder: ["argument"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { argument: { validate: (0, i2.assertNodeType)("Expression") } } }), o2("Import", { aliases: ["Expression"] }), o2("BigIntLiteral", { builder: ["value"], fields: { value: { validate: (0, i2.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), o2("ExportNamespaceSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, i2.assertNodeType)("Identifier") } } }), o2("OptionalMemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression"], fields: { object: { validate: (0, i2.assertNodeType)("Expression") }, property: { validate: function() {
    const e3 = (0, i2.assertNodeType)("Identifier"), t3 = (0, i2.assertNodeType)("Expression");
    return Object.assign(function(r3, n3, s3) {
      (r3.computed ? t3 : e3)(r3, n3, s3);
    }, { oneOfNodeTypes: ["Expression", "Identifier"] });
  }() }, computed: { default: false }, optional: { validate: (0, i2.assertValueType)("boolean") } } }), o2("OptionalCallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments", "optional"], aliases: ["Expression"], fields: { callee: { validate: (0, i2.assertNodeType)("Expression") }, arguments: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) }, optional: { validate: (0, i2.assertValueType)("boolean") }, typeArguments: { validate: (0, i2.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, i2.assertNodeType)("TSTypeParameterInstantiation"), optional: true } } }), o2("ClassProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property"], fields: Object.assign({}, p(), { value: { validate: (0, i2.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, i2.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, i2.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true }, readonly: { validate: (0, i2.assertValueType)("boolean"), optional: true }, declare: { validate: (0, i2.assertValueType)("boolean"), optional: true }, variance: { validate: (0, i2.assertNodeType)("Variance"), optional: true } }) }), o2("ClassAccessorProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property", "Accessor"], fields: Object.assign({}, p(), { key: { validate: (0, i2.chain)(function() {
    const e3 = (0, i2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), t3 = (0, i2.assertNodeType)("Expression");
    return function(r3, n3, s3) {
      (r3.computed ? t3 : e3)(r3, n3, s3);
    };
  }(), (0, i2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName")) }, value: { validate: (0, i2.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, i2.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, i2.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true }, readonly: { validate: (0, i2.assertValueType)("boolean"), optional: true }, declare: { validate: (0, i2.assertValueType)("boolean"), optional: true }, variance: { validate: (0, i2.assertNodeType)("Variance"), optional: true } }) }), o2("ClassPrivateProperty", { visitor: ["key", "value", "decorators", "typeAnnotation"], builder: ["key", "value", "decorators", "static"], aliases: ["Property", "Private"], fields: { key: { validate: (0, i2.assertNodeType)("PrivateName") }, value: { validate: (0, i2.assertNodeType)("Expression"), optional: true }, typeAnnotation: { validate: (0, i2.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true }, static: { validate: (0, i2.assertValueType)("boolean"), default: false }, readonly: { validate: (0, i2.assertValueType)("boolean"), optional: true }, definite: { validate: (0, i2.assertValueType)("boolean"), optional: true }, variance: { validate: (0, i2.assertNodeType)("Variance"), optional: true } } }), o2("ClassPrivateMethod", { builder: ["kind", "key", "params", "body", "static"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"], fields: Object.assign({}, d(), l(), { kind: { validate: (0, i2.assertOneOf)("get", "set", "method"), default: "method" }, key: { validate: (0, i2.assertNodeType)("PrivateName") }, body: { validate: (0, i2.assertNodeType)("BlockStatement") } }) }), o2("PrivateName", { visitor: ["id"], aliases: ["Private"], fields: { id: { validate: (0, i2.assertNodeType)("Identifier") } } }), o2("StaticBlock", { visitor: ["body"], fields: { body: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "FunctionParent"] });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if (e3 === t3) return true;
    const r3 = n2.PLACEHOLDERS_ALIAS[e3];
    if (r3) {
      for (const e4 of r3) if (t3 === e4) return true;
    }
    return false;
  };
  var n2 = r2(9);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.PLACEHOLDERS_FLIPPED_ALIAS = t2.PLACEHOLDERS_ALIAS = t2.PLACEHOLDERS = void 0;
  var n2 = r2(18);
  const s2 = t2.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"], i2 = t2.PLACEHOLDERS_ALIAS = { Declaration: ["Statement"], Pattern: ["PatternLike", "LVal"] };
  for (const e3 of s2) {
    const t3 = n2.ALIAS_KEYS[e3];
    null != t3 && t3.length && (i2[e3] = t3);
  }
  const o2 = t2.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(i2).forEach((e3) => {
    i2[e3].forEach((t3) => {
      Object.hasOwnProperty.call(o2, t3) || (o2[t3] = []), o2[t3].push(e3);
    });
  });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return !(!e3 || !n2.VISITOR_KEYS[e3.type]);
  };
  var n2 = r2(9);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3) {
    const r3 = Array.from(t3), i2 = /* @__PURE__ */ new Map(), o2 = /* @__PURE__ */ new Map(), a2 = /* @__PURE__ */ new Set(), l = [];
    for (let t4 = 0; t4 < r3.length; t4++) {
      const c = r3[t4];
      if (c && !(l.indexOf(c) >= 0)) {
        if ((0, n2.isAnyTypeAnnotation)(c)) return [c];
        if ((0, n2.isFlowBaseAnnotation)(c)) o2.set(c.type, c);
        else if ((0, n2.isUnionTypeAnnotation)(c)) a2.has(c.types) || (r3.push(...c.types), a2.add(c.types));
        else if ((0, n2.isGenericTypeAnnotation)(c)) {
          const t5 = s2(c.id);
          if (i2.has(t5)) {
            let r4 = i2.get(t5);
            r4.typeParameters ? c.typeParameters && (r4.typeParameters.params.push(...c.typeParameters.params), r4.typeParameters.params = e3(r4.typeParameters.params)) : r4 = c.typeParameters;
          } else i2.set(t5, c);
        } else l.push(c);
      }
    }
    for (const [, e4] of o2) l.push(e4);
    for (const [, e4] of i2) l.push(e4);
    return l;
  };
  var n2 = r2(2);
  function s2(e3) {
    return (0, n2.isIdentifier)(e3) ? e3.name : `${e3.id.name}.${s2(e3.qualification)}`;
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r2) {
    if (!r2 || !e3) return e3;
    const n2 = `${t3}Comments`;
    return e3[n2] ? "leading" === t3 ? e3[n2] = r2.concat(e3[n2]) : e3[n2].push(...r2) : e3[n2] = r2, e3;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    (0, n2.default)("innerComments", e3, t3);
  };
  var n2 = r2(99);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    (0, n2.default)("leadingComments", e3, t3);
  };
  var n2 = r2(99);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    return (0, n2.default)(e3, t3), (0, s2.default)(e3, t3), (0, i2.default)(e3, t3), e3;
  };
  var n2 = r2(176), s2 = r2(174), i2 = r2(173);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    (0, n2.default)("trailingComments", e3, t3);
  };
  var n2 = r2(99);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if ((0, n2.isBlockStatement)(e3)) return e3;
    let r3 = [];
    return (0, n2.isEmptyStatement)(e3) ? r3 = [] : ((0, n2.isStatement)(e3) || (e3 = (0, n2.isFunction)(t3) ? (0, s2.returnStatement)(e3) : (0, s2.expressionStatement)(e3)), r3 = [e3]), (0, s2.blockStatement)(r3);
  };
  var n2 = r2(2), s2 = r2(4);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    e3 += "";
    let t3 = "";
    for (const r3 of e3) t3 += (0, s2.isIdentifierChar)(r3.codePointAt(0)) ? r3 : "-";
    return t3 = t3.replace(/^[-0-9]+/, ""), t3 = t3.replace(/[-\s]+(.)?/g, function(e4, t4) {
      return t4 ? t4.toUpperCase() : "";
    }), (0, n2.default)(t3) || (t3 = `_${t3}`), t3 || "_";
  };
  var n2 = r2(43), s2 = r2(59);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    return (0, n2.default)(e3, s2.default, t3), e3;
  };
  var n2 = r2(180), s2 = r2(181);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, r3, s2) {
    if (!t3) return;
    const i2 = n2.VISITOR_KEYS[t3.type];
    if (i2) {
      r3(t3, s2 = s2 || {});
      for (const n3 of i2) {
        const i3 = t3[n3];
        if (Array.isArray(i3)) for (const t4 of i3) e3(t4, r3, s2);
        else e3(i3, r3, s2);
      }
    }
  };
  var n2 = r2(9);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const t3 = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).preserveComments ? s2 : i2;
    for (const r4 of t3) null != e3[r4] && (e3[r4] = void 0);
    for (const t4 of Object.keys(e3)) "_" === t4[0] && null != e3[t4] && (e3[t4] = void 0);
    const r3 = Object.getOwnPropertySymbols(e3);
    for (const t4 of r3) e3[t4] = null;
  };
  var n2 = r2(26);
  const s2 = ["tokens", "start", "end", "loc", "raw", "rawValue"], i2 = [...n2.COMMENT_KEYS, "comments", ...s2];
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.isVariableDeclaration)(e3) && ("var" !== e3.kind || e3[s2.BLOCK_SCOPED_SYMBOL]);
  };
  var n2 = r2(2), s2 = r2(26);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(401), s2 = r2(14), i2 = r2(402), o2 = r2(403), a2 = r2(0), l = a2, c = r2(35), u = r2(57);
  const { NOT_LOCAL_BINDING: p, callExpression: d, cloneNode: f, getBindingIdentifiers: h, identifier: m, isArrayExpression: y, isBinary: g, isClass: b, isClassBody: v, isClassDeclaration: E, isExportAllDeclaration: S, isExportDefaultDeclaration: x, isExportNamedDeclaration: T, isFunctionDeclaration: w, isIdentifier: P, isImportDeclaration: A, isLiteral: C, isMethod: O, isModuleSpecifier: I, isNullLiteral: _, isObjectExpression: k, isProperty: N, isPureish: D, isRegExpLiteral: j, isSuper: L, isTaggedTemplateExpression: M, isTemplateLiteral: B, isThisExpression: R, isUnaryExpression: F, isVariableDeclaration: U, matchesPattern: $, memberExpression: V, numericLiteral: q, toIdentifier: W, variableDeclaration: G, variableDeclarator: H, isRecordExpression: z, isTupleExpression: K, isObjectProperty: X, isTopicReference: J, isMetaProperty: Y, isPrivateName: Q, isExportDeclaration: Z, buildUndefinedNode: ee } = a2;
  function te(e3, t3) {
    switch (null == e3 ? void 0 : e3.type) {
      default:
        var r3;
        if (A(e3) || Z(e3)) if ((S(e3) || T(e3) || A(e3)) && e3.source) te(e3.source, t3);
        else if ((T(e3) || A(e3)) && null != (r3 = e3.specifiers) && r3.length) for (const r4 of e3.specifiers) te(r4, t3);
        else (x(e3) || T(e3)) && e3.declaration && te(e3.declaration, t3);
        else I(e3) ? te(e3.local, t3) : !C(e3) || _(e3) || j(e3) || B(e3) || t3.push(e3.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        te(e3.object, t3), te(e3.property, t3);
        break;
      case "Identifier":
      case "JSXIdentifier":
        t3.push(e3.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        te(e3.callee, t3);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (const r4 of e3.properties) te(r4, t3);
        break;
      case "SpreadElement":
      case "RestElement":
      case "UnaryExpression":
      case "UpdateExpression":
        te(e3.argument, t3);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        te(e3.key, t3);
        break;
      case "ThisExpression":
        t3.push("this");
        break;
      case "Super":
        t3.push("super");
        break;
      case "Import":
        t3.push("import");
        break;
      case "DoExpression":
        t3.push("do");
        break;
      case "YieldExpression":
        t3.push("yield"), te(e3.argument, t3);
        break;
      case "AwaitExpression":
        t3.push("await"), te(e3.argument, t3);
        break;
      case "AssignmentExpression":
        te(e3.left, t3);
        break;
      case "VariableDeclarator":
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
      case "PrivateName":
        te(e3.id, t3);
        break;
      case "ParenthesizedExpression":
        te(e3.expression, t3);
        break;
      case "MetaProperty":
        te(e3.meta, t3), te(e3.property, t3);
        break;
      case "JSXElement":
        te(e3.openingElement, t3);
        break;
      case "JSXOpeningElement":
        te(e3.name, t3);
        break;
      case "JSXFragment":
        te(e3.openingFragment, t3);
        break;
      case "JSXOpeningFragment":
        t3.push("Fragment");
        break;
      case "JSXNamespacedName":
        te(e3.namespace, t3), te(e3.name, t3);
    }
  }
  const re = { ForStatement(e3) {
    const t3 = e3.get("init");
    if (t3.isVar()) {
      const { scope: r3 } = e3;
      (r3.getFunctionParent() || r3.getProgramParent()).registerBinding("var", t3);
    }
  }, Declaration(e3) {
    e3.isBlockScoped() || e3.isImportDeclaration() || e3.isExportDeclaration() || (e3.scope.getFunctionParent() || e3.scope.getProgramParent()).registerDeclaration(e3);
  }, ImportDeclaration(e3) {
    e3.scope.getBlockParent().registerDeclaration(e3);
  }, ReferencedIdentifier(e3, t3) {
    t3.references.push(e3);
  }, ForXStatement(e3, t3) {
    const r3 = e3.get("left");
    if (r3.isPattern() || r3.isIdentifier()) t3.constantViolations.push(e3);
    else if (r3.isVar()) {
      const { scope: t4 } = e3;
      (t4.getFunctionParent() || t4.getProgramParent()).registerBinding("var", r3);
    }
  }, ExportDeclaration: { exit(e3) {
    const { node: t3, scope: r3 } = e3;
    if (S(t3)) return;
    const n3 = t3.declaration;
    if (E(n3) || w(n3)) {
      const t4 = n3.id;
      if (!t4) return;
      const s3 = r3.getBinding(t4.name);
      null == s3 || s3.reference(e3);
    } else if (U(n3)) for (const t4 of n3.declarations) for (const n4 of Object.keys(h(t4))) {
      const t5 = r3.getBinding(n4);
      null == t5 || t5.reference(e3);
    }
  } }, LabeledStatement(e3) {
    e3.scope.getBlockParent().registerDeclaration(e3);
  }, AssignmentExpression(e3, t3) {
    t3.assignments.push(e3);
  }, UpdateExpression(e3, t3) {
    t3.constantViolations.push(e3);
  }, UnaryExpression(e3, t3) {
    "delete" === e3.node.operator && t3.constantViolations.push(e3);
  }, BlockScoped(e3) {
    let t3 = e3.scope;
    if (t3.path === e3 && (t3 = t3.parent), t3.getBlockParent().registerDeclaration(e3), e3.isClassDeclaration() && e3.node.id) {
      const t4 = e3.node.id.name;
      e3.scope.bindings[t4] = e3.scope.parent.getBinding(t4);
    }
  }, CatchClause(e3) {
    e3.scope.registerBinding("let", e3);
  }, Function(e3) {
    const t3 = e3.get("params");
    for (const r3 of t3) e3.scope.registerBinding("param", r3);
    e3.isFunctionExpression() && e3.has("id") && !e3.get("id").node[p] && e3.scope.registerBinding("local", e3.get("id"), e3);
  }, ClassExpression(e3) {
    e3.has("id") && !e3.get("id").node[p] && e3.scope.registerBinding("local", e3);
  } };
  let ne = 0;
  class se {
    constructor(e3) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      const { node: t3 } = e3, r3 = c.scope.get(t3);
      if ((null == r3 ? void 0 : r3.path) === e3) return r3;
      c.scope.set(t3, this), this.uid = ne++, this.block = t3, this.path = e3, this.labels = /* @__PURE__ */ new Map(), this.inited = false;
    }
    get parent() {
      var e3;
      let t3, r3 = this.path;
      do {
        const e4 = "key" === r3.key || "decorators" === r3.listKey;
        r3 = r3.parentPath, e4 && r3.isMethod() && (r3 = r3.parentPath), r3 && r3.isScope() && (t3 = r3);
      } while (r3 && !t3);
      return null == (e3 = t3) ? void 0 : e3.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(e3, t3, r3) {
      (0, s2.default)(e3, t3, this, r3, this.path);
    }
    generateDeclaredUidIdentifier(e3) {
      const t3 = this.generateUidIdentifier(e3);
      return this.push({ id: t3 }), f(t3);
    }
    generateUidIdentifier(e3) {
      return m(this.generateUid(e3));
    }
    generateUid() {
      let e3, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "temp";
      t3 = W(t3).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let r3 = 1;
      do {
        e3 = this._generateUid(t3, r3), r3++;
      } while (this.hasLabel(e3) || this.hasBinding(e3) || this.hasGlobal(e3) || this.hasReference(e3));
      const n3 = this.getProgramParent();
      return n3.references[e3] = true, n3.uids[e3] = true, e3;
    }
    _generateUid(e3, t3) {
      let r3 = e3;
      return t3 > 1 && (r3 += t3), `_${r3}`;
    }
    generateUidBasedOnNode(e3, t3) {
      const r3 = [];
      te(e3, r3);
      let n3 = r3.join("$");
      return n3 = n3.replace(/^_/, "") || t3 || "ref", this.generateUid(n3.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(e3, t3) {
      return m(this.generateUidBasedOnNode(e3, t3));
    }
    isStatic(e3) {
      if (R(e3) || L(e3) || J(e3)) return true;
      if (P(e3)) {
        const t3 = this.getBinding(e3.name);
        return t3 ? t3.constant : this.hasBinding(e3.name);
      }
      return false;
    }
    maybeGenerateMemoised(e3, t3) {
      if (this.isStatic(e3)) return null;
      {
        const r3 = this.generateUidIdentifierBasedOnNode(e3);
        return t3 ? r3 : (this.push({ id: r3 }), f(r3));
      }
    }
    checkBlockScopedCollisions(e3, t3, r3, n3) {
      if ("param" !== t3 && "local" !== e3.kind && ("let" === t3 || "let" === e3.kind || "const" === e3.kind || "module" === e3.kind || "param" === e3.kind && "const" === t3)) throw this.hub.buildError(n3, `Duplicate declaration "${r3}"`, TypeError);
    }
    rename(e3, t3) {
      const r3 = this.getBinding(e3);
      r3 && (t3 || (t3 = this.generateUidIdentifier(e3).name), new n2.default(r3, e3, t3).rename(arguments[2]));
    }
    _renameFromMap(e3, t3, r3, n3) {
      e3[t3] && (e3[r3] = n3, e3[t3] = null);
    }
    dump() {
      "-".repeat(60);
      let e3 = this;
      do {
        for (const t3 of Object.keys(e3.bindings)) e3.bindings[t3];
      } while (e3 = e3.parent);
    }
    toArray(e3, t3, r3) {
      if (P(e3)) {
        const t4 = this.getBinding(e3.name);
        if (null != t4 && t4.constant && t4.path.isGenericType("Array")) return e3;
      }
      if (y(e3)) return e3;
      if (P(e3, { name: "arguments" })) return d(V(V(V(m("Array"), m("prototype")), m("slice")), m("call")), [e3]);
      let n3;
      const s3 = [e3];
      return true === t3 ? n3 = "toConsumableArray" : "number" == typeof t3 ? (s3.push(q(t3)), n3 = "slicedToArray") : n3 = "toArray", r3 && (s3.unshift(this.hub.addHelper(n3)), n3 = "maybeArrayLike"), d(this.hub.addHelper(n3), s3);
    }
    hasLabel(e3) {
      return !!this.getLabel(e3);
    }
    getLabel(e3) {
      return this.labels.get(e3);
    }
    registerLabel(e3) {
      this.labels.set(e3.node.label.name, e3);
    }
    registerDeclaration(e3) {
      if (e3.isLabeledStatement()) this.registerLabel(e3);
      else if (e3.isFunctionDeclaration()) this.registerBinding("hoisted", e3.get("id"), e3);
      else if (e3.isVariableDeclaration()) {
        const t3 = e3.get("declarations"), { kind: r3 } = e3.node;
        for (const e4 of t3) this.registerBinding("using" === r3 || "await using" === r3 ? "const" : r3, e4);
      } else if (e3.isClassDeclaration()) {
        if (e3.node.declare) return;
        this.registerBinding("let", e3);
      } else if (e3.isImportDeclaration()) {
        const t3 = "type" === e3.node.importKind || "typeof" === e3.node.importKind, r3 = e3.get("specifiers");
        for (const e4 of r3) {
          const r4 = t3 || e4.isImportSpecifier() && ("type" === e4.node.importKind || "typeof" === e4.node.importKind);
          this.registerBinding(r4 ? "unknown" : "module", e4);
        }
      } else if (e3.isExportDeclaration()) {
        const t3 = e3.get("declaration");
        (t3.isClassDeclaration() || t3.isFunctionDeclaration() || t3.isVariableDeclaration()) && this.registerDeclaration(t3);
      } else this.registerBinding("unknown", e3);
    }
    buildUndefinedNode() {
      return ee();
    }
    registerConstantViolation(e3) {
      const t3 = e3.getBindingIdentifiers();
      for (const n3 of Object.keys(t3)) {
        var r3;
        null == (r3 = this.getBinding(n3)) || r3.reassign(e3);
      }
    }
    registerBinding(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t3;
      if (!e3) throw new ReferenceError("no `kind`");
      if (t3.isVariableDeclaration()) {
        const r4 = t3.get("declarations");
        for (const t4 of r4) this.registerBinding(e3, t4);
        return;
      }
      const n3 = this.getProgramParent(), s3 = t3.getOuterBindingIdentifiers(true);
      for (const t4 of Object.keys(s3)) {
        n3.references[t4] = true;
        for (const n4 of s3[t4]) {
          const s4 = this.getOwnBinding(t4);
          if (s4) {
            if (s4.identifier === n4) continue;
            this.checkBlockScopedCollisions(s4, e3, t4, n4);
          }
          s4 ? this.registerConstantViolation(r3) : this.bindings[t4] = new i2.default({ identifier: n4, scope: this, path: r3, kind: e3 });
        }
      }
    }
    addGlobal(e3) {
      this.globals[e3.name] = e3;
    }
    hasUid(e3) {
      let t3 = this;
      do {
        if (t3.uids[e3]) return true;
      } while (t3 = t3.parent);
      return false;
    }
    hasGlobal(e3) {
      let t3 = this;
      do {
        if (t3.globals[e3]) return true;
      } while (t3 = t3.parent);
      return false;
    }
    hasReference(e3) {
      return !!this.getProgramParent().references[e3];
    }
    isPure(e3, t3) {
      if (P(e3)) {
        const r4 = this.getBinding(e3.name);
        return !!r4 && (!t3 || r4.constant);
      }
      if (R(e3) || Y(e3) || J(e3) || Q(e3)) return true;
      var r3, n3, s3;
      if (b(e3)) return !(e3.superClass && !this.isPure(e3.superClass, t3)) && !((null == (r3 = e3.decorators) ? void 0 : r3.length) > 0) && this.isPure(e3.body, t3);
      if (v(e3)) {
        for (const r4 of e3.body) if (!this.isPure(r4, t3)) return false;
        return true;
      }
      if (g(e3)) return this.isPure(e3.left, t3) && this.isPure(e3.right, t3);
      if (y(e3) || K(e3)) {
        for (const r4 of e3.elements) if (null !== r4 && !this.isPure(r4, t3)) return false;
        return true;
      }
      if (k(e3) || z(e3)) {
        for (const r4 of e3.properties) if (!this.isPure(r4, t3)) return false;
        return true;
      }
      if (O(e3)) return !(e3.computed && !this.isPure(e3.key, t3) || (null == (n3 = e3.decorators) ? void 0 : n3.length) > 0);
      if (N(e3)) return !(e3.computed && !this.isPure(e3.key, t3) || (null == (s3 = e3.decorators) ? void 0 : s3.length) > 0 || (X(e3) || e3.static) && null !== e3.value && !this.isPure(e3.value, t3));
      if (F(e3)) return this.isPure(e3.argument, t3);
      if (M(e3)) return $(e3.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(e3.quasi, t3);
      if (B(e3)) {
        for (const r4 of e3.expressions) if (!this.isPure(r4, t3)) return false;
        return true;
      }
      return D(e3);
    }
    setData(e3, t3) {
      return this.data[e3] = t3;
    }
    getData(e3) {
      let t3 = this;
      do {
        const r3 = t3.data[e3];
        if (null != r3) return r3;
      } while (t3 = t3.parent);
    }
    removeData(e3) {
      let t3 = this;
      do {
        null != t3.data[e3] && (t3.data[e3] = null);
      } while (t3 = t3.parent);
    }
    init() {
      this.inited || (this.inited = true, this.crawl());
    }
    crawl() {
      const e3 = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      const t3 = this.getProgramParent();
      if (t3.crawling) return;
      const r3 = { references: [], constantViolations: [], assignments: [] };
      if (this.crawling = true, "Program" !== e3.type && (0, u.isExplodedVisitor)(re)) {
        for (const t5 of re.enter) t5.call(r3, e3, r3);
        const t4 = re[e3.type];
        if (t4) for (const n3 of t4.enter) n3.call(r3, e3, r3);
      }
      e3.traverse(re, r3), this.crawling = false;
      for (const e4 of r3.assignments) {
        const r4 = e4.getBindingIdentifiers();
        for (const n3 of Object.keys(r4)) e4.scope.getBinding(n3) || t3.addGlobal(r4[n3]);
        e4.scope.registerConstantViolation(e4);
      }
      for (const e4 of r3.references) {
        const r4 = e4.scope.getBinding(e4.node.name);
        r4 ? r4.reference(e4) : t3.addGlobal(e4.node);
      }
      for (const e4 of r3.constantViolations) e4.scope.registerConstantViolation(e4);
    }
    push(e3) {
      let t3 = this.path;
      t3.isPattern() ? t3 = this.getPatternParent().path : t3.isBlockStatement() || t3.isProgram() || (t3 = this.getBlockParent().path), t3.isSwitchStatement() && (t3 = (this.getFunctionParent() || this.getProgramParent()).path);
      const { init: r3, unique: n3, kind: s3 = "var", id: i3 } = e3;
      if (!r3 && !n3 && ("var" === s3 || "let" === s3) && t3.isFunction() && !t3.node.name && l.isCallExpression(t3.parent, { callee: t3.node }) && t3.parent.arguments.length <= t3.node.params.length && l.isIdentifier(i3)) return t3.pushContainer("params", i3), void t3.scope.registerBinding("param", t3.get("params")[t3.node.params.length - 1]);
      (t3.isLoop() || t3.isCatchClause() || t3.isFunction()) && (t3.ensureBlock(), t3 = t3.get("body"));
      const o3 = null == e3._blockHoist ? 2 : e3._blockHoist, a3 = `declaration:${s3}:${o3}`;
      let c2 = !n3 && t3.getData(a3);
      if (!c2) {
        const e4 = G(s3, []);
        e4._blockHoist = o3, [c2] = t3.unshiftContainer("body", [e4]), n3 || t3.setData(a3, c2);
      }
      const u2 = H(i3, r3), p2 = c2.node.declarations.push(u2);
      t3.scope.registerBinding(s3, c2.get("declarations")[p2 - 1]);
    }
    getProgramParent() {
      let e3 = this;
      do {
        if (e3.path.isProgram()) return e3;
      } while (e3 = e3.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let e3 = this;
      do {
        if (e3.path.isFunctionParent()) return e3;
      } while (e3 = e3.parent);
      return null;
    }
    getBlockParent() {
      let e3 = this;
      do {
        if (e3.path.isBlockParent()) return e3;
      } while (e3 = e3.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let e3 = this;
      do {
        if (!e3.path.isPattern()) return e3.getBlockParent();
      } while (e3 = e3.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      const e3 = /* @__PURE__ */ Object.create(null);
      let t3 = this;
      do {
        for (const r3 of Object.keys(t3.bindings)) r3 in e3 == 0 && (e3[r3] = t3.bindings[r3]);
        t3 = t3.parent;
      } while (t3);
      return e3;
    }
    getAllBindingsOfKind() {
      const e3 = /* @__PURE__ */ Object.create(null);
      for (var t3 = arguments.length, r3 = new Array(t3), n3 = 0; n3 < t3; n3++) r3[n3] = arguments[n3];
      for (const t4 of r3) {
        let r4 = this;
        do {
          for (const n4 of Object.keys(r4.bindings)) {
            const s3 = r4.bindings[n4];
            s3.kind === t4 && (e3[n4] = s3);
          }
          r4 = r4.parent;
        } while (r4);
      }
      return e3;
    }
    bindingIdentifierEquals(e3, t3) {
      return this.getBindingIdentifier(e3) === t3;
    }
    getBinding(e3) {
      let t3, r3 = this;
      do {
        const s3 = r3.getOwnBinding(e3);
        var n3;
        if (s3) {
          if (null == (n3 = t3) || !n3.isPattern() || "param" === s3.kind || "local" === s3.kind) return s3;
        } else if (!s3 && "arguments" === e3 && r3.path.isFunction() && !r3.path.isArrowFunctionExpression()) break;
        t3 = r3.path;
      } while (r3 = r3.parent);
    }
    getOwnBinding(e3) {
      return this.bindings[e3];
    }
    getBindingIdentifier(e3) {
      var t3;
      return null == (t3 = this.getBinding(e3)) ? void 0 : t3.identifier;
    }
    getOwnBindingIdentifier(e3) {
      const t3 = this.bindings[e3];
      return null == t3 ? void 0 : t3.identifier;
    }
    hasOwnBinding(e3) {
      return !!this.getOwnBinding(e3);
    }
    hasBinding(e3, t3) {
      var r3, n3, s3;
      return !(!e3 || !this.hasOwnBinding(e3) && ("boolean" == typeof t3 && (t3 = { noGlobals: t3 }), !this.parentHasBinding(e3, t3) && (null != (r3 = t3) && r3.noUids || !this.hasUid(e3)) && (null != (n3 = t3) && n3.noGlobals || !se.globals.includes(e3)) && (null != (s3 = t3) && s3.noGlobals || !se.contextVariables.includes(e3))));
    }
    parentHasBinding(e3, t3) {
      var r3;
      return null == (r3 = this.parent) ? void 0 : r3.hasBinding(e3, t3);
    }
    moveBindingTo(e3, t3) {
      const r3 = this.getBinding(e3);
      r3 && (r3.scope.removeOwnBinding(e3), r3.scope = t3, t3.bindings[e3] = r3);
    }
    removeOwnBinding(e3) {
      delete this.bindings[e3];
    }
    removeBinding(e3) {
      var t3;
      null == (t3 = this.getBinding(e3)) || t3.scope.removeOwnBinding(e3);
      let r3 = this;
      do {
        r3.uids[e3] && (r3.uids[e3] = false);
      } while (r3 = r3.parent);
    }
  }
  t2.default = se, se.globals = Object.keys(o2.builtin), se.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.needsParens = function(e3, t3, r3) {
    var n3;
    return !!t3 && (!(!u(t3) || t3.callee !== e3 || !h(e3)) || (null == (n3 = d.get(e3.type)) ? void 0 : n3(e3, t3, r3)));
  }, t2.needsWhitespace = m, t2.needsWhitespaceAfter = function(e3, t3) {
    return m(e3, t3, 2);
  }, t2.needsWhitespaceBefore = function(e3, t3) {
    return m(e3, t3, 1);
  };
  var n2 = r2(410), s2 = r2(411), i2 = r2(0);
  const { FLIPPED_ALIAS_KEYS: o2, isCallExpression: a2, isExpressionStatement: l, isMemberExpression: c, isNewExpression: u } = i2;
  function p(e3) {
    const t3 = /* @__PURE__ */ new Map();
    function r3(e4, r4) {
      const n3 = t3.get(e4);
      t3.set(e4, n3 ? function(e5, t4, s3) {
        var i3;
        return null != (i3 = n3(e5, t4, s3)) ? i3 : r4(e5, t4, s3);
      } : r4);
    }
    for (const t4 of Object.keys(e3)) {
      const n3 = o2[t4];
      if (n3) for (const s3 of n3) r3(s3, e3[t4]);
      else r3(t4, e3[t4]);
    }
    return t3;
  }
  const d = p(s2), f = p(n2.nodes);
  function h(e3) {
    return !!a2(e3) || c(e3) && h(e3.object);
  }
  function m(e3, t3, r3) {
    var n3;
    if (!e3) return false;
    l(e3) && (e3 = e3.expression);
    const s3 = null == (n3 = f.get(e3.type)) ? void 0 : n3(e3, t3);
    return "number" == typeof s3 && 0 != (s3 & r3);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ExportAllDeclaration = function(e3) {
    var t3, r3;
    this.word("export"), this.space(), "type" === e3.exportKind && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), null != (t3 = e3.attributes) && t3.length || null != (r3 = e3.assertions) && r3.length ? (this.print(e3.source, e3, true), this.space(), this._printAttributes(e3)) : this.print(e3.source, e3), this.semicolon();
  }, t2.ExportDefaultDeclaration = function(e3) {
    p(this, e3), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
    const t3 = e3.declaration;
    this.print(t3, e3), c(t3) || this.semicolon();
  }, t2.ExportDefaultSpecifier = function(e3) {
    this.print(e3.exported, e3);
  }, t2.ExportNamedDeclaration = function(e3) {
    if (p(this, e3), this.word("export"), this.space(), e3.declaration) {
      const t4 = e3.declaration;
      this.print(t4, e3), c(t4) || this.semicolon();
    } else {
      "type" === e3.exportKind && (this.word("type"), this.space());
      const n3 = e3.specifiers.slice(0);
      let s3 = false;
      for (; ; ) {
        const t4 = n3[0];
        if (!i2(t4) && !o2(t4)) break;
        s3 = true, this.print(n3.shift(), e3), n3.length && (this.tokenChar(44), this.space());
      }
      var t3, r3;
      (n3.length || !n3.length && !s3) && (this.tokenChar(123), n3.length && (this.space(), this.printList(n3, e3), this.space()), this.tokenChar(125)), e3.source && (this.space(), this.word("from"), this.space(), null != (t3 = e3.attributes) && t3.length || null != (r3 = e3.assertions) && r3.length ? (this.print(e3.source, e3, true), this.space(), this._printAttributes(e3)) : this.print(e3.source, e3)), this.semicolon();
    }
  }, t2.ExportNamespaceSpecifier = function(e3) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e3.exported, e3);
  }, t2.ExportSpecifier = function(e3) {
    "type" === e3.exportKind && (this.word("type"), this.space()), this.print(e3.local, e3), e3.exported && e3.local.name !== e3.exported.name && (this.space(), this.word("as"), this.space(), this.print(e3.exported, e3));
  }, t2.ImportAttribute = function(e3) {
    this.print(e3.key), this.tokenChar(58), this.space(), this.print(e3.value);
  }, t2.ImportDeclaration = function(e3) {
    var t3, r3;
    this.word("import"), this.space();
    const n3 = "type" === e3.importKind || "typeof" === e3.importKind;
    n3 ? (this.noIndentInnerCommentsHere(), this.word(e3.importKind), this.space()) : e3.module ? (this.noIndentInnerCommentsHere(), this.word("module"), this.space()) : e3.phase && (this.noIndentInnerCommentsHere(), this.word(e3.phase), this.space());
    const s3 = e3.specifiers.slice(0), i3 = !!s3.length;
    for (; i3; ) {
      const t4 = s3[0];
      if (!a2(t4) && !l(t4)) break;
      this.print(s3.shift(), e3), s3.length && (this.tokenChar(44), this.space());
    }
    s3.length ? (this.tokenChar(123), this.space(), this.printList(s3, e3), this.space(), this.tokenChar(125)) : n3 && !i3 && (this.tokenChar(123), this.tokenChar(125)), (i3 || n3) && (this.space(), this.word("from"), this.space()), null != (t3 = e3.attributes) && t3.length || null != (r3 = e3.assertions) && r3.length ? (this.print(e3.source, e3, true), this.space(), this._printAttributes(e3)) : this.print(e3.source, e3), this.semicolon();
  }, t2.ImportDefaultSpecifier = function(e3) {
    this.print(e3.local, e3);
  }, t2.ImportExpression = function(e3) {
    this.word("import"), e3.phase && (this.tokenChar(46), this.word(e3.phase)), this.tokenChar(40), this.print(e3.source, e3), null != e3.options && (this.tokenChar(44), this.space(), this.print(e3.options, e3)), this.tokenChar(41);
  }, t2.ImportNamespaceSpecifier = function(e3) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e3.local, e3);
  }, t2.ImportSpecifier = function(e3) {
    "type" !== e3.importKind && "typeof" !== e3.importKind || (this.word(e3.importKind), this.space()), this.print(e3.imported, e3), e3.local && e3.local.name !== e3.imported.name && (this.space(), this.word("as"), this.space(), this.print(e3.local, e3));
  }, t2._printAttributes = function(e3) {
    const { importAttributesKeyword: t3 } = this.format, { attributes: r3, assertions: n3 } = e3;
    !r3 || t3 || u || (u = true);
    const s3 = "assert" === t3 || !t3 && n3;
    this.word(s3 ? "assert" : "with"), this.space(), s3 || "with" === t3 ? (this.tokenChar(123), this.space(), this.printList(r3 || n3, e3), this.space(), this.tokenChar(125)) : this.printList(r3 || n3, e3);
  };
  var n2 = r2(0);
  const { isClassDeclaration: s2, isExportDefaultSpecifier: i2, isExportNamespaceSpecifier: o2, isImportDefaultSpecifier: a2, isImportNamespaceSpecifier: l, isStatement: c } = n2;
  let u = false;
  function p(e3, t3) {
    s2(t3.declaration) && e3._shouldPrintDecoratorsBeforeExport(t3) && e3.printJoin(t3.declaration.decorators, t3);
  }
}, (e2, t2, r2) => {
  r2(44), Object.defineProperty(t2, "__esModule", { value: true }), t2.ArgumentPlaceholder = function() {
    this.tokenChar(63);
  }, t2.ArrayPattern = t2.ArrayExpression = function(e3) {
    const t3 = e3.elements, r3 = t3.length;
    this.tokenChar(91);
    for (let n3 = 0; n3 < t3.length; n3++) {
      const s3 = t3[n3];
      s3 ? (n3 > 0 && this.space(), this.print(s3, e3), n3 < r3 - 1 && this.tokenChar(44)) : this.tokenChar(44);
    }
    this.tokenChar(93);
  }, t2.BigIntLiteral = function(e3) {
    const t3 = this.getPossibleRaw(e3);
    this.format.minified || void 0 === t3 ? this.word(e3.value + "n") : this.word(t3);
  }, t2.BooleanLiteral = function(e3) {
    this.word(e3.value ? "true" : "false");
  }, t2.DecimalLiteral = function(e3) {
    const t3 = this.getPossibleRaw(e3);
    this.format.minified || void 0 === t3 ? this.word(e3.value + "m") : this.word(t3);
  }, t2.Identifier = function(e3) {
    var t3;
    this.sourceIdentifierName((null == (t3 = e3.loc) ? void 0 : t3.identifierName) || e3.name), this.word(e3.name);
  }, t2.NullLiteral = function() {
    this.word("null");
  }, t2.NumericLiteral = function(e3) {
    const t3 = this.getPossibleRaw(e3), r3 = this.format.jsescOption, n3 = e3.value, i3 = n3 + "";
    r3.numbers ? this.number(s2(n3, r3), n3) : null == t3 ? this.number(i3, n3) : this.format.minified ? this.number(t3.length < i3.length ? t3 : i3, n3) : this.number(t3, n3);
  }, t2.ObjectPattern = t2.ObjectExpression = function(e3) {
    const t3 = e3.properties;
    this.tokenChar(123), t3.length && (this.space(), this.printList(t3, e3, { indent: true, statement: true }), this.space()), this.sourceWithOffset("end", e3.loc, -1), this.tokenChar(125);
  }, t2.ObjectMethod = function(e3) {
    this.printJoin(e3.decorators, e3), this._methodHead(e3), this.space(), this.print(e3.body, e3);
  }, t2.ObjectProperty = function(e3) {
    if (this.printJoin(e3.decorators, e3), e3.computed) this.tokenChar(91), this.print(e3.key, e3), this.tokenChar(93);
    else {
      if (i2(e3.value) && o2(e3.key) && e3.key.name === e3.value.left.name) return void this.print(e3.value, e3);
      if (this.print(e3.key, e3), e3.shorthand && o2(e3.key) && o2(e3.value) && e3.key.name === e3.value.name) return;
    }
    this.tokenChar(58), this.space(), this.print(e3.value, e3);
  }, t2.PipelineBareFunction = function(e3) {
    this.print(e3.callee, e3);
  }, t2.PipelinePrimaryTopicReference = function() {
    this.tokenChar(35);
  }, t2.PipelineTopicExpression = function(e3) {
    this.print(e3.expression, e3);
  }, t2.RecordExpression = function(e3) {
    const t3 = e3.properties;
    let r3, n3;
    if ("bar" === this.format.recordAndTupleSyntaxType) r3 = "{|", n3 = "|}";
    else {
      if ("hash" !== this.format.recordAndTupleSyntaxType && null != this.format.recordAndTupleSyntaxType) throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
      r3 = "#{", n3 = "}";
    }
    this.token(r3), t3.length && (this.space(), this.printList(t3, e3, { indent: true, statement: true }), this.space()), this.token(n3);
  }, t2.RegExpLiteral = function(e3) {
    this.word(`/${e3.pattern}/${e3.flags}`);
  }, t2.SpreadElement = t2.RestElement = function(e3) {
    this.token("..."), this.print(e3.argument, e3);
  }, t2.StringLiteral = function(e3) {
    const t3 = this.getPossibleRaw(e3);
    if (!this.format.minified && void 0 !== t3) return void this.token(t3);
    const r3 = s2(e3.value, this.format.jsescOption);
    this.token(r3);
  }, t2.TopicReference = function() {
    const { topicToken: e3 } = this.format;
    if (!a2.has(e3)) {
      const t3 = JSON.stringify(e3), r3 = Array.from(a2, (e4) => JSON.stringify(e4));
      throw new Error(`The "topicToken" generator option must be one of ${r3.join(", ")} (${t3} received instead).`);
    }
    this.token(e3);
  }, t2.TupleExpression = function(e3) {
    const t3 = e3.elements, r3 = t3.length;
    let n3, s3;
    if ("bar" === this.format.recordAndTupleSyntaxType) n3 = "[|", s3 = "|]";
    else {
      if ("hash" !== this.format.recordAndTupleSyntaxType) throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
      n3 = "#[", s3 = "]";
    }
    this.token(n3);
    for (let n4 = 0; n4 < t3.length; n4++) {
      const s4 = t3[n4];
      s4 && (n4 > 0 && this.space(), this.print(s4, e3), n4 < r3 - 1 && this.tokenChar(44));
    }
    this.token(s3);
  };
  var n2 = r2(0), s2 = r2(205);
  const { isAssignmentPattern: i2, isIdentifier: o2 } = n2, a2 = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
}, (e2, t2, r2) => {
  var n2 = r2(105), s2 = TypeError;
  e2.exports = function(e3) {
    if (n2(e3)) throw new s2("Can't call method on " + e3);
    return e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(15), s2 = r2(29), i2 = Function.prototype, o2 = n2 && Object.getOwnPropertyDescriptor, a2 = s2(i2, "name"), l = a2 && "something" === (function() {
  }).name, c = a2 && (!n2 || n2 && o2(i2, "name").configurable);
  e2.exports = { EXISTS: a2, PROPER: l, CONFIGURABLE: c };
}, (e2, t2, r2) => {
  var n2 = r2(19), s2 = r2(6), i2 = r2(64), o2 = n2(Function.toString);
  s2(i2.inspectSource) || (i2.inspectSource = function(e3) {
    return o2(e3);
  }), e2.exports = i2.inspectSource;
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(6), i2 = n2.WeakMap;
  e2.exports = s2(i2) && /native code/.test(String(i2));
}, (e2, t2, r2) => {
  var n2 = r2(15), s2 = r2(11), i2 = r2(192);
  e2.exports = !n2 && !s2(function() {
    return 7 !== Object.defineProperty(i2("div"), "a", { get: function() {
      return 7;
    } }).a;
  });
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(20), i2 = n2.document, o2 = s2(i2) && s2(i2.createElement);
  e2.exports = function(e3) {
    return o2 ? i2.createElement(e3) : {};
  };
}, (e2, t2, r2) => {
  var n2 = r2(15), s2 = r2(11);
  e2.exports = n2 && s2(function() {
    return 42 !== Object.defineProperty(function() {
    }, "prototype", { value: 42, writable: false }).prototype;
  });
}, (e2, t2, r2) => {
  var n2 = r2(195), s2 = r2(110);
  e2.exports = function(e3) {
    var t3 = n2(e3, "string");
    return s2(t3) ? t3 : t3 + "";
  };
}, (e2, t2, r2) => {
  var n2 = r2(66), s2 = r2(20), i2 = r2(110), o2 = r2(199), a2 = r2(200), l = r2(45), c = TypeError, u = l("toPrimitive");
  e2.exports = function(e3, t3) {
    if (!s2(e3) || i2(e3)) return e3;
    var r3, l2 = o2(e3, u);
    if (l2) {
      if (void 0 === t3 && (t3 = "default"), r3 = n2(l2, e3, t3), !s2(r3) || i2(r3)) return r3;
      throw new c("Can't convert object to primitive value");
    }
    return void 0 === t3 && (t3 = "number"), a2(e3, t3);
  };
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(6);
  e2.exports = function(e3, t3) {
    return arguments.length < 2 ? (r3 = n2[e3], s2(r3) ? r3 : void 0) : n2[e3] && n2[e3][t3];
    var r3;
  };
}, (e2, t2, r2) => {
  var n2, s2, i2 = r2(5), o2 = r2(198), a2 = i2.process, l = i2.Deno, c = a2 && a2.versions || l && l.version, u = c && c.v8;
  u && (s2 = (n2 = u.split("."))[0] > 0 && n2[0] < 4 ? 1 : +(n2[0] + n2[1])), !s2 && o2 && (!(n2 = o2.match(/Edge\/(\d+)/)) || n2[1] >= 74) && (n2 = o2.match(/Chrome\/(\d+)/)) && (s2 = +n2[1]), e2.exports = s2;
}, (e2) => {
  e2.exports = "undefined" != typeof navigator && String(navigator.userAgent) || "";
}, (e2, t2, r2) => {
  var n2 = r2(114), s2 = r2(105);
  e2.exports = function(e3, t3) {
    var r3 = e3[t3];
    return s2(r3) ? void 0 : n2(r3);
  };
}, (e2, t2, r2) => {
  var n2 = r2(66), s2 = r2(6), i2 = r2(20), o2 = TypeError;
  e2.exports = function(e3, t3) {
    var r3, a2;
    if ("string" === t3 && s2(r3 = e3.toString) && !i2(a2 = n2(r3, e3))) return a2;
    if (s2(r3 = e3.valueOf) && !i2(a2 = n2(r3, e3))) return a2;
    if ("string" !== t3 && s2(r3 = e3.toString) && !i2(a2 = n2(r3, e3))) return a2;
    throw new o2("Can't convert object to primitive value");
  };
}, (e2) => {
  e2.exports = false;
}, (e2) => {
  e2.exports = function(e3, t2) {
    return { enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t2 };
  };
}, (e2) => {
  e2.exports = {};
}, (e2, t2, r2) => {
  var n2 = r2(65);
  e2.exports = function() {
    var e3 = n2(this), t3 = "";
    return e3.hasIndices && (t3 += "d"), e3.global && (t3 += "g"), e3.ignoreCase && (t3 += "i"), e3.multiline && (t3 += "m"), e3.dotAll && (t3 += "s"), e3.unicode && (t3 += "u"), e3.unicodeSets && (t3 += "v"), e3.sticky && (t3 += "y"), t3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(31).a;
  const s2 = {}, i2 = s2.hasOwnProperty, o2 = (e3, t3) => {
    for (const r3 in e3) i2.call(e3, r3) && t3(r3, e3[r3]);
  }, a2 = s2.toString, l = Array.isArray, c = n2.isBuffer, u = { '"': '\\"', "'": "\\'", "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t" }, p = /["'\\\b\f\n\r\t]/, d = /[0-9]/, f = /[ !#-&\(-\[\]-_a-~]/, h = (e3, t3) => {
    const r3 = () => {
      E = v, ++t3.indentLevel, v = t3.indent.repeat(t3.indentLevel);
    }, n3 = { escapeEverything: false, minimal: false, isScriptContext: false, quotes: "single", wrap: false, es6: false, json: false, compact: true, lowercaseHex: false, numbers: "decimal", indent: "	", indentLevel: 0, __inline1__: false, __inline2__: false }, s3 = t3 && t3.json;
    var i3, m;
    s3 && (n3.quotes = "double", n3.wrap = true), i3 = n3, t3 = (m = t3) ? (o2(m, (e4, t4) => {
      i3[e4] = t4;
    }), i3) : i3, "single" != t3.quotes && "double" != t3.quotes && "backtick" != t3.quotes && (t3.quotes = "single");
    const y = "double" == t3.quotes ? '"' : "backtick" == t3.quotes ? "`" : "'", g = t3.compact, b = t3.lowercaseHex;
    let v = t3.indent.repeat(t3.indentLevel), E = "";
    const S = t3.__inline1__, x = t3.__inline2__, T = g ? "" : "\n";
    let w, P = true;
    const A = "binary" == t3.numbers, C = "octal" == t3.numbers, O = "decimal" == t3.numbers, I = "hexadecimal" == t3.numbers;
    if (s3 && e3 && "function" == typeof e3.toJSON && (e3 = e3.toJSON()), "string" != typeof (_ = e3) && "[object String]" != a2.call(_)) {
      if (((e4) => "[object Map]" == a2.call(e4))(e3)) return 0 == e3.size ? "new Map()" : (g || (t3.__inline1__ = true, t3.__inline2__ = false), "new Map(" + h(Array.from(e3), t3) + ")");
      if (((e4) => "[object Set]" == a2.call(e4))(e3)) return 0 == e3.size ? "new Set()" : "new Set(" + h(Array.from(e3), t3) + ")";
      if (c(e3)) return 0 == e3.length ? "Buffer.from([])" : "Buffer.from(" + h(Array.from(e3), t3) + ")";
      if (l(e3)) return w = [], t3.wrap = true, S && (t3.__inline1__ = false, t3.__inline2__ = true), x || r3(), ((e4, t4) => {
        const r4 = e4.length;
        let n4 = -1;
        for (; ++n4 < r4; ) t4(e4[n4]);
      })(e3, (e4) => {
        P = false, x && (t3.__inline2__ = false), w.push((g || x ? "" : v) + h(e4, t3));
      }), P ? "[]" : x ? "[" + w.join(", ") + "]" : "[" + T + w.join("," + T) + T + (g ? "" : E) + "]";
      if (!((e4) => "number" == typeof e4 || "[object Number]" == a2.call(e4))(e3)) return ((e4) => "[object Object]" == a2.call(e4))(e3) ? (w = [], t3.wrap = true, r3(), o2(e3, (e4, r4) => {
        P = false, w.push((g ? "" : v) + h(e4, t3) + ":" + (g ? "" : " ") + h(r4, t3));
      }), P ? "{}" : "{" + T + w.join("," + T) + T + (g ? "" : E) + "}") : s3 ? JSON.stringify(e3) || "null" : String(e3);
      if (s3) return JSON.stringify(e3);
      if (O) return String(e3);
      if (I) {
        let t4 = e3.toString(16);
        return b || (t4 = t4.toUpperCase()), "0x" + t4;
      }
      if (A) return "0b" + e3.toString(2);
      if (C) return "0o" + e3.toString(8);
    }
    var _;
    const k = e3;
    let N = -1;
    const D = k.length;
    for (w = ""; ++N < D; ) {
      const e4 = k.charAt(N);
      if (t3.es6) {
        const e5 = k.charCodeAt(N);
        if (e5 >= 55296 && e5 <= 56319 && D > N + 1) {
          const t4 = k.charCodeAt(N + 1);
          if (t4 >= 56320 && t4 <= 57343) {
            let r5 = (1024 * (e5 - 55296) + t4 - 56320 + 65536).toString(16);
            b || (r5 = r5.toUpperCase()), w += "\\u{" + r5 + "}", ++N;
            continue;
          }
        }
      }
      if (!t3.escapeEverything) {
        if (f.test(e4)) {
          w += e4;
          continue;
        }
        if ('"' == e4) {
          w += y == e4 ? '\\"' : e4;
          continue;
        }
        if ("`" == e4) {
          w += y == e4 ? "\\`" : e4;
          continue;
        }
        if ("'" == e4) {
          w += y == e4 ? "\\'" : e4;
          continue;
        }
      }
      if ("\0" == e4 && !s3 && !d.test(k.charAt(N + 1))) {
        w += "\\0";
        continue;
      }
      if (p.test(e4)) {
        w += u[e4];
        continue;
      }
      const r4 = e4.charCodeAt(0);
      if (t3.minimal && 8232 != r4 && 8233 != r4) {
        w += e4;
        continue;
      }
      let n4 = r4.toString(16);
      b || (n4 = n4.toUpperCase());
      const i4 = n4.length > 2 || s3, o3 = "\\" + (i4 ? "u" : "x") + ("0000" + n4).slice(i4 ? -4 : -2);
      w += o3;
    }
    return t3.wrap && (w = y + w + y), "`" == y && (w = w.replace(/\$\{/g, "\\${")), t3.isScriptContext ? w.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, s3 ? "\\u003C!--" : "\\x3C!--") : w;
  };
  h.version = "2.5.2", e2.exports = h;
}, (e2, t2, r2) => {
  var n2, s2, i2, o2 = r2(207), a2 = r2(15), l = r2(5), c = r2(6), u = r2(20), p = r2(29), d = r2(208), f = r2(115), h = r2(108), m = r2(211), y = r2(102), g = r2(111), b = r2(212), v = r2(214), E = r2(45), S = r2(67), x = r2(107), T = x.enforce, w = x.get, P = l.Int8Array, A = P && P.prototype, C = l.Uint8ClampedArray, O = C && C.prototype, I = P && b(P), _ = A && b(A), k = Object.prototype, N = l.TypeError, D = E("toStringTag"), j = S("TYPED_ARRAY_TAG"), L = "TypedArrayConstructor", M = o2 && !!v && "Opera" !== d(l.opera), B = false, R = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, F = { BigInt64Array: 8, BigUint64Array: 8 }, U = function(e3) {
    var t3 = b(e3);
    if (u(t3)) {
      var r3 = w(t3);
      return r3 && p(r3, L) ? r3[L] : U(t3);
    }
  }, $ = function(e3) {
    if (!u(e3)) return false;
    var t3 = d(e3);
    return p(R, t3) || p(F, t3);
  };
  for (n2 in R) (i2 = (s2 = l[n2]) && s2.prototype) ? T(i2)[L] = s2 : M = false;
  for (n2 in F) (i2 = (s2 = l[n2]) && s2.prototype) && (T(i2)[L] = s2);
  if ((!M || !c(I) || I === Function.prototype) && (I = function() {
    throw new N("Incorrect invocation");
  }, M)) for (n2 in R) l[n2] && v(l[n2], I);
  if ((!M || !_ || _ === k) && (_ = I.prototype, M)) for (n2 in R) l[n2] && v(l[n2].prototype, _);
  if (M && b(O) !== _ && v(O, _), a2 && !p(_, D)) for (n2 in B = true, y(_, D, { configurable: true, get: function() {
    return u(this) ? this[j] : void 0;
  } }), R) l[n2] && h(l[n2], j, n2);
  e2.exports = { NATIVE_ARRAY_BUFFER_VIEWS: M, TYPED_ARRAY_TAG: B && j, aTypedArray: function(e3) {
    if ($(e3)) return e3;
    throw new N("Target is not a typed array");
  }, aTypedArrayConstructor: function(e3) {
    if (c(e3) && (!v || g(I, e3))) return e3;
    throw new N(f(e3) + " is not a typed array constructor");
  }, exportTypedArrayMethod: function(e3, t3, r3, n3) {
    if (a2) {
      if (r3) for (var s3 in R) {
        var i3 = l[s3];
        if (i3 && p(i3.prototype, e3)) try {
          delete i3.prototype[e3];
        } catch (r4) {
          try {
            i3.prototype[e3] = t3;
          } catch (e4) {
          }
        }
      }
      _[e3] && !r3 || m(_, e3, r3 ? t3 : M && A[e3] || t3, n3);
    }
  }, exportTypedArrayStaticMethod: function(e3, t3, r3) {
    var n3, s3;
    if (a2) {
      if (v) {
        if (r3) {
          for (n3 in R) if ((s3 = l[n3]) && p(s3, e3)) try {
            delete s3[e3];
          } catch (e4) {
          }
        }
        if (I[e3] && !r3) return;
        try {
          return m(I, e3, r3 ? t3 : M && I[e3] || t3);
        } catch (e4) {
        }
      }
      for (n3 in R) !(s3 = l[n3]) || s3[e3] && !r3 || m(s3, e3, t3);
    }
  }, getTypedArrayConstructor: U, isView: function(e3) {
    if (!u(e3)) return false;
    var t3 = d(e3);
    return "DataView" === t3 || p(R, t3) || p(F, t3);
  }, isTypedArray: $, TypedArray: I, TypedArrayPrototype: _ };
}, (e2) => {
  e2.exports = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView;
}, (e2, t2, r2) => {
  var n2 = r2(209), s2 = r2(6), i2 = r2(210), o2 = r2(45)("toStringTag"), a2 = Object, l = "Arguments" === i2(/* @__PURE__ */ function() {
    return arguments;
  }());
  e2.exports = n2 ? i2 : function(e3) {
    var t3, r3, n3;
    return void 0 === e3 ? "Undefined" : null === e3 ? "Null" : "string" == typeof (r3 = function(e4, t4) {
      try {
        return e4[t4];
      } catch (e5) {
      }
    }(t3 = a2(e3), o2)) ? r3 : l ? i2(t3) : "Object" === (n3 = i2(t3)) && s2(t3.callee) ? "Arguments" : n3;
  };
}, (e2, t2, r2) => {
  var n2 = {};
  n2[r2(45)("toStringTag")] = "z", e2.exports = "[object z]" === String(n2);
}, (e2, t2, r2) => {
  var n2 = r2(19), s2 = n2({}.toString), i2 = n2("".slice);
  e2.exports = function(e3) {
    return i2(s2(e3), 8, -1);
  };
}, (e2, t2, r2) => {
  var n2 = r2(6), s2 = r2(109), i2 = r2(103), o2 = r2(106);
  e2.exports = function(e3, t3, r3, a2) {
    a2 || (a2 = {});
    var l = a2.enumerable, c = void 0 !== a2.name ? a2.name : t3;
    if (n2(r3) && i2(r3, c, a2), a2.global) l ? e3[t3] = r3 : o2(t3, r3);
    else {
      try {
        a2.unsafe ? e3[t3] && (l = true) : delete e3[t3];
      } catch (e4) {
      }
      l ? e3[t3] = r3 : s2.f(e3, t3, { value: r3, enumerable: false, configurable: !a2.nonConfigurable, writable: !a2.nonWritable });
    }
    return e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(29), s2 = r2(6), i2 = r2(63), o2 = r2(117), a2 = r2(213), l = o2("IE_PROTO"), c = Object, u = c.prototype;
  e2.exports = a2 ? c.getPrototypeOf : function(e3) {
    var t3 = i2(e3);
    if (n2(t3, l)) return t3[l];
    var r3 = t3.constructor;
    return s2(r3) && t3 instanceof r3 ? r3.prototype : t3 instanceof c ? u : null;
  };
}, (e2, t2, r2) => {
  var n2 = r2(11);
  e2.exports = !n2(function() {
    function e3() {
    }
    return e3.prototype.constructor = null, Object.getPrototypeOf(new e3()) !== e3.prototype;
  });
}, (e2, t2, r2) => {
  var n2 = r2(215), s2 = r2(65), i2 = r2(216);
  e2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
    var e3, t3 = false, r3 = {};
    try {
      (e3 = n2(Object.prototype, "__proto__", "set"))(r3, []), t3 = r3 instanceof Array;
    } catch (e4) {
    }
    return function(r4, n3) {
      return s2(r4), i2(n3), t3 ? e3(r4, n3) : r4.__proto__ = n3, r4;
    };
  }() : void 0);
}, (e2, t2, r2) => {
  var n2 = r2(19), s2 = r2(114);
  e2.exports = function(e3, t3, r3) {
    try {
      return n2(s2(Object.getOwnPropertyDescriptor(e3, t3)[r3]));
    } catch (e4) {
    }
  };
}, (e2, t2, r2) => {
  var n2 = r2(217), s2 = String, i2 = TypeError;
  e2.exports = function(e3) {
    if (n2(e3)) return e3;
    throw new i2("Can't set " + s2(e3) + " as a prototype");
  };
}, (e2, t2, r2) => {
  var n2 = r2(20);
  e2.exports = function(e3) {
    return n2(e3) || null === e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(219);
  e2.exports = function(e3) {
    return n2(e3.length);
  };
}, (e2, t2, r2) => {
  var n2 = r2(118), s2 = Math.min;
  e2.exports = function(e3) {
    var t3 = n2(e3);
    return t3 > 0 ? s2(t3, 9007199254740991) : 0;
  };
}, (e2) => {
  var t2 = Math.ceil, r2 = Math.floor;
  e2.exports = Math.trunc || function(e3) {
    var n2 = +e3;
    return (n2 > 0 ? r2 : t2)(n2);
  };
}, (e2, t2, r2) => {
  var n2 = r2(222), s2 = RangeError;
  e2.exports = function(e3, t3) {
    var r3 = n2(e3);
    if (r3 % t3) throw new s2("Wrong offset");
    return r3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(118), s2 = RangeError;
  e2.exports = function(e3) {
    var t3 = n2(e3);
    if (t3 < 0) throw new s2("The argument can't be less than 0");
    return t3;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.createUnionType = function(e3) {
    return a2(e3[0]) ? s2 ? s2(e3) : o2(e3) : i2 ? i2(e3) : void 0;
  };
  var n2 = r2(0);
  const { createFlowUnionType: s2, createTSUnionType: i2, createUnionTypeAnnotation: o2, isFlowType: a2, isTSType: l } = n2;
}, (e2) => {
  e2.exports = { grey: null, red: { bold: null } };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    const { placeholderWhitelist: n3, placeholderPattern: o3, preserveComments: a3, syntacticPlaceholders: l2 } = r3, c2 = function(e4, t4, r4) {
      const n4 = (t4.plugins || []).slice();
      false !== r4 && n4.push("placeholders"), t4 = Object.assign({ allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, sourceType: "module" }, t4, { plugins: n4 });
      try {
        return (0, s2.parse)(e4, t4);
      } catch (t5) {
        const r5 = t5.loc;
        throw r5 && (t5.message += "\n" + (0, i2.codeFrameColumns)(e4, { start: r5 }), t5.code = "BABEL_TEMPLATE_PARSE_ERROR"), t5;
      }
    }(t3, r3.parser, l2);
    m(c2, { preserveComments: a3 }), e3.validate(c2);
    const u2 = { syntactic: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, legacy: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, placeholderWhitelist: n3, placeholderPattern: o3, syntacticPlaceholders: l2 };
    return y(c2, b, u2), Object.assign({ ast: c2 }, u2.syntactic.placeholders.length ? u2.syntactic : u2.legacy);
  };
  var n2 = r2(0), s2 = r2(21), i2 = r2(36);
  const { isCallExpression: o2, isExpressionStatement: a2, isFunction: l, isIdentifier: c, isJSXIdentifier: u, isNewExpression: p, isPlaceholder: d, isStatement: f, isStringLiteral: h, removePropertiesDeep: m, traverse: y } = n2, g = /^[_$A-Z0-9]+$/;
  function b(e3, t3, r3) {
    var n3;
    let s3, i3 = r3.syntactic.placeholders.length > 0;
    if (d(e3)) {
      if (false === r3.syntacticPlaceholders) throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      s3 = e3.name.name, i3 = true;
    } else {
      if (i3 || r3.syntacticPlaceholders) return;
      if (c(e3) || u(e3)) s3 = e3.name;
      else {
        if (!h(e3)) return;
        s3 = e3.value;
      }
    }
    if (i3 && (null != r3.placeholderPattern || null != r3.placeholderWhitelist)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (!(i3 || false !== r3.placeholderPattern && (r3.placeholderPattern || g).test(s3) || null != (n3 = r3.placeholderWhitelist) && n3.has(s3))) return;
    t3 = t3.slice();
    const { node: m2, key: y2 } = t3[t3.length - 1];
    let b2;
    h(e3) || d(e3, { expectedNode: "StringLiteral" }) ? b2 = "string" : p(m2) && "arguments" === y2 || o2(m2) && "arguments" === y2 || l(m2) && "params" === y2 ? b2 = "param" : a2(m2) && !d(e3) ? (b2 = "statement", t3 = t3.slice(0, -1)) : b2 = f(e3) && d(e3) ? "statement" : "other";
    const { placeholders: v, placeholderNames: E } = i3 ? r3.syntactic : r3.legacy;
    v.push({ name: s3, type: b2, resolve: (e4) => function(e5, t4) {
      let r4 = e5;
      for (let e6 = 0; e6 < t4.length - 1; e6++) {
        const { key: n5, index: s5 } = t4[e6];
        r4 = void 0 === s5 ? r4[n5] : r4[n5][s5];
      }
      const { key: n4, index: s4 } = t4[t4.length - 1];
      return { parent: r4, key: n4, index: s4 };
    }(e4, t3), isDuplicate: E.has(s3) }), E.add(s3);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const r3 = i2(e3.ast);
    return t3 && (e3.placeholders.forEach((e4) => {
      if (!Object.prototype.hasOwnProperty.call(t3, e4.name)) {
        const t4 = e4.name;
        throw new Error(`Error: No substitution given for "${t4}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${t4}'])}
            - { placeholderPattern: /^${t4}$/ }`);
      }
    }), Object.keys(t3).forEach((t4) => {
      if (!e3.placeholderNames.has(t4)) throw new Error(`Unknown substitution "${t4}" given`);
    })), e3.placeholders.slice().reverse().forEach((e4) => {
      try {
        !function(e5, t4, r4) {
          e5.isDuplicate && (Array.isArray(r4) ? r4 = r4.map((e6) => i2(e6)) : "object" == typeof r4 && (r4 = i2(r4)));
          const { parent: n3, key: f, index: h } = e5.resolve(t4);
          if ("string" === e5.type) {
            if ("string" == typeof r4 && (r4 = p(r4)), !r4 || !u(r4)) throw new Error("Expected string substitution");
          } else if ("statement" === e5.type) void 0 === h ? r4 ? Array.isArray(r4) ? r4 = s2(r4) : "string" == typeof r4 ? r4 = a2(l(r4)) : c(r4) || (r4 = a2(r4)) : r4 = o2() : r4 && !Array.isArray(r4) && ("string" == typeof r4 && (r4 = l(r4)), c(r4) || (r4 = a2(r4)));
          else if ("param" === e5.type) {
            if ("string" == typeof r4 && (r4 = l(r4)), void 0 === h) throw new Error("Assertion failure.");
          } else if ("string" == typeof r4 && (r4 = l(r4)), Array.isArray(r4)) throw new Error("Cannot replace single expression with an array.");
          if (void 0 === h) d(n3, f, r4), n3[f] = r4;
          else {
            const t5 = n3[f].slice();
            "statement" === e5.type || "param" === e5.type ? null == r4 ? t5.splice(h, 1) : Array.isArray(r4) ? t5.splice(h, 1, ...r4) : t5[h] = r4 : t5[h] = r4, d(n3, f, t5), n3[f] = t5;
          }
        }(e4, r3, t3 && t3[e4.name] || null);
      } catch (t4) {
        throw t4.message = `@babel/template placeholder "${e4.name}": ${t4.message}`, t4;
      }
    }), r3;
  };
  var n2 = r2(0);
  const { blockStatement: s2, cloneNode: i2, emptyStatement: o2, expressionStatement: a2, identifier: l, isStatement: c, isStringLiteral: u, stringLiteral: p, validate: d } = n2;
}, (e2, t2, r2) => {
  function n2(e3) {
    return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
      return typeof e4;
    } : function(e4) {
      return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
    }, n2(e3);
  }
  function s2(e3, t3) {
    return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
      return e4.__proto__ = t4, e4;
    }, s2(e3, t3);
  }
  function i2(e3) {
    return i2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
      return e4.__proto__ || Object.getPrototypeOf(e4);
    }, i2(e3);
  }
  var o2, a2, l = {};
  function c(e3, t3, r3) {
    r3 || (r3 = Error);
    var o3 = function(r4) {
      !function(e4, t4) {
        if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
        e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && s2(e4, t4);
      }(u2, r4);
      var o4, a3, l2, c2 = (a3 = u2, l2 = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if ("function" == typeof Proxy) return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (e4) {
          return false;
        }
      }(), function() {
        var e4, t4 = i2(a3);
        if (l2) {
          var r5 = i2(this).constructor;
          e4 = Reflect.construct(t4, arguments, r5);
        } else e4 = t4.apply(this, arguments);
        return function(e5, t5) {
          if (t5 && ("object" === n2(t5) || "function" == typeof t5)) return t5;
          if (void 0 !== t5) throw new TypeError("Derived constructors may only return object or undefined");
          return function(e6) {
            if (void 0 === e6) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e6;
          }(e5);
        }(this, e4);
      });
      function u2(r5, n3, s3) {
        var i3;
        return function(e4, t4) {
          if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
        }(this, u2), i3 = c2.call(this, function(e4, r6, n4) {
          return "string" == typeof t3 ? t3 : t3(e4, r6, n4);
        }(r5, n3, s3)), i3.code = e3, i3;
      }
      return o4 = u2, Object.defineProperty(o4, "prototype", { writable: false }), o4;
    }(r3);
    l[e3] = o3;
  }
  function u(e3, t3) {
    if (Array.isArray(e3)) {
      var r3 = e3.length;
      return e3 = e3.map(function(e4) {
        return String(e4);
      }), r3 > 2 ? "one of ".concat(t3, " ").concat(e3.slice(0, r3 - 1).join(", "), ", or ") + e3[r3 - 1] : 2 === r3 ? "one of ".concat(t3, " ").concat(e3[0], " or ").concat(e3[1]) : "of ".concat(t3, " ").concat(e3[0]);
    }
    return "of ".concat(t3, " ").concat(String(e3));
  }
  c("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), c("ERR_INVALID_ARG_TYPE", function(e3, t3, s3) {
    var i3, a3, l2, c2, p;
    if (void 0 === o2 && (o2 = r2(25)), o2("string" == typeof e3, "'name' must be a string"), "string" == typeof t3 && (a3 = "not ", t3.substr(0, 4) === a3) ? (i3 = "must not be", t3 = t3.replace(/^not /, "")) : i3 = "must be", function(e4, t4, r3) {
      return (void 0 === r3 || r3 > e4.length) && (r3 = e4.length), e4.substring(r3 - 9, r3) === t4;
    }(e3, " argument")) l2 = "The ".concat(e3, " ").concat(i3, " ").concat(u(t3, "type"));
    else {
      var d = ("number" != typeof p && (p = 0), p + 1 > (c2 = e3).length || -1 === c2.indexOf(".", p) ? "argument" : "property");
      l2 = 'The "'.concat(e3, '" ').concat(d, " ").concat(i3, " ").concat(u(t3, "type"));
    }
    return l2 + ". Received type ".concat(n2(s3));
  }, TypeError), c("ERR_INVALID_ARG_VALUE", function(e3, t3) {
    var n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
    void 0 === a2 && (a2 = r2(32));
    var s3 = a2.inspect(t3);
    return s3.length > 128 && (s3 = "".concat(s3.slice(0, 128), "...")), "The argument '".concat(e3, "' ").concat(n3, ". Received ").concat(s3);
  }, TypeError, RangeError), c("ERR_INVALID_RETURN_VALUE", function(e3, t3, r3) {
    var s3;
    return s3 = r3 && r3.constructor && r3.constructor.name ? "instance of ".concat(r3.constructor.name) : "type ".concat(n2(r3)), "Expected ".concat(e3, ' to be returned from the "').concat(t3, '"') + " function but got ".concat(s3, ".");
  }, TypeError), c("ERR_MISSING_ARGS", function() {
    for (var e3 = arguments.length, t3 = new Array(e3), n3 = 0; n3 < e3; n3++) t3[n3] = arguments[n3];
    void 0 === o2 && (o2 = r2(25)), o2(t3.length > 0, "At least one arg needs to be specified");
    var s3 = "The ", i3 = t3.length;
    switch (t3 = t3.map(function(e4) {
      return '"'.concat(e4, '"');
    }), i3) {
      case 1:
        s3 += "".concat(t3[0], " argument");
        break;
      case 2:
        s3 += "".concat(t3[0], " and ").concat(t3[1], " arguments");
        break;
      default:
        s3 += t3.slice(0, i3 - 1).join(", "), s3 += ", and ".concat(t3[i3 - 1], " arguments");
    }
    return "".concat(s3, " must be specified");
  }, TypeError), e2.exports.codes = l;
}, (e2, t2, r2) => {
  r2(12);
  var n2 = r2(229), s2 = r2(235), i2 = r2(122), o2 = r2(239);
  function a2(e3) {
    return e3.call.bind(e3);
  }
  var l = "undefined" != typeof BigInt, c = "undefined" != typeof Symbol, u = a2(Object.prototype.toString), p = a2(Number.prototype.valueOf), d = a2(String.prototype.valueOf), f = a2(Boolean.prototype.valueOf);
  if (l) var h = a2(BigInt.prototype.valueOf);
  if (c) var m = a2(Symbol.prototype.valueOf);
  function y(e3, t3) {
    if ("object" != typeof e3) return false;
    try {
      return t3(e3), true;
    } catch (e4) {
      return false;
    }
  }
  function g(e3) {
    return "[object Map]" === u(e3);
  }
  function b(e3) {
    return "[object Set]" === u(e3);
  }
  function v(e3) {
    return "[object WeakMap]" === u(e3);
  }
  function E(e3) {
    return "[object WeakSet]" === u(e3);
  }
  function S(e3) {
    return "[object ArrayBuffer]" === u(e3);
  }
  function x(e3) {
    return "undefined" != typeof ArrayBuffer && (S.working ? S(e3) : e3 instanceof ArrayBuffer);
  }
  function T(e3) {
    return "[object DataView]" === u(e3);
  }
  function w(e3) {
    return "undefined" != typeof DataView && (T.working ? T(e3) : e3 instanceof DataView);
  }
  t2.isArgumentsObject = n2, t2.isGeneratorFunction = s2, t2.isTypedArray = o2, t2.isPromise = function(e3) {
    return "undefined" != typeof Promise && e3 instanceof Promise || null !== e3 && "object" == typeof e3 && "function" == typeof e3.then && "function" == typeof e3.catch;
  }, t2.isArrayBufferView = function(e3) {
    return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e3) : o2(e3) || w(e3);
  }, t2.isUint8Array = function(e3) {
    return "Uint8Array" === i2(e3);
  }, t2.isUint8ClampedArray = function(e3) {
    return "Uint8ClampedArray" === i2(e3);
  }, t2.isUint16Array = function(e3) {
    return "Uint16Array" === i2(e3);
  }, t2.isUint32Array = function(e3) {
    return "Uint32Array" === i2(e3);
  }, t2.isInt8Array = function(e3) {
    return "Int8Array" === i2(e3);
  }, t2.isInt16Array = function(e3) {
    return "Int16Array" === i2(e3);
  }, t2.isInt32Array = function(e3) {
    return "Int32Array" === i2(e3);
  }, t2.isFloat32Array = function(e3) {
    return "Float32Array" === i2(e3);
  }, t2.isFloat64Array = function(e3) {
    return "Float64Array" === i2(e3);
  }, t2.isBigInt64Array = function(e3) {
    return "BigInt64Array" === i2(e3);
  }, t2.isBigUint64Array = function(e3) {
    return "BigUint64Array" === i2(e3);
  }, g.working = "undefined" != typeof Map && g(/* @__PURE__ */ new Map()), t2.isMap = function(e3) {
    return "undefined" != typeof Map && (g.working ? g(e3) : e3 instanceof Map);
  }, b.working = "undefined" != typeof Set && b(/* @__PURE__ */ new Set()), t2.isSet = function(e3) {
    return "undefined" != typeof Set && (b.working ? b(e3) : e3 instanceof Set);
  }, v.working = "undefined" != typeof WeakMap && v(/* @__PURE__ */ new WeakMap()), t2.isWeakMap = function(e3) {
    return "undefined" != typeof WeakMap && (v.working ? v(e3) : e3 instanceof WeakMap);
  }, E.working = "undefined" != typeof WeakSet && E(/* @__PURE__ */ new WeakSet()), t2.isWeakSet = function(e3) {
    return E(e3);
  }, S.working = "undefined" != typeof ArrayBuffer && S(new ArrayBuffer()), t2.isArrayBuffer = x, T.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && T(new DataView(new ArrayBuffer(1), 0, 1)), t2.isDataView = w;
  var P = "undefined" != typeof SharedArrayBuffer ? SharedArrayBuffer : void 0;
  function A(e3) {
    return "[object SharedArrayBuffer]" === u(e3);
  }
  function C(e3) {
    return void 0 !== P && (void 0 === A.working && (A.working = A(new P())), A.working ? A(e3) : e3 instanceof P);
  }
  function O(e3) {
    return y(e3, p);
  }
  function I(e3) {
    return y(e3, d);
  }
  function _(e3) {
    return y(e3, f);
  }
  function k(e3) {
    return l && y(e3, h);
  }
  function N(e3) {
    return c && y(e3, m);
  }
  t2.isSharedArrayBuffer = C, t2.isAsyncFunction = function(e3) {
    return "[object AsyncFunction]" === u(e3);
  }, t2.isMapIterator = function(e3) {
    return "[object Map Iterator]" === u(e3);
  }, t2.isSetIterator = function(e3) {
    return "[object Set Iterator]" === u(e3);
  }, t2.isGeneratorObject = function(e3) {
    return "[object Generator]" === u(e3);
  }, t2.isWebAssemblyCompiledModule = function(e3) {
    return "[object WebAssembly.Module]" === u(e3);
  }, t2.isNumberObject = O, t2.isStringObject = I, t2.isBooleanObject = _, t2.isBigIntObject = k, t2.isSymbolObject = N, t2.isBoxedPrimitive = function(e3) {
    return O(e3) || I(e3) || _(e3) || k(e3) || N(e3);
  }, t2.isAnyArrayBuffer = function(e3) {
    return "undefined" != typeof Uint8Array && (x(e3) || C(e3));
  }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e3) {
    Object.defineProperty(t2, e3, { enumerable: false, value: function() {
      throw new Error(e3 + " is not supported in userland");
    } });
  });
}, (e2, t2, r2) => {
  var n2 = r2(69)(), s2 = r2(38)("Object.prototype.toString"), i2 = function(e3) {
    return !(n2 && e3 && "object" == typeof e3 && Symbol.toStringTag in e3) && "[object Arguments]" === s2(e3);
  }, o2 = function(e3) {
    return !!i2(e3) || null !== e3 && "object" == typeof e3 && "number" == typeof e3.length && e3.length >= 0 && "[object Array]" !== s2(e3) && "[object Function]" === s2(e3.callee);
  }, a2 = function() {
    return i2(arguments);
  }();
  i2.isLegacyArguments = o2, e2.exports = a2 ? i2 : o2;
}, (e2, t2, r2) => {
  var n2 = "undefined" != typeof Symbol && Symbol, s2 = r2(70);
  e2.exports = function() {
    return "function" == typeof n2 && "function" == typeof Symbol && "symbol" == typeof n2("foo") && "symbol" == typeof Symbol("bar") && s2();
  };
}, (e2) => {
  var t2 = { foo: {} }, r2 = Object;
  e2.exports = function() {
    return { __proto__: t2 }.foo === t2.foo && !({ __proto__: null } instanceof r2);
  };
}, (e2) => {
  var t2 = Object.prototype.toString, r2 = Math.max, n2 = function(e3, t3) {
    for (var r3 = [], n3 = 0; n3 < e3.length; n3 += 1) r3[n3] = e3[n3];
    for (var s2 = 0; s2 < t3.length; s2 += 1) r3[s2 + e3.length] = t3[s2];
    return r3;
  };
  e2.exports = function(e3) {
    var s2 = this;
    if ("function" != typeof s2 || "[object Function]" !== t2.apply(s2)) throw new TypeError("Function.prototype.bind called on incompatible " + s2);
    for (var i2, o2 = function(e4, t3) {
      for (var r3 = [], n3 = 1, s3 = 0; n3 < e4.length; n3 += 1, s3 += 1) r3[s3] = e4[n3];
      return r3;
    }(arguments), a2 = r2(0, s2.length - o2.length), l = [], c = 0; c < a2; c++) l[c] = "$" + c;
    if (i2 = Function("binder", "return function (" + function(e4, t3) {
      for (var r3 = "", n3 = 0; n3 < e4.length; n3 += 1) r3 += e4[n3], n3 + 1 < e4.length && (r3 += ",");
      return r3;
    }(l) + "){ return binder.apply(this,arguments); }")(function() {
      if (this instanceof i2) {
        var t3 = s2.apply(this, n2(o2, arguments));
        return Object(t3) === t3 ? t3 : this;
      }
      return s2.apply(e3, n2(o2, arguments));
    }), s2.prototype) {
      var u = function() {
      };
      u.prototype = s2.prototype, i2.prototype = new u(), u.prototype = null;
    }
    return i2;
  };
}, (e2, t2, r2) => {
  var n2 = Function.prototype.call, s2 = Object.prototype.hasOwnProperty, i2 = r2(71);
  e2.exports = i2.call(n2, s2);
}, (e2, t2, r2) => {
  var n2 = r2(22), s2 = r2(121), i2 = r2(72)(), o2 = r2(73), a2 = n2("%TypeError%"), l = n2("%Math.floor%");
  e2.exports = function(e3, t3) {
    if ("function" != typeof e3) throw new a2("`fn` is not a function");
    if ("number" != typeof t3 || t3 < 0 || t3 > 4294967295 || l(t3) !== t3) throw new a2("`length` must be a positive 32-bit integer");
    var r3 = arguments.length > 2 && !!arguments[2], n3 = true, c = true;
    if ("length" in e3 && o2) {
      var u = o2(e3, "length");
      u && !u.configurable && (n3 = false), u && !u.writable && (c = false);
    }
    return (n3 || c || !r3) && (i2 ? s2(e3, "length", t3, true, true) : s2(e3, "length", t3)), e3;
  };
}, (e2, t2, r2) => {
  var n2, s2 = Object.prototype.toString, i2 = Function.prototype.toString, o2 = /^\s*(?:function)?\*/, a2 = r2(69)(), l = Object.getPrototypeOf;
  e2.exports = function(e3) {
    if ("function" != typeof e3) return false;
    if (o2.test(i2.call(e3))) return true;
    if (!a2) return "[object GeneratorFunction]" === s2.call(e3);
    if (!l) return false;
    if (void 0 === n2) {
      var t3 = function() {
        if (!a2) return false;
        try {
          return Function("return function*() {}")();
        } catch (e4) {
        }
      }();
      n2 = !!t3 && l(t3);
    }
    return l(e3) === n2;
  };
}, (e2, t2, r2) => {
  var n2 = r2(237), s2 = Object.prototype.toString, i2 = Object.prototype.hasOwnProperty;
  e2.exports = function(e3, t3, r3) {
    if (!n2(t3)) throw new TypeError("iterator must be a function");
    var o2;
    arguments.length >= 3 && (o2 = r3), "[object Array]" === s2.call(e3) ? function(e4, t4, r4) {
      for (var n3 = 0, s3 = e4.length; n3 < s3; n3++) i2.call(e4, n3) && (null == r4 ? t4(e4[n3], n3, e4) : t4.call(r4, e4[n3], n3, e4));
    }(e3, t3, o2) : "string" == typeof e3 ? function(e4, t4, r4) {
      for (var n3 = 0, s3 = e4.length; n3 < s3; n3++) null == r4 ? t4(e4.charAt(n3), n3, e4) : t4.call(r4, e4.charAt(n3), n3, e4);
    }(e3, t3, o2) : function(e4, t4, r4) {
      for (var n3 in e4) i2.call(e4, n3) && (null == r4 ? t4(e4[n3], n3, e4) : t4.call(r4, e4[n3], n3, e4));
    }(e3, t3, o2);
  };
}, (e2) => {
  var t2, r2, n2 = Function.prototype.toString, s2 = "object" == typeof Reflect && null !== Reflect && Reflect.apply;
  if ("function" == typeof s2 && "function" == typeof Object.defineProperty) try {
    t2 = Object.defineProperty({}, "length", { get: function() {
      throw r2;
    } }), r2 = {}, s2(function() {
      throw 42;
    }, null, t2);
  } catch (e3) {
    e3 !== r2 && (s2 = null);
  }
  else s2 = null;
  var i2 = /^\s*class\b/, o2 = function(e3) {
    try {
      var t3 = n2.call(e3);
      return i2.test(t3);
    } catch (e4) {
      return false;
    }
  }, a2 = function(e3) {
    try {
      return !o2(e3) && (n2.call(e3), true);
    } catch (e4) {
      return false;
    }
  }, l = Object.prototype.toString, c = "function" == typeof Symbol && !!Symbol.toStringTag, u = !(0 in [,]), p = function() {
    return false;
  };
  if ("object" == typeof document) {
    var d = document.all;
    l.call(d) === l.call(document.all) && (p = function(e3) {
      if ((u || !e3) && (void 0 === e3 || "object" == typeof e3)) try {
        var t3 = l.call(e3);
        return ("[object HTMLAllCollection]" === t3 || "[object HTML document.all class]" === t3 || "[object HTMLCollection]" === t3 || "[object Object]" === t3) && null == e3("");
      } catch (e4) {
      }
      return false;
    });
  }
  e2.exports = s2 ? function(e3) {
    if (p(e3)) return true;
    if (!e3) return false;
    if ("function" != typeof e3 && "object" != typeof e3) return false;
    try {
      s2(e3, null, t2);
    } catch (e4) {
      if (e4 !== r2) return false;
    }
    return !o2(e3) && a2(e3);
  } : function(e3) {
    if (p(e3)) return true;
    if (!e3) return false;
    if ("function" != typeof e3 && "object" != typeof e3) return false;
    if (c) return a2(e3);
    if (o2(e3)) return false;
    var t3 = l.call(e3);
    return !("[object Function]" !== t3 && "[object GeneratorFunction]" !== t3 && !/^\[object HTML/.test(t3)) && a2(e3);
  };
}, (e2, t2, r2) => {
  var n2 = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], s2 = "undefined" == typeof globalThis ? r2.g : globalThis;
  e2.exports = function() {
    for (var e3 = [], t3 = 0; t3 < n2.length; t3++) "function" == typeof s2[n2[t3]] && (e3[e3.length] = n2[t3]);
    return e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(122);
  e2.exports = function(e3) {
    return !!n2(e3);
  };
}, (e2) => {
  e2.exports = function(e3) {
    return e3 && "object" == typeof e3 && "function" == typeof e3.copy && "function" == typeof e3.fill && "function" == typeof e3.readUInt8;
  };
}, (e2, t2, r2) => {
  function n2(e3, t3) {
    var r3 = Object.keys(e3);
    if (Object.getOwnPropertySymbols) {
      var n3 = Object.getOwnPropertySymbols(e3);
      t3 && (n3 = n3.filter(function(t4) {
        return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
      })), r3.push.apply(r3, n3);
    }
    return r3;
  }
  function s2(e3) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var r3 = null != arguments[t3] ? arguments[t3] : {};
      t3 % 2 ? n2(Object(r3), true).forEach(function(t4) {
        var n3, s3, i3;
        n3 = e3, s3 = t4, i3 = r3[t4], (s3 = o2(s3)) in n3 ? Object.defineProperty(n3, s3, { value: i3, enumerable: true, configurable: true, writable: true }) : n3[s3] = i3;
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : n2(Object(r3)).forEach(function(t4) {
        Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
      });
    }
    return e3;
  }
  function i2(e3, t3) {
    for (var r3 = 0; r3 < t3.length; r3++) {
      var n3 = t3[r3];
      n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, o2(n3.key), n3);
    }
  }
  function o2(e3) {
    var t3 = function(e4, t4) {
      if ("object" !== h(e4) || null === e4) return e4;
      var r3 = e4[Symbol.toPrimitive];
      if (void 0 !== r3) {
        var n3 = r3.call(e4, "string");
        if ("object" !== h(n3)) return n3;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(e4);
    }(e3);
    return "symbol" === h(t3) ? t3 : String(t3);
  }
  function a2(e3, t3) {
    if (t3 && ("object" === h(t3) || "function" == typeof t3)) return t3;
    if (void 0 !== t3) throw new TypeError("Derived constructors may only return object or undefined");
    return l(e3);
  }
  function l(e3) {
    if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e3;
  }
  function c(e3) {
    var t3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
    return c = function(e4) {
      if (null === e4 || (r3 = e4, -1 === Function.toString.call(r3).indexOf("[native code]"))) return e4;
      var r3;
      if ("function" != typeof e4) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== t3) {
        if (t3.has(e4)) return t3.get(e4);
        t3.set(e4, n3);
      }
      function n3() {
        return u(e4, arguments, f(this).constructor);
      }
      return n3.prototype = Object.create(e4.prototype, { constructor: { value: n3, enumerable: false, writable: true, configurable: true } }), d(n3, e4);
    }, c(e3);
  }
  function u(e3, t3, r3) {
    return u = p() ? Reflect.construct.bind() : function(e4, t4, r4) {
      var n3 = [null];
      n3.push.apply(n3, t4);
      var s3 = new (Function.bind.apply(e4, n3))();
      return r4 && d(s3, r4.prototype), s3;
    }, u.apply(null, arguments);
  }
  function p() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if ("function" == typeof Proxy) return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch (e3) {
      return false;
    }
  }
  function d(e3, t3) {
    return d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
      return e4.__proto__ = t4, e4;
    }, d(e3, t3);
  }
  function f(e3) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
      return e4.__proto__ || Object.getPrototypeOf(e4);
    }, f(e3);
  }
  function h(e3) {
    return h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
      return typeof e4;
    } : function(e4) {
      return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
    }, h(e3);
  }
  var m = r2(32).inspect, y = r2(227).codes.ERR_INVALID_ARG_TYPE;
  function g(e3, t3, r3) {
    return (void 0 === r3 || r3 > e3.length) && (r3 = e3.length), e3.substring(r3 - t3.length, r3) === t3;
  }
  var b = "", v = "", E = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
  function S(e3) {
    var t3 = Object.keys(e3), r3 = Object.create(Object.getPrototypeOf(e3));
    return t3.forEach(function(t4) {
      r3[t4] = e3[t4];
    }), Object.defineProperty(r3, "message", { value: e3.message }), r3;
  }
  function x(e3) {
    return m(e3, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
  }
  var T = function(e3, t3) {
    !function(e4, t4) {
      if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
      e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && d(e4, t4);
    }(T2, e3);
    var r3, n3, o3, c2, u2 = (r3 = T2, n3 = p(), function() {
      var e4, t4 = f(r3);
      if (n3) {
        var s3 = f(this).constructor;
        e4 = Reflect.construct(t4, arguments, s3);
      } else e4 = t4.apply(this, arguments);
      return a2(this, e4);
    });
    function T2(e4) {
      var t4;
      if (function(e5, t5) {
        if (!(e5 instanceof t5)) throw new TypeError("Cannot call a class as a function");
      }(this, T2), "object" !== h(e4) || null === e4) throw new y("options", "Object", e4);
      var r4 = e4.message, n4 = e4.operator, s3 = e4.stackStartFn, i3 = e4.actual, o4 = e4.expected, c3 = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, null != r4) t4 = u2.call(this, String(r4));
      else if ("object" === h(i3) && null !== i3 && "object" === h(o4) && null !== o4 && "stack" in i3 && i3 instanceof Error && "stack" in o4 && o4 instanceof Error && (i3 = S(i3), o4 = S(o4)), "deepStrictEqual" === n4 || "strictEqual" === n4) t4 = u2.call(this, function(e5, t5, r5) {
        var n5 = "", s4 = "", i4 = 0, o5 = "", a3 = false, l2 = x(e5), c4 = l2.split("\n"), u3 = x(t5).split("\n"), p3 = 0, d3 = "";
        if ("strictEqual" === r5 && "object" === h(e5) && "object" === h(t5) && null !== e5 && null !== t5 && (r5 = "strictEqualObject"), 1 === c4.length && 1 === u3.length && c4[0] !== u3[0]) {
          var f3 = c4[0].length + u3[0].length;
          if (f3 <= 10) {
            if (!("object" === h(e5) && null !== e5 || "object" === h(t5) && null !== t5 || 0 === e5 && 0 === t5)) return "".concat(E[r5], "\n\n") + "".concat(c4[0], " !== ").concat(u3[0], "\n");
          } else if ("strictEqualObject" !== r5 && f3 < 80) {
            for (; c4[0][p3] === u3[0][p3]; ) p3++;
            p3 > 2 && (d3 = "\n  ".concat(function(e6, t6) {
              if (t6 = Math.floor(t6), 0 == e6.length || 0 == t6) return "";
              var r6 = e6.length * t6;
              for (t6 = Math.floor(Math.log(t6) / Math.log(2)); t6; ) e6 += e6, t6--;
              return e6 + e6.substring(0, r6 - e6.length);
            }(" ", p3), "^"), p3 = 0);
          }
        }
        for (var m3 = c4[c4.length - 1], y2 = u3[u3.length - 1]; m3 === y2 && (p3++ < 2 ? o5 = "\n  ".concat(m3).concat(o5) : n5 = m3, c4.pop(), u3.pop(), 0 !== c4.length && 0 !== u3.length); ) m3 = c4[c4.length - 1], y2 = u3[u3.length - 1];
        var S2 = Math.max(c4.length, u3.length);
        if (0 === S2) {
          var T3 = l2.split("\n");
          if (T3.length > 30) for (T3[26] = "".concat(b, "...").concat(v); T3.length > 27; ) T3.pop();
          return "".concat(E.notIdentical, "\n\n").concat(T3.join("\n"), "\n");
        }
        p3 > 3 && (o5 = "\n".concat(b, "...").concat(v).concat(o5), a3 = true), "" !== n5 && (o5 = "\n  ".concat(n5).concat(o5), n5 = "");
        var w2 = 0, P = E[r5] + "\n".concat("", "+ actual").concat(v, " ").concat("", "- expected").concat(v), A = " ".concat(b, "...").concat(v, " Lines skipped");
        for (p3 = 0; p3 < S2; p3++) {
          var C = p3 - i4;
          if (c4.length < p3 + 1) C > 1 && p3 > 2 && (C > 4 ? (s4 += "\n".concat(b, "...").concat(v), a3 = true) : C > 3 && (s4 += "\n  ".concat(u3[p3 - 2]), w2++), s4 += "\n  ".concat(u3[p3 - 1]), w2++), i4 = p3, n5 += "\n".concat("", "-").concat(v, " ").concat(u3[p3]), w2++;
          else if (u3.length < p3 + 1) C > 1 && p3 > 2 && (C > 4 ? (s4 += "\n".concat(b, "...").concat(v), a3 = true) : C > 3 && (s4 += "\n  ".concat(c4[p3 - 2]), w2++), s4 += "\n  ".concat(c4[p3 - 1]), w2++), i4 = p3, s4 += "\n".concat("", "+").concat(v, " ").concat(c4[p3]), w2++;
          else {
            var O = u3[p3], I = c4[p3], _ = I !== O && (!g(I, ",") || I.slice(0, -1) !== O);
            _ && g(O, ",") && O.slice(0, -1) === I && (_ = false, I += ","), _ ? (C > 1 && p3 > 2 && (C > 4 ? (s4 += "\n".concat(b, "...").concat(v), a3 = true) : C > 3 && (s4 += "\n  ".concat(c4[p3 - 2]), w2++), s4 += "\n  ".concat(c4[p3 - 1]), w2++), i4 = p3, s4 += "\n".concat("", "+").concat(v, " ").concat(I), n5 += "\n".concat("", "-").concat(v, " ").concat(O), w2 += 2) : (s4 += n5, n5 = "", 1 !== C && 0 !== p3 || (s4 += "\n  ".concat(I), w2++));
          }
          if (w2 > 20 && p3 < S2 - 2) return "".concat(P).concat(A, "\n").concat(s4, "\n").concat(b, "...").concat(v).concat(n5, "\n") + "".concat(b, "...").concat(v);
        }
        return "".concat(P).concat(a3 ? A : "", "\n").concat(s4).concat(n5).concat(o5).concat(d3);
      }(i3, o4, n4));
      else if ("notDeepStrictEqual" === n4 || "notStrictEqual" === n4) {
        var p2 = E[n4], d2 = x(i3).split("\n");
        if ("notStrictEqual" === n4 && "object" === h(i3) && null !== i3 && (p2 = E.notStrictEqualObject), d2.length > 30) for (d2[26] = "".concat(b, "...").concat(v); d2.length > 27; ) d2.pop();
        t4 = 1 === d2.length ? u2.call(this, "".concat(p2, " ").concat(d2[0])) : u2.call(this, "".concat(p2, "\n\n").concat(d2.join("\n"), "\n"));
      } else {
        var f2 = x(i3), m2 = "", w = E[n4];
        "notDeepEqual" === n4 || "notEqual" === n4 ? (f2 = "".concat(E[n4], "\n\n").concat(f2)).length > 1024 && (f2 = "".concat(f2.slice(0, 1021), "...")) : (m2 = "".concat(x(o4)), f2.length > 512 && (f2 = "".concat(f2.slice(0, 509), "...")), m2.length > 512 && (m2 = "".concat(m2.slice(0, 509), "...")), "deepEqual" === n4 || "equal" === n4 ? f2 = "".concat(w, "\n\n").concat(f2, "\n\nshould equal\n\n") : m2 = " ".concat(n4, " ").concat(m2)), t4 = u2.call(this, "".concat(f2).concat(m2));
      }
      return Error.stackTraceLimit = c3, t4.generatedMessage = !r4, Object.defineProperty(l(t4), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), t4.code = "ERR_ASSERTION", t4.actual = i3, t4.expected = o4, t4.operator = n4, Error.captureStackTrace && Error.captureStackTrace(l(t4), s3), t4.stack, t4.name = "AssertionError", a2(t4);
    }
    return o3 = T2, (c2 = [{ key: "toString", value: function() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    } }, { key: t3, value: function(e4, t4) {
      return m(this, s2(s2({}, t4), {}, { customInspect: false, depth: 0 }));
    } }]) && i2(o3.prototype, c2), Object.defineProperty(o3, "prototype", { writable: false }), T2;
  }(c(Error), m.custom);
  e2.exports = T;
}, (e2, t2, r2) => {
  var n2 = r2(243);
  e2.exports = function() {
    return Object.assign ? function() {
      if (!Object.assign) return false;
      for (var e3 = "abcdefghijklmnopqrst", t3 = e3.split(""), r3 = {}, n3 = 0; n3 < t3.length; ++n3) r3[t3[n3]] = t3[n3];
      var s2 = Object.assign({}, r3), i2 = "";
      for (var o2 in s2) i2 += o2;
      return e3 !== i2;
    }() || function() {
      if (!Object.assign || !Object.preventExtensions) return false;
      var e3 = Object.preventExtensions({ 1: 2 });
      try {
        Object.assign(e3, "xy");
      } catch (t3) {
        return "y" === e3[1];
      }
      return false;
    }() ? n2 : Object.assign : n2;
  };
}, (e2, t2, r2) => {
  var n2 = r2(123), s2 = r2(70)(), i2 = r2(38), o2 = Object, a2 = i2("Array.prototype.push"), l = i2("Object.prototype.propertyIsEnumerable"), c = s2 ? Object.getOwnPropertySymbols : null;
  e2.exports = function(e3, t3) {
    if (null == e3) throw new TypeError("target must be an object");
    var r3 = o2(e3);
    if (1 === arguments.length) return r3;
    for (var i3 = 1; i3 < arguments.length; ++i3) {
      var u = o2(arguments[i3]), p = n2(u), d = s2 && (Object.getOwnPropertySymbols || c);
      if (d) for (var f = d(u), h = 0; h < f.length; ++h) {
        var m = f[h];
        l(u, m) && a2(p, m);
      }
      for (var y = 0; y < p.length; ++y) {
        var g = p[y];
        if (l(u, g)) {
          var b = u[g];
          r3[g] = b;
        }
      }
    }
    return r3;
  };
}, (e2, t2, r2) => {
  var n2;
  if (!Object.keys) {
    var s2 = Object.prototype.hasOwnProperty, i2 = Object.prototype.toString, o2 = r2(124), a2 = Object.prototype.propertyIsEnumerable, l = !a2.call({ toString: null }, "toString"), c = a2.call(function() {
    }, "prototype"), u = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], p = function(e3) {
      var t3 = e3.constructor;
      return t3 && t3.prototype === e3;
    }, d = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, f = function() {
      if ("undefined" == typeof window) return false;
      for (var e3 in window) try {
        if (!d["$" + e3] && s2.call(window, e3) && null !== window[e3] && "object" == typeof window[e3]) try {
          p(window[e3]);
        } catch (e4) {
          return true;
        }
      } catch (e4) {
        return true;
      }
      return false;
    }();
    n2 = function(e3) {
      var t3 = null !== e3 && "object" == typeof e3, r3 = "[object Function]" === i2.call(e3), n3 = o2(e3), a3 = t3 && "[object String]" === i2.call(e3), d2 = [];
      if (!t3 && !r3 && !n3) throw new TypeError("Object.keys called on a non-object");
      var h = c && r3;
      if (a3 && e3.length > 0 && !s2.call(e3, 0)) for (var m = 0; m < e3.length; ++m) d2.push(String(m));
      if (n3 && e3.length > 0) for (var y = 0; y < e3.length; ++y) d2.push(String(y));
      else for (var g in e3) h && "prototype" === g || !s2.call(e3, g) || d2.push(String(g));
      if (l) for (var b = function(e4) {
        if ("undefined" == typeof window || !f) return p(e4);
        try {
          return p(e4);
        } catch (e5) {
          return false;
        }
      }(e3), v = 0; v < u.length; ++v) b && "constructor" === u[v] || !s2.call(e3, u[v]) || d2.push(u[v]);
      return d2;
    };
  }
  e2.exports = n2;
}, (e2, t2, r2) => {
  function n2(e3, t3) {
    return function(e4) {
      if (Array.isArray(e4)) return e4;
    }(e3) || function(e4, t4) {
      var r3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
      if (null != r3) {
        var n3, s3, i3, o3, a3 = [], l2 = true, c2 = false;
        try {
          if (i3 = (r3 = r3.call(e4)).next, 0 === t4) {
            if (Object(r3) !== r3) return;
            l2 = false;
          } else for (; !(l2 = (n3 = i3.call(r3)).done) && (a3.push(n3.value), a3.length !== t4); l2 = true) ;
        } catch (e5) {
          c2 = true, s3 = e5;
        } finally {
          try {
            if (!l2 && null != r3.return && (o3 = r3.return(), Object(o3) !== o3)) return;
          } finally {
            if (c2) throw s3;
          }
        }
        return a3;
      }
    }(e3, t3) || function(e4, t4) {
      if (e4) {
        if ("string" == typeof e4) return s2(e4, t4);
        var r3 = Object.prototype.toString.call(e4).slice(8, -1);
        return "Object" === r3 && e4.constructor && (r3 = e4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? s2(e4, t4) : void 0;
      }
    }(e3, t3) || function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function s2(e3, t3) {
    (null == t3 || t3 > e3.length) && (t3 = e3.length);
    for (var r3 = 0, n3 = new Array(t3); r3 < t3; r3++) n3[r3] = e3[r3];
    return n3;
  }
  function i2(e3) {
    return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
      return typeof e4;
    } : function(e4) {
      return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
    }, i2(e3);
  }
  r2(44), r2(12);
  var o2 = void 0 !== /a/g.flags, a2 = function(e3) {
    var t3 = [];
    return e3.forEach(function(e4) {
      return t3.push(e4);
    }), t3;
  }, l = function(e3) {
    var t3 = [];
    return e3.forEach(function(e4, r3) {
      return t3.push([r3, e4]);
    }), t3;
  }, c = Object.is ? Object.is : r2(246), u = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, p = Number.isNaN ? Number.isNaN : r2(248);
  function d(e3) {
    return e3.call.bind(e3);
  }
  var f = d(Object.prototype.hasOwnProperty), h = d(Object.prototype.propertyIsEnumerable), m = d(Object.prototype.toString), y = r2(32).types, g = y.isAnyArrayBuffer, b = y.isArrayBufferView, v = y.isDate, E = y.isMap, S = y.isRegExp, x = y.isSet, T = y.isNativeError, w = y.isBoxedPrimitive, P = y.isNumberObject, A = y.isStringObject, C = y.isBooleanObject, O = y.isBigIntObject, I = y.isSymbolObject, _ = y.isFloat32Array, k = y.isFloat64Array;
  function N(e3) {
    if (0 === e3.length || e3.length > 10) return true;
    for (var t3 = 0; t3 < e3.length; t3++) {
      var r3 = e3.charCodeAt(t3);
      if (r3 < 48 || r3 > 57) return true;
    }
    return 10 === e3.length && e3 >= Math.pow(2, 32);
  }
  function D(e3) {
    return Object.keys(e3).filter(N).concat(u(e3).filter(Object.prototype.propertyIsEnumerable.bind(e3)));
  }
  function j(e3, t3) {
    if (e3 === t3) return 0;
    for (var r3 = e3.length, n3 = t3.length, s3 = 0, i3 = Math.min(r3, n3); s3 < i3; ++s3) if (e3[s3] !== t3[s3]) {
      r3 = e3[s3], n3 = t3[s3];
      break;
    }
    return r3 < n3 ? -1 : n3 < r3 ? 1 : 0;
  }
  var L = 0, M = 1, B = 2, R = 3;
  function F(e3, t3, r3, n3) {
    if (e3 === t3) return 0 !== e3 || !r3 || c(e3, t3);
    if (r3) {
      if ("object" !== i2(e3)) return "number" == typeof e3 && p(e3) && p(t3);
      if ("object" !== i2(t3) || null === e3 || null === t3) return false;
      if (Object.getPrototypeOf(e3) !== Object.getPrototypeOf(t3)) return false;
    } else {
      if (null === e3 || "object" !== i2(e3)) return (null === t3 || "object" !== i2(t3)) && e3 == t3;
      if (null === t3 || "object" !== i2(t3)) return false;
    }
    var s3, a3, l2, u2, d2 = m(e3);
    if (d2 !== m(t3)) return false;
    if (Array.isArray(e3)) {
      if (e3.length !== t3.length) return false;
      var f2 = D(e3), h2 = D(t3);
      return f2.length === h2.length && $(e3, t3, r3, n3, M, f2);
    }
    if ("[object Object]" === d2 && (!E(e3) && E(t3) || !x(e3) && x(t3))) return false;
    if (v(e3)) {
      if (!v(t3) || Date.prototype.getTime.call(e3) !== Date.prototype.getTime.call(t3)) return false;
    } else if (S(e3)) {
      if (!S(t3) || (l2 = e3, u2 = t3, !(o2 ? l2.source === u2.source && l2.flags === u2.flags : RegExp.prototype.toString.call(l2) === RegExp.prototype.toString.call(u2)))) return false;
    } else if (T(e3) || e3 instanceof Error) {
      if (e3.message !== t3.message || e3.name !== t3.name) return false;
    } else {
      if (b(e3)) {
        if (r3 || !_(e3) && !k(e3)) {
          if (!function(e4, t4) {
            return e4.byteLength === t4.byteLength && 0 === j(new Uint8Array(e4.buffer, e4.byteOffset, e4.byteLength), new Uint8Array(t4.buffer, t4.byteOffset, t4.byteLength));
          }(e3, t3)) return false;
        } else if (!function(e4, t4) {
          if (e4.byteLength !== t4.byteLength) return false;
          for (var r4 = 0; r4 < e4.byteLength; r4++) if (e4[r4] !== t4[r4]) return false;
          return true;
        }(e3, t3)) return false;
        var y2 = D(e3), N2 = D(t3);
        return y2.length === N2.length && $(e3, t3, r3, n3, L, y2);
      }
      if (x(e3)) return !(!x(t3) || e3.size !== t3.size) && $(e3, t3, r3, n3, B);
      if (E(e3)) return !(!E(t3) || e3.size !== t3.size) && $(e3, t3, r3, n3, R);
      if (g(e3)) {
        if (a3 = t3, (s3 = e3).byteLength !== a3.byteLength || 0 !== j(new Uint8Array(s3), new Uint8Array(a3))) return false;
      } else if (w(e3) && !function(e4, t4) {
        return P(e4) ? P(t4) && c(Number.prototype.valueOf.call(e4), Number.prototype.valueOf.call(t4)) : A(e4) ? A(t4) && String.prototype.valueOf.call(e4) === String.prototype.valueOf.call(t4) : C(e4) ? C(t4) && Boolean.prototype.valueOf.call(e4) === Boolean.prototype.valueOf.call(t4) : O(e4) ? O(t4) && BigInt.prototype.valueOf.call(e4) === BigInt.prototype.valueOf.call(t4) : I(t4) && Symbol.prototype.valueOf.call(e4) === Symbol.prototype.valueOf.call(t4);
      }(e3, t3)) return false;
    }
    return $(e3, t3, r3, n3, L);
  }
  function U(e3, t3) {
    return t3.filter(function(t4) {
      return h(e3, t4);
    });
  }
  function $(e3, t3, r3, s3, o3, c2) {
    if (5 === arguments.length) {
      c2 = Object.keys(e3);
      var p2 = Object.keys(t3);
      if (c2.length !== p2.length) return false;
    }
    for (var d2 = 0; d2 < c2.length; d2++) if (!f(t3, c2[d2])) return false;
    if (r3 && 5 === arguments.length) {
      var m2 = u(e3);
      if (0 !== m2.length) {
        var y2 = 0;
        for (d2 = 0; d2 < m2.length; d2++) {
          var g2 = m2[d2];
          if (h(e3, g2)) {
            if (!h(t3, g2)) return false;
            c2.push(g2), y2++;
          } else if (h(t3, g2)) return false;
        }
        var b2 = u(t3);
        if (m2.length !== b2.length && U(t3, b2).length !== y2) return false;
      } else {
        var v2 = u(t3);
        if (0 !== v2.length && 0 !== U(t3, v2).length) return false;
      }
    }
    if (0 === c2.length && (o3 === L || o3 === M && 0 === e3.length || 0 === e3.size)) return true;
    if (void 0 === s3) s3 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
    else {
      var E2 = s3.val1.get(e3);
      if (void 0 !== E2) {
        var S2 = s3.val2.get(t3);
        if (void 0 !== S2) return E2 === S2;
      }
      s3.position++;
    }
    s3.val1.set(e3, s3.position), s3.val2.set(t3, s3.position);
    var x2 = function(e4, t4, r4, s4, o4, c3) {
      var u2 = 0;
      if (c3 === B) {
        if (!function(e5, t5, r5, n3) {
          for (var s5 = null, o5 = a2(e5), l2 = 0; l2 < o5.length; l2++) {
            var c4 = o5[l2];
            if ("object" === i2(c4) && null !== c4) null === s5 && (s5 = /* @__PURE__ */ new Set()), s5.add(c4);
            else if (!t5.has(c4)) {
              if (r5) return false;
              if (!W(e5, t5, c4)) return false;
              null === s5 && (s5 = /* @__PURE__ */ new Set()), s5.add(c4);
            }
          }
          if (null !== s5) {
            for (var u3 = a2(t5), p4 = 0; p4 < u3.length; p4++) {
              var d4 = u3[p4];
              if ("object" === i2(d4) && null !== d4) {
                if (!V(s5, d4, r5, n3)) return false;
              } else if (!r5 && !e5.has(d4) && !V(s5, d4, r5, n3)) return false;
            }
            return 0 === s5.size;
          }
          return true;
        }(e4, t4, r4, o4)) return false;
      } else if (c3 === R) {
        if (!function(e5, t5, r5, s5) {
          for (var o5 = null, a3 = l(e5), c4 = 0; c4 < a3.length; c4++) {
            var u3 = n2(a3[c4], 2), p4 = u3[0], d4 = u3[1];
            if ("object" === i2(p4) && null !== p4) null === o5 && (o5 = /* @__PURE__ */ new Set()), o5.add(p4);
            else {
              var f2 = t5.get(p4);
              if (void 0 === f2 && !t5.has(p4) || !F(d4, f2, r5, s5)) {
                if (r5) return false;
                if (!G(e5, t5, p4, d4, s5)) return false;
                null === o5 && (o5 = /* @__PURE__ */ new Set()), o5.add(p4);
              }
            }
          }
          if (null !== o5) {
            for (var h3 = l(t5), m3 = 0; m3 < h3.length; m3++) {
              var y3 = n2(h3[m3], 2), g3 = y3[0], b3 = y3[1];
              if ("object" === i2(g3) && null !== g3) {
                if (!H(o5, e5, g3, b3, r5, s5)) return false;
              } else if (!(r5 || e5.has(g3) && F(e5.get(g3), b3, false, s5) || H(o5, e5, g3, b3, false, s5))) return false;
            }
            return 0 === o5.size;
          }
          return true;
        }(e4, t4, r4, o4)) return false;
      } else if (c3 === M) for (; u2 < e4.length; u2++) {
        if (!f(e4, u2)) {
          if (f(t4, u2)) return false;
          for (var p3 = Object.keys(e4); u2 < p3.length; u2++) {
            var d3 = p3[u2];
            if (!f(t4, d3) || !F(e4[d3], t4[d3], r4, o4)) return false;
          }
          return p3.length === Object.keys(t4).length;
        }
        if (!f(t4, u2) || !F(e4[u2], t4[u2], r4, o4)) return false;
      }
      for (u2 = 0; u2 < s4.length; u2++) {
        var h2 = s4[u2];
        if (!F(e4[h2], t4[h2], r4, o4)) return false;
      }
      return true;
    }(e3, t3, r3, c2, s3, o3);
    return s3.val1.delete(e3), s3.val2.delete(t3), x2;
  }
  function V(e3, t3, r3, n3) {
    for (var s3 = a2(e3), i3 = 0; i3 < s3.length; i3++) {
      var o3 = s3[i3];
      if (F(t3, o3, r3, n3)) return e3.delete(o3), true;
    }
    return false;
  }
  function q(e3) {
    switch (i2(e3)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return false;
      case "string":
        e3 = +e3;
      case "number":
        if (p(e3)) return false;
    }
    return true;
  }
  function W(e3, t3, r3) {
    var n3 = q(r3);
    return null != n3 ? n3 : t3.has(n3) && !e3.has(n3);
  }
  function G(e3, t3, r3, n3, s3) {
    var i3 = q(r3);
    if (null != i3) return i3;
    var o3 = t3.get(i3);
    return !(void 0 === o3 && !t3.has(i3) || !F(n3, o3, false, s3)) && !e3.has(i3) && F(n3, o3, false, s3);
  }
  function H(e3, t3, r3, n3, s3, i3) {
    for (var o3 = a2(e3), l2 = 0; l2 < o3.length; l2++) {
      var c2 = o3[l2];
      if (F(r3, c2, s3, i3) && F(n3, t3.get(c2), s3, i3)) return e3.delete(c2), true;
    }
    return false;
  }
  e2.exports = { isDeepEqual: function(e3, t3) {
    return F(e3, t3, false);
  }, isDeepStrictEqual: function(e3, t3) {
    return F(e3, t3, true);
  } };
}, (e2, t2, r2) => {
  var n2 = r2(46), s2 = r2(41), i2 = r2(125), o2 = r2(74), a2 = r2(247), l = s2(o2(), Object);
  n2(l, { getPolyfill: o2, implementation: i2, shim: a2 }), e2.exports = l;
}, (e2, t2, r2) => {
  var n2 = r2(74), s2 = r2(46);
  e2.exports = function() {
    var e3 = n2();
    return s2(Object, { is: e3 }, { is: function() {
      return Object.is !== e3;
    } }), e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(41), s2 = r2(46), i2 = r2(126), o2 = r2(127), a2 = r2(249), l = n2(o2(), Number);
  s2(l, { getPolyfill: o2, implementation: i2, shim: a2 }), e2.exports = l;
}, (e2, t2, r2) => {
  var n2 = r2(46), s2 = r2(127);
  e2.exports = function() {
    var e3 = s2();
    return n2(Number, { isNaN: e3 }, { isNaN: function() {
      return Number.isNaN !== e3;
    } }), e3;
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return "module" === e3.node.sourceType;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    var r3;
    e3.traverse(f, { scope: e3.scope, bindingNames: t3, seen: /* @__PURE__ */ new WeakSet(), includeUpdateExpression: null == (r3 = arguments[2]) || r3 });
  };
  var n2 = r2(0);
  const { LOGICAL_OPERATORS: s2, assignmentExpression: i2, binaryExpression: o2, cloneNode: a2, identifier: l, logicalExpression: c, numericLiteral: u, sequenceExpression: p, unaryExpression: d } = n2, f = { AssignmentExpression: { exit(e3) {
    const { scope: t3, seen: r3, bindingNames: n3 } = this;
    if ("=" === e3.node.operator) return;
    if (r3.has(e3.node)) return;
    r3.add(e3.node);
    const l2 = e3.get("left");
    if (!l2.isIdentifier()) return;
    const u2 = l2.node.name;
    if (!n3.has(u2)) return;
    if (t3.getBinding(u2) !== e3.scope.getBinding(u2)) return;
    const p2 = e3.node.operator.slice(0, -1);
    s2.includes(p2) ? e3.replaceWith(c(p2, e3.node.left, i2("=", a2(e3.node.left), e3.node.right))) : (e3.node.right = o2(p2, a2(e3.node.left), e3.node.right), e3.node.operator = "=");
  } } };
  f.UpdateExpression = { exit(e3) {
    if (!this.includeUpdateExpression) return;
    const { scope: t3, bindingNames: r3 } = this, n3 = e3.get("argument");
    if (!n3.isIdentifier()) return;
    const s3 = n3.node.name;
    if (r3.has(s3) && t3.getBinding(s3) === e3.scope.getBinding(s3)) if (e3.parentPath.isExpressionStatement() && !e3.isCompletionRecord()) {
      const t4 = "++" == e3.node.operator ? "+=" : "-=";
      e3.replaceWith(i2(t4, n3.node, u(1)));
    } else if (e3.node.prefix) e3.replaceWith(i2("=", l(s3), o2(e3.node.operator[0], d("+", n3.node), u(1))));
    else {
      const t4 = e3.scope.generateUidIdentifierBasedOnNode(n3.node, "old"), r4 = t4.name;
      e3.scope.push({ id: t4 });
      const s4 = o2(e3.node.operator[0], l(r4), u(1));
      e3.replaceWith(p([i2("=", l(r4), d("+", n3.node)), i2("=", a2(n3.node), s4), l(r4)]));
    }
  } };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    let { importInterop: s3, initializeReexports: o3 = false, getWrapperPayload: u, esNamespaceOnly: p = false, filename: d } = r3;
    t3 || (t3 = e3.scope.generateUidIdentifier("exports").name);
    const f = /* @__PURE__ */ new Set();
    !function(e4) {
      e4.get("body").forEach((e5) => {
        e5.isExportDefaultDeclaration() && (0, i2.default)(e5);
      });
    }(e3);
    const { local: h, sources: m, hasExports: y } = function(e4, t4, r4) {
      let { getWrapperPayload: s4, initializeReexports: i3 } = t4;
      const o4 = function(e5, t5, r5) {
        const n3 = /* @__PURE__ */ new Map();
        e5.get("body").forEach((e6) => {
          let r6;
          if (e6.isImportDeclaration()) r6 = "import";
          else {
            if (e6.isExportDefaultDeclaration() && (e6 = e6.get("declaration")), e6.isExportNamedDeclaration()) {
              if (e6.node.declaration) e6 = e6.get("declaration");
              else if (t5 && e6.node.source && e6.get("source").isStringLiteral()) return void e6.get("specifiers").forEach((e7) => {
                c(e7), n3.set(e7.get("local").node.name, "block");
              });
            }
            if (e6.isFunctionDeclaration()) r6 = "hoisted";
            else if (e6.isClassDeclaration()) r6 = "block";
            else if (e6.isVariableDeclaration({ kind: "var" })) r6 = "var";
            else {
              if (!e6.isVariableDeclaration()) return;
              r6 = "block";
            }
          }
          Object.keys(e6.getOuterBindingIdentifiers()).forEach((e7) => {
            n3.set(e7, r6);
          });
        });
        const s5 = /* @__PURE__ */ new Map(), i4 = (e6) => {
          const t6 = e6.node.name;
          let r6 = s5.get(t6);
          if (!r6) {
            const i5 = n3.get(t6);
            if (void 0 === i5) throw e6.buildCodeFrameError(`Exporting local "${t6}", which is not declared.`);
            r6 = { names: [], kind: i5 }, s5.set(t6, r6);
          }
          return r6;
        };
        return e5.get("body").forEach((e6) => {
          if (!e6.isExportNamedDeclaration() || !t5 && e6.node.source) {
            if (e6.isExportDefaultDeclaration()) {
              const t6 = e6.get("declaration");
              if (!t6.isFunctionDeclaration() && !t6.isClassDeclaration()) throw t6.buildCodeFrameError("Unexpected default expression export.");
              i4(t6.get("id")).names.push("default");
            }
          } else if (e6.node.declaration) {
            const t6 = e6.get("declaration"), r6 = t6.getOuterBindingIdentifierPaths();
            Object.keys(r6).forEach((e7) => {
              if ("__esModule" === e7) throw t6.buildCodeFrameError('Illegal export "__esModule".');
              i4(r6[e7]).names.push(e7);
            });
          } else e6.get("specifiers").forEach((e7) => {
            const t6 = e7.get("local"), n4 = e7.get("exported"), s6 = i4(t6), o5 = l(n4, r5);
            if ("__esModule" === o5) throw n4.buildCodeFrameError('Illegal export "__esModule".');
            s6.names.push(o5);
          });
        }), s5;
      }(e4, i3, r4), a3 = /* @__PURE__ */ new Map(), u2 = /* @__PURE__ */ new Map(), p2 = (t5, r5) => {
        const s5 = t5.value;
        let i4 = u2.get(s5);
        return i4 ? a3.get(s5).push(r5) : (i4 = { name: e4.scope.generateUidIdentifier((0, n2.basename)(s5, (0, n2.extname)(s5))).name, interop: "none", loc: null, imports: /* @__PURE__ */ new Map(), importsNamespace: /* @__PURE__ */ new Set(), reexports: /* @__PURE__ */ new Map(), reexportNamespace: /* @__PURE__ */ new Set(), reexportAll: null, wrap: null, get lazy() {
          return "lazy" === this.wrap;
        }, referenced: false }, u2.set(s5, i4), a3.set(s5, [r5])), i4;
      };
      let d2 = false;
      e4.get("body").forEach((e5) => {
        if (e5.isImportDeclaration()) {
          const t5 = p2(e5.node.source, e5.node);
          t5.loc || (t5.loc = e5.node.loc), e5.get("specifiers").forEach((e6) => {
            if (e6.isImportDefaultSpecifier()) {
              const r5 = e6.get("local").node.name;
              t5.imports.set(r5, "default");
              const n3 = o4.get(r5);
              n3 && (o4.delete(r5), n3.names.forEach((e7) => {
                t5.reexports.set(e7, "default");
              }), t5.referenced = true);
            } else if (e6.isImportNamespaceSpecifier()) {
              const r5 = e6.get("local").node.name;
              t5.importsNamespace.add(r5);
              const n3 = o4.get(r5);
              n3 && (o4.delete(r5), n3.names.forEach((e7) => {
                t5.reexportNamespace.add(e7);
              }), t5.referenced = true);
            } else if (e6.isImportSpecifier()) {
              const n3 = l(e6.get("imported"), r4), s5 = e6.get("local").node.name;
              t5.imports.set(s5, n3);
              const i4 = o4.get(s5);
              i4 && (o4.delete(s5), i4.names.forEach((e7) => {
                t5.reexports.set(e7, n3);
              }), t5.referenced = true);
            }
          });
        } else if (e5.isExportAllDeclaration()) {
          d2 = true;
          const t5 = p2(e5.node.source, e5.node);
          t5.loc || (t5.loc = e5.node.loc), t5.reexportAll = { loc: e5.node.loc }, t5.referenced = true;
        } else if (e5.isExportNamedDeclaration() && e5.node.source) {
          d2 = true;
          const t5 = p2(e5.node.source, e5.node);
          t5.loc || (t5.loc = e5.node.loc), e5.get("specifiers").forEach((e6) => {
            c(e6);
            const n3 = l(e6.get("local"), r4), s5 = l(e6.get("exported"), r4);
            if (t5.reexports.set(s5, n3), t5.referenced = true, "__esModule" === s5) throw e6.get("exported").buildCodeFrameError('Illegal export "__esModule".');
          });
        } else (e5.isExportNamedDeclaration() || e5.isExportDefaultDeclaration()) && (d2 = true);
      });
      for (const e5 of u2.values()) {
        let t5 = false, r5 = false;
        e5.importsNamespace.size > 0 && (t5 = true, r5 = true), e5.reexportAll && (r5 = true);
        for (const n3 of e5.imports.values()) "default" === n3 ? t5 = true : r5 = true;
        for (const n3 of e5.reexports.values()) "default" === n3 ? t5 = true : r5 = true;
        t5 && r5 ? e5.interop = "namespace" : t5 && (e5.interop = "default");
      }
      if (s4) for (const [e5, t5] of u2) t5.wrap = s4(e5, t5, a3.get(e5));
      return { hasExports: d2, local: o4, sources: u2 };
    }(e3, { initializeReexports: o3, getWrapperPayload: u }, f);
    !function(e4) {
      e4.get("body").forEach((e5) => {
        if (e5.isImportDeclaration()) e5.remove();
        else if (e5.isExportNamedDeclaration()) e5.node.declaration ? (e5.node.declaration._blockHoist = e5.node._blockHoist, e5.replaceWith(e5.node.declaration)) : e5.remove();
        else if (e5.isExportDefaultDeclaration()) {
          const t4 = e5.get("declaration");
          if (!t4.isFunctionDeclaration() && !t4.isClassDeclaration()) throw t4.buildCodeFrameError("Unexpected default expression export.");
          t4._blockHoist = e5.node._blockHoist, e5.replaceWith(t4);
        } else e5.isExportAllDeclaration() && e5.remove();
      });
    }(e3);
    for (const [e4, t4] of m) {
      const { importsNamespace: r4, imports: n3 } = t4;
      if (r4.size > 0 && 0 === n3.size) {
        const [e5] = r4;
        t4.name = e5;
      }
      const i3 = a2(s3, e4, d);
      "none" === i3 ? t4.interop = "none" : "node" === i3 && "namespace" === t4.interop ? t4.interop = "node-namespace" : "node" === i3 && "default" === t4.interop ? t4.interop = "node-default" : p && "namespace" === t4.interop && (t4.interop = "default");
    }
    return { exportName: t3, exportNameListName: null, hasExports: y, local: h, source: m, stringSpecifiers: f };
  }, t2.hasExports = function(e3) {
    return e3.hasExports;
  }, t2.isSideEffectImport = function(e3) {
    return 0 === e3.imports.size && 0 === e3.importsNamespace.size && 0 === e3.reexports.size && 0 === e3.reexportNamespace.size && !e3.reexportAll;
  }, t2.validateImportInteropOption = o2;
  var n2 = r2(10), s2 = r2(59), i2 = r2(62);
  function o2(e3) {
    if ("function" != typeof e3 && "none" !== e3 && "babel" !== e3 && "node" !== e3) throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${e3}).`);
    return e3;
  }
  function a2(e3, t3, r3) {
    return "function" == typeof e3 ? o2(e3(t3, r3)) : e3;
  }
  function l(e3, t3) {
    if (e3.isIdentifier()) return e3.node.name;
    if (e3.isStringLiteral()) {
      const r3 = e3.node.value;
      return (0, s2.isIdentifierName)(r3) || t3.add(r3), r3;
    }
    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${e3.node.type}`);
  }
  function c(e3) {
    if (!e3.isExportSpecifier()) throw e3.isExportNamespaceSpecifier() ? e3.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.") : e3.buildCodeFrameError("Unexpected export specifier type");
  }
}, (e2, t2, r2) => {
  const n2 = r2(30);
  e2.exports = (e3, t3) => {
    const r3 = n2(e3, t3);
    return r3 ? r3.version : null;
  };
}, (e2, t2, r2) => {
  const n2 = r2(30);
  e2.exports = (e3, t3) => {
    const r3 = n2(e3.trim().replace(/^[=v]+/, ""), t3);
    return r3 ? r3.version : null;
  };
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = (e3, t3, r3, s2, i2) => {
    "string" == typeof r3 && (i2 = s2, s2 = r3, r3 = void 0);
    try {
      return new n2(e3 instanceof n2 ? e3.version : e3, r3).inc(t3, s2, i2).version;
    } catch (e4) {
      return null;
    }
  };
}, (e2, t2, r2) => {
  const n2 = r2(30);
  e2.exports = (e3, t3) => {
    const r3 = n2(e3, null, true), s2 = n2(t3, null, true), i2 = r3.compare(s2);
    if (0 === i2) return null;
    const o2 = i2 > 0, a2 = o2 ? r3 : s2, l = o2 ? s2 : r3, c = !!a2.prerelease.length;
    if (l.prerelease.length && !c) return l.patch || l.minor ? a2.patch ? "patch" : a2.minor ? "minor" : "major" : "major";
    const u = c ? "pre" : "";
    return r3.major !== s2.major ? u + "major" : r3.minor !== s2.minor ? u + "minor" : r3.patch !== s2.patch ? u + "patch" : "prerelease";
  };
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = (e3, t3) => new n2(e3, t3).major;
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = (e3, t3) => new n2(e3, t3).minor;
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = (e3, t3) => new n2(e3, t3).patch;
}, (e2, t2, r2) => {
  const n2 = r2(30);
  e2.exports = (e3, t3) => {
    const r3 = n2(e3, t3);
    return r3 && r3.prerelease.length ? r3.prerelease : null;
  };
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => n2(t3, e3, r3);
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3) => n2(e3, t3, true);
}, (e2, t2, r2) => {
  const n2 = r2(76);
  e2.exports = (e3, t3) => e3.sort((e4, r3) => n2(e4, r3, t3));
}, (e2, t2, r2) => {
  const n2 = r2(76);
  e2.exports = (e3, t3) => e3.sort((e4, r3) => n2(r3, e4, t3));
}, (e2, t2, r2) => {
  const n2 = r2(3), s2 = r2(30), { safeRe: i2, t: o2 } = r2(34);
  e2.exports = (e3, t3) => {
    if (e3 instanceof n2) return e3;
    if ("number" == typeof e3 && (e3 = String(e3)), "string" != typeof e3) return null;
    let r3 = null;
    if ((t3 = t3 || {}).rtl) {
      let t4;
      for (; (t4 = i2[o2.COERCERTL].exec(e3)) && (!r3 || r3.index + r3[0].length !== e3.length); ) r3 && t4.index + t4[0].length === r3.index + r3[0].length || (r3 = t4), i2[o2.COERCERTL].lastIndex = t4.index + t4[1].length + t4[2].length;
      i2[o2.COERCERTL].lastIndex = -1;
    } else r3 = e3.match(i2[o2.COERCE]);
    return null === r3 ? null : s2(`${r3[2]}.${r3[3] || "0"}.${r3[4] || "0"}`, t3);
  };
}, (e2, t2, r2) => {
  function n2(e3) {
    var t3 = this;
    if (t3 instanceof n2 || (t3 = new n2()), t3.tail = null, t3.head = null, t3.length = 0, e3 && "function" == typeof e3.forEach) e3.forEach(function(e4) {
      t3.push(e4);
    });
    else if (arguments.length > 0) for (var r3 = 0, s3 = arguments.length; r3 < s3; r3++) t3.push(arguments[r3]);
    return t3;
  }
  function s2(e3, t3, r3) {
    var n3 = t3 === e3.head ? new a2(r3, null, t3, e3) : new a2(r3, t3, t3.next, e3);
    return null === n3.next && (e3.tail = n3), null === n3.prev && (e3.head = n3), e3.length++, n3;
  }
  function i2(e3, t3) {
    e3.tail = new a2(t3, e3.tail, null, e3), e3.head || (e3.head = e3.tail), e3.length++;
  }
  function o2(e3, t3) {
    e3.head = new a2(t3, null, e3.head, e3), e3.tail || (e3.tail = e3.head), e3.length++;
  }
  function a2(e3, t3, r3, n3) {
    if (!(this instanceof a2)) return new a2(e3, t3, r3, n3);
    this.list = n3, this.value = e3, t3 ? (t3.next = this, this.prev = t3) : this.prev = null, r3 ? (r3.prev = this, this.next = r3) : this.next = null;
  }
  e2.exports = n2, n2.Node = a2, n2.create = n2, n2.prototype.removeNode = function(e3) {
    if (e3.list !== this) throw new Error("removing node which does not belong to this list");
    var t3 = e3.next, r3 = e3.prev;
    return t3 && (t3.prev = r3), r3 && (r3.next = t3), e3 === this.head && (this.head = t3), e3 === this.tail && (this.tail = r3), e3.list.length--, e3.next = null, e3.prev = null, e3.list = null, t3;
  }, n2.prototype.unshiftNode = function(e3) {
    if (e3 !== this.head) {
      e3.list && e3.list.removeNode(e3);
      var t3 = this.head;
      e3.list = this, e3.next = t3, t3 && (t3.prev = e3), this.head = e3, this.tail || (this.tail = e3), this.length++;
    }
  }, n2.prototype.pushNode = function(e3) {
    if (e3 !== this.tail) {
      e3.list && e3.list.removeNode(e3);
      var t3 = this.tail;
      e3.list = this, e3.prev = t3, t3 && (t3.next = e3), this.tail = e3, this.head || (this.head = e3), this.length++;
    }
  }, n2.prototype.push = function() {
    for (var e3 = 0, t3 = arguments.length; e3 < t3; e3++) i2(this, arguments[e3]);
    return this.length;
  }, n2.prototype.unshift = function() {
    for (var e3 = 0, t3 = arguments.length; e3 < t3; e3++) o2(this, arguments[e3]);
    return this.length;
  }, n2.prototype.pop = function() {
    if (this.tail) {
      var e3 = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e3;
    }
  }, n2.prototype.shift = function() {
    if (this.head) {
      var e3 = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e3;
    }
  }, n2.prototype.forEach = function(e3, t3) {
    t3 = t3 || this;
    for (var r3 = this.head, n3 = 0; null !== r3; n3++) e3.call(t3, r3.value, n3, this), r3 = r3.next;
  }, n2.prototype.forEachReverse = function(e3, t3) {
    t3 = t3 || this;
    for (var r3 = this.tail, n3 = this.length - 1; null !== r3; n3--) e3.call(t3, r3.value, n3, this), r3 = r3.prev;
  }, n2.prototype.get = function(e3) {
    for (var t3 = 0, r3 = this.head; null !== r3 && t3 < e3; t3++) r3 = r3.next;
    if (t3 === e3 && null !== r3) return r3.value;
  }, n2.prototype.getReverse = function(e3) {
    for (var t3 = 0, r3 = this.tail; null !== r3 && t3 < e3; t3++) r3 = r3.prev;
    if (t3 === e3 && null !== r3) return r3.value;
  }, n2.prototype.map = function(e3, t3) {
    t3 = t3 || this;
    for (var r3 = new n2(), s3 = this.head; null !== s3; ) r3.push(e3.call(t3, s3.value, this)), s3 = s3.next;
    return r3;
  }, n2.prototype.mapReverse = function(e3, t3) {
    t3 = t3 || this;
    for (var r3 = new n2(), s3 = this.tail; null !== s3; ) r3.push(e3.call(t3, s3.value, this)), s3 = s3.prev;
    return r3;
  }, n2.prototype.reduce = function(e3, t3) {
    var r3, n3 = this.head;
    if (arguments.length > 1) r3 = t3;
    else {
      if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
      n3 = this.head.next, r3 = this.head.value;
    }
    for (var s3 = 0; null !== n3; s3++) r3 = e3(r3, n3.value, s3), n3 = n3.next;
    return r3;
  }, n2.prototype.reduceReverse = function(e3, t3) {
    var r3, n3 = this.tail;
    if (arguments.length > 1) r3 = t3;
    else {
      if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
      n3 = this.tail.prev, r3 = this.tail.value;
    }
    for (var s3 = this.length - 1; null !== n3; s3--) r3 = e3(r3, n3.value, s3), n3 = n3.prev;
    return r3;
  }, n2.prototype.toArray = function() {
    for (var e3 = new Array(this.length), t3 = 0, r3 = this.head; null !== r3; t3++) e3[t3] = r3.value, r3 = r3.next;
    return e3;
  }, n2.prototype.toArrayReverse = function() {
    for (var e3 = new Array(this.length), t3 = 0, r3 = this.tail; null !== r3; t3++) e3[t3] = r3.value, r3 = r3.prev;
    return e3;
  }, n2.prototype.slice = function(e3, t3) {
    (t3 = t3 || this.length) < 0 && (t3 += this.length), (e3 = e3 || 0) < 0 && (e3 += this.length);
    var r3 = new n2();
    if (t3 < e3 || t3 < 0) return r3;
    e3 < 0 && (e3 = 0), t3 > this.length && (t3 = this.length);
    for (var s3 = 0, i3 = this.head; null !== i3 && s3 < e3; s3++) i3 = i3.next;
    for (; null !== i3 && s3 < t3; s3++, i3 = i3.next) r3.push(i3.value);
    return r3;
  }, n2.prototype.sliceReverse = function(e3, t3) {
    (t3 = t3 || this.length) < 0 && (t3 += this.length), (e3 = e3 || 0) < 0 && (e3 += this.length);
    var r3 = new n2();
    if (t3 < e3 || t3 < 0) return r3;
    e3 < 0 && (e3 = 0), t3 > this.length && (t3 = this.length);
    for (var s3 = this.length, i3 = this.tail; null !== i3 && s3 > t3; s3--) i3 = i3.prev;
    for (; null !== i3 && s3 > e3; s3--, i3 = i3.prev) r3.push(i3.value);
    return r3;
  }, n2.prototype.splice = function(e3, t3) {
    e3 > this.length && (e3 = this.length - 1), e3 < 0 && (e3 = this.length + e3);
    for (var r3 = 0, n3 = this.head; null !== n3 && r3 < e3; r3++) n3 = n3.next;
    var i3 = [];
    for (r3 = 0; n3 && r3 < t3; r3++) i3.push(n3.value), n3 = this.removeNode(n3);
    for (null === n3 && (n3 = this.tail), n3 !== this.head && n3 !== this.tail && (n3 = n3.prev), r3 = 0; r3 < (arguments.length <= 2 ? 0 : arguments.length - 2); r3++) n3 = s2(this, n3, r3 + 2 < 2 || arguments.length <= r3 + 2 ? void 0 : arguments[r3 + 2]);
    return i3;
  }, n2.prototype.reverse = function() {
    for (var e3 = this.head, t3 = this.tail, r3 = e3; null !== r3; r3 = r3.prev) {
      var n3 = r3.prev;
      r3.prev = r3.next, r3.next = n3;
    }
    return this.head = t3, this.tail = e3, this;
  };
  try {
    r2(267)(n2);
  } catch (e3) {
  }
}, (e2) => {
  e2.exports = function(e3) {
    e3.prototype[Symbol.iterator] = function* () {
      for (let e4 = this.head; e4; e4 = e4.next) yield e4.value;
    };
  };
}, (e2, t2, r2) => {
  const n2 = r2(8);
  e2.exports = (e3, t3) => new n2(e3, t3).set.map((e4) => e4.map((e5) => e5.value).join(" ").trim().split(" "));
}, (e2, t2, r2) => {
  const n2 = r2(3), s2 = r2(8);
  e2.exports = (e3, t3, r3) => {
    let i2 = null, o2 = null, a2 = null;
    try {
      a2 = new s2(t3, r3);
    } catch (e4) {
      return null;
    }
    return e3.forEach((e4) => {
      a2.test(e4) && (i2 && -1 !== o2.compare(e4) || (i2 = e4, o2 = new n2(i2, r3)));
    }), i2;
  };
}, (e2, t2, r2) => {
  const n2 = r2(3), s2 = r2(8);
  e2.exports = (e3, t3, r3) => {
    let i2 = null, o2 = null, a2 = null;
    try {
      a2 = new s2(t3, r3);
    } catch (e4) {
      return null;
    }
    return e3.forEach((e4) => {
      a2.test(e4) && (i2 && 1 !== o2.compare(e4) || (i2 = e4, o2 = new n2(i2, r3)));
    }), i2;
  };
}, (e2, t2, r2) => {
  const n2 = r2(3), s2 = r2(8), i2 = r2(49);
  e2.exports = (e3, t3) => {
    e3 = new s2(e3, t3);
    let r3 = new n2("0.0.0");
    if (e3.test(r3)) return r3;
    if (r3 = new n2("0.0.0-0"), e3.test(r3)) return r3;
    r3 = null;
    for (let t4 = 0; t4 < e3.set.length; ++t4) {
      const s3 = e3.set[t4];
      let o2 = null;
      s3.forEach((e4) => {
        const t5 = new n2(e4.semver.version);
        switch (e4.operator) {
          case ">":
            0 === t5.prerelease.length ? t5.patch++ : t5.prerelease.push(0), t5.raw = t5.format();
          case "":
          case ">=":
            o2 && !i2(t5, o2) || (o2 = t5);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${e4.operator}`);
        }
      }), !o2 || r3 && !i2(r3, o2) || (r3 = o2);
    }
    return r3 && e3.test(r3) ? r3 : null;
  };
}, (e2, t2, r2) => {
  const n2 = r2(8);
  e2.exports = (e3, t3) => {
    try {
      return new n2(e3, t3).range || "*";
    } catch (e4) {
      return null;
    }
  };
}, (e2, t2, r2) => {
  const n2 = r2(80);
  e2.exports = (e3, t3, r3) => n2(e3, t3, ">", r3);
}, (e2, t2, r2) => {
  const n2 = r2(80);
  e2.exports = (e3, t3, r3) => n2(e3, t3, "<", r3);
}, (e2, t2, r2) => {
  const n2 = r2(8);
  e2.exports = (e3, t3, r3) => (e3 = new n2(e3, r3), t3 = new n2(t3, r3), e3.intersects(t3, r3));
}, (e2, t2, r2) => {
  const n2 = r2(51), s2 = r2(7);
  e2.exports = (e3, t3, r3) => {
    const i2 = [];
    let o2 = null, a2 = null;
    const l = e3.sort((e4, t4) => s2(e4, t4, r3));
    for (const e4 of l) n2(e4, t3, r3) ? (a2 = e4, o2 || (o2 = e4)) : (a2 && i2.push([o2, a2]), a2 = null, o2 = null);
    o2 && i2.push([o2, null]);
    const c = [];
    for (const [e4, t4] of i2) e4 === t4 ? c.push(e4) : t4 || e4 !== l[0] ? t4 ? e4 === l[0] ? c.push(`<=${t4}`) : c.push(`${e4} - ${t4}`) : c.push(`>=${e4}`) : c.push("*");
    const u = c.join(" || "), p = "string" == typeof t3.raw ? t3.raw : String(t3);
    return u.length < p.length ? u : t3;
  };
}, (e2, t2, r2) => {
  const n2 = r2(8), s2 = r2(50), { ANY: i2 } = s2, o2 = r2(51), a2 = r2(7), l = [new s2(">=0.0.0-0")], c = [new s2(">=0.0.0")], u = (e3, t3, r3) => {
    if (e3 === t3) return true;
    if (1 === e3.length && e3[0].semver === i2) {
      if (1 === t3.length && t3[0].semver === i2) return true;
      e3 = r3.includePrerelease ? l : c;
    }
    if (1 === t3.length && t3[0].semver === i2) {
      if (r3.includePrerelease) return true;
      t3 = c;
    }
    const n3 = /* @__PURE__ */ new Set();
    let s3, u2, f, h, m, y, g;
    for (const t4 of e3) ">" === t4.operator || ">=" === t4.operator ? s3 = p(s3, t4, r3) : "<" === t4.operator || "<=" === t4.operator ? u2 = d(u2, t4, r3) : n3.add(t4.semver);
    if (n3.size > 1) return null;
    if (s3 && u2) {
      if (f = a2(s3.semver, u2.semver, r3), f > 0) return null;
      if (0 === f && (">=" !== s3.operator || "<=" !== u2.operator)) return null;
    }
    for (const e4 of n3) {
      if (s3 && !o2(e4, String(s3), r3)) return null;
      if (u2 && !o2(e4, String(u2), r3)) return null;
      for (const n4 of t3) if (!o2(e4, String(n4), r3)) return false;
      return true;
    }
    let b = !(!u2 || r3.includePrerelease || !u2.semver.prerelease.length) && u2.semver, v = !(!s3 || r3.includePrerelease || !s3.semver.prerelease.length) && s3.semver;
    b && 1 === b.prerelease.length && "<" === u2.operator && 0 === b.prerelease[0] && (b = false);
    for (const e4 of t3) {
      if (g = g || ">" === e4.operator || ">=" === e4.operator, y = y || "<" === e4.operator || "<=" === e4.operator, s3) {
        if (v && e4.semver.prerelease && e4.semver.prerelease.length && e4.semver.major === v.major && e4.semver.minor === v.minor && e4.semver.patch === v.patch && (v = false), ">" === e4.operator || ">=" === e4.operator) {
          if (h = p(s3, e4, r3), h === e4 && h !== s3) return false;
        } else if (">=" === s3.operator && !o2(s3.semver, String(e4), r3)) return false;
      }
      if (u2) {
        if (b && e4.semver.prerelease && e4.semver.prerelease.length && e4.semver.major === b.major && e4.semver.minor === b.minor && e4.semver.patch === b.patch && (b = false), "<" === e4.operator || "<=" === e4.operator) {
          if (m = d(u2, e4, r3), m === e4 && m !== u2) return false;
        } else if ("<=" === u2.operator && !o2(u2.semver, String(e4), r3)) return false;
      }
      if (!e4.operator && (u2 || s3) && 0 !== f) return false;
    }
    return !(s3 && y && !u2 && 0 !== f || u2 && g && !s3 && 0 !== f || v || b);
  }, p = (e3, t3, r3) => {
    if (!e3) return t3;
    const n3 = a2(e3.semver, t3.semver, r3);
    return n3 > 0 ? e3 : n3 < 0 || ">" === t3.operator && ">=" === e3.operator ? t3 : e3;
  }, d = (e3, t3, r3) => {
    if (!e3) return t3;
    const n3 = a2(e3.semver, t3.semver, r3);
    return n3 < 0 ? e3 : n3 > 0 || "<" === t3.operator && "<=" === e3.operator ? t3 : e3;
  };
  e2.exports = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if (e3 === t3) return true;
    e3 = new n2(e3, r3), t3 = new n2(t3, r3);
    let s3 = false;
    e: for (const n3 of e3.set) {
      for (const e4 of t3.set) {
        const t4 = u(n3, e4, r3);
        if (s3 = s3 || null !== t4, t4) continue e;
      }
      if (s3) return false;
    }
    return true;
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.getEnv = function() {
    return "production";
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.createCachedDescriptors = function(e3, t3, r3) {
    const { plugins: n3, presets: s3, passPerPreset: i3 } = t3;
    return { options: u(t3, e3), plugins: n3 ? () => h(n3, e3)(r3) : () => c([]), presets: s3 ? () => d(s3, e3)(r3)(!!i3) : () => c([]) };
  }, t2.createDescriptor = E, t2.createUncachedDescriptors = function(e3, t3, r3) {
    return { options: u(t3, e3), plugins: (0, s2.once)(() => b(t3.plugins || [], e3, r3)), presets: (0, s2.once)(() => g(t3.presets || [], e3, r3, !!t3.passPerPreset)) };
  };
  var s2 = r2(455), i2 = r2(81), o2 = r2(83), a2 = r2(84), l = r2(280);
  function* c(e3) {
    return e3;
  }
  function u(e3, t3) {
    return "string" == typeof e3.browserslistConfigFile && (e3.browserslistConfigFile = (0, l.resolveBrowserslistConfigFile)(e3.browserslistConfigFile, t3)), e3;
  }
  const p = /* @__PURE__ */ new WeakMap(), d = (0, a2.makeWeakCacheSync)((e3, t3) => {
    const r3 = t3.using((e4) => e4);
    return (0, a2.makeStrongCacheSync)((t4) => (0, a2.makeStrongCache)(function* (n3) {
      return (yield* g(e3, r3, t4, n3)).map((e4) => y(p, e4));
    }));
  }), f = /* @__PURE__ */ new WeakMap(), h = (0, a2.makeWeakCacheSync)((e3, t3) => {
    const r3 = t3.using((e4) => e4);
    return (0, a2.makeStrongCache)(function* (t4) {
      return (yield* b(e3, r3, t4)).map((e4) => y(f, e4));
    });
  }), m = {};
  function y(e3, t3) {
    const { value: r3, options: n3 = m } = t3;
    if (false === n3) return t3;
    let s3 = e3.get(r3);
    s3 || (s3 = /* @__PURE__ */ new WeakMap(), e3.set(r3, s3));
    let i3 = s3.get(n3);
    if (i3 || (i3 = [], s3.set(n3, i3)), -1 === i3.indexOf(t3)) {
      const e4 = i3.filter((e5) => {
        return n4 = t3, (r4 = e5).name === n4.name && r4.value === n4.value && r4.options === n4.options && r4.dirname === n4.dirname && r4.alias === n4.alias && r4.ownPass === n4.ownPass && (null == (s4 = r4.file) ? void 0 : s4.request) === (null == (i4 = n4.file) ? void 0 : i4.request) && (null == (o3 = r4.file) ? void 0 : o3.resolved) === (null == (a3 = n4.file) ? void 0 : a3.resolved);
        var r4, n4, s4, i4, o3, a3;
      });
      if (e4.length > 0) return e4[0];
      i3.push(t3);
    }
    return t3;
  }
  function* g(e3, t3, r3, n3) {
    return yield* v("preset", e3, t3, r3, n3);
  }
  function* b(e3, t3, r3) {
    return yield* v("plugin", e3, t3, r3);
  }
  function* v(e3, t3, r3, s3, i3) {
    const o3 = yield* n2().all(t3.map((t4, n3) => E(t4, r3, { type: e3, alias: `${s3}$${n3}`, ownPass: !!i3 })));
    return function(e4) {
      const t4 = /* @__PURE__ */ new Map();
      for (const r4 of e4) {
        if ("function" != typeof r4.value) continue;
        let n3 = t4.get(r4.value);
        if (n3 || (n3 = /* @__PURE__ */ new Set(), t4.set(r4.value, n3)), n3.has(r4.name)) {
          const t5 = e4.filter((e5) => e5.value === r4.value);
          throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", `${JSON.stringify(t5, null, 2)}`].join("\n"));
        }
        n3.add(r4.name);
      }
    }(o3), o3;
  }
  function E(e3, t3, r3) {
    let { type: n3, alias: s3, ownPass: a3 } = r3;
    return function* () {
      const r4 = (0, o2.getItemDescriptor)(e3);
      if (r4) return r4;
      let l2, c2, u2, p2 = e3;
      Array.isArray(p2) && (3 === p2.length ? [p2, c2, l2] = p2 : [p2, c2] = p2);
      let d2 = null;
      if ("string" == typeof p2) {
        if ("string" != typeof n3) throw new Error("To resolve a string-based item, the type of item must be given");
        const e4 = "plugin" === n3 ? i2.loadPlugin : i2.loadPreset, r5 = p2;
        ({ filepath: d2, value: p2 } = yield* e4(p2, t3)), u2 = { request: r5, resolved: d2 };
      }
      if (!p2) throw new Error(`Unexpected falsy value: ${String(p2)}`);
      if ("object" == typeof p2 && p2.__esModule) {
        if (!p2.default) throw new Error("Must export a default export when using ES6 modules.");
        p2 = p2.default;
      }
      if ("object" != typeof p2 && "function" != typeof p2) throw new Error(`Unsupported format: ${typeof p2}. Expected an object or a function.`);
      if (null !== d2 && "object" == typeof p2 && p2) throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${d2}`);
      return { name: l2, alias: d2 || s3, value: p2, options: c2, dirname: t3, ownPass: a3, file: u2 };
    }();
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(281);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.resolveBrowserslistConfigFile = function(e3, t3) {
  }, t2.resolveTargets = function(e3, t3) {
    const r3 = e3.targets;
    let s2;
    return "string" == typeof r3 || Array.isArray(r3) ? s2 = { browsers: r3 } : r3 && (s2 = "esmodules" in r3 ? Object.assign({}, r3, { esmodules: "intersect" }) : r3), (0, n2().default)(s2, { ignoreBrowserslistConfig: true, browserslistEnv: e3.browserslistEnv });
  };
}, (e2, t2, r2) => {
  var n2 = r2(17);
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "TargetNames", { enumerable: true, get: function() {
    return u.TargetNames;
  } }), t2.default = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var r3, n3;
    let { browsers: o3, esmodules: a3 } = e3;
    const { configPath: p2 = "." } = t3;
    !function(e4) {
      m.invariant(void 0 === e4 || y(e4), `'${String(e4)}' is not a valid browserslist query`);
    }(o3);
    let d2 = function(e4) {
      const t4 = Object.keys(u.TargetNames);
      for (const r4 of Object.keys(e4)) if (!(r4 in u.TargetNames)) throw new Error(m.formatMessage(`'${r4}' is not a valid target
- Did you mean '${(0, i2.findSuggestion)(r4, t4)}'?`));
      return e4;
    }(function(e4) {
      const t4 = Object.assign({}, e4);
      return delete t4.esmodules, delete t4.browsers, t4;
    }(e3));
    const f2 = !!o3 || Object.keys(d2).length > 0, g2 = !t3.ignoreBrowserslistConfig && !f2;
    if (!o3 && g2 && (o3 = s2.loadConfig({ config: t3.configFile, path: p2, env: t3.browserslistEnv }), null == o3 && (o3 = [])), !a3 || "intersect" === a3 && null != (r3 = o3) && r3.length || (o3 = Object.keys(h).map((e4) => `${e4} >= ${h[e4]}`).join(", "), a3 = false), null != (n3 = o3) && n3.length) {
      const e4 = function(e5, t4) {
        const r4 = "string" == typeof e5 ? e5 : e5.join() + t4;
        let n4 = E.get(r4);
        return n4 || (n4 = function(e6, t5) {
          return function(e7) {
            return e7.reduce((e8, t6) => {
              const [r5, n5] = t6.split(" "), s3 = c.browserNameMap[r5];
              if (!s3) return e8;
              try {
                const t7 = n5.split("-")[0].toLowerCase(), r6 = (0, l.isUnreleasedVersion)(t7, s3);
                if (!e8[s3]) return e8[s3] = r6 ? t7 : (0, l.semverify)(t7), e8;
                const i3 = e8[s3], o4 = (0, l.isUnreleasedVersion)(i3, s3);
                if (o4 && r6) e8[s3] = (0, l.getLowestUnreleased)(i3, t7, s3);
                else if (o4) e8[s3] = (0, l.semverify)(t7);
                else if (!o4 && !r6) {
                  const r7 = (0, l.semverify)(t7);
                  e8[s3] = (0, l.semverMin)(i3, r7);
                }
              } catch (e9) {
              }
              return e8;
            }, {});
          }(s2(e6, { mobileToDesktop: true, env: t5 }));
        }(e5, t4), E.set(r4, n4)), Object.assign({}, n4);
      }(o3, t3.browserslistEnv);
      if ("intersect" === a3) for (const t4 of Object.keys(e4)) if ("deno" !== t4 && "ie" !== t4) {
        const r4 = h["opera_mobile" === t4 ? "op_mob" : t4];
        if (r4) {
          const n4 = e4[t4];
          e4[t4] = (0, l.getHighestUnreleased)(n4, (0, l.semverify)(r4), t4);
        } else delete e4[t4];
      } else delete e4[t4];
      d2 = Object.assign(e4, d2);
    }
    const S = {}, x = [];
    for (const e4 of Object.keys(d2).sort()) {
      const t4 = d2[e4];
      "number" == typeof t4 && t4 % 1 != 0 && x.push({ target: e4, value: t4 });
      const [r4, n4] = "node" === e4 ? b(t4) : v(e4, t4);
      n4 && (S[r4] = n4);
    }
    return (T = x).length && T.forEach((e4) => {
      let { target: t4, value: r4 } = e4;
    }), S;
    var T;
  }, Object.defineProperty(t2, "filterItems", { enumerable: true, get: function() {
    return f.default;
  } }), Object.defineProperty(t2, "getInclusionReasons", { enumerable: true, get: function() {
    return d.getInclusionReasons;
  } }), t2.isBrowsersQueryValid = y, Object.defineProperty(t2, "isRequired", { enumerable: true, get: function() {
    return f.isRequired;
  } }), Object.defineProperty(t2, "prettifyTargets", { enumerable: true, get: function() {
    return p.prettifyTargets;
  } }), Object.defineProperty(t2, "unreleasedLabels", { enumerable: true, get: function() {
    return c.unreleasedLabels;
  } });
  var s2 = r2(282), i2 = r2(289), o2 = r2(463), a2 = r2(132), l = r2(138), c = r2(139), u = r2(465), p = r2(291), d = r2(466), f = r2(467);
  const h = o2["es6.module"], m = new i2.OptionValidator("@babel/helper-compilation-targets");
  function y(e3) {
    return "string" == typeof e3 || Array.isArray(e3) && e3.every((e4) => "string" == typeof e4);
  }
  function g(e3, t3) {
    try {
      return (0, l.semverify)(t3);
    } catch (r3) {
      throw new Error(m.formatMessage(`'${t3}' is not a valid value for 'targets.${e3}'.`));
    }
  }
  function b(e3) {
    return ["node", true === e3 || "current" === e3 ? n2.versions.node : g("node", e3)];
  }
  function v(e3, t3) {
    return [e3, (0, l.isUnreleasedVersion)(t3, e3) ? t3.toLowerCase() : g(e3, t3)];
  }
  const E = new a2({ max: 64 });
}, (e2, t2, r2) => {
  var n2 = r2(456), s2 = r2(457).a, i2 = r2(460), o2 = r2(461), a2 = r2(286), l = r2(137), c = r2(287), u = r2(288), p = "37";
  function d(e3, t3) {
    return 0 === (e3 + ".").indexOf(t3 + ".");
  }
  function f(e3) {
    return e3.filter(function(e4) {
      return "string" == typeof e4;
    });
  }
  function h(e3) {
    var t3 = e3;
    return 3 === e3.split(".").length && (t3 = e3.split(".").slice(0, -1).join(".")), t3;
  }
  function m(e3) {
    return function(t3) {
      return e3 + " " + t3;
    };
  }
  function y(e3) {
    return parseInt(e3.split(".")[0]);
  }
  function g(e3, t3) {
    if (0 === e3.length) return [];
    var r3 = b(e3.map(y)), n3 = r3[r3.length - t3];
    if (!n3) return e3;
    for (var s3 = [], i3 = e3.length - 1; i3 >= 0 && !(n3 > y(e3[i3])); i3--) s3.unshift(e3[i3]);
    return s3;
  }
  function b(e3) {
    for (var t3 = [], r3 = 0; r3 < e3.length; r3++) -1 === t3.indexOf(e3[r3]) && t3.push(e3[r3]);
    return t3;
  }
  function v(e3, t3, r3) {
    for (var n3 in r3) e3[t3 + " " + n3] = r3[n3];
  }
  function E(e3, t3) {
    return t3 = parseFloat(t3), ">" === e3 ? function(e4) {
      return parseFloat(e4) > t3;
    } : ">=" === e3 ? function(e4) {
      return parseFloat(e4) >= t3;
    } : "<" === e3 ? function(e4) {
      return parseFloat(e4) < t3;
    } : function(e4) {
      return parseFloat(e4) <= t3;
    };
  }
  function S(e3) {
    return parseInt(e3);
  }
  function x(e3, t3) {
    return e3 < t3 ? -1 : e3 > t3 ? 1 : 0;
  }
  function T(e3, t3) {
    return x(parseInt(e3[0]), parseInt(t3[0])) || x(parseInt(e3[1] || "0"), parseInt(t3[1] || "0")) || x(parseInt(e3[2] || "0"), parseInt(t3[2] || "0"));
  }
  function w(e3, t3) {
    return void 0 === (t3 = t3.split(".").map(S))[1] && (t3[1] = "x"), "<=" === e3 ? function(e4) {
      return P(e4 = e4.split(".").map(S), t3) <= 0;
    } : function(e4) {
      return P(e4 = e4.split(".").map(S), t3) >= 0;
    };
  }
  function P(e3, t3) {
    return e3[0] !== t3[0] ? e3[0] < t3[0] ? -1 : 1 : "x" === t3[1] ? 0 : e3[1] !== t3[1] ? e3[1] < t3[1] ? -1 : 1 : 0;
  }
  function A(e3, t3) {
    var r3 = function(e4, t4) {
      return -1 !== e4.versions.indexOf(t4) ? t4 : !!F.versionAliases[e4.name][t4] && F.versionAliases[e4.name][t4];
    }(e3, t3);
    return r3 || 1 === e3.versions.length && e3.versions[0];
  }
  function C(e3, t3) {
    return e3 /= 1e3, Object.keys(s2).reduce(function(r3, n3) {
      var s3 = I(n3, t3);
      if (!s3) return r3;
      var i3 = Object.keys(s3.releaseDate).filter(function(t4) {
        var r4 = s3.releaseDate[t4];
        return null !== r4 && r4 >= e3;
      });
      return r3.concat(i3.map(m(s3.name)));
    }, []);
  }
  function O(e3) {
    return { name: e3.name, versions: e3.versions, released: e3.released, releaseDate: e3.releaseDate };
  }
  function I(e3, t3) {
    if (e3 = e3.toLowerCase(), e3 = F.aliases[e3] || e3, t3.mobileToDesktop && F.desktopNames[e3]) {
      var r3 = F.data[F.desktopNames[e3]];
      if ("android" === e3) return s3 = O(F.data[e3]), i3 = r3, s3.released = _(s3.released, i3.released), s3.versions = _(s3.versions, i3.versions), s3.releaseDate = function(e4) {
        var t4 = {};
        for (var r4 in e4) t4[r4] = e4[r4];
        return t4;
      }(s3.releaseDate), s3.released.forEach(function(e4) {
        void 0 === s3.releaseDate[e4] && (s3.releaseDate[e4] = i3.releaseDate[e4]);
      }), s3;
      var n3 = O(r3);
      return n3.name = e3, n3;
    }
    var s3, i3;
    return F.data[e3];
  }
  function _(e3, t3) {
    var r3 = t3.indexOf(p);
    return e3.filter(function(e4) {
      return /^(?:[2-4]\.|[34]$)/.test(e4);
    }).concat(t3.slice(r3));
  }
  function k(e3, t3) {
    var r3 = I(e3, t3);
    if (!r3) throw new l("Unknown browser " + e3);
    return r3;
  }
  function N(e3, t3, r3, n3) {
    var s3 = 1;
    switch (t3) {
      case "android":
        if (n3.mobileToDesktop) return e3;
        var i3 = F.data.chrome.released;
        s3 = i3.length - i3.indexOf(p);
        break;
      case "op_mob":
        s3 = y(F.data.op_mob.released.slice(-1)[0]) - 14 + 1;
        break;
      default:
        return e3;
    }
    return r3 <= s3 ? e3.slice(-1) : e3.slice(s3 - 1 - r3);
  }
  function D(e3, t3) {
    return "string" == typeof e3 && (e3.indexOf("y") >= 0 || t3 && e3.indexOf("a") >= 0);
  }
  function j(e3, t3) {
    return c(q, e3).reduce(function(e4, r3, n3) {
      if (r3.not && 0 === n3) throw new l("Write any browsers query (for instance, `defaults`) before `" + r3.query + "`");
      var s3 = q[r3.type].select.call(F, t3, r3).map(function(e5) {
        var r4 = e5.split(" ");
        return "0" === r4[1] ? r4[0] + " " + I(r4[0], t3).versions[0] : e5;
      });
      if ("and" === r3.compose) return r3.not ? e4.filter(function(e5) {
        return -1 === s3.indexOf(e5);
      }) : e4.filter(function(e5) {
        return -1 !== s3.indexOf(e5);
      });
      if (r3.not) {
        var i3 = {};
        return s3.forEach(function(e5) {
          i3[e5] = true;
        }), e4.filter(function(e5) {
          return !i3[e5];
        });
      }
      return e4.concat(s3);
    }, []);
  }
  function L(e3) {
    return void 0 === e3 && (e3 = {}), void 0 === e3.path && (e3.path = o2.resolve ? o2.resolve(".") : "."), e3;
  }
  function M(e3, t3) {
    null == e3 && (e3 = F.loadConfig(t3) || F.defaults);
    return e3;
  }
  function B(e3) {
    if ("string" != typeof e3 && !Array.isArray(e3)) throw new l("Browser queries must be an array or string. Got " + typeof e3 + ".");
  }
  var R = {};
  function F(e3, t3) {
    B(e3 = M(e3, t3 = L(t3)));
    var r3 = { ignoreUnknownVersions: t3.ignoreUnknownVersions, dangerousExtend: t3.dangerousExtend, mobileToDesktop: t3.mobileToDesktop, path: t3.path, env: t3.env };
    u.oldDataWarning(F.data);
    var n3 = u.getStat(t3, F.data);
    if (n3) for (var s3 in r3.customUsage = {}, n3) v(r3.customUsage, s3, n3[s3]);
    var i3 = JSON.stringify([e3, r3]);
    if (R[i3]) return R[i3];
    var o3 = b(j(e3, r3)).sort(function(e4, t4) {
      if (e4 = e4.split(" "), t4 = t4.split(" "), e4[0] === t4[0]) {
        var r4 = e4[1].split("-")[0];
        return T(t4[1].split("-")[0].split("."), r4.split("."));
      }
      return x(e4[0], t4[0]);
    });
    return u.env.BROWSERSLIST_DISABLE_CACHE || (R[i3] = o3), o3;
  }
  function U(e3, t3) {
    var r3 = F.nodeVersions.filter(function(e4) {
      return d(e4, t3.version);
    });
    if (0 === r3.length) {
      if (e3.ignoreUnknownVersions) return [];
      throw new l("Unknown version " + t3.version + " of Node.js");
    }
    return ["node " + r3[r3.length - 1]];
  }
  function $(e3, t3) {
    var r3 = parseInt(t3.year), n3 = parseInt(t3.month || "01") - 1, s3 = parseInt(t3.day || "01");
    return C(Date.UTC(r3, n3, s3, 0, 0, 0), e3);
  }
  function V(e3, t3) {
    var r3 = parseFloat(t3.coverage), n3 = F.usage.global;
    if (t3.place) if (t3.place.match(/^my\s+stats$/i)) {
      if (!e3.customUsage) throw new l("Custom usage statistics was not provided");
      n3 = e3.customUsage;
    } else {
      var s3;
      s3 = 2 === t3.place.length ? t3.place.toUpperCase() : t3.place.toLowerCase(), u.loadCountry(F.usage, s3, F.data), n3 = F.usage[s3];
    }
    for (var i3, o3 = Object.keys(n3).sort(function(e4, t4) {
      return n3[t4] - n3[e4];
    }), a3 = 0, c2 = [], p2 = 0; p2 < o3.length && (i3 = o3[p2], 0 !== n3[i3]) && (a3 += n3[i3], c2.push(i3), !(a3 >= r3)); p2++) ;
    return c2;
  }
  F.parse = function(e3, t3) {
    return B(e3 = M(e3, t3 = L(t3))), c(q, e3);
  }, F.cache = {}, F.data = {}, F.usage = { global: {}, custom: null }, F.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"], F.aliases = { fx: "firefox", ff: "firefox", ios: "ios_saf", explorer: "ie", blackberry: "bb", explorermobile: "ie_mob", operamini: "op_mini", operamobile: "op_mob", chromeandroid: "and_chr", firefoxandroid: "and_ff", ucandroid: "and_uc", qqandroid: "and_qq" }, F.desktopNames = { and_chr: "chrome", and_ff: "firefox", ie_mob: "ie", android: "chrome" }, F.versionAliases = {}, F.clearCaches = u.clearCaches, F.parseConfig = u.parseConfig, F.readConfig = u.readConfig, F.findConfig = u.findConfig, F.loadConfig = u.loadConfig, F.coverage = function(e3, t3) {
    var r3;
    if (void 0 === t3) r3 = F.usage.global;
    else if ("my stats" === t3) {
      var n3 = {};
      n3.path = o2.resolve ? o2.resolve(".") : ".";
      var s3 = u.getStat(n3);
      if (!s3) throw new l("Custom usage statistics was not provided");
      for (var i3 in r3 = {}, s3) v(r3, i3, s3[i3]);
    } else if ("string" == typeof t3) t3 = t3.length > 2 ? t3.toLowerCase() : t3.toUpperCase(), u.loadCountry(F.usage, t3, F.data), r3 = F.usage[t3];
    else for (var a3 in "dataByBrowser" in t3 && (t3 = t3.dataByBrowser), r3 = {}, t3) for (var c2 in t3[a3]) r3[a3 + " " + c2] = t3[a3][c2];
    return e3.reduce(function(e4, t4) {
      var n4 = r3[t4];
      return void 0 === n4 && (n4 = r3[t4.replace(/ \S+$/, " 0")]), e4 + (n4 || 0);
    }, 0);
  };
  var q = { last_major_versions: { matches: ["versions"], regexp: /^last\s+(\d+)\s+major\s+versions?$/i, select: function(e3, t3) {
    return Object.keys(s2).reduce(function(r3, n3) {
      var s3 = I(n3, e3);
      if (!s3) return r3;
      var i3 = g(s3.released, t3.versions);
      return i3 = N(i3 = i3.map(m(s3.name)), s3.name, t3.versions, e3), r3.concat(i3);
    }, []);
  } }, last_versions: { matches: ["versions"], regexp: /^last\s+(\d+)\s+versions?$/i, select: function(e3, t3) {
    return Object.keys(s2).reduce(function(r3, n3) {
      var s3 = I(n3, e3);
      if (!s3) return r3;
      var i3 = s3.released.slice(-t3.versions);
      return i3 = N(i3 = i3.map(m(s3.name)), s3.name, t3.versions, e3), r3.concat(i3);
    }, []);
  } }, last_electron_major_versions: { matches: ["versions"], regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i, select: function(e3, t3) {
    return g(Object.keys(a2), t3.versions).map(function(e4) {
      return "chrome " + a2[e4];
    });
  } }, last_node_major_versions: { matches: ["versions"], regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i, select: function(e3, t3) {
    return g(F.nodeVersions, t3.versions).map(function(e4) {
      return "node " + e4;
    });
  } }, last_browser_major_versions: { matches: ["versions", "browser"], regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i, select: function(e3, t3) {
    var r3 = k(t3.browser, e3), n3 = g(r3.released, t3.versions).map(m(r3.name));
    return N(n3, r3.name, t3.versions, e3);
  } }, last_electron_versions: { matches: ["versions"], regexp: /^last\s+(\d+)\s+electron\s+versions?$/i, select: function(e3, t3) {
    return Object.keys(a2).slice(-t3.versions).map(function(e4) {
      return "chrome " + a2[e4];
    });
  } }, last_node_versions: { matches: ["versions"], regexp: /^last\s+(\d+)\s+node\s+versions?$/i, select: function(e3, t3) {
    return F.nodeVersions.slice(-t3.versions).map(function(e4) {
      return "node " + e4;
    });
  } }, last_browser_versions: { matches: ["versions", "browser"], regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i, select: function(e3, t3) {
    var r3 = k(t3.browser, e3), n3 = r3.released.slice(-t3.versions).map(m(r3.name));
    return N(n3, r3.name, t3.versions, e3);
  } }, unreleased_versions: { matches: [], regexp: /^unreleased\s+versions$/i, select: function(e3) {
    return Object.keys(s2).reduce(function(t3, r3) {
      var n3 = I(r3, e3);
      if (!n3) return t3;
      var s3 = n3.versions.filter(function(e4) {
        return -1 === n3.released.indexOf(e4);
      });
      return s3 = s3.map(m(n3.name)), t3.concat(s3);
    }, []);
  } }, unreleased_electron_versions: { matches: [], regexp: /^unreleased\s+electron\s+versions?$/i, select: function() {
    return [];
  } }, unreleased_browser_versions: { matches: ["browser"], regexp: /^unreleased\s+(\w+)\s+versions?$/i, select: function(e3, t3) {
    var r3 = k(t3.browser, e3);
    return r3.versions.filter(function(e4) {
      return -1 === r3.released.indexOf(e4);
    }).map(m(r3.name));
  } }, last_years: { matches: ["years"], regexp: /^last\s+(\d*.?\d+)\s+years?$/i, select: function(e3, t3) {
    return C(Date.now() - 315584329824e-1 * t3.years, e3);
  } }, since_y: { matches: ["year"], regexp: /^since (\d+)$/i, select: $ }, since_y_m: { matches: ["year", "month"], regexp: /^since (\d+)-(\d+)$/i, select: $ }, since_y_m_d: { matches: ["year", "month", "day"], regexp: /^since (\d+)-(\d+)-(\d+)$/i, select: $ }, popularity: { matches: ["sign", "popularity"], regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/, select: function(e3, t3) {
    var r3 = parseFloat(t3.popularity), n3 = F.usage.global;
    return Object.keys(n3).reduce(function(e4, s3) {
      return ">" === t3.sign ? n3[s3] > r3 && e4.push(s3) : "<" === t3.sign ? n3[s3] < r3 && e4.push(s3) : "<=" === t3.sign ? n3[s3] <= r3 && e4.push(s3) : n3[s3] >= r3 && e4.push(s3), e4;
    }, []);
  } }, popularity_in_my_stats: { matches: ["sign", "popularity"], regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/, select: function(e3, t3) {
    var r3 = parseFloat(t3.popularity);
    if (!e3.customUsage) throw new l("Custom usage statistics was not provided");
    var n3 = e3.customUsage;
    return Object.keys(n3).reduce(function(e4, s3) {
      var i3 = n3[s3];
      return null == i3 || (">" === t3.sign ? i3 > r3 && e4.push(s3) : "<" === t3.sign ? i3 < r3 && e4.push(s3) : "<=" === t3.sign ? i3 <= r3 && e4.push(s3) : i3 >= r3 && e4.push(s3)), e4;
    }, []);
  } }, popularity_in_config_stats: { matches: ["sign", "popularity", "config"], regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/, select: function(e3, t3) {
    var r3 = parseFloat(t3.popularity), n3 = u.loadStat(e3, t3.config, F.data);
    if (n3) for (var s3 in e3.customUsage = {}, n3) v(e3.customUsage, s3, n3[s3]);
    if (!e3.customUsage) throw new l("Custom usage statistics was not provided");
    var i3 = e3.customUsage;
    return Object.keys(i3).reduce(function(e4, n4) {
      var s4 = i3[n4];
      return null == s4 || (">" === t3.sign ? s4 > r3 && e4.push(n4) : "<" === t3.sign ? s4 < r3 && e4.push(n4) : "<=" === t3.sign ? s4 <= r3 && e4.push(n4) : s4 >= r3 && e4.push(n4)), e4;
    }, []);
  } }, popularity_in_place: { matches: ["sign", "popularity", "place"], regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/, select: function(e3, t3) {
    var r3 = parseFloat(t3.popularity), n3 = t3.place;
    n3 = 2 === n3.length ? n3.toUpperCase() : n3.toLowerCase(), u.loadCountry(F.usage, n3, F.data);
    var s3 = F.usage[n3];
    return Object.keys(s3).reduce(function(e4, n4) {
      var i3 = s3[n4];
      return null == i3 || (">" === t3.sign ? i3 > r3 && e4.push(n4) : "<" === t3.sign ? i3 < r3 && e4.push(n4) : "<=" === t3.sign ? i3 <= r3 && e4.push(n4) : i3 >= r3 && e4.push(n4)), e4;
    }, []);
  } }, cover: { matches: ["coverage"], regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i, select: V }, cover_in: { matches: ["coverage", "place"], regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i, select: V }, supports: { matches: ["supportType", "feature"], regexp: /^(?:(fully|partially) )?supports\s+([\w-]+)$/, select: function(e3, t3) {
    u.loadFeature(F.cache, t3.feature);
    var r3 = "fully" !== t3.supportType, n3 = F.cache[t3.feature], s3 = [];
    for (var i3 in n3) {
      var o3 = I(i3, e3), a3 = e3.mobileToDesktop && i3 in F.desktopNames && D(n3[i3][o3.released.slice(-1)[0]], r3);
      o3.versions.forEach(function(e4) {
        var t4 = n3[i3][e4];
        void 0 === t4 && a3 && (t4 = n3[F.desktopNames[i3]][e4]), D(t4, r3) && s3.push(i3 + " " + e4);
      });
    }
    return s3;
  } }, electron_range: { matches: ["from", "to"], regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i, select: function(e3, t3) {
    var r3 = h(t3.from), n3 = h(t3.to), s3 = parseFloat(t3.from), i3 = parseFloat(t3.to);
    if (!a2[r3]) throw new l("Unknown version " + s3 + " of electron");
    if (!a2[n3]) throw new l("Unknown version " + i3 + " of electron");
    return Object.keys(a2).filter(function(e4) {
      var t4 = parseFloat(e4);
      return t4 >= s3 && t4 <= i3;
    }).map(function(e4) {
      return "chrome " + a2[e4];
    });
  } }, node_range: { matches: ["from", "to"], regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i, select: function(e3, t3) {
    return F.nodeVersions.filter(w(">=", t3.from)).filter(w("<=", t3.to)).map(function(e4) {
      return "node " + e4;
    });
  } }, browser_range: { matches: ["browser", "from", "to"], regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i, select: function(e3, t3) {
    var r3 = k(t3.browser, e3), n3 = parseFloat(A(r3, t3.from) || t3.from), s3 = parseFloat(A(r3, t3.to) || t3.to);
    return r3.released.filter(function(e4) {
      var t4 = parseFloat(e4);
      return t4 >= n3 && t4 <= s3;
    }).map(m(r3.name));
  } }, electron_ray: { matches: ["sign", "version"], regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i, select: function(e3, t3) {
    var r3 = h(t3.version);
    return Object.keys(a2).filter(E(t3.sign, r3)).map(function(e4) {
      return "chrome " + a2[e4];
    });
  } }, node_ray: { matches: ["sign", "version"], regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i, select: function(e3, t3) {
    return F.nodeVersions.filter((r3 = t3.sign, n3 = t3.version, (n3 = n3.split(".").map(S))[1] = n3[1] || 0, n3[2] = n3[2] || 0, ">" === r3 ? function(e4) {
      return T(e4 = e4.split(".").map(S), n3) > 0;
    } : ">=" === r3 ? function(e4) {
      return T(e4 = e4.split(".").map(S), n3) >= 0;
    } : "<" === r3 ? function(e4) {
      return e4 = e4.split(".").map(S), T(n3, e4) > 0;
    } : function(e4) {
      return e4 = e4.split(".").map(S), T(n3, e4) >= 0;
    })).map(function(e4) {
      return "node " + e4;
    });
    var r3, n3;
  } }, browser_ray: { matches: ["browser", "sign", "version"], regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/, select: function(e3, t3) {
    var r3 = t3.version, n3 = k(t3.browser, e3), s3 = F.versionAliases[n3.name][r3];
    return s3 && (r3 = s3), n3.released.filter(E(t3.sign, r3)).map(function(e4) {
      return n3.name + " " + e4;
    });
  } }, firefox_esr: { matches: [], regexp: /^(firefox|ff|fx)\s+esr$/i, select: function() {
    return ["firefox 115"];
  } }, opera_mini_all: { matches: [], regexp: /(operamini|op_mini)\s+all/i, select: function() {
    return ["op_mini all"];
  } }, electron_version: { matches: ["version"], regexp: /^electron\s+([\d.]+)$/i, select: function(e3, t3) {
    var r3 = h(t3.version), n3 = a2[r3];
    if (!n3) throw new l("Unknown version " + t3.version + " of electron");
    return ["chrome " + n3];
  } }, node_major_version: { matches: ["version"], regexp: /^node\s+(\d+)$/i, select: U }, node_minor_version: { matches: ["version"], regexp: /^node\s+(\d+\.\d+)$/i, select: U }, node_patch_version: { matches: ["version"], regexp: /^node\s+(\d+\.\d+\.\d+)$/i, select: U }, current_node: { matches: [], regexp: /^current\s+node$/i, select: function(e3) {
    return [u.currentNode(j, e3)];
  } }, maintained_node: { matches: [], regexp: /^maintained\s+node\s+versions$/i, select: function(e3) {
    var t3 = Date.now();
    return j(Object.keys(i2).filter(function(e4) {
      return t3 < Date.parse(i2[e4].end) && t3 > Date.parse(i2[e4].start) && (r3 = e4.slice(1), F.nodeVersions.some(function(e5) {
        return d(e5, r3);
      }));
      var r3;
    }).map(function(e4) {
      return "node " + e4.slice(1);
    }), e3);
  } }, phantomjs_1_9: { matches: [], regexp: /^phantomjs\s+1.9$/i, select: function() {
    return ["safari 5"];
  } }, phantomjs_2_1: { matches: [], regexp: /^phantomjs\s+2.1$/i, select: function() {
    return ["safari 6"];
  } }, browser_version: { matches: ["browser", "version"], regexp: /^(\w+)\s+(tp|[\d.]+)$/i, select: function(e3, t3) {
    var r3 = t3.version;
    /^tp$/i.test(r3) && (r3 = "TP");
    var n3 = k(t3.browser, e3), s3 = A(n3, r3);
    if (s3) r3 = s3;
    else {
      if (!(s3 = A(n3, s3 = -1 === r3.indexOf(".") ? r3 + ".0" : r3.replace(/\.0$/, "")))) {
        if (e3.ignoreUnknownVersions) return [];
        throw new l("Unknown version " + r3 + " of " + t3.browser);
      }
      r3 = s3;
    }
    return [n3.name + " " + r3];
  } }, browserslist_config: { matches: [], regexp: /^browserslist config$/i, select: function(e3) {
    return F(void 0, e3);
  } }, extends: { matches: ["config"], regexp: /^extends (.+)$/i, select: function(e3, t3) {
    return j(u.loadQueries(e3, t3.config), e3);
  } }, defaults: { matches: [], regexp: /^defaults$/i, select: function(e3) {
    return j(F.defaults, e3);
  } }, dead: { matches: [], regexp: /^dead$/i, select: function(e3) {
    return j(["Baidu >= 0", "ie <= 11", "ie_mob <= 11", "bb <= 10", "op_mob <= 12.1", "samsung 4"], e3);
  } }, unknown: { matches: [], regexp: /^(\w+)$/i, select: function(e3, t3) {
    throw I(t3.query, e3) ? new l("Specify versions in Browserslist query for browser " + t3.query) : (r3 = t3.query, new l("Unknown browser query `" + r3 + "`. Maybe you are using old Browserslist or made typo in query."));
    var r3;
  } } };
  !function() {
    for (var e3 in s2) {
      var t3 = s2[e3];
      F.data[e3] = { name: e3, versions: f(s2[e3].versions), released: f(s2[e3].versions.slice(0, -3)), releaseDate: s2[e3].release_date }, v(F.usage.global, e3, t3.usage_global), F.versionAliases[e3] = {};
      for (var r3 = 0; r3 < t3.versions.length; r3++) {
        var i3 = t3.versions[r3];
        if (i3 && -1 !== i3.indexOf("-")) for (var o3 = i3.split("-"), a3 = 0; a3 < o3.length; a3++) F.versionAliases[e3][o3[a3]] = i3;
      }
    }
    F.nodeVersions = n2.map(function(e4) {
      return e4.version;
    });
  }(), e2.exports = F;
}, (e2) => {
  e2.exports = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
}, (e2) => {
  e2.exports = { 0: "111", 1: "112", 2: "113", 3: "114", 4: "115", 5: "116", 6: "117", 7: "118", 8: "5", 9: "19", A: "10", B: "11", C: "12", D: "7", E: "8", F: "9", G: "15", H: "120", I: "4", J: "6", K: "13", L: "14", M: "16", N: "17", O: "18", P: "79", Q: "80", R: "81", S: "83", T: "84", U: "85", V: "86", W: "87", X: "88", Y: "89", Z: "90", a: "91", b: "92", c: "93", d: "94", e: "95", f: "96", g: "97", h: "98", i: "99", j: "100", k: "101", l: "102", m: "103", n: "104", o: "105", p: "106", q: "119", r: "20", s: "21", t: "22", u: "23", v: "73", w: "107", x: "108", y: "109", z: "110", AB: "24", BB: "25", CB: "26", DB: "27", EB: "28", FB: "29", GB: "30", HB: "31", IB: "32", JB: "33", KB: "34", LB: "35", MB: "36", NB: "37", OB: "38", PB: "39", QB: "40", RB: "41", SB: "42", TB: "43", UB: "44", VB: "45", WB: "46", XB: "47", YB: "48", ZB: "49", aB: "50", bB: "51", cB: "52", dB: "53", eB: "54", fB: "55", gB: "56", hB: "57", iB: "58", jB: "60", kB: "62", lB: "63", mB: "64", nB: "65", oB: "66", pB: "67", qB: "68", rB: "69", sB: "70", tB: "71", uB: "72", vB: "74", wB: "75", xB: "76", yB: "77", zB: "78", "0B": "11.1", "1B": "12.1", "2B": "15.5", "3B": "16.0", "4B": "17.0", "5B": "3", "6B": "59", "7B": "61", "8B": "82", "9B": "121", AC: "122", BC: "123", CC: "3.2", DC: "10.1", EC: "13.1", FC: "15.2-15.3", GC: "15.4", HC: "16.1", IC: "16.2", JC: "16.3", KC: "16.4", LC: "16.5", MC: "17.1", NC: "17.2", OC: "17.3", PC: "11.5", QC: "4.2-4.3", RC: "5.5", SC: "2", TC: "124", UC: "3.5", VC: "3.6", WC: "3.1", XC: "5.1", YC: "6.1", ZC: "7.1", aC: "9.1", bC: "14.1", cC: "15.1", dC: "15.6", eC: "16.6", fC: "TP", gC: "9.5-9.6", hC: "10.0-10.1", iC: "10.5", jC: "10.6", kC: "11.6", lC: "4.0-4.1", mC: "5.0-5.1", nC: "6.0-6.1", oC: "7.0-7.1", pC: "8.1-8.4", qC: "9.0-9.2", rC: "9.3", sC: "10.0-10.2", tC: "10.3", uC: "11.0-11.2", vC: "11.3-11.4", wC: "12.0-12.1", xC: "12.2-12.5", yC: "13.0-13.1", zC: "13.2", "0C": "13.3", "1C": "13.4-13.7", "2C": "14.0-14.4", "3C": "14.5-14.8", "4C": "15.0-15.1", "5C": "15.6-15.8", "6C": "16.6-16.7", "7C": "all", "8C": "2.1", "9C": "2.2", AD: "2.3", BD: "4.1", CD: "4.4", DD: "4.4.3-4.4.4", ED: "5.0-5.4", FD: "6.2-6.4", GD: "7.2-7.4", HD: "8.2", ID: "9.2", JD: "11.1-11.2", KD: "12.0", LD: "13.0", MD: "14.0", ND: "15.0", OD: "18.0", PD: "19.0", QD: "13.18", RD: "2.5", SD: "3.0-3.1" };
}, (e2) => {
  e2.exports = { A: { A: { J: 0, D: 0, E: 0.0223482, F: 0.0446964, A: 0, B: 0.424615, RC: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "RC", "J", "D", "E", "F", "A", "B", "", "", ""], E: "IE", F: { RC: 962323200, J: 998870400, D: 1161129600, E: 1237420800, F: 1300060800, A: 1346716800, B: 1381968e3 } }, B: { A: { 0: 0.01209, 1: 806e-5, 2: 0.01209, 3: 0.02015, 4: 0.01209, 5: 0.02015, 6: 0.02821, 7: 0.05239, C: 403e-5, K: 403e-5, L: 403e-5, G: 403e-5, M: 0, N: 806e-5, O: 0.01209, P: 0, Q: 0, R: 0, S: 0, T: 0, U: 0, V: 0, W: 0.31434, X: 0, Y: 0, Z: 0, a: 0, b: 0.01209, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0, i: 0.02015, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 806e-5, w: 0.01612, x: 0.01612, y: 0.07657, z: 0.01612, q: 1.56364, H: 2.5389 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "K", "L", "G", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "q", "H", "", "", ""], E: "Edge", F: { 0: 1678665600, 1: 1680825600, 2: 1683158400, 3: 1685664e3, 4: 1689897600, 5: 1692576e3, 6: 1694649600, 7: 1697155200, C: 1438128e3, K: 1447286400, L: 1470096e3, G: 1491868800, M: 1508198400, N: 1525046400, O: 1542067200, P: 1579046400, Q: 1581033600, R: 1586736e3, S: 1590019200, T: 1594857600, U: 1598486400, V: 1602201600, W: 1605830400, X: 161136e4, Y: 1614816e3, Z: 1618358400, a: 1622073600, b: 1626912e3, c: 1630627200, d: 1632441600, e: 1634774400, f: 1637539200, g: 1641427200, h: 1643932800, i: 1646265600, j: 1649635200, k: 1651190400, l: 1653955200, m: 1655942400, n: 1659657600, o: 1661990400, p: 1664755200, w: 1666915200, x: 1670198400, y: 1673481600, z: 1675900800, q: 1698969600, H: 1701993600 }, D: { C: "ms", K: "ms", L: "ms", G: "ms", M: "ms", N: "ms", O: "ms" } }, C: { A: { 0: 806e-5, 1: 403e-5, 2: 0.01209, 3: 0.01612, 4: 0.43927, 5: 806e-5, 6: 0.01209, 7: 0.10881, 8: 0, 9: 0, SC: 0, "5B": 0, I: 403e-5, J: 0, D: 0, E: 0, F: 0, A: 0, B: 0.0403, C: 0.0403, K: 0, L: 0, G: 0, M: 0, N: 0, O: 0, r: 0, s: 0, t: 0, u: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 0, LB: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 806e-5, UB: 806e-5, VB: 0, WB: 0, XB: 0, YB: 806e-5, ZB: 0, aB: 806e-5, bB: 0, cB: 0.06448, dB: 806e-5, eB: 806e-5, fB: 806e-5, gB: 0.01612, hB: 0, iB: 0, "6B": 403e-5, jB: 0, "7B": 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 403e-5, v: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0.02015, P: 0, Q: 0, R: 0, "8B": 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 806e-5, Y: 0, Z: 0, a: 0.01612, b: 0, c: 0, d: 806e-5, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0.01209, l: 0.03224, m: 0.02418, n: 0.01209, o: 806e-5, p: 403e-5, w: 806e-5, x: 806e-5, y: 0.01209, z: 806e-5, q: 0.27807, H: 1.24124, "9B": 0.41912, AC: 0, BC: 0, TC: 0, UC: 0, VC: 0 }, B: "moz", C: ["SC", "5B", "UC", "VC", "I", "8", "J", "D", "E", "F", "A", "B", "C", "K", "L", "G", "M", "N", "O", "9", "r", "s", "t", "u", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "6B", "jB", "7B", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "v", "vB", "wB", "xB", "yB", "zB", "P", "Q", "R", "8B", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "q", "H", "9B", "AC", "BC", "TC"], E: "Firefox", F: { 0: 1678752e3, 1: 1681171200, 2: 1683590400, 3: 1686009600, 4: 1688428800, 5: 1690848e3, 6: 1693267200, 7: 1695686400, 8: 1308614400, 9: 1357603200, SC: 1161648e3, "5B": 1213660800, UC: 124632e4, VC: 1264032e3, I: 1300752e3, J: 1313452800, D: 1317081600, E: 1317081600, F: 1320710400, A: 1324339200, B: 1327968e3, C: 1331596800, K: 1335225600, L: 1338854400, G: 1342483200, M: 1346112e3, N: 1349740800, O: 1353628800, r: 1361232e3, s: 1364860800, t: 1368489600, u: 1372118400, AB: 1375747200, BB: 1379376e3, CB: 1386633600, DB: 1391472e3, EB: 1395100800, FB: 1398729600, GB: 1402358400, HB: 1405987200, IB: 1409616e3, JB: 1413244800, KB: 1417392e3, LB: 1421107200, MB: 1424736e3, NB: 1428278400, OB: 1431475200, PB: 1435881600, QB: 1439251200, RB: 144288e4, SB: 1446508800, TB: 1450137600, UB: 1453852800, VB: 1457395200, WB: 1461628800, XB: 1465257600, YB: 1470096e3, ZB: 1474329600, aB: 1479168e3, bB: 1485216e3, cB: 1488844800, dB: 149256e4, eB: 1497312e3, fB: 1502150400, gB: 1506556800, hB: 1510617600, iB: 1516665600, "6B": 1520985600, jB: 1525824e3, "7B": 1529971200, kB: 1536105600, lB: 1540252800, mB: 1544486400, nB: 154872e4, oB: 1552953600, pB: 1558396800, qB: 1562630400, rB: 1567468800, sB: 1571788800, tB: 1575331200, uB: 1578355200, v: 1581379200, vB: 1583798400, wB: 1586304e3, xB: 1588636800, yB: 1591056e3, zB: 1593475200, P: 1595894400, Q: 1598313600, R: 1600732800, "8B": 1603152e3, S: 1605571200, T: 1607990400, U: 1611619200, V: 1614038400, W: 1616457600, X: 1618790400, Y: 1622505600, Z: 1626134400, a: 1628553600, b: 1630972800, c: 1633392e3, d: 1635811200, e: 1638835200, f: 1641859200, g: 1644364800, h: 1646697600, i: 1649116800, j: 1651536e3, k: 1653955200, l: 1656374400, m: 1658793600, n: 1661212800, o: 1663632e3, p: 1666051200, w: 1668470400, x: 1670889600, y: 1673913600, z: 1676332800, q: 1698105600, H: 1700524800, "9B": 1702944e3, AC: null, BC: null, TC: null } }, D: { A: { 0: 0.10478, 1: 0.12896, 2: 0.21359, 3: 0.14508, 4: 0.10075, 5: 0.2821, 6: 0.26598, 7: 0.82615, 8: 0, 9: 0, I: 0, J: 0, D: 0, E: 0, F: 0, A: 0, B: 0, C: 0, K: 0, L: 0, G: 0, M: 0, N: 0, O: 0, r: 0, s: 0, t: 0, u: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 806e-5, LB: 0, MB: 0, NB: 0, OB: 0.01612, PB: 0, QB: 0, RB: 403e-5, SB: 0, TB: 0, UB: 0, VB: 806e-5, WB: 0, XB: 806e-5, YB: 0.03627, ZB: 0.02821, aB: 0.01209, bB: 0, cB: 0, dB: 806e-5, eB: 806e-5, fB: 403e-5, gB: 0.01612, hB: 806e-5, iB: 403e-5, "6B": 0, jB: 0.03224, "7B": 403e-5, kB: 0, lB: 403e-5, mB: 0, nB: 403e-5, oB: 0.03224, pB: 403e-5, qB: 403e-5, rB: 0.04836, sB: 0.0806, tB: 806e-5, uB: 806e-5, v: 0.01209, vB: 0.01209, wB: 0.01209, xB: 0.02015, yB: 0.01209, zB: 0.01612, P: 0.13299, Q: 0.02821, R: 0.02821, S: 0.04433, T: 0.01209, U: 0.03627, V: 0.04433, W: 0.06851, X: 0.01612, Y: 0.01612, Z: 0.01612, a: 0.06448, b: 0.03627, c: 0.09672, d: 0.04836, e: 0.02418, f: 0.01612, g: 0.02015, h: 0.07254, i: 0.0403, j: 0.03224, k: 0.04433, l: 0.03627, m: 0.26598, n: 0.06851, o: 0.08463, p: 0.0806, w: 0.0806, x: 0.12896, y: 1.7732, z: 0.10075, q: 8.53554, H: 10.1596, "9B": 0.01612, AC: 0.01209, BC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "I", "8", "J", "D", "E", "F", "A", "B", "C", "K", "L", "G", "M", "N", "O", "9", "r", "s", "t", "u", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "6B", "jB", "7B", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "v", "vB", "wB", "xB", "yB", "zB", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "q", "H", "9B", "AC", "BC"], E: "Chrome", F: { 0: 1678147200, 1: 1680566400, 2: 1682985600, 3: 1685404800, 4: 1689724800, 5: 1692057600, 6: 1694476800, 7: 1696896e3, 8: 1274745600, 9: 1332892800, I: 1264377600, J: 1283385600, D: 1287619200, E: 1291248e3, F: 1296777600, A: 1299542400, B: 1303862400, C: 1307404800, K: 1312243200, L: 1316131200, G: 1316131200, M: 1319500800, N: 1323734400, O: 1328659200, r: 133704e4, s: 1340668800, t: 1343692800, u: 1348531200, AB: 1352246400, BB: 1357862400, CB: 1361404800, DB: 1364428800, EB: 1369094400, FB: 1374105600, GB: 1376956800, HB: 1384214400, IB: 1389657600, JB: 1392940800, KB: 1397001600, LB: 1400544e3, MB: 1405468800, NB: 1409011200, OB: 141264e4, PB: 1416268800, QB: 1421798400, RB: 1425513600, SB: 1429401600, TB: 143208e4, UB: 1437523200, VB: 1441152e3, WB: 1444780800, XB: 1449014400, YB: 1453248e3, ZB: 1456963200, aB: 1460592e3, bB: 1464134400, cB: 1469059200, dB: 1472601600, eB: 1476230400, fB: 1480550400, gB: 1485302400, hB: 1489017600, iB: 149256e4, "6B": 1496707200, jB: 1500940800, "7B": 1504569600, kB: 1508198400, lB: 1512518400, mB: 1516752e3, nB: 1520294400, oB: 1523923200, pB: 1527552e3, qB: 1532390400, rB: 1536019200, sB: 1539648e3, tB: 1543968e3, uB: 154872e4, v: 1552348800, vB: 1555977600, wB: 1559606400, xB: 1564444800, yB: 1568073600, zB: 1571702400, P: 1575936e3, Q: 1580860800, R: 1586304e3, S: 1589846400, T: 1594684800, U: 1598313600, V: 1601942400, W: 1605571200, X: 1611014400, Y: 1614556800, Z: 1618272e3, a: 1621987200, b: 1626739200, c: 1630368e3, d: 1632268800, e: 1634601600, f: 1637020800, g: 1641340800, h: 1643673600, i: 1646092800, j: 1648512e3, k: 1650931200, l: 1653350400, m: 1655769600, n: 1659398400, o: 1661817600, p: 1664236800, w: 1666656e3, x: 166968e4, y: 1673308800, z: 1675728e3, q: 1698710400, H: 1701993600, "9B": null, AC: null, BC: null } }, E: { A: { 8: 0, I: 0, J: 0, D: 806e-5, E: 403e-5, F: 403e-5, A: 0, B: 0, C: 0, K: 806e-5, L: 0.05239, G: 806e-5, WC: 0, CC: 0, XC: 806e-5, YC: 0, ZC: 0, aC: 0.01209, DC: 0, "0B": 0.01612, "1B": 0.02015, EC: 0.0806, bC: 0.12493, cC: 0.02821, FC: 0.01612, GC: 0.03224, "2B": 0.04836, dC: 0.3224, "3B": 0.03224, HC: 0.0806, IC: 0.06448, JC: 0.1612, KC: 0.07254, LC: 0.12493, eC: 0.59241, "4B": 0.14911, MC: 1.26139, NC: 0.1612, OC: 403e-5, fC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "WC", "CC", "I", "8", "XC", "J", "YC", "D", "ZC", "E", "F", "aC", "A", "DC", "B", "0B", "C", "1B", "K", "EC", "L", "bC", "G", "cC", "FC", "GC", "2B", "dC", "3B", "HC", "IC", "JC", "KC", "LC", "eC", "4B", "MC", "NC", "OC", "fC", ""], E: "Safari", F: { 8: 1275868800, WC: 1205798400, CC: 1226534400, I: 1244419200, XC: 131112e4, J: 1343174400, YC: 13824e5, D: 13824e5, ZC: 1410998400, E: 1413417600, F: 1443657600, aC: 1458518400, A: 1474329600, DC: 1490572800, B: 1505779200, "0B": 1522281600, C: 1537142400, "1B": 1553472e3, K: 1568851200, EC: 1585008e3, L: 1600214400, bC: 1619395200, G: 1632096e3, cC: 1635292800, FC: 1639353600, GC: 1647216e3, "2B": 1652745600, dC: 1658275200, "3B": 1662940800, HC: 1666569600, IC: 1670889600, JC: 1674432e3, KC: 1679875200, LC: 1684368e3, eC: 1690156800, "4B": 1695686400, MC: 1698192e3, NC: 1702252800, OC: null, fC: null } }, F: { A: { 9: 0, F: 0, B: 0, C: 0, G: 0, M: 0, N: 0, O: 0, r: 0, s: 0, t: 0, u: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 0, LB: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0.01612, XB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, v: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0, P: 0, Q: 0, R: 0, "8B": 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0, c: 0, d: 403e-5, e: 0.05642, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0.02015, m: 0, n: 0.50778, o: 0.78585, p: 0.01612, gC: 0, hC: 0, iC: 0, jC: 0, "0B": 0, PC: 0, kC: 0, "1B": 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "gC", "hC", "iC", "jC", "B", "0B", "PC", "kC", "C", "1B", "G", "M", "N", "O", "9", "r", "s", "t", "u", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "v", "vB", "wB", "xB", "yB", "zB", "P", "Q", "R", "8B", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "", "", ""], E: "Opera", F: { 9: 1390867200, F: 1150761600, gC: 1223424e3, hC: 1251763200, iC: 1267488e3, jC: 1277942400, B: 1292457600, "0B": 1302566400, PC: 1309219200, kC: 1323129600, C: 1323129600, "1B": 1352073600, G: 1372723200, M: 1377561600, N: 1381104e3, O: 1386288e3, r: 1393891200, s: 1399334400, t: 1401753600, u: 1405987200, AB: 1409616e3, BB: 1413331200, CB: 1417132800, DB: 1422316800, EB: 1425945600, FB: 1430179200, GB: 1433808e3, HB: 1438646400, IB: 1442448e3, JB: 1445904e3, KB: 1449100800, LB: 1454371200, MB: 1457308800, NB: 146232e4, OB: 1465344e3, PB: 1470096e3, QB: 1474329600, RB: 1477267200, SB: 1481587200, TB: 1486425600, UB: 1490054400, VB: 1494374400, WB: 1498003200, XB: 1502236800, YB: 1506470400, ZB: 1510099200, aB: 1515024e3, bB: 1517961600, cB: 1521676800, dB: 1525910400, eB: 1530144e3, fB: 1534982400, gB: 1537833600, hB: 1543363200, iB: 1548201600, jB: 1554768e3, kB: 1561593600, lB: 1566259200, mB: 1570406400, nB: 1573689600, oB: 1578441600, pB: 1583971200, qB: 1587513600, rB: 1592956800, sB: 1595894400, tB: 1600128e3, uB: 1603238400, v: 161352e4, vB: 1612224e3, wB: 1616544e3, xB: 1619568e3, yB: 1623715200, zB: 1627948800, P: 1631577600, Q: 1633392e3, R: 1635984e3, "8B": 1638403200, S: 1642550400, T: 1644969600, U: 1647993600, V: 1650412800, W: 1652745600, X: 1654646400, Y: 1657152e3, Z: 1660780800, a: 1663113600, b: 1668816e3, c: 1668643200, d: 1671062400, e: 1675209600, f: 1677024e3, g: 1679529600, h: 1681948800, i: 1684195200, j: 1687219200, k: 1690329600, l: 1692748800, m: 1696204800, n: 169992e4, o: 169992e4, p: 1702944e3 }, D: { F: "o", B: "o", C: "o", gC: "o", hC: "o", iC: "o", jC: "o", "0B": "o", PC: "o", kC: "o", "1B": "o" } }, G: { A: { E: 0, CC: 0, lC: 0, QC: 294848e-8, mC: 294848e-8, nC: 589696e-8, oC: 0.0103197, pC: 294848e-8, qC: 0.0103197, rC: 0.0353818, sC: 294848e-8, tC: 0.0545469, uC: 0.0221136, vC: 0.0250621, wC: 0.0132682, xC: 0.27126, yC: 589696e-8, zC: 0.042753, "0C": 0.0147424, "1C": 0.0530726, "2C": 0.106145, "3C": 0.165115, "4C": 0.0707635, FC: 0.0810832, GC: 0.0987741, "2B": 0.126785, "5C": 0.971524, "3B": 0.308116, HC: 0.661934, IC: 0.293374, JC: 0.551366, KC: 0.110568, LC: 0.263889, "6C": 2.32635, "4B": 0.412787, MC: 6.85816, NC: 0.717955, OC: 0.0353818 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "CC", "lC", "QC", "mC", "nC", "oC", "E", "pC", "qC", "rC", "sC", "tC", "uC", "vC", "wC", "xC", "yC", "zC", "0C", "1C", "2C", "3C", "4C", "FC", "GC", "2B", "5C", "3B", "HC", "IC", "JC", "KC", "LC", "6C", "4B", "MC", "NC", "OC", "", ""], E: "Safari on iOS", F: { CC: 1270252800, lC: 1283904e3, QC: 1299628800, mC: 1331078400, nC: 1359331200, oC: 1394409600, E: 1410912e3, pC: 1413763200, qC: 1442361600, rC: 1458518400, sC: 1473724800, tC: 1490572800, uC: 1505779200, vC: 1522281600, wC: 1537142400, xC: 1553472e3, yC: 1568851200, zC: 1572220800, "0C": 1580169600, "1C": 1585008e3, "2C": 1600214400, "3C": 1619395200, "4C": 1632096e3, FC: 1639353600, GC: 1647216e3, "2B": 1652659200, "5C": 1658275200, "3B": 1662940800, HC: 1666569600, IC: 1670889600, JC: 1674432e3, KC: 1679875200, LC: 1684368e3, "6C": 1690156800, "4B": 1694995200, MC: 1698192e3, NC: 1702252800, OC: null } }, H: { A: { "7C": 0.07 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "7C", "", "", ""], E: "Opera Mini", F: { "7C": 1426464e3 } }, I: { A: { "5B": 0, I: 489622e-10, H: 0.24366, "8C": 0, "9C": 244811e-10, AD: 0, BD: 489622e-10, QC: 171368e-9, CD: 0, DD: 709952e-9 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "8C", "9C", "AD", "5B", "I", "BD", "QC", "CD", "DD", "H", "", "", ""], E: "Android Browser", F: { "8C": 1256515200, "9C": 1274313600, AD: 1291593600, "5B": 1298332800, I: 1318896e3, BD: 1341792e3, QC: 1374624e3, CD: 1386547200, DD: 1401667200, H: 1701734400 } }, J: { A: { D: 0, A: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "A", "", "", ""], E: "Blackberry Browser", F: { D: 1325376e3, A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, v: 1.27348, "0B": 0, PC: 0, "1B": 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "0B", "PC", "C", "1B", "v", "", "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, "0B": 1314835200, PC: 1318291200, C: 1330300800, "1B": 1349740800, v: 1673827200 }, D: { v: "webkit" } }, L: { A: { H: 40.1948 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "H", "", "", ""], E: "Chrome for Android", F: { H: 1701734400 } }, M: { A: { q: 0.310492 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "q", "", "", ""], E: "Firefox for Android", F: { q: 1698105600 } }, N: { A: { A: 0, B: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } }, O: { A: { "2B": 0.883708 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "2B", "", "", ""], E: "UC Browser for Android", F: { "2B": 1687132800 }, D: { "2B": "webkit" } }, P: { A: { I: 0.1284, r: 0.0428001, s: 0.0856003, t: 0.1605, u: 2.04371, ED: 0.0107, FD: 0, GD: 0.0535002, HD: 0, ID: 0, DC: 0, JD: 0.0107, KD: 0, LD: 0.0214001, MD: 0, ND: 0, "3B": 0.0214001, "4B": 0.0321001, OD: 0.0214001, PD: 0.0428001 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "ED", "FD", "GD", "HD", "ID", "DC", "JD", "KD", "LD", "MD", "ND", "3B", "4B", "OD", "PD", "r", "s", "t", "u", "", "", ""], E: "Samsung Internet", F: { I: 1461024e3, ED: 1481846400, FD: 1509408e3, GD: 1528329600, HD: 1546128e3, ID: 1554163200, DC: 1567900800, JD: 1582588800, KD: 1593475200, LD: 1605657600, MD: 1618531200, ND: 1629072e3, "3B": 1640736e3, "4B": 1651708800, OD: 1659657600, PD: 1667260800, r: 1677369600, s: 1684454400, t: 1689292800, u: 1697587200 } }, Q: { A: { EC: 0.167188 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "EC", "", "", ""], E: "QQ Browser", F: { EC: 1663718400 } }, R: { A: { QD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "QD", "", "", ""], E: "Baidu Browser", F: { QD: 1663027200 } }, S: { A: { RD: 0.083594, SD: 0 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "RD", "SD", "", "", ""], E: "KaiOS Browser", F: { RD: 1527811200, SD: 1631664e3 } } };
}, (e2) => {
  e2.exports = { "0.20": "39", 0.21: "41", 0.22: "41", 0.23: "41", 0.24: "41", 0.25: "42", 0.26: "42", 0.27: "43", 0.28: "43", 0.29: "43", "0.30": "44", 0.31: "45", 0.32: "45", 0.33: "45", 0.34: "45", 0.35: "45", 0.36: "47", 0.37: "49", "1.0": "49", 1.1: "50", 1.2: "51", 1.3: "52", 1.4: "53", 1.5: "54", 1.6: "56", 1.7: "58", 1.8: "59", "2.0": "61", 2.1: "61", "3.0": "66", 3.1: "66", "4.0": "69", 4.1: "69", 4.2: "69", "5.0": "73", "6.0": "76", 6.1: "76", "7.0": "78", 7.1: "78", 7.2: "78", 7.3: "78", "8.0": "80", 8.1: "80", 8.2: "80", 8.3: "80", 8.4: "80", 8.5: "80", "9.0": "83", 9.1: "83", 9.2: "83", 9.3: "83", 9.4: "83", "10.0": "85", 10.1: "85", 10.2: "85", 10.3: "85", 10.4: "85", "11.0": "87", 11.1: "87", 11.2: "87", 11.3: "87", 11.4: "87", 11.5: "87", "12.0": "89", 12.1: "89", 12.2: "89", "13.0": "91", 13.1: "91", 13.2: "91", 13.3: "91", 13.4: "91", 13.5: "91", 13.6: "91", "14.0": "93", 14.1: "93", 14.2: "93", "15.0": "94", 15.1: "94", 15.2: "94", 15.3: "94", 15.4: "94", 15.5: "94", "16.0": "96", 16.1: "96", 16.2: "96", "17.0": "98", 17.1: "98", 17.2: "98", 17.3: "98", 17.4: "98", "18.0": "100", 18.1: "100", 18.2: "100", 18.3: "100", "19.0": "102", 19.1: "102", "20.0": "104", 20.1: "104", 20.2: "104", 20.3: "104", "21.0": "106", 21.1: "106", 21.2: "106", 21.3: "106", 21.4: "106", "22.0": "108", 22.1: "108", 22.2: "108", 22.3: "108", "23.0": "110", 23.1: "110", 23.2: "110", 23.3: "110", "24.0": "112", 24.1: "112", 24.2: "112", 24.3: "112", 24.4: "112", 24.5: "112", 24.6: "112", 24.7: "112", 24.8: "112", "25.0": "114", 25.1: "114", 25.2: "114", 25.3: "114", 25.4: "114", 25.5: "114", 25.6: "114", 25.7: "114", 25.8: "114", 25.9: "114", "26.0": "116", 26.1: "116", 26.2: "116", 26.3: "116", 26.4: "116", 26.5: "116", 26.6: "116", "27.0": "118", 27.1: "118", 27.2: "118", "28.0": "120", 28.1: "120", "29.0": "121" };
}, (e2) => {
  var t2 = /^\s+and\s+(.*)/i, r2 = /^(?:,\s*|\s+or\s+)(.*)/i;
  function n2(e3) {
    return Array.isArray(e3) ? e3.reduce(function(e4, t3) {
      return e4.concat(n2(t3));
    }, []) : [e3];
  }
  function s2(e3, t3) {
    var r3 = { query: t3 };
    for (var n3 in 0 === t3.indexOf("not ") && (r3.not = true, t3 = t3.slice(4)), e3) {
      var s3 = e3[n3], i3 = t3.match(s3.regexp);
      if (i3) {
        r3.type = n3;
        for (var o2 = 0; o2 < s3.matches.length; o2++) r3[s3.matches[o2]] = i3[o2 + 1];
        return r3;
      }
    }
    return r3.type = "unknown", r3;
  }
  function i2(e3, n3, i3) {
    var o2;
    return function(e4, t3) {
      for (var r3 = 1, n4 = e4.length; r3 <= n4; r3++) if (t3(e4.substr(-r3, r3), r3, n4)) return e4.slice(0, -r3);
      return "";
    }(n3, function(n4, a2, l) {
      return t2.test(n4) ? ((o2 = s2(e3, n4.match(t2)[1])).compose = "and", i3.unshift(o2), true) : r2.test(n4) ? ((o2 = s2(e3, n4.match(r2)[1])).compose = "or", i3.unshift(o2), true) : a2 === l && ((o2 = s2(e3, n4.trim())).compose = "or", i3.unshift(o2), true);
    });
  }
  e2.exports = function(e3, t3) {
    return Array.isArray(t3) || (t3 = [t3]), n2(t3.map(function(t4) {
      var r3 = [];
      do {
        t4 = i2(e3, t4, r3);
      } while (t4);
      return r3;
    }));
  };
}, (e2, t2, r2) => {
  var n2 = r2(137);
  function s2() {
  }
  e2.exports = { loadQueries: function() {
    throw new n2("Sharable configs are not supported in client-side build of Browserslist");
  }, getStat: function(e3) {
    return e3.stats;
  }, loadConfig: function(e3) {
    if (e3.config) throw new n2("Browserslist config are not supported in client-side build");
  }, loadCountry: function() {
    throw new n2("Country statistics are not supported in client-side build of Browserslist");
  }, loadFeature: function() {
    throw new n2("Supports queries are not available in client-side build of Browserslist");
  }, currentNode: function(e3, t3) {
    return e3(["maintained node versions"], t3)[0];
  }, parseConfig: s2, readConfig: s2, findConfig: s2, clearCaches: s2, oldDataWarning: s2, env: {} };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "OptionValidator", { enumerable: true, get: function() {
    return n2.OptionValidator;
  } }), Object.defineProperty(t2, "findSuggestion", { enumerable: true, get: function() {
    return s2.findSuggestion;
  } });
  var n2 = r2(462), s2 = r2(290);
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.findSuggestion = function(e3, t3) {
    const n2 = t3.map((t4) => function(e4, t5) {
      let n3, s2, i2 = [], o2 = [];
      const a2 = e4.length, l = t5.length;
      if (!a2) return l;
      if (!l) return a2;
      for (s2 = 0; s2 <= l; s2++) i2[s2] = s2;
      for (n3 = 1; n3 <= a2; n3++) {
        for (o2 = [n3], s2 = 1; s2 <= l; s2++) o2[s2] = e4[n3 - 1] === t5[s2 - 1] ? i2[s2 - 1] : r2(i2[s2 - 1], i2[s2], o2[s2 - 1]) + 1;
        i2 = o2;
      }
      return o2[l];
    }(t4, e3));
    return t3[n2.indexOf(r2(...n2))];
  };
  const { min: r2 } = Math;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.prettifyTargets = function(e3) {
    return Object.keys(e3).reduce((t3, r3) => {
      let n3 = e3[r3];
      const o2 = s2.unreleasedLabels[r3];
      return "string" == typeof n3 && o2 !== n3 && (n3 = i2(n3)), t3[r3] = n3, t3;
    }, {});
  }, t2.prettifyVersion = i2;
  var n2 = r2(23), s2 = r2(139);
  function i2(e3) {
    if ("string" != typeof e3) return e3;
    const { major: t3, minor: r3, patch: s3 } = n2.parse(e3), i3 = [t3];
    return (r3 || s3) && i3.push(r3), s3 && i3.push(s3), i3.join(".");
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(10);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2() {
    const e3 = r2(61);
    return s2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.buildPresetChain = function* (e3, t3) {
    const r3 = yield* h(e3, t3);
    return r3 ? { plugins: F(r3.plugins), presets: F(r3.presets), options: r3.options.map((e4) => R(e4)), files: /* @__PURE__ */ new Set() } : null;
  }, t2.buildPresetChainWalker = void 0, t2.buildRootChain = function* (e3, t3) {
    let r3, s3;
    const i3 = new a2.ConfigPrinter(), l2 = yield* x({ options: e3, dirname: t3.cwd }, t3, void 0, i3);
    if (!l2) return null;
    let c2;
    yield* i3.output(), "string" == typeof e3.configFile ? c2 = yield* (0, u.loadConfig)(e3.configFile, t3.cwd, t3.envName, t3.caller) : false !== e3.configFile && (c2 = yield* (0, u.findRootConfig)(t3.root, t3.envName, t3.caller));
    let { babelrc: p2, babelrcRoots: d2 } = e3, f2 = t3.cwd;
    const h2 = B(), m2 = new a2.ConfigPrinter();
    if (c2) {
      const e4 = v(c2), n3 = yield* w(e4, t3, void 0, m2);
      if (!n3) return null;
      r3 = yield* m2.output(), void 0 === p2 && (p2 = e4.options.babelrc), void 0 === d2 && (f2 = e4.dirname, d2 = e4.options.babelrcRoots), L(h2, n3);
    }
    let y2, g2, b2 = false;
    const S2 = B();
    if ((true === p2 || void 0 === p2) && "string" == typeof t3.filename) {
      const e4 = yield* (0, u.findPackageData)(t3.filename);
      if (e4 && function(e5, t4, r4, s4) {
        if ("boolean" == typeof r4) return r4;
        const i4 = e5.root;
        if (void 0 === r4) return -1 !== t4.directories.indexOf(i4);
        let a3 = r4;
        return Array.isArray(a3) || (a3 = [a3]), a3 = a3.map((e6) => "string" == typeof e6 ? n2().resolve(s4, e6) : e6), 1 === a3.length && a3[0] === i4 ? -1 !== t4.directories.indexOf(i4) : a3.some((r5) => ("string" == typeof r5 && (r5 = (0, o2.default)(r5, s4)), t4.directories.some((t5) => G(r5, s4, t5, e5))));
      }(t3, e4, d2, f2)) {
        if ({ ignore: y2, config: g2 } = yield* (0, u.findRelativeConfig)(e4, t3.envName, t3.caller), y2 && S2.files.add(y2.filepath), y2 && q(t3, y2.ignore, null, y2.dirname) && (b2 = true), g2 && !b2) {
          const e5 = E(g2), r4 = new a2.ConfigPrinter(), n3 = yield* w(e5, t3, void 0, r4);
          n3 ? (s3 = yield* r4.output(), L(S2, n3)) : b2 = true;
        }
        g2 && b2 && S2.files.add(g2.filepath);
      }
    }
    t3.showConfig;
    const T2 = L(L(L(B(), h2), S2), l2);
    return { plugins: b2 ? [] : F(T2.plugins), presets: b2 ? [] : F(T2.presets), options: b2 ? [] : T2.options.map((e4) => R(e4)), fileHandling: b2 ? "ignored" : "transpile", ignore: y2 || void 0, babelrc: g2 || void 0, config: c2 || void 0, files: T2.files };
  };
  var i2 = r2(85), o2 = r2(471), a2 = r2(472), l = r2(39), c = r2(140), u = r2(81), p = r2(84), d = r2(279);
  const f = s2()("babel:config:config-chain"), h = t2.buildPresetChainWalker = D({ root: (e3) => m(e3), env: (e3, t3) => y(e3)(t3), overrides: (e3, t3) => g(e3)(t3), overridesEnv: (e3, t3, r3) => b(e3)(t3)(r3), createLogger: () => () => {
  } }), m = (0, p.makeWeakCacheSync)((e3) => I(e3, e3.alias, d.createUncachedDescriptors)), y = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => _(e3, e3.alias, d.createUncachedDescriptors, t3))), g = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => k(e3, e3.alias, d.createUncachedDescriptors, t3))), b = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => (0, p.makeStrongCacheSync)((r3) => N(e3, e3.alias, d.createUncachedDescriptors, t3, r3)))), v = (0, p.makeWeakCacheSync)((e3) => ({ filepath: e3.filepath, dirname: e3.dirname, options: (0, i2.validate)("configfile", e3.options, e3.filepath) })), E = (0, p.makeWeakCacheSync)((e3) => ({ filepath: e3.filepath, dirname: e3.dirname, options: (0, i2.validate)("babelrcfile", e3.options, e3.filepath) })), S = (0, p.makeWeakCacheSync)((e3) => ({ filepath: e3.filepath, dirname: e3.dirname, options: (0, i2.validate)("extendsfile", e3.options, e3.filepath) })), x = D({ root: (e3) => I(e3, "base", d.createCachedDescriptors), env: (e3, t3) => _(e3, "base", d.createCachedDescriptors, t3), overrides: (e3, t3) => k(e3, "base", d.createCachedDescriptors, t3), overridesEnv: (e3, t3, r3) => N(e3, "base", d.createCachedDescriptors, t3, r3), createLogger: (e3, t3, r3) => function(e4, t4, r4) {
    var n3;
    return r4 ? r4.configure(t4.showConfig, a2.ChainFormatter.Programmatic, { callerName: null == (n3 = t4.caller) ? void 0 : n3.name }) : () => {
    };
  }(0, t3, r3) }), T = D({ root: (e3) => P(e3), env: (e3, t3) => A(e3)(t3), overrides: (e3, t3) => C(e3)(t3), overridesEnv: (e3, t3, r3) => O(e3)(t3)(r3), createLogger: (e3, t3, r3) => function(e4, t4, r4) {
    return r4 ? r4.configure(t4.showConfig, a2.ChainFormatter.Config, { filepath: e4 }) : () => {
    };
  }(e3.filepath, t3, r3) });
  function* w(e3, t3, r3, n3) {
    const s3 = yield* T(e3, t3, r3, n3);
    return null == s3 || s3.files.add(e3.filepath), s3;
  }
  const P = (0, p.makeWeakCacheSync)((e3) => I(e3, e3.filepath, d.createUncachedDescriptors)), A = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => _(e3, e3.filepath, d.createUncachedDescriptors, t3))), C = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => k(e3, e3.filepath, d.createUncachedDescriptors, t3))), O = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => (0, p.makeStrongCacheSync)((r3) => N(e3, e3.filepath, d.createUncachedDescriptors, t3, r3))));
  function I(e3, t3, r3) {
    let { dirname: n3, options: s3 } = e3;
    return r3(n3, s3, t3);
  }
  function _(e3, t3, r3, n3) {
    let { dirname: s3, options: i3 } = e3;
    var o3;
    const a3 = null == (o3 = i3.env) ? void 0 : o3[n3];
    return a3 ? r3(s3, a3, `${t3}.env["${n3}"]`) : null;
  }
  function k(e3, t3, r3, n3) {
    let { dirname: s3, options: i3 } = e3;
    var o3;
    const a3 = null == (o3 = i3.overrides) ? void 0 : o3[n3];
    if (!a3) throw new Error("Assertion failure - missing override");
    return r3(s3, a3, `${t3}.overrides[${n3}]`);
  }
  function N(e3, t3, r3, n3, s3) {
    let { dirname: i3, options: o3 } = e3;
    var a3, l2;
    const c2 = null == (a3 = o3.overrides) ? void 0 : a3[n3];
    if (!c2) throw new Error("Assertion failure - missing override");
    const u2 = null == (l2 = c2.env) ? void 0 : l2[s3];
    return u2 ? r3(i3, u2, `${t3}.overrides[${n3}].env["${s3}"]`) : null;
  }
  function D(e3) {
    let { root: t3, env: r3, overrides: n3, overridesEnv: s3, createLogger: i3 } = e3;
    return function(e4, o3) {
      let a3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : /* @__PURE__ */ new Set(), l2 = arguments.length > 3 ? arguments[3] : void 0;
      return function* () {
        const { dirname: c2 } = e4, u2 = [], p2 = t3(e4);
        if (U(p2, c2, o3, e4.filepath)) {
          u2.push({ config: p2, envName: void 0, index: void 0 });
          const t4 = r3(e4, o3.envName);
          t4 && U(t4, c2, o3, e4.filepath) && u2.push({ config: t4, envName: o3.envName, index: void 0 }), (p2.options.overrides || []).forEach((t5, r4) => {
            const i4 = n3(e4, r4);
            if (U(i4, c2, o3, e4.filepath)) {
              u2.push({ config: i4, index: r4, envName: void 0 });
              const t6 = s3(e4, r4, o3.envName);
              t6 && U(t6, c2, o3, e4.filepath) && u2.push({ config: t6, index: r4, envName: o3.envName });
            }
          });
        }
        if (u2.some((e5) => {
          let { config: { options: { ignore: t4, only: r4 } } } = e5;
          return q(o3, t4, r4, c2);
        })) return null;
        const d2 = B(), f2 = i3(e4, o3, l2);
        for (const { config: e5, index: t4, envName: r4 } of u2) {
          if (!(yield* j(d2, e5.options, c2, o3, a3, l2))) return null;
          f2(e5, t4, r4), yield* M(d2, e5);
        }
        return d2;
      }();
    };
  }
  function* j(e3, t3, r3, n3, s3, i3) {
    if (void 0 === t3.extends) return true;
    const o3 = yield* (0, u.loadConfig)(t3.extends, r3, n3.envName, n3.caller);
    if (s3.has(o3)) throw new Error(`Configuration cycle detected loading ${o3.filepath}.
File already loaded following the config chain:
` + Array.from(s3, (e4) => ` - ${e4.filepath}`).join("\n"));
    s3.add(o3);
    const a3 = yield* w(S(o3), n3, s3, i3);
    return s3.delete(o3), !!a3 && (L(e3, a3), true);
  }
  function L(e3, t3) {
    e3.options.push(...t3.options), e3.plugins.push(...t3.plugins), e3.presets.push(...t3.presets);
    for (const r3 of t3.files) e3.files.add(r3);
    return e3;
  }
  function M(e3, t3) {
    let { options: r3, plugins: n3, presets: s3 } = t3;
    return function* () {
      return e3.options.push(r3), e3.plugins.push(...yield* n3()), e3.presets.push(...yield* s3()), e3;
    }();
  }
  function B() {
    return { options: [], presets: [], plugins: [], files: /* @__PURE__ */ new Set() };
  }
  function R(e3) {
    const t3 = Object.assign({}, e3);
    return delete t3.extends, delete t3.env, delete t3.overrides, delete t3.plugins, delete t3.presets, delete t3.passPerPreset, delete t3.ignore, delete t3.only, delete t3.test, delete t3.include, delete t3.exclude, Object.prototype.hasOwnProperty.call(t3, "sourceMap") && (t3.sourceMaps = t3.sourceMap, delete t3.sourceMap), t3;
  }
  function F(e3) {
    const t3 = /* @__PURE__ */ new Map(), r3 = [];
    for (const n3 of e3) if ("function" == typeof n3.value) {
      const e4 = n3.value;
      let s3 = t3.get(e4);
      s3 || (s3 = /* @__PURE__ */ new Map(), t3.set(e4, s3));
      let i3 = s3.get(n3.name);
      i3 ? i3.value = n3 : (i3 = { value: n3 }, r3.push(i3), n3.ownPass || s3.set(n3.name, i3));
    } else r3.push({ value: n3 });
    return r3.reduce((e4, t4) => (e4.push(t4.value), e4), []);
  }
  function U(e3, t3, r3, n3) {
    let { options: s3 } = e3;
    return (void 0 === s3.test || $(r3, s3.test, t3, n3)) && (void 0 === s3.include || $(r3, s3.include, t3, n3)) && (void 0 === s3.exclude || !$(r3, s3.exclude, t3, n3));
  }
  function $(e3, t3, r3, n3) {
    return W(e3, Array.isArray(t3) ? t3 : [t3], r3, n3);
  }
  function V(e3, t3) {
    return t3 instanceof RegExp ? String(t3) : t3;
  }
  function q(e3, t3, r3, n3) {
    if (t3 && W(e3, t3, n3)) {
      var s3;
      const r4 = `No config is applied to "${null != (s3 = e3.filename) ? s3 : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(t3, V)}\` from "${n3}"`;
      return f(r4), e3.showConfig, true;
    }
    if (r3 && !W(e3, r3, n3)) {
      var i3;
      const t4 = `No config is applied to "${null != (i3 = e3.filename) ? i3 : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(r3, V)}\` from "${n3}"`;
      return f(t4), e3.showConfig, true;
    }
    return false;
  }
  function W(e3, t3, r3, n3) {
    return t3.some((t4) => G(t4, r3, e3.filename, e3, n3));
  }
  function G(e3, t3, r3, n3, s3) {
    if ("function" == typeof e3) return !!(0, l.endHiddenCallStack)(e3)(r3, { dirname: t3, envName: n3.envName, caller: n3.caller });
    if ("string" != typeof r3) throw new c.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", s3);
    return "string" == typeof e3 && (e3 = (0, o2.default)(e3, t3)), e3.test(r3);
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(281);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.access = o2, t2.assertArray = c, t2.assertAssumptions = function(e3, t3) {
    if (void 0 === t3) return;
    if ("object" != typeof t3 || null === t3) throw new Error(`${i2(e3)} must be an object or undefined.`);
    let r3 = e3;
    do {
      r3 = r3.parent;
    } while ("root" !== r3.type);
    const n3 = "preset" === r3.source;
    for (const r4 of Object.keys(t3)) {
      const a3 = o2(e3, r4);
      if (!s2.assumptionsNames.has(r4)) throw new Error(`${i2(a3)} is not a supported assumption.`);
      if ("boolean" != typeof t3[r4]) throw new Error(`${i2(a3)} must be a boolean.`);
      if (n3 && false === t3[r4]) throw new Error(`${i2(a3)} cannot be set to 'false' inside presets.`);
    }
    return t3;
  }, t2.assertBabelrcSearch = function(e3, t3) {
    if (void 0 === t3 || "boolean" == typeof t3) return t3;
    if (Array.isArray(t3)) t3.forEach((t4, r3) => {
      if (!u(t4)) throw new Error(`${i2(o2(e3, r3))} must be a string/Function/RegExp.`);
    });
    else if (!u(t3)) throw new Error(`${i2(e3)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(t3)}`);
    return t3;
  }, t2.assertBoolean = a2, t2.assertCallerMetadata = function(e3, t3) {
    const r3 = l(e3, t3);
    if (r3) {
      if ("string" != typeof r3.name) throw new Error(`${i2(e3)} set but does not contain "name" property string`);
      for (const t4 of Object.keys(r3)) {
        const n3 = o2(e3, t4), s3 = r3[t4];
        if (null != s3 && "boolean" != typeof s3 && "string" != typeof s3 && "number" != typeof s3) throw new Error(`${i2(n3)} must be null, undefined, a boolean, a string, or a number.`);
      }
    }
    return t3;
  }, t2.assertCompact = function(e3, t3) {
    if (void 0 !== t3 && "boolean" != typeof t3 && "auto" !== t3) throw new Error(`${i2(e3)} must be a boolean, "auto", or undefined`);
    return t3;
  }, t2.assertConfigApplicableTest = function(e3, t3) {
    if (void 0 === t3) return t3;
    if (Array.isArray(t3)) t3.forEach((t4, r3) => {
      if (!u(t4)) throw new Error(`${i2(o2(e3, r3))} must be a string/Function/RegExp.`);
    });
    else if (!u(t3)) throw new Error(`${i2(e3)} must be a string/Function/RegExp, or an array of those`);
    return t3;
  }, t2.assertConfigFileSearch = function(e3, t3) {
    if (void 0 !== t3 && "boolean" != typeof t3 && "string" != typeof t3) throw new Error(`${i2(e3)} must be a undefined, a boolean, a string, got ${JSON.stringify(t3)}`);
    return t3;
  }, t2.assertFunction = function(e3, t3) {
    if (void 0 !== t3 && "function" != typeof t3) throw new Error(`${i2(e3)} must be a function, or undefined`);
    return t3;
  }, t2.assertIgnoreList = function(e3, t3) {
    const r3 = c(e3, t3);
    return null == r3 || r3.forEach((t4, r4) => function(e4, t5) {
      if ("string" != typeof t5 && "function" != typeof t5 && !(t5 instanceof RegExp)) throw new Error(`${i2(e4)} must be an array of string/Function/RegExp values, or undefined`);
      return t5;
    }(o2(e3, r4), t4)), r3;
  }, t2.assertInputSourceMap = function(e3, t3) {
    if (void 0 !== t3 && "boolean" != typeof t3 && ("object" != typeof t3 || !t3)) throw new Error(`${i2(e3)} must be a boolean, object, or undefined`);
    return t3;
  }, t2.assertObject = l, t2.assertPluginList = function(e3, t3) {
    const r3 = c(e3, t3);
    return r3 && r3.forEach((t4, r4) => function(e4, t5) {
      if (Array.isArray(t5)) {
        if (0 === t5.length) throw new Error(`${i2(e4)} must include an object`);
        if (t5.length > 3) throw new Error(`${i2(e4)} may only be a two-tuple or three-tuple`);
        if (p(o2(e4, 0), t5[0]), t5.length > 1) {
          const r5 = t5[1];
          if (void 0 !== r5 && false !== r5 && ("object" != typeof r5 || Array.isArray(r5) || null === r5)) throw new Error(`${i2(o2(e4, 1))} must be an object, false, or undefined`);
        }
        if (3 === t5.length) {
          const r5 = t5[2];
          if (void 0 !== r5 && "string" != typeof r5) throw new Error(`${i2(o2(e4, 2))} must be a string, or undefined`);
        }
      } else p(e4, t5);
      return t5;
    }(o2(e3, r4), t4)), r3;
  }, t2.assertRootMode = function(e3, t3) {
    if (void 0 !== t3 && "root" !== t3 && "upward" !== t3 && "upward-optional" !== t3) throw new Error(`${i2(e3)} must be a "root", "upward", "upward-optional" or undefined`);
    return t3;
  }, t2.assertSourceMaps = function(e3, t3) {
    if (void 0 !== t3 && "boolean" != typeof t3 && "inline" !== t3 && "both" !== t3) throw new Error(`${i2(e3)} must be a boolean, "inline", "both", or undefined`);
    return t3;
  }, t2.assertSourceType = function(e3, t3) {
    if (void 0 !== t3 && "module" !== t3 && "script" !== t3 && "unambiguous" !== t3) throw new Error(`${i2(e3)} must be "module", "script", "unambiguous", or undefined`);
    return t3;
  }, t2.assertString = function(e3, t3) {
    if (void 0 !== t3 && "string" != typeof t3) throw new Error(`${i2(e3)} must be a string, or undefined`);
    return t3;
  }, t2.assertTargets = function(e3, t3) {
    if ((0, n2().isBrowsersQueryValid)(t3)) return t3;
    if ("object" != typeof t3 || !t3 || Array.isArray(t3)) throw new Error(`${i2(e3)} must be a string, an array of strings or an object`);
    const r3 = o2(e3, "browsers"), s3 = o2(e3, "esmodules");
    d(r3, t3.browsers), a2(s3, t3.esmodules);
    for (const r4 of Object.keys(t3)) {
      const s4 = t3[r4], l2 = o2(e3, r4);
      if ("esmodules" === r4) a2(l2, s4);
      else if ("browsers" === r4) d(l2, s4);
      else {
        if (!Object.hasOwnProperty.call(n2().TargetNames, r4)) {
          const e4 = Object.keys(n2().TargetNames).join(", ");
          throw new Error(`${i2(l2)} is not a valid target. Supported targets are ${e4}`);
        }
        f(l2, s4);
      }
    }
    return t3;
  }, t2.msg = i2;
  var s2 = r2(85);
  function i2(e3) {
    switch (e3.type) {
      case "root":
        return "";
      case "env":
        return `${i2(e3.parent)}.env["${e3.name}"]`;
      case "overrides":
        return `${i2(e3.parent)}.overrides[${e3.index}]`;
      case "option":
        return `${i2(e3.parent)}.${e3.name}`;
      case "access":
        return `${i2(e3.parent)}[${JSON.stringify(e3.name)}]`;
      default:
        throw new Error(`Assertion failure: Unknown type ${e3.type}`);
    }
  }
  function o2(e3, t3) {
    return { type: "access", name: t3, parent: e3 };
  }
  function a2(e3, t3) {
    if (void 0 !== t3 && "boolean" != typeof t3) throw new Error(`${i2(e3)} must be a boolean, or undefined`);
    return t3;
  }
  function l(e3, t3) {
    if (void 0 !== t3 && ("object" != typeof t3 || Array.isArray(t3) || !t3)) throw new Error(`${i2(e3)} must be an object, or undefined`);
    return t3;
  }
  function c(e3, t3) {
    if (null != t3 && !Array.isArray(t3)) throw new Error(`${i2(e3)} must be an array, or undefined`);
    return t3;
  }
  function u(e3) {
    return "string" == typeof e3 || "function" == typeof e3 || e3 instanceof RegExp;
  }
  function p(e3, t3) {
    if (("object" != typeof t3 || !t3) && "string" != typeof t3 && "function" != typeof t3) throw new Error(`${i2(e3)} must be a string, object, function`);
    return t3;
  }
  function d(e3, t3) {
    if (void 0 !== t3 && !(0, n2().isBrowsersQueryValid)(t3)) throw new Error(`${i2(e3)} must be undefined, a string or an array of strings`);
  }
  function f(e3, t3) {
    if (("number" != typeof t3 || Math.round(t3) !== t3) && "string" != typeof t3) throw new Error(`${i2(e3)} must be a string or an integer number`);
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(10);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = f, t2.loadPartialConfig = function* (e3) {
    let t3 = false;
    if ("object" == typeof e3 && null !== e3 && !Array.isArray(e3)) {
      var r3 = e3;
      ({ showIgnoredFiles: t3 } = r3), e3 = function(e4, t4) {
        if (null == e4) return {};
        var r4, n4, s3 = {}, i4 = Object.keys(e4);
        for (n4 = 0; n4 < i4.length; n4++) r4 = i4[n4], t4.indexOf(r4) >= 0 || (s3[r4] = e4[r4]);
        return s3;
      }(r3, d);
    }
    const n3 = yield* f(e3);
    if (!n3) return null;
    const { options: i3, babelrc: o3, ignore: a3, config: l2, fileHandling: c2, files: u2 } = n3;
    return "ignored" !== c2 || t3 ? ((i3.plugins || []).forEach((e4) => {
      if (e4.value instanceof s2.default) throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
    }), new h(i3, o3 ? o3.filepath : void 0, a3 ? a3.filepath : void 0, l2 ? l2.filepath : void 0, c2, u2)) : null;
  };
  var s2 = r2(135), i2 = r2(134), o2 = r2(83), a2 = r2(292), l = r2(278), c = r2(85), u = r2(81), p = r2(280);
  const d = ["showIgnoredFiles"];
  function* f(e3) {
    if (null != e3 && ("object" != typeof e3 || Array.isArray(e3))) throw new Error("Babel options must be an object, null, or undefined");
    const t3 = e3 ? (0, c.validate)("arguments", e3) : {}, { envName: r3 = (0, l.getEnv)(), cwd: s3 = ".", root: d2 = ".", rootMode: f2 = "root", caller: h2, cloneInputAst: m = true } = t3, y = n2().resolve(s3), g = function(e4, t4) {
      switch (t4) {
        case "root":
          return e4;
        case "upward-optional": {
          const t5 = (0, u.findConfigUpwards)(e4);
          return null === t5 ? e4 : t5;
        }
        case "upward": {
          const t5 = (0, u.findConfigUpwards)(e4);
          if (null !== t5) return t5;
          throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${e4}".
One of the following config files must be in the directory tree: "${u.ROOT_CONFIG_FILENAMES.join(", ")}".`), { code: "BABEL_ROOT_NOT_FOUND", dirname: e4 });
        }
        default:
          throw new Error("Assertion failure - unknown rootMode value.");
      }
    }(n2().resolve(y, d2), f2), b = "string" == typeof t3.filename ? n2().resolve(s3, t3.filename) : void 0, v = { filename: b, cwd: y, root: g, envName: r3, caller: h2, showConfig: (yield* (0, u.resolveShowConfigPath)(y)) === b }, E = yield* (0, a2.buildRootChain)(t3, v);
    if (!E) return null;
    const S = { assumptions: {} };
    return E.options.forEach((e4) => {
      (0, i2.mergeOptions)(S, e4);
    }), { options: Object.assign({}, S, { targets: (0, p.resolveTargets)(S, g), cloneInputAst: m, babelrc: false, configFile: false, browserslistConfigFile: false, passPerPreset: false, envName: v.envName, cwd: v.cwd, root: v.root, rootMode: "root", filename: "string" == typeof v.filename ? v.filename : void 0, plugins: E.plugins.map((e4) => (0, o2.createItemFromDescriptor)(e4)), presets: E.presets.map((e4) => (0, o2.createItemFromDescriptor)(e4)) }), context: v, fileHandling: E.fileHandling, ignore: E.ignore, babelrc: E.babelrc, config: E.config, files: E.files };
  }
  class h {
    constructor(e3, t3, r3, n3, s3, i3) {
      this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files = void 0, this.options = e3, this.babelignore = r3, this.babelrc = t3, this.config = n3, this.fileHandling = s3, this.files = i3, Object.freeze(this);
    }
    hasFilesystemConfig() {
      return void 0 !== this.babelrc || void 0 !== this.config;
    }
  }
  Object.freeze(h.prototype);
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(14);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.run = function* (e3, t3, r3) {
    const p = yield* (0, a2.default)(e3.passes, (0, o2.default)(e3), t3, r3), d = p.opts;
    try {
      yield* function* (e4, t4) {
        for (const r4 of t4) {
          const t5 = [], o3 = [], a3 = [];
          for (const n3 of r4.concat([(0, i2.default)()])) {
            const r5 = new s2.default(e4, n3.key, n3.options);
            t5.push([n3, r5]), o3.push(r5), a3.push(n3.visitor);
          }
          for (const [r5, n3] of t5) {
            const t6 = r5.pre;
            if (t6) {
              const r6 = t6.call(n3, e4);
              if (yield* [], u(r6)) throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
            }
          }
          const l2 = n2().default.visitors.merge(a3, o3, e4.opts.wrapPluginVisitorMethod);
          (0, n2().default)(e4.ast, l2, e4.scope);
          for (const [r5, n3] of t5) {
            const t6 = r5.post;
            if (t6) {
              const r6 = t6.call(n3, e4);
              if (yield* [], u(r6)) throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
            }
          }
        }
      }(p, e3.passes);
    } catch (e4) {
      var f;
      throw e4.message = `${null != (f = d.filename) ? f : "unknown file"}: ${e4.message}`, e4.code || (e4.code = "BABEL_TRANSFORM_ERROR"), e4;
    }
    let h, m;
    try {
      false !== d.code && ({ outputCode: h, outputMap: m } = (0, l.default)(e3.passes, p));
    } catch (e4) {
      var y;
      throw e4.message = `${null != (y = d.filename) ? y : "unknown file"}: ${e4.message}`, e4.code || (e4.code = "BABEL_GENERATE_ERROR"), e4;
    }
    return { metadata: p.metadata, options: d, ast: true === d.ast ? p.ast : null, code: void 0 === h ? null : h, map: void 0 === m ? null : m, sourceType: p.ast.program.sourceType, externalDependencies: (0, c.flattenToSet)(e3.externalDependencies) };
  };
  var s2 = r2(476), i2 = r2(477), o2 = r2(296), a2 = r2(478), l = r2(483), c = r2(136);
  function u(e3) {
    return !(!e3 || "object" != typeof e3 && "function" != typeof e3 || !e3.then || "function" != typeof e3.then);
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(10);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const { filename: t3, cwd: r3, filenameRelative: s2 = "string" == typeof t3 ? n2().relative(r3, t3) : "unknown", sourceType: i2 = "module", inputSourceMap: o2, sourceMaps: a2 = !!o2, sourceRoot: l = e3.options.moduleRoot, sourceFileName: c = n2().basename(s2), comments: u = true, compact: p = "auto" } = e3.options, d = e3.options, f = Object.assign({}, d, { parserOpts: Object.assign({ sourceType: ".mjs" === n2().extname(s2) ? "module" : i2, sourceFileName: t3, plugins: [] }, d.parserOpts), generatorOpts: Object.assign({ filename: t3, auxiliaryCommentBefore: d.auxiliaryCommentBefore, auxiliaryCommentAfter: d.auxiliaryCommentAfter, retainLines: d.retainLines, comments: u, shouldPrintComment: d.shouldPrintComment, compact: p, minified: d.minified, sourceMaps: a2, sourceRoot: l, sourceFileName: c }, d.generatorOpts) });
    for (const t4 of e3.passes) for (const e4 of t4) e4.manipulateOptions && e4.manipulateOptions(f, f.parserOpts);
    return f;
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(21);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2() {
    const e3 = r2(36);
    return s2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    let { parserOpts: o2, highlightCode: a2 = true, filename: l = "unknown" } = t3;
    return function* () {
      try {
        const t4 = [];
        for (const s3 of e3) for (const e4 of s3) {
          const { parserOverride: s4 } = e4;
          if (s4) {
            const e5 = s4(r3, o2, n2().parse);
            void 0 !== e5 && t4.push(e5);
          }
        }
        if (0 === t4.length) return (0, n2().parse)(r3, o2);
        if (1 === t4.length) {
          if (yield* [], "function" == typeof t4[0].then) throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
          return t4[0];
        }
        throw new Error("More than one plugin attempted to override parsing.");
      } catch (e4) {
        "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" === e4.code && (e4.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.");
        const { loc: t4, missingPlugin: n3 } = e4;
        if (t4) {
          const o3 = (0, s2().codeFrameColumns)(r3, { start: { line: t4.line, column: t4.column + 1 } }, { highlightCode: a2 });
          e4.message = n3 ? `${l}: ` + (0, i2.default)(n3[0], t4, o3) : `${l}: ${e4.message}

` + o3, e4.code = "BABEL_PARSE_ERROR";
        }
        throw e4;
      }
    }();
  };
  var i2 = r2(481);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "FEATURES", { enumerable: true, get: function() {
    return p.FEATURES;
  } }), Object.defineProperty(t2, "buildCheckInRHS", { enumerable: true, get: function() {
    return l.buildCheckInRHS;
  } }), t2.createClassFeaturePlugin = function(e3) {
    let { name: t3, feature: r3, loose: h, manipulateOptions: m, api: y, inherits: g, decoratorVersion: b } = e3;
    if (r3 & p.FEATURES.decorators && ("2021-12" === b || "2022-03" === b || "2023-01" === b || "2023-05" === b)) return (0, o2.default)(y, { loose: h }, b, g);
    null != y || (y = { assumption: () => {
    } });
    const v = y.assumption("setPublicClassFields"), E = y.assumption("privateFieldsAsSymbols"), S = y.assumption("privateFieldsAsProperties"), x = y.assumption("constantSuper"), T = y.assumption("noDocumentAll");
    if (S && E) throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');
    const w = S || E;
    if (true === h) {
      const e4 = [];
      void 0 !== v && e4.push('"setPublicClassFields"'), void 0 !== S && e4.push('"privateFieldsAsProperties"'), void 0 !== E && e4.push('"privateFieldsAsSymbols"'), e4.length;
    }
    return { name: t3, manipulateOptions: m, inherits: g, pre(e4) {
      (0, p.enableFeature)(e4, r3, h), "number" != typeof e4.get(f) && e4.get(f) && !a2.lt(e4.get(f), "7.23.7") || e4.set(f, "7.23.7");
    }, visitor: { Class(e4, t4) {
      let { file: i3 } = t4;
      var o3;
      if ("7.23.7" !== i3.get(f)) return;
      if (!(0, p.shouldTransform)(e4, i3)) return;
      const a3 = e4.isClassDeclaration();
      a3 && (0, d.assertFieldTransformed)(e4);
      const h2 = (0, p.isLoose)(i3, r3);
      let m2;
      const y2 = (0, c.hasDecorators)(e4.node), g2 = [], b2 = [], P = [], A = /* @__PURE__ */ new Set(), C = e4.get("body");
      for (const e5 of C.get("body")) {
        if ((e5.isClassProperty() || e5.isClassMethod()) && e5.node.computed && P.push(e5), e5.isPrivate()) {
          const { name: t5 } = e5.node.key.id, r4 = `get ${t5}`, n3 = `set ${t5}`;
          if (e5.isClassPrivateMethod()) {
            if ("get" === e5.node.kind) {
              if (A.has(r4) || A.has(t5) && !A.has(n3)) throw e5.buildCodeFrameError("Duplicate private field");
              A.add(r4).add(t5);
            } else if ("set" === e5.node.kind) {
              if (A.has(n3) || A.has(t5) && !A.has(r4)) throw e5.buildCodeFrameError("Duplicate private field");
              A.add(n3).add(t5);
            }
          } else {
            if (A.has(t5) && !A.has(r4) && !A.has(n3) || A.has(t5) && (A.has(r4) || A.has(n3))) throw e5.buildCodeFrameError("Duplicate private field");
            A.add(t5);
          }
        }
        e5.isClassMethod({ kind: "constructor" }) ? m2 = e5 : (b2.push(e5), (e5.isProperty() || e5.isPrivate() || null != e5.isStaticBlock && e5.isStaticBlock()) && g2.push(e5));
      }
      if (!g2.length && !y2) return;
      const O = e4.node.id;
      let I;
      O && a3 || ((0, s2.default)(e4), I = e4.scope.generateUidIdentifier("class"));
      const _ = null != (o3 = I) ? o3 : n2.types.cloneNode(O), k = (0, l.buildPrivateNamesMap)(g2), N = (0, l.buildPrivateNamesNodes)(k, null != S ? S : h2, null != E && E, i3);
      let D, j, L, M, B, R, F;
      (0, l.transformPrivateNamesUsage)(_, e4, k, { privateFieldsAsProperties: null != w ? w : h2, noDocumentAll: T, innerBinding: O }, i3), y2 ? (j = B = D = [], { instanceNodes: L, wrapClass: F } = (0, c.buildDecoratedClass)(_, e4, b2, i3)) : (D = (0, u.extractComputedKeys)(e4, P, i3), { staticNodes: j, pureStaticNodes: B, instanceNodes: L, lastInstanceNodeReturnsThis: M, classBindingNode: R, wrapClass: F } = (0, l.buildFieldsInitNodes)(I, e4.node.superClass, g2, k, i3, null != v ? v : h2, null != w ? w : h2, null != x ? x : h2, O)), L.length > 0 && (0, u.injectInitialization)(e4, m2, L, (e5, t5) => {
        if (!y2) for (const r4 of g2) null != n2.types.isStaticBlock && n2.types.isStaticBlock(r4.node) || r4.node.static || r4.traverse(e5, t5);
      }, M);
      const U = F(e4);
      U.insertBefore([...N, ...D]), j.length > 0 && U.insertAfter(j), B.length > 0 && U.find((e5) => e5.isStatement() || e5.isDeclaration()).insertAfter(B), null != R && a3 && U.insertAfter(R);
    }, ExportDefaultDeclaration(e4, t4) {
      let { file: r4 } = t4;
      {
        if ("7.23.7" !== r4.get(f)) return;
        const t5 = e4.get("declaration");
        t5.isClassDeclaration() && (0, c.hasDecorators)(t5.node) && (t5.node.id ? (0, i2.default)(e4) : t5.node.type = "ClassExpression");
      }
    } } };
  }, Object.defineProperty(t2, "enableFeature", { enumerable: true, get: function() {
    return p.enableFeature;
  } }), Object.defineProperty(t2, "injectInitialization", { enumerable: true, get: function() {
    return u.injectInitialization;
  } });
  var n2 = r2(1), s2 = r2(119), i2 = r2(62), o2 = r2(496), a2 = r2(23), l = r2(497), c = r2(304), u = r2(498), p = r2(499), d = r2(303);
  const f = "@babel/plugin-class-features/version";
}, (e2, t2, r2) => {
  function n2(e3) {
    if (e3 && e3.__esModule) return e3;
    var t3 = /* @__PURE__ */ Object.create(null);
    return e3 && Object.keys(e3).forEach(function(r3) {
      if ("default" !== r3) {
        var n3 = Object.getOwnPropertyDescriptor(e3, r3);
        Object.defineProperty(t3, r3, n3.get ? n3 : { enumerable: true, get: function() {
          return e3[r3];
        } });
      }
    }), t3.default = e3, Object.freeze(t3);
  }
  Object.defineProperty(t2, "__esModule", { value: true });
  var s2 = n2(r2(0));
  function i2(e3) {
    const t3 = e3, { node: r3, parentPath: n3 } = t3;
    if (n3.isLogicalExpression()) {
      const { operator: e4, right: t4 } = n3.node;
      if ("&&" === e4 || "||" === e4 || "??" === e4 && r3 === t4) return i2(n3);
    }
    if (n3.isSequenceExpression()) {
      const { expressions: e4 } = n3.node;
      return e4[e4.length - 1] !== r3 || i2(n3);
    }
    return n3.isConditional({ test: r3 }) || n3.isUnaryExpression({ operator: "!" }) || n3.isLoop({ test: r3 });
  }
  const { LOGICAL_OPERATORS: o2, arrowFunctionExpression: a2, assignmentExpression: l, binaryExpression: c, booleanLiteral: u, callExpression: p, cloneNode: d, conditionalExpression: f, identifier: h, isMemberExpression: m, isOptionalCallExpression: y, isOptionalMemberExpression: g, isUpdateExpression: b, logicalExpression: v, memberExpression: E, nullLiteral: S, optionalCallExpression: x, optionalMemberExpression: T, sequenceExpression: w, updateExpression: P } = s2;
  class A {
    constructor() {
      this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
    }
    has(e3) {
      return this._map.has(e3);
    }
    get(e3) {
      if (!this.has(e3)) return;
      const t3 = this._map.get(e3), { value: r3 } = t3;
      return t3.count--, 0 === t3.count ? l("=", r3, e3) : r3;
    }
    set(e3, t3, r3) {
      return this._map.set(e3, { count: r3, value: t3 });
    }
  }
  function C(e3, t3) {
    const { node: r3 } = e3;
    if (g(r3)) return E(t3, r3.property, r3.computed);
    if (e3.isOptionalCallExpression()) {
      const r4 = e3.get("callee");
      if (e3.node.optional && r4.isOptionalMemberExpression()) {
        const n3 = r4.node.object, s3 = e3.scope.maybeGenerateMemoised(n3);
        return r4.get("object").replaceWith(l("=", s3, n3)), p(E(t3, h("call")), [s3, ...e3.node.arguments]);
      }
      return p(t3, e3.node.arguments);
    }
    return e3.node;
  }
  const O = { memoise() {
  }, handle(e3, t3) {
    const { node: r3, parent: n3, parentPath: s3, scope: o3 } = e3;
    if (e3.isOptionalMemberExpression()) {
      if (function(e4) {
        for (; e4 && !e4.isProgram(); ) {
          const { parentPath: t4, container: r4, listKey: n4 } = e4, s4 = t4.node;
          if (n4) {
            if (r4 !== s4[n4]) return true;
          } else if (r4 !== s4) return true;
          e4 = t4;
        }
        return false;
      }(e3)) return;
      const b2 = e3.find((t4) => {
        let { node: r4, parent: n4 } = t4;
        return g(n4) ? n4.optional || n4.object !== r4 : !y(n4) || r4 !== e3.node && n4.optional || n4.callee !== r4;
      });
      if (o3.path.isPattern()) return void b2.replaceWith(p(a2([], b2.node), []));
      const E2 = i2(b2), w2 = b2.parentPath;
      if (w2.isUpdateExpression({ argument: r3 })) throw e3.buildCodeFrameError("can't handle update expression");
      const P2 = w2.isAssignmentExpression({ left: b2.node }), A2 = w2.isUnaryExpression({ operator: "delete" });
      if (A2 && b2.isOptionalMemberExpression() && b2.get("property").isPrivateName()) throw e3.buildCodeFrameError("can't delete a private class element");
      let O2 = e3;
      for (; ; ) if (O2.isOptionalMemberExpression()) {
        if (O2.node.optional) break;
        O2 = O2.get("object");
      } else {
        if (!O2.isOptionalCallExpression()) throw new Error(`Internal error: unexpected ${O2.node.type}`);
        if (O2.node.optional) break;
        O2 = O2.get("callee");
      }
      const _ = O2.isOptionalMemberExpression() ? O2.node.object : O2.node.callee, k = o3.maybeGenerateMemoised(_), N = null != k ? k : _, D = s3.isOptionalCallExpression({ callee: r3 }), j = (e4) => D, L = s3.isCallExpression({ callee: r3 });
      O2.replaceWith(C(O2, N)), j() ? n3.optional ? s3.replaceWith(this.optionalCall(e3, n3.arguments)) : s3.replaceWith(this.call(e3, n3.arguments)) : L ? e3.replaceWith(this.boundGet(e3)) : this.delete && s3.isUnaryExpression({ operator: "delete" }) ? s3.replaceWith(this.delete(e3)) : s3.isAssignmentExpression() ? I(this, e3, s3) : e3.replaceWith(this.get(e3));
      let M, B = e3.node;
      for (let t4 = e3; t4 !== b2; ) {
        const e4 = t4.parentPath;
        if (e4 === b2 && j() && n3.optional) {
          B = e4.node;
          break;
        }
        B = C(e4, B), t4 = e4;
      }
      const R = b2.parentPath;
      if (m(B) && R.isOptionalCallExpression({ callee: b2.node, optional: true })) {
        const { object: t4 } = B;
        M = e3.scope.maybeGenerateMemoised(t4), M && (B.object = l("=", M, t4));
      }
      let F = b2;
      (A2 || P2) && (F = R, B = R.node);
      const U = k ? l("=", d(N), d(_)) : d(N);
      if (E2) {
        let e4;
        e4 = t3 ? c("!=", U, S()) : v("&&", c("!==", U, S()), c("!==", d(N), o3.buildUndefinedNode())), F.replaceWith(v("&&", e4, B));
      } else {
        let e4;
        e4 = t3 ? c("==", U, S()) : v("||", c("===", U, S()), c("===", d(N), o3.buildUndefinedNode())), F.replaceWith(f(e4, A2 ? u(true) : o3.buildUndefinedNode(), B));
      }
      if (M) {
        const e4 = R.node;
        R.replaceWith(x(T(e4.callee, h("call"), false, true), [d(M), ...e4.arguments], false));
      }
    } else {
      if (b(n3, { argument: r3 })) {
        if (this.simpleSet) return void e3.replaceWith(this.simpleSet(e3));
        const { operator: t4, prefix: i3 } = n3;
        this.memoise(e3, 2);
        const a3 = o3.generateUidIdentifierBasedOnNode(r3);
        o3.push({ id: a3 });
        const c2 = [l("=", d(a3), this.get(e3))];
        if (i3) {
          c2.push(P(t4, d(a3), i3));
          const r4 = w(c2);
          return void s3.replaceWith(this.set(e3, r4));
        }
        {
          const n4 = o3.generateUidIdentifierBasedOnNode(r3);
          o3.push({ id: n4 }), c2.push(l("=", d(n4), P(t4, d(a3), i3)), d(a3));
          const u2 = w(c2);
          return void s3.replaceWith(w([this.set(e3, u2), d(n4)]));
        }
      }
      if (s3.isAssignmentExpression({ left: r3 })) I(this, e3, s3);
      else {
        if (!s3.isCallExpression({ callee: r3 })) return s3.isOptionalCallExpression({ callee: r3 }) ? o3.path.isPattern() ? void s3.replaceWith(p(a2([], s3.node), [])) : void s3.replaceWith(this.optionalCall(e3, s3.node.arguments)) : void (this.delete && s3.isUnaryExpression({ operator: "delete" }) ? s3.replaceWith(this.delete(e3)) : s3.isForXStatement({ left: r3 }) || s3.isObjectProperty({ value: r3 }) && s3.parentPath.isObjectPattern() || s3.isAssignmentPattern({ left: r3 }) && s3.parentPath.isObjectProperty({ value: n3 }) && s3.parentPath.parentPath.isObjectPattern() || s3.isArrayPattern() || s3.isAssignmentPattern({ left: r3 }) && s3.parentPath.isArrayPattern() || s3.isRestElement() ? e3.replaceWith(this.destructureSet(e3)) : s3.isTaggedTemplateExpression() ? e3.replaceWith(this.boundGet(e3)) : e3.replaceWith(this.get(e3)));
        s3.replaceWith(this.call(e3, s3.node.arguments));
      }
    }
  } };
  function I(e3, t3, r3) {
    if (e3.simpleSet) return void t3.replaceWith(e3.simpleSet(t3));
    const { operator: n3, right: s3 } = r3.node;
    if ("=" === n3) r3.replaceWith(e3.set(t3, s3));
    else {
      const i3 = n3.slice(0, -1);
      o2.includes(i3) ? (e3.memoise(t3, 1), r3.replaceWith(v(i3, e3.get(t3), e3.set(t3, s3)))) : (e3.memoise(t3, 2), r3.replaceWith(e3.set(t3, c(i3, e3.get(t3), s3))));
    }
  }
  t2.default = function(e3, t3, r3) {
    e3.traverse(t3, Object.assign({}, O, r3, { memoiser: new A() }));
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, n3) {
    return 1 === r3.length && a2(r3[0]) && o2(r3[0].argument, { name: "arguments" }) ? n3 ? c(u(e3, i2("apply"), false, true), [t3, r3[0].argument], false) : s2(l(e3, i2("apply")), [t3, r3[0].argument]) : n3 ? c(u(e3, i2("call"), false, true), [t3, ...r3], false) : s2(l(e3, i2("call")), [t3, ...r3]);
  };
  var n2 = r2(0);
  const { callExpression: s2, identifier: i2, isIdentifier: o2, isSpreadElement: a2, memberExpression: l, optionalCallExpression: c, optionalMemberExpression: u } = n2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isTransparentExprWrapper = u, t2.skipTransparentExprWrapperNodes = function(e3) {
    for (; u(e3); ) e3 = e3.expression;
    return e3;
  }, t2.skipTransparentExprWrappers = function(e3) {
    for (; u(e3.node); ) e3 = e3.get("expression");
    return e3;
  };
  var n2 = r2(0);
  const { isParenthesizedExpression: s2, isTSAsExpression: i2, isTSNonNullExpression: o2, isTSSatisfiesExpression: a2, isTSTypeAssertion: l, isTypeCastExpression: c } = n2;
  function u(e3) {
    return i2(e3) || a2(e3) || l(e3) || o2(e3) || c(e3) || s2(e3);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const t3 = e3.node || e3;
    o2(t3) || s2(t3, "leading", i2);
  };
  var n2 = r2(0);
  const { addComment: s2 } = n2, i2 = "#__PURE__", o2 = (e3) => {
    let { leadingComments: t3 } = e3;
    return !!t3 && t3.some((e4) => /[@#]__PURE__/.test(e4.value));
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.assertFieldTransformed = function(e3) {
    if (e3.node.declare) throw e3.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-transform-class-properties\n - @babel/plugin-transform-private-methods\n - @babel/plugin-proposal-decorators");
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.buildDecoratedClass = function(e3, t3, r3, o3) {
    const { node: u, scope: p } = t3, d = p.generateUidIdentifier("initialize"), f = u.id && t3.isDeclaration(), h = t3.isInStrictMode(), { superClass: m } = u;
    let y;
    u.type = "ClassDeclaration", u.id || (u.id = n2.types.cloneNode(e3)), m && (y = p.generateUidIdentifierBasedOnNode(u.superClass, "super"), u.superClass = y);
    const g = l(u), b = n2.types.arrayExpression(r3.filter((e4) => !e4.node.abstract && "TSIndexSignature" !== e4.node.type).map((e4) => function(e5, t4, r4, o4) {
      const u2 = o4.isClassMethod();
      if (o4.isPrivate()) throw o4.buildCodeFrameError(`Private ${u2 ? "methods" : "fields"} in decorated classes are not supported yet.`);
      if ("ClassAccessorProperty" === o4.node.type) throw o4.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
      if ("StaticBlock" === o4.node.type) throw o4.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
      const { node: p2, scope: d2 } = o4;
      o4.isTSDeclareMethod() || new s2.default({ methodPath: o4, objectRef: t4, superRef: r4, file: e5, refToPreserve: t4 }).replace();
      const f2 = [a2("kind", n2.types.stringLiteral(n2.types.isClassMethod(p2) ? p2.kind : "field")), a2("decorators", l(p2)), a2("static", p2.static && n2.types.booleanLiteral(true)), a2("key", c(p2))].filter(Boolean);
      if (n2.types.isClassMethod(p2)) {
        const e6 = p2.computed ? null : p2.key, t5 = n2.types.toExpression(p2);
        f2.push(a2("value", (0, i2.default)({ node: t5, id: e6, scope: d2 }) || t5));
      } else n2.types.isClassProperty(p2) && p2.value ? f2.push(("value", h2 = n2.template.statements.ast`return ${p2.value}`, n2.types.objectMethod("method", n2.types.identifier("value"), [], n2.types.blockStatement(h2)))) : f2.push(a2("value", d2.buildUndefinedNode()));
      var h2;
      return o4.remove(), n2.types.objectExpression(f2);
    }(o3, u.id, y, e4))), v = n2.template.expression.ast`
    ${function(e4) {
      return e4.addHelper("decorate");
    }(o3)}(
      ${g || n2.types.nullLiteral()},
      function (${d}, ${m ? n2.types.cloneNode(y) : null}) {
        ${u}
        return { F: ${n2.types.cloneNode(u.id)}, d: ${b} };
      },
      ${m}
    )
  `;
    h || v.arguments[1].body.directives.push(n2.types.directive(n2.types.directiveLiteral("use strict")));
    let E = v, S = "arguments.1.body.body.0";
    return f && (E = n2.template.statement.ast`let ${e3} = ${v}`, S = "declarations.0.init." + S), { instanceNodes: [n2.template.statement.ast`
        ${n2.types.cloneNode(d)}(this)
      `], wrapClass: (e4) => (e4.replaceWith(E), e4.get(S)) };
  }, t2.hasDecorators = function(e3) {
    return o2(e3) || e3.body.body.some(o2);
  }, t2.hasOwnDecorators = o2;
  var n2 = r2(1), s2 = r2(141), i2 = r2(119);
  function o2(e3) {
    var t3;
    return !(null == (t3 = e3.decorators) || !t3.length);
  }
  function a2(e3, t3) {
    return t3 ? n2.types.objectProperty(n2.types.identifier(e3), t3) : null;
  }
  function l(e3) {
    let t3;
    return e3.decorators && e3.decorators.length > 0 && (t3 = n2.types.arrayExpression(e3.decorators.map((e4) => e4.expression))), e3.decorators = void 0, t3;
  }
  function c(e3) {
    return e3.computed ? e3.key : n2.types.isIdentifier(e3.key) ? n2.types.stringLiteral(e3.key.name) : n2.types.stringLiteral(String(e3.key.value));
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const { node: r3, parentPath: n3 } = e3;
    if (r3.declare) return void e3.remove();
    const s3 = r3.id.name, { fill: l2, data: c2, isPure: p2 } = function(e4, t4, r4) {
      const { enumValues: n4, data: s4, isPure: i3 } = f(e4, t4), o3 = n4.map((e5) => {
        let [n5, s5] = e5;
        return u(t4.isStringLiteral(s5), { ENUM: t4.cloneNode(r4), NAME: n5, VALUE: s5 });
      });
      return { fill: { ID: t4.cloneNode(r4), ASSIGNMENTS: o3 }, data: s4, isPure: i3 };
    }(e3, t3, r3.id);
    switch (n3.type) {
      case "BlockStatement":
      case "ExportNamedDeclaration":
      case "Program": {
        const u2 = t3.isProgram(e3.parent), d2 = function e4(t4) {
          return t4.isExportDeclaration() ? e4(t4.parentPath) : !!t4.getData(s3) || (t4.setData(s3, true), false);
        }(n3);
        let f2 = t3.objectExpression([]);
        (d2 || u2) && (f2 = t3.logicalExpression("||", t3.cloneNode(l2.ID), f2));
        const h2 = a2(Object.assign({}, l2, { INIT: f2 }));
        p2 && (0, i2.default)(h2), d2 ? (n3.isExportDeclaration() ? n3 : e3).replaceWith(t3.expressionStatement(t3.assignmentExpression("=", t3.cloneNode(r3.id), h2))) : e3.scope.registerDeclaration(e3.replaceWith(t3.variableDeclaration(u2 ? "var" : "let", [t3.variableDeclarator(r3.id, h2)]))[0]), o2.set(e3.scope.getBindingIdentifier(s3), c2);
        break;
      }
      default:
        throw new Error(`Unexpected enum parent '${e3.parent.type}`);
    }
  }, t2.translateEnumValues = f;
  var n2 = r2(1), s2 = r2(25), i2 = r2(302);
  const o2 = /* @__PURE__ */ new WeakMap(), a2 = n2.template.expression("\n    (function (ID) {\n      ASSIGNMENTS;\n      return ID;\n    })(INIT)\n  "), l = (0, n2.template)('\n  ENUM["NAME"] = VALUE;\n'), c = (0, n2.template)('\n  ENUM[ENUM["NAME"] = VALUE] = "NAME";\n'), u = (e3, t3) => (e3 ? l : c)(t3);
  function p(e3, t3) {
    const { seen: r3, path: n3, t: s3 } = t3, i3 = e3.node.name;
    r3.has(i3) && !e3.scope.hasOwnBinding(i3) && (e3.replaceWith(s3.memberExpression(s3.cloneNode(n3.node.id), s3.cloneNode(e3.node))), e3.skip());
  }
  const d = { ReferencedIdentifier: p };
  function f(e3, t3) {
    var r3;
    const n3 = e3.scope.getBindingIdentifier(e3.node.id.name), i3 = null != (r3 = o2.get(n3)) ? r3 : /* @__PURE__ */ new Map();
    let a3, l2 = -1, c2 = true;
    const u2 = e3.get("members").map((r4) => {
      const n4 = r4.node, o3 = t3.isIdentifier(n4.id) ? n4.id.name : n4.id.value, u3 = r4.get("initializer");
      let f2;
      if (n4.initializer) l2 = h(u3, i3), void 0 !== l2 ? (i3.set(o3, l2), s2("number" == typeof l2 || "string" == typeof l2), f2 = l2 === 1 / 0 || Number.isNaN(l2) ? t3.identifier(String(l2)) : l2 === -1 / 0 ? t3.unaryExpression("-", t3.identifier("Infinity")) : t3.valueToNode(l2)) : (c2 && (c2 = u3.isPure()), u3.isReferencedIdentifier() ? p(u3, { t: t3, seen: i3, path: e3 }) : u3.traverse(d, { t: t3, seen: i3, path: e3 }), f2 = u3.node, i3.set(o3, void 0));
      else if ("number" == typeof l2) l2 += 1, f2 = t3.numericLiteral(l2), i3.set(o3, l2);
      else {
        if ("string" == typeof l2) throw e3.buildCodeFrameError("Enum member must have initializer.");
        {
          const r5 = t3.memberExpression(t3.cloneNode(e3.node.id), t3.stringLiteral(a3), true);
          f2 = t3.binaryExpression("+", t3.numericLiteral(1), r5), i3.set(o3, void 0);
        }
      }
      return a3 = o3, [o3, f2];
    });
    return { isPure: c2, data: i3, enumValues: u2 };
  }
  function h(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : /* @__PURE__ */ new Set();
    return function e4(n3) {
      const i3 = n3.node;
      switch (i3.type) {
        case "MemberExpression":
        case "Identifier":
          return s3(n3, t3, r3);
        case "StringLiteral":
        case "NumericLiteral":
          return i3.value;
        case "UnaryExpression":
          return function(t4) {
            const r4 = e4(t4.get("argument"));
            if (void 0 !== r4) switch (t4.node.operator) {
              case "+":
                return r4;
              case "-":
                return -r4;
              case "~":
                return ~r4;
              default:
                return;
            }
          }(n3);
        case "BinaryExpression":
          return function(t4) {
            const r4 = e4(t4.get("left"));
            if (void 0 === r4) return;
            const n4 = e4(t4.get("right"));
            if (void 0 !== n4) switch (t4.node.operator) {
              case "|":
                return r4 | n4;
              case "&":
                return r4 & n4;
              case ">>":
                return r4 >> n4;
              case ">>>":
                return r4 >>> n4;
              case "<<":
                return r4 << n4;
              case "^":
                return r4 ^ n4;
              case "*":
                return r4 * n4;
              case "/":
                return r4 / n4;
              case "+":
                return r4 + n4;
              case "-":
                return r4 - n4;
              case "%":
                return r4 % n4;
              case "**":
                return Math.pow(r4, n4);
              default:
                return;
            }
          }(n3);
        case "ParenthesizedExpression":
          return e4(n3.get("expression"));
        case "TemplateLiteral": {
          if (1 === i3.quasis.length) return i3.quasis[0].value.cooked;
          const e5 = n3.get("expressions"), o3 = i3.quasis;
          let a3 = "";
          for (let n4 = 0; n4 < o3.length; n4++) if (a3 += o3[n4].value.cooked, n4 + 1 < o3.length) {
            const i4 = s3(e5[n4], t3, r3);
            if (void 0 === i4) return;
            a3 += i4;
          }
          return a3;
        }
        default:
          return;
      }
    }(e3);
    function s3(e4, t4, r4) {
      if (e4.isMemberExpression()) {
        const t5 = e4.node, r5 = t5.object, s4 = t5.property;
        if (!n2.types.isIdentifier(r5) || (t5.computed ? !n2.types.isStringLiteral(s4) : !n2.types.isIdentifier(s4))) return;
        const i3 = e4.scope.getBindingIdentifier(r5.name), a3 = o2.get(i3);
        if (!a3) return;
        return a3.get(s4.computed ? s4.value : s4.name);
      }
      if (e4.isIdentifier()) {
        const n3 = e4.node.name;
        if (["Infinity", "NaN"].includes(n3)) return Number(n3);
        let s4 = null == t4 ? void 0 : t4.get(n3);
        if (void 0 !== s4) return s4;
        if (r4.has(e4.node)) return;
        return r4.add(e4.node), s4 = h(e4.resolve(), t4, r4), null == t4 || t4.set(n3, s4), s4;
      }
    }
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.GLOBAL_TYPES = void 0, t2.isGlobalType = function(e3, t3) {
    let { scope: n2 } = e3;
    return !n2.hasBinding(t3) && !!r2.get(n2).has(t3);
  }, t2.registerGlobalType = function(e3, t3) {
    r2.get(e3).add(t3);
  };
  const r2 = t2.GLOBAL_TYPES = /* @__PURE__ */ new WeakMap();
}, (e2, t2, r2) => {
  r2(12), e2.exports = function(e3) {
    var t3 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function r3(e4, t4) {
      var r4 = e4[0], n3 = e4[1], s3 = e4[2], i3 = e4[3];
      n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & s3 | ~n3 & i3) + t4[0] - 680876936 | 0) << 7 | r4 >>> 25) + n3 | 0) & n3 | ~r4 & s3) + t4[1] - 389564586 | 0) << 12 | i3 >>> 20) + r4 | 0) & r4 | ~i3 & n3) + t4[2] + 606105819 | 0) << 17 | s3 >>> 15) + i3 | 0) & i3 | ~s3 & r4) + t4[3] - 1044525330 | 0) << 22 | n3 >>> 10) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & s3 | ~n3 & i3) + t4[4] - 176418897 | 0) << 7 | r4 >>> 25) + n3 | 0) & n3 | ~r4 & s3) + t4[5] + 1200080426 | 0) << 12 | i3 >>> 20) + r4 | 0) & r4 | ~i3 & n3) + t4[6] - 1473231341 | 0) << 17 | s3 >>> 15) + i3 | 0) & i3 | ~s3 & r4) + t4[7] - 45705983 | 0) << 22 | n3 >>> 10) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & s3 | ~n3 & i3) + t4[8] + 1770035416 | 0) << 7 | r4 >>> 25) + n3 | 0) & n3 | ~r4 & s3) + t4[9] - 1958414417 | 0) << 12 | i3 >>> 20) + r4 | 0) & r4 | ~i3 & n3) + t4[10] - 42063 | 0) << 17 | s3 >>> 15) + i3 | 0) & i3 | ~s3 & r4) + t4[11] - 1990404162 | 0) << 22 | n3 >>> 10) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & s3 | ~n3 & i3) + t4[12] + 1804603682 | 0) << 7 | r4 >>> 25) + n3 | 0) & n3 | ~r4 & s3) + t4[13] - 40341101 | 0) << 12 | i3 >>> 20) + r4 | 0) & r4 | ~i3 & n3) + t4[14] - 1502002290 | 0) << 17 | s3 >>> 15) + i3 | 0) & i3 | ~s3 & r4) + t4[15] + 1236535329 | 0) << 22 | n3 >>> 10) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & i3 | s3 & ~i3) + t4[1] - 165796510 | 0) << 5 | r4 >>> 27) + n3 | 0) & s3 | n3 & ~s3) + t4[6] - 1069501632 | 0) << 9 | i3 >>> 23) + r4 | 0) & n3 | r4 & ~n3) + t4[11] + 643717713 | 0) << 14 | s3 >>> 18) + i3 | 0) & r4 | i3 & ~r4) + t4[0] - 373897302 | 0) << 20 | n3 >>> 12) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & i3 | s3 & ~i3) + t4[5] - 701558691 | 0) << 5 | r4 >>> 27) + n3 | 0) & s3 | n3 & ~s3) + t4[10] + 38016083 | 0) << 9 | i3 >>> 23) + r4 | 0) & n3 | r4 & ~n3) + t4[15] - 660478335 | 0) << 14 | s3 >>> 18) + i3 | 0) & r4 | i3 & ~r4) + t4[4] - 405537848 | 0) << 20 | n3 >>> 12) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & i3 | s3 & ~i3) + t4[9] + 568446438 | 0) << 5 | r4 >>> 27) + n3 | 0) & s3 | n3 & ~s3) + t4[14] - 1019803690 | 0) << 9 | i3 >>> 23) + r4 | 0) & n3 | r4 & ~n3) + t4[3] - 187363961 | 0) << 14 | s3 >>> 18) + i3 | 0) & r4 | i3 & ~r4) + t4[8] + 1163531501 | 0) << 20 | n3 >>> 12) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & i3 | s3 & ~i3) + t4[13] - 1444681467 | 0) << 5 | r4 >>> 27) + n3 | 0) & s3 | n3 & ~s3) + t4[2] - 51403784 | 0) << 9 | i3 >>> 23) + r4 | 0) & n3 | r4 & ~n3) + t4[7] + 1735328473 | 0) << 14 | s3 >>> 18) + i3 | 0) & r4 | i3 & ~r4) + t4[12] - 1926607734 | 0) << 20 | n3 >>> 12) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 ^ s3 ^ i3) + t4[5] - 378558 | 0) << 4 | r4 >>> 28) + n3 | 0) ^ n3 ^ s3) + t4[8] - 2022574463 | 0) << 11 | i3 >>> 21) + r4 | 0) ^ r4 ^ n3) + t4[11] + 1839030562 | 0) << 16 | s3 >>> 16) + i3 | 0) ^ i3 ^ r4) + t4[14] - 35309556 | 0) << 23 | n3 >>> 9) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 ^ s3 ^ i3) + t4[1] - 1530992060 | 0) << 4 | r4 >>> 28) + n3 | 0) ^ n3 ^ s3) + t4[4] + 1272893353 | 0) << 11 | i3 >>> 21) + r4 | 0) ^ r4 ^ n3) + t4[7] - 155497632 | 0) << 16 | s3 >>> 16) + i3 | 0) ^ i3 ^ r4) + t4[10] - 1094730640 | 0) << 23 | n3 >>> 9) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 ^ s3 ^ i3) + t4[13] + 681279174 | 0) << 4 | r4 >>> 28) + n3 | 0) ^ n3 ^ s3) + t4[0] - 358537222 | 0) << 11 | i3 >>> 21) + r4 | 0) ^ r4 ^ n3) + t4[3] - 722521979 | 0) << 16 | s3 >>> 16) + i3 | 0) ^ i3 ^ r4) + t4[6] + 76029189 | 0) << 23 | n3 >>> 9) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 ^ s3 ^ i3) + t4[9] - 640364487 | 0) << 4 | r4 >>> 28) + n3 | 0) ^ n3 ^ s3) + t4[12] - 421815835 | 0) << 11 | i3 >>> 21) + r4 | 0) ^ r4 ^ n3) + t4[15] + 530742520 | 0) << 16 | s3 >>> 16) + i3 | 0) ^ i3 ^ r4) + t4[2] - 995338651 | 0) << 23 | n3 >>> 9) + s3 | 0, n3 = ((n3 += ((i3 = ((i3 += (n3 ^ ((r4 = ((r4 += (s3 ^ (n3 | ~i3)) + t4[0] - 198630844 | 0) << 6 | r4 >>> 26) + n3 | 0) | ~s3)) + t4[7] + 1126891415 | 0) << 10 | i3 >>> 22) + r4 | 0) ^ ((s3 = ((s3 += (r4 ^ (i3 | ~n3)) + t4[14] - 1416354905 | 0) << 15 | s3 >>> 17) + i3 | 0) | ~r4)) + t4[5] - 57434055 | 0) << 21 | n3 >>> 11) + s3 | 0, n3 = ((n3 += ((i3 = ((i3 += (n3 ^ ((r4 = ((r4 += (s3 ^ (n3 | ~i3)) + t4[12] + 1700485571 | 0) << 6 | r4 >>> 26) + n3 | 0) | ~s3)) + t4[3] - 1894986606 | 0) << 10 | i3 >>> 22) + r4 | 0) ^ ((s3 = ((s3 += (r4 ^ (i3 | ~n3)) + t4[10] - 1051523 | 0) << 15 | s3 >>> 17) + i3 | 0) | ~r4)) + t4[1] - 2054922799 | 0) << 21 | n3 >>> 11) + s3 | 0, n3 = ((n3 += ((i3 = ((i3 += (n3 ^ ((r4 = ((r4 += (s3 ^ (n3 | ~i3)) + t4[8] + 1873313359 | 0) << 6 | r4 >>> 26) + n3 | 0) | ~s3)) + t4[15] - 30611744 | 0) << 10 | i3 >>> 22) + r4 | 0) ^ ((s3 = ((s3 += (r4 ^ (i3 | ~n3)) + t4[6] - 1560198380 | 0) << 15 | s3 >>> 17) + i3 | 0) | ~r4)) + t4[13] + 1309151649 | 0) << 21 | n3 >>> 11) + s3 | 0, n3 = ((n3 += ((i3 = ((i3 += (n3 ^ ((r4 = ((r4 += (s3 ^ (n3 | ~i3)) + t4[4] - 145523070 | 0) << 6 | r4 >>> 26) + n3 | 0) | ~s3)) + t4[11] - 1120210379 | 0) << 10 | i3 >>> 22) + r4 | 0) ^ ((s3 = ((s3 += (r4 ^ (i3 | ~n3)) + t4[2] + 718787259 | 0) << 15 | s3 >>> 17) + i3 | 0) | ~r4)) + t4[9] - 343485551 | 0) << 21 | n3 >>> 11) + s3 | 0, e4[0] = r4 + e4[0] | 0, e4[1] = n3 + e4[1] | 0, e4[2] = s3 + e4[2] | 0, e4[3] = i3 + e4[3] | 0;
    }
    function n2(e4) {
      var t4, r4 = [];
      for (t4 = 0; t4 < 64; t4 += 4) r4[t4 >> 2] = e4.charCodeAt(t4) + (e4.charCodeAt(t4 + 1) << 8) + (e4.charCodeAt(t4 + 2) << 16) + (e4.charCodeAt(t4 + 3) << 24);
      return r4;
    }
    function s2(e4) {
      var t4, r4 = [];
      for (t4 = 0; t4 < 64; t4 += 4) r4[t4 >> 2] = e4[t4] + (e4[t4 + 1] << 8) + (e4[t4 + 2] << 16) + (e4[t4 + 3] << 24);
      return r4;
    }
    function i2(e4) {
      var t4, s3, i3, o3, a3, l2, c2 = e4.length, u2 = [1732584193, -271733879, -1732584194, 271733878];
      for (t4 = 64; t4 <= c2; t4 += 64) r3(u2, n2(e4.substring(t4 - 64, t4)));
      for (s3 = (e4 = e4.substring(t4 - 64)).length, i3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], t4 = 0; t4 < s3; t4 += 1) i3[t4 >> 2] |= e4.charCodeAt(t4) << (t4 % 4 << 3);
      if (i3[t4 >> 2] |= 128 << (t4 % 4 << 3), t4 > 55) for (r3(u2, i3), t4 = 0; t4 < 16; t4 += 1) i3[t4] = 0;
      return o3 = (o3 = 8 * c2).toString(16).match(/(.*?)(.{0,8})$/), a3 = parseInt(o3[2], 16), l2 = parseInt(o3[1], 16) || 0, i3[14] = a3, i3[15] = l2, r3(u2, i3), u2;
    }
    function o2(e4) {
      var r4, n3 = "";
      for (r4 = 0; r4 < 4; r4 += 1) n3 += t3[e4 >> 8 * r4 + 4 & 15] + t3[e4 >> 8 * r4 & 15];
      return n3;
    }
    function a2(e4) {
      var t4;
      for (t4 = 0; t4 < e4.length; t4 += 1) e4[t4] = o2(e4[t4]);
      return e4.join("");
    }
    function l(e4) {
      return /[\u0080-\uFFFF]/.test(e4) && (e4 = unescape(encodeURIComponent(e4))), e4;
    }
    function c(e4) {
      var t4, r4 = [], n3 = e4.length;
      for (t4 = 0; t4 < n3 - 1; t4 += 2) r4.push(parseInt(e4.substr(t4, 2), 16));
      return String.fromCharCode.apply(String, r4);
    }
    function u() {
      this.reset();
    }
    return a2(i2("hello")), "undefined" == typeof ArrayBuffer || ArrayBuffer.prototype.slice || function() {
      function e4(e5, t4) {
        return (e5 = 0 | e5 || 0) < 0 ? Math.max(e5 + t4, 0) : Math.min(e5, t4);
      }
      ArrayBuffer.prototype.slice = function(t4, r4) {
        var n3, s3, i3, o3, a3 = this.byteLength, l2 = e4(t4, a3), c2 = a3;
        return void 0 !== r4 && (c2 = e4(r4, a3)), l2 > c2 ? new ArrayBuffer(0) : (n3 = c2 - l2, s3 = new ArrayBuffer(n3), i3 = new Uint8Array(s3), o3 = new Uint8Array(this, l2, n3), i3.set(o3), s3);
      };
    }(), u.prototype.append = function(e4) {
      return this.appendBinary(l(e4)), this;
    }, u.prototype.appendBinary = function(e4) {
      this._buff += e4, this._length += e4.length;
      var t4, s3 = this._buff.length;
      for (t4 = 64; t4 <= s3; t4 += 64) r3(this._hash, n2(this._buff.substring(t4 - 64, t4)));
      return this._buff = this._buff.substring(t4 - 64), this;
    }, u.prototype.end = function(e4) {
      var t4, r4, n3 = this._buff, s3 = n3.length, i3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (t4 = 0; t4 < s3; t4 += 1) i3[t4 >> 2] |= n3.charCodeAt(t4) << (t4 % 4 << 3);
      return this._finish(i3, s3), r4 = a2(this._hash), e4 && (r4 = c(r4)), this.reset(), r4;
    }, u.prototype.reset = function() {
      return this._buff = "", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, u.prototype.getState = function() {
      return { buff: this._buff, length: this._length, hash: this._hash.slice() };
    }, u.prototype.setState = function(e4) {
      return this._buff = e4.buff, this._length = e4.length, this._hash = e4.hash, this;
    }, u.prototype.destroy = function() {
      delete this._hash, delete this._buff, delete this._length;
    }, u.prototype._finish = function(e4, t4) {
      var n3, s3, i3, o3 = t4;
      if (e4[o3 >> 2] |= 128 << (o3 % 4 << 3), o3 > 55) for (r3(this._hash, e4), o3 = 0; o3 < 16; o3 += 1) e4[o3] = 0;
      n3 = (n3 = 8 * this._length).toString(16).match(/(.*?)(.{0,8})$/), s3 = parseInt(n3[2], 16), i3 = parseInt(n3[1], 16) || 0, e4[14] = s3, e4[15] = i3, r3(this._hash, e4);
    }, u.hash = function(e4, t4) {
      return u.hashBinary(l(e4), t4);
    }, u.hashBinary = function(e4, t4) {
      var r4 = a2(i2(e4));
      return t4 ? c(r4) : r4;
    }, u.ArrayBuffer = function() {
      this.reset();
    }, u.ArrayBuffer.prototype.append = function(e4) {
      var t4, n3, i3, o3, a3, l2 = (n3 = this._buff.buffer, i3 = e4, o3 = true, (a3 = new Uint8Array(n3.byteLength + i3.byteLength)).set(new Uint8Array(n3)), a3.set(new Uint8Array(i3), n3.byteLength), o3 ? a3 : a3.buffer), c2 = l2.length;
      for (this._length += e4.byteLength, t4 = 64; t4 <= c2; t4 += 64) r3(this._hash, s2(l2.subarray(t4 - 64, t4)));
      return this._buff = t4 - 64 < c2 ? new Uint8Array(l2.buffer.slice(t4 - 64)) : new Uint8Array(0), this;
    }, u.ArrayBuffer.prototype.end = function(e4) {
      var t4, r4, n3 = this._buff, s3 = n3.length, i3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (t4 = 0; t4 < s3; t4 += 1) i3[t4 >> 2] |= n3[t4] << (t4 % 4 << 3);
      return this._finish(i3, s3), r4 = a2(this._hash), e4 && (r4 = c(r4)), this.reset(), r4;
    }, u.ArrayBuffer.prototype.reset = function() {
      return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, u.ArrayBuffer.prototype.getState = function() {
      var e4, t4 = u.prototype.getState.call(this);
      return t4.buff = (e4 = t4.buff, String.fromCharCode.apply(null, new Uint8Array(e4))), t4;
    }, u.ArrayBuffer.prototype.setState = function(e4) {
      return e4.buff = function(e5, t4) {
        var r4, n3 = e5.length, s3 = new ArrayBuffer(n3), i3 = new Uint8Array(s3);
        for (r4 = 0; r4 < n3; r4 += 1) i3[r4] = e5.charCodeAt(r4);
        return t4 ? i3 : s3;
      }(e4.buff, true), u.prototype.setState.call(this, e4);
    }, u.ArrayBuffer.prototype.destroy = u.prototype.destroy, u.ArrayBuffer.prototype._finish = u.prototype._finish, u.ArrayBuffer.hash = function(e4, t4) {
      var n3 = a2(function(e5) {
        var t5, n4, i3, o3, a3, l2, c2 = e5.length, u2 = [1732584193, -271733879, -1732584194, 271733878];
        for (t5 = 64; t5 <= c2; t5 += 64) r3(u2, s2(e5.subarray(t5 - 64, t5)));
        for (n4 = (e5 = t5 - 64 < c2 ? e5.subarray(t5 - 64) : new Uint8Array(0)).length, i3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], t5 = 0; t5 < n4; t5 += 1) i3[t5 >> 2] |= e5[t5] << (t5 % 4 << 3);
        if (i3[t5 >> 2] |= 128 << (t5 % 4 << 3), t5 > 55) for (r3(u2, i3), t5 = 0; t5 < 16; t5 += 1) i3[t5] = 0;
        return o3 = (o3 = 8 * c2).toString(16).match(/(.*?)(.{0,8})$/), a3 = parseInt(o3[2], 16), l2 = parseInt(o3[1], 16) || 0, i3[14] = a3, i3[15] = l2, r3(u2, i3), u2;
      }(new Uint8Array(e4)));
      return t4 ? c(n3) : n3;
    }, u;
  }();
}, (e2, t2, r2) => {
  var _a2, _e2, _t2, _r2, _n2, _s2, _i2, _o2, _a3, _l2, _c2, _u, _p, _d, _f, _h, _m, _y, _g, _b, _v, _E, _S, _x, _pe_instances, __fn, _N, _D, _k, _O, I_fn, _j, _M, _L, A_fn, C_fn, R_fn, B_fn, w_fn, T_fn, F_fn, P_fn, _U, _$, _V, _q, _W, _G, _H, _z, _K, _X, _J, _el_instances, Y_fn, _el_static, Q_fn, ee_fn, Z_fn;
  var n2 = r2(17), s2 = r2(31).a;
  r2(44), r2(12), Object.defineProperty(t2, "__esModule", { value: true });
  var i2 = r2(309), o2 = r2(328), a2 = r2(507), l = r2(10), c = r2(142), u = r2(508), p = r2(510), d = r2(32), f = r2(511), h = r2(315), m = r2(94), y = r2(325), g = r2(21), b = r2(17);
  function v(e3) {
    var t3 = /* @__PURE__ */ Object.create(null);
    if (e3) for (var r3 in e3) t3[r3] = e3[r3];
    return t3.default = e3, Object.freeze(t3);
  }
  var E = v(o2), S = v(p), x = v(b);
  const T = "Unknown";
  function w(e3, t3) {
    switch (e3.type) {
      case "StringLiteral":
      case "NumericLiteral":
        return String(e3.value);
      case "Identifier":
        if (!t3) return e3.name;
    }
  }
  function P(e3) {
    return e3.filter((e4) => !!e4).join(", ");
  }
  function A(e3) {
    return e3.type.endsWith("Literal");
  }
  function C(e3, t3) {
    return !!(e3 && t3 && "CallExpression" === e3.type && "Identifier" === e3.callee.type && ("string" == typeof t3 ? e3.callee.name === t3 : t3(e3.callee.name)));
  }
  function O(e3) {
    return e3.length > 1 ? `[${e3.join(", ")}]` : e3[0];
  }
  function I(e3) {
    return "ImportSpecifier" === e3.type ? "Identifier" === e3.imported.type ? e3.imported.name : e3.imported.value : "ImportNamespaceSpecifier" === e3.type ? "*" : "default";
  }
  function _(e3) {
    return "Identifier" === e3.type ? e3.name : "StringLiteral" === e3.type ? e3.value : null;
  }
  const k = (e3) => e3, N = /[^\u0130\u0131\u00DFa-z0-9\\/:\-_\. ]+/g, D = (e3) => e3.toLowerCase();
  function j(e3) {
    return N.test(e3) ? e3.replace(N, D) : e3;
  }
  const L = (l.posix || l).normalize, M = /\\/g;
  function B(e3) {
    return L(e3.replace(M, "/"));
  }
  const R = (l.posix || l).join, F = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~\-]/;
  function U(e3) {
    return F.test(e3) ? JSON.stringify(e3) : e3;
  }
  const $ = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
  var V = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== r2.g ? r2.g : "undefined" != typeof self ? self : {};
  function q(e3) {
    return e3 && e3.__esModule && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
  }
  function W(e3, t3) {
    var r3, n3;
    if (0 === t3.length) return e3;
    for (r3 = 0, n3 = t3.length; r3 < n3; r3++) e3 = (e3 << 5) - e3 + t3.charCodeAt(r3), e3 |= 0;
    return e3 < 0 ? -2 * e3 : e3;
  }
  function G(e3, t3, r3, n3) {
    var s3, i3 = W(W(W(e3, r3), (s3 = t3, Object.prototype.toString.call(s3))), typeof t3);
    if (null === t3) return W(i3, "null");
    if (void 0 === t3) return W(i3, "undefined");
    if ("object" == typeof t3 || "function" == typeof t3) {
      if (-1 !== n3.indexOf(t3)) return W(i3, "[Circular]" + r3);
      n3.push(t3);
      var o3 = function(e4, t4, r4) {
        return Object.keys(t4).sort().reduce(function(e5, n4) {
          return G(e5, t4[n4], n4, r4);
        }, e4);
      }(i3, t3, n3);
      if (!("valueOf" in t3) || "function" != typeof t3.valueOf) return o3;
      try {
        return W(o3, String(t3.valueOf()));
      } catch (e4) {
        return W(o3, "[valueOf exception]" + (e4.stack || e4.message));
      }
    }
    return W(i3, t3.toString());
  }
  var H = q(function(e3) {
    return function(e4, t3) {
      for (; e4.length < 8; ) e4 = "0" + e4;
      return e4;
    }(G(0, e3, "", []).toString(16));
  });
  const z = "useCssVars";
  function K(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    return `{
  ${e3.map((e4) => `"${n3 ? "--" : ""}${X(t3, e4, r3, n3)}": (${e4})`).join(",\n  ")}
}`;
  }
  function X(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    return r3 ? H(e3 + t3) : `${e3}-${s3 = t3, i3 = n3, s3.replace($, (e4) => i3 ? `\\\\${e4}` : `\\${e4}`)}`;
    var s3, i3;
  }
  function J(e3) {
    return "'" === (e3 = e3.trim())[0] && "'" === e3[e3.length - 1] || '"' === e3[0] && '"' === e3[e3.length - 1] ? e3.slice(1, -1) : e3;
  }
  const Y = /v-bind\s*\(/g;
  function Q(e3, t3) {
    let r3 = 0, n3 = 0;
    for (let s3 = t3; s3 < e3.length; s3++) {
      const t4 = e3.charAt(s3);
      switch (r3) {
        case 0:
          if ("'" === t4) r3 = 1;
          else if ('"' === t4) r3 = 2;
          else if ("(" === t4) n3++;
          else if (")" === t4) {
            if (!(n3 > 0)) return s3;
            n3--;
          }
          break;
        case 1:
          "'" === t4 && (r3 = 0);
          break;
        case 2:
          '"' === t4 && (r3 = 0);
      }
    }
    return null;
  }
  const Z = (e3) => {
    const { id: t3, isProd: r3 } = e3;
    return { postcssPlugin: "vue-sfc-vars", Declaration(e4) {
      const n3 = e4.value;
      if (Y.test(n3)) {
        Y.lastIndex = 0;
        let s3, i3 = "", o3 = 0;
        for (; s3 = Y.exec(n3); ) {
          const e5 = s3.index + s3[0].length, a3 = Q(n3, e5);
          if (null !== a3) {
            const l2 = J(n3.slice(e5, a3));
            i3 += n3.slice(o3, s3.index) + `var(--${X(t3, l2, r3)})`, o3 = a3 + 1;
          }
        }
        e4.value = i3 + n3.slice(o3);
      }
    } };
  };
  function ee(e3, t3, r3, n3) {
    const s3 = K(e3, r3, n3), i3 = o2.createSimpleExpression(s3, false), a3 = o2.createTransformContext(o2.createRoot([]), { prefixIdentifiers: true, inline: true, bindingMetadata: false === t3.__isScriptSetup ? void 0 : t3 }), l2 = o2.processExpression(i3, a3), c2 = 4 === l2.type ? l2.content : l2.children.map((e4) => "string" == typeof e4 ? e4 : e4.content).join("");
    return `_${z}(_ctx => (${c2}))`;
  }
  Z.postcss = true;
  const te = "object" == typeof performance && performance && "function" == typeof performance.now ? performance : Date, re = /* @__PURE__ */ new Set(), ne = "object" == typeof n2 && n2 ? n2 : {}, se = (e3, t3, r3, n3) => {
    "function" == typeof ne.emitWarning && ne.emitWarning(e3, t3, r3, n3);
  };
  let ie = globalThis.AbortController, oe = globalThis.AbortSignal;
  if (void 0 === ie) {
    oe = class {
      constructor() {
        __publicField(this, "onabort");
        __publicField(this, "_onabort", []);
        __publicField(this, "reason");
        __publicField(this, "aborted", false);
      }
      addEventListener(e4, t4) {
        this._onabort.push(t4);
      }
    }, ie = class {
      constructor() {
        __publicField(this, "signal", new oe());
        t3();
      }
      abort(e4) {
        var _a4, _b2;
        if (!this.signal.aborted) {
          this.signal.reason = e4, this.signal.aborted = true;
          for (const t4 of this.signal._onabort) t4(e4);
          (_b2 = (_a4 = this.signal).onabort) == null ? void 0 : _b2.call(_a4, e4);
        }
      }
    };
    let e3 = "1" !== ((_a2 = ne.env) == null ? void 0 : _a2.LRU_CACHE_IGNORE_AC_WARNING);
    const t3 = () => {
      e3 && (e3 = false, se("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", t3));
    };
  }
  const ae = (e3) => e3 && e3 === Math.floor(e3) && e3 > 0 && isFinite(e3), le = (e3) => ae(e3) ? e3 <= Math.pow(2, 8) ? Uint8Array : e3 <= Math.pow(2, 16) ? Uint16Array : e3 <= Math.pow(2, 32) ? Uint32Array : e3 <= Number.MAX_SAFE_INTEGER ? ce : null : null;
  class ce extends Array {
    constructor(e3) {
      super(e3), this.fill(0);
    }
  }
  const _ue = class _ue {
    constructor(e3, t3) {
      __publicField(this, "heap");
      __publicField(this, "length");
      if (!__privateGet(_ue, _e2)) throw new TypeError("instantiate Stack using Stack.create(n)");
      this.heap = new t3(e3), this.length = 0;
    }
    static create(e3) {
      const t3 = le(e3);
      if (!t3) return [];
      __privateSet(_ue, _e2, true);
      const r3 = new _ue(e3, t3);
      return __privateSet(_ue, _e2, false), r3;
    }
    push(e3) {
      this.heap[this.length++] = e3;
    }
    pop() {
      return this.heap[--this.length];
    }
  };
  _e2 = new WeakMap();
  __privateAdd(_ue, _e2, false);
  let ue = _ue;
  const _pe = class _pe {
    constructor(e3) {
      __privateAdd(this, _pe_instances);
      __privateAdd(this, _t2);
      __privateAdd(this, _r2);
      __privateAdd(this, _n2);
      __privateAdd(this, _s2);
      __privateAdd(this, _i2);
      __publicField(this, "ttl");
      __publicField(this, "ttlResolution");
      __publicField(this, "ttlAutopurge");
      __publicField(this, "updateAgeOnGet");
      __publicField(this, "updateAgeOnHas");
      __publicField(this, "allowStale");
      __publicField(this, "noDisposeOnSet");
      __publicField(this, "noUpdateTTL");
      __publicField(this, "maxEntrySize");
      __publicField(this, "sizeCalculation");
      __publicField(this, "noDeleteOnFetchRejection");
      __publicField(this, "noDeleteOnStaleGet");
      __publicField(this, "allowStaleOnFetchAbort");
      __publicField(this, "allowStaleOnFetchRejection");
      __publicField(this, "ignoreFetchAbort");
      __privateAdd(this, _o2);
      __privateAdd(this, _a3);
      __privateAdd(this, _l2);
      __privateAdd(this, _c2);
      __privateAdd(this, _u);
      __privateAdd(this, _p);
      __privateAdd(this, _d);
      __privateAdd(this, _f);
      __privateAdd(this, _h);
      __privateAdd(this, _m);
      __privateAdd(this, _y);
      __privateAdd(this, _g);
      __privateAdd(this, _b);
      __privateAdd(this, _v);
      __privateAdd(this, _E);
      __privateAdd(this, _S);
      __privateAdd(this, _x);
      __privateAdd(this, _N, () => {
      });
      __privateAdd(this, _D, () => {
      });
      __privateAdd(this, _k, () => {
      });
      __privateAdd(this, _O, () => false);
      __privateAdd(this, _j, (e3) => {
      });
      __privateAdd(this, _M, (e3, t3, r3) => {
      });
      __privateAdd(this, _L, (e3, t3, r3, n3) => {
        if (r3 || n3) throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        return 0;
      });
      const { max: t3 = 0, ttl: r3, ttlResolution: n3 = 1, ttlAutopurge: s3, updateAgeOnGet: i3, updateAgeOnHas: o3, allowStale: a3, dispose: l2, disposeAfter: c2, noDisposeOnSet: u2, noUpdateTTL: p2, maxSize: d2 = 0, maxEntrySize: f2 = 0, sizeCalculation: h2, fetchMethod: m2, noDeleteOnFetchRejection: y2, noDeleteOnStaleGet: g2, allowStaleOnFetchRejection: b2, allowStaleOnFetchAbort: v2, ignoreFetchAbort: E2 } = e3;
      if (0 !== t3 && !ae(t3)) throw new TypeError("max option must be a nonnegative integer");
      const S2 = t3 ? le(t3) : Array;
      if (!S2) throw new Error("invalid max value: " + t3);
      if (__privateSet(this, _t2, t3), __privateSet(this, _r2, d2), this.maxEntrySize = f2 || __privateGet(this, _r2), this.sizeCalculation = h2, this.sizeCalculation) {
        if (!__privateGet(this, _r2) && !this.maxEntrySize) throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        if ("function" != typeof this.sizeCalculation) throw new TypeError("sizeCalculation set to non-function");
      }
      if (void 0 !== m2 && "function" != typeof m2) throw new TypeError("fetchMethod must be a function if specified");
      if (__privateSet(this, _i2, m2), __privateSet(this, _S, !!m2), __privateSet(this, _l2, /* @__PURE__ */ new Map()), __privateSet(this, _c2, new Array(t3).fill(void 0)), __privateSet(this, _u, new Array(t3).fill(void 0)), __privateSet(this, _p, new S2(t3)), __privateSet(this, _d, new S2(t3)), __privateSet(this, _f, 0), __privateSet(this, _h, 0), __privateSet(this, _m, ue.create(t3)), __privateSet(this, _o2, 0), __privateSet(this, _a3, 0), "function" == typeof l2 && __privateSet(this, _n2, l2), "function" == typeof c2 ? (__privateSet(this, _s2, c2), __privateSet(this, _y, [])) : (__privateSet(this, _s2, void 0), __privateSet(this, _y, void 0)), __privateSet(this, _E, !!__privateGet(this, _n2)), __privateSet(this, _x, !!__privateGet(this, _s2)), this.noDisposeOnSet = !!u2, this.noUpdateTTL = !!p2, this.noDeleteOnFetchRejection = !!y2, this.allowStaleOnFetchRejection = !!b2, this.allowStaleOnFetchAbort = !!v2, this.ignoreFetchAbort = !!E2, 0 !== this.maxEntrySize) {
        if (0 !== __privateGet(this, _r2) && !ae(__privateGet(this, _r2))) throw new TypeError("maxSize must be a positive integer if specified");
        if (!ae(this.maxEntrySize)) throw new TypeError("maxEntrySize must be a positive integer if specified");
        __privateMethod(this, _pe_instances, I_fn).call(this);
      }
      if (this.allowStale = !!a3, this.noDeleteOnStaleGet = !!g2, this.updateAgeOnGet = !!i3, this.updateAgeOnHas = !!o3, this.ttlResolution = ae(n3) || 0 === n3 ? n3 : 1, this.ttlAutopurge = !!s3, this.ttl = r3 || 0, this.ttl) {
        if (!ae(this.ttl)) throw new TypeError("ttl must be a positive integer if specified");
        __privateMethod(this, _pe_instances, __fn).call(this);
      }
      if (0 === __privateGet(this, _t2) && 0 === this.ttl && 0 === __privateGet(this, _r2)) throw new TypeError("At least one of max, maxSize, or ttl is required");
      if (!this.ttlAutopurge && !__privateGet(this, _t2) && !__privateGet(this, _r2)) {
        const e4 = "LRU_CACHE_UNBOUNDED";
        ((e5) => !re.has(e5))(e4) && (re.add(e4), se("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", e4, _pe));
      }
    }
    static unsafeExposeInternals(e3) {
      return { starts: __privateGet(e3, _b), ttls: __privateGet(e3, _v), sizes: __privateGet(e3, _g), keyMap: __privateGet(e3, _l2), keyList: __privateGet(e3, _c2), valList: __privateGet(e3, _u), next: __privateGet(e3, _p), prev: __privateGet(e3, _d), get head() {
        return __privateGet(e3, _f);
      }, get tail() {
        return __privateGet(e3, _h);
      }, free: __privateGet(e3, _m), isBackgroundFetch: (t3) => {
        var _a4;
        return __privateMethod(_a4 = e3, _pe_instances, T_fn).call(_a4, t3);
      }, backgroundFetch: (t3, r3, n3, s3) => {
        var _a4;
        return __privateMethod(_a4 = e3, _pe_instances, w_fn).call(_a4, t3, r3, n3, s3);
      }, moveToTail: (t3) => {
        var _a4;
        return __privateMethod(_a4 = e3, _pe_instances, P_fn).call(_a4, t3);
      }, indexes: (t3) => {
        var _a4;
        return __privateMethod(_a4 = e3, _pe_instances, A_fn).call(_a4, t3);
      }, rindexes: (t3) => {
        var _a4;
        return __privateMethod(_a4 = e3, _pe_instances, C_fn).call(_a4, t3);
      }, isStale: (t3) => {
        var _a4;
        return __privateGet(_a4 = e3, _O).call(_a4, t3);
      } };
    }
    get max() {
      return __privateGet(this, _t2);
    }
    get maxSize() {
      return __privateGet(this, _r2);
    }
    get calculatedSize() {
      return __privateGet(this, _a3);
    }
    get size() {
      return __privateGet(this, _o2);
    }
    get fetchMethod() {
      return __privateGet(this, _i2);
    }
    get dispose() {
      return __privateGet(this, _n2);
    }
    get disposeAfter() {
      return __privateGet(this, _s2);
    }
    getRemainingTTL(e3) {
      return __privateGet(this, _l2).has(e3) ? 1 / 0 : 0;
    }
    *entries() {
      for (const e3 of __privateMethod(this, _pe_instances, A_fn).call(this)) void 0 === __privateGet(this, _u)[e3] || void 0 === __privateGet(this, _c2)[e3] || __privateMethod(this, _pe_instances, T_fn).call(this, __privateGet(this, _u)[e3]) || (yield [__privateGet(this, _c2)[e3], __privateGet(this, _u)[e3]]);
    }
    *rentries() {
      for (const e3 of __privateMethod(this, _pe_instances, C_fn).call(this)) void 0 === __privateGet(this, _u)[e3] || void 0 === __privateGet(this, _c2)[e3] || __privateMethod(this, _pe_instances, T_fn).call(this, __privateGet(this, _u)[e3]) || (yield [__privateGet(this, _c2)[e3], __privateGet(this, _u)[e3]]);
    }
    *keys() {
      for (const e3 of __privateMethod(this, _pe_instances, A_fn).call(this)) {
        const t3 = __privateGet(this, _c2)[e3];
        void 0 === t3 || __privateMethod(this, _pe_instances, T_fn).call(this, __privateGet(this, _u)[e3]) || (yield t3);
      }
    }
    *rkeys() {
      for (const e3 of __privateMethod(this, _pe_instances, C_fn).call(this)) {
        const t3 = __privateGet(this, _c2)[e3];
        void 0 === t3 || __privateMethod(this, _pe_instances, T_fn).call(this, __privateGet(this, _u)[e3]) || (yield t3);
      }
    }
    *values() {
      for (const e3 of __privateMethod(this, _pe_instances, A_fn).call(this)) void 0 === __privateGet(this, _u)[e3] || __privateMethod(this, _pe_instances, T_fn).call(this, __privateGet(this, _u)[e3]) || (yield __privateGet(this, _u)[e3]);
    }
    *rvalues() {
      for (const e3 of __privateMethod(this, _pe_instances, C_fn).call(this)) void 0 === __privateGet(this, _u)[e3] || __privateMethod(this, _pe_instances, T_fn).call(this, __privateGet(this, _u)[e3]) || (yield __privateGet(this, _u)[e3]);
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    find(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      for (const r3 of __privateMethod(this, _pe_instances, A_fn).call(this)) {
        const n3 = __privateGet(this, _u)[r3], s3 = __privateMethod(this, _pe_instances, T_fn).call(this, n3) ? n3.__staleWhileFetching : n3;
        if (void 0 !== s3 && e3(s3, __privateGet(this, _c2)[r3], this)) return this.get(__privateGet(this, _c2)[r3], t3);
      }
    }
    forEach(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this;
      for (const r3 of __privateMethod(this, _pe_instances, A_fn).call(this)) {
        const n3 = __privateGet(this, _u)[r3], s3 = __privateMethod(this, _pe_instances, T_fn).call(this, n3) ? n3.__staleWhileFetching : n3;
        void 0 !== s3 && e3.call(t3, s3, __privateGet(this, _c2)[r3], this);
      }
    }
    rforEach(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this;
      for (const r3 of __privateMethod(this, _pe_instances, C_fn).call(this)) {
        const n3 = __privateGet(this, _u)[r3], s3 = __privateMethod(this, _pe_instances, T_fn).call(this, n3) ? n3.__staleWhileFetching : n3;
        void 0 !== s3 && e3.call(t3, s3, __privateGet(this, _c2)[r3], this);
      }
    }
    purgeStale() {
      let e3 = false;
      for (const t3 of __privateMethod(this, _pe_instances, C_fn).call(this, { allowStale: true })) __privateGet(this, _O).call(this, t3) && (this.delete(__privateGet(this, _c2)[t3]), e3 = true);
      return e3;
    }
    info(e3) {
      const t3 = __privateGet(this, _l2).get(e3);
      if (void 0 === t3) return;
      const r3 = __privateGet(this, _u)[t3], n3 = __privateMethod(this, _pe_instances, T_fn).call(this, r3) ? r3.__staleWhileFetching : r3;
      if (void 0 === n3) return;
      const s3 = { value: n3 };
      if (__privateGet(this, _v) && __privateGet(this, _b)) {
        const e4 = __privateGet(this, _v)[t3], r4 = __privateGet(this, _b)[t3];
        if (e4 && r4) {
          const t4 = e4 - (te.now() - r4);
          s3.ttl = t4, s3.start = Date.now();
        }
      }
      return __privateGet(this, _g) && (s3.size = __privateGet(this, _g)[t3]), s3;
    }
    dump() {
      const e3 = [];
      for (const t3 of __privateMethod(this, _pe_instances, A_fn).call(this, { allowStale: true })) {
        const r3 = __privateGet(this, _c2)[t3], n3 = __privateGet(this, _u)[t3], s3 = __privateMethod(this, _pe_instances, T_fn).call(this, n3) ? n3.__staleWhileFetching : n3;
        if (void 0 === s3 || void 0 === r3) continue;
        const i3 = { value: s3 };
        if (__privateGet(this, _v) && __privateGet(this, _b)) {
          i3.ttl = __privateGet(this, _v)[t3];
          const e4 = te.now() - __privateGet(this, _b)[t3];
          i3.start = Math.floor(Date.now() - e4);
        }
        __privateGet(this, _g) && (i3.size = __privateGet(this, _g)[t3]), e3.unshift([r3, i3]);
      }
      return e3;
    }
    load(e3) {
      this.clear();
      for (const [t3, r3] of e3) {
        if (r3.start) {
          const e4 = Date.now() - r3.start;
          r3.start = te.now() - e4;
        }
        this.set(t3, r3.value, r3);
      }
    }
    set(e3, t3) {
      var _a4, _b2, _c3, _d2, _e3;
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      if (void 0 === t3) return this.delete(e3), this;
      const { ttl: n3 = this.ttl, start: s3, noDisposeOnSet: i3 = this.noDisposeOnSet, sizeCalculation: o3 = this.sizeCalculation, status: a3 } = r3;
      let { noUpdateTTL: l2 = this.noUpdateTTL } = r3;
      const c2 = __privateGet(this, _L).call(this, e3, t3, r3.size || 0, o3);
      if (this.maxEntrySize && c2 > this.maxEntrySize) return a3 && (a3.set = "miss", a3.maxEntrySizeExceeded = true), this.delete(e3), this;
      let u2 = 0 === __privateGet(this, _o2) ? void 0 : __privateGet(this, _l2).get(e3);
      if (void 0 === u2) u2 = 0 === __privateGet(this, _o2) ? __privateGet(this, _h) : 0 !== __privateGet(this, _m).length ? __privateGet(this, _m).pop() : __privateGet(this, _o2) === __privateGet(this, _t2) ? __privateMethod(this, _pe_instances, B_fn).call(this, false) : __privateGet(this, _o2), __privateGet(this, _c2)[u2] = e3, __privateGet(this, _u)[u2] = t3, __privateGet(this, _l2).set(e3, u2), __privateGet(this, _p)[__privateGet(this, _h)] = u2, __privateGet(this, _d)[u2] = __privateGet(this, _h), __privateSet(this, _h, u2), __privateWrapper(this, _o2)._++, __privateGet(this, _M).call(this, u2, c2, a3), a3 && (a3.set = "add"), l2 = false;
      else {
        __privateMethod(this, _pe_instances, P_fn).call(this, u2);
        const r4 = __privateGet(this, _u)[u2];
        if (t3 !== r4) {
          if (__privateGet(this, _S) && __privateMethod(this, _pe_instances, T_fn).call(this, r4)) {
            r4.__abortController.abort(new Error("replaced"));
            const { __staleWhileFetching: t4 } = r4;
            void 0 === t4 || i3 || (__privateGet(this, _E) && ((_a4 = __privateGet(this, _n2)) == null ? void 0 : _a4.call(this, t4, e3, "set")), __privateGet(this, _x) && ((_b2 = __privateGet(this, _y)) == null ? void 0 : _b2.push([t4, e3, "set"])));
          } else i3 || (__privateGet(this, _E) && ((_c3 = __privateGet(this, _n2)) == null ? void 0 : _c3.call(this, r4, e3, "set")), __privateGet(this, _x) && ((_d2 = __privateGet(this, _y)) == null ? void 0 : _d2.push([r4, e3, "set"])));
          if (__privateGet(this, _j).call(this, u2), __privateGet(this, _M).call(this, u2, c2, a3), __privateGet(this, _u)[u2] = t3, a3) {
            a3.set = "replace";
            const e4 = r4 && __privateMethod(this, _pe_instances, T_fn).call(this, r4) ? r4.__staleWhileFetching : r4;
            void 0 !== e4 && (a3.oldValue = e4);
          }
        } else a3 && (a3.set = "update");
      }
      if (0 === n3 || __privateGet(this, _v) || __privateMethod(this, _pe_instances, __fn).call(this), __privateGet(this, _v) && (l2 || __privateGet(this, _k).call(this, u2, n3, s3), a3 && __privateGet(this, _D).call(this, a3, u2)), !i3 && __privateGet(this, _x) && __privateGet(this, _y)) {
        const e4 = __privateGet(this, _y);
        let t4;
        for (; t4 = e4 == null ? void 0 : e4.shift(); ) (_e3 = __privateGet(this, _s2)) == null ? void 0 : _e3.call(this, ...t4);
      }
      return this;
    }
    pop() {
      var _a4;
      try {
        for (; __privateGet(this, _o2); ) {
          const e3 = __privateGet(this, _u)[__privateGet(this, _f)];
          if (__privateMethod(this, _pe_instances, B_fn).call(this, true), __privateMethod(this, _pe_instances, T_fn).call(this, e3)) {
            if (e3.__staleWhileFetching) return e3.__staleWhileFetching;
          } else if (void 0 !== e3) return e3;
        }
      } finally {
        if (__privateGet(this, _x) && __privateGet(this, _y)) {
          const e3 = __privateGet(this, _y);
          let t3;
          for (; t3 = e3 == null ? void 0 : e3.shift(); ) (_a4 = __privateGet(this, _s2)) == null ? void 0 : _a4.call(this, ...t3);
        }
      }
    }
    has(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const { updateAgeOnHas: r3 = this.updateAgeOnHas, status: n3 } = t3, s3 = __privateGet(this, _l2).get(e3);
      if (void 0 !== s3) {
        const e4 = __privateGet(this, _u)[s3];
        if (__privateMethod(this, _pe_instances, T_fn).call(this, e4) && void 0 === e4.__staleWhileFetching) return false;
        if (!__privateGet(this, _O).call(this, s3)) return r3 && __privateGet(this, _N).call(this, s3), n3 && (n3.has = "hit", __privateGet(this, _D).call(this, n3, s3)), true;
        n3 && (n3.has = "stale", __privateGet(this, _D).call(this, n3, s3));
      } else n3 && (n3.has = "miss");
      return false;
    }
    peek(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const { allowStale: r3 = this.allowStale } = t3, n3 = __privateGet(this, _l2).get(e3);
      if (void 0 === n3 || !r3 && __privateGet(this, _O).call(this, n3)) return;
      const s3 = __privateGet(this, _u)[n3];
      return __privateMethod(this, _pe_instances, T_fn).call(this, s3) ? s3.__staleWhileFetching : s3;
    }
    async fetch(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const { allowStale: r3 = this.allowStale, updateAgeOnGet: n3 = this.updateAgeOnGet, noDeleteOnStaleGet: s3 = this.noDeleteOnStaleGet, ttl: i3 = this.ttl, noDisposeOnSet: o3 = this.noDisposeOnSet, size: a3 = 0, sizeCalculation: l2 = this.sizeCalculation, noUpdateTTL: c2 = this.noUpdateTTL, noDeleteOnFetchRejection: u2 = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection: p2 = this.allowStaleOnFetchRejection, ignoreFetchAbort: d2 = this.ignoreFetchAbort, allowStaleOnFetchAbort: f2 = this.allowStaleOnFetchAbort, context: h2, forceRefresh: m2 = false, status: y2, signal: g2 } = t3;
      if (!__privateGet(this, _S)) return y2 && (y2.fetch = "get"), this.get(e3, { allowStale: r3, updateAgeOnGet: n3, noDeleteOnStaleGet: s3, status: y2 });
      const b2 = { allowStale: r3, updateAgeOnGet: n3, noDeleteOnStaleGet: s3, ttl: i3, noDisposeOnSet: o3, size: a3, sizeCalculation: l2, noUpdateTTL: c2, noDeleteOnFetchRejection: u2, allowStaleOnFetchRejection: p2, allowStaleOnFetchAbort: f2, ignoreFetchAbort: d2, status: y2, signal: g2 };
      let v2 = __privateGet(this, _l2).get(e3);
      if (void 0 === v2) {
        y2 && (y2.fetch = "miss");
        const t4 = __privateMethod(this, _pe_instances, w_fn).call(this, e3, v2, b2, h2);
        return t4.__returned = t4;
      }
      {
        const t4 = __privateGet(this, _u)[v2];
        if (__privateMethod(this, _pe_instances, T_fn).call(this, t4)) {
          const e4 = r3 && void 0 !== t4.__staleWhileFetching;
          return y2 && (y2.fetch = "inflight", e4 && (y2.returnedStale = true)), e4 ? t4.__staleWhileFetching : t4.__returned = t4;
        }
        const s4 = __privateGet(this, _O).call(this, v2);
        if (!m2 && !s4) return y2 && (y2.fetch = "hit"), __privateMethod(this, _pe_instances, P_fn).call(this, v2), n3 && __privateGet(this, _N).call(this, v2), y2 && __privateGet(this, _D).call(this, y2, v2), t4;
        const i4 = __privateMethod(this, _pe_instances, w_fn).call(this, e3, v2, b2, h2), o4 = void 0 !== i4.__staleWhileFetching && r3;
        return y2 && (y2.fetch = s4 ? "stale" : "refresh", o4 && s4 && (y2.returnedStale = true)), o4 ? i4.__staleWhileFetching : i4.__returned = i4;
      }
    }
    get(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const { allowStale: r3 = this.allowStale, updateAgeOnGet: n3 = this.updateAgeOnGet, noDeleteOnStaleGet: s3 = this.noDeleteOnStaleGet, status: i3 } = t3, o3 = __privateGet(this, _l2).get(e3);
      if (void 0 !== o3) {
        const t4 = __privateGet(this, _u)[o3], a3 = __privateMethod(this, _pe_instances, T_fn).call(this, t4);
        return i3 && __privateGet(this, _D).call(this, i3, o3), __privateGet(this, _O).call(this, o3) ? (i3 && (i3.get = "stale"), a3 ? (i3 && r3 && void 0 !== t4.__staleWhileFetching && (i3.returnedStale = true), r3 ? t4.__staleWhileFetching : void 0) : (s3 || this.delete(e3), i3 && r3 && (i3.returnedStale = true), r3 ? t4 : void 0)) : (i3 && (i3.get = "hit"), a3 ? t4.__staleWhileFetching : (__privateMethod(this, _pe_instances, P_fn).call(this, o3), n3 && __privateGet(this, _N).call(this, o3), t4));
      }
      i3 && (i3.get = "miss");
    }
    delete(e3) {
      var _a4, _b2, _c3, _d2;
      let t3 = false;
      if (0 !== __privateGet(this, _o2)) {
        const r3 = __privateGet(this, _l2).get(e3);
        if (void 0 !== r3) if (t3 = true, 1 === __privateGet(this, _o2)) this.clear();
        else {
          __privateGet(this, _j).call(this, r3);
          const t4 = __privateGet(this, _u)[r3];
          if (__privateMethod(this, _pe_instances, T_fn).call(this, t4) ? t4.__abortController.abort(new Error("deleted")) : (__privateGet(this, _E) || __privateGet(this, _x)) && (__privateGet(this, _E) && ((_a4 = __privateGet(this, _n2)) == null ? void 0 : _a4.call(this, t4, e3, "delete")), __privateGet(this, _x) && ((_b2 = __privateGet(this, _y)) == null ? void 0 : _b2.push([t4, e3, "delete"]))), __privateGet(this, _l2).delete(e3), __privateGet(this, _c2)[r3] = void 0, __privateGet(this, _u)[r3] = void 0, r3 === __privateGet(this, _h)) __privateSet(this, _h, __privateGet(this, _d)[r3]);
          else if (r3 === __privateGet(this, _f)) __privateSet(this, _f, __privateGet(this, _p)[r3]);
          else {
            const e4 = __privateGet(this, _d)[r3];
            __privateGet(this, _p)[e4] = __privateGet(this, _p)[r3];
            const t5 = __privateGet(this, _p)[r3];
            __privateGet(this, _d)[t5] = __privateGet(this, _d)[r3];
          }
          __privateWrapper(this, _o2)._--, __privateGet(this, _m).push(r3);
        }
      }
      if (__privateGet(this, _x) && ((_c3 = __privateGet(this, _y)) == null ? void 0 : _c3.length)) {
        const e4 = __privateGet(this, _y);
        let t4;
        for (; t4 = e4 == null ? void 0 : e4.shift(); ) (_d2 = __privateGet(this, _s2)) == null ? void 0 : _d2.call(this, ...t4);
      }
      return t3;
    }
    clear() {
      var _a4, _b2, _c3;
      for (const e3 of __privateMethod(this, _pe_instances, C_fn).call(this, { allowStale: true })) {
        const t3 = __privateGet(this, _u)[e3];
        if (__privateMethod(this, _pe_instances, T_fn).call(this, t3)) t3.__abortController.abort(new Error("deleted"));
        else {
          const r3 = __privateGet(this, _c2)[e3];
          __privateGet(this, _E) && ((_a4 = __privateGet(this, _n2)) == null ? void 0 : _a4.call(this, t3, r3, "delete")), __privateGet(this, _x) && ((_b2 = __privateGet(this, _y)) == null ? void 0 : _b2.push([t3, r3, "delete"]));
        }
      }
      if (__privateGet(this, _l2).clear(), __privateGet(this, _u).fill(void 0), __privateGet(this, _c2).fill(void 0), __privateGet(this, _v) && __privateGet(this, _b) && (__privateGet(this, _v).fill(0), __privateGet(this, _b).fill(0)), __privateGet(this, _g) && __privateGet(this, _g).fill(0), __privateSet(this, _f, 0), __privateSet(this, _h, 0), __privateGet(this, _m).length = 0, __privateSet(this, _a3, 0), __privateSet(this, _o2, 0), __privateGet(this, _x) && __privateGet(this, _y)) {
        const e3 = __privateGet(this, _y);
        let t3;
        for (; t3 = e3 == null ? void 0 : e3.shift(); ) (_c3 = __privateGet(this, _s2)) == null ? void 0 : _c3.call(this, ...t3);
      }
    }
  };
  _t2 = new WeakMap();
  _r2 = new WeakMap();
  _n2 = new WeakMap();
  _s2 = new WeakMap();
  _i2 = new WeakMap();
  _o2 = new WeakMap();
  _a3 = new WeakMap();
  _l2 = new WeakMap();
  _c2 = new WeakMap();
  _u = new WeakMap();
  _p = new WeakMap();
  _d = new WeakMap();
  _f = new WeakMap();
  _h = new WeakMap();
  _m = new WeakMap();
  _y = new WeakMap();
  _g = new WeakMap();
  _b = new WeakMap();
  _v = new WeakMap();
  _E = new WeakMap();
  _S = new WeakMap();
  _x = new WeakMap();
  _pe_instances = new WeakSet();
  __fn = function() {
    var e3 = this;
    const t3 = new ce(__privateGet(this, _t2)), r3 = new ce(__privateGet(this, _t2));
    __privateSet(this, _v, t3), __privateSet(this, _b, r3), __privateSet(this, _k, function(n4, s4) {
      let i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : te.now();
      if (r3[n4] = 0 !== s4 ? i3 : 0, t3[n4] = s4, 0 !== s4 && e3.ttlAutopurge) {
        const t4 = setTimeout(() => {
          var _a4;
          __privateGet(_a4 = e3, _O).call(_a4, n4) && e3.delete(__privateGet(e3, _c2)[n4]);
        }, s4 + 1);
        t4.unref && t4.unref();
      }
    }), __privateSet(this, _N, (e4) => {
      r3[e4] = 0 !== t3[e4] ? te.now() : 0;
    }), __privateSet(this, _D, (e4, i3) => {
      if (t3[i3]) {
        const o3 = t3[i3], a3 = r3[i3];
        if (!o3 || !a3) return;
        e4.ttl = o3, e4.start = a3, e4.now = n3 || s3();
        const l2 = e4.now - a3;
        e4.remainingTTL = o3 - l2;
      }
    });
    let n3 = 0;
    const s3 = () => {
      const e4 = te.now();
      if (this.ttlResolution > 0) {
        n3 = e4;
        const t4 = setTimeout(() => n3 = 0, this.ttlResolution);
        t4.unref && t4.unref();
      }
      return e4;
    };
    this.getRemainingTTL = (e4) => {
      const i3 = __privateGet(this, _l2).get(e4);
      if (void 0 === i3) return 0;
      const o3 = t3[i3], a3 = r3[i3];
      return o3 && a3 ? o3 - ((n3 || s3()) - a3) : 1 / 0;
    }, __privateSet(this, _O, (e4) => {
      const i3 = r3[e4], o3 = t3[e4];
      return !!o3 && !!i3 && (n3 || s3()) - i3 > o3;
    });
  };
  _N = new WeakMap();
  _D = new WeakMap();
  _k = new WeakMap();
  _O = new WeakMap();
  I_fn = function() {
    const e3 = new ce(__privateGet(this, _t2));
    __privateSet(this, _a3, 0), __privateSet(this, _g, e3), __privateSet(this, _j, (t3) => {
      __privateSet(this, _a3, __privateGet(this, _a3) - e3[t3]), e3[t3] = 0;
    }), __privateSet(this, _L, (e4, t3, r3, n3) => {
      if (__privateMethod(this, _pe_instances, T_fn).call(this, t3)) return 0;
      if (!ae(r3)) {
        if (!n3) throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        if ("function" != typeof n3) throw new TypeError("sizeCalculation must be a function");
        if (r3 = n3(t3, e4), !ae(r3)) throw new TypeError("sizeCalculation return invalid (expect positive integer)");
      }
      return r3;
    }), __privateSet(this, _M, (t3, r3, n3) => {
      if (e3[t3] = r3, __privateGet(this, _r2)) {
        const r4 = __privateGet(this, _r2) - e3[t3];
        for (; __privateGet(this, _a3) > r4; ) __privateMethod(this, _pe_instances, B_fn).call(this, true);
      }
      __privateSet(this, _a3, __privateGet(this, _a3) + e3[t3]), n3 && (n3.entrySize = r3, n3.totalCalculatedSize = __privateGet(this, _a3));
    });
  };
  _j = new WeakMap();
  _M = new WeakMap();
  _L = new WeakMap();
  A_fn = function() {
    var e3 = this;
    let { allowStale: t3 = this.allowStale } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return function* () {
      var _a4, _b2;
      if (__privateGet(e3, _o2)) for (let r3 = __privateGet(e3, _h); __privateMethod(_a4 = e3, _pe_instances, R_fn).call(_a4, r3) && (!t3 && __privateGet(_b2 = e3, _O).call(_b2, r3) || (yield r3), r3 !== __privateGet(e3, _f)); ) r3 = __privateGet(e3, _d)[r3];
    }();
  };
  C_fn = function() {
    var e3 = this;
    let { allowStale: t3 = this.allowStale } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return function* () {
      var _a4, _b2;
      if (__privateGet(e3, _o2)) for (let r3 = __privateGet(e3, _f); __privateMethod(_a4 = e3, _pe_instances, R_fn).call(_a4, r3) && (!t3 && __privateGet(_b2 = e3, _O).call(_b2, r3) || (yield r3), r3 !== __privateGet(e3, _h)); ) r3 = __privateGet(e3, _p)[r3];
    }();
  };
  R_fn = function(e3) {
    return void 0 !== e3 && __privateGet(this, _l2).get(__privateGet(this, _c2)[e3]) === e3;
  };
  B_fn = function(e3) {
    var _a4, _b2;
    const t3 = __privateGet(this, _f), r3 = __privateGet(this, _c2)[t3], n3 = __privateGet(this, _u)[t3];
    return __privateGet(this, _S) && __privateMethod(this, _pe_instances, T_fn).call(this, n3) ? n3.__abortController.abort(new Error("evicted")) : (__privateGet(this, _E) || __privateGet(this, _x)) && (__privateGet(this, _E) && ((_a4 = __privateGet(this, _n2)) == null ? void 0 : _a4.call(this, n3, r3, "evict")), __privateGet(this, _x) && ((_b2 = __privateGet(this, _y)) == null ? void 0 : _b2.push([n3, r3, "evict"]))), __privateGet(this, _j).call(this, t3), e3 && (__privateGet(this, _c2)[t3] = void 0, __privateGet(this, _u)[t3] = void 0, __privateGet(this, _m).push(t3)), 1 === __privateGet(this, _o2) ? (__privateSet(this, _f, __privateSet(this, _h, 0)), __privateGet(this, _m).length = 0) : __privateSet(this, _f, __privateGet(this, _p)[t3]), __privateGet(this, _l2).delete(r3), __privateWrapper(this, _o2)._--, t3;
  };
  w_fn = function(e3, t3, r3, n3) {
    var s3 = this;
    const i3 = void 0 === t3 ? void 0 : __privateGet(this, _u)[t3];
    if (__privateMethod(this, _pe_instances, T_fn).call(this, i3)) return i3;
    const o3 = new ie(), { signal: a3 } = r3;
    a3 == null ? void 0 : a3.addEventListener("abort", () => o3.abort(a3.reason), { signal: o3.signal });
    const l2 = { signal: o3.signal, options: r3, context: n3 }, c2 = function(n4) {
      let i4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      const { aborted: a4 } = o3.signal, c3 = r3.ignoreFetchAbort && void 0 !== n4;
      if (r3.status && (a4 && !i4 ? (r3.status.fetchAborted = true, r3.status.fetchError = o3.signal.reason, c3 && (r3.status.fetchAbortIgnored = true)) : r3.status.fetchResolved = true), a4 && !c3 && !i4) return u2(o3.signal.reason);
      const d3 = p2;
      return __privateGet(s3, _u)[t3] === p2 && (void 0 === n4 ? d3.__staleWhileFetching ? __privateGet(s3, _u)[t3] = d3.__staleWhileFetching : s3.delete(e3) : (r3.status && (r3.status.fetchUpdated = true), s3.set(e3, n4, l2.options))), n4;
    }, u2 = (n4) => {
      const { aborted: s4 } = o3.signal, i4 = s4 && r3.allowStaleOnFetchAbort, a4 = i4 || r3.allowStaleOnFetchRejection, l3 = a4 || r3.noDeleteOnFetchRejection, c3 = p2;
      if (__privateGet(this, _u)[t3] === p2 && (l3 && void 0 !== c3.__staleWhileFetching ? i4 || (__privateGet(this, _u)[t3] = c3.__staleWhileFetching) : this.delete(e3)), a4) return r3.status && void 0 !== c3.__staleWhileFetching && (r3.status.returnedStale = true), c3.__staleWhileFetching;
      if (c3.__returned === c3) throw n4;
    };
    r3.status && (r3.status.fetchDispatched = true);
    const p2 = new Promise((t4, n4) => {
      var _a4;
      const s4 = (_a4 = __privateGet(this, _i2)) == null ? void 0 : _a4.call(this, e3, i3, l2);
      s4 && s4 instanceof Promise && s4.then((e4) => t4(void 0 === e4 ? void 0 : e4), n4), o3.signal.addEventListener("abort", () => {
        r3.ignoreFetchAbort && !r3.allowStaleOnFetchAbort || (t4(void 0), r3.allowStaleOnFetchAbort && (t4 = (e4) => c2(e4, true)));
      });
    }).then(c2, (e4) => (r3.status && (r3.status.fetchRejected = true, r3.status.fetchError = e4), u2(e4))), d2 = Object.assign(p2, { __abortController: o3, __staleWhileFetching: i3, __returned: void 0 });
    return void 0 === t3 ? (this.set(e3, d2, { ...l2.options, status: void 0 }), t3 = __privateGet(this, _l2).get(e3)) : __privateGet(this, _u)[t3] = d2, d2;
  };
  T_fn = function(e3) {
    if (!__privateGet(this, _S)) return false;
    const t3 = e3;
    return !!t3 && t3 instanceof Promise && t3.hasOwnProperty("__staleWhileFetching") && t3.__abortController instanceof ie;
  };
  F_fn = function(e3, t3) {
    __privateGet(this, _d)[t3] = e3, __privateGet(this, _p)[e3] = t3;
  };
  P_fn = function(e3) {
    e3 !== __privateGet(this, _h) && (e3 === __privateGet(this, _f) ? __privateSet(this, _f, __privateGet(this, _p)[e3]) : __privateMethod(this, _pe_instances, F_fn).call(this, __privateGet(this, _d)[e3], __privateGet(this, _p)[e3]), __privateMethod(this, _pe_instances, F_fn).call(this, __privateGet(this, _h), e3), __privateSet(this, _h, e3));
  };
  let pe = _pe;
  function de() {
    return new pe({ max: arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 500 });
  }
  function fe(e3, t3) {
    return function(e4) {
      const { content: t4, ast: r3 } = e4.template, n3 = he.get(t4);
      if (n3) return n3;
      const s3 = /* @__PURE__ */ new Set();
      return r3.children.forEach(function e5(t5) {
        var r4;
        switch (t5.type) {
          case 1:
            let n4 = t5.tag;
            n4.includes(".") && (n4 = n4.split(".")[0].trim()), o2.parserOptions.isNativeTag(n4) || o2.parserOptions.isBuiltInComponent(n4) || (s3.add(c.camelize(n4)), s3.add(c.capitalize(c.camelize(n4))));
            for (let e6 = 0; e6 < t5.props.length; e6++) {
              const n5 = t5.props[e6];
              7 === n5.type && (c.isBuiltInDirective(n5.name) || s3.add(`v${c.capitalize(c.camelize(n5.name))}`), n5.arg && !n5.arg.isStatic && me(s3, n5.arg), "for" === n5.name ? me(s3, n5.forParseResult.source) : n5.exp && me(s3, n5.exp)), 6 === n5.type && "ref" === n5.name && (null == (r4 = n5.value) ? void 0 : r4.content) && s3.add(n5.value.content);
            }
            t5.children.forEach(e5);
            break;
          case 5:
            me(s3, t5.content);
        }
      }), he.set(t4, s3), s3;
    }(t3).has(e3);
  }
  const he = de();
  function me(e3, t3) {
    t3.ast ? o2.walkIdentifiers(t3.ast, (t4) => e3.add(t4.name)) : null === t3.ast && e3.add(t3.content);
  }
  const ye = "anonymous.vue", ge = de();
  function be(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const r3 = function(e4, t4) {
      var r4;
      return e4 + JSON.stringify({ ...t4, compiler: { parse: null == (r4 = t4.compiler) ? void 0 : r4.parse } }, (e5, t5) => "function" == typeof t5 ? t5.toString() : t5);
    }(e3, t3), n3 = ge.get(r3);
    if (n3) return n3;
    const { sourceMap: s3 = true, filename: o3 = ye, sourceRoot: l2 = "", pad: c2 = false, ignoreEmpty: u2 = true, compiler: p2 = E, templateParseOptions: d2 = {}, parseExpressions: f2 = true } = t3, h2 = { filename: o3, source: e3, template: null, script: null, scriptSetup: null, styles: [], customBlocks: [], cssVars: [], slotted: false, shouldForceReload: (e4) => function(e5, t4) {
      if (!t4.scriptSetup || "ts" !== t4.scriptSetup.lang && "tsx" !== t4.scriptSetup.lang) return false;
      for (const r4 in e5) if (!e5[r4].isUsedInTemplate && fe(r4, t4)) return true;
      return false;
    }(e4, h2) }, m2 = [];
    p2.parse(e3, { parseMode: "sfc", prefixIdentifiers: f2, ...d2, onError: (e4) => {
      m2.push(e4);
    } }).children.forEach((t4) => {
      if (1 === t4.type && (!u2 || "template" === t4.tag || !function(e4) {
        for (let t5 = 0; t5 < e4.children.length; t5++) {
          const r4 = e4.children[t5];
          if (2 !== r4.type || "" !== r4.content.trim()) return false;
        }
        return true;
      }(t4) || function(e4) {
        return e4.props.some((e5) => 6 === e5.type && "src" === e5.name);
      }(t4))) switch (t4.tag) {
        case "template":
          if (h2.template) m2.push(ve(t4));
          else {
            const r5 = h2.template = Ee(t4, e3, false);
            if (r5.attrs.src || (r5.ast = i2.createRoot(t4.children, e3)), r5.attrs.functional) {
              const e4 = new SyntaxError("<template functional> is no longer supported in Vue 3, since functional components no longer have significant performance difference from stateful ones. Just use a normal <template> instead.");
              e4.loc = t4.props.find((e5) => 6 === e5.type && "functional" === e5.name).loc, m2.push(e4);
            }
          }
          break;
        case "script":
          const r4 = Ee(t4, e3, c2), n4 = !!r4.attrs.setup;
          if (n4 && !h2.scriptSetup) {
            h2.scriptSetup = r4;
            break;
          }
          if (!n4 && !h2.script) {
            h2.script = r4;
            break;
          }
          m2.push(ve(t4, n4));
          break;
        case "style":
          const s4 = Ee(t4, e3, c2);
          s4.attrs.vars && m2.push(new SyntaxError("<style vars> has been replaced by a new proposal: https://github.com/vuejs/rfcs/pull/231")), h2.styles.push(s4);
          break;
        default:
          h2.customBlocks.push(Ee(t4, e3, c2));
      }
    }), h2.template || h2.script || h2.scriptSetup || m2.push(new SyntaxError("At least one <template> or <script> is required in a single file component.")), h2.scriptSetup && (h2.scriptSetup.src && (m2.push(new SyntaxError('<script setup> cannot use the "src" attribute because its syntax will be ambiguous outside of the component.')), h2.scriptSetup = null), h2.script && h2.script.src && (m2.push(new SyntaxError('<script> cannot use the "src" attribute when <script setup> is also present because they must be processed together.')), h2.script = null));
    let y2 = 0;
    if (!h2.template || "pug" !== h2.template.lang && "jade" !== h2.template.lang || ([h2.template.content, y2] = function(e4) {
      const t4 = e4.split("\n"), r4 = t4.reduce(function(e5, t5) {
        var r5, n4;
        if ("" === t5.trim()) return e5;
        const s4 = (null == (n4 = null == (r5 = t5.match(/^\s*/)) ? void 0 : r5[0]) ? void 0 : n4.length) || 0;
        return Math.min(s4, e5);
      }, 1 / 0);
      return 0 === r4 ? [e4, r4] : [t4.map(function(e5) {
        return e5.slice(r4);
      }).join("\n"), r4];
    }(h2.template.content)), s3) {
      const t4 = function(t5) {
        let r4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        t5 && !t5.src && (t5.map = function(e4, t6, r5, n4, s4, i3) {
          const o4 = new a2.SourceMapGenerator({ file: e4.replace(/\\/g, "/"), sourceRoot: n4.replace(/\\/g, "/") });
          return o4.setSourceContent(e4, t6), o4._sources.add(e4), r5.split(Se).forEach((t7, r6) => {
            if (!xe.test(t7)) {
              const n5 = r6 + 1 + s4, a3 = r6 + 1;
              for (let r7 = 0; r7 < t7.length; r7++) /\s/.test(t7[r7]) || o4._mappings.add({ originalLine: n5, originalColumn: r7 + i3, generatedLine: a3, generatedColumn: r7, source: e4, name: null });
            }
          }), o4.toJSON();
        }(o3, e3, t5.content, l2, c2 && "template" !== t5.type ? 0 : t5.loc.start.line - 1, r4));
      };
      t4(h2.template, y2), t4(h2.script), h2.styles.forEach((e4) => t4(e4)), h2.customBlocks.forEach((e4) => t4(e4));
    }
    h2.cssVars = function(e4) {
      const t4 = [];
      return e4.styles.forEach((e5) => {
        let r4;
        const n4 = e5.content.replace(/\/\*([\s\S]*?)\*\/|\/\/.*/g, "");
        for (; r4 = Y.exec(n4); ) {
          const e6 = r4.index + r4[0].length, s4 = Q(n4, e6);
          if (null !== s4) {
            const r5 = J(n4.slice(e6, s4));
            t4.includes(r5) || t4.push(r5);
          }
        }
      }), t4;
    }(h2);
    const g2 = /(?:::v-|:)slotted\(/;
    h2.slotted = h2.styles.some((e4) => e4.scoped && g2.test(e4.content));
    const b2 = { descriptor: h2, errors: m2 };
    return ge.set(r3, b2), b2;
  }
  function ve(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    const r3 = new SyntaxError(`Single file component can contain only one <${e3.tag}${t3 ? " setup" : ""}> element`);
    return r3.loc = e3.loc, r3;
  }
  function Ee(e3, t3, r3) {
    const n3 = e3.tag, s3 = e3.innerLoc, i3 = {}, o3 = { type: n3, content: t3.slice(s3.start.offset, s3.end.offset), loc: s3, attrs: i3 };
    return r3 && (o3.content = function(e4, t4, r4) {
      if (e4 = e4.slice(0, t4.loc.start.offset), "space" === r4) return e4.replace(Te, " ");
      {
        const r5 = e4.split(Se).length, n4 = "script" !== t4.type || t4.lang ? "\n" : "//\n";
        return Array(r5).join(n4);
      }
    }(t3, o3, r3) + o3.content), e3.props.forEach((e4) => {
      if (6 === e4.type) {
        const t4 = e4.name;
        i3[t4] = e4.value && e4.value.content || true, "lang" === t4 ? o3.lang = e4.value && e4.value.content : "src" === t4 ? o3.src = e4.value && e4.value.content : "style" === n3 ? "scoped" === t4 ? o3.scoped = true : "module" === t4 && (o3.module = i3[t4]) : "script" === n3 && "setup" === t4 && (o3.setup = i3.setup);
      }
    }), o3;
  }
  const Se = /\r?\n/g, xe = /^(?:\/\/)?\s*$/, Te = /./g;
  function we(e3) {
    const t3 = e3.charAt(0);
    return "." === t3 || "~" === t3 || "@" === t3;
  }
  const Pe = /^(https?:)?\/\//;
  function Ae(e3) {
    return Pe.test(e3);
  }
  const Ce = /^\s*data:/i;
  function Oe(e3) {
    return Ce.test(e3);
  }
  function Ie(e3) {
    if ("~" === e3.charAt(0)) {
      const t3 = e3.charAt(1);
      e3 = e3.slice("/" === t3 ? 2 : 1);
    }
    return _e(e3);
  }
  function _e(e3) {
    return u.parse(c.isString(e3) ? e3 : "", false, true);
  }
  const ke = { base: null, includeAbsolute: false, tags: { video: ["src", "poster"], source: ["src"], img: ["src"], image: ["xlink:href", "href"], use: ["xlink:href", "href"] } }, Ne = (e3) => Object.keys(e3).some((t3) => c.isArray(e3[t3])) ? { ...ke, tags: e3 } : { ...ke, ...e3 }, De = (e3) => (t3, r3) => je(t3, r3, e3), je = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ke;
    if (1 === e3.type) {
      if (!e3.props.length) return;
      const n3 = r3.tags || ke.tags, s3 = n3[e3.tag], o3 = n3["*"];
      if (!s3 && !o3) return;
      const a3 = (s3 || []).concat(o3 || []);
      e3.props.forEach((n4, s4) => {
        if (6 !== n4.type || !a3.includes(n4.name) || !n4.value || Ae(n4.value.content) || Oe(n4.value.content) || "#" === n4.value.content[0] || !r3.includeAbsolute && !we(n4.value.content)) return;
        const o4 = Ie(n4.value.content);
        if (r3.base && "." === n4.value.content[0]) {
          const e4 = Ie(r3.base), t4 = e4.protocol || "", s5 = e4.host ? t4 + "//" + e4.host : "", i3 = e4.path || "/";
          return void (n4.value.content = s5 + (l.posix || l).join(i3, o4.path + (o4.hash || "")));
        }
        const c2 = function(e4, t4, r4, n5) {
          if (e4) {
            let s5, o5;
            const a4 = n5.imports.findIndex((t5) => t5.path === e4);
            if (a4 > -1 ? (s5 = `_imports_${a4}`, o5 = n5.imports[a4].exp) : (s5 = `_imports_${n5.imports.length}`, o5 = i2.createSimpleExpression(s5, false, r4, 3), n5.imports.push({ exp: o5, path: decodeURIComponent(e4) })), !t4) return o5;
            const l2 = `${s5} + '${t4}'`, c3 = i2.createSimpleExpression(l2, false, r4, 3);
            if (!n5.hoistStatic) return c3;
            const u2 = n5.hoists.findIndex((e5) => e5 && 4 === e5.type && !e5.isStatic && e5.content === l2);
            return u2 > -1 ? i2.createSimpleExpression(`_hoisted_${u2 + 1}`, false, r4, 3) : n5.hoist(c3);
          }
          return i2.createSimpleExpression("''", false, r4, 3);
        }(o4.path, o4.hash, n4.loc, t3);
        e3.props[s4] = { type: 7, name: "bind", arg: i2.createSimpleExpression(n4.name, true, n4.loc), exp: c2, modifiers: [], loc: n4.loc };
      });
    }
  }, Le = ["img", "source"], Me = /( |\\t|\\n|\\f|\\r)+/g, Be = (e3) => (t3, r3) => Re(t3, r3, e3), Re = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ke;
    1 === e3.type && Le.includes(e3.tag) && e3.props.length && e3.props.forEach((n3, s3) => {
      if ("srcset" === n3.name && 6 === n3.type) {
        if (!n3.value) return;
        const o3 = n3.value.content;
        if (!o3) return;
        const a3 = o3.split(",").map((e4) => {
          const [t4, r4] = e4.replace(Me, " ").trim().split(" ", 2);
          return { url: t4, descriptor: r4 };
        });
        for (let e4 = 0; e4 < a3.length; e4++) {
          const { url: t4 } = a3[e4];
          Oe(t4) && (a3[e4 + 1].url = t4 + "," + a3[e4 + 1].url, a3.splice(e4, 1));
        }
        const c2 = (e4) => !Ae(e4) && !Oe(e4) && (r3.includeAbsolute || we(e4));
        if (!a3.some((e4) => {
          let { url: t4 } = e4;
          return c2(t4);
        })) return;
        if (r3.base) {
          const e4 = r3.base, t4 = [];
          let s4 = false;
          if (a3.forEach((r4) => {
            let { url: n4, descriptor: i3 } = r4;
            i3 = i3 ? ` ${i3}` : "", "." === n4[0] ? (r4.url = (l.posix || l).join(e4, n4), t4.push(r4.url + i3)) : c2(n4) ? s4 = true : t4.push(n4 + i3);
          }), !s4) return void (n3.value.content = t4.join(", "));
        }
        const u2 = i2.createCompoundExpression([], n3.loc);
        a3.forEach((e4, r4) => {
          let { url: s4, descriptor: o4 } = e4;
          if (c2(s4)) {
            const { path: e5 } = Ie(s4);
            let r5;
            if (e5) {
              const s5 = t3.imports.findIndex((t4) => t4.path === e5);
              s5 > -1 ? r5 = i2.createSimpleExpression(`_imports_${s5}`, false, n3.loc, 3) : (r5 = i2.createSimpleExpression(`_imports_${t3.imports.length}`, false, n3.loc, 3), t3.imports.push({ exp: r5, path: e5 })), u2.children.push(r5);
            }
          } else {
            const e5 = i2.createSimpleExpression(`"${s4}"`, false, n3.loc, 3);
            u2.children.push(e5);
          }
          const l2 = a3.length - 1 > r4;
          o4 && l2 ? u2.children.push(` + ' ${o4}, ' + `) : o4 ? u2.children.push(` + ' ${o4}'`) : l2 && u2.children.push(" + ', ' + ");
        });
        let p2 = u2;
        t3.hoistStatic && (p2 = t3.hoist(u2), p2.constType = 3), e3.props[s3] = { type: 7, name: "bind", arg: i2.createSimpleExpression("srcset", true, n3.loc), exp: p2, modifiers: [], loc: n3.loc };
      }
    });
  };
  function Fe(e3) {
    throw new Error('Could not dynamically require "' + e3 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var Ue = { exports: {} };
  !function(e3, t3) {
    var s3 = f, i3 = l, o3 = d, a3 = i3.join, c2 = i3.resolve, u2 = i3.extname, p2 = i3.dirname, h2 = i3.isAbsolute, m2 = {}, y2 = {}, g2 = {};
    function b2(e4, t4) {
      return t4 && e4.filename && e4.cache ? (delete m2[e4.filename], y2[e4.filename] = t4, t4) : e4.filename && e4.cache ? y2[e4.filename] : t4;
    }
    function v2(e4, t4, r3) {
      var n3 = m2[e4];
      if (t4.cache && n3 && "string" == typeof n3) return r3(null, n3);
      s3.readFile(e4, "utf8", function(n4, s4) {
        if (n4) return r3(n4);
        s4 = s4.replace(/^\uFEFF/, ""), t4.cache && (m2[e4] = s4), r3(null, s4);
      });
    }
    function E2(e4, t4) {
      return new Promise(function(r3, n3) {
        t4(e4 = e4 || function(e5, t5) {
          if (e5) return n3(e5);
          r3(t5);
        });
      });
    }
    function S2(e4) {
      return function(r3, n3, s4) {
        return n3.filename = r3, E2(s4, function(s5) {
          !function(e5, t4, r4) {
            if (!t4.partials) return r4();
            var n4 = Object.keys(t4.partials), s6 = {};
            !function i4(o4) {
              if (o4 === n4.length) return r4(null, s6);
              var l2 = n4[o4], c3 = t4.partials[l2];
              if (null == c3 || false === c3) return i4(++o4);
              v2(h2(c3) ? "" !== u2(c3) ? c3 : a3(c3 + u2(e5)) : a3(p2(e5), c3 + u2(e5)), t4, function(e6, t5) {
                if (e6) return r4(e6);
                s6[l2] = t5, i4(++o4);
              });
            }(0);
          }(r3, n3, function(i4, o4) {
            var a4 = (g2.extend || (g2.extend = d._extend))({}, n3);
            if (a4.partials = o4, i4) return s5(i4);
            b2(a4) ? t3[e4].render("", a4, s5) : v2(r3, a4, function(r4, n4) {
              if (r4) return s5(r4);
              t3[e4].render(n4, a4, s5);
            });
          });
        });
      };
    }
    function x2(e4, t4) {
      var n3 = (g2.babel || (g2.babel = r2(341))).transformFileSync(t4, { presets: ["react"] }).code;
      return e4._compile(n3, t4);
    }
    function T2(t4) {
      return Fe.extensions && (Fe.extensions[".jsx"] || (Fe.extensions[".jsx"] = x2), Fe.extensions[".react"] || (Fe.extensions[".react"] = x2)), function(n3, i4, o4) {
        return E2(o4, function(o5) {
          var a4 = g2.ReactDOM || (g2.ReactDOM = r2(547)), l2 = g2.react || (g2.react = r2(548)), u3 = i4.base;
          delete i4.base;
          var p3 = i4.cache;
          delete i4.cache;
          var d2 = i4.isNonStatic;
          delete i4.isNonStatic;
          try {
            var f2, h3, y3, v3, E3;
            if (b2(i4)) h3 = b2(i4);
            else {
              if ("path" === t4) {
                var S3 = c2(n3);
                delete r2.c[S3], f2 = Fe(S3);
              } else f2 = function(t5, n4) {
                var s4 = g2.babel || (g2.babel = r2(341));
                n4 || (n4 = "");
                var i5 = new e3.constructor();
                n4 = n4 || "";
                var o6 = s4.transform(t5, { presets: ["react"] }).code;
                return i5.paths = e3.paths, i5._compile(o6, n4), i5.exports;
              }(n3);
              h3 = b2(i4, l2.createFactory(f2));
            }
            E3 = new h3(i4), v3 = d2 ? a4.renderToString(E3) : a4.renderToStaticMarkup(E3), u3 && (y3 = m2[n3] || s3.readFileSync(c2(u3), "utf8"), p3 && (m2[n3] = y3), i4.content = v3, v3 = function(e4, t5) {
              var r3;
              for (var n4 in t5) t5.hasOwnProperty(n4) && (r3 = new RegExp("{{" + n4 + "}}", "g"), e4.match(r3) && (e4 = e4.replace(r3, t5[n4])));
              return e4;
            }(y3, i4)), o5(null, v3);
          } catch (e4) {
            o5(e4);
          }
        });
      };
    }
    t3.clearCache = function() {
      m2 = {}, y2 = {};
    }, t3.velocityjs = S2("velocityjs"), t3.velocityjs.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.velocityjs || (g2.velocityjs = r2(514));
        try {
          t4.locals = t4, n4(null, s4.render(e4, t4).trimLeft());
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.liquid = S2("liquid"), t3.liquid.render = function(e4, t4, o4) {
      return E2(o4, function(o5) {
        var a4, l2 = g2.liquid;
        try {
          return void function(e5, t5, r3, o6) {
            var a5, l3 = e5.newContext();
            if (r3.locals) {
              for (a5 in r3.locals) l3.setLocals(a5, r3.locals[a5]);
              delete r3.locals;
            }
            if (r3.meta && (l3.setLocals("page", r3.meta), delete r3.meta), r3.filters) {
              for (a5 in r3.filters) l3.setFilter(a5, r3.filters[a5]);
              delete r3.filters;
            }
            var c4 = r3.includeDir || n2.cwd();
            l3.onInclude(function(t6, r4) {
              var n3 = i3.extname(t6) ? "" : ".liquid", o7 = i3.resolve(c4, t6 + n3);
              s3.readFile(o7, { encoding: "utf8" }, function(t7, n4) {
                if (t7) return r4(t7);
                r4(null, e5.parse(n4));
              });
            }), delete r3.includeDir;
            var u4 = { customTags: {} };
            if (r3.customTags) {
              var p4 = r3.customTags;
              for (a5 in r3.customTags) u4.customTags[a5] = function(t6, r4, n3) {
                var s4 = p4[r4](n3.trim());
                t6.astStack.push(e5.parse(s4));
              };
              delete r3.customTags;
            }
            for (a5 in r3) l3.setLocals(a5, r3[a5]);
            (b2(l3) || b2(l3, e5.compile(t5, u4)))(l3, o6);
          }(l2 = g2.liquid = r2(515), e4, t4, o5);
        } catch (e5) {
          try {
            l2 = new (a4 = g2.liquid = r2(516)).Engine();
          } catch (e6) {
            throw e6;
          }
        }
        try {
          var c3 = t4.locals || {};
          t4.meta && (c3.pages = t4.meta, delete t4.meta), t4.filters && (l2.registerFilters(t4.filters), delete t4.filters);
          var u3 = t4.includeDir || n2.cwd();
          if (l2.fileSystem = new a4.LocalFileSystem(u3, "liquid"), delete t4.includeDir, t4.customTags) {
            var p3 = t4.customTags;
            for (d2 in t4.customTags) l2.registerTag(d2, p3[d2]);
            delete t4.customTags;
          }
          for (var d2 in t4) c3[d2] = t4[d2];
          return l2.parseAndRender(e4, c3).nodeify(function(e5, t5) {
            if (e5) throw new Error(e5);
            return o5(null, t5);
          });
        } catch (e5) {
          o5(e5);
        }
      });
    }, t3.jade = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.jade;
        if (!s4) try {
          s4 = g2.jade = r2(332);
        } catch (e5) {
          try {
            s4 = g2.jade = r2(333);
          } catch (t5) {
            throw e5;
          }
        }
        try {
          n4(null, (b2(t4) || b2(t4, s4.compileFile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.jade.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.jade;
        if (!s4) try {
          s4 = g2.jade = r2(332);
        } catch (e5) {
          try {
            s4 = g2.jade = r2(333);
          } catch (t5) {
            throw e5;
          }
        }
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.dust = S2("dust"), t3.dust.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.dust;
        if (!s4) try {
          s4 = g2.dust = r2(517);
        } catch (e5) {
          try {
            s4 = g2.dust = r2(518);
          } catch (e6) {
            s4 = g2.dust = r2(519);
          }
        }
        var i4 = "dust", o4 = ".";
        t4 && (t4.ext && (i4 = t4.ext), t4.views && (o4 = t4.views), t4.settings && t4.settings.views && (o4 = t4.settings.views)), (!t4 || t4 && !t4.cache) && (s4.cache = {}), s4.onLoad = function(e5, r3) {
          "" === u2(e5) && (e5 += "." + i4), "/" !== e5[0] && (e5 = o4 + "/" + e5), v2(e5, t4, r3);
        };
        try {
          var a4;
          t4.filename && (a4 = t4.filename.replace(new RegExp("^" + o4 + "/"), "").replace(new RegExp("\\." + i4), "")), (b2(t4) || b2(t4, s4.compileFn(e4, a4)))(t4, n4);
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.swig = S2("swig"), t3.swig.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.swig;
        if (!s4) try {
          s4 = g2.swig = r2(520);
        } catch (e5) {
          try {
            s4 = g2.swig = r2(521);
          } catch (t5) {
            throw e5;
          }
        }
        try {
          true === t4.cache && (t4.cache = "memory"), s4.setDefaults({ cache: t4.cache }), n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.razor = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.razor;
        if (!s4) try {
          s4 = g2.razor = r2(334);
        } catch (e5) {
          throw e5;
        }
        try {
          n4(null, (b2(t4) || b2(t4, (t5) => s4.renderFileSync(e4, t5)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.razor.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        try {
          var s4 = g2.razor = r2(334);
        } catch (e5) {
          throw e5;
        }
        try {
          var i4 = s4.compile(e4);
          n4(null, (b2(t4) || b2(t4, i4))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.atpl = S2("atpl"), t3.atpl.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.atpl || (g2.atpl = r2(522));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.liquor = S2("liquor"), t3.liquor.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.liquor || (g2.liquor = r2(523));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.twig = S2("twig"), t3.twig.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.twig || (g2.twig = r2(524).twig), i4 = { data: e4, allowInlineIncludes: t4.allowInlineIncludes, namespaces: t4.namespaces, path: t4.path };
        try {
          n4(null, (b2(i4) || b2(i4, s4(i4))).render(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.ejs = S2("ejs"), t3.ejs.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.ejs || (g2.ejs = r2(525));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.eco = S2("eco"), t3.eco.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.eco || (g2.eco = r2(526));
        try {
          n4(null, s4.render(e4, t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.jazz = S2("jazz"), t3.jazz.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.jazz || (g2.jazz = r2(527));
        try {
          (b2(t4) || b2(t4, s4.compile(e4, t4))).eval(t4, function(e5) {
            n4(null, e5);
          });
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.jqtpl = S2("jqtpl"), t3.jqtpl.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.jqtpl || (g2.jqtpl = r2(528));
        try {
          s4.template(e4, e4), n4(null, s4.tmpl(e4, t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.haml = S2("haml"), t3.haml.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.haml || (g2.haml = r2(529));
        try {
          t4.locals = t4, n4(null, s4.render(e4, t4).trimLeft());
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.hamlet = S2("hamlet"), t3.hamlet.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.hamlet || (g2.hamlet = r2(530));
        try {
          t4.locals = t4, n4(null, s4.render(e4, t4).trimLeft());
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.whiskers = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        (g2.whiskers || (g2.whiskers = r2(335))).__express(e4, t4, n4);
      });
    }, t3.whiskers.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.whiskers || (g2.whiskers = r2(335));
        try {
          n4(null, s4.render(e4, t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3["haml-coffee"] = S2("haml-coffee"), t3["haml-coffee"].render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2["haml-coffee"] || (g2["haml-coffee"] = r2(531));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.hogan = S2("hogan"), t3.hogan.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.hogan || (g2.hogan = r2(532));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4))).render(t4, t4.partials));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.templayed = S2("templayed"), t3.templayed.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.templayed || (g2.templayed = r2(533));
        try {
          n4(null, (b2(t4) || b2(t4, s4(e4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.handlebars = S2("handlebars"), t3.handlebars.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.handlebars || (g2.handlebars = r2(534));
        try {
          for (var i4 in t4.partials) s4.registerPartial(i4, t4.partials[i4]);
          for (var o4 in t4.helpers) s4.registerHelper(o4, t4.helpers[o4]);
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.underscore = S2("underscore"), t3.underscore.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.underscore || (g2.underscore = r2(535));
        try {
          const r3 = {};
          for (var i4 in t4.partials) r3[i4] = s4.template(t4.partials[i4]);
          t4.partials = r3, n4(null, (b2(t4) || b2(t4, s4.template(e4, null, t4)))(t4).replace(/\n$/, ""));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.lodash = S2("lodash"), t3.lodash.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.lodash || (g2.lodash = r2(536));
        try {
          n4(null, (b2(t4) || b2(t4, s4.template(e4, t4)))(t4).replace(/\n$/, ""));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.pug = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.pug;
        if (!s4) try {
          s4 = g2.pug = r2(336);
        } catch (e5) {
          try {
            s4 = g2.pug = r2(337);
          } catch (t5) {
            throw e5;
          }
        }
        try {
          n4(null, (b2(t4) || b2(t4, s4.compileFile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.pug.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.pug;
        if (!s4) try {
          s4 = g2.pug = r2(336);
        } catch (e5) {
          try {
            s4 = g2.pug = r2(337);
          } catch (t5) {
            throw e5;
          }
        }
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.qejs = S2("qejs"), t3.qejs.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        try {
          (g2.qejs || (g2.qejs = r2(537))).render(e4, t4).then(function(e5) {
            n4(null, e5);
          }, function(e5) {
            n4(e5);
          }).done();
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.walrus = S2("walrus"), t3.walrus.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.walrus || (g2.walrus = r2(538));
        try {
          n4(null, (b2(t4) || b2(t4, s4.parse(e4))).compile(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.mustache = S2("mustache"), t3.mustache.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.mustache || (g2.mustache = r2(539));
        try {
          n4(null, s4.render(e4, t4, t4.partials));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.just = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.just;
        if (!s4) {
          var i4 = r2(338);
          s4 = g2.just = new i4();
        }
        s4.configure({ useCache: t4.cache }), s4.render(e4, t4, n4);
      });
    }, t3.just.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        new (r2(338))({ root: { page: e4 } }).render("page", t4, n4);
      });
    }, t3.ect = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.ect;
        if (!s4) {
          var i4 = r2(339);
          s4 = g2.ect = new i4(t4);
        }
        s4.configure({ cache: t4.cache }), s4.render(e4, t4, n4);
      });
    }, t3.ect.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        new (r2(339))({ root: { page: e4 } }).render("page", t4, n4);
      });
    }, t3.mote = S2("mote"), t3.mote.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.mote || (g2.mote = r2(540));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.toffee = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        (g2.toffee || (g2.toffee = r2(340))).__consolidate_engine_render(e4, t4, n4);
      });
    }, t3.toffee.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.toffee || (g2.toffee = r2(340));
        try {
          s4.str_render(e4, t4, n4);
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.dot = S2("dot"), t3.dot.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.dot || (g2.dot = r2(541)), i4 = g2.extend || (g2.extend = d._extend);
        try {
          var o4 = {};
          o4 = i4(o4, s4.templateSettings), o4 = i4(o4, t4 ? t4.dot : {}), n4(null, (b2(t4) || b2(t4, s4.template(e4, o4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.bracket = S2("bracket"), t3.bracket.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.bracket || (g2.bracket = r2(542));
        try {
          n4(null, (b2(t4) || b2(t4, s4.default.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.ractive = S2("ractive"), t3.ractive.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.ractive || (g2.ractive = r2(543)), i4 = b2(t4) || b2(t4, s4.parse(e4));
        if (t4.template = i4, null === t4.data || void 0 === t4.data) {
          var o4, a4, l2 = g2.extend || (g2.extend = d._extend);
          t4.data = l2({}, t4);
          var c3 = ["template", "filename", "cache", "partials"];
          for (o4 = 0, a4 = c3.length; o4 < a4; o4++) {
            var u3 = c3[o4];
            delete t4.data[u3];
          }
        }
        try {
          n4(null, new s4(t4).toHTML());
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.nunjucks = S2("nunjucks"), t3.nunjucks.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        try {
          var s4 = t4.nunjucksEnv || g2.nunjucks || (g2.nunjucks = r2(544)), i4 = s4;
          t4.settings && t4.settings.views ? i4 = s4.configure(t4.settings.views) : t4.nunjucks && t4.nunjucks.configure && (i4 = s4.configure.apply(s4, t4.nunjucks.configure)), t4.loader ? i4 = new s4.Environment(t4.loader) : t4.settings && t4.settings.views ? i4 = new s4.Environment(new s4.FileSystemLoader(t4.settings.views)) : t4.nunjucks && t4.nunjucks.loader && (i4 = "string" == typeof t4.nunjucks.loader ? new s4.Environment(new s4.FileSystemLoader(t4.nunjucks.loader)) : new s4.Environment(new s4.FileSystemLoader(t4.nunjucks.loader[0], t4.nunjucks.loader[1]))), i4.renderString(e4, t4, n4);
        } catch (e5) {
          throw n4(e5);
        }
      });
    }, t3.htmling = S2("htmling"), t3.htmling.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.htmling || (g2.htmling = r2(545));
        try {
          n4(null, (b2(t4) || b2(t4, s4.string(e4))).render(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.requireReact = x2, t3.plates = S2("plates"), t3.plates.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.plates || (g2.plates = r2(546)), i4 = t4.map || void 0;
        try {
          n4(null, s4.bind(e4, t4, i4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.react = T2("path"), t3.react.render = T2("string"), t3["arc-templates"] = S2("arc-templates"), t3["arc-templates"].render = function(e4, t4, n3) {
      var s4 = o3.promisify(v2), i4 = { readFile: function(e5) {
        return s4(e5, t4);
      } };
      return E2(n3, function(n4) {
        try {
          var s5 = g2["arc-templates"];
          if (!s5) {
            var o4 = r2(549);
            s5 = g2["arc-templates"] = new o4({ filesystem: i4 });
          }
          (b2(t4) || b2(t4, s5.compileString(e4, t4.filename))).then(function(e5) {
            return e5(t4);
          }).then(function(e5) {
            n4(null, e5.content);
          }).catch(n4);
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.vash = S2("vash"), t3.vash.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.vash || (g2.vash = r2(550));
        try {
          if (t4.helpers) for (var i4 in t4.helpers) t4.helpers.hasOwnProperty(i4) && "function" == typeof t4.helpers[i4] && (s4.helpers[i4] = t4.helpers[i4]);
          (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4, function(e5, t5) {
            e5 && n4(e5), t5.finishLayout(), n4(null, t5.toString().replace(/\n$/, ""));
          });
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.slm = S2("slm"), t3.slm.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.slm || (g2.slm = r2(551));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.marko = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.marko || (g2.marko = r2(342));
        t4.writeToDisk = !!t4.cache;
        try {
          (b2(t4) || b2(t4, s4.load(e4, t4))).renderToString(t4, n4);
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.marko.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.marko || (g2.marko = r2(342));
        t4.writeToDisk = !!t4.cache, t4.filename = t4.filename || "string.marko";
        try {
          (b2(t4) || b2(t4, s4.load(t4.filename, e4, t4))).renderToString(t4, n4);
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.teacup = function(e4, t4, s4) {
      return E2(s4, function(s5) {
        var i4 = g2.teacup || (g2.teacup = r2(552));
        if (Fe.extensions[".teacup"] = Fe.extensions[".coffee"], "/" !== e4[0] && (e4 = a3(n2.cwd(), e4)), !t4.cache) {
          var o4 = s5;
          s5 = function() {
            delete r2.c[e4], o4.apply(this, arguments);
          };
        }
        i4.renderFile(e4, t4, s5);
      });
    }, t3.teacup.render = function(e4, t4, n3) {
      var s4 = r2(553), i4 = r2(554), o4 = { module: { exports: {} }, require: Fe };
      return E2(n3, function(r3) {
        i4.runInNewContext(s4.compile(e4), o4), r3(null, (0, o4.module.exports)(t4));
      });
    }, t3.squirrelly = S2("squirrelly"), t3.squirrelly.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.squirrelly || (g2.squirrelly = r2(555));
        try {
          for (var i4 in t4.partials) s4.definePartial(i4, t4.partials[i4]);
          for (var o4 in t4.helpers) s4.defineHelper(o4, t4.helpers[o4]);
          n4(null, (b2(t4) || b2(t4, s4.Compile(e4, t4)))(t4, s4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.twing = S2("twing"), t3.twing.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.twing || (g2.twing = r2(556));
        try {
          new s4.TwingEnvironment(new s4.TwingLoaderNull()).createTemplate(e4).then((e5) => {
            e5.render(t4).then((e6) => {
              var r3 = b2(t4) || b2(t4, e6);
              n4(null, r3);
            });
          });
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.requires = g2;
  }(Ue, Ue.exports);
  var $e = q(Ue.exports);
  const Ve = {};
  function qe(e3) {
    void 0 !== n2 || Ve[e3] || (Ve[e3] = true);
  }
  function We(e3, t3) {
    let { source: r3, filename: n3, preprocessOptions: s3 } = e3, i3 = "", o3 = null;
    if (t3.render(r3, { filename: n3, ...s3 }, (e4, t4) => {
      e4 && (o3 = e4), i3 = t4;
    }), o3) throw o3;
    return i3;
  }
  function Ge(e3) {
    const { preprocessLang: t3, preprocessCustomRequire: r3 } = e3, n3 = !!t3 && (r3 ? r3(t3) : $e[t3]);
    if (!n3) return t3 ? { code: "export default function render() {}", source: e3.source, tips: [`Component ${e3.filename} uses lang ${t3} for template. Please install the language preprocessor.`], errors: [`Component ${e3.filename} uses lang ${t3} for template, however it is not installed.`] } : He(e3);
    try {
      return He({ ...e3, source: We(e3, n3), ast: void 0 });
    } catch (t4) {
      return { code: "export default function render() {}", source: e3.source, tips: [], errors: [t4] };
    }
  }
  function He(e3) {
    let { filename: t3, id: r3, scoped: n3, slotted: s3, inMap: o3, source: l2, ast: u2, ssr: p2 = false, ssrCssVars: d2, isProd: f2 = false, compiler: h2, compilerOptions: m2 = {}, transformAssetUrls: y2 } = e3;
    const g2 = [], b2 = [];
    let v2 = [];
    if (c.isObject(y2)) {
      const e4 = Ne(y2);
      v2 = [De(e4), Be(e4)];
    } else false !== y2 && (v2 = [je, Re]);
    p2 && !d2 && qe("compileTemplate is called with `ssr: true` but no corresponding `cssVars` option.`."), r3 || (qe("compileTemplate now requires the `id` option.`."), r3 = "");
    const x2 = r3.replace(/^data-v-/, ""), T2 = `data-v-${x2}`, w2 = p2 ? S : E;
    if (h2 = h2 || w2, h2 !== w2 && (u2 = void 0), null == u2 ? void 0 : u2.transformed) {
      const e4 = (p2 ? E : h2).parse(u2.source, { prefixIdentifiers: true, ...m2, parseMode: "sfc", onError: (e5) => g2.push(e5) }).children.find((e5) => 1 === e5.type && "template" === e5.tag);
      u2 = i2.createRoot(e4.children, u2.source);
    }
    let { code: P2, ast: A2, preamble: C2, map: O2 } = h2.compile(u2 || l2, { mode: "module", prefixIdentifiers: true, hoistStatic: true, cacheHandlers: true, ssrCssVars: p2 && d2 && d2.length ? K(d2, x2, f2, true) : "", scopeId: n3 ? T2 : void 0, slotted: s3, sourceMap: true, ...m2, hmr: !f2, nodeTransforms: v2.concat(m2.nodeTransforms || []), filename: t3, onError: (e4) => g2.push(e4), onWarn: (e4) => b2.push(e4) });
    o3 && !u2 && (O2 && (O2 = function(e4, t4) {
      if (!e4) return t4;
      if (!t4) return e4;
      const r4 = new a2.SourceMapConsumer(e4), n4 = new a2.SourceMapConsumer(t4), s4 = new a2.SourceMapGenerator();
      n4.eachMapping((e5) => {
        if (null == e5.originalLine) return;
        const t5 = r4.originalPositionFor({ line: e5.originalLine, column: e5.originalColumn });
        null != t5.source && s4.addMapping({ generated: { line: e5.generatedLine, column: e5.generatedColumn }, original: { line: t5.line, column: e5.originalColumn }, source: t5.source, name: t5.name });
      });
      const i3 = s4;
      return r4.sources.forEach((e5) => {
        i3._sources.add(e5);
        const t5 = r4.sourceContentFor(e5);
        null != t5 && s4.setSourceContent(e5, t5);
      }), i3._sourceRoot = e4.sourceRoot, i3._file = e4.file, i3.toJSON();
    }(o3, O2)), g2.length && function(e4, t4, r4) {
      const n4 = r4.sourcesContent[0], s4 = n4.indexOf(t4), i3 = n4.slice(0, s4).split(/\r?\n/).length - 1;
      e4.forEach((e5) => {
        e5.loc && (e5.loc.start.line += i3, e5.loc.start.offset += s4, e5.loc.end !== e5.loc.start && (e5.loc.end.line += i3, e5.loc.end.offset += s4));
      });
    }(g2, l2, o3));
    const I2 = b2.map((e4) => {
      let t4 = e4.message;
      return e4.loc && (t4 += `
${c.generateCodeFrame((null == u2 ? void 0 : u2.source) || l2, e4.loc.start.offset, e4.loc.end.offset)}`), t4;
    });
    return { code: P2, ast: A2, preamble: C2, source: l2, errors: g2, tips: I2, map: O2 };
  }
  const ze = () => ({ postcssPlugin: "vue-sfc-trim", Once(e3) {
    e3.walk((e4) => {
      let { type: t3, raws: r3 } = e4;
      "rule" !== t3 && "atrule" !== t3 || (r3.before && (r3.before = "\n"), "after" in r3 && r3.after && (r3.after = "\n"));
    });
  } });
  ze.postcss = true;
  var Ke = ze, Xe = { exports: {} }, Je = { exports: {} }, Ye = { exports: {} }, Qe = { exports: {} }, Ze = { exports: {} }, et = { exports: {} }, tt = {}, rt = { exports: {} };
  !function(e3, t3) {
    function r3(e4) {
      for (var t4 = e4.toLowerCase(), r4 = "", n4 = false, s3 = 0; s3 < 6 && void 0 !== t4[s3]; s3++) {
        var i3 = t4.charCodeAt(s3);
        if (n4 = 32 === i3, !(i3 >= 97 && i3 <= 102 || i3 >= 48 && i3 <= 57)) break;
        r4 += t4[s3];
      }
      if (0 !== r4.length) {
        var o3 = parseInt(r4, 16);
        return o3 >= 55296 && o3 <= 57343 || 0 === o3 || o3 > 1114111 ? ["�", r4.length + (n4 ? 1 : 0)] : [String.fromCodePoint(o3), r4.length + (n4 ? 1 : 0)];
      }
    }
    t3.__esModule = true, t3.default = function(e4) {
      if (!n3.test(e4)) return e4;
      for (var t4 = "", s3 = 0; s3 < e4.length; s3++) if ("\\" !== e4[s3]) t4 += e4[s3];
      else {
        var i3 = r3(e4.slice(s3 + 1, s3 + 7));
        if (void 0 !== i3) {
          t4 += i3[0], s3 += i3[1];
          continue;
        }
        if ("\\" === e4[s3 + 1]) {
          t4 += "\\", s3++;
          continue;
        }
        e4.length === s3 + 1 && (t4 += e4[s3]);
      }
      return t4;
    };
    var n3 = /\\/;
    e3.exports = t3.default;
  }(rt, rt.exports);
  var nt = rt.exports, st = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = function(e4) {
      for (var t4 = arguments.length, r3 = new Array(t4 > 1 ? t4 - 1 : 0), n3 = 1; n3 < t4; n3++) r3[n3 - 1] = arguments[n3];
      for (; r3.length > 0; ) {
        var s3 = r3.shift();
        if (!e4[s3]) return;
        e4 = e4[s3];
      }
      return e4;
    }, e3.exports = t3.default;
  }(st, st.exports);
  var it = st.exports, ot = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = function(e4) {
      for (var t4 = arguments.length, r3 = new Array(t4 > 1 ? t4 - 1 : 0), n3 = 1; n3 < t4; n3++) r3[n3 - 1] = arguments[n3];
      for (; r3.length > 0; ) {
        var s3 = r3.shift();
        e4[s3] || (e4[s3] = {}), e4 = e4[s3];
      }
    }, e3.exports = t3.default;
  }(ot, ot.exports);
  var at = ot.exports, lt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = function(e4) {
      for (var t4 = "", r3 = e4.indexOf("/*"), n3 = 0; r3 >= 0; ) {
        t4 += e4.slice(n3, r3);
        var s3 = e4.indexOf("*/", r3 + 2);
        if (s3 < 0) return t4;
        n3 = s3 + 2, r3 = e4.indexOf("/*", n3);
      }
      return t4 += e4.slice(n3);
    }, e3.exports = t3.default;
  }(lt, lt.exports);
  var ct = lt.exports;
  tt.__esModule = true, tt.unesc = tt.stripComments = tt.getProp = tt.ensureObject = void 0;
  var ut = ht(nt);
  tt.unesc = ut.default;
  var pt = ht(it);
  tt.getProp = pt.default;
  var dt = ht(at);
  tt.ensureObject = dt.default;
  var ft = ht(ct);
  function ht(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  }
  tt.stripComments = ft.default, function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3 = tt;
    function n3(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    var s3 = function e4(t4, r4) {
      if ("object" != typeof t4 || null === t4) return t4;
      var n4 = new t4.constructor();
      for (var s4 in t4) if (t4.hasOwnProperty(s4)) {
        var i4 = t4[s4];
        "parent" === s4 && "object" == typeof i4 ? r4 && (n4[s4] = r4) : n4[s4] = i4 instanceof Array ? i4.map(function(t5) {
          return e4(t5, n4);
        }) : e4(i4, n4);
      }
      return n4;
    }, i3 = function() {
      function e4(e5) {
        void 0 === e5 && (e5 = {}), Object.assign(this, e5), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
      }
      var t4, i4, o3 = e4.prototype;
      return o3.remove = function() {
        return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
      }, o3.replaceWith = function() {
        if (this.parent) {
          for (var e5 in arguments) this.parent.insertBefore(this, arguments[e5]);
          this.remove();
        }
        return this;
      }, o3.next = function() {
        return this.parent.at(this.parent.index(this) + 1);
      }, o3.prev = function() {
        return this.parent.at(this.parent.index(this) - 1);
      }, o3.clone = function(e5) {
        void 0 === e5 && (e5 = {});
        var t5 = s3(this);
        for (var r4 in e5) t5[r4] = e5[r4];
        return t5;
      }, o3.appendToPropertyAndEscape = function(e5, t5, r4) {
        this.raws || (this.raws = {});
        var n4 = this[e5], s4 = this.raws[e5];
        this[e5] = n4 + t5, s4 || r4 !== t5 ? this.raws[e5] = (s4 || n4) + r4 : delete this.raws[e5];
      }, o3.setPropertyAndEscape = function(e5, t5, r4) {
        this.raws || (this.raws = {}), this[e5] = t5, this.raws[e5] = r4;
      }, o3.setPropertyWithoutEscape = function(e5, t5) {
        this[e5] = t5, this.raws && delete this.raws[e5];
      }, o3.isAtPosition = function(e5, t5) {
        if (this.source && this.source.start && this.source.end) return !(this.source.start.line > e5 || this.source.end.line < e5 || this.source.start.line === e5 && this.source.start.column > t5 || this.source.end.line === e5 && this.source.end.column < t5);
      }, o3.stringifyProperty = function(e5) {
        return this.raws && this.raws[e5] || this[e5];
      }, o3.valueToString = function() {
        return String(this.stringifyProperty("value"));
      }, o3.toString = function() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      }, t4 = e4, (i4 = [{ key: "rawSpaceBefore", get: function() {
        var e5 = this.raws && this.raws.spaces && this.raws.spaces.before;
        return void 0 === e5 && (e5 = this.spaces && this.spaces.before), e5 || "";
      }, set: function(e5) {
        (0, r3.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = e5;
      } }, { key: "rawSpaceAfter", get: function() {
        var e5 = this.raws && this.raws.spaces && this.raws.spaces.after;
        return void 0 === e5 && (e5 = this.spaces.after), e5 || "";
      }, set: function(e5) {
        (0, r3.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = e5;
      } }]) && n3(t4.prototype, i4), Object.defineProperty(t4, "prototype", { writable: false }), e4;
    }();
    t3.default = i3, e3.exports = t3.default;
  }(et, et.exports);
  var mt = et.exports, yt = { __esModule: true };
  yt.UNIVERSAL = yt.TAG = yt.STRING = yt.SELECTOR = yt.ROOT = yt.PSEUDO = yt.NESTING = yt.ID = yt.COMMENT = yt.COMBINATOR = yt.CLASS = yt.ATTRIBUTE = void 0, yt.TAG = "tag", yt.STRING = "string", yt.SELECTOR = "selector", yt.ROOT = "root", yt.PSEUDO = "pseudo", yt.NESTING = "nesting", yt.ID = "id", yt.COMMENT = "comment", yt.COMBINATOR = "combinator", yt.CLASS = "class", yt.ATTRIBUTE = "attribute", yt.UNIVERSAL = "universal", function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = mt) && r3.__esModule ? r3 : { default: r3 }, s3 = function(e4, t4) {
      if (e4 && e4.__esModule) return e4;
      if (null === e4 || "object" != typeof e4 && "function" != typeof e4) return { default: e4 };
      var r4 = i3(t4);
      if (r4 && r4.has(e4)) return r4.get(e4);
      var n4 = {}, s4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var o4 in e4) if ("default" !== o4 && Object.prototype.hasOwnProperty.call(e4, o4)) {
        var a4 = s4 ? Object.getOwnPropertyDescriptor(e4, o4) : null;
        a4 && (a4.get || a4.set) ? Object.defineProperty(n4, o4, a4) : n4[o4] = e4[o4];
      }
      return n4.default = e4, r4 && r4.set(e4, n4), n4;
    }(yt);
    function i3(e4) {
      if ("function" != typeof WeakMap) return null;
      var t4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
      return (i3 = function(e5) {
        return e5 ? r4 : t4;
      })(e4);
    }
    function o3(e4, t4) {
      (null == t4 || t4 > e4.length) && (t4 = e4.length);
      for (var r4 = 0, n4 = new Array(t4); r4 < t4; r4++) n4[r4] = e4[r4];
      return n4;
    }
    function a3(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    function l2(e4, t4) {
      return l2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, l2(e4, t4);
    }
    var c2 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).nodes || (r5.nodes = []), r5;
      }
      r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, l2(t4, r4);
      var i4, c3, u2 = n4.prototype;
      return u2.append = function(e5) {
        return e5.parent = this, this.nodes.push(e5), this;
      }, u2.prepend = function(e5) {
        return e5.parent = this, this.nodes.unshift(e5), this;
      }, u2.at = function(e5) {
        return this.nodes[e5];
      }, u2.index = function(e5) {
        return "number" == typeof e5 ? e5 : this.nodes.indexOf(e5);
      }, u2.removeChild = function(e5) {
        var t5;
        for (var r5 in e5 = this.index(e5), this.at(e5).parent = void 0, this.nodes.splice(e5, 1), this.indexes) (t5 = this.indexes[r5]) >= e5 && (this.indexes[r5] = t5 - 1);
        return this;
      }, u2.removeAll = function() {
        for (var e5, t5 = function(e6, t6) {
          var r5 = "undefined" != typeof Symbol && e6[Symbol.iterator] || e6["@@iterator"];
          if (r5) return (r5 = r5.call(e6)).next.bind(r5);
          if (Array.isArray(e6) || (r5 = function(e7, t7) {
            if (e7) {
              if ("string" == typeof e7) return o3(e7, t7);
              var r6 = Object.prototype.toString.call(e7).slice(8, -1);
              return "Object" === r6 && e7.constructor && (r6 = e7.constructor.name), "Map" === r6 || "Set" === r6 ? Array.from(e7) : "Arguments" === r6 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r6) ? o3(e7, t7) : void 0;
            }
          }(e6)) || t6 && e6 && "number" == typeof e6.length) {
            r5 && (e6 = r5);
            var n5 = 0;
            return function() {
              return n5 >= e6.length ? { done: true } : { done: false, value: e6[n5++] };
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }(this.nodes); !(e5 = t5()).done; ) e5.value.parent = void 0;
        return this.nodes = [], this;
      }, u2.empty = function() {
        return this.removeAll();
      }, u2.insertAfter = function(e5, t5) {
        t5.parent = this;
        var r5, n5 = this.index(e5);
        for (var s4 in this.nodes.splice(n5 + 1, 0, t5), t5.parent = this, this.indexes) n5 <= (r5 = this.indexes[s4]) && (this.indexes[s4] = r5 + 1);
        return this;
      }, u2.insertBefore = function(e5, t5) {
        t5.parent = this;
        var r5, n5 = this.index(e5);
        for (var s4 in this.nodes.splice(n5, 0, t5), t5.parent = this, this.indexes) (r5 = this.indexes[s4]) <= n5 && (this.indexes[s4] = r5 + 1);
        return this;
      }, u2._findChildAtPosition = function(e5, t5) {
        var r5 = void 0;
        return this.each(function(n5) {
          if (n5.atPosition) {
            var s4 = n5.atPosition(e5, t5);
            if (s4) return r5 = s4, false;
          } else if (n5.isAtPosition(e5, t5)) return r5 = n5, false;
        }), r5;
      }, u2.atPosition = function(e5, t5) {
        return this.isAtPosition(e5, t5) ? this._findChildAtPosition(e5, t5) || this : void 0;
      }, u2._inferEndPosition = function() {
        this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
      }, u2.each = function(e5) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var t5 = this.lastEach;
        if (this.indexes[t5] = 0, this.length) {
          for (var r5, n5; this.indexes[t5] < this.length && (r5 = this.indexes[t5], false !== (n5 = e5(this.at(r5), r5))); ) this.indexes[t5] += 1;
          return delete this.indexes[t5], false !== n5 && void 0;
        }
      }, u2.walk = function(e5) {
        return this.each(function(t5, r5) {
          var n5 = e5(t5, r5);
          if (false !== n5 && t5.length && (n5 = t5.walk(e5)), false === n5) return false;
        });
      }, u2.walkAttributes = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.ATTRIBUTE) return e5.call(t5, r5);
        });
      }, u2.walkClasses = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.CLASS) return e5.call(t5, r5);
        });
      }, u2.walkCombinators = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.COMBINATOR) return e5.call(t5, r5);
        });
      }, u2.walkComments = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.COMMENT) return e5.call(t5, r5);
        });
      }, u2.walkIds = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.ID) return e5.call(t5, r5);
        });
      }, u2.walkNesting = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.NESTING) return e5.call(t5, r5);
        });
      }, u2.walkPseudos = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.PSEUDO) return e5.call(t5, r5);
        });
      }, u2.walkTags = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.TAG) return e5.call(t5, r5);
        });
      }, u2.walkUniversals = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.UNIVERSAL) return e5.call(t5, r5);
        });
      }, u2.split = function(e5) {
        var t5 = this, r5 = [];
        return this.reduce(function(n5, s4, i5) {
          var o4 = e5.call(t5, s4);
          return r5.push(s4), o4 ? (n5.push(r5), r5 = []) : i5 === t5.length - 1 && n5.push(r5), n5;
        }, []);
      }, u2.map = function(e5) {
        return this.nodes.map(e5);
      }, u2.reduce = function(e5, t5) {
        return this.nodes.reduce(e5, t5);
      }, u2.every = function(e5) {
        return this.nodes.every(e5);
      }, u2.some = function(e5) {
        return this.nodes.some(e5);
      }, u2.filter = function(e5) {
        return this.nodes.filter(e5);
      }, u2.sort = function(e5) {
        return this.nodes.sort(e5);
      }, u2.toString = function() {
        return this.map(String).join("");
      }, i4 = n4, (c3 = [{ key: "first", get: function() {
        return this.at(0);
      } }, { key: "last", get: function() {
        return this.at(this.length - 1);
      } }, { key: "length", get: function() {
        return this.nodes.length;
      } }]) && a3(i4.prototype, c3), Object.defineProperty(i4, "prototype", { writable: false }), n4;
    }(n3.default);
    t3.default = c2, e3.exports = t3.default;
  }(Ze, Ze.exports);
  var gt = Ze.exports;
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = gt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    function o3(e4, t4) {
      return o3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, o3(e4, t4);
    }
    var a3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.ROOT, r5;
      }
      r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, o3(t4, r4);
      var a4, l2, c2 = n4.prototype;
      return c2.toString = function() {
        var e5 = this.reduce(function(e6, t5) {
          return e6.push(String(t5)), e6;
        }, []).join(",");
        return this.trailingComma ? e5 + "," : e5;
      }, c2.error = function(e5, t5) {
        return this._error ? this._error(e5, t5) : new Error(e5);
      }, a4 = n4, (l2 = [{ key: "errorGenerator", set: function(e5) {
        this._error = e5;
      } }]) && i3(a4.prototype, l2), Object.defineProperty(a4, "prototype", { writable: false }), n4;
    }(n3.default);
    t3.default = a3, e3.exports = t3.default;
  }(Qe, Qe.exports);
  var bt = Qe.exports, vt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = gt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.SELECTOR, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(vt, vt.exports);
  var Et = vt.exports, St = { exports: {} }, xt = {}.hasOwnProperty, Tt = /[ -,\.\/:-@\[-\^`\{-~]/, wt = /[ -,\.\/:-@\[\]\^`\{-~]/, Pt = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, At = function e3(t3, r3) {
    "single" != (r3 = function(e4, t4) {
      if (!e4) return t4;
      var r4 = {};
      for (var n4 in t4) r4[n4] = xt.call(e4, n4) ? e4[n4] : t4[n4];
      return r4;
    }(r3, e3.options)).quotes && "double" != r3.quotes && (r3.quotes = "single");
    for (var n3 = "double" == r3.quotes ? '"' : "'", s3 = r3.isIdentifier, i3 = t3.charAt(0), o3 = "", a3 = 0, l2 = t3.length; a3 < l2; ) {
      var c2 = t3.charAt(a3++), u2 = c2.charCodeAt(), p2 = void 0;
      if (u2 < 32 || u2 > 126) {
        if (u2 >= 55296 && u2 <= 56319 && a3 < l2) {
          var d2 = t3.charCodeAt(a3++);
          56320 == (64512 & d2) ? u2 = ((1023 & u2) << 10) + (1023 & d2) + 65536 : a3--;
        }
        p2 = "\\" + u2.toString(16).toUpperCase() + " ";
      } else p2 = r3.escapeEverything ? Tt.test(c2) ? "\\" + c2 : "\\" + u2.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(c2) ? "\\" + u2.toString(16).toUpperCase() + " " : "\\" == c2 || !s3 && ('"' == c2 && n3 == c2 || "'" == c2 && n3 == c2) || s3 && wt.test(c2) ? "\\" + c2 : c2;
      o3 += p2;
    }
    return s3 && (/^-[-\d]/.test(o3) ? o3 = "\\-" + o3.slice(1) : /\d/.test(i3) && (o3 = "\\3" + i3 + " " + o3.slice(1))), o3 = o3.replace(Pt, function(e4, t4, r4) {
      return t4 && t4.length % 2 ? e4 : (t4 || "") + r4;
    }), !s3 && r3.wrap ? n3 + o3 + n3 : o3;
  };
  At.options = { escapeEverything: false, isIdentifier: false, quotes: "single", wrap: false }, At.version = "3.0.0";
  var Ct = At;
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3 = o3(Ct), n3 = tt, s3 = o3(mt), i3 = yt;
    function o3(e4) {
      return e4 && e4.__esModule ? e4 : { default: e4 };
    }
    function a3(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    function l2(e4, t4) {
      return l2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, l2(e4, t4);
    }
    var c2 = function(e4) {
      var t4, s4, o4, c3;
      function u2(t5) {
        var r4;
        return (r4 = e4.call(this, t5) || this).type = i3.CLASS, r4._constructed = true, r4;
      }
      return s4 = e4, (t4 = u2).prototype = Object.create(s4.prototype), t4.prototype.constructor = t4, l2(t4, s4), u2.prototype.valueToString = function() {
        return "." + e4.prototype.valueToString.call(this);
      }, o4 = u2, (c3 = [{ key: "value", get: function() {
        return this._value;
      }, set: function(e5) {
        if (this._constructed) {
          var t5 = (0, r3.default)(e5, { isIdentifier: true });
          t5 !== e5 ? ((0, n3.ensureObject)(this, "raws"), this.raws.value = t5) : this.raws && delete this.raws.value;
        }
        this._value = e5;
      } }]) && a3(o4.prototype, c3), Object.defineProperty(o4, "prototype", { writable: false }), u2;
    }(s3.default);
    t3.default = c2, e3.exports = t3.default;
  }(St, St.exports);
  var Ot = St.exports, It = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = mt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.COMMENT, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(It, It.exports);
  var _t = It.exports, kt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = mt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.ID, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4.prototype.valueToString = function() {
        return "#" + e4.prototype.valueToString.call(this);
      }, n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(kt, kt.exports);
  var Nt = kt.exports, Dt = { exports: {} }, jt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3 = s3(Ct), n3 = tt;
    function s3(e4) {
      return e4 && e4.__esModule ? e4 : { default: e4 };
    }
    function i3(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    function o3(e4, t4) {
      return o3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, o3(e4, t4);
    }
    var a3 = function(e4) {
      var t4, s4;
      function a4() {
        return e4.apply(this, arguments) || this;
      }
      s4 = e4, (t4 = a4).prototype = Object.create(s4.prototype), t4.prototype.constructor = t4, o3(t4, s4);
      var l2, c2, u2 = a4.prototype;
      return u2.qualifiedName = function(e5) {
        return this.namespace ? this.namespaceString + "|" + e5 : e5;
      }, u2.valueToString = function() {
        return this.qualifiedName(e4.prototype.valueToString.call(this));
      }, l2 = a4, c2 = [{ key: "namespace", get: function() {
        return this._namespace;
      }, set: function(e5) {
        if (true === e5 || "*" === e5 || "&" === e5) return this._namespace = e5, void (this.raws && delete this.raws.namespace);
        var t5 = (0, r3.default)(e5, { isIdentifier: true });
        this._namespace = e5, t5 !== e5 ? ((0, n3.ensureObject)(this, "raws"), this.raws.namespace = t5) : this.raws && delete this.raws.namespace;
      } }, { key: "ns", get: function() {
        return this._namespace;
      }, set: function(e5) {
        this.namespace = e5;
      } }, { key: "namespaceString", get: function() {
        if (this.namespace) {
          var e5 = this.stringifyProperty("namespace");
          return true === e5 ? "" : e5;
        }
        return "";
      } }], c2 && i3(l2.prototype, c2), Object.defineProperty(l2, "prototype", { writable: false }), a4;
    }(s3(mt).default);
    t3.default = a3, e3.exports = t3.default;
  }(jt, jt.exports);
  var Lt = jt.exports;
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = Lt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.TAG, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(Dt, Dt.exports);
  var Mt = Dt.exports, Bt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = mt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.STRING, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(Bt, Bt.exports);
  var Rt = Bt.exports, Ft = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = gt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.PSEUDO, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4.prototype.toString = function() {
        var e5 = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), e5, this.rawSpaceAfter].join("");
      }, n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(Ft, Ft.exports);
  var Ut = Ft.exports, $t = {}, Vt = d.deprecate;
  !function(e3) {
    e3.__esModule = true, e3.default = void 0, e3.unescapeValue = h2;
    var t3, r3 = o3(Ct), n3 = o3(nt), s3 = o3(Lt), i3 = yt;
    function o3(e4) {
      return e4 && e4.__esModule ? e4 : { default: e4 };
    }
    function a3(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    function l2(e4, t4) {
      return l2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, l2(e4, t4);
    }
    var c2 = Vt, u2 = /^('|")([^]*)\1$/, p2 = c2(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), d2 = c2(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), f2 = c2(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function h2(e4) {
      var t4 = false, r4 = null, s4 = e4, i4 = s4.match(u2);
      return i4 && (r4 = i4[1], s4 = i4[2]), (s4 = (0, n3.default)(s4)) !== e4 && (t4 = true), { deprecatedUsage: t4, unescaped: s4, quoteMark: r4 };
    }
    var m2 = function(e4) {
      var t4, n4;
      function s4(t5) {
        var r4;
        return void 0 === t5 && (t5 = {}), r4 = e4.call(this, function(e5) {
          if (void 0 !== e5.quoteMark) return e5;
          if (void 0 === e5.value) return e5;
          f2();
          var t6 = h2(e5.value), r5 = t6.quoteMark, n5 = t6.unescaped;
          return e5.raws || (e5.raws = {}), void 0 === e5.raws.value && (e5.raws.value = e5.value), e5.value = n5, e5.quoteMark = r5, e5;
        }(t5)) || this, r4.type = i3.ATTRIBUTE, r4.raws = r4.raws || {}, Object.defineProperty(r4.raws, "unquoted", { get: c2(function() {
          return r4.value;
        }, "attr.raws.unquoted is deprecated. Call attr.value instead."), set: c2(function() {
          return r4.value;
        }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") }), r4._constructed = true, r4;
      }
      n4 = e4, (t4 = s4).prototype = Object.create(n4.prototype), t4.prototype.constructor = t4, l2(t4, n4);
      var o4, u3, m3 = s4.prototype;
      return m3.getQuotedValue = function(e5) {
        void 0 === e5 && (e5 = {});
        var t5 = this._determineQuoteMark(e5), n5 = y2[t5];
        return (0, r3.default)(this._value, n5);
      }, m3._determineQuoteMark = function(e5) {
        return e5.smart ? this.smartQuoteMark(e5) : this.preferredQuoteMark(e5);
      }, m3.setValue = function(e5, t5) {
        void 0 === t5 && (t5 = {}), this._value = e5, this._quoteMark = this._determineQuoteMark(t5), this._syncRawValue();
      }, m3.smartQuoteMark = function(e5) {
        var t5 = this.value, n5 = t5.replace(/[^']/g, "").length, i4 = t5.replace(/[^"]/g, "").length;
        if (n5 + i4 === 0) {
          var o5 = (0, r3.default)(t5, { isIdentifier: true });
          if (o5 === t5) return s4.NO_QUOTE;
          var a4 = this.preferredQuoteMark(e5);
          if (a4 === s4.NO_QUOTE) {
            var l3 = this.quoteMark || e5.quoteMark || s4.DOUBLE_QUOTE, c3 = y2[l3];
            if ((0, r3.default)(t5, c3).length < o5.length) return l3;
          }
          return a4;
        }
        return i4 === n5 ? this.preferredQuoteMark(e5) : i4 < n5 ? s4.DOUBLE_QUOTE : s4.SINGLE_QUOTE;
      }, m3.preferredQuoteMark = function(e5) {
        var t5 = e5.preferCurrentQuoteMark ? this.quoteMark : e5.quoteMark;
        return void 0 === t5 && (t5 = e5.preferCurrentQuoteMark ? e5.quoteMark : this.quoteMark), void 0 === t5 && (t5 = s4.DOUBLE_QUOTE), t5;
      }, m3._syncRawValue = function() {
        var e5 = (0, r3.default)(this._value, y2[this.quoteMark]);
        e5 === this._value ? this.raws && delete this.raws.value : this.raws.value = e5;
      }, m3._handleEscapes = function(e5, t5) {
        if (this._constructed) {
          var n5 = (0, r3.default)(t5, { isIdentifier: true });
          n5 !== t5 ? this.raws[e5] = n5 : delete this.raws[e5];
        }
      }, m3._spacesFor = function(e5) {
        var t5 = this.spaces[e5] || {}, r4 = this.raws.spaces && this.raws.spaces[e5] || {};
        return Object.assign({ before: "", after: "" }, t5, r4);
      }, m3._stringFor = function(e5, t5, r4) {
        void 0 === t5 && (t5 = e5), void 0 === r4 && (r4 = g2);
        var n5 = this._spacesFor(t5);
        return r4(this.stringifyProperty(e5), n5);
      }, m3.offsetOf = function(e5) {
        var t5 = 1, r4 = this._spacesFor("attribute");
        if (t5 += r4.before.length, "namespace" === e5 || "ns" === e5) return this.namespace ? t5 : -1;
        if ("attributeNS" === e5) return t5;
        if (t5 += this.namespaceString.length, this.namespace && (t5 += 1), "attribute" === e5) return t5;
        t5 += this.stringifyProperty("attribute").length, t5 += r4.after.length;
        var n5 = this._spacesFor("operator");
        t5 += n5.before.length;
        var s5 = this.stringifyProperty("operator");
        if ("operator" === e5) return s5 ? t5 : -1;
        t5 += s5.length, t5 += n5.after.length;
        var i4 = this._spacesFor("value");
        t5 += i4.before.length;
        var o5 = this.stringifyProperty("value");
        return "value" === e5 ? o5 ? t5 : -1 : (t5 += o5.length, t5 += i4.after.length, t5 += this._spacesFor("insensitive").before.length, "insensitive" === e5 && this.insensitive ? t5 : -1);
      }, m3.toString = function() {
        var e5 = this, t5 = [this.rawSpaceBefore, "["];
        return t5.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || "" === this.value) && (t5.push(this._stringFor("operator")), t5.push(this._stringFor("value")), t5.push(this._stringFor("insensitiveFlag", "insensitive", function(t6, r4) {
          return !(t6.length > 0) || e5.quoted || 0 !== r4.before.length || e5.spaces.value && e5.spaces.value.after || (r4.before = " "), g2(t6, r4);
        }))), t5.push("]"), t5.push(this.rawSpaceAfter), t5.join("");
      }, o4 = s4, (u3 = [{ key: "quoted", get: function() {
        var e5 = this.quoteMark;
        return "'" === e5 || '"' === e5;
      }, set: function(e5) {
        d2();
      } }, { key: "quoteMark", get: function() {
        return this._quoteMark;
      }, set: function(e5) {
        this._constructed ? this._quoteMark !== e5 && (this._quoteMark = e5, this._syncRawValue()) : this._quoteMark = e5;
      } }, { key: "qualifiedAttribute", get: function() {
        return this.qualifiedName(this.raws.attribute || this.attribute);
      } }, { key: "insensitiveFlag", get: function() {
        return this.insensitive ? "i" : "";
      } }, { key: "value", get: function() {
        return this._value;
      }, set: function(e5) {
        if (this._constructed) {
          var t5 = h2(e5), r4 = t5.deprecatedUsage, n5 = t5.unescaped, s5 = t5.quoteMark;
          if (r4 && p2(), n5 === this._value && s5 === this._quoteMark) return;
          this._value = n5, this._quoteMark = s5, this._syncRawValue();
        } else this._value = e5;
      } }, { key: "insensitive", get: function() {
        return this._insensitive;
      }, set: function(e5) {
        e5 || (this._insensitive = false, !this.raws || "I" !== this.raws.insensitiveFlag && "i" !== this.raws.insensitiveFlag || (this.raws.insensitiveFlag = void 0)), this._insensitive = e5;
      } }, { key: "attribute", get: function() {
        return this._attribute;
      }, set: function(e5) {
        this._handleEscapes("attribute", e5), this._attribute = e5;
      } }]) && a3(o4.prototype, u3), Object.defineProperty(o4, "prototype", { writable: false }), s4;
    }(s3.default);
    e3.default = m2, m2.NO_QUOTE = null, m2.SINGLE_QUOTE = "'", m2.DOUBLE_QUOTE = '"';
    var y2 = ((t3 = { "'": { quotes: "single", wrap: true }, '"': { quotes: "double", wrap: true } }).null = { isIdentifier: true }, t3);
    function g2(e4, t4) {
      return "" + t4.before + e4 + t4.after;
    }
  }($t);
  var qt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = Lt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.UNIVERSAL, r5.value = "*", r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(qt, qt.exports);
  var Wt = qt.exports, Gt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = mt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.COMBINATOR, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(Gt, Gt.exports);
  var Ht = Gt.exports, zt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = mt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.NESTING, r5.value = "&", r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(zt, zt.exports);
  var Kt = zt.exports, Xt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = function(e4) {
      return e4.sort(function(e5, t4) {
        return e5 - t4;
      });
    }, e3.exports = t3.default;
  }(Xt, Xt.exports);
  var Jt = Xt.exports, Yt = {}, Qt = { __esModule: true };
  Qt.word = Qt.tilde = Qt.tab = Qt.str = Qt.space = Qt.slash = Qt.singleQuote = Qt.semicolon = Qt.plus = Qt.pipe = Qt.openSquare = Qt.openParenthesis = Qt.newline = Qt.greaterThan = Qt.feed = Qt.equals = Qt.doubleQuote = Qt.dollar = Qt.cr = Qt.comment = Qt.comma = Qt.combinator = Qt.colon = Qt.closeSquare = Qt.closeParenthesis = Qt.caret = Qt.bang = Qt.backslash = Qt.at = Qt.asterisk = Qt.ampersand = void 0, Qt.ampersand = 38, Qt.asterisk = 42, Qt.at = 64, Qt.comma = 44, Qt.colon = 58, Qt.semicolon = 59, Qt.openParenthesis = 40, Qt.closeParenthesis = 41, Qt.openSquare = 91, Qt.closeSquare = 93, Qt.dollar = 36, Qt.tilde = 126, Qt.caret = 94, Qt.plus = 43, Qt.equals = 61, Qt.pipe = 124, Qt.greaterThan = 62, Qt.space = 32, Qt.singleQuote = 39, Qt.doubleQuote = 34, Qt.slash = 47, Qt.bang = 33, Qt.backslash = 92, Qt.cr = 13, Qt.feed = 12, Qt.newline = 10, Qt.tab = 9, Qt.str = 39, Qt.comment = -1, Qt.word = -2, Qt.combinator = -3, function(e3) {
    e3.__esModule = true, e3.FIELDS = void 0, e3.default = function(e4) {
      var t4, r4, s4, i4, o4, a4, l3, u3, p2, d2, f2, h2, m2 = [], y2 = e4.css.valueOf(), g2 = y2.length, b2 = -1, v2 = 1, E2 = 0, S2 = 0;
      function x2(t5, r5) {
        if (!e4.safe) throw e4.error("Unclosed " + t5, v2, E2 - b2, E2);
        u3 = (y2 += r5).length - 1;
      }
      for (; E2 < g2; ) {
        switch ((t4 = y2.charCodeAt(E2)) === n3.newline && (b2 = E2, v2 += 1), t4) {
          case n3.space:
          case n3.tab:
          case n3.newline:
          case n3.cr:
          case n3.feed:
            u3 = E2;
            do {
              u3 += 1, (t4 = y2.charCodeAt(u3)) === n3.newline && (b2 = u3, v2 += 1);
            } while (t4 === n3.space || t4 === n3.newline || t4 === n3.tab || t4 === n3.cr || t4 === n3.feed);
            h2 = n3.space, s4 = v2, r4 = u3 - b2 - 1, S2 = u3;
            break;
          case n3.plus:
          case n3.greaterThan:
          case n3.tilde:
          case n3.pipe:
            u3 = E2;
            do {
              u3 += 1, t4 = y2.charCodeAt(u3);
            } while (t4 === n3.plus || t4 === n3.greaterThan || t4 === n3.tilde || t4 === n3.pipe);
            h2 = n3.combinator, s4 = v2, r4 = E2 - b2, S2 = u3;
            break;
          case n3.asterisk:
          case n3.ampersand:
          case n3.bang:
          case n3.comma:
          case n3.equals:
          case n3.dollar:
          case n3.caret:
          case n3.openSquare:
          case n3.closeSquare:
          case n3.colon:
          case n3.semicolon:
          case n3.openParenthesis:
          case n3.closeParenthesis:
            h2 = t4, s4 = v2, r4 = E2 - b2, S2 = (u3 = E2) + 1;
            break;
          case n3.singleQuote:
          case n3.doubleQuote:
            f2 = t4 === n3.singleQuote ? "'" : '"', u3 = E2;
            do {
              for (i4 = false, -1 === (u3 = y2.indexOf(f2, u3 + 1)) && x2("quote", f2), o4 = u3; y2.charCodeAt(o4 - 1) === n3.backslash; ) o4 -= 1, i4 = !i4;
            } while (i4);
            h2 = n3.str, s4 = v2, r4 = E2 - b2, S2 = u3 + 1;
            break;
          default:
            t4 === n3.slash && y2.charCodeAt(E2 + 1) === n3.asterisk ? (0 === (u3 = y2.indexOf("*/", E2 + 2) + 1) && x2("comment", "*/"), (a4 = (l3 = y2.slice(E2, u3 + 1).split("\n")).length - 1) > 0 ? (p2 = v2 + a4, d2 = u3 - l3[a4].length) : (p2 = v2, d2 = b2), h2 = n3.comment, v2 = p2, s4 = p2, r4 = u3 - d2) : t4 === n3.slash ? (h2 = t4, s4 = v2, r4 = E2 - b2, S2 = (u3 = E2) + 1) : (u3 = c2(y2, E2), h2 = n3.word, s4 = v2, r4 = u3 - b2), S2 = u3 + 1;
        }
        m2.push([h2, v2, E2 - b2, s4, r4, E2, S2]), d2 && (b2 = d2, d2 = null), E2 = S2;
      }
      return m2;
    };
    var t3, r3, n3 = function(e4, t4) {
      if (e4 && e4.__esModule) return e4;
      if (null === e4 || "object" != typeof e4 && "function" != typeof e4) return { default: e4 };
      var r4 = s3(t4);
      if (r4 && r4.has(e4)) return r4.get(e4);
      var n4 = {}, i4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var o4 in e4) if ("default" !== o4 && Object.prototype.hasOwnProperty.call(e4, o4)) {
        var a4 = i4 ? Object.getOwnPropertyDescriptor(e4, o4) : null;
        a4 && (a4.get || a4.set) ? Object.defineProperty(n4, o4, a4) : n4[o4] = e4[o4];
      }
      return n4.default = e4, r4 && r4.set(e4, n4), n4;
    }(Qt);
    function s3(e4) {
      if ("function" != typeof WeakMap) return null;
      var t4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
      return (s3 = function(e5) {
        return e5 ? r4 : t4;
      })(e4);
    }
    for (var i3 = ((t3 = {})[n3.tab] = true, t3[n3.newline] = true, t3[n3.cr] = true, t3[n3.feed] = true, t3), o3 = ((r3 = {})[n3.space] = true, r3[n3.tab] = true, r3[n3.newline] = true, r3[n3.cr] = true, r3[n3.feed] = true, r3[n3.ampersand] = true, r3[n3.asterisk] = true, r3[n3.bang] = true, r3[n3.comma] = true, r3[n3.colon] = true, r3[n3.semicolon] = true, r3[n3.openParenthesis] = true, r3[n3.closeParenthesis] = true, r3[n3.openSquare] = true, r3[n3.closeSquare] = true, r3[n3.singleQuote] = true, r3[n3.doubleQuote] = true, r3[n3.plus] = true, r3[n3.pipe] = true, r3[n3.tilde] = true, r3[n3.greaterThan] = true, r3[n3.equals] = true, r3[n3.dollar] = true, r3[n3.caret] = true, r3[n3.slash] = true, r3), a3 = {}, l2 = 0; l2 < 22; l2++) a3["0123456789abcdefABCDEF".charCodeAt(l2)] = true;
    function c2(e4, t4) {
      var r4, s4 = t4;
      do {
        if (r4 = e4.charCodeAt(s4), o3[r4]) return s4 - 1;
        r4 === n3.backslash ? s4 = u2(e4, s4) + 1 : s4++;
      } while (s4 < e4.length);
      return s4 - 1;
    }
    function u2(e4, t4) {
      var r4 = t4, s4 = e4.charCodeAt(r4 + 1);
      if (i3[s4]) ;
      else if (a3[s4]) {
        var o4 = 0;
        do {
          r4++, o4++, s4 = e4.charCodeAt(r4 + 1);
        } while (a3[s4] && o4 < 6);
        o4 < 6 && s4 === n3.space && r4++;
      } else r4++;
      return r4;
    }
    e3.FIELDS = { TYPE: 0, START_LINE: 1, START_COL: 2, END_LINE: 3, END_COL: 4, START_POS: 5, END_POS: 6 };
  }(Yt), function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3, s3 = T2(bt), i3 = T2(Et), o3 = T2(Ot), a3 = T2(_t), l2 = T2(Nt), c2 = T2(Mt), u2 = T2(Rt), p2 = T2(Ut), d2 = x2($t), f2 = T2(Wt), h2 = T2(Ht), m2 = T2(Kt), y2 = T2(Jt), g2 = x2(Yt), b2 = x2(Qt), v2 = x2(yt), E2 = tt;
    function S2(e4) {
      if ("function" != typeof WeakMap) return null;
      var t4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
      return (S2 = function(e5) {
        return e5 ? r4 : t4;
      })(e4);
    }
    function x2(e4, t4) {
      if (!t4 && e4 && e4.__esModule) return e4;
      if (null === e4 || "object" != typeof e4 && "function" != typeof e4) return { default: e4 };
      var r4 = S2(t4);
      if (r4 && r4.has(e4)) return r4.get(e4);
      var n4 = {}, s4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var i4 in e4) if ("default" !== i4 && Object.prototype.hasOwnProperty.call(e4, i4)) {
        var o4 = s4 ? Object.getOwnPropertyDescriptor(e4, i4) : null;
        o4 && (o4.get || o4.set) ? Object.defineProperty(n4, i4, o4) : n4[i4] = e4[i4];
      }
      return n4.default = e4, r4 && r4.set(e4, n4), n4;
    }
    function T2(e4) {
      return e4 && e4.__esModule ? e4 : { default: e4 };
    }
    function w2(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    var P2 = ((r3 = {})[b2.space] = true, r3[b2.cr] = true, r3[b2.feed] = true, r3[b2.newline] = true, r3[b2.tab] = true, r3), A2 = Object.assign({}, P2, ((n3 = {})[b2.comment] = true, n3));
    function C2(e4) {
      return { line: e4[g2.FIELDS.START_LINE], column: e4[g2.FIELDS.START_COL] };
    }
    function O2(e4) {
      return { line: e4[g2.FIELDS.END_LINE], column: e4[g2.FIELDS.END_COL] };
    }
    function I2(e4, t4, r4, n4) {
      return { start: { line: e4, column: t4 }, end: { line: r4, column: n4 } };
    }
    function _2(e4) {
      return I2(e4[g2.FIELDS.START_LINE], e4[g2.FIELDS.START_COL], e4[g2.FIELDS.END_LINE], e4[g2.FIELDS.END_COL]);
    }
    function k2(e4, t4) {
      if (e4) return I2(e4[g2.FIELDS.START_LINE], e4[g2.FIELDS.START_COL], t4[g2.FIELDS.END_LINE], t4[g2.FIELDS.END_COL]);
    }
    function N2(e4, t4) {
      var r4 = e4[t4];
      if ("string" == typeof r4) return -1 !== r4.indexOf("\\") && ((0, E2.ensureObject)(e4, "raws"), e4[t4] = (0, E2.unesc)(r4), void 0 === e4.raws[t4] && (e4.raws[t4] = r4)), e4;
    }
    function D2(e4, t4) {
      for (var r4 = -1, n4 = []; -1 !== (r4 = e4.indexOf(t4, r4 + 1)); ) n4.push(r4);
      return n4;
    }
    var j2 = function() {
      function e4(e5, t5) {
        void 0 === t5 && (t5 = {}), this.rule = e5, this.options = Object.assign({ lossy: false, safe: false }, t5), this.position = 0, this.css = "string" == typeof this.rule ? this.rule : this.rule.selector, this.tokens = (0, g2.default)({ css: this.css, error: this._errorGenerator(), safe: this.options.safe });
        var r5 = k2(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new s3.default({ source: r5 }), this.root.errorGenerator = this._errorGenerator();
        var n5 = new i3.default({ source: { start: { line: 1, column: 1 } } });
        this.root.append(n5), this.current = n5, this.loop();
      }
      var t4, r4, n4 = e4.prototype;
      return n4._errorGenerator = function() {
        var e5 = this;
        return function(t5, r5) {
          return "string" == typeof e5.rule ? new Error(t5) : e5.rule.error(t5, r5);
        };
      }, n4.attribute = function() {
        var e5 = [], t5 = this.currToken;
        for (this.position++; this.position < this.tokens.length && this.currToken[g2.FIELDS.TYPE] !== b2.closeSquare; ) e5.push(this.currToken), this.position++;
        if (this.currToken[g2.FIELDS.TYPE] !== b2.closeSquare) return this.expected("closing square bracket", this.currToken[g2.FIELDS.START_POS]);
        var r5 = e5.length, n5 = { source: I2(t5[1], t5[2], this.currToken[3], this.currToken[4]), sourceIndex: t5[g2.FIELDS.START_POS] };
        if (1 === r5 && !~[b2.word].indexOf(e5[0][g2.FIELDS.TYPE])) return this.expected("attribute", e5[0][g2.FIELDS.START_POS]);
        for (var s4 = 0, i4 = "", o4 = "", a4 = null, l3 = false; s4 < r5; ) {
          var c3 = e5[s4], u3 = this.content(c3), p3 = e5[s4 + 1];
          switch (c3[g2.FIELDS.TYPE]) {
            case b2.space:
              if (l3 = true, this.options.lossy) break;
              if (a4) {
                (0, E2.ensureObject)(n5, "spaces", a4);
                var f3 = n5.spaces[a4].after || "";
                n5.spaces[a4].after = f3 + u3;
                var h3 = (0, E2.getProp)(n5, "raws", "spaces", a4, "after") || null;
                h3 && (n5.raws.spaces[a4].after = h3 + u3);
              } else i4 += u3, o4 += u3;
              break;
            case b2.asterisk:
              p3[g2.FIELDS.TYPE] === b2.equals ? (n5.operator = u3, a4 = "operator") : n5.namespace && ("namespace" !== a4 || l3) || !p3 || (i4 && ((0, E2.ensureObject)(n5, "spaces", "attribute"), n5.spaces.attribute.before = i4, i4 = ""), o4 && ((0, E2.ensureObject)(n5, "raws", "spaces", "attribute"), n5.raws.spaces.attribute.before = i4, o4 = ""), n5.namespace = (n5.namespace || "") + u3, (0, E2.getProp)(n5, "raws", "namespace") && (n5.raws.namespace += u3), a4 = "namespace"), l3 = false;
              break;
            case b2.dollar:
              if ("value" === a4) {
                var m3 = (0, E2.getProp)(n5, "raws", "value");
                n5.value += "$", m3 && (n5.raws.value = m3 + "$");
                break;
              }
            case b2.caret:
              p3[g2.FIELDS.TYPE] === b2.equals && (n5.operator = u3, a4 = "operator"), l3 = false;
              break;
            case b2.combinator:
              if ("~" === u3 && p3[g2.FIELDS.TYPE] === b2.equals && (n5.operator = u3, a4 = "operator"), "|" !== u3) {
                l3 = false;
                break;
              }
              p3[g2.FIELDS.TYPE] === b2.equals ? (n5.operator = u3, a4 = "operator") : n5.namespace || n5.attribute || (n5.namespace = true), l3 = false;
              break;
            case b2.word:
              if (p3 && "|" === this.content(p3) && e5[s4 + 2] && e5[s4 + 2][g2.FIELDS.TYPE] !== b2.equals && !n5.operator && !n5.namespace) n5.namespace = u3, a4 = "namespace";
              else if (!n5.attribute || "attribute" === a4 && !l3) i4 && ((0, E2.ensureObject)(n5, "spaces", "attribute"), n5.spaces.attribute.before = i4, i4 = ""), o4 && ((0, E2.ensureObject)(n5, "raws", "spaces", "attribute"), n5.raws.spaces.attribute.before = o4, o4 = ""), n5.attribute = (n5.attribute || "") + u3, (0, E2.getProp)(n5, "raws", "attribute") && (n5.raws.attribute += u3), a4 = "attribute";
              else if (!n5.value && "" !== n5.value || "value" === a4 && !l3 && !n5.quoteMark) {
                var y3 = (0, E2.unesc)(u3), v3 = (0, E2.getProp)(n5, "raws", "value") || "", S3 = n5.value || "";
                n5.value = S3 + y3, n5.quoteMark = null, (y3 !== u3 || v3) && ((0, E2.ensureObject)(n5, "raws"), n5.raws.value = (v3 || S3) + u3), a4 = "value";
              } else {
                var x3 = "i" === u3 || "I" === u3;
                !n5.value && "" !== n5.value || !n5.quoteMark && !l3 ? (n5.value || "" === n5.value) && (a4 = "value", n5.value += u3, n5.raws.value && (n5.raws.value += u3)) : (n5.insensitive = x3, x3 && "I" !== u3 || ((0, E2.ensureObject)(n5, "raws"), n5.raws.insensitiveFlag = u3), a4 = "insensitive", i4 && ((0, E2.ensureObject)(n5, "spaces", "insensitive"), n5.spaces.insensitive.before = i4, i4 = ""), o4 && ((0, E2.ensureObject)(n5, "raws", "spaces", "insensitive"), n5.raws.spaces.insensitive.before = o4, o4 = ""));
              }
              l3 = false;
              break;
            case b2.str:
              if (!n5.attribute || !n5.operator) return this.error("Expected an attribute followed by an operator preceding the string.", { index: c3[g2.FIELDS.START_POS] });
              var T3 = (0, d2.unescapeValue)(u3), w3 = T3.unescaped, P3 = T3.quoteMark;
              n5.value = w3, n5.quoteMark = P3, a4 = "value", (0, E2.ensureObject)(n5, "raws"), n5.raws.value = u3, l3 = false;
              break;
            case b2.equals:
              if (!n5.attribute) return this.expected("attribute", c3[g2.FIELDS.START_POS], u3);
              if (n5.value) return this.error('Unexpected "=" found; an operator was already defined.', { index: c3[g2.FIELDS.START_POS] });
              n5.operator = n5.operator ? n5.operator + u3 : u3, a4 = "operator", l3 = false;
              break;
            case b2.comment:
              if (a4) if (l3 || p3 && p3[g2.FIELDS.TYPE] === b2.space || "insensitive" === a4) {
                var A3 = (0, E2.getProp)(n5, "spaces", a4, "after") || "", C3 = (0, E2.getProp)(n5, "raws", "spaces", a4, "after") || A3;
                (0, E2.ensureObject)(n5, "raws", "spaces", a4), n5.raws.spaces[a4].after = C3 + u3;
              } else {
                var O3 = n5[a4] || "", _3 = (0, E2.getProp)(n5, "raws", a4) || O3;
                (0, E2.ensureObject)(n5, "raws"), n5.raws[a4] = _3 + u3;
              }
              else o4 += u3;
              break;
            default:
              return this.error('Unexpected "' + u3 + '" found.', { index: c3[g2.FIELDS.START_POS] });
          }
          s4++;
        }
        N2(n5, "attribute"), N2(n5, "namespace"), this.newNode(new d2.default(n5)), this.position++;
      }, n4.parseWhitespaceEquivalentTokens = function(e5) {
        e5 < 0 && (e5 = this.tokens.length);
        var t5 = this.position, r5 = [], n5 = "", s4 = void 0;
        do {
          if (P2[this.currToken[g2.FIELDS.TYPE]]) this.options.lossy || (n5 += this.content());
          else if (this.currToken[g2.FIELDS.TYPE] === b2.comment) {
            var i4 = {};
            n5 && (i4.before = n5, n5 = ""), s4 = new a3.default({ value: this.content(), source: _2(this.currToken), sourceIndex: this.currToken[g2.FIELDS.START_POS], spaces: i4 }), r5.push(s4);
          }
        } while (++this.position < e5);
        if (n5) {
          if (s4) s4.spaces.after = n5;
          else if (!this.options.lossy) {
            var o4 = this.tokens[t5], l3 = this.tokens[this.position - 1];
            r5.push(new u2.default({ value: "", source: I2(o4[g2.FIELDS.START_LINE], o4[g2.FIELDS.START_COL], l3[g2.FIELDS.END_LINE], l3[g2.FIELDS.END_COL]), sourceIndex: o4[g2.FIELDS.START_POS], spaces: { before: n5, after: "" } }));
          }
        }
        return r5;
      }, n4.convertWhitespaceNodesToSpace = function(e5, t5) {
        var r5 = this;
        void 0 === t5 && (t5 = false);
        var n5 = "", s4 = "";
        return e5.forEach(function(e6) {
          var i4 = r5.lossySpace(e6.spaces.before, t5), o4 = r5.lossySpace(e6.rawSpaceBefore, t5);
          n5 += i4 + r5.lossySpace(e6.spaces.after, t5 && 0 === i4.length), s4 += i4 + e6.value + r5.lossySpace(e6.rawSpaceAfter, t5 && 0 === o4.length);
        }), s4 === n5 && (s4 = void 0), { space: n5, rawSpace: s4 };
      }, n4.isNamedCombinator = function(e5) {
        return void 0 === e5 && (e5 = this.position), this.tokens[e5 + 0] && this.tokens[e5 + 0][g2.FIELDS.TYPE] === b2.slash && this.tokens[e5 + 1] && this.tokens[e5 + 1][g2.FIELDS.TYPE] === b2.word && this.tokens[e5 + 2] && this.tokens[e5 + 2][g2.FIELDS.TYPE] === b2.slash;
      }, n4.namedCombinator = function() {
        if (this.isNamedCombinator()) {
          var e5 = this.content(this.tokens[this.position + 1]), t5 = (0, E2.unesc)(e5).toLowerCase(), r5 = {};
          t5 !== e5 && (r5.value = "/" + e5 + "/");
          var n5 = new h2.default({ value: "/" + t5 + "/", source: I2(this.currToken[g2.FIELDS.START_LINE], this.currToken[g2.FIELDS.START_COL], this.tokens[this.position + 2][g2.FIELDS.END_LINE], this.tokens[this.position + 2][g2.FIELDS.END_COL]), sourceIndex: this.currToken[g2.FIELDS.START_POS], raws: r5 });
          return this.position = this.position + 3, n5;
        }
        this.unexpected();
      }, n4.combinator = function() {
        var e5 = this;
        if ("|" === this.content()) return this.namespace();
        var t5 = this.locateNextMeaningfulToken(this.position);
        if (!(t5 < 0 || this.tokens[t5][g2.FIELDS.TYPE] === b2.comma)) {
          var r5, n5 = this.currToken, s4 = void 0;
          if (t5 > this.position && (s4 = this.parseWhitespaceEquivalentTokens(t5)), this.isNamedCombinator() ? r5 = this.namedCombinator() : this.currToken[g2.FIELDS.TYPE] === b2.combinator ? (r5 = new h2.default({ value: this.content(), source: _2(this.currToken), sourceIndex: this.currToken[g2.FIELDS.START_POS] }), this.position++) : P2[this.currToken[g2.FIELDS.TYPE]] || s4 || this.unexpected(), r5) {
            if (s4) {
              var i4 = this.convertWhitespaceNodesToSpace(s4), o4 = i4.space, a4 = i4.rawSpace;
              r5.spaces.before = o4, r5.rawSpaceBefore = a4;
            }
          } else {
            var l3 = this.convertWhitespaceNodesToSpace(s4, true), c3 = l3.space, u3 = l3.rawSpace;
            u3 || (u3 = c3);
            var p3 = {}, d3 = { spaces: {} };
            c3.endsWith(" ") && u3.endsWith(" ") ? (p3.before = c3.slice(0, c3.length - 1), d3.spaces.before = u3.slice(0, u3.length - 1)) : c3.startsWith(" ") && u3.startsWith(" ") ? (p3.after = c3.slice(1), d3.spaces.after = u3.slice(1)) : d3.value = u3, r5 = new h2.default({ value: " ", source: k2(n5, this.tokens[this.position - 1]), sourceIndex: n5[g2.FIELDS.START_POS], spaces: p3, raws: d3 });
          }
          return this.currToken && this.currToken[g2.FIELDS.TYPE] === b2.space && (r5.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(r5);
        }
        var f3 = this.parseWhitespaceEquivalentTokens(t5);
        if (f3.length > 0) {
          var m3 = this.current.last;
          if (m3) {
            var y3 = this.convertWhitespaceNodesToSpace(f3), v3 = y3.space, E3 = y3.rawSpace;
            void 0 !== E3 && (m3.rawSpaceAfter += E3), m3.spaces.after += v3;
          } else f3.forEach(function(t6) {
            return e5.newNode(t6);
          });
        }
      }, n4.comma = function() {
        if (this.position === this.tokens.length - 1) return this.root.trailingComma = true, void this.position++;
        this.current._inferEndPosition();
        var e5 = new i3.default({ source: { start: C2(this.tokens[this.position + 1]) } });
        this.current.parent.append(e5), this.current = e5, this.position++;
      }, n4.comment = function() {
        var e5 = this.currToken;
        this.newNode(new a3.default({ value: this.content(), source: _2(e5), sourceIndex: e5[g2.FIELDS.START_POS] })), this.position++;
      }, n4.error = function(e5, t5) {
        throw this.root.error(e5, t5);
      }, n4.missingBackslash = function() {
        return this.error("Expected a backslash preceding the semicolon.", { index: this.currToken[g2.FIELDS.START_POS] });
      }, n4.missingParenthesis = function() {
        return this.expected("opening parenthesis", this.currToken[g2.FIELDS.START_POS]);
      }, n4.missingSquareBracket = function() {
        return this.expected("opening square bracket", this.currToken[g2.FIELDS.START_POS]);
      }, n4.unexpected = function() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[g2.FIELDS.START_POS]);
      }, n4.unexpectedPipe = function() {
        return this.error("Unexpected '|'.", this.currToken[g2.FIELDS.START_POS]);
      }, n4.namespace = function() {
        var e5 = this.prevToken && this.content(this.prevToken) || true;
        return this.nextToken[g2.FIELDS.TYPE] === b2.word ? (this.position++, this.word(e5)) : this.nextToken[g2.FIELDS.TYPE] === b2.asterisk ? (this.position++, this.universal(e5)) : void this.unexpectedPipe();
      }, n4.nesting = function() {
        if (this.nextToken && "|" === this.content(this.nextToken)) this.position++;
        else {
          var e5 = this.currToken;
          this.newNode(new m2.default({ value: this.content(), source: _2(e5), sourceIndex: e5[g2.FIELDS.START_POS] })), this.position++;
        }
      }, n4.parentheses = function() {
        var e5 = this.current.last, t5 = 1;
        if (this.position++, e5 && e5.type === v2.PSEUDO) {
          var r5 = new i3.default({ source: { start: C2(this.tokens[this.position - 1]) } }), n5 = this.current;
          for (e5.append(r5), this.current = r5; this.position < this.tokens.length && t5; ) this.currToken[g2.FIELDS.TYPE] === b2.openParenthesis && t5++, this.currToken[g2.FIELDS.TYPE] === b2.closeParenthesis && t5--, t5 ? this.parse() : (this.current.source.end = O2(this.currToken), this.current.parent.source.end = O2(this.currToken), this.position++);
          this.current = n5;
        } else {
          for (var s4, o4 = this.currToken, a4 = "("; this.position < this.tokens.length && t5; ) this.currToken[g2.FIELDS.TYPE] === b2.openParenthesis && t5++, this.currToken[g2.FIELDS.TYPE] === b2.closeParenthesis && t5--, s4 = this.currToken, a4 += this.parseParenthesisToken(this.currToken), this.position++;
          e5 ? e5.appendToPropertyAndEscape("value", a4, a4) : this.newNode(new u2.default({ value: a4, source: I2(o4[g2.FIELDS.START_LINE], o4[g2.FIELDS.START_COL], s4[g2.FIELDS.END_LINE], s4[g2.FIELDS.END_COL]), sourceIndex: o4[g2.FIELDS.START_POS] }));
        }
        if (t5) return this.expected("closing parenthesis", this.currToken[g2.FIELDS.START_POS]);
      }, n4.pseudo = function() {
        for (var e5 = this, t5 = "", r5 = this.currToken; this.currToken && this.currToken[g2.FIELDS.TYPE] === b2.colon; ) t5 += this.content(), this.position++;
        return this.currToken ? this.currToken[g2.FIELDS.TYPE] !== b2.word ? this.expected(["pseudo-class", "pseudo-element"], this.currToken[g2.FIELDS.START_POS]) : void this.splitWord(false, function(n5, s4) {
          t5 += n5, e5.newNode(new p2.default({ value: t5, source: k2(r5, e5.currToken), sourceIndex: r5[g2.FIELDS.START_POS] })), s4 > 1 && e5.nextToken && e5.nextToken[g2.FIELDS.TYPE] === b2.openParenthesis && e5.error("Misplaced parenthesis.", { index: e5.nextToken[g2.FIELDS.START_POS] });
        }) : this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      }, n4.space = function() {
        var e5 = this.content();
        0 === this.position || this.prevToken[g2.FIELDS.TYPE] === b2.comma || this.prevToken[g2.FIELDS.TYPE] === b2.openParenthesis || this.current.nodes.every(function(e6) {
          return "comment" === e6.type;
        }) ? (this.spaces = this.optionalSpace(e5), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[g2.FIELDS.TYPE] === b2.comma || this.nextToken[g2.FIELDS.TYPE] === b2.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(e5), this.position++) : this.combinator();
      }, n4.string = function() {
        var e5 = this.currToken;
        this.newNode(new u2.default({ value: this.content(), source: _2(e5), sourceIndex: e5[g2.FIELDS.START_POS] })), this.position++;
      }, n4.universal = function(e5) {
        var t5 = this.nextToken;
        if (t5 && "|" === this.content(t5)) return this.position++, this.namespace();
        var r5 = this.currToken;
        this.newNode(new f2.default({ value: this.content(), source: _2(r5), sourceIndex: r5[g2.FIELDS.START_POS] }), e5), this.position++;
      }, n4.splitWord = function(e5, t5) {
        for (var r5 = this, n5 = this.nextToken, s4 = this.content(); n5 && ~[b2.dollar, b2.caret, b2.equals, b2.word].indexOf(n5[g2.FIELDS.TYPE]); ) {
          this.position++;
          var i4 = this.content();
          if (s4 += i4, i4.lastIndexOf("\\") === i4.length - 1) {
            var a4 = this.nextToken;
            a4 && a4[g2.FIELDS.TYPE] === b2.space && (s4 += this.requiredSpace(this.content(a4)), this.position++);
          }
          n5 = this.nextToken;
        }
        var u3 = D2(s4, ".").filter(function(e6) {
          var t6 = "\\" === s4[e6 - 1], r6 = /^\d+\.\d+%$/.test(s4);
          return !t6 && !r6;
        }), p3 = D2(s4, "#").filter(function(e6) {
          return "\\" !== s4[e6 - 1];
        }), d3 = D2(s4, "#{");
        d3.length && (p3 = p3.filter(function(e6) {
          return !~d3.indexOf(e6);
        }));
        var f3 = (0, y2.default)(function() {
          var e6 = Array.prototype.concat.apply([], arguments);
          return e6.filter(function(t6, r6) {
            return r6 === e6.indexOf(t6);
          });
        }([0].concat(u3, p3)));
        f3.forEach(function(n6, i5) {
          var a5, d4 = f3[i5 + 1] || s4.length, h3 = s4.slice(n6, d4);
          if (0 === i5 && t5) return t5.call(r5, h3, f3.length);
          var m3 = r5.currToken, y3 = m3[g2.FIELDS.START_POS] + f3[i5], b3 = I2(m3[1], m3[2] + n6, m3[3], m3[2] + (d4 - 1));
          if (~u3.indexOf(n6)) {
            var v3 = { value: h3.slice(1), source: b3, sourceIndex: y3 };
            a5 = new o3.default(N2(v3, "value"));
          } else if (~p3.indexOf(n6)) {
            var E3 = { value: h3.slice(1), source: b3, sourceIndex: y3 };
            a5 = new l2.default(N2(E3, "value"));
          } else {
            var S3 = { value: h3, source: b3, sourceIndex: y3 };
            N2(S3, "value"), a5 = new c2.default(S3);
          }
          r5.newNode(a5, e5), e5 = null;
        }), this.position++;
      }, n4.word = function(e5) {
        var t5 = this.nextToken;
        return t5 && "|" === this.content(t5) ? (this.position++, this.namespace()) : this.splitWord(e5);
      }, n4.loop = function() {
        for (; this.position < this.tokens.length; ) this.parse(true);
        return this.current._inferEndPosition(), this.root;
      }, n4.parse = function(e5) {
        switch (this.currToken[g2.FIELDS.TYPE]) {
          case b2.space:
            this.space();
            break;
          case b2.comment:
            this.comment();
            break;
          case b2.openParenthesis:
            this.parentheses();
            break;
          case b2.closeParenthesis:
            e5 && this.missingParenthesis();
            break;
          case b2.openSquare:
            this.attribute();
            break;
          case b2.dollar:
          case b2.caret:
          case b2.equals:
          case b2.word:
            this.word();
            break;
          case b2.colon:
            this.pseudo();
            break;
          case b2.comma:
            this.comma();
            break;
          case b2.asterisk:
            this.universal();
            break;
          case b2.ampersand:
            this.nesting();
            break;
          case b2.slash:
          case b2.combinator:
            this.combinator();
            break;
          case b2.str:
            this.string();
            break;
          case b2.closeSquare:
            this.missingSquareBracket();
          case b2.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      }, n4.expected = function(e5, t5, r5) {
        if (Array.isArray(e5)) {
          var n5 = e5.pop();
          e5 = e5.join(", ") + " or " + n5;
        }
        var s4 = /^[aeiou]/.test(e5[0]) ? "an" : "a";
        return r5 ? this.error("Expected " + s4 + " " + e5 + ', found "' + r5 + '" instead.', { index: t5 }) : this.error("Expected " + s4 + " " + e5 + ".", { index: t5 });
      }, n4.requiredSpace = function(e5) {
        return this.options.lossy ? " " : e5;
      }, n4.optionalSpace = function(e5) {
        return this.options.lossy ? "" : e5;
      }, n4.lossySpace = function(e5, t5) {
        return this.options.lossy ? t5 ? " " : "" : e5;
      }, n4.parseParenthesisToken = function(e5) {
        var t5 = this.content(e5);
        return e5[g2.FIELDS.TYPE] === b2.space ? this.requiredSpace(t5) : t5;
      }, n4.newNode = function(e5, t5) {
        return t5 && (/^ +$/.test(t5) && (this.options.lossy || (this.spaces = (this.spaces || "") + t5), t5 = true), e5.namespace = t5, N2(e5, "namespace")), this.spaces && (e5.spaces.before = this.spaces, this.spaces = ""), this.current.append(e5);
      }, n4.content = function(e5) {
        return void 0 === e5 && (e5 = this.currToken), this.css.slice(e5[g2.FIELDS.START_POS], e5[g2.FIELDS.END_POS]);
      }, n4.locateNextMeaningfulToken = function(e5) {
        void 0 === e5 && (e5 = this.position + 1);
        for (var t5 = e5; t5 < this.tokens.length; ) {
          if (!A2[this.tokens[t5][g2.FIELDS.TYPE]]) return t5;
          t5++;
        }
        return -1;
      }, t4 = e4, (r4 = [{ key: "currToken", get: function() {
        return this.tokens[this.position];
      } }, { key: "nextToken", get: function() {
        return this.tokens[this.position + 1];
      } }, { key: "prevToken", get: function() {
        return this.tokens[this.position - 1];
      } }]) && w2(t4.prototype, r4), Object.defineProperty(t4, "prototype", { writable: false }), e4;
    }();
    t3.default = j2, e3.exports = t3.default;
  }(Ye, Ye.exports);
  var Zt = Ye.exports;
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = Zt) && r3.__esModule ? r3 : { default: r3 }, s3 = function() {
      function e4(e5, t5) {
        this.func = e5 || function() {
        }, this.funcRes = null, this.options = t5;
      }
      var t4 = e4.prototype;
      return t4._shouldUpdateSelector = function(e5, t5) {
        return void 0 === t5 && (t5 = {}), false !== Object.assign({}, this.options, t5).updateSelector && "string" != typeof e5;
      }, t4._isLossy = function(e5) {
        return void 0 === e5 && (e5 = {}), false === Object.assign({}, this.options, e5).lossless;
      }, t4._root = function(e5, t5) {
        return void 0 === t5 && (t5 = {}), new n3.default(e5, this._parseOptions(t5)).root;
      }, t4._parseOptions = function(e5) {
        return { lossy: this._isLossy(e5) };
      }, t4._run = function(e5, t5) {
        var r4 = this;
        return void 0 === t5 && (t5 = {}), new Promise(function(n4, s4) {
          try {
            var i3 = r4._root(e5, t5);
            Promise.resolve(r4.func(i3)).then(function(n5) {
              var s5 = void 0;
              return r4._shouldUpdateSelector(e5, t5) && (s5 = i3.toString(), e5.selector = s5), { transform: n5, root: i3, string: s5 };
            }).then(n4, s4);
          } catch (e6) {
            return void s4(e6);
          }
        });
      }, t4._runSync = function(e5, t5) {
        void 0 === t5 && (t5 = {});
        var r4 = this._root(e5, t5), n4 = this.func(r4);
        if (n4 && "function" == typeof n4.then) throw new Error("Selector processor returned a promise to a synchronous call.");
        var s4 = void 0;
        return t5.updateSelector && "string" != typeof e5 && (s4 = r4.toString(), e5.selector = s4), { transform: n4, root: r4, string: s4 };
      }, t4.ast = function(e5, t5) {
        return this._run(e5, t5).then(function(e6) {
          return e6.root;
        });
      }, t4.astSync = function(e5, t5) {
        return this._runSync(e5, t5).root;
      }, t4.transform = function(e5, t5) {
        return this._run(e5, t5).then(function(e6) {
          return e6.transform;
        });
      }, t4.transformSync = function(e5, t5) {
        return this._runSync(e5, t5).transform;
      }, t4.process = function(e5, t5) {
        return this._run(e5, t5).then(function(e6) {
          return e6.string || e6.root.toString();
        });
      }, t4.processSync = function(e5, t5) {
        var r4 = this._runSync(e5, t5);
        return r4.string || r4.root.toString();
      }, e4;
    }();
    t3.default = s3, e3.exports = t3.default;
  }(Je, Je.exports);
  var er = Je.exports, tr = {}, rr = { __esModule: true };
  rr.universal = rr.tag = rr.string = rr.selector = rr.root = rr.pseudo = rr.nesting = rr.id = rr.comment = rr.combinator = rr.className = rr.attribute = void 0;
  var nr = mr($t), sr = mr(Ot), ir = mr(Ht), or = mr(_t), ar = mr(Nt), lr = mr(Kt), cr = mr(Ut), ur = mr(bt), pr = mr(Et), dr = mr(Rt), fr = mr(Mt), hr = mr(Wt);
  function mr(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  }
  rr.attribute = function(e3) {
    return new nr.default(e3);
  }, rr.className = function(e3) {
    return new sr.default(e3);
  }, rr.combinator = function(e3) {
    return new ir.default(e3);
  }, rr.comment = function(e3) {
    return new or.default(e3);
  }, rr.id = function(e3) {
    return new ar.default(e3);
  }, rr.nesting = function(e3) {
    return new lr.default(e3);
  }, rr.pseudo = function(e3) {
    return new cr.default(e3);
  }, rr.root = function(e3) {
    return new ur.default(e3);
  }, rr.selector = function(e3) {
    return new pr.default(e3);
  }, rr.string = function(e3) {
    return new dr.default(e3);
  }, rr.tag = function(e3) {
    return new fr.default(e3);
  }, rr.universal = function(e3) {
    return new hr.default(e3);
  };
  var yr = { __esModule: true };
  yr.isComment = yr.isCombinator = yr.isClassName = yr.isAttribute = void 0, yr.isContainer = function(e3) {
    return !(!Er(e3) || !e3.walk);
  }, yr.isIdentifier = void 0, yr.isNamespace = function(e3) {
    return xr(e3) || Nr(e3);
  }, yr.isNesting = void 0, yr.isNode = Er, yr.isPseudo = void 0, yr.isPseudoClass = function(e3) {
    return Or(e3) && !jr(e3);
  }, yr.isPseudoElement = jr, yr.isUniversal = yr.isTag = yr.isString = yr.isSelector = yr.isRoot = void 0;
  var gr, br = yt, vr = ((gr = {})[br.ATTRIBUTE] = true, gr[br.CLASS] = true, gr[br.COMBINATOR] = true, gr[br.COMMENT] = true, gr[br.ID] = true, gr[br.NESTING] = true, gr[br.PSEUDO] = true, gr[br.ROOT] = true, gr[br.SELECTOR] = true, gr[br.STRING] = true, gr[br.TAG] = true, gr[br.UNIVERSAL] = true, gr);
  function Er(e3) {
    return "object" == typeof e3 && vr[e3.type];
  }
  function Sr(e3, t3) {
    return Er(t3) && t3.type === e3;
  }
  var xr = Sr.bind(null, br.ATTRIBUTE);
  yr.isAttribute = xr;
  var Tr = Sr.bind(null, br.CLASS);
  yr.isClassName = Tr;
  var wr = Sr.bind(null, br.COMBINATOR);
  yr.isCombinator = wr;
  var Pr = Sr.bind(null, br.COMMENT);
  yr.isComment = Pr;
  var Ar = Sr.bind(null, br.ID);
  yr.isIdentifier = Ar;
  var Cr = Sr.bind(null, br.NESTING);
  yr.isNesting = Cr;
  var Or = Sr.bind(null, br.PSEUDO);
  yr.isPseudo = Or;
  var Ir = Sr.bind(null, br.ROOT);
  yr.isRoot = Ir;
  var _r = Sr.bind(null, br.SELECTOR);
  yr.isSelector = _r;
  var kr = Sr.bind(null, br.STRING);
  yr.isString = kr;
  var Nr = Sr.bind(null, br.TAG);
  yr.isTag = Nr;
  var Dr = Sr.bind(null, br.UNIVERSAL);
  function jr(e3) {
    return Or(e3) && e3.value && (e3.value.startsWith("::") || ":before" === e3.value.toLowerCase() || ":after" === e3.value.toLowerCase() || ":first-letter" === e3.value.toLowerCase() || ":first-line" === e3.value.toLowerCase());
  }
  yr.isUniversal = Dr, function(e3) {
    e3.__esModule = true;
    var t3 = yt;
    Object.keys(t3).forEach(function(r4) {
      "default" !== r4 && "__esModule" !== r4 && (r4 in e3 && e3[r4] === t3[r4] || (e3[r4] = t3[r4]));
    });
    var r3 = rr;
    Object.keys(r3).forEach(function(t4) {
      "default" !== t4 && "__esModule" !== t4 && (t4 in e3 && e3[t4] === r3[t4] || (e3[t4] = r3[t4]));
    });
    var n3 = yr;
    Object.keys(n3).forEach(function(t4) {
      "default" !== t4 && "__esModule" !== t4 && (t4 in e3 && e3[t4] === n3[t4] || (e3[t4] = n3[t4]));
    });
  }(tr), function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = er) && r3.__esModule ? r3 : { default: r3 }, s3 = function(e4, t4) {
      if (e4 && e4.__esModule) return e4;
      if (null === e4 || "object" != typeof e4 && "function" != typeof e4) return { default: e4 };
      var r4 = i3(t4);
      if (r4 && r4.has(e4)) return r4.get(e4);
      var n4 = {}, s4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var o4 in e4) if ("default" !== o4 && Object.prototype.hasOwnProperty.call(e4, o4)) {
        var a4 = s4 ? Object.getOwnPropertyDescriptor(e4, o4) : null;
        a4 && (a4.get || a4.set) ? Object.defineProperty(n4, o4, a4) : n4[o4] = e4[o4];
      }
      return n4.default = e4, r4 && r4.set(e4, n4), n4;
    }(tr);
    function i3(e4) {
      if ("function" != typeof WeakMap) return null;
      var t4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
      return (i3 = function(e5) {
        return e5 ? r4 : t4;
      })(e4);
    }
    var o3 = function(e4) {
      return new n3.default(e4);
    };
    Object.assign(o3, s3), delete o3.__esModule;
    var a3 = o3;
    t3.default = a3, e3.exports = t3.default;
  }(Xe, Xe.exports);
  var Lr = Xe.exports, Mr = q(Lr);
  const Br = /^(-\w+-)?animation-name$/, Rr = /^(-\w+-)?animation$/, Fr = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
    const t3 = /* @__PURE__ */ Object.create(null), r3 = e3.replace(/^data-v-/, "");
    return { postcssPlugin: "vue-sfc-scoped", Rule(t4) {
      !function(e4, t5) {
        Ur.has(t5) || t5.parent && "atrule" === t5.parent.type && /-?keyframes$/.test(t5.parent.name) || (Ur.add(t5), t5.selector = Mr((t6) => {
          t6.each((r4) => {
            $r(e4, r4, t6);
          });
        }).processSync(t5.selector));
      }(e3, t4);
    }, AtRule(e4) {
      /-?keyframes$/.test(e4.name) && !e4.params.endsWith(`-${r3}`) && (t3[e4.params] = e4.params = e4.params + "-" + r3);
    }, OnceExit(e4) {
      Object.keys(t3).length && e4.walkDecls((e5) => {
        Br.test(e5.prop) && (e5.value = e5.value.split(",").map((e6) => t3[e6.trim()] || e6.trim()).join(",")), Rr.test(e5.prop) && (e5.value = e5.value.split(",").map((e6) => {
          const r4 = e6.trim().split(/\s+/), n3 = r4.findIndex((e7) => t3[e7]);
          return -1 !== n3 ? (r4.splice(n3, 1, t3[r4[n3]]), r4.join(" ")) : e6;
        }).join(","));
      });
    } };
  }, Ur = /* @__PURE__ */ new WeakSet();
  function $r(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], s3 = null, i3 = true;
    if (t3.each((n4) => {
      if ("combinator" === n4.type && (">>>" === n4.value || "/deep/" === n4.value)) return n4.value = " ", n4.spaces.before = n4.spaces.after = "", false;
      if ("pseudo" === n4.type) {
        const { value: s4 } = n4;
        if (":deep" === s4 || "::v-deep" === s4) {
          if (n4.nodes.length) {
            let e4 = n4;
            n4.nodes[0].each((r5) => {
              t3.insertAfter(e4, r5), e4 = r5;
            });
            const r4 = t3.at(t3.index(n4) - 1);
            r4 && Vr(r4) || t3.insertAfter(n4, Mr.combinator({ value: " " })), t3.removeChild(n4);
          } else {
            const e4 = t3.at(t3.index(n4) - 1);
            e4 && Vr(e4) && t3.removeChild(e4), t3.removeChild(n4);
          }
          return false;
        }
        if (":slotted" === s4 || "::v-slotted" === s4) {
          $r(e3, n4.nodes[0], r3, true);
          let s5 = n4;
          return n4.nodes[0].each((e4) => {
            t3.insertAfter(s5, e4), s5 = e4;
          }), t3.removeChild(n4), i3 = false, false;
        }
        if (":global" === s4 || "::v-global" === s4) return r3.insertAfter(t3, n4.nodes[0]), r3.removeChild(t3), false;
      }
      ("pseudo" !== n4.type && "combinator" !== n4.type || "pseudo" === n4.type && (":is" === n4.value || ":where" === n4.value)) && (s3 = n4);
    }), s3) {
      const { type: t4, value: o3 } = s3;
      "pseudo" !== t4 || ":is" !== o3 && ":where" !== o3 || (s3.nodes.forEach((t5) => $r(e3, t5, r3, n3)), i3 = false);
    }
    if (s3 ? s3.spaces.after = "" : t3.first.spaces.before = "", i3) {
      const r4 = n3 ? e3 + "-s" : e3;
      t3.insertAfter(s3, Mr.attribute({ attribute: r4, value: r4, raws: {}, quoteMark: '"' }));
    }
  }
  function Vr(e3) {
    return "combinator" === e3.type && /^\s+$/.test(e3.value);
  }
  Fr.postcss = true;
  var qr = Fr, Wr = {}, Gr = {}, Hr = {}, zr = {}, Kr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  zr.encode = function(e3) {
    if (0 <= e3 && e3 < Kr.length) return Kr[e3];
    throw new TypeError("Must be between 0 and 63: " + e3);
  }, zr.decode = function(e3) {
    return 65 <= e3 && e3 <= 90 ? e3 - 65 : 97 <= e3 && e3 <= 122 ? e3 - 97 + 26 : 48 <= e3 && e3 <= 57 ? e3 - 48 + 52 : 43 == e3 ? 62 : 47 == e3 ? 63 : -1;
  };
  var Xr = zr;
  Hr.encode = function(e3) {
    var t3, r3 = "", n3 = function(e4) {
      return e4 < 0 ? 1 + (-e4 << 1) : 0 + (e4 << 1);
    }(e3);
    do {
      t3 = 31 & n3, (n3 >>>= 5) > 0 && (t3 |= 32), r3 += Xr.encode(t3);
    } while (n3 > 0);
    return r3;
  }, Hr.decode = function(e3, t3, r3) {
    var n3, s3, i3, o3, a3 = e3.length, l2 = 0, c2 = 0;
    do {
      if (t3 >= a3) throw new Error("Expected more digits in base 64 VLQ value.");
      if (-1 === (s3 = Xr.decode(e3.charCodeAt(t3++)))) throw new Error("Invalid base64 digit: " + e3.charAt(t3 - 1));
      n3 = !!(32 & s3), l2 += (s3 &= 31) << c2, c2 += 5;
    } while (n3);
    r3.value = (o3 = (i3 = l2) >> 1, 1 == (1 & i3) ? -o3 : o3), r3.rest = t3;
  };
  var Jr = {};
  !function(e3) {
    e3.getArg = function(e4, t4, r4) {
      if (t4 in e4) return e4[t4];
      if (3 === arguments.length) return r4;
      throw new Error('"' + t4 + '" is a required argument.');
    };
    var t3 = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, r3 = /^data:.+\,.+$/;
    function n3(e4) {
      var r4 = e4.match(t3);
      return r4 ? { scheme: r4[1], auth: r4[2], host: r4[3], port: r4[4], path: r4[5] } : null;
    }
    function s3(e4) {
      var t4 = "";
      return e4.scheme && (t4 += e4.scheme + ":"), t4 += "//", e4.auth && (t4 += e4.auth + "@"), e4.host && (t4 += e4.host), e4.port && (t4 += ":" + e4.port), e4.path && (t4 += e4.path), t4;
    }
    function i3(t4) {
      var r4 = t4, i4 = n3(t4);
      if (i4) {
        if (!i4.path) return t4;
        r4 = i4.path;
      }
      for (var o4, a4 = e3.isAbsolute(r4), l3 = r4.split(/\/+/), c3 = 0, u3 = l3.length - 1; u3 >= 0; u3--) "." === (o4 = l3[u3]) ? l3.splice(u3, 1) : ".." === o4 ? c3++ : c3 > 0 && ("" === o4 ? (l3.splice(u3 + 1, c3), c3 = 0) : (l3.splice(u3, 2), c3--));
      return "" === (r4 = l3.join("/")) && (r4 = a4 ? "/" : "."), i4 ? (i4.path = r4, s3(i4)) : r4;
    }
    function o3(e4, t4) {
      "" === e4 && (e4 = "."), "" === t4 && (t4 = ".");
      var o4 = n3(t4), a4 = n3(e4);
      if (a4 && (e4 = a4.path || "/"), o4 && !o4.scheme) return a4 && (o4.scheme = a4.scheme), s3(o4);
      if (o4 || t4.match(r3)) return t4;
      if (a4 && !a4.host && !a4.path) return a4.host = t4, s3(a4);
      var l3 = "/" === t4.charAt(0) ? t4 : i3(e4.replace(/\/+$/, "") + "/" + t4);
      return a4 ? (a4.path = l3, s3(a4)) : l3;
    }
    e3.urlParse = n3, e3.urlGenerate = s3, e3.normalize = i3, e3.join = o3, e3.isAbsolute = function(e4) {
      return "/" === e4.charAt(0) || t3.test(e4);
    }, e3.relative = function(e4, t4) {
      "" === e4 && (e4 = "."), e4 = e4.replace(/\/$/, "");
      for (var r4 = 0; 0 !== t4.indexOf(e4 + "/"); ) {
        var n4 = e4.lastIndexOf("/");
        if (n4 < 0) return t4;
        if ((e4 = e4.slice(0, n4)).match(/^([^\/]+:\/)?\/*$/)) return t4;
        ++r4;
      }
      return Array(r4 + 1).join("../") + t4.substr(e4.length + 1);
    };
    var a3 = !("__proto__" in /* @__PURE__ */ Object.create(null));
    function l2(e4) {
      return e4;
    }
    function c2(e4) {
      if (!e4) return false;
      var t4 = e4.length;
      if (t4 < 9) return false;
      if (95 !== e4.charCodeAt(t4 - 1) || 95 !== e4.charCodeAt(t4 - 2) || 111 !== e4.charCodeAt(t4 - 3) || 116 !== e4.charCodeAt(t4 - 4) || 111 !== e4.charCodeAt(t4 - 5) || 114 !== e4.charCodeAt(t4 - 6) || 112 !== e4.charCodeAt(t4 - 7) || 95 !== e4.charCodeAt(t4 - 8) || 95 !== e4.charCodeAt(t4 - 9)) return false;
      for (var r4 = t4 - 10; r4 >= 0; r4--) if (36 !== e4.charCodeAt(r4)) return false;
      return true;
    }
    function u2(e4, t4) {
      return e4 === t4 ? 0 : null === e4 ? 1 : null === t4 ? -1 : e4 > t4 ? 1 : -1;
    }
    e3.toSetString = a3 ? l2 : function(e4) {
      return c2(e4) ? "$" + e4 : e4;
    }, e3.fromSetString = a3 ? l2 : function(e4) {
      return c2(e4) ? e4.slice(1) : e4;
    }, e3.compareByOriginalPositions = function(e4, t4, r4) {
      var n4 = u2(e4.source, t4.source);
      return 0 !== n4 || 0 != (n4 = e4.originalLine - t4.originalLine) || 0 != (n4 = e4.originalColumn - t4.originalColumn) || r4 || 0 != (n4 = e4.generatedColumn - t4.generatedColumn) || 0 != (n4 = e4.generatedLine - t4.generatedLine) ? n4 : u2(e4.name, t4.name);
    }, e3.compareByGeneratedPositionsDeflated = function(e4, t4, r4) {
      var n4 = e4.generatedLine - t4.generatedLine;
      return 0 !== n4 || 0 != (n4 = e4.generatedColumn - t4.generatedColumn) || r4 || 0 !== (n4 = u2(e4.source, t4.source)) || 0 != (n4 = e4.originalLine - t4.originalLine) || 0 != (n4 = e4.originalColumn - t4.originalColumn) ? n4 : u2(e4.name, t4.name);
    }, e3.compareByGeneratedPositionsInflated = function(e4, t4) {
      var r4 = e4.generatedLine - t4.generatedLine;
      return 0 !== r4 || 0 != (r4 = e4.generatedColumn - t4.generatedColumn) || 0 !== (r4 = u2(e4.source, t4.source)) || 0 != (r4 = e4.originalLine - t4.originalLine) || 0 != (r4 = e4.originalColumn - t4.originalColumn) ? r4 : u2(e4.name, t4.name);
    }, e3.parseSourceMapInput = function(e4) {
      return JSON.parse(e4.replace(/^\)]}'[^\n]*\n/, ""));
    }, e3.computeSourceURL = function(e4, t4, r4) {
      if (t4 = t4 || "", e4 && ("/" !== e4[e4.length - 1] && "/" !== t4[0] && (e4 += "/"), t4 = e4 + t4), r4) {
        var a4 = n3(r4);
        if (!a4) throw new Error("sourceMapURL could not be parsed");
        if (a4.path) {
          var l3 = a4.path.lastIndexOf("/");
          l3 >= 0 && (a4.path = a4.path.substring(0, l3 + 1));
        }
        t4 = o3(s3(a4), t4);
      }
      return i3(t4);
    };
  }(Jr);
  var Yr = {}, Qr = Jr, Zr = Object.prototype.hasOwnProperty, en = "undefined" != typeof Map;
  function tn() {
    this._array = [], this._set = en ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  tn.fromArray = function(e3, t3) {
    for (var r3 = new tn(), n3 = 0, s3 = e3.length; n3 < s3; n3++) r3.add(e3[n3], t3);
    return r3;
  }, tn.prototype.size = function() {
    return en ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, tn.prototype.add = function(e3, t3) {
    var r3 = en ? e3 : Qr.toSetString(e3), n3 = en ? this.has(e3) : Zr.call(this._set, r3), s3 = this._array.length;
    n3 && !t3 || this._array.push(e3), n3 || (en ? this._set.set(e3, s3) : this._set[r3] = s3);
  }, tn.prototype.has = function(e3) {
    if (en) return this._set.has(e3);
    var t3 = Qr.toSetString(e3);
    return Zr.call(this._set, t3);
  }, tn.prototype.indexOf = function(e3) {
    if (en) {
      var t3 = this._set.get(e3);
      if (t3 >= 0) return t3;
    } else {
      var r3 = Qr.toSetString(e3);
      if (Zr.call(this._set, r3)) return this._set[r3];
    }
    throw new Error('"' + e3 + '" is not in the set.');
  }, tn.prototype.at = function(e3) {
    if (e3 >= 0 && e3 < this._array.length) return this._array[e3];
    throw new Error("No element indexed by " + e3);
  }, tn.prototype.toArray = function() {
    return this._array.slice();
  }, Yr.ArraySet = tn;
  var rn = {}, nn = Jr;
  function sn() {
    this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  sn.prototype.unsortedForEach = function(e3, t3) {
    this._array.forEach(e3, t3);
  }, sn.prototype.add = function(e3) {
    var t3, r3, n3, s3, i3, o3;
    r3 = e3, n3 = (t3 = this._last).generatedLine, s3 = r3.generatedLine, i3 = t3.generatedColumn, o3 = r3.generatedColumn, s3 > n3 || s3 == n3 && o3 >= i3 || nn.compareByGeneratedPositionsInflated(t3, r3) <= 0 ? (this._last = e3, this._array.push(e3)) : (this._sorted = false, this._array.push(e3));
  }, sn.prototype.toArray = function() {
    return this._sorted || (this._array.sort(nn.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
  }, rn.MappingList = sn;
  var on = Hr, an = Jr, ln = Yr.ArraySet, cn = rn.MappingList;
  function un(e3) {
    e3 || (e3 = {}), this._file = an.getArg(e3, "file", null), this._sourceRoot = an.getArg(e3, "sourceRoot", null), this._skipValidation = an.getArg(e3, "skipValidation", false), this._sources = new ln(), this._names = new ln(), this._mappings = new cn(), this._sourcesContents = null;
  }
  un.prototype._version = 3, un.fromSourceMap = function(e3) {
    var t3 = e3.sourceRoot, r3 = new un({ file: e3.file, sourceRoot: t3 });
    return e3.eachMapping(function(e4) {
      var n3 = { generated: { line: e4.generatedLine, column: e4.generatedColumn } };
      null != e4.source && (n3.source = e4.source, null != t3 && (n3.source = an.relative(t3, n3.source)), n3.original = { line: e4.originalLine, column: e4.originalColumn }, null != e4.name && (n3.name = e4.name)), r3.addMapping(n3);
    }), e3.sources.forEach(function(n3) {
      var s3 = n3;
      null !== t3 && (s3 = an.relative(t3, n3)), r3._sources.has(s3) || r3._sources.add(s3);
      var i3 = e3.sourceContentFor(n3);
      null != i3 && r3.setSourceContent(n3, i3);
    }), r3;
  }, un.prototype.addMapping = function(e3) {
    var t3 = an.getArg(e3, "generated"), r3 = an.getArg(e3, "original", null), n3 = an.getArg(e3, "source", null), s3 = an.getArg(e3, "name", null);
    this._skipValidation || this._validateMapping(t3, r3, n3, s3), null != n3 && (n3 = String(n3), this._sources.has(n3) || this._sources.add(n3)), null != s3 && (s3 = String(s3), this._names.has(s3) || this._names.add(s3)), this._mappings.add({ generatedLine: t3.line, generatedColumn: t3.column, originalLine: null != r3 && r3.line, originalColumn: null != r3 && r3.column, source: n3, name: s3 });
  }, un.prototype.setSourceContent = function(e3, t3) {
    var r3 = e3;
    null != this._sourceRoot && (r3 = an.relative(this._sourceRoot, r3)), null != t3 ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[an.toSetString(r3)] = t3) : this._sourcesContents && (delete this._sourcesContents[an.toSetString(r3)], 0 === Object.keys(this._sourcesContents).length && (this._sourcesContents = null));
  }, un.prototype.applySourceMap = function(e3, t3, r3) {
    var n3 = t3;
    if (null == t3) {
      if (null == e3.file) throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      n3 = e3.file;
    }
    var s3 = this._sourceRoot;
    null != s3 && (n3 = an.relative(s3, n3));
    var i3 = new ln(), o3 = new ln();
    this._mappings.unsortedForEach(function(t4) {
      if (t4.source === n3 && null != t4.originalLine) {
        var a3 = e3.originalPositionFor({ line: t4.originalLine, column: t4.originalColumn });
        null != a3.source && (t4.source = a3.source, null != r3 && (t4.source = an.join(r3, t4.source)), null != s3 && (t4.source = an.relative(s3, t4.source)), t4.originalLine = a3.line, t4.originalColumn = a3.column, null != a3.name && (t4.name = a3.name));
      }
      var l2 = t4.source;
      null == l2 || i3.has(l2) || i3.add(l2);
      var c2 = t4.name;
      null == c2 || o3.has(c2) || o3.add(c2);
    }, this), this._sources = i3, this._names = o3, e3.sources.forEach(function(t4) {
      var n4 = e3.sourceContentFor(t4);
      null != n4 && (null != r3 && (t4 = an.join(r3, t4)), null != s3 && (t4 = an.relative(s3, t4)), this.setSourceContent(t4, n4));
    }, this);
  }, un.prototype._validateMapping = function(e3, t3, r3, n3) {
    if (t3 && "number" != typeof t3.line && "number" != typeof t3.column) throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    if ((!(e3 && "line" in e3 && "column" in e3 && e3.line > 0 && e3.column >= 0) || t3 || r3 || n3) && !(e3 && "line" in e3 && "column" in e3 && t3 && "line" in t3 && "column" in t3 && e3.line > 0 && e3.column >= 0 && t3.line > 0 && t3.column >= 0 && r3)) throw new Error("Invalid mapping: " + JSON.stringify({ generated: e3, source: r3, original: t3, name: n3 }));
  }, un.prototype._serializeMappings = function() {
    for (var e3, t3, r3, n3, s3 = 0, i3 = 1, o3 = 0, a3 = 0, l2 = 0, c2 = 0, u2 = "", p2 = this._mappings.toArray(), d2 = 0, f2 = p2.length; d2 < f2; d2++) {
      if (e3 = "", (t3 = p2[d2]).generatedLine !== i3) for (s3 = 0; t3.generatedLine !== i3; ) e3 += ";", i3++;
      else if (d2 > 0) {
        if (!an.compareByGeneratedPositionsInflated(t3, p2[d2 - 1])) continue;
        e3 += ",";
      }
      e3 += on.encode(t3.generatedColumn - s3), s3 = t3.generatedColumn, null != t3.source && (n3 = this._sources.indexOf(t3.source), e3 += on.encode(n3 - c2), c2 = n3, e3 += on.encode(t3.originalLine - 1 - a3), a3 = t3.originalLine - 1, e3 += on.encode(t3.originalColumn - o3), o3 = t3.originalColumn, null != t3.name && (r3 = this._names.indexOf(t3.name), e3 += on.encode(r3 - l2), l2 = r3)), u2 += e3;
    }
    return u2;
  }, un.prototype._generateSourcesContent = function(e3, t3) {
    return e3.map(function(e4) {
      if (!this._sourcesContents) return null;
      null != t3 && (e4 = an.relative(t3, e4));
      var r3 = an.toSetString(e4);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, r3) ? this._sourcesContents[r3] : null;
    }, this);
  }, un.prototype.toJSON = function() {
    var e3 = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
    return null != this._file && (e3.file = this._file), null != this._sourceRoot && (e3.sourceRoot = this._sourceRoot), this._sourcesContents && (e3.sourcesContent = this._generateSourcesContent(e3.sources, e3.sourceRoot)), e3;
  }, un.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, Gr.SourceMapGenerator = un;
  var pn = {}, dn = {};
  !function(e3) {
    function t3(r3, n3, s3, i3, o3, a3) {
      var l2 = Math.floor((n3 - r3) / 2) + r3, c2 = o3(s3, i3[l2], true);
      return 0 === c2 ? l2 : c2 > 0 ? n3 - l2 > 1 ? t3(l2, n3, s3, i3, o3, a3) : a3 == e3.LEAST_UPPER_BOUND ? n3 < i3.length ? n3 : -1 : l2 : l2 - r3 > 1 ? t3(r3, l2, s3, i3, o3, a3) : a3 == e3.LEAST_UPPER_BOUND ? l2 : r3 < 0 ? -1 : r3;
    }
    e3.GREATEST_LOWER_BOUND = 1, e3.LEAST_UPPER_BOUND = 2, e3.search = function(r3, n3, s3, i3) {
      if (0 === n3.length) return -1;
      var o3 = t3(-1, n3.length, r3, n3, s3, i3 || e3.GREATEST_LOWER_BOUND);
      if (o3 < 0) return -1;
      for (; o3 - 1 >= 0 && 0 === s3(n3[o3], n3[o3 - 1], true); ) --o3;
      return o3;
    };
  }(dn);
  var fn = {};
  function hn(e3, t3, r3) {
    var n3 = e3[t3];
    e3[t3] = e3[r3], e3[r3] = n3;
  }
  function mn(e3, t3, r3, n3) {
    if (r3 < n3) {
      var s3 = r3 - 1;
      hn(e3, (l2 = r3, c2 = n3, Math.round(l2 + Math.random() * (c2 - l2))), n3);
      for (var i3 = e3[n3], o3 = r3; o3 < n3; o3++) t3(e3[o3], i3) <= 0 && hn(e3, s3 += 1, o3);
      hn(e3, s3 + 1, o3);
      var a3 = s3 + 1;
      mn(e3, t3, r3, a3 - 1), mn(e3, t3, a3 + 1, n3);
    }
    var l2, c2;
  }
  fn.quickSort = function(e3, t3) {
    mn(e3, t3, 0, e3.length - 1);
  };
  var yn = Jr, gn = dn, bn = Yr.ArraySet, vn = Hr, En = fn.quickSort;
  function Sn(e3, t3) {
    var r3 = e3;
    return "string" == typeof e3 && (r3 = yn.parseSourceMapInput(e3)), null != r3.sections ? new wn(r3, t3) : new xn(r3, t3);
  }
  function xn(e3, t3) {
    var r3 = e3;
    "string" == typeof e3 && (r3 = yn.parseSourceMapInput(e3));
    var n3 = yn.getArg(r3, "version"), s3 = yn.getArg(r3, "sources"), i3 = yn.getArg(r3, "names", []), o3 = yn.getArg(r3, "sourceRoot", null), a3 = yn.getArg(r3, "sourcesContent", null), l2 = yn.getArg(r3, "mappings"), c2 = yn.getArg(r3, "file", null);
    if (n3 != this._version) throw new Error("Unsupported version: " + n3);
    o3 && (o3 = yn.normalize(o3)), s3 = s3.map(String).map(yn.normalize).map(function(e4) {
      return o3 && yn.isAbsolute(o3) && yn.isAbsolute(e4) ? yn.relative(o3, e4) : e4;
    }), this._names = bn.fromArray(i3.map(String), true), this._sources = bn.fromArray(s3, true), this._absoluteSources = this._sources.toArray().map(function(e4) {
      return yn.computeSourceURL(o3, e4, t3);
    }), this.sourceRoot = o3, this.sourcesContent = a3, this._mappings = l2, this._sourceMapURL = t3, this.file = c2;
  }
  function Tn() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  function wn(e3, t3) {
    var r3 = e3;
    "string" == typeof e3 && (r3 = yn.parseSourceMapInput(e3));
    var n3 = yn.getArg(r3, "version"), s3 = yn.getArg(r3, "sections");
    if (n3 != this._version) throw new Error("Unsupported version: " + n3);
    this._sources = new bn(), this._names = new bn();
    var i3 = { line: -1, column: 0 };
    this._sections = s3.map(function(e4) {
      if (e4.url) throw new Error("Support for url field in sections not implemented.");
      var r4 = yn.getArg(e4, "offset"), n4 = yn.getArg(r4, "line"), s4 = yn.getArg(r4, "column");
      if (n4 < i3.line || n4 === i3.line && s4 < i3.column) throw new Error("Section offsets must be ordered and non-overlapping.");
      return i3 = r4, { generatedOffset: { generatedLine: n4 + 1, generatedColumn: s4 + 1 }, consumer: new Sn(yn.getArg(e4, "map"), t3) };
    });
  }
  Sn.fromSourceMap = function(e3, t3) {
    return xn.fromSourceMap(e3, t3);
  }, Sn.prototype._version = 3, Sn.prototype.__generatedMappings = null, Object.defineProperty(Sn.prototype, "_generatedMappings", { configurable: true, enumerable: true, get: function() {
    return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
  } }), Sn.prototype.__originalMappings = null, Object.defineProperty(Sn.prototype, "_originalMappings", { configurable: true, enumerable: true, get: function() {
    return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
  } }), Sn.prototype._charIsMappingSeparator = function(e3, t3) {
    var r3 = e3.charAt(t3);
    return ";" === r3 || "," === r3;
  }, Sn.prototype._parseMappings = function(e3, t3) {
    throw new Error("Subclasses must implement _parseMappings");
  }, Sn.GENERATED_ORDER = 1, Sn.ORIGINAL_ORDER = 2, Sn.GREATEST_LOWER_BOUND = 1, Sn.LEAST_UPPER_BOUND = 2, Sn.prototype.eachMapping = function(e3, t3, r3) {
    var n3, s3 = t3 || null;
    switch (r3 || Sn.GENERATED_ORDER) {
      case Sn.GENERATED_ORDER:
        n3 = this._generatedMappings;
        break;
      case Sn.ORIGINAL_ORDER:
        n3 = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var i3 = this.sourceRoot;
    n3.map(function(e4) {
      var t4 = null === e4.source ? null : this._sources.at(e4.source);
      return { source: t4 = yn.computeSourceURL(i3, t4, this._sourceMapURL), generatedLine: e4.generatedLine, generatedColumn: e4.generatedColumn, originalLine: e4.originalLine, originalColumn: e4.originalColumn, name: null === e4.name ? null : this._names.at(e4.name) };
    }, this).forEach(e3, s3);
  }, Sn.prototype.allGeneratedPositionsFor = function(e3) {
    var t3 = yn.getArg(e3, "line"), r3 = { source: yn.getArg(e3, "source"), originalLine: t3, originalColumn: yn.getArg(e3, "column", 0) };
    if (r3.source = this._findSourceIndex(r3.source), r3.source < 0) return [];
    var n3 = [], s3 = this._findMapping(r3, this._originalMappings, "originalLine", "originalColumn", yn.compareByOriginalPositions, gn.LEAST_UPPER_BOUND);
    if (s3 >= 0) {
      var i3 = this._originalMappings[s3];
      if (void 0 === e3.column) for (var o3 = i3.originalLine; i3 && i3.originalLine === o3; ) n3.push({ line: yn.getArg(i3, "generatedLine", null), column: yn.getArg(i3, "generatedColumn", null), lastColumn: yn.getArg(i3, "lastGeneratedColumn", null) }), i3 = this._originalMappings[++s3];
      else for (var a3 = i3.originalColumn; i3 && i3.originalLine === t3 && i3.originalColumn == a3; ) n3.push({ line: yn.getArg(i3, "generatedLine", null), column: yn.getArg(i3, "generatedColumn", null), lastColumn: yn.getArg(i3, "lastGeneratedColumn", null) }), i3 = this._originalMappings[++s3];
    }
    return n3;
  }, pn.SourceMapConsumer = Sn, xn.prototype = Object.create(Sn.prototype), xn.prototype.consumer = Sn, xn.prototype._findSourceIndex = function(e3) {
    var t3, r3 = e3;
    if (null != this.sourceRoot && (r3 = yn.relative(this.sourceRoot, r3)), this._sources.has(r3)) return this._sources.indexOf(r3);
    for (t3 = 0; t3 < this._absoluteSources.length; ++t3) if (this._absoluteSources[t3] == e3) return t3;
    return -1;
  }, xn.fromSourceMap = function(e3, t3) {
    var r3 = Object.create(xn.prototype), n3 = r3._names = bn.fromArray(e3._names.toArray(), true), s3 = r3._sources = bn.fromArray(e3._sources.toArray(), true);
    r3.sourceRoot = e3._sourceRoot, r3.sourcesContent = e3._generateSourcesContent(r3._sources.toArray(), r3.sourceRoot), r3.file = e3._file, r3._sourceMapURL = t3, r3._absoluteSources = r3._sources.toArray().map(function(e4) {
      return yn.computeSourceURL(r3.sourceRoot, e4, t3);
    });
    for (var i3 = e3._mappings.toArray().slice(), o3 = r3.__generatedMappings = [], a3 = r3.__originalMappings = [], l2 = 0, c2 = i3.length; l2 < c2; l2++) {
      var u2 = i3[l2], p2 = new Tn();
      p2.generatedLine = u2.generatedLine, p2.generatedColumn = u2.generatedColumn, u2.source && (p2.source = s3.indexOf(u2.source), p2.originalLine = u2.originalLine, p2.originalColumn = u2.originalColumn, u2.name && (p2.name = n3.indexOf(u2.name)), a3.push(p2)), o3.push(p2);
    }
    return En(r3.__originalMappings, yn.compareByOriginalPositions), r3;
  }, xn.prototype._version = 3, Object.defineProperty(xn.prototype, "sources", { get: function() {
    return this._absoluteSources.slice();
  } }), xn.prototype._parseMappings = function(e3, t3) {
    for (var r3, n3, s3, i3, o3, a3 = 1, l2 = 0, c2 = 0, u2 = 0, p2 = 0, d2 = 0, f2 = e3.length, h2 = 0, m2 = {}, y2 = {}, g2 = [], b2 = []; h2 < f2; ) if (";" === e3.charAt(h2)) a3++, h2++, l2 = 0;
    else if ("," === e3.charAt(h2)) h2++;
    else {
      for ((r3 = new Tn()).generatedLine = a3, i3 = h2; i3 < f2 && !this._charIsMappingSeparator(e3, i3); i3++) ;
      if (s3 = m2[n3 = e3.slice(h2, i3)]) h2 += n3.length;
      else {
        for (s3 = []; h2 < i3; ) vn.decode(e3, h2, y2), o3 = y2.value, h2 = y2.rest, s3.push(o3);
        if (2 === s3.length) throw new Error("Found a source, but no line and column");
        if (3 === s3.length) throw new Error("Found a source and line, but no column");
        m2[n3] = s3;
      }
      r3.generatedColumn = l2 + s3[0], l2 = r3.generatedColumn, s3.length > 1 && (r3.source = p2 + s3[1], p2 += s3[1], r3.originalLine = c2 + s3[2], c2 = r3.originalLine, r3.originalLine += 1, r3.originalColumn = u2 + s3[3], u2 = r3.originalColumn, s3.length > 4 && (r3.name = d2 + s3[4], d2 += s3[4])), b2.push(r3), "number" == typeof r3.originalLine && g2.push(r3);
    }
    En(b2, yn.compareByGeneratedPositionsDeflated), this.__generatedMappings = b2, En(g2, yn.compareByOriginalPositions), this.__originalMappings = g2;
  }, xn.prototype._findMapping = function(e3, t3, r3, n3, s3, i3) {
    if (e3[r3] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + e3[r3]);
    if (e3[n3] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + e3[n3]);
    return gn.search(e3, t3, s3, i3);
  }, xn.prototype.computeColumnSpans = function() {
    for (var e3 = 0; e3 < this._generatedMappings.length; ++e3) {
      var t3 = this._generatedMappings[e3];
      if (e3 + 1 < this._generatedMappings.length) {
        var r3 = this._generatedMappings[e3 + 1];
        if (t3.generatedLine === r3.generatedLine) {
          t3.lastGeneratedColumn = r3.generatedColumn - 1;
          continue;
        }
      }
      t3.lastGeneratedColumn = 1 / 0;
    }
  }, xn.prototype.originalPositionFor = function(e3) {
    var t3 = { generatedLine: yn.getArg(e3, "line"), generatedColumn: yn.getArg(e3, "column") }, r3 = this._findMapping(t3, this._generatedMappings, "generatedLine", "generatedColumn", yn.compareByGeneratedPositionsDeflated, yn.getArg(e3, "bias", Sn.GREATEST_LOWER_BOUND));
    if (r3 >= 0) {
      var n3 = this._generatedMappings[r3];
      if (n3.generatedLine === t3.generatedLine) {
        var s3 = yn.getArg(n3, "source", null);
        null !== s3 && (s3 = this._sources.at(s3), s3 = yn.computeSourceURL(this.sourceRoot, s3, this._sourceMapURL));
        var i3 = yn.getArg(n3, "name", null);
        return null !== i3 && (i3 = this._names.at(i3)), { source: s3, line: yn.getArg(n3, "originalLine", null), column: yn.getArg(n3, "originalColumn", null), name: i3 };
      }
    }
    return { source: null, line: null, column: null, name: null };
  }, xn.prototype.hasContentsOfAllSources = function() {
    return !!this.sourcesContent && this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e3) {
      return null == e3;
    });
  }, xn.prototype.sourceContentFor = function(e3, t3) {
    if (!this.sourcesContent) return null;
    var r3 = this._findSourceIndex(e3);
    if (r3 >= 0) return this.sourcesContent[r3];
    var n3, s3 = e3;
    if (null != this.sourceRoot && (s3 = yn.relative(this.sourceRoot, s3)), null != this.sourceRoot && (n3 = yn.urlParse(this.sourceRoot))) {
      var i3 = s3.replace(/^file:\/\//, "");
      if ("file" == n3.scheme && this._sources.has(i3)) return this.sourcesContent[this._sources.indexOf(i3)];
      if ((!n3.path || "/" == n3.path) && this._sources.has("/" + s3)) return this.sourcesContent[this._sources.indexOf("/" + s3)];
    }
    if (t3) return null;
    throw new Error('"' + s3 + '" is not in the SourceMap.');
  }, xn.prototype.generatedPositionFor = function(e3) {
    var t3 = yn.getArg(e3, "source");
    if ((t3 = this._findSourceIndex(t3)) < 0) return { line: null, column: null, lastColumn: null };
    var r3 = { source: t3, originalLine: yn.getArg(e3, "line"), originalColumn: yn.getArg(e3, "column") }, n3 = this._findMapping(r3, this._originalMappings, "originalLine", "originalColumn", yn.compareByOriginalPositions, yn.getArg(e3, "bias", Sn.GREATEST_LOWER_BOUND));
    if (n3 >= 0) {
      var s3 = this._originalMappings[n3];
      if (s3.source === r3.source) return { line: yn.getArg(s3, "generatedLine", null), column: yn.getArg(s3, "generatedColumn", null), lastColumn: yn.getArg(s3, "lastGeneratedColumn", null) };
    }
    return { line: null, column: null, lastColumn: null };
  }, pn.BasicSourceMapConsumer = xn, wn.prototype = Object.create(Sn.prototype), wn.prototype.constructor = Sn, wn.prototype._version = 3, Object.defineProperty(wn.prototype, "sources", { get: function() {
    for (var e3 = [], t3 = 0; t3 < this._sections.length; t3++) for (var r3 = 0; r3 < this._sections[t3].consumer.sources.length; r3++) e3.push(this._sections[t3].consumer.sources[r3]);
    return e3;
  } }), wn.prototype.originalPositionFor = function(e3) {
    var t3 = { generatedLine: yn.getArg(e3, "line"), generatedColumn: yn.getArg(e3, "column") }, r3 = gn.search(t3, this._sections, function(e4, t4) {
      return e4.generatedLine - t4.generatedOffset.generatedLine || e4.generatedColumn - t4.generatedOffset.generatedColumn;
    }), n3 = this._sections[r3];
    return n3 ? n3.consumer.originalPositionFor({ line: t3.generatedLine - (n3.generatedOffset.generatedLine - 1), column: t3.generatedColumn - (n3.generatedOffset.generatedLine === t3.generatedLine ? n3.generatedOffset.generatedColumn - 1 : 0), bias: e3.bias }) : { source: null, line: null, column: null, name: null };
  }, wn.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(e3) {
      return e3.consumer.hasContentsOfAllSources();
    });
  }, wn.prototype.sourceContentFor = function(e3, t3) {
    for (var r3 = 0; r3 < this._sections.length; r3++) {
      var n3 = this._sections[r3].consumer.sourceContentFor(e3, true);
      if (n3) return n3;
    }
    if (t3) return null;
    throw new Error('"' + e3 + '" is not in the SourceMap.');
  }, wn.prototype.generatedPositionFor = function(e3) {
    for (var t3 = 0; t3 < this._sections.length; t3++) {
      var r3 = this._sections[t3];
      if (-1 !== r3.consumer._findSourceIndex(yn.getArg(e3, "source"))) {
        var n3 = r3.consumer.generatedPositionFor(e3);
        if (n3) return { line: n3.line + (r3.generatedOffset.generatedLine - 1), column: n3.column + (r3.generatedOffset.generatedLine === n3.line ? r3.generatedOffset.generatedColumn - 1 : 0) };
      }
    }
    return { line: null, column: null };
  }, wn.prototype._parseMappings = function(e3, t3) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var r3 = 0; r3 < this._sections.length; r3++) for (var n3 = this._sections[r3], s3 = n3.consumer._generatedMappings, i3 = 0; i3 < s3.length; i3++) {
      var o3 = s3[i3], a3 = n3.consumer._sources.at(o3.source);
      a3 = yn.computeSourceURL(n3.consumer.sourceRoot, a3, this._sourceMapURL), this._sources.add(a3), a3 = this._sources.indexOf(a3);
      var l2 = null;
      o3.name && (l2 = n3.consumer._names.at(o3.name), this._names.add(l2), l2 = this._names.indexOf(l2));
      var c2 = { source: a3, generatedLine: o3.generatedLine + (n3.generatedOffset.generatedLine - 1), generatedColumn: o3.generatedColumn + (n3.generatedOffset.generatedLine === o3.generatedLine ? n3.generatedOffset.generatedColumn - 1 : 0), originalLine: o3.originalLine, originalColumn: o3.originalColumn, name: l2 };
      this.__generatedMappings.push(c2), "number" == typeof c2.originalLine && this.__originalMappings.push(c2);
    }
    En(this.__generatedMappings, yn.compareByGeneratedPositionsDeflated), En(this.__originalMappings, yn.compareByOriginalPositions);
  }, pn.IndexedSourceMapConsumer = wn;
  var Pn = {}, An = Gr.SourceMapGenerator, Cn = Jr, On = /(\r?\n)/, In = "$$$isSourceNode$$$";
  function _n(e3, t3, r3, n3, s3) {
    this.children = [], this.sourceContents = {}, this.line = null == e3 ? null : e3, this.column = null == t3 ? null : t3, this.source = null == r3 ? null : r3, this.name = null == s3 ? null : s3, this[In] = true, null != n3 && this.add(n3);
  }
  _n.fromStringWithSourceMap = function(e3, t3, r3) {
    var n3 = new _n(), s3 = e3.split(On), i3 = 0, o3 = function() {
      return e4() + (e4() || "");
      function e4() {
        return i3 < s3.length ? s3[i3++] : void 0;
      }
    }, a3 = 1, l2 = 0, c2 = null;
    return t3.eachMapping(function(e4) {
      if (null !== c2) {
        if (!(a3 < e4.generatedLine)) {
          var t4 = (r4 = s3[i3] || "").substr(0, e4.generatedColumn - l2);
          return s3[i3] = r4.substr(e4.generatedColumn - l2), l2 = e4.generatedColumn, u2(c2, t4), void (c2 = e4);
        }
        u2(c2, o3()), a3++, l2 = 0;
      }
      for (; a3 < e4.generatedLine; ) n3.add(o3()), a3++;
      if (l2 < e4.generatedColumn) {
        var r4 = s3[i3] || "";
        n3.add(r4.substr(0, e4.generatedColumn)), s3[i3] = r4.substr(e4.generatedColumn), l2 = e4.generatedColumn;
      }
      c2 = e4;
    }, this), i3 < s3.length && (c2 && u2(c2, o3()), n3.add(s3.splice(i3).join(""))), t3.sources.forEach(function(e4) {
      var s4 = t3.sourceContentFor(e4);
      null != s4 && (null != r3 && (e4 = Cn.join(r3, e4)), n3.setSourceContent(e4, s4));
    }), n3;
    function u2(e4, t4) {
      if (null === e4 || void 0 === e4.source) n3.add(t4);
      else {
        var s4 = r3 ? Cn.join(r3, e4.source) : e4.source;
        n3.add(new _n(e4.originalLine, e4.originalColumn, s4, t4, e4.name));
      }
    }
  }, _n.prototype.add = function(e3) {
    if (Array.isArray(e3)) e3.forEach(function(e4) {
      this.add(e4);
    }, this);
    else {
      if (!e3[In] && "string" != typeof e3) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e3);
      e3 && this.children.push(e3);
    }
    return this;
  }, _n.prototype.prepend = function(e3) {
    if (Array.isArray(e3)) for (var t3 = e3.length - 1; t3 >= 0; t3--) this.prepend(e3[t3]);
    else {
      if (!e3[In] && "string" != typeof e3) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e3);
      this.children.unshift(e3);
    }
    return this;
  }, _n.prototype.walk = function(e3) {
    for (var t3, r3 = 0, n3 = this.children.length; r3 < n3; r3++) (t3 = this.children[r3])[In] ? t3.walk(e3) : "" !== t3 && e3(t3, { source: this.source, line: this.line, column: this.column, name: this.name });
  }, _n.prototype.join = function(e3) {
    var t3, r3, n3 = this.children.length;
    if (n3 > 0) {
      for (t3 = [], r3 = 0; r3 < n3 - 1; r3++) t3.push(this.children[r3]), t3.push(e3);
      t3.push(this.children[r3]), this.children = t3;
    }
    return this;
  }, _n.prototype.replaceRight = function(e3, t3) {
    var r3 = this.children[this.children.length - 1];
    return r3[In] ? r3.replaceRight(e3, t3) : "string" == typeof r3 ? this.children[this.children.length - 1] = r3.replace(e3, t3) : this.children.push("".replace(e3, t3)), this;
  }, _n.prototype.setSourceContent = function(e3, t3) {
    this.sourceContents[Cn.toSetString(e3)] = t3;
  }, _n.prototype.walkSourceContents = function(e3) {
    for (var t3 = 0, r3 = this.children.length; t3 < r3; t3++) this.children[t3][In] && this.children[t3].walkSourceContents(e3);
    var n3 = Object.keys(this.sourceContents);
    for (t3 = 0, r3 = n3.length; t3 < r3; t3++) e3(Cn.fromSetString(n3[t3]), this.sourceContents[n3[t3]]);
  }, _n.prototype.toString = function() {
    var e3 = "";
    return this.walk(function(t3) {
      e3 += t3;
    }), e3;
  }, _n.prototype.toStringWithSourceMap = function(e3) {
    var t3 = { code: "", line: 1, column: 0 }, r3 = new An(e3), n3 = false, s3 = null, i3 = null, o3 = null, a3 = null;
    return this.walk(function(e4, l2) {
      t3.code += e4, null !== l2.source && null !== l2.line && null !== l2.column ? (s3 === l2.source && i3 === l2.line && o3 === l2.column && a3 === l2.name || r3.addMapping({ source: l2.source, original: { line: l2.line, column: l2.column }, generated: { line: t3.line, column: t3.column }, name: l2.name }), s3 = l2.source, i3 = l2.line, o3 = l2.column, a3 = l2.name, n3 = true) : n3 && (r3.addMapping({ generated: { line: t3.line, column: t3.column } }), s3 = null, n3 = false);
      for (var c2 = 0, u2 = e4.length; c2 < u2; c2++) 10 === e4.charCodeAt(c2) ? (t3.line++, t3.column = 0, c2 + 1 === u2 ? (s3 = null, n3 = false) : n3 && r3.addMapping({ source: l2.source, original: { line: l2.line, column: l2.column }, generated: { line: t3.line, column: t3.column }, name: l2.name })) : t3.column++;
    }), this.walkSourceContents(function(e4, t4) {
      r3.setSourceContent(e4, t4);
    }), { code: t3.code, map: r3 };
  }, Pn.SourceNode = _n, Wr.SourceMapGenerator = Gr.SourceMapGenerator, Wr.SourceMapConsumer = pn.SourceMapConsumer, Wr.SourceNode = Pn.SourceNode;
  var kn = Wr, Nn = kn.SourceMapConsumer, Dn = kn.SourceMapGenerator, jn = q(function(e3, t3) {
    if (!e3) return t3;
    if (!t3) return e3;
    var r3 = new Nn(e3), n3 = new Nn(t3), s3 = new Dn();
    return n3.eachMapping(function(e4) {
      if (null != e4.originalLine) {
        var t4 = r3.originalPositionFor({ line: e4.originalLine, column: e4.originalColumn });
        null != t4.source && s3.addMapping({ original: { line: t4.line, column: t4.column }, generated: { line: e4.generatedLine, column: e4.generatedColumn }, source: t4.source, name: t4.name });
      }
    }), [r3, n3].forEach(function(e4) {
      e4.sources.forEach(function(t4) {
        s3._sources.add(t4);
        var r4 = e4.sourceContentFor(t4);
        null != r4 && s3.setSourceContent(t4, r4);
      });
    }), s3._sourceRoot = e3.sourceRoot, s3._file = e3.file, JSON.parse(s3.toString());
  });
  const Ln = function(e3, t3, n3) {
    const s3 = (arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : r2(329))("sass"), i3 = { ...n3, data: Bn(e3, n3.filename, n3.additionalData), file: n3.filename, outFile: n3.filename, sourceMap: !!t3 };
    try {
      const e4 = s3.renderSync(i3), r3 = e4.stats.includedFiles;
      return t3 ? { code: e4.css.toString(), map: jn(t3, JSON.parse(e4.map.toString())), errors: [], dependencies: r3 } : { code: e4.css.toString(), errors: [], dependencies: r3 };
    } catch (e4) {
      return { code: "", errors: [e4], dependencies: [] };
    }
  }, Mn = function(e3, t3, n3) {
    const s3 = (arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : r2(329))("stylus");
    try {
      const r3 = s3(e3, n3);
      t3 && r3.set("sourcemap", { inline: false, comment: false });
      const i3 = r3.render(), o3 = r3.deps();
      return t3 ? { code: i3, map: jn(t3, r3.sourcemap), errors: [], dependencies: o3 } : { code: i3, errors: [], dependencies: o3 };
    } catch (e4) {
      return { code: "", errors: [e4], dependencies: [] };
    }
  };
  function Bn(e3, t3, r3) {
    return r3 ? c.isFunction(r3) ? r3(e3, t3) : r3 + e3 : e3;
  }
  const Rn = { less: function(e3, t3, n3) {
    const s3 = (arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : r2(329))("less");
    let i3, o3 = null;
    if (s3.render(Bn(e3, n3.filename, n3.additionalData), { ...n3, syncImport: true }, (e4, t4) => {
      o3 = e4, i3 = t4;
    }), o3) return { code: "", errors: [o3], dependencies: [] };
    const a3 = i3.imports;
    return t3 ? { code: i3.css.toString(), map: jn(t3, i3.map), errors: [], dependencies: a3 } : { code: i3.css.toString(), errors: [], dependencies: a3 };
  }, sass: (e3, t3, r3, n3) => Ln(e3, t3, { ...r3, indentedSyntax: true }, n3), scss: Ln, styl: Mn, stylus: Mn };
  var Fn = { exports: {} }, Un = {};
  Object.defineProperty(Un, "__esModule", { value: true }), Un.getFileSystem = function() {
    return $n;
  }, Un.setFileSystem = function(e3) {
    $n.readFile = e3.readFile, $n.writeFile = e3.writeFile;
  };
  let $n = { readFile: () => {
    throw Error("readFile not implemented");
  }, writeFile: () => {
    throw Error("writeFile not implemented");
  } };
  var Vn = {}, qn = {};
  Object.defineProperty(qn, "__esModule", { value: true }), qn.default = function(e3) {
    return e3 ? (Wn.test(e3.charAt(0)) && (e3 = e3.substr(1)), Wn.test(e3.charAt(e3.length - 1)) && (e3 = e3.substr(0, e3.length - 1)), e3) : "";
  };
  const Wn = /['"]/;
  var Gn = {};
  const Hn = /[$]?[\w-]+/g;
  var zn = (e3, t3) => {
    let r3;
    for (; r3 = Hn.exec(e3); ) {
      const n3 = t3[r3[0]];
      n3 && (e3 = e3.slice(0, r3.index) + n3 + e3.slice(Hn.lastIndex), Hn.lastIndex -= r3[0].length - n3.length);
    }
    return e3;
  };
  const Kn = zn;
  const Xn = /^:import\(("[^"]*"|'[^']*'|[^"']+)\)$/, Jn = /^("[^"]*"|'[^']*'|[^"']+)$/, Yn = (e3) => {
    const t3 = {};
    return e3.walkDecls((e4) => {
      const r3 = e4.raws.before ? e4.raws.before.trim() : "";
      t3[r3 + e4.prop] = e4.value;
    }), t3;
  };
  const Qn = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "rule";
    return Object.keys(e3).map((n3) => {
      const s3 = e3[n3], i3 = Object.keys(s3).map((e4) => t3.decl({ prop: e4, value: s3[e4], raws: { before: "\n  " } })), o3 = i3.length > 0, a3 = "rule" === r3 ? t3.rule({ selector: `:import('${n3}')`, raws: { after: o3 ? "\n" : "" } }) : t3.atRule({ name: "icss-import", params: `'${n3}'`, raws: { after: o3 ? "\n" : "" } });
      return o3 && a3.append(i3), a3;
    });
  }, Zn = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "rule";
    const n3 = Object.keys(e3).map((r4) => t3.decl({ prop: r4, value: e3[r4], raws: { before: "\n  " } }));
    if (0 === n3.length) return [];
    const s3 = "rule" === r3 ? t3.rule({ selector: ":export", raws: { after: "\n" } }) : t3.atRule({ name: "icss-export", raws: { after: "\n" } });
    return s3.append(n3), [s3];
  };
  var es = { replaceValueSymbols: zn, replaceSymbols: (e3, t3) => {
    e3.walk((e4) => {
      "decl" === e4.type && e4.value ? e4.value = Kn(e4.value.toString(), t3) : "rule" === e4.type && e4.selector ? e4.selector = Kn(e4.selector.toString(), t3) : "atrule" === e4.type && e4.params && (e4.params = Kn(e4.params.toString(), t3));
    });
  }, extractICSS: function(e3) {
    let t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "auto";
    const n3 = {}, s3 = {};
    function i3(e4, r4) {
      const s4 = r4.replace(/'|"/g, "");
      n3[s4] = Object.assign(n3[s4] || {}, Yn(e4)), t3 && e4.remove();
    }
    function o3(e4) {
      Object.assign(s3, Yn(e4)), t3 && e4.remove();
    }
    return e3.each((e4) => {
      if ("rule" === e4.type && "at-rule" !== r3) {
        if (":import" === e4.selector.slice(0, 7)) {
          const t4 = Xn.exec(e4.selector);
          t4 && i3(e4, t4[1]);
        }
        ":export" === e4.selector && o3(e4);
      }
      if ("atrule" === e4.type && "rule" !== r3) {
        if ("icss-import" === e4.name) {
          const t4 = Jn.exec(e4.params);
          t4 && i3(e4, t4[1]);
        }
        "icss-export" === e4.name && o3(e4);
      }
    }), { icssImports: n3, icssExports: s3 };
  }, createICSSRules: (e3, t3, r3, n3) => [...Qn(e3, r3, n3), ...Zn(t3, r3, n3)] };
  Object.defineProperty(Gn, "__esModule", { value: true }), Gn.default = void 0;
  var ts = es;
  const rs = /^:import\((.+)\)$/;
  Gn.default = class {
    constructor(e3, t3) {
      this.pathFetcher = e3, this.plugin = this.plugin.bind(this), this.exportTokens = {}, this.translations = {}, this.trace = t3;
    }
    plugin() {
      const e3 = this;
      return { postcssPlugin: "css-modules-parser", OnceExit: async (t3) => (await Promise.all(e3.fetchAllImports(t3)), e3.linkImportedSymbols(t3), e3.extractExports(t3)) };
    }
    fetchAllImports(e3) {
      let t3 = [];
      return e3.each((r3) => {
        "rule" == r3.type && r3.selector.match(rs) && t3.push(this.fetchImport(r3, e3.source.input.from, t3.length));
      }), t3;
    }
    linkImportedSymbols(e3) {
      (0, ts.replaceSymbols)(e3, this.translations);
    }
    extractExports(e3) {
      e3.each((e4) => {
        "rule" == e4.type && ":export" == e4.selector && this.handleExport(e4);
      });
    }
    handleExport(e3) {
      e3.each((e4) => {
        "decl" == e4.type && (Object.keys(this.translations).forEach((t3) => {
          e4.value = e4.value.replace(t3, this.translations[t3]);
        }), this.exportTokens[e4.prop] = e4.value);
      }), e3.remove();
    }
    async fetchImport(e3, t3, r3) {
      const n3 = e3.selector.match(rs)[1], s3 = this.trace + String.fromCharCode(r3), i3 = await this.pathFetcher(n3, t3, s3);
      try {
        e3.each((e4) => {
          "decl" == e4.type && (this.translations[e4.prop] = i3[e4.value]);
        }), e3.remove();
      } catch (e4) {
      }
    }
  };
  var ns = {};
  Object.defineProperty(ns, "__esModule", { value: true }), ns.default = function(e3, t3) {
    return new Promise((r3, n3) => {
      const { writeFile: s3 } = (0, is.getFileSystem)();
      s3(`${e3}.json`, JSON.stringify(t3), (e4) => e4 ? n3(e4) : r3(t3));
    });
  };
  var ss, is = Un, os = {}, as = 1 / 0, ls = "[object Symbol]", cs = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, us = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, ps = "\\ud800-\\udfff", ds = "\\u0300-\\u036f\\ufe20-\\ufe23", fs = "\\u20d0-\\u20f0", hs = "\\u2700-\\u27bf", ms = "a-z\\xdf-\\xf6\\xf8-\\xff", ys = "A-Z\\xc0-\\xd6\\xd8-\\xde", gs = "\\ufe0e\\ufe0f", bs = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", vs = "[" + ps + "]", Es = "[" + bs + "]", Ss = "[" + ds + fs + "]", xs = "\\d+", Ts = "[" + hs + "]", ws = "[" + ms + "]", Ps = "[^" + ps + bs + xs + hs + ms + ys + "]", As = "\\ud83c[\\udffb-\\udfff]", Cs = "[^" + ps + "]", Os = "(?:\\ud83c[\\udde6-\\uddff]){2}", Is = "[\\ud800-\\udbff][\\udc00-\\udfff]", _s = "[" + ys + "]", ks = "\\u200d", Ns = "(?:" + ws + "|" + Ps + ")", Ds = "(?:" + _s + "|" + Ps + ")", js = "(?:['’](?:d|ll|m|re|s|t|ve))?", Ls = "(?:['’](?:D|LL|M|RE|S|T|VE))?", Ms = "(?:" + Ss + "|" + As + ")?", Bs = "[" + gs + "]?", Rs = Bs + Ms + "(?:" + ks + "(?:" + [Cs, Os, Is].join("|") + ")" + Bs + Ms + ")*", Fs = "(?:" + [Ts, Os, Is].join("|") + ")" + Rs, Us = "(?:" + [Cs + Ss + "?", Ss, Os, Is, vs].join("|") + ")", $s = RegExp("['’]", "g"), Vs = RegExp(Ss, "g"), qs = RegExp(As + "(?=" + As + ")|" + Us + Rs, "g"), Ws = RegExp([_s + "?" + ws + "+" + js + "(?=" + [Es, _s, "$"].join("|") + ")", Ds + "+" + Ls + "(?=" + [Es, _s + Ns, "$"].join("|") + ")", _s + "?" + Ns + "+" + js, _s + "+" + Ls, xs, Fs].join("|"), "g"), Gs = RegExp("[" + ks + ps + ds + fs + gs + "]"), Hs = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, zs = "object" == typeof V && V && V.Object === Object && V, Ks = "object" == typeof self && self && self.Object === Object && self, Xs = zs || Ks || Function("return this")(), Js = (ss = { À: "A", Á: "A", Â: "A", Ã: "A", Ä: "A", Å: "A", à: "a", á: "a", â: "a", ã: "a", ä: "a", å: "a", Ç: "C", ç: "c", Ð: "D", ð: "d", È: "E", É: "E", Ê: "E", Ë: "E", è: "e", é: "e", ê: "e", ë: "e", Ì: "I", Í: "I", Î: "I", Ï: "I", ì: "i", í: "i", î: "i", ï: "i", Ñ: "N", ñ: "n", Ò: "O", Ó: "O", Ô: "O", Õ: "O", Ö: "O", Ø: "O", ò: "o", ó: "o", ô: "o", õ: "o", ö: "o", ø: "o", Ù: "U", Ú: "U", Û: "U", Ü: "U", ù: "u", ú: "u", û: "u", ü: "u", Ý: "Y", ý: "y", ÿ: "y", Æ: "Ae", æ: "ae", Þ: "Th", þ: "th", ß: "ss", Ā: "A", Ă: "A", Ą: "A", ā: "a", ă: "a", ą: "a", Ć: "C", Ĉ: "C", Ċ: "C", Č: "C", ć: "c", ĉ: "c", ċ: "c", č: "c", Ď: "D", Đ: "D", ď: "d", đ: "d", Ē: "E", Ĕ: "E", Ė: "E", Ę: "E", Ě: "E", ē: "e", ĕ: "e", ė: "e", ę: "e", ě: "e", Ĝ: "G", Ğ: "G", Ġ: "G", Ģ: "G", ĝ: "g", ğ: "g", ġ: "g", ģ: "g", Ĥ: "H", Ħ: "H", ĥ: "h", ħ: "h", Ĩ: "I", Ī: "I", Ĭ: "I", Į: "I", İ: "I", ĩ: "i", ī: "i", ĭ: "i", į: "i", ı: "i", Ĵ: "J", ĵ: "j", Ķ: "K", ķ: "k", ĸ: "k", Ĺ: "L", Ļ: "L", Ľ: "L", Ŀ: "L", Ł: "L", ĺ: "l", ļ: "l", ľ: "l", ŀ: "l", ł: "l", Ń: "N", Ņ: "N", Ň: "N", Ŋ: "N", ń: "n", ņ: "n", ň: "n", ŋ: "n", Ō: "O", Ŏ: "O", Ő: "O", ō: "o", ŏ: "o", ő: "o", Ŕ: "R", Ŗ: "R", Ř: "R", ŕ: "r", ŗ: "r", ř: "r", Ś: "S", Ŝ: "S", Ş: "S", Š: "S", ś: "s", ŝ: "s", ş: "s", š: "s", Ţ: "T", Ť: "T", Ŧ: "T", ţ: "t", ť: "t", ŧ: "t", Ũ: "U", Ū: "U", Ŭ: "U", Ů: "U", Ű: "U", Ų: "U", ũ: "u", ū: "u", ŭ: "u", ů: "u", ű: "u", ų: "u", Ŵ: "W", ŵ: "w", Ŷ: "Y", ŷ: "y", Ÿ: "Y", Ź: "Z", Ż: "Z", Ž: "Z", ź: "z", ż: "z", ž: "z", Ĳ: "IJ", ĳ: "ij", Œ: "Oe", œ: "oe", ŉ: "'n", ſ: "ss" }, function(e3) {
    return null == ss ? void 0 : ss[e3];
  });
  function Ys(e3) {
    return Gs.test(e3);
  }
  var Qs = Object.prototype.toString, Zs = Xs.Symbol, ei = Zs ? Zs.prototype : void 0, ti = ei ? ei.toString : void 0;
  function ri(e3) {
    return null == e3 ? "" : function(e4) {
      if ("string" == typeof e4) return e4;
      if (function(e5) {
        return "symbol" == typeof e5 || /* @__PURE__ */ function(e6) {
          return !!e6 && "object" == typeof e6;
        }(e5) && Qs.call(e5) == ls;
      }(e4)) return ti ? ti.call(e4) : "";
      var t3 = e4 + "";
      return "0" == t3 && 1 / e4 == -as ? "-0" : t3;
    }(e3);
  }
  var ni, si = (ni = function(e3, t3, r3) {
    return t3 = t3.toLowerCase(), e3 + (r3 ? ii(ri(t3).toLowerCase()) : t3);
  }, function(e3) {
    return function(e4, t3, r3, n3) {
      for (var s3 = -1, i3 = e4 ? e4.length : 0; ++s3 < i3; ) r3 = t3(r3, e4[s3], s3, e4);
      return r3;
    }(function(e4, t3, r3) {
      return e4 = ri(e4), void 0 === t3 ? function(e5) {
        return Hs.test(e5);
      }(e4) ? function(e5) {
        return e5.match(Ws) || [];
      }(e4) : function(e5) {
        return e5.match(cs) || [];
      }(e4) : e4.match(t3) || [];
    }(function(e4) {
      return (e4 = ri(e4)) && e4.replace(us, Js).replace(Vs, "");
    }(e3).replace($s, "")), ni, "");
  }), ii = ("toUpperCase", function(e3) {
    var t3, r3, n3, s3, i3 = Ys(e3 = ri(e3)) ? function(e4) {
      return Ys(e4) ? function(e5) {
        return e5.match(qs) || [];
      }(e4) : function(e5) {
        return e5.split("");
      }(e4);
    }(e3) : void 0, o3 = i3 ? i3[0] : e3.charAt(0), a3 = i3 ? (t3 = i3, r3 = 1, s3 = t3.length, n3 = void 0 === n3 ? s3 : n3, !r3 && n3 >= s3 ? t3 : function(e4, t4, r4) {
      var n4 = -1, s4 = e4.length;
      t4 < 0 && (t4 = -t4 > s4 ? 0 : s4 + t4), (r4 = r4 > s4 ? s4 : r4) < 0 && (r4 += s4), s4 = t4 > r4 ? 0 : r4 - t4 >>> 0, t4 >>>= 0;
      for (var i4 = Array(s4); ++n4 < s4; ) i4[n4] = e4[n4 + t4];
      return i4;
    }(t3, r3, n3)).join("") : e3.slice(1);
    return o3.toUpperCase() + a3;
  }), oi = si;
  Object.defineProperty(os, "__esModule", { value: true }), os.makeLocalsConventionReducer = function(e3, t3) {
    const r3 = "function" == typeof e3;
    return (n3, s3) => {
      let [i3, o3] = s3;
      if (r3) return n3[e3(i3, o3, t3)] = o3, n3;
      switch (e3) {
        case "camelCase":
          n3[i3] = o3, n3[(0, li.default)(i3)] = o3;
          break;
        case "camelCaseOnly":
          n3[(0, li.default)(i3)] = o3;
          break;
        case "dashes":
          n3[i3] = o3, n3[ci(i3)] = o3;
          break;
        case "dashesOnly":
          n3[ci(i3)] = o3;
      }
      return n3;
    };
  };
  var ai, li = (ai = oi) && ai.__esModule ? ai : { default: ai };
  function ci(e3) {
    return e3.replace(/-+(\w)/g, (e4, t3) => t3.toUpperCase());
  }
  var ui = {};
  Object.defineProperty(ui, "__esModule", { value: true }), ui.default = void 0;
  var pi = mi(h), di = mi(l), fi = mi(Gn), hi = Un;
  function mi(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  }
  class yi {
    constructor(e3) {
      this.plugins = e3 || yi.defaultPlugins;
    }
    async load(e3, t3, r3, n3) {
      const s3 = new fi.default(n3, r3), i3 = this.plugins.concat([s3.plugin()]);
      return { injectableSource: (await (0, pi.default)(i3).process(e3, { from: t3 })).css, exportTokens: s3.exportTokens };
    }
  }
  const gi = (e3, t3) => e3.length < t3.length ? e3 < t3.substring(0, e3.length) ? -1 : 1 : e3.length > t3.length ? e3.substring(0, t3.length) <= t3 ? -1 : 1 : e3 < t3 ? -1 : 1;
  ui.default = class {
    constructor(e3, t3, r3) {
      if ("/" === e3 && "win32" === n2.platform) {
        const t4 = n2.cwd().slice(0, 3);
        if (!/^[A-Za-z]:\\$/.test(t4)) throw new Error(`Failed to obtain root from "${n2.cwd()}".`);
        e3 = t4;
      }
      this.root = e3, this.fileResolve = r3, this.sources = {}, this.traces = {}, this.importNr = 0, this.core = new yi(t3), this.tokensByFile = {}, this.fs = (0, hi.getFileSystem)();
    }
    async fetch(e3, t3, n3) {
      const s3 = e3.replace(/^["']|["']$/g, ""), i3 = n3 || String.fromCharCode(this.importNr++), o3 = "function" == typeof this.fileResolve, a3 = o3 ? await this.fileResolve(s3, t3) : await Promise.resolve();
      if (a3 && !di.default.isAbsolute(a3)) throw new Error('The returned path from the "fileResolve" option must be absolute.');
      const l2 = di.default.dirname(t3), c2 = a3 || di.default.resolve(l2, s3);
      let u2 = a3 || di.default.resolve(di.default.resolve(this.root, l2), s3);
      if (!o3 && "." !== s3[0] && !di.default.isAbsolute(s3)) try {
        u2 = r2(329).resolve(s3);
      } catch (e4) {
      }
      return this.tokensByFile[u2] || new Promise((e4, t4) => {
        this.fs.readFile(u2, "utf-8", async (r3, n4) => {
          r3 && t4(r3);
          const { injectableSource: s4, exportTokens: o4 } = await this.core.load(n4, c2, i3, this.fetch.bind(this));
          this.sources[u2] = s4, this.traces[i3] = u2, this.tokensByFile[u2] = o4, e4(o4);
        });
      });
    }
    get finalSource() {
      const e3 = this.traces, t3 = this.sources;
      let r3 = /* @__PURE__ */ new Set();
      return Object.keys(e3).sort(gi).map((n3) => {
        const s3 = e3[n3];
        return r3.has(s3) ? null : (r3.add(s3), t3[s3]);
      }).join("");
    }
  };
  var bi = {}, vi = { exports: {} };
  function Ei(e3, t3, r3, n3, s3) {
    if (2 === r3[e3]) return;
    if (1 === r3[e3]) return s3 ? function(e4, t4) {
      const r4 = new Error("Nondeterministic import's order"), n4 = t4[e4].find((r5) => t4[r5].indexOf(e4) > -1);
      return r4.nodes = [e4, n4], r4;
    }(e3, t3) : void 0;
    r3[e3] = 1;
    const i3 = t3[e3], o3 = i3.length;
    for (let e4 = 0; e4 < o3; ++e4) {
      const o4 = Ei(i3[e4], t3, r3, n3, s3);
      if (o4 instanceof Error) return o4;
    }
    r3[e3] = 2, n3.push(e3);
  }
  const Si = /^(.+?)\s+from\s+(?:"([^"]+)"|'([^']+)'|(global))$/, xi = /^:import\((?:"([^"]+)"|'([^']+)')\)/;
  function Ti(e3, t3, r3, n3) {
    const s3 = t3 + "_siblings", i3 = t3 + "_" + e3;
    if (1 !== n3[i3]) {
      Array.isArray(n3[s3]) || (n3[s3] = []);
      const t4 = n3[s3];
      Array.isArray(r3[e3]) ? r3[e3] = r3[e3].concat(t4) : r3[e3] = t4.slice(), n3[i3] = 1, t4.push(e3);
    }
  }
  vi.exports = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = 0;
    const r3 = "function" != typeof e3.createImportedName ? (e4) => `i__imported_${e4.replace(/\W/g, "_")}_${t3++}` : e3.createImportedName, n3 = e3.failOnWrongOrder;
    return { postcssPlugin: "postcss-modules-extract-imports", prepare() {
      const e4 = {}, t4 = {}, s3 = {}, i3 = {}, o3 = {};
      return { Once(a3, l2) {
        a3.walkRules((r4) => {
          const n4 = xi.exec(r4.selector);
          if (n4) {
            const [, i4, o4] = n4, a4 = i4 || o4;
            Ti(a4, "root", e4, t4), s3[a4] = r4;
          }
        }), a3.walkDecls(/^composes$/, (n4) => {
          const s4 = n4.value.match(Si);
          if (!s4) return;
          let a4, [, l3, c3, u3, p2] = s4;
          if (p2) a4 = l3.split(/\s+/).map((e5) => `global(${e5})`);
          else {
            const s5 = c3 || u3;
            let p3 = n4.parent, d2 = "";
            for (; "root" !== p3.type; ) d2 = p3.parent.index(p3) + "_" + d2, p3 = p3.parent;
            const { selector: f2 } = n4.parent;
            Ti(s5, `_${d2}${f2}`, e4, t4), i3[s5] = n4, o3[s5] = o3[s5] || {}, a4 = l3.split(/\s+/).map((e5) => (o3[s5][e5] || (o3[s5][e5] = r3(e5, s5)), o3[s5][e5]));
          }
          n4.value = a4.join(" ");
        });
        const c2 = function(e5, t5) {
          const r4 = [], n4 = {}, s4 = Object.keys(e5), i4 = s4.length;
          for (let o4 = 0; o4 < i4; ++o4) {
            const i5 = Ei(s4[o4], e5, n4, r4, t5);
            if (i5 instanceof Error) return i5;
          }
          return r4;
        }(e4, n3);
        if (c2 instanceof Error) {
          const e5 = c2.nodes.find((e6) => i3.hasOwnProperty(e6));
          throw i3[e5].error("Failed to resolve order of composed modules " + c2.nodes.map((e6) => "`" + e6 + "`").join(", ") + ".", { plugin: "postcss-modules-extract-imports", word: "composes" });
        }
        let u2;
        c2.forEach((e5) => {
          const t5 = o3[e5];
          let r4 = s3[e5];
          !r4 && t5 && (r4 = l2.rule({ selector: `:import("${e5}")`, raws: { after: "\n" } }), u2 ? a3.insertAfter(u2, r4) : a3.prepend(r4)), u2 = r4, t5 && Object.keys(t5).forEach((e6) => {
            r4.append(l2.decl({ value: e6, prop: t5[e6], raws: { before: "\n  " } }));
          });
        });
      } };
    } };
  }, vi.exports.postcss = true;
  var wi, Pi, Ai = vi.exports;
  function Ci() {
    if (Pi) return wi;
    Pi = 1;
    const e3 = {};
    return wi = class {
      constructor(e4, t3) {
        this.hashKey = t3, "function" == typeof e4 ? (this.hashFactory = e4, this.hash = void 0) : (this.hashFactory = void 0, this.hash = e4), this.buffer = "";
      }
      update(e4, t3) {
        return void 0 !== t3 || "string" != typeof e4 || e4.length > 2e3 ? (void 0 === this.hash && (this.hash = this.hashFactory()), this.buffer.length > 0 && (this.hash.update(this.buffer), this.buffer = ""), this.hash.update(e4, t3)) : (this.buffer += e4, this.buffer.length > 2e3 && (void 0 === this.hash && (this.hash = this.hashFactory()), this.hash.update(this.buffer), this.buffer = "")), this;
      }
      digest(t3) {
        let r3;
        const n3 = this.buffer;
        if (void 0 === this.hash) {
          const s4 = `${this.hashKey}-${t3}`;
          r3 = e3[s4], void 0 === r3 && (r3 = e3[s4] = /* @__PURE__ */ new Map());
          const i3 = r3.get(n3);
          if (void 0 !== i3) return i3;
          this.hash = this.hashFactory();
        }
        n3.length > 0 && this.hash.update(n3);
        const s3 = this.hash.digest(t3);
        return void 0 !== r3 && r3.set(n3, s3), s3;
      }
    };
  }
  var Oi, Ii, _i, ki, Ni, Di, ji, Li = { exports: {} };
  function Mi() {
    if (Oi) return Li.exports;
    Oi = 1;
    const e3 = -4 & Math.floor(16368);
    class t3 {
      constructor(e4, t4, r3, n3) {
        const i3 = e4.exports;
        i3.init(), this.exports = i3, this.mem = s2.from(i3.memory.buffer, 0, 65536), this.buffered = 0, this.instancesPool = t4, this.chunkSize = r3, this.digestSize = n3;
      }
      reset() {
        this.buffered = 0, this.exports.init();
      }
      update(t4, r3) {
        if ("string" == typeof t4) {
          for (; t4.length > e3; ) this._updateWithShortString(t4.slice(0, e3), r3), t4 = t4.slice(e3);
          return this._updateWithShortString(t4, r3), this;
        }
        return this._updateWithBuffer(t4), this;
      }
      _updateWithShortString(e4, t4) {
        const { exports: r3, buffered: n3, mem: s3, chunkSize: i3 } = this;
        let o3;
        if (e4.length < 70) if (t4 && "utf-8" !== t4 && "utf8" !== t4) if ("latin1" === t4) {
          o3 = n3;
          for (let t5 = 0; t5 < e4.length; t5++) {
            const r4 = e4.charCodeAt(t5);
            s3[o3++] = r4;
          }
        } else o3 = n3 + s3.write(e4, n3, t4);
        else {
          o3 = n3;
          for (let r4 = 0; r4 < e4.length; r4++) {
            const n4 = e4.charCodeAt(r4);
            if (n4 < 128) s3[o3++] = n4;
            else {
              if (!(n4 < 2048)) {
                o3 += s3.write(e4.slice(r4), o3, t4);
                break;
              }
              s3[o3] = n4 >> 6 | 192, s3[o3 + 1] = 63 & n4 | 128, o3 += 2;
            }
          }
        }
        else o3 = n3 + s3.write(e4, n3, t4);
        if (o3 < i3) this.buffered = o3;
        else {
          const e5 = o3 & ~(this.chunkSize - 1);
          r3.update(e5);
          const t5 = o3 - e5;
          this.buffered = t5, t5 > 0 && s3.copyWithin(0, e5, o3);
        }
      }
      _updateWithBuffer(e4) {
        const { exports: t4, buffered: r3, mem: n3 } = this, s3 = e4.length;
        if (r3 + s3 < this.chunkSize) e4.copy(n3, r3, 0, s3), this.buffered += s3;
        else {
          const i3 = r3 + s3 & ~(this.chunkSize - 1);
          if (i3 > 65536) {
            let s4 = 65536 - r3;
            e4.copy(n3, r3, 0, s4), t4.update(65536);
            const o4 = i3 - r3 - 65536;
            for (; s4 < o4; ) e4.copy(n3, 0, s4, s4 + 65536), t4.update(65536), s4 += 65536;
            e4.copy(n3, 0, s4, i3 - r3), t4.update(i3 - r3 - s4);
          } else e4.copy(n3, r3, 0, i3 - r3), t4.update(i3);
          const o3 = s3 + r3 - i3;
          this.buffered = o3, o3 > 0 && e4.copy(n3, 0, s3 - o3, s3);
        }
      }
      digest(e4) {
        const { exports: t4, buffered: r3, mem: n3, digestSize: i3 } = this;
        t4.final(r3), this.instancesPool.push(this);
        const o3 = n3.toString("latin1", 0, i3);
        return "hex" === e4 ? o3 : "binary" !== e4 && e4 ? s2.from(o3, "hex").toString(e4) : s2.from(o3, "hex");
      }
    }
    return Li.exports = (e4, r3, n3, s3) => {
      if (r3.length > 0) {
        const e5 = r3.pop();
        return e5.reset(), e5;
      }
      return new t3(new WebAssembly.Instance(e4), r3, n3, s3);
    }, Li.exports.MAX_SHORT_STRING = e3, Li.exports;
  }
  function Bi() {
    if (Ni) return ki;
    Ni = 1;
    const e3 = Mi().MAX_SHORT_STRING;
    return ki = class {
      constructor(e4) {
        this.string = void 0, this.encoding = void 0, this.hash = e4;
      }
      update(t3, r3) {
        if (void 0 !== this.string) {
          if ("string" == typeof t3 && r3 === this.encoding && this.string.length + t3.length < e3) return this.string += t3, this;
          this.hash.update(this.string, this.encoding), this.string = void 0;
        }
        return "string" == typeof t3 ? !(t3.length < e3) || r3 && r3.startsWith("ba") ? this.hash.update(t3, r3) : (this.string = t3, this.encoding = r3) : this.hash.update(t3), this;
      }
      digest(e4) {
        return void 0 !== this.string && this.hash.update(this.string, this.encoding), this.hash.digest(e4);
      }
    };
  }
  const Ri = { 26: "abcdefghijklmnopqrstuvwxyz", 32: "123456789abcdefghjkmnpqrstuvwxyz", 36: "0123456789abcdefghijklmnopqrstuvwxyz", 49: "abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ", 52: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", 58: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ", 62: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", 64: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_" };
  function Fi(e3, t3) {
    let r3 = 0;
    for (let n3 = e3.length - 1; n3 >= 0; n3--) {
      const s3 = 4294967296 * r3 + e3[n3];
      r3 = s3 % t3, e3[n3] = Math.floor(s3 / t3);
    }
    return r3;
  }
  let Ui, $i, Vi, qi, Wi;
  const Gi = l, Hi = function(e3, t3, n3, i3) {
    let o3;
    return i3 = i3 || 9999, "xxhash64" === (t3 = t3 || "xxhash64") ? (void 0 === $i && ($i = function() {
      if (ji) return Di;
      ji = 1;
      const e4 = Mi(), t4 = new WebAssembly.Module(s2.from("AGFzbQEAAAABCAJgAX8AYAAAAwQDAQAABQMBAAEGGgV+AUIAC34BQgALfgFCAAt+AUIAC34BQgALByIEBGluaXQAAAZ1cGRhdGUAAQVmaW5hbAACBm1lbW9yeQIACrUIAzAAQtbrgu7q/Yn14AAkAELP1tO+0ser2UIkAUIAJAJC+erQ0OfJoeThACQDQgAkBAvUAQIBfwR+IABFBEAPCyMEIACtfCQEIwAhAiMBIQMjAiEEIwMhBQNAIAIgASkDAELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiECIAMgASkDCELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEDIAQgASkDEELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEEIAUgASkDGELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEFIAAgAUEgaiIBSw0ACyACJAAgAyQBIAQkAiAFJAMLqwYCAX8EfiMEQgBSBH4jACICQgGJIwEiA0IHiXwjAiIEQgyJfCMDIgVCEol8IAJCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0gA0LP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkKdo7Xqg7GNivoAfSAEQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IAVCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0FQsXP2bLx5brqJwsjBCAArXx8IQIDQCABQQhqIABNBEAgAiABKQMAQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQhuJQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IQIgAUEIaiEBDAELCyABQQRqIABNBEACfyACIAE1AgBCh5Wvr5i23puef36FQheJQs/W077Sx6vZQn5C+fPd8Zn2masWfCECIAFBBGoLIQELA0AgACABRwRAIAIgATEAAELFz9my8eW66id+hUILiUKHla+vmLbem55/fiECIAFBAWohAQwBCwtBACACIAJCIYiFQs/W077Sx6vZQn4iAiACQh2IhUL5893xmfaZqxZ+IgIgAkIgiIUiAkIgiCIDQv//A4NCIIYgA0KAgPz/D4NCEIiEIgNC/4GAgPAfg0IQhiADQoD+g4CA4D+DQgiIhCIDQo+AvIDwgcAHg0IIhiADQvCBwIeAnoD4AINCBIiEIgNChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IANCsODAgYOGjJgwhHw3AwBBCCACQv////8PgyICQv//A4NCIIYgAkKAgPz/D4NCEIiEIgJC/4GAgPAfg0IQhiACQoD+g4CA4D+DQgiIhCICQo+AvIDwgcAHg0IIhiACQvCBwIeAnoD4AINCBIiEIgJChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IAJCsODAgYOGjJgwhHw3AwAL", "base64"));
      return Di = e4.bind(null, t4, [], 32, 16);
    }(), void 0 === qi && (qi = Bi())), o3 = new qi($i())) : "md4" === t3 ? (void 0 === Vi && (Vi = function() {
      if (_i) return Ii;
      _i = 1;
      const e4 = Mi(), t4 = new WebAssembly.Module(s2.from("AGFzbQEAAAABCAJgAX8AYAAAAwUEAQAAAAUDAQABBhoFfwFBAAt/AUEAC38BQQALfwFBAAt/AUEACwciBARpbml0AAAGdXBkYXRlAAIFZmluYWwAAwZtZW1vcnkCAAqFEAQmAEGBxpS6BiQBQYnXtv5+JAJB/rnrxXkkA0H2qMmBASQEQQAkAAvMCgEYfyMBIQojAiEGIwMhByMEIQgDQCAAIAVLBEAgBSgCCCINIAcgBiAFKAIEIgsgCCAHIAUoAgAiDCAKIAggBiAHIAhzcXNqakEDdyIDIAYgB3Nxc2pqQQd3IgEgAyAGc3FzampBC3chAiAFKAIUIg8gASACIAUoAhAiCSADIAEgBSgCDCIOIAYgAyACIAEgA3Nxc2pqQRN3IgQgASACc3FzampBA3ciAyACIARzcXNqakEHdyEBIAUoAiAiEiADIAEgBSgCHCIRIAQgAyAFKAIYIhAgAiAEIAEgAyAEc3FzampBC3ciAiABIANzcXNqakETdyIEIAEgAnNxc2pqQQN3IQMgBSgCLCIVIAQgAyAFKAIoIhQgAiAEIAUoAiQiEyABIAIgAyACIARzcXNqakEHdyIBIAMgBHNxc2pqQQt3IgIgASADc3FzampBE3chBCAPIBAgCSAVIBQgEyAFKAI4IhYgAiAEIAUoAjQiFyABIAIgBSgCMCIYIAMgASAEIAEgAnNxc2pqQQN3IgEgAiAEc3FzampBB3ciAiABIARzcXNqakELdyIDIAkgAiAMIAEgBSgCPCIJIAQgASADIAEgAnNxc2pqQRN3IgEgAiADcnEgAiADcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyaiASakGZ84nUBWpBCXciAyAPIAQgCyACIBggASADIAIgBHJxIAIgBHFyampBmfOJ1AVqQQ13IgEgAyAEcnEgAyAEcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyampBmfOJ1AVqQQl3IgMgECAEIAIgFyABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmogDWpBmfOJ1AVqQQN3IgIgASADcnEgASADcXJqakGZ84nUBWpBBXciBCABIAJycSABIAJxcmpqQZnzidQFakEJdyIDIBEgBCAOIAIgFiABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmpqQZnzidQFakEDdyICIAEgA3JxIAEgA3FyampBmfOJ1AVqQQV3IgQgASACcnEgASACcXJqakGZ84nUBWpBCXciAyAMIAIgAyAJIAEgAyACIARycSACIARxcmpqQZnzidQFakENdyIBcyAEc2pqQaHX5/YGakEDdyICIAQgASACcyADc2ogEmpBodfn9gZqQQl3IgRzIAFzampBodfn9gZqQQt3IgMgAiADIBggASADIARzIAJzampBodfn9gZqQQ93IgFzIARzaiANakGh1+f2BmpBA3ciAiAUIAQgASACcyADc2pqQaHX5/YGakEJdyIEcyABc2pqQaHX5/YGakELdyIDIAsgAiADIBYgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgIgEyAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3chAyAKIA4gAiADIBcgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgJqIQogBiAJIAEgESADIAIgFSAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3ciAyAEcyACc2pqQaHX5/YGakEPd2ohBiADIAdqIQcgBCAIaiEIIAVBQGshBQwBCwsgCiQBIAYkAiAHJAMgCCQECw0AIAAQASMAIABqJAAL/wQCA38BfiMAIABqrUIDhiEEIABByABqQUBxIgJBCGshAyAAIgFBAWohACABQYABOgAAA0AgACACSUEAIABBB3EbBEAgAEEAOgAAIABBAWohAAwBCwsDQCAAIAJJBEAgAEIANwMAIABBCGohAAwBCwsgAyAENwMAIAIQAUEAIwGtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEIIwKtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEQIwOtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEYIwStIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAAs=", "base64"));
      return Ii = e4.bind(null, t4, [], 64, 32);
    }(), void 0 === qi && (qi = Bi())), o3 = new qi(Vi())) : "native-md4" === t3 ? (void 0 === Ui && (Ui = r2(343), void 0 === Wi && (Wi = Ci())), o3 = new Wi(() => Ui.createHash("md4"), "md4")) : (void 0 === Ui && (Ui = r2(343), void 0 === Wi && (Wi = Ci())), o3 = new Wi(() => Ui.createHash(t3), t3)), o3.update(e3), "base26" === n3 || "base32" === n3 || "base36" === n3 || "base49" === n3 || "base52" === n3 || "base58" === n3 || "base62" === n3 ? function(e4, t4, r3) {
      const n4 = Ri[t4];
      if (!n4) throw new Error("Unknown encoding base" + t4);
      const i4 = Math.ceil(8 * e4.length / Math.log2(t4));
      r3 = Math.min(r3, i4);
      const o4 = new Uint32Array(Math.ceil(e4.length / 4));
      e4.copy(s2.from(o4.buffer));
      let a3 = "";
      for (let e5 = 0; e5 < r3; e5++) a3 = n4[Fi(o4, t4)] + a3;
      return a3;
    }(o3.digest(), n3.substr(4), i3) : o3.digest(n3 || "hex").substr(0, i3);
  };
  var zi, Ki, Xi = function(e3, t3) {
    let r3, n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    const s3 = e3.resourceQuery && e3.resourceQuery.length > 1;
    r3 = "function" == typeof t3 ? t3(e3.resourcePath, s3 ? e3.resourceQuery : void 0) : t3 || "[hash].[ext]";
    const i3 = n3.context, o3 = n3.content, a3 = n3.regExp;
    let l2 = "bin", c2 = "file", u2 = "", p2 = "", d2 = "";
    if (e3.resourcePath) {
      const t4 = Gi.parse(e3.resourcePath);
      let r4 = e3.resourcePath;
      t4.ext && (l2 = t4.ext.substr(1)), t4.dir && (c2 = t4.name, r4 = t4.dir + Gi.sep), void 0 !== i3 ? (u2 = Gi.relative(i3, r4 + "_").replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1"), u2 = u2.substr(0, u2.length - 1)) : u2 = r4.replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1"), 1 === u2.length ? u2 = "" : u2.length > 1 && (p2 = Gi.basename(u2));
    }
    if (e3.resourceQuery && e3.resourceQuery.length > 1) {
      d2 = e3.resourceQuery;
      const t4 = d2.indexOf("#");
      t4 >= 0 && (d2 = d2.substr(0, t4));
    }
    let f2 = r3;
    if (o3 && (f2 = f2.replace(/\[(?:([^[:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*))?(?::(\d+))?\]/gi, (e4, t4, r4, n4) => Hi(o3, t4, r4, parseInt(n4, 10)))), f2 = f2.replace(/\[ext\]/gi, () => l2).replace(/\[name\]/gi, () => c2).replace(/\[path\]/gi, () => u2).replace(/\[folder\]/gi, () => p2).replace(/\[query\]/gi, () => d2), a3 && e3.resourcePath) {
      const t4 = e3.resourcePath.match(new RegExp(a3));
      t4 && t4.forEach((e4, t5) => {
        f2 = f2.replace(new RegExp("\\[" + t5 + "\\]", "ig"), e4);
      });
    }
    return "object" == typeof e3.options && "function" == typeof e3.options.customInterpolateName && (f2 = e3.options.customInterpolateName.call(e3, f2, t3, n3)), f2;
  }, Ji = l, Yi = { exports: {} }, Qi = "(".charCodeAt(0), Zi = ")".charCodeAt(0), eo = "'".charCodeAt(0), to = '"'.charCodeAt(0), ro = "\\".charCodeAt(0), no = "/".charCodeAt(0), so = ",".charCodeAt(0), io = ":".charCodeAt(0), oo = "*".charCodeAt(0), ao = "u".charCodeAt(0), lo = "U".charCodeAt(0), co = "+".charCodeAt(0), uo = /^[a-f0-9?-]+$/i;
  function po(e3, t3) {
    var r3, n3, s3 = e3.type, i3 = e3.value;
    return t3 && void 0 !== (n3 = t3(e3)) ? n3 : "word" === s3 || "space" === s3 ? i3 : "string" === s3 ? (r3 = e3.quote || "") + i3 + (e3.unclosed ? "" : r3) : "comment" === s3 ? "/*" + i3 + (e3.unclosed ? "" : "*/") : "div" === s3 ? (e3.before || "") + i3 + (e3.after || "") : Array.isArray(e3.nodes) ? (r3 = fo(e3.nodes, t3), "function" !== s3 ? r3 : i3 + "(" + (e3.before || "") + r3 + (e3.after || "") + (e3.unclosed ? "" : ")")) : i3;
  }
  function fo(e3, t3) {
    var r3, n3;
    if (Array.isArray(e3)) {
      for (r3 = "", n3 = e3.length - 1; ~n3; n3 -= 1) r3 = po(e3[n3], t3) + r3;
      return r3;
    }
    return po(e3, t3);
  }
  var ho = function e3(t3, r3, n3) {
    var s3, i3, o3, a3;
    for (s3 = 0, i3 = t3.length; s3 < i3; s3 += 1) o3 = t3[s3], n3 || (a3 = r3(o3, s3, t3)), false !== a3 && "function" === o3.type && Array.isArray(o3.nodes) && e3(o3.nodes, r3, n3), n3 && r3(o3, s3, t3);
  }, mo = fo;
  function yo(e3) {
    return this instanceof yo ? (this.nodes = function(e4) {
      for (var t3, r3, n3, s3, i3, o3, a3, l2, c2, u2 = [], p2 = e4, d2 = 0, f2 = p2.charCodeAt(d2), h2 = p2.length, m2 = [{ nodes: u2 }], y2 = 0, g2 = "", b2 = "", v2 = ""; d2 < h2; ) if (f2 <= 32) {
        t3 = d2;
        do {
          t3 += 1, f2 = p2.charCodeAt(t3);
        } while (f2 <= 32);
        s3 = p2.slice(d2, t3), n3 = u2[u2.length - 1], f2 === Zi && y2 ? v2 = s3 : n3 && "div" === n3.type ? (n3.after = s3, n3.sourceEndIndex += s3.length) : f2 === so || f2 === io || f2 === no && p2.charCodeAt(t3 + 1) !== oo && (!c2 || c2 && "function" === c2.type && "calc" !== c2.value) ? b2 = s3 : u2.push({ type: "space", sourceIndex: d2, sourceEndIndex: t3, value: s3 }), d2 = t3;
      } else if (f2 === eo || f2 === to) {
        t3 = d2, s3 = { type: "string", sourceIndex: d2, quote: r3 = f2 === eo ? "'" : '"' };
        do {
          if (i3 = false, ~(t3 = p2.indexOf(r3, t3 + 1))) for (o3 = t3; p2.charCodeAt(o3 - 1) === ro; ) o3 -= 1, i3 = !i3;
          else t3 = (p2 += r3).length - 1, s3.unclosed = true;
        } while (i3);
        s3.value = p2.slice(d2 + 1, t3), s3.sourceEndIndex = s3.unclosed ? t3 : t3 + 1, u2.push(s3), d2 = t3 + 1, f2 = p2.charCodeAt(d2);
      } else if (f2 === no && p2.charCodeAt(d2 + 1) === oo) s3 = { type: "comment", sourceIndex: d2, sourceEndIndex: (t3 = p2.indexOf("*/", d2)) + 2 }, -1 === t3 && (s3.unclosed = true, t3 = p2.length, s3.sourceEndIndex = t3), s3.value = p2.slice(d2 + 2, t3), u2.push(s3), d2 = t3 + 2, f2 = p2.charCodeAt(d2);
      else if (f2 !== no && f2 !== oo || !c2 || "function" !== c2.type || "calc" !== c2.value) if (f2 === no || f2 === so || f2 === io) s3 = p2[d2], u2.push({ type: "div", sourceIndex: d2 - b2.length, sourceEndIndex: d2 + s3.length, value: s3, before: b2, after: "" }), b2 = "", d2 += 1, f2 = p2.charCodeAt(d2);
      else if (Qi === f2) {
        t3 = d2;
        do {
          t3 += 1, f2 = p2.charCodeAt(t3);
        } while (f2 <= 32);
        if (l2 = d2, s3 = { type: "function", sourceIndex: d2 - g2.length, value: g2, before: p2.slice(l2 + 1, t3) }, d2 = t3, "url" === g2 && f2 !== eo && f2 !== to) {
          t3 -= 1;
          do {
            if (i3 = false, ~(t3 = p2.indexOf(")", t3 + 1))) for (o3 = t3; p2.charCodeAt(o3 - 1) === ro; ) o3 -= 1, i3 = !i3;
            else t3 = (p2 += ")").length - 1, s3.unclosed = true;
          } while (i3);
          a3 = t3;
          do {
            a3 -= 1, f2 = p2.charCodeAt(a3);
          } while (f2 <= 32);
          l2 < a3 ? (s3.nodes = d2 !== a3 + 1 ? [{ type: "word", sourceIndex: d2, sourceEndIndex: a3 + 1, value: p2.slice(d2, a3 + 1) }] : [], s3.unclosed && a3 + 1 !== t3 ? (s3.after = "", s3.nodes.push({ type: "space", sourceIndex: a3 + 1, sourceEndIndex: t3, value: p2.slice(a3 + 1, t3) })) : (s3.after = p2.slice(a3 + 1, t3), s3.sourceEndIndex = t3)) : (s3.after = "", s3.nodes = []), d2 = t3 + 1, s3.sourceEndIndex = s3.unclosed ? t3 : d2, f2 = p2.charCodeAt(d2), u2.push(s3);
        } else y2 += 1, s3.after = "", s3.sourceEndIndex = d2 + 1, u2.push(s3), m2.push(s3), u2 = s3.nodes = [], c2 = s3;
        g2 = "";
      } else if (Zi === f2 && y2) d2 += 1, f2 = p2.charCodeAt(d2), c2.after = v2, c2.sourceEndIndex += v2.length, v2 = "", y2 -= 1, m2[m2.length - 1].sourceEndIndex = d2, m2.pop(), u2 = (c2 = m2[y2]).nodes;
      else {
        t3 = d2;
        do {
          f2 === ro && (t3 += 1), t3 += 1, f2 = p2.charCodeAt(t3);
        } while (t3 < h2 && !(f2 <= 32 || f2 === eo || f2 === to || f2 === so || f2 === io || f2 === no || f2 === Qi || f2 === oo && c2 && "function" === c2.type && "calc" === c2.value || f2 === no && "function" === c2.type && "calc" === c2.value || f2 === Zi && y2));
        s3 = p2.slice(d2, t3), Qi === f2 ? g2 = s3 : ao !== s3.charCodeAt(0) && lo !== s3.charCodeAt(0) || co !== s3.charCodeAt(1) || !uo.test(s3.slice(2)) ? u2.push({ type: "word", sourceIndex: d2, sourceEndIndex: t3, value: s3 }) : u2.push({ type: "unicode-range", sourceIndex: d2, sourceEndIndex: t3, value: s3 }), d2 = t3;
      }
      else s3 = p2[d2], u2.push({ type: "word", sourceIndex: d2 - b2.length, sourceEndIndex: d2 + s3.length, value: s3 }), d2 += 1, f2 = p2.charCodeAt(d2);
      for (d2 = m2.length - 1; d2; d2 -= 1) m2[d2].unclosed = true, m2[d2].sourceEndIndex = p2.length;
      return m2[0].nodes;
    }(e3), this) : new yo(e3);
  }
  yo.prototype.toString = function() {
    return Array.isArray(this.nodes) ? mo(this.nodes) : "";
  }, yo.prototype.walk = function(e3, t3) {
    return ho(this.nodes, e3, t3), this;
  }, yo.unit = function() {
    if (Ki) return zi;
    Ki = 1;
    var e3 = "-".charCodeAt(0), t3 = "+".charCodeAt(0), r3 = ".".charCodeAt(0), n3 = "e".charCodeAt(0), s3 = "E".charCodeAt(0);
    return zi = function(i3) {
      var o3, a3, l2, c2 = 0, u2 = i3.length;
      if (0 === u2 || !function(n4) {
        var s4, i4 = n4.charCodeAt(0);
        if (i4 === t3 || i4 === e3) {
          if ((s4 = n4.charCodeAt(1)) >= 48 && s4 <= 57) return true;
          var o4 = n4.charCodeAt(2);
          return s4 === r3 && o4 >= 48 && o4 <= 57;
        }
        return i4 === r3 ? (s4 = n4.charCodeAt(1)) >= 48 && s4 <= 57 : i4 >= 48 && i4 <= 57;
      }(i3)) return false;
      for ((o3 = i3.charCodeAt(c2)) !== t3 && o3 !== e3 || c2++; c2 < u2 && !((o3 = i3.charCodeAt(c2)) < 48 || o3 > 57); ) c2 += 1;
      if (o3 = i3.charCodeAt(c2), a3 = i3.charCodeAt(c2 + 1), o3 === r3 && a3 >= 48 && a3 <= 57) for (c2 += 2; c2 < u2 && !((o3 = i3.charCodeAt(c2)) < 48 || o3 > 57); ) c2 += 1;
      if (o3 = i3.charCodeAt(c2), a3 = i3.charCodeAt(c2 + 1), l2 = i3.charCodeAt(c2 + 2), (o3 === n3 || o3 === s3) && (a3 >= 48 && a3 <= 57 || (a3 === t3 || a3 === e3) && l2 >= 48 && l2 <= 57)) for (c2 += a3 === t3 || a3 === e3 ? 3 : 2; c2 < u2 && !((o3 = i3.charCodeAt(c2)) < 48 || o3 > 57); ) c2 += 1;
      return { number: i3.slice(0, c2), unit: i3.slice(c2) };
    };
  }(), yo.walk = ho, yo.stringify = mo;
  const go = Lr, bo = yo, { extractICSS: vo } = es, Eo = (e3) => "combinator" === e3.type && " " === e3.value;
  function So(e3) {
    const t3 = [];
    return e3.forEach((e4) => {
      Array.isArray(e4) ? So(e4).forEach((e5) => {
        t3.push(e5);
      }) : e4 && t3.push(e4);
    }), t3.length > 0 && Eo(t3[t3.length - 1]) && t3.pop(), t3;
  }
  function xo(e3, t3) {
    switch (e3.type) {
      case "word":
        t3.localizeNextItem && (t3.localAliasMap.has(e3.value) || (e3.value = ":local(" + e3.value + ")", t3.localizeNextItem = false));
        break;
      case "function":
        t3.options && t3.options.rewriteUrl && "url" === e3.value.toLowerCase() && e3.nodes.map((e4) => {
          if ("string" !== e4.type && "word" !== e4.type) return;
          let r3 = t3.options.rewriteUrl(t3.global, e4.value);
          switch (e4.type) {
            case "string":
              "'" === e4.quote && (r3 = r3.replace(/(\\)/g, "\\$1").replace(/'/g, "\\'")), '"' === e4.quote && (r3 = r3.replace(/(\\)/g, "\\$1").replace(/"/g, '\\"'));
              break;
            case "word":
              r3 = r3.replace(/("|'|\)|\\)/g, "\\$1");
          }
          e4.value = r3;
        });
    }
    return e3;
  }
  const To = ["none", "inherit", "initial", "revert", "revert-layer", "unset"];
  function wo(e3, t3, r3) {
    const n3 = bo(t3.value);
    n3.walk((t4, n4, s3) => {
      if ("function" === t4.type && ("var" === t4.value.toLowerCase() || "env" === t4.value.toLowerCase())) return false;
      if ("word" === t4.type && To.includes(t4.value.toLowerCase())) return;
      const i3 = { options: r3.options, global: r3.global, localizeNextItem: e3 && !r3.global, localAliasMap: r3.localAliasMap };
      s3[n4] = xo(t4, i3);
    }), t3.value = n3.toString();
  }
  function Po(e3, t3) {
    if (!/animation$/i.test(e3.prop)) return /animation(-name)?$/i.test(e3.prop) ? wo(true, e3, t3) : /url\(/i.test(e3.value) ? wo(false, e3, t3) : void 0;
    {
      const r3 = /^-?([a-z\u0080-\uFFFF_]|(\\[^\r\n\f])|-)((\\[^\r\n\f])|[a-z\u0080-\uFFFF_0-9-])*$/i, n3 = { $normal: 1, $reverse: 1, $alternate: 1, "$alternate-reverse": 1, $forwards: 1, $backwards: 1, $both: 1, $infinite: 1, $paused: 1, $running: 1, $ease: 1, "$ease-in": 1, "$ease-out": 1, "$ease-in-out": 1, $linear: 1, "$step-end": 1, "$step-start": 1, $none: 1 / 0, $initial: 1 / 0, $inherit: 1 / 0, $unset: 1 / 0, $revert: 1 / 0, "$revert-layer": 1 / 0 };
      let s3 = {};
      const i3 = bo(e3.value).walk((e4) => {
        if ("div" === e4.type) return void (s3 = {});
        if ("function" === e4.type) return false;
        if ("word" !== e4.type) return;
        const i4 = "word" === e4.type ? e4.value.toLowerCase() : null;
        let o3 = false;
        return i4 && r3.test(i4) && ("$" + i4 in n3 ? (s3["$" + i4] = "$" + i4 in s3 ? s3["$" + i4] + 1 : 0, o3 = s3["$" + i4] >= n3["$" + i4]) : o3 = true), xo(e4, { options: t3.options, global: t3.global, localizeNextItem: o3 && !t3.global, localAliasMap: t3.localAliasMap });
      });
      e3.value = i3.toString();
    }
  }
  Yi.exports = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (e3 && e3.mode && "global" !== e3.mode && "local" !== e3.mode && "pure" !== e3.mode) throw new Error('options.mode must be either "global", "local" or "pure" (default "local")');
    const t3 = e3 && "pure" === e3.mode, r3 = e3 && "global" === e3.mode;
    return { postcssPlugin: "postcss-modules-local-by-default", prepare() {
      const n3 = /* @__PURE__ */ new Map();
      return { Once(s3) {
        const { icssImports: i3 } = vo(s3, false);
        Object.keys(i3).forEach((e4) => {
          Object.keys(i3[e4]).forEach((t4) => {
            n3.set(t4, i3[e4][t4]);
          });
        }), s3.walkAtRules((s4) => {
          if (/keyframes$/i.test(s4.name)) {
            const i4 = /^\s*:global\s*\((.+)\)\s*$/.exec(s4.params), o3 = /^\s*:local\s*\((.+)\)\s*$/.exec(s4.params);
            let a3 = r3;
            if (i4) {
              if (t3) throw s4.error("@keyframes :global(...) is not allowed in pure mode");
              s4.params = i4[1], a3 = true;
            } else o3 ? (s4.params = o3[0], a3 = false) : r3 || s4.params && !n3.has(s4.params) && (s4.params = ":local(" + s4.params + ")");
            s4.walkDecls((t4) => {
              Po(t4, { localAliasMap: n3, options: e3, global: a3 });
            });
          } else s4.nodes && s4.nodes.forEach((t4) => {
            "decl" === t4.type && Po(t4, { localAliasMap: n3, options: e3, global: r3 });
          });
        }), s3.walkRules((r4) => {
          if (r4.parent && "atrule" === r4.parent.type && /keyframes$/i.test(r4.parent.name)) return;
          const s4 = function(e4, t4, r5) {
            const n4 = (e5, t5) => {
              if (t5.ignoreNextSpacing && !Eo(e5)) throw new Error("Missing whitespace after " + t5.ignoreNextSpacing);
              if (t5.enforceNoSpacing && Eo(e5)) throw new Error("Missing whitespace before " + t5.enforceNoSpacing);
              let s6;
              switch (e5.type) {
                case "root": {
                  let r6;
                  t5.hasPureGlobals = false, s6 = e5.nodes.map((s7) => {
                    const i4 = { global: t5.global, lastWasSpacing: true, hasLocals: false, explicit: false };
                    if (s7 = n4(s7, i4), void 0 === r6) r6 = i4.global;
                    else if (r6 !== i4.global) throw new Error('Inconsistent rule global/local result in rule "' + e5 + '" (multiple selectors must result in the same mode for the rule)');
                    return i4.hasLocals || (t5.hasPureGlobals = true), s7;
                  }), t5.global = r6, e5.nodes = So(s6);
                  break;
                }
                case "selector":
                  s6 = e5.map((e6) => n4(e6, t5)), (e5 = e5.clone()).nodes = So(s6);
                  break;
                case "combinator":
                  if (Eo(e5)) return t5.ignoreNextSpacing ? (t5.ignoreNextSpacing = false, t5.lastWasSpacing = false, t5.enforceNoSpacing = false, null) : (t5.lastWasSpacing = true, e5);
                  break;
                case "pseudo": {
                  let r6;
                  const i4 = !!e5.length, o3 = ":local" === e5.value || ":global" === e5.value;
                  if (":import" === e5.value || ":export" === e5.value) t5.hasLocals = true;
                  else {
                    if (i4) {
                      if (o3) {
                        if (0 === e5.nodes.length) throw new Error(`${e5.value}() can't be empty`);
                        if (t5.inside) throw new Error(`A ${e5.value} is not allowed inside of a ${t5.inside}(...)`);
                        if (r6 = { global: ":global" === e5.value, inside: e5.value, hasLocals: false, explicit: true }, s6 = e5.map((e6) => n4(e6, r6)).reduce((e6, t6) => e6.concat(t6.nodes), []), s6.length) {
                          const { before: t6, after: r7 } = e5.spaces, n5 = s6[0], i5 = s6[s6.length - 1];
                          n5.spaces = { before: t6, after: n5.spaces.after }, i5.spaces = { before: i5.spaces.before, after: r7 };
                        }
                        e5 = s6;
                        break;
                      }
                      r6 = { global: t5.global, inside: t5.inside, lastWasSpacing: true, hasLocals: false, explicit: t5.explicit }, s6 = e5.map((e6) => {
                        const t6 = { ...r6, enforceNoSpacing: false }, s7 = n4(e6, t6);
                        return r6.global = t6.global, r6.hasLocals = t6.hasLocals, s7;
                      }), (e5 = e5.clone()).nodes = So(s6), r6.hasLocals && (t5.hasLocals = true);
                      break;
                    }
                    if (o3) {
                      if (t5.inside) throw new Error(`A ${e5.value} is not allowed inside of a ${t5.inside}(...)`);
                      const r7 = !!e5.spaces.before;
                      return t5.ignoreNextSpacing = !!t5.lastWasSpacing && e5.value, t5.enforceNoSpacing = !t5.lastWasSpacing && e5.value, t5.global = ":global" === e5.value, t5.explicit = true, r7 ? go.combinator({ value: " " }) : null;
                    }
                  }
                  break;
                }
                case "id":
                case "class": {
                  if (!e5.value) throw new Error("Invalid class or id selector syntax");
                  if (t5.global) break;
                  const n5 = r5.has(e5.value), s7 = n5 && t5.explicit;
                  if (!n5 || s7) {
                    const r6 = e5.clone();
                    r6.spaces = { before: "", after: "" }, e5 = go.pseudo({ value: ":local", nodes: [r6], spaces: e5.spaces }), t5.hasLocals = true;
                  }
                  break;
                }
              }
              return t5.lastWasSpacing = false, t5.ignoreNextSpacing = false, t5.enforceNoSpacing = false, e5;
            }, s5 = { global: "global" === t4, hasPureGlobals: false };
            return s5.selector = go((e5) => {
              n4(e5, s5);
            }).processSync(e4, { updateSelector: false, lossless: true }), s5;
          }(r4, e3.mode, n3);
          if (s4.options = e3, s4.localAliasMap = n3, t3 && s4.hasPureGlobals) throw r4.error('Selector "' + r4.selector + '" is not pure (pure selectors must contain at least one local class or id)');
          r4.selector = s4.selector, r4.nodes && r4.nodes.forEach((e4) => Po(e4, s4));
        });
      } };
    } };
  }, Yi.exports.postcss = true;
  var Ao = Yi.exports;
  const Co = Lr, Oo = Object.prototype.hasOwnProperty, Io = "[\\x20\\t\\r\\n\\f]", _o = new RegExp("\\\\([\\da-f]{1,6}" + Io + "?|(" + Io + ")|.)", "ig");
  function ko(e3) {
    return e3.replace(_o, (e4, t3, r3) => {
      const n3 = "0x" + t3 - 65536;
      return n3 != n3 || r3 ? t3 : n3 < 0 ? String.fromCharCode(n3 + 65536) : String.fromCharCode(n3 >> 10 | 55296, 1023 & n3 | 56320);
    });
  }
  const No = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const t3 = e3 && e3.generateScopedName || No.generateScopedName, r3 = e3 && e3.generateExportEntry || No.generateExportEntry, n3 = e3 && e3.exportGlobals;
    return { postcssPlugin: "postcss-modules-scope", Once(e4, s3) {
      let { rule: i3 } = s3;
      const o3 = /* @__PURE__ */ Object.create(null);
      function a3(n4, s4) {
        const i4 = t3(s4 || n4, e4.source.input.from, e4.source.input.css), a4 = r3(s4 || n4, i4, e4.source.input.from, e4.source.input.css), { key: l3, value: c3 } = a4;
        return o3[l3] = o3[l3] || [], o3[l3].indexOf(c3) < 0 && o3[l3].push(c3), i4;
      }
      function l2(e5) {
        switch (e5.type) {
          case "selector":
            return e5.nodes = e5.map(l2), e5;
          case "class":
            return Co.className({ value: a3(e5.value, e5.raws && e5.raws.value ? e5.raws.value : null) });
          case "id":
            return Co.id({ value: a3(e5.value, e5.raws && e5.raws.value ? e5.raws.value : null) });
        }
        throw new Error(`${e5.type} ("${e5}") is not allowed in a :local block`);
      }
      function c2(e5) {
        switch (e5.type) {
          case "pseudo":
            if (":local" === e5.value) {
              if (1 !== e5.nodes.length) throw new Error('Unexpected comma (",") in :local block');
              const t4 = l2(e5.first, e5.spaces);
              t4.first.spaces = e5.spaces;
              const r4 = e5.next();
              return r4 && "combinator" === r4.type && " " === r4.value && /\\[A-F0-9]{1,6}$/.test(t4.last.value) && (t4.last.spaces.after = " "), void e5.replaceWith(t4);
            }
          case "root":
          case "selector":
            e5.each(c2);
            break;
          case "id":
          case "class":
            n3 && (o3[e5.value] = [e5.value]);
        }
        return e5;
      }
      const u2 = {};
      e4.walkRules(/^:import\(.+\)$/, (e5) => {
        e5.walkDecls((e6) => {
          u2[e6.prop] = true;
        });
      }), e4.walkRules((e5) => {
        let t4 = Co().astSync(e5);
        e5.selector = c2(t4.clone()).toString(), e5.walkDecls(/composes|compose-with/i, (e6) => {
          const r4 = function(e7) {
            return e7.nodes.map((t5) => {
              if ("selector" !== t5.type || 1 !== t5.nodes.length) throw new Error(`composition is only allowed when selector is single :local class name not in "${e7}"`);
              if ("pseudo" !== (t5 = t5.nodes[0]).type || ":local" !== t5.value || 1 !== t5.nodes.length) throw new Error('composition is only allowed when selector is single :local class name not in "' + e7 + '", "' + t5 + '" is weird');
              if ("selector" !== (t5 = t5.first).type || 1 !== t5.length) throw new Error('composition is only allowed when selector is single :local class name not in "' + e7 + '", "' + t5 + '" is weird');
              if ("class" !== (t5 = t5.first).type) throw new Error('composition is only allowed when selector is single :local class name not in "' + e7 + '", "' + t5 + '" is weird');
              return t5.value;
            });
          }(t4);
          e6.value.split(/\s+/).forEach((t5) => {
            const n4 = /^global\(([^)]+)\)$/.exec(t5);
            if (n4) r4.forEach((e7) => {
              o3[e7].push(n4[1]);
            });
            else if (Oo.call(u2, t5)) r4.forEach((e7) => {
              o3[e7].push(t5);
            });
            else {
              if (!Oo.call(o3, t5)) throw e6.error(`referenced class name "${t5}" in ${e6.prop} not found`);
              r4.forEach((e7) => {
                o3[t5].forEach((t6) => {
                  o3[e7].push(t6);
                });
              });
            }
          }), e6.remove();
        }), e5.walkDecls((e6) => {
          if (!/:local\s*\((.+?)\)/.test(e6.value)) return;
          let t5 = e6.value.split(/(,|'[^']*'|"[^"]*")/);
          t5 = t5.map((e7, r4) => {
            if (0 === r4 || "," === t5[r4 - 1]) {
              let t6 = e7;
              const r5 = /:local\s*\((.+?)\)/.exec(e7);
              if (!r5) return e7;
              {
                const e8 = r5.input, n4 = r5[0], s4 = a3(r5[1]);
                t6 = e8.replace(n4, s4);
              }
              return t6;
            }
            return e7;
          }), e6.value = t5.join("");
        });
      }), e4.walkAtRules(/keyframes$/i, (e5) => {
        const t4 = /^\s*:local\s*\((.+?)\)\s*$/.exec(e5.params);
        t4 && (e5.params = a3(t4[1]));
      });
      const p2 = Object.keys(o3);
      if (p2.length > 0) {
        const t4 = i3({ selector: ":export" });
        p2.forEach((e5) => t4.append({ prop: e5, value: o3[e5].join(" "), raws: { before: "\n  " } })), e4.append(t4);
      }
    } };
  };
  No.postcss = true, No.generateScopedName = function(e3, t3) {
    return `_${t3.replace(/\.[^./\\]+$/, "").replace(/[\W_]+/g, "_").replace(/^_|_$/g, "")}__${e3}`.trim();
  }, No.generateExportEntry = function(e3, t3) {
    return { key: ko(e3), value: ko(t3) };
  };
  var Do = No, jo = { exports: {} };
  const Lo = es, Mo = /^(.+?|\([\s\S]+?\))\s+from\s+("[^"]*"|'[^']*'|[\w-]+)$/, Bo = /(?:\s+|^)([\w-]+):?(.*?)$/, Ro = /^([\w-]+)(?:\s+as\s+([\w-]+))?/;
  jo.exports = (e3) => {
    let t3 = 0;
    const r3 = e3 && e3.createImportedName || ((e4) => `i__const_${e4.replace(/\W/g, "_")}_${t3++}`);
    return { postcssPlugin: "postcss-modules-values", prepare(e4) {
      const t4 = [], n3 = {};
      return { Once(s3, i3) {
        if (s3.walkAtRules(/value/i, (s4) => {
          const i4 = s4.params.match(Mo);
          if (i4) {
            let [, e5, o5] = i4;
            n3[o5] && (o5 = n3[o5]);
            const a4 = e5.replace(/^\(\s*([\s\S]+)\s*\)$/, "$1").split(/\s*,\s*/).map((e6) => {
              const t5 = Ro.exec(e6);
              if (t5) {
                const [, e7, s5 = e7] = t5, i5 = r3(s5);
                return n3[s5] = i5, { theirName: e7, importedName: i5 };
              }
              throw new Error(`@import statement "${e6}" is invalid!`);
            });
            return t4.push({ path: o5, imports: a4 }), void s4.remove();
          }
          -1 !== s4.params.indexOf("@value") && e4.warn("Invalid value definition: " + s4.params);
          let [, o4, a3] = `${s4.params}${s4.raws.between}`.match(Bo);
          const l2 = a3.replace(/\/\*((?!\*\/).*?)\*\//g, "");
          if (0 === l2.length) return e4.warn("Invalid value definition: " + s4.params), void s4.remove();
          /^\s+$/.test(l2) || (a3 = a3.trim()), n3[o4] = Lo.replaceValueSymbols(a3, n3), s4.remove();
        }), !Object.keys(n3).length) return;
        Lo.replaceSymbols(s3, n3);
        const o3 = Object.keys(n3).map((e5) => i3.decl({ value: n3[e5], prop: e5, raws: { before: "\n  " } }));
        if (o3.length > 0) {
          const e5 = i3.rule({ selector: ":export", raws: { after: "\n" } });
          e5.append(o3), s3.prepend(e5);
        }
        t4.reverse().forEach((e5) => {
          let { path: t5, imports: r4 } = e5;
          const n4 = i3.rule({ selector: `:import(${t5})`, raws: { after: "\n" } });
          r4.forEach((e6) => {
            let { theirName: t6, importedName: r5 } = e6;
            n4.append({ value: t6, prop: r5, raws: { before: "\n  " } });
          }), s3.prepend(n4);
        });
      } };
    } };
  }, jo.exports.postcss = true;
  var Fo = jo.exports;
  Object.defineProperty(bi, "__esModule", { value: true }), bi.behaviours = void 0, bi.getDefaultPlugins = function(e3) {
    let { behaviour: t3, generateScopedName: r3, exportGlobals: n3 } = e3;
    const s3 = (0, qo.default)({ generateScopedName: r3, exportGlobals: n3 });
    return { [zo.LOCAL]: [Go.default, (0, Vo.default)({ mode: "local" }), Uo.default, s3], [zo.GLOBAL]: [Go.default, (0, Vo.default)({ mode: "global" }), Uo.default, s3] }[t3];
  }, bi.getDefaultScopeBehaviour = function(e3) {
    return e3 && (t3 = e3, Object.keys(zo).map((e4) => zo[e4]).indexOf(t3) > -1) ? e3 : zo.LOCAL;
    var t3;
  }, bi.getScopedNameGenerator = function(e3, t3) {
    const r3 = e3 || Ko;
    return "function" == typeof r3 ? r3 : (0, $o.default)(r3, { context: n2.cwd(), hashPrefix: t3 });
  };
  var Uo = Ho(Ai), $o = Ho(function(e3, t3) {
    var r3 = (t3 = t3 || {}) && "string" == typeof t3.context ? t3.context : n2.cwd(), s3 = t3 && "string" == typeof t3.hashPrefix ? t3.hashPrefix : "";
    return function(t4, n3) {
      var i3 = e3.replace(/\[local\]/gi, t4), o3 = { resourcePath: n3 }, a3 = { content: s3 + Ji.relative(r3, n3).replace(/\\/g, "/") + "\0" + t4, context: r3 };
      return Xi(o3, i3, a3).replace(new RegExp("[^a-zA-Z0-9\\-_ -￿]", "g"), "-").replace(/^((-?[0-9])|--)/, "_$1");
    };
  }), Vo = Ho(Ao), qo = Ho(Do), Wo = Ho(function(e3) {
    for (var t3 = 5381, r3 = e3.length; r3; ) t3 = 33 * t3 ^ e3.charCodeAt(--r3);
    return t3 >>> 0;
  }), Go = Ho(Fo);
  function Ho(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  }
  const zo = { LOCAL: "local", GLOBAL: "global" };
  function Ko(e3, t3, r3) {
    const n3 = r3.indexOf(`.${e3}`), s3 = r3.substr(0, n3).split(/[\r\n]/).length;
    return `_${e3}_${(0, Wo.default)(r3).toString(36).substr(0, 5)}_${s3}`;
  }
  bi.behaviours = zo, Object.defineProperty(Vn, "__esModule", { value: true }), Vn.makePlugin = function(e3) {
    return { postcssPlugin: na, async OnceExit(t3, r3) {
      let { result: n3 } = r3;
      const s3 = e3.getJSON || Qo.default, i3 = t3.source.input.file, o3 = function(e4, t4) {
        const r4 = e4.globalModulePaths || null, n4 = e4.exportGlobals || false, s4 = (0, ta.getDefaultScopeBehaviour)(e4.scopeBehaviour), i4 = (0, ta.getScopedNameGenerator)(e4.generateScopedName, e4.hashPrefix);
        return r4 && function(e5, t5) {
          return e5.some((e6) => t5.match(e6));
        }(r4, t4) ? (0, ta.getDefaultPlugins)({ behaviour: ta.behaviours.GLOBAL, generateScopedName: i4, exportGlobals: n4 }) : (0, ta.getDefaultPlugins)({ behaviour: s4, generateScopedName: i4, exportGlobals: n4 });
      }(e3, i3), a3 = n3.processor.plugins.findIndex((e4) => function(e5) {
        return e5.postcssPlugin === na;
      }(e4));
      if (-1 === a3) throw new Error("Plugin missing from options.");
      const l2 = [...n3.processor.plugins.slice(0, a3), ...o3], c2 = function(e4, t4) {
        const r4 = void 0 === e4.root ? "/" : e4.root;
        return "function" == typeof e4.Loader ? new e4.Loader(r4, t4, e4.resolve) : new ea.default(r4, t4, e4.resolve);
      }(e3, l2), u2 = new Yo.default(async (e4, t4, r4) => {
        const n4 = (0, Jo.default)(e4);
        return c2.fetch.call(c2, n4, t4, r4);
      });
      await (0, Xo.default)([...o3, u2.plugin()]).process(t3, { from: i3 });
      const p2 = c2.finalSource;
      if (p2 && t3.prepend(p2), e3.localsConvention) {
        const t4 = (0, Zo.makeLocalsConventionReducer)(e3.localsConvention, i3);
        u2.exportTokens = Object.entries(u2.exportTokens).reduce(t4, {});
      }
      return n3.messages.push({ type: "export", plugin: "postcss-modules", exportTokens: u2.exportTokens }), s3(t3.source.input.file, u2.exportTokens, n3.opts.to);
    } };
  };
  var Xo = ra(h), Jo = ra(qn), Yo = ra(Gn), Qo = ra(ns), Zo = os, ea = ra(ui), ta = bi;
  function ra(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  }
  const na = "postcss-modules";
  var sa = f, ia = Vn;
  (0, Un.setFileSystem)({ readFile: sa.readFile, writeFile: sa.writeFile }), Fn.exports = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return (0, ia.makePlugin)(e3);
  }, Fn.exports.postcss = true;
  var oa, aa, la = q(Fn.exports);
  function ca(e3) {
    const { filename: t3, id: r3, scoped: n3 = false, trim: s3 = true, isProd: i3 = false, modules: o3 = false, modulesOptions: a3 = {}, preprocessLang: l2, postcssOptions: c2, postcssPlugins: u2 } = e3, p2 = l2 && Rn[l2], d2 = p2 && function(e4, t4) {
      return t4(e4.source, e4.inMap || e4.map, { filename: e4.filename, ...e4.preprocessOptions }, e4.preprocessCustomRequire);
    }(e3, p2), f2 = d2 ? d2.map : e3.inMap || e3.map, m2 = d2 ? d2.code : e3.source, y2 = r3.replace(/^data-v-/, ""), g2 = `data-v-${y2}`, b2 = (u2 || []).slice();
    let v2;
    if (b2.unshift(Z({ id: y2, isProd: i3 })), s3 && b2.push(Ke()), n3 && b2.push(qr(g2)), o3) {
      if (!e3.isAsync) throw new Error("[@vue/compiler-sfc] `modules` option can only be used with compileStyleAsync().");
      b2.push(la({ ...a3, getJSON: (e4, t4) => {
        v2 = t4;
      } }));
    }
    const E2 = { ...c2, to: t3, from: t3 };
    let S2, x2, T2;
    f2 && (E2.map = { inline: false, annotation: false, prev: f2 });
    const w2 = new Set(d2 ? d2.dependencies : []);
    w2.delete(t3);
    const P2 = [];
    d2 && d2.errors.length && P2.push(...d2.errors);
    const A2 = (e4) => (e4.forEach((e5) => {
      "dependency" === e5.type && w2.add(e5.file);
    }), w2);
    try {
      if (S2 = h(b2).process(m2, E2), e3.isAsync) return S2.then((e4) => ({ code: e4.css || "", map: e4.map && e4.map.toJSON(), errors: P2, modules: v2, rawResult: e4, dependencies: A2(e4.messages) })).catch((e4) => ({ code: "", map: void 0, errors: [...P2, e4], rawResult: void 0, dependencies: w2 }));
      A2(S2.messages), x2 = S2.css, T2 = S2.map;
    } catch (e4) {
      P2.push(e4);
    }
    return { code: x2 || "", map: T2 && T2.toJSON(), errors: P2, rawResult: S2, dependencies: w2 };
  }
  function ua(e3) {
    for (const t3 of e3) if ("ExportDefaultDeclaration" === t3.type && "ObjectExpression" === t3.declaration.type) return pa(t3.declaration);
    return {};
  }
  function pa(e3) {
    const t3 = {};
    Object.defineProperty(t3, "__isScriptSetup", { enumerable: false, value: false });
    for (const r3 of e3.properties) if ("ObjectProperty" !== r3.type || r3.computed || "Identifier" !== r3.key.type) {
      if ("ObjectMethod" === r3.type && "Identifier" === r3.key.type && ("setup" === r3.key.name || "data" === r3.key.name)) {
        for (const e4 of r3.body.body) if ("ReturnStatement" === e4.type && e4.argument && "ObjectExpression" === e4.argument.type) for (const n3 of da(e4.argument)) t3[n3] = "setup" === r3.key.name ? "setup-maybe-ref" : "data";
      }
    } else if ("props" === r3.key.name) for (const e4 of fa(r3.value)) t3[e4] = "props";
    else if ("inject" === r3.key.name) for (const e4 of fa(r3.value)) t3[e4] = "options";
    else if ("ObjectExpression" === r3.value.type && ("computed" === r3.key.name || "methods" === r3.key.name)) for (const e4 of da(r3.value)) t3[e4] = "options";
    return t3;
  }
  function da(e3) {
    const t3 = [];
    for (const r3 of e3.properties) {
      if ("SpreadElement" === r3.type) continue;
      const e4 = w(r3.key, r3.computed);
      e4 && t3.push(String(e4));
    }
    return t3;
  }
  function fa(e3) {
    return "ArrayExpression" === e3.type ? function(e4) {
      const t3 = [];
      for (const r3 of e4.elements) r3 && "StringLiteral" === r3.type && t3.push(r3.value);
      return t3;
    }(e3) : "ObjectExpression" === e3.type ? da(e3) : [];
  }
  class ha {
    constructor(e3, t3) {
      this.descriptor = e3, this.options = t3, this.isCE = false, this.source = this.descriptor.source, this.filename = this.descriptor.filename, this.s = new y(this.source), this.startOffset = null == (oa = this.descriptor.scriptSetup) ? void 0 : oa.loc.start.offset, this.endOffset = null == (aa = this.descriptor.scriptSetup) ? void 0 : aa.loc.end.offset, this.userImports = /* @__PURE__ */ Object.create(null), this.hasDefinePropsCall = false, this.hasDefineEmitCall = false, this.hasDefineExposeCall = false, this.hasDefaultExportName = false, this.hasDefaultExportRender = false, this.hasDefineOptionsCall = false, this.hasDefineSlotsCall = false, this.hasDefineModelCall = false, this.propsDestructuredBindings = /* @__PURE__ */ Object.create(null), this.modelDecls = /* @__PURE__ */ Object.create(null), this.bindingMetadata = {}, this.helperImports = /* @__PURE__ */ new Set();
      const { script: r3, scriptSetup: n3 } = e3, s3 = r3 && r3.lang, i3 = n3 && n3.lang;
      this.isJS = "js" === s3 || "jsx" === s3 || "js" === i3 || "jsx" === i3, this.isTS = "ts" === s3 || "tsx" === s3 || "ts" === i3 || "tsx" === i3;
      const o3 = t3.customElement, a3 = this.descriptor.filename;
      o3 && (this.isCE = "boolean" == typeof o3 ? o3 : o3(a3));
      const l2 = ma(s3 || i3, t3.babelParserPlugins);
      function u2(t4, r4) {
        try {
          return g.parse(t4, { plugins: l2, sourceType: "module" }).program;
        } catch (t5) {
          throw t5.message = `[vue/compiler-sfc] ${t5.message}

${e3.filename}
${c.generateCodeFrame(e3.source, t5.pos + r4, t5.pos + r4 + 1)}`, t5;
        }
      }
      this.scriptAst = e3.script && u2(e3.script.content, e3.script.loc.start.offset), this.scriptSetupAst = e3.scriptSetup && u2(e3.scriptSetup.content, this.startOffset);
    }
    helper(e3) {
      return this.helperImports.add(e3), `_${e3}`;
    }
    getString(e3) {
      return (arguments.length > 1 && void 0 !== arguments[1] && !arguments[1] ? this.descriptor.script : this.descriptor.scriptSetup).content.slice(e3.start, e3.end);
    }
    error(e3, t3, r3) {
      const n3 = r3 ? r3.offset : this.startOffset;
      throw new Error(`[@vue/compiler-sfc] ${e3}

${(r3 || this.descriptor).filename}
${c.generateCodeFrame((r3 || this.descriptor).source, t3.start + n3, t3.end + n3)}`);
    }
  }
  function ma(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    const n3 = [];
    return t3 && t3.some((e4) => "importAssertions" === e4 || "importAttributes" === e4 || c.isArray(e4) && "importAttributes" === e4[0]) || n3.push("importAttributes"), "jsx" === e3 || "tsx" === e3 ? n3.push("jsx") : t3 && (t3 = t3.filter((e4) => "jsx" !== e4)), "ts" !== e3 && "tsx" !== e3 || (n3.push(["typescript", { dts: r3 }], "explicitResourceManagement"), t3 && t3.includes("decorators") || n3.push("decorators-legacy")), t3 && n3.push(...t3), n3;
  }
  function ya(e3, t3, r3) {
    !function(e4) {
      for (const t4 of e4) {
        if ("ExportDefaultDeclaration" === t4.type) return true;
        if ("ExportNamedDeclaration" === t4.type && t4.specifiers.some((e5) => "default" === e5.exported.name)) return true;
      }
      return false;
    }(e3) ? t3.append(`
const ${r3} = {}`) : e3.forEach((e4) => {
      if ("ExportDefaultDeclaration" === e4.type) if ("ClassDeclaration" === e4.declaration.type && e4.declaration.id) {
        let n3 = e4.declaration.decorators && e4.declaration.decorators.length > 0 ? e4.declaration.decorators[e4.declaration.decorators.length - 1].end : e4.start;
        t3.overwrite(n3, e4.declaration.id.start, " class "), t3.append(`
const ${r3} = ${e4.declaration.id.name}`);
      } else t3.overwrite(e4.start, e4.declaration.start, `const ${r3} = `);
      else if ("ExportNamedDeclaration" === e4.type) {
        for (const n3 of e4.specifiers) if ("ExportSpecifier" === n3.type && "Identifier" === n3.exported.type && "default" === n3.exported.name) {
          if (e4.source) {
            if ("default" === n3.local.name) {
              t3.prepend(`import { default as __VUE_DEFAULT__ } from '${e4.source.value}'
`);
              const s4 = ga(t3, n3.local.end, e4.end);
              t3.remove(n3.start, s4), t3.append(`
const ${r3} = __VUE_DEFAULT__`);
              continue;
            }
            {
              t3.prepend(`import { ${t3.slice(n3.local.start, n3.local.end)} as __VUE_DEFAULT__ } from '${e4.source.value}'
`);
              const s4 = ga(t3, n3.exported.end, e4.end);
              t3.remove(n3.start, s4), t3.append(`
const ${r3} = __VUE_DEFAULT__`);
              continue;
            }
          }
          const s3 = ga(t3, n3.end, e4.end);
          t3.remove(n3.start, s3), t3.append(`
const ${r3} = ${n3.local.name}`);
        }
      }
    });
  }
  function ga(e3, t3, r3) {
    let n3 = false, s3 = t3;
    for (; t3 < r3; ) if (/\s/.test(e3.slice(t3, t3 + 1))) t3++;
    else {
      if ("," === e3.slice(t3, t3 + 1)) {
        t3++, n3 = true;
        break;
      }
      if ("}" === e3.slice(t3, t3 + 1)) break;
    }
    return n3 ? t3 : s3;
  }
  const ba = "__default__";
  var va = Ea;
  function Ea(e3, t3, r3) {
    e3 instanceof RegExp && (e3 = Sa(e3, r3)), t3 instanceof RegExp && (t3 = Sa(t3, r3));
    var n3 = xa(e3, t3, r3);
    return n3 && { start: n3[0], end: n3[1], pre: r3.slice(0, n3[0]), body: r3.slice(n3[0] + e3.length, n3[1]), post: r3.slice(n3[1] + t3.length) };
  }
  function Sa(e3, t3) {
    var r3 = t3.match(e3);
    return r3 ? r3[0] : null;
  }
  function xa(e3, t3, r3) {
    var n3, s3, i3, o3, a3, l2 = r3.indexOf(e3), c2 = r3.indexOf(t3, l2 + 1), u2 = l2;
    if (l2 >= 0 && c2 > 0) {
      if (e3 === t3) return [l2, c2];
      for (n3 = [], i3 = r3.length; u2 >= 0 && !a3; ) u2 == l2 ? (n3.push(u2), l2 = r3.indexOf(e3, u2 + 1)) : 1 == n3.length ? a3 = [n3.pop(), c2] : ((s3 = n3.pop()) < i3 && (i3 = s3, o3 = c2), c2 = r3.indexOf(t3, u2 + 1)), u2 = l2 < c2 && l2 >= 0 ? l2 : c2;
      n3.length && (a3 = [i3, o3]);
    }
    return a3;
  }
  Ea.range = xa;
  var Ta = va, wa = function(e3) {
    return e3 ? ("{}" === e3.substr(0, 2) && (e3 = "\\{\\}" + e3.substr(2)), Ba(function(e4) {
      return e4.split("\\\\").join(Pa).split("\\{").join(Aa).split("\\}").join(Ca).split("\\,").join(Oa).split("\\.").join(Ia);
    }(e3), true).map(ka)) : [];
  }, Pa = "\0SLASH" + Math.random() + "\0", Aa = "\0OPEN" + Math.random() + "\0", Ca = "\0CLOSE" + Math.random() + "\0", Oa = "\0COMMA" + Math.random() + "\0", Ia = "\0PERIOD" + Math.random() + "\0";
  function _a(e3) {
    return parseInt(e3, 10) == e3 ? parseInt(e3, 10) : e3.charCodeAt(0);
  }
  function ka(e3) {
    return e3.split(Pa).join("\\").split(Aa).join("{").split(Ca).join("}").split(Oa).join(",").split(Ia).join(".");
  }
  function Na(e3) {
    if (!e3) return [""];
    var t3 = [], r3 = Ta("{", "}", e3);
    if (!r3) return e3.split(",");
    var n3 = r3.pre, s3 = r3.body, i3 = r3.post, o3 = n3.split(",");
    o3[o3.length - 1] += "{" + s3 + "}";
    var a3 = Na(i3);
    return i3.length && (o3[o3.length - 1] += a3.shift(), o3.push.apply(o3, a3)), t3.push.apply(t3, o3), t3;
  }
  function Da(e3) {
    return "{" + e3 + "}";
  }
  function ja(e3) {
    return /^-?0\d/.test(e3);
  }
  function La(e3, t3) {
    return e3 <= t3;
  }
  function Ma(e3, t3) {
    return e3 >= t3;
  }
  function Ba(e3, t3) {
    var r3 = [], n3 = Ta("{", "}", e3);
    if (!n3) return [e3];
    var s3 = n3.pre, i3 = n3.post.length ? Ba(n3.post, false) : [""];
    if (/\$$/.test(n3.pre)) for (var o3 = 0; o3 < i3.length; o3++) {
      var a3 = s3 + "{" + n3.body + "}" + i3[o3];
      r3.push(a3);
    }
    else {
      var l2, c2, u2 = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(n3.body), p2 = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(n3.body), d2 = u2 || p2, f2 = n3.body.indexOf(",") >= 0;
      if (!d2 && !f2) return n3.post.match(/,.*\}/) ? Ba(e3 = n3.pre + "{" + n3.body + Ca + n3.post) : [e3];
      if (d2) l2 = n3.body.split(/\.\./);
      else if (1 === (l2 = Na(n3.body)).length && 1 === (l2 = Ba(l2[0], false).map(Da)).length) return i3.map(function(e4) {
        return n3.pre + l2[0] + e4;
      });
      if (d2) {
        var h2 = _a(l2[0]), m2 = _a(l2[1]), y2 = Math.max(l2[0].length, l2[1].length), g2 = 3 == l2.length ? Math.abs(_a(l2[2])) : 1, b2 = La;
        m2 < h2 && (g2 *= -1, b2 = Ma);
        var v2 = l2.some(ja);
        c2 = [];
        for (var E2 = h2; b2(E2, m2); E2 += g2) {
          var S2;
          if (p2) "\\" === (S2 = String.fromCharCode(E2)) && (S2 = "");
          else if (S2 = String(E2), v2) {
            var x2 = y2 - S2.length;
            if (x2 > 0) {
              var T2 = new Array(x2 + 1).join("0");
              S2 = E2 < 0 ? "-" + T2 + S2.slice(1) : T2 + S2;
            }
          }
          c2.push(S2);
        }
      } else {
        c2 = [];
        for (var w2 = 0; w2 < l2.length; w2++) c2.push.apply(c2, Ba(l2[w2], false));
      }
      for (w2 = 0; w2 < c2.length; w2++) for (o3 = 0; o3 < i3.length; o3++) a3 = s3 + c2[w2] + i3[o3], (!t3 || d2 || a3) && r3.push(a3);
    }
    return r3;
  }
  var Ra = q(wa);
  const Fa = (e3) => {
    if ("string" != typeof e3) throw new TypeError("invalid pattern");
    if (e3.length > 65536) throw new TypeError("pattern is too long");
  }, Ua = { "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true], "[:alpha:]": ["\\p{L}\\p{Nl}", true], "[:ascii:]": ["\\x00-\\x7f", false], "[:blank:]": ["\\p{Zs}\\t", true], "[:cntrl:]": ["\\p{Cc}", true], "[:digit:]": ["\\p{Nd}", true], "[:graph:]": ["\\p{Z}\\p{C}", true, true], "[:lower:]": ["\\p{Ll}", true], "[:print:]": ["\\p{C}", true], "[:punct:]": ["\\p{P}", true], "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true], "[:upper:]": ["\\p{Lu}", true], "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true], "[:xdigit:]": ["A-Fa-f0-9", false] }, $a = (e3) => e3.replace(/[[\]\\-]/g, "\\$&"), Va = (e3) => e3.join(""), qa = (e3, t3) => {
    const r3 = t3;
    if ("[" !== e3.charAt(r3)) throw new Error("not in a brace expression");
    const n3 = [], s3 = [];
    let i3 = r3 + 1, o3 = false, a3 = false, l2 = false, c2 = false, u2 = r3, p2 = "";
    e: for (; i3 < e3.length; ) {
      const t4 = e3.charAt(i3);
      if ("!" !== t4 && "^" !== t4 || i3 !== r3 + 1) {
        if ("]" === t4 && o3 && !l2) {
          u2 = i3 + 1;
          break;
        }
        if (o3 = true, "\\" !== t4 || l2) {
          if ("[" === t4 && !l2) {
            for (const [t5, [o4, l3, c3]] of Object.entries(Ua)) if (e3.startsWith(t5, i3)) {
              if (p2) return ["$.", false, e3.length - r3, true];
              i3 += t5.length, c3 ? s3.push(o4) : n3.push(o4), a3 = a3 || l3;
              continue e;
            }
          }
          l2 = false, p2 ? (t4 > p2 ? n3.push($a(p2) + "-" + $a(t4)) : t4 === p2 && n3.push($a(t4)), p2 = "", i3++) : e3.startsWith("-]", i3 + 1) ? (n3.push($a(t4 + "-")), i3 += 2) : e3.startsWith("-", i3 + 1) ? (p2 = t4, i3 += 2) : (n3.push($a(t4)), i3++);
        } else l2 = true, i3++;
      } else c2 = true, i3++;
    }
    if (u2 < i3) return ["", false, 0, false];
    if (!n3.length && !s3.length) return ["$.", false, e3.length - r3, true];
    if (0 === s3.length && 1 === n3.length && /^\\?.$/.test(n3[0]) && !c2) {
      return [(d2 = 2 === n3[0].length ? n3[0].slice(-1) : n3[0], d2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")), false, u2 - r3, false];
    }
    var d2;
    const f2 = "[" + (c2 ? "^" : "") + Va(n3) + "]", h2 = "[" + (c2 ? "" : "^") + Va(s3) + "]";
    return [n3.length && s3.length ? "(" + f2 + "|" + h2 + ")" : n3.length ? f2 : h2, a3, u2 - r3, true];
  }, Wa = function(e3) {
    let { windowsPathsNoEscape: t3 = false } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return t3 ? e3.replace(/\[([^\/\\])\]/g, "$1") : e3.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  }, Ga = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]), Ha = (e3) => Ga.has(e3), za = "(?!\\.)", Ka = /* @__PURE__ */ new Set(["[", "."]), Xa = /* @__PURE__ */ new Set(["..", "."]), Ja = new Set("().*{}+?[]^$\\!"), Ya = "[^/]", Qa = Ya + "*?", Za = Ya + "+?";
  const _el = class _el {
    constructor(e3, t3) {
      __privateAdd(this, _el_instances);
      __publicField(this, "type");
      __privateAdd(this, _U);
      __privateAdd(this, _$);
      __privateAdd(this, _V, false);
      __privateAdd(this, _q, []);
      __privateAdd(this, _W);
      __privateAdd(this, _G);
      __privateAdd(this, _H);
      __privateAdd(this, _z, false);
      __privateAdd(this, _K);
      __privateAdd(this, _X);
      __privateAdd(this, _J, false);
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      this.type = e3, e3 && __privateSet(this, _$, true), __privateSet(this, _W, t3), __privateSet(this, _U, __privateGet(this, _W) ? __privateGet(__privateGet(this, _W), _U) : this), __privateSet(this, _K, __privateGet(this, _U) === this ? r3 : __privateGet(__privateGet(this, _U), _K)), __privateSet(this, _H, __privateGet(this, _U) === this ? [] : __privateGet(__privateGet(this, _U), _H)), "!" !== e3 || __privateGet(__privateGet(this, _U), _z) || __privateGet(this, _H).push(this), __privateSet(this, _G, __privateGet(this, _W) ? __privateGet(__privateGet(this, _W), _q).length : 0);
    }
    get hasMagic() {
      if (void 0 !== __privateGet(this, _$)) return __privateGet(this, _$);
      for (const e3 of __privateGet(this, _q)) if ("string" != typeof e3 && (e3.type || e3.hasMagic)) return __privateSet(this, _$, true);
      return __privateGet(this, _$);
    }
    toString() {
      return void 0 !== __privateGet(this, _X) ? __privateGet(this, _X) : this.type ? __privateSet(this, _X, this.type + "(" + __privateGet(this, _q).map((e3) => String(e3)).join("|") + ")") : __privateSet(this, _X, __privateGet(this, _q).map((e3) => String(e3)).join(""));
    }
    push() {
      for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
      for (const e4 of t3) if ("" !== e4) {
        if ("string" != typeof e4 && !(e4 instanceof _el && __privateGet(e4, _W) === this)) throw new Error("invalid part: " + e4);
        __privateGet(this, _q).push(e4);
      }
    }
    toJSON() {
      var _a4;
      const e3 = null === this.type ? __privateGet(this, _q).slice().map((e4) => "string" == typeof e4 ? e4 : e4.toJSON()) : [this.type, ...__privateGet(this, _q).map((e4) => e4.toJSON())];
      return this.isStart() && !this.type && e3.unshift([]), this.isEnd() && (this === __privateGet(this, _U) || __privateGet(__privateGet(this, _U), _z) && "!" === ((_a4 = __privateGet(this, _W)) == null ? void 0 : _a4.type)) && e3.push({}), e3;
    }
    isStart() {
      var _a4;
      if (__privateGet(this, _U) === this) return true;
      if (!((_a4 = __privateGet(this, _W)) == null ? void 0 : _a4.isStart())) return false;
      if (0 === __privateGet(this, _G)) return true;
      const e3 = __privateGet(this, _W);
      for (let t3 = 0; t3 < __privateGet(this, _G); t3++) {
        const r3 = __privateGet(e3, _q)[t3];
        if (!(r3 instanceof _el && "!" === r3.type)) return false;
      }
      return true;
    }
    isEnd() {
      var _a4, _b2, _c3;
      if (__privateGet(this, _U) === this) return true;
      if ("!" === ((_a4 = __privateGet(this, _W)) == null ? void 0 : _a4.type)) return true;
      if (!((_b2 = __privateGet(this, _W)) == null ? void 0 : _b2.isEnd())) return false;
      if (!this.type) return (_c3 = __privateGet(this, _W)) == null ? void 0 : _c3.isEnd();
      const e3 = __privateGet(this, _W) ? __privateGet(__privateGet(this, _W), _q).length : 0;
      return __privateGet(this, _G) === e3 - 1;
    }
    copyIn(e3) {
      "string" == typeof e3 ? this.push(e3) : this.push(e3.clone(this));
    }
    clone(e3) {
      const t3 = new _el(this.type, e3);
      for (const e4 of __privateGet(this, _q)) t3.copyIn(e4);
      return t3;
    }
    static fromGlob(e3) {
      var _a4;
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const r3 = new _el(null, void 0, t3);
      return __privateMethod(_a4 = _el, _el_static, Q_fn).call(_a4, e3, r3, 0, t3), r3;
    }
    toMMPattern() {
      if (this !== __privateGet(this, _U)) return __privateGet(this, _U).toMMPattern();
      const e3 = this.toString(), [t3, r3, n3, s3] = this.toRegExpSource();
      if (!(n3 || __privateGet(this, _$) || __privateGet(this, _K).nocase && !__privateGet(this, _K).nocaseMagicOnly && e3.toUpperCase() !== e3.toLowerCase())) return r3;
      const i3 = (__privateGet(this, _K).nocase ? "i" : "") + (s3 ? "u" : "");
      return Object.assign(new RegExp(`^${t3}$`, i3), { _src: t3, _glob: e3 });
    }
    toRegExpSource(e3) {
      var _a4;
      const t3 = e3 ?? !!__privateGet(this, _K).dot;
      if (__privateGet(this, _U) === this && __privateMethod(this, _el_instances, Y_fn).call(this), !this.type) {
        const r4 = this.isStart() && this.isEnd(), n4 = __privateGet(this, _q).map((t4) => {
          var _a5;
          const [n5, s5, i5, o4] = "string" == typeof t4 ? __privateMethod(_a5 = _el, _el_static, Z_fn).call(_a5, t4, __privateGet(this, _$), r4) : t4.toRegExpSource(e3);
          return __privateSet(this, _$, __privateGet(this, _$) || i5), __privateSet(this, _V, __privateGet(this, _V) || o4), n5;
        }).join("");
        let s4 = "";
        if (this.isStart() && "string" == typeof __privateGet(this, _q)[0] && (1 !== __privateGet(this, _q).length || !Xa.has(__privateGet(this, _q)[0]))) {
          const r5 = Ka, i5 = t3 && r5.has(n4.charAt(0)) || n4.startsWith("\\.") && r5.has(n4.charAt(2)) || n4.startsWith("\\.\\.") && r5.has(n4.charAt(4)), o4 = !t3 && !e3 && r5.has(n4.charAt(0));
          s4 = i5 ? "(?!(?:^|/)\\.\\.?(?:$|/))" : o4 ? za : "";
        }
        let i4 = "";
        return this.isEnd() && __privateGet(__privateGet(this, _U), _z) && "!" === ((_a4 = __privateGet(this, _W)) == null ? void 0 : _a4.type) && (i4 = "(?:$|\\/)"), [s4 + n4 + i4, Wa(n4), __privateSet(this, _$, !!__privateGet(this, _$)), __privateGet(this, _V)];
      }
      const r3 = "*" === this.type || "+" === this.type, n3 = "!" === this.type ? "(?:(?!(?:" : "(?:";
      let s3 = __privateMethod(this, _el_instances, ee_fn).call(this, t3);
      if (this.isStart() && this.isEnd() && !s3 && "!" !== this.type) {
        const e4 = this.toString();
        return __privateSet(this, _q, [e4]), this.type = null, __privateSet(this, _$, void 0), [e4, Wa(this.toString()), false, false];
      }
      let i3 = !r3 || e3 || t3 ? "" : __privateMethod(this, _el_instances, ee_fn).call(this, true);
      i3 === s3 && (i3 = ""), i3 && (s3 = `(?:${s3})(?:${i3})*?`);
      let o3 = "";
      return o3 = "!" === this.type && __privateGet(this, _J) ? (this.isStart() && !t3 ? za : "") + Za : n3 + s3 + ("!" === this.type ? "))" + (!this.isStart() || t3 || e3 ? "" : za) + Qa + ")" : "@" === this.type ? ")" : "?" === this.type ? ")?" : "+" === this.type && i3 ? ")" : "*" === this.type && i3 ? ")?" : `)${this.type}`), [o3, Wa(s3), __privateSet(this, _$, !!__privateGet(this, _$)), __privateGet(this, _V)];
    }
  };
  _U = new WeakMap();
  _$ = new WeakMap();
  _V = new WeakMap();
  _q = new WeakMap();
  _W = new WeakMap();
  _G = new WeakMap();
  _H = new WeakMap();
  _z = new WeakMap();
  _K = new WeakMap();
  _X = new WeakMap();
  _J = new WeakMap();
  _el_instances = new WeakSet();
  Y_fn = function() {
    if (this !== __privateGet(this, _U)) throw new Error("should only call on root");
    if (__privateGet(this, _z)) return this;
    let e3;
    for (this.toString(), __privateSet(this, _z, true); e3 = __privateGet(this, _H).pop(); ) {
      if ("!" !== e3.type) continue;
      let t3 = e3, r3 = __privateGet(t3, _W);
      for (; r3; ) {
        for (let n3 = __privateGet(t3, _G) + 1; !r3.type && n3 < __privateGet(r3, _q).length; n3++) for (const t4 of __privateGet(e3, _q)) {
          if ("string" == typeof t4) throw new Error("string part in extglob AST??");
          t4.copyIn(__privateGet(r3, _q)[n3]);
        }
        t3 = r3, r3 = __privateGet(t3, _W);
      }
    }
    return this;
  };
  _el_static = new WeakSet();
  Q_fn = function(e3, t3, r3, n3) {
    var _a4, _b2;
    let s3 = false, i3 = false, o3 = -1, a3 = false;
    if (null === t3.type) {
      let l3 = r3, c3 = "";
      for (; l3 < e3.length; ) {
        const r4 = e3.charAt(l3++);
        if (s3 || "\\" === r4) s3 = !s3, c3 += r4;
        else if (i3) l3 === o3 + 1 ? "^" !== r4 && "!" !== r4 || (a3 = true) : "]" !== r4 || l3 === o3 + 2 && a3 || (i3 = false), c3 += r4;
        else if ("[" !== r4) if (n3.noext || !Ha(r4) || "(" !== e3.charAt(l3)) c3 += r4;
        else {
          t3.push(c3), c3 = "";
          const s4 = new _el(r4, t3);
          l3 = __privateMethod(_a4 = _el, _el_static, Q_fn).call(_a4, e3, s4, l3, n3), t3.push(s4);
        }
        else i3 = true, o3 = l3, a3 = false, c3 += r4;
      }
      return t3.push(c3), l3;
    }
    let l2 = r3 + 1, c2 = new _el(null, t3);
    const u2 = [];
    let p2 = "";
    for (; l2 < e3.length; ) {
      const r4 = e3.charAt(l2++);
      if (s3 || "\\" === r4) s3 = !s3, p2 += r4;
      else if (i3) l2 === o3 + 1 ? "^" !== r4 && "!" !== r4 || (a3 = true) : "]" !== r4 || l2 === o3 + 2 && a3 || (i3 = false), p2 += r4;
      else if ("[" !== r4) if (Ha(r4) && "(" === e3.charAt(l2)) {
        c2.push(p2), p2 = "";
        const t4 = new _el(r4, c2);
        c2.push(t4), l2 = __privateMethod(_b2 = _el, _el_static, Q_fn).call(_b2, e3, t4, l2, n3);
      } else if ("|" !== r4) {
        if (")" === r4) return "" === p2 && 0 === __privateGet(t3, _q).length && __privateSet(t3, _J, true), c2.push(p2), p2 = "", t3.push(...u2, c2), l2;
        p2 += r4;
      } else c2.push(p2), p2 = "", u2.push(c2), c2 = new _el(null, t3);
      else i3 = true, o3 = l2, a3 = false, p2 += r4;
    }
    return t3.type = null, __privateSet(t3, _$, void 0), __privateSet(t3, _q, [e3.substring(r3 - 1)]), l2;
  };
  ee_fn = function(e3) {
    return __privateGet(this, _q).map((t3) => {
      if ("string" == typeof t3) throw new Error("string type in extglob ast??");
      const [r3, n3, s3, i3] = t3.toRegExpSource(e3);
      return __privateSet(this, _V, __privateGet(this, _V) || i3), r3;
    }).filter((e4) => !(this.isStart() && this.isEnd() && !e4)).join("|");
  };
  Z_fn = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = false, s3 = "", i3 = false;
    for (let o3 = 0; o3 < e3.length; o3++) {
      const a3 = e3.charAt(o3);
      if (n3) n3 = false, s3 += (Ja.has(a3) ? "\\" : "") + a3;
      else if ("\\" !== a3) {
        if ("[" === a3) {
          const [r4, n4, a4, l2] = qa(e3, o3);
          if (a4) {
            s3 += r4, i3 = i3 || n4, o3 += a4 - 1, t3 = t3 || l2;
            continue;
          }
        }
        "*" !== a3 ? "?" !== a3 ? s3 += a3.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : (s3 += Ya, t3 = true) : (s3 += r3 && "*" === e3 ? Za : Qa, t3 = true);
      } else o3 === e3.length - 1 ? s3 += "\\\\" : n3 = true;
    }
    return [s3, Wa(e3), !!t3, i3];
  };
  __privateAdd(_el, _el_static);
  let el = _el;
  const tl = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    return Fa(t3), !(!r3.nocomment && "#" === t3.charAt(0)) && new Ol(t3, r3).match(e3);
  }, rl = /^\*+([^+@!?\*\[\(]*)$/, nl = (e3) => (t3) => !t3.startsWith(".") && t3.endsWith(e3), sl = (e3) => (t3) => t3.endsWith(e3), il = (e3) => (e3 = e3.toLowerCase(), (t3) => !t3.startsWith(".") && t3.toLowerCase().endsWith(e3)), ol = (e3) => (e3 = e3.toLowerCase(), (t3) => t3.toLowerCase().endsWith(e3)), al = /^\*+\.\*+$/, ll = (e3) => !e3.startsWith(".") && e3.includes("."), cl = (e3) => "." !== e3 && ".." !== e3 && e3.includes("."), ul = /^\.\*+$/, pl = (e3) => "." !== e3 && ".." !== e3 && e3.startsWith("."), dl = /^\*+$/, fl = (e3) => 0 !== e3.length && !e3.startsWith("."), hl = (e3) => 0 !== e3.length && "." !== e3 && ".." !== e3, ml = /^\?+([^+@!?\*\[\(]*)?$/, yl = (e3) => {
    let [t3, r3 = ""] = e3;
    const n3 = El([t3]);
    return r3 ? (r3 = r3.toLowerCase(), (e4) => n3(e4) && e4.toLowerCase().endsWith(r3)) : n3;
  }, gl = (e3) => {
    let [t3, r3 = ""] = e3;
    const n3 = Sl([t3]);
    return r3 ? (r3 = r3.toLowerCase(), (e4) => n3(e4) && e4.toLowerCase().endsWith(r3)) : n3;
  }, bl = (e3) => {
    let [t3, r3 = ""] = e3;
    const n3 = Sl([t3]);
    return r3 ? (e4) => n3(e4) && e4.endsWith(r3) : n3;
  }, vl = (e3) => {
    let [t3, r3 = ""] = e3;
    const n3 = El([t3]);
    return r3 ? (e4) => n3(e4) && e4.endsWith(r3) : n3;
  }, El = (e3) => {
    let [t3] = e3;
    const r3 = t3.length;
    return (e4) => e4.length === r3 && !e4.startsWith(".");
  }, Sl = (e3) => {
    let [t3] = e3;
    const r3 = t3.length;
    return (e4) => e4.length === r3 && "." !== e4 && ".." !== e4;
  }, xl = "object" == typeof n2 && n2 ? "object" == typeof n2.env && n2.env && n2.env.__MINIMATCH_TESTING_PLATFORM__ || n2.platform : "posix", Tl = "win32" === xl ? "\\" : "/";
  tl.sep = Tl;
  const wl = Symbol("globstar **");
  tl.GLOBSTAR = wl, tl.filter = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return (r3) => tl(r3, e3, t3);
  };
  const Pl = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return Object.assign({}, e3, t3);
  };
  tl.defaults = (e3) => {
    if (!e3 || "object" != typeof e3 || !Object.keys(e3).length) return tl;
    const t3 = tl;
    return Object.assign(function(r3, n3) {
      return t3(r3, n3, Pl(e3, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}));
    }, { Minimatch: class extends t3.Minimatch {
      constructor(t4) {
        super(t4, Pl(e3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}));
      }
      static defaults(r3) {
        return t3.defaults(Pl(e3, r3)).Minimatch;
      }
    }, AST: class extends t3.AST {
      constructor(t4, r3) {
        super(t4, r3, Pl(e3, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}));
      }
      static fromGlob(r3) {
        let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return t3.AST.fromGlob(r3, Pl(e3, n3));
      }
    }, unescape: function(r3) {
      let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3.unescape(r3, Pl(e3, n3));
    }, escape: function(r3) {
      let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3.escape(r3, Pl(e3, n3));
    }, filter: function(r3) {
      let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3.filter(r3, Pl(e3, n3));
    }, defaults: (r3) => t3.defaults(Pl(e3, r3)), makeRe: function(r3) {
      let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3.makeRe(r3, Pl(e3, n3));
    }, braceExpand: function(r3) {
      let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3.braceExpand(r3, Pl(e3, n3));
    }, match: function(r3, n3) {
      let s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      return t3.match(r3, n3, Pl(e3, s3));
    }, sep: t3.sep, GLOBSTAR: wl });
  };
  const Al = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return Fa(e3), t3.nobrace || !/\{(?:(?!\{).)*\}/.test(e3) ? [e3] : Ra(e3);
  };
  tl.braceExpand = Al, tl.makeRe = function(e3) {
    return new Ol(e3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).makeRe();
  }, tl.match = function(e3, t3) {
    const r3 = new Ol(t3, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {});
    return e3 = e3.filter((e4) => r3.match(e4)), r3.options.nonull && !e3.length && e3.push(t3), e3;
  };
  const Cl = /[?*]|[+@!]\(.*?\)|\[|\]/;
  class Ol {
    constructor(e3) {
      __publicField(this, "options");
      __publicField(this, "set");
      __publicField(this, "pattern");
      __publicField(this, "windowsPathsNoEscape");
      __publicField(this, "nonegate");
      __publicField(this, "negate");
      __publicField(this, "comment");
      __publicField(this, "empty");
      __publicField(this, "preserveMultipleSlashes");
      __publicField(this, "partial");
      __publicField(this, "globSet");
      __publicField(this, "globParts");
      __publicField(this, "nocase");
      __publicField(this, "isWindows");
      __publicField(this, "platform");
      __publicField(this, "windowsNoMagicRoot");
      __publicField(this, "regexp");
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      Fa(e3), t3 = t3 || {}, this.options = t3, this.pattern = e3, this.platform = t3.platform || xl, this.isWindows = "win32" === this.platform, this.windowsPathsNoEscape = !!t3.windowsPathsNoEscape || false === t3.allowWindowsEscape, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!t3.preserveMultipleSlashes, this.regexp = null, this.negate = false, this.nonegate = !!t3.nonegate, this.comment = false, this.empty = false, this.partial = !!t3.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = void 0 !== t3.windowsNoMagicRoot ? t3.windowsNoMagicRoot : !(!this.isWindows || !this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
    }
    hasMagic() {
      if (this.options.magicalBraces && this.set.length > 1) return true;
      for (const e3 of this.set) for (const t3 of e3) if ("string" != typeof t3) return true;
      return false;
    }
    debug() {
    }
    make() {
      const e3 = this.pattern, t3 = this.options;
      if (!t3.nocomment && "#" === e3.charAt(0)) return void (this.comment = true);
      if (!e3) return void (this.empty = true);
      this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], t3.debug && (this.debug = function() {
      }), this.debug(this.pattern, this.globSet);
      const r3 = this.globSet.map((e4) => this.slashSplit(e4));
      this.globParts = this.preprocess(r3), this.debug(this.pattern, this.globParts);
      let n3 = this.globParts.map((e4, t4, r4) => {
        if (this.isWindows && this.windowsNoMagicRoot) {
          const t5 = !("" !== e4[0] || "" !== e4[1] || "?" !== e4[2] && Cl.test(e4[2]) || Cl.test(e4[3])), r5 = /^[a-z]:/i.test(e4[0]);
          if (t5) return [...e4.slice(0, 4), ...e4.slice(4).map((e5) => this.parse(e5))];
          if (r5) return [e4[0], ...e4.slice(1).map((e5) => this.parse(e5))];
        }
        return e4.map((e5) => this.parse(e5));
      });
      if (this.debug(this.pattern, n3), this.set = n3.filter((e4) => -1 === e4.indexOf(false)), this.isWindows) for (let e4 = 0; e4 < this.set.length; e4++) {
        const t4 = this.set[e4];
        "" === t4[0] && "" === t4[1] && "?" === this.globParts[e4][2] && "string" == typeof t4[3] && /^[a-z]:$/i.test(t4[3]) && (t4[2] = "?");
      }
      this.debug(this.pattern, this.set);
    }
    preprocess(e3) {
      if (this.options.noglobstar) for (let t4 = 0; t4 < e3.length; t4++) for (let r3 = 0; r3 < e3[t4].length; r3++) "**" === e3[t4][r3] && (e3[t4][r3] = "*");
      const { optimizationLevel: t3 = 1 } = this.options;
      return t3 >= 2 ? (e3 = this.firstPhasePreProcess(e3), e3 = this.secondPhasePreProcess(e3)) : e3 = t3 >= 1 ? this.levelOneOptimize(e3) : this.adjascentGlobstarOptimize(e3), e3;
    }
    adjascentGlobstarOptimize(e3) {
      return e3.map((e4) => {
        let t3 = -1;
        for (; -1 !== (t3 = e4.indexOf("**", t3 + 1)); ) {
          let r3 = t3;
          for (; "**" === e4[r3 + 1]; ) r3++;
          r3 !== t3 && e4.splice(t3, r3 - t3);
        }
        return e4;
      });
    }
    levelOneOptimize(e3) {
      return e3.map((e4) => 0 === (e4 = e4.reduce((e5, t3) => {
        const r3 = e5[e5.length - 1];
        return "**" === t3 && "**" === r3 ? e5 : ".." === t3 && r3 && ".." !== r3 && "." !== r3 && "**" !== r3 ? (e5.pop(), e5) : (e5.push(t3), e5);
      }, [])).length ? [""] : e4);
    }
    levelTwoFileOptimize(e3) {
      Array.isArray(e3) || (e3 = this.slashSplit(e3));
      let t3 = false;
      do {
        if (t3 = false, !this.preserveMultipleSlashes) {
          for (let r4 = 1; r4 < e3.length - 1; r4++) {
            const n3 = e3[r4];
            1 === r4 && "" === n3 && "" === e3[0] || "." !== n3 && "" !== n3 || (t3 = true, e3.splice(r4, 1), r4--);
          }
          "." !== e3[0] || 2 !== e3.length || "." !== e3[1] && "" !== e3[1] || (t3 = true, e3.pop());
        }
        let r3 = 0;
        for (; -1 !== (r3 = e3.indexOf("..", r3 + 1)); ) {
          const n3 = e3[r3 - 1];
          n3 && "." !== n3 && ".." !== n3 && "**" !== n3 && (t3 = true, e3.splice(r3 - 1, 2), r3 -= 2);
        }
      } while (t3);
      return 0 === e3.length ? [""] : e3;
    }
    firstPhasePreProcess(e3) {
      let t3 = false;
      do {
        t3 = false;
        for (let r3 of e3) {
          let n3 = -1;
          for (; -1 !== (n3 = r3.indexOf("**", n3 + 1)); ) {
            let s4 = n3;
            for (; "**" === r3[s4 + 1]; ) s4++;
            s4 > n3 && r3.splice(n3 + 1, s4 - n3);
            let i3 = r3[n3 + 1];
            const o3 = r3[n3 + 2], a3 = r3[n3 + 3];
            if (".." !== i3) continue;
            if (!o3 || "." === o3 || ".." === o3 || !a3 || "." === a3 || ".." === a3) continue;
            t3 = true, r3.splice(n3, 1);
            const l2 = r3.slice(0);
            l2[n3] = "**", e3.push(l2), n3--;
          }
          if (!this.preserveMultipleSlashes) {
            for (let e4 = 1; e4 < r3.length - 1; e4++) {
              const n4 = r3[e4];
              1 === e4 && "" === n4 && "" === r3[0] || "." !== n4 && "" !== n4 || (t3 = true, r3.splice(e4, 1), e4--);
            }
            "." !== r3[0] || 2 !== r3.length || "." !== r3[1] && "" !== r3[1] || (t3 = true, r3.pop());
          }
          let s3 = 0;
          for (; -1 !== (s3 = r3.indexOf("..", s3 + 1)); ) {
            const e4 = r3[s3 - 1];
            if (e4 && "." !== e4 && ".." !== e4 && "**" !== e4) {
              t3 = true;
              const e5 = 1 === s3 && "**" === r3[s3 + 1] ? ["."] : [];
              r3.splice(s3 - 1, 2, ...e5), 0 === r3.length && r3.push(""), s3 -= 2;
            }
          }
        }
      } while (t3);
      return e3;
    }
    secondPhasePreProcess(e3) {
      for (let t3 = 0; t3 < e3.length - 1; t3++) for (let r3 = t3 + 1; r3 < e3.length; r3++) {
        const n3 = this.partsMatch(e3[t3], e3[r3], !this.preserveMultipleSlashes);
        n3 && (e3[t3] = n3, e3[r3] = []);
      }
      return e3.filter((e4) => e4.length);
    }
    partsMatch(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = 0, s3 = 0, i3 = [], o3 = "";
      for (; n3 < e3.length && s3 < t3.length; ) if (e3[n3] === t3[s3]) i3.push("b" === o3 ? t3[s3] : e3[n3]), n3++, s3++;
      else if (r3 && "**" === e3[n3] && t3[s3] === e3[n3 + 1]) i3.push(e3[n3]), n3++;
      else if (r3 && "**" === t3[s3] && e3[n3] === t3[s3 + 1]) i3.push(t3[s3]), s3++;
      else if ("*" !== e3[n3] || !t3[s3] || !this.options.dot && t3[s3].startsWith(".") || "**" === t3[s3]) {
        if ("*" !== t3[s3] || !e3[n3] || !this.options.dot && e3[n3].startsWith(".") || "**" === e3[n3]) return false;
        if ("a" === o3) return false;
        o3 = "b", i3.push(t3[s3]), n3++, s3++;
      } else {
        if ("b" === o3) return false;
        o3 = "a", i3.push(e3[n3]), n3++, s3++;
      }
      return e3.length === t3.length && i3;
    }
    parseNegate() {
      if (this.nonegate) return;
      const e3 = this.pattern;
      let t3 = false, r3 = 0;
      for (let n3 = 0; n3 < e3.length && "!" === e3.charAt(n3); n3++) t3 = !t3, r3++;
      r3 && (this.pattern = e3.slice(r3)), this.negate = t3;
    }
    matchOne(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      const n3 = this.options;
      if (this.isWindows) {
        const r4 = "string" == typeof e3[0] && /^[a-z]:$/i.test(e3[0]), n4 = !r4 && "" === e3[0] && "" === e3[1] && "?" === e3[2] && /^[a-z]:$/i.test(e3[3]), s4 = "string" == typeof t3[0] && /^[a-z]:$/i.test(t3[0]), i4 = n4 ? 3 : r4 ? 0 : void 0, o4 = !s4 && "" === t3[0] && "" === t3[1] && "?" === t3[2] && "string" == typeof t3[3] && /^[a-z]:$/i.test(t3[3]) ? 3 : s4 ? 0 : void 0;
        if ("number" == typeof i4 && "number" == typeof o4) {
          const [r5, n5] = [e3[i4], t3[o4]];
          r5.toLowerCase() === n5.toLowerCase() && (t3[o4] = r5, o4 > i4 ? t3 = t3.slice(o4) : i4 > o4 && (e3 = e3.slice(i4)));
        }
      }
      const { optimizationLevel: s3 = 1 } = this.options;
      s3 >= 2 && (e3 = this.levelTwoFileOptimize(e3)), this.debug("matchOne", this, { file: e3, pattern: t3 }), this.debug("matchOne", e3.length, t3.length);
      for (var i3 = 0, o3 = 0, a3 = e3.length, l2 = t3.length; i3 < a3 && o3 < l2; i3++, o3++) {
        this.debug("matchOne loop");
        var c2 = t3[o3], u2 = e3[i3];
        if (this.debug(t3, c2, u2), false === c2) return false;
        if (c2 === wl) {
          this.debug("GLOBSTAR", [t3, c2, u2]);
          var p2 = i3, d2 = o3 + 1;
          if (d2 === l2) {
            for (this.debug("** at the end"); i3 < a3; i3++) if ("." === e3[i3] || ".." === e3[i3] || !n3.dot && "." === e3[i3].charAt(0)) return false;
            return true;
          }
          for (; p2 < a3; ) {
            var f2 = e3[p2];
            if (this.debug("\nglobstar while", e3, p2, t3, d2, f2), this.matchOne(e3.slice(p2), t3.slice(d2), r3)) return this.debug("globstar found match!", p2, a3, f2), true;
            if ("." === f2 || ".." === f2 || !n3.dot && "." === f2.charAt(0)) {
              this.debug("dot detected!", e3, p2, t3, d2);
              break;
            }
            this.debug("globstar swallow a segment, and continue"), p2++;
          }
          return !(!r3 || (this.debug("\n>>> no match, partial?", e3, p2, t3, d2), p2 !== a3));
        }
        let s4;
        if ("string" == typeof c2 ? (s4 = u2 === c2, this.debug("string match", c2, u2, s4)) : (s4 = c2.test(u2), this.debug("pattern match", c2, u2, s4)), !s4) return false;
      }
      if (i3 === a3 && o3 === l2) return true;
      if (i3 === a3) return r3;
      if (o3 === l2) return i3 === a3 - 1 && "" === e3[i3];
      throw new Error("wtf?");
    }
    braceExpand() {
      return Al(this.pattern, this.options);
    }
    parse(e3) {
      Fa(e3);
      const t3 = this.options;
      if ("**" === e3) return wl;
      if ("" === e3) return "";
      let r3, n3 = null;
      (r3 = e3.match(dl)) ? n3 = t3.dot ? hl : fl : (r3 = e3.match(rl)) ? n3 = (t3.nocase ? t3.dot ? ol : il : t3.dot ? sl : nl)(r3[1]) : (r3 = e3.match(ml)) ? n3 = (t3.nocase ? t3.dot ? gl : yl : t3.dot ? bl : vl)(r3) : (r3 = e3.match(al)) ? n3 = t3.dot ? cl : ll : (r3 = e3.match(ul)) && (n3 = pl);
      const s3 = el.fromGlob(e3, this.options).toMMPattern();
      return n3 ? Object.assign(s3, { test: n3 }) : s3;
    }
    makeRe() {
      if (this.regexp || false === this.regexp) return this.regexp;
      const e3 = this.set;
      if (!e3.length) return this.regexp = false, this.regexp;
      const t3 = this.options, r3 = t3.noglobstar ? "[^/]*?" : t3.dot ? "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?" : "(?:(?!(?:\\/|^)\\.).)*?", n3 = new Set(t3.nocase ? ["i"] : []);
      let s3 = e3.map((e4) => {
        const t4 = e4.map((e5) => {
          if (e5 instanceof RegExp) for (const t5 of e5.flags.split("")) n3.add(t5);
          return "string" == typeof e5 ? e5.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : e5 === wl ? wl : e5._src;
        });
        return t4.forEach((e5, n4) => {
          const s4 = t4[n4 + 1], i4 = t4[n4 - 1];
          e5 === wl && i4 !== wl && (void 0 === i4 ? void 0 !== s4 && s4 !== wl ? t4[n4 + 1] = "(?:\\/|" + r3 + "\\/)?" + s4 : t4[n4] = r3 : void 0 === s4 ? t4[n4 - 1] = i4 + "(?:\\/|" + r3 + ")?" : s4 !== wl && (t4[n4 - 1] = i4 + "(?:\\/|\\/" + r3 + "\\/)" + s4, t4[n4 + 1] = wl));
        }), t4.filter((e5) => e5 !== wl).join("/");
      }).join("|");
      const [i3, o3] = e3.length > 1 ? ["(?:", ")"] : ["", ""];
      s3 = "^" + i3 + s3 + o3 + "$", this.negate && (s3 = "^(?!" + s3 + ").+$");
      try {
        this.regexp = new RegExp(s3, [...n3].join(""));
      } catch (e4) {
        this.regexp = false;
      }
      return this.regexp;
    }
    slashSplit(e3) {
      return this.preserveMultipleSlashes ? e3.split("/") : this.isWindows && /^\/\/[^\/]+/.test(e3) ? ["", ...e3.split(/\/+/)] : e3.split(/\/+/);
    }
    match(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.partial;
      if (this.debug("match", e3, this.pattern), this.comment) return false;
      if (this.empty) return "" === e3;
      if ("/" === e3 && t3) return true;
      const r3 = this.options;
      this.isWindows && (e3 = e3.split("\\").join("/"));
      const n3 = this.slashSplit(e3);
      this.debug(this.pattern, "split", n3);
      const s3 = this.set;
      this.debug(this.pattern, "set", s3);
      let i3 = n3[n3.length - 1];
      if (!i3) for (let e4 = n3.length - 2; !i3 && e4 >= 0; e4--) i3 = n3[e4];
      for (let e4 = 0; e4 < s3.length; e4++) {
        const o3 = s3[e4];
        let a3 = n3;
        if (r3.matchBase && 1 === o3.length && (a3 = [i3]), this.matchOne(a3, o3, t3)) return !!r3.flipNegate || !this.negate;
      }
      return !r3.flipNegate && this.negate;
    }
    static defaults(e3) {
      return tl.defaults(e3).Minimatch;
    }
  }
  tl.AST = el, tl.Minimatch = Ol, tl.escape = function(e3) {
    let { windowsPathsNoEscape: t3 = false } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return t3 ? e3.replace(/[?*()[\]]/g, "[$&]") : e3.replace(/[?*()[\]\\]/g, "\\$&");
  }, tl.unescape = Wa;
  class Il {
    constructor(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : /* @__PURE__ */ Object.create(null), s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : /* @__PURE__ */ Object.create(null), i3 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : /* @__PURE__ */ Object.create(null);
      this.filename = e3, this.source = t3, this.offset = r3, this.imports = n3, this.types = s3, this.declares = i3, this.isGenericScope = false, this.resolvedImportSources = /* @__PURE__ */ Object.create(null), this.exportedTypes = /* @__PURE__ */ Object.create(null), this.exportedDeclares = /* @__PURE__ */ Object.create(null);
    }
  }
  function _l(e3, t3, r3, n3) {
    const s3 = !n3;
    if (s3 && t3._resolvedElements) return t3._resolvedElements;
    const i3 = function(e4, t4, r4, n4) {
      var s4, i4;
      switch (t4.type) {
        case "TSTypeLiteral":
          return kl(e4, t4.members, r4, n4);
        case "TSInterfaceDeclaration":
          return function(e5, t5, r5, n5) {
            const s5 = kl(e5, t5.body.body, t5._ownerScope, n5);
            if (t5.extends) {
              for (const n6 of t5.extends) if (!n6.leadingComments || !n6.leadingComments.some((e6) => e6.value.includes("@vue-ignore"))) try {
                const { props: t6, calls: i5 } = _l(e5, n6, r5);
                for (const e6 in t6) c.hasOwn(s5.props, e6) || (s5.props[e6] = t6[e6]);
                i5 && (s5.calls || (s5.calls = [])).push(...i5);
              } catch (t6) {
                e5.error("Failed to resolve extends base type.\nIf this previously worked in 3.2, you can instruct the compiler to ignore this extend by adding /* @vue-ignore */ before it, for example:\n\ninterface Props extends /* @vue-ignore */ Base {}\n\nNote: both in 3.2 or with the ignore, the properties in the base type are treated as fallthrough attrs at runtime.", n6);
              }
            }
            return s5;
          }(e4, t4, r4, n4);
        case "TSTypeAliasDeclaration":
        case "TSParenthesizedType":
          return _l(e4, t4.typeAnnotation, r4, n4);
        case "TSFunctionType":
          return { props: {}, calls: [t4] };
        case "TSUnionType":
        case "TSIntersectionType":
          return Nl(t4.types.map((t5) => _l(e4, t5, r4, n4)), t4.type);
        case "TSMappedType":
          return function(e5, t5, r5) {
            const n5 = { props: {} }, s5 = Ml(e5, t5.typeParameter.constraint, r5);
            for (const e6 of s5) n5.props[e6] = Dl({ type: "Identifier", name: e6 }, t5.typeAnnotation, r5, !!t5.optional);
            return n5;
          }(e4, t4, r4);
        case "TSIndexedAccessType":
          return Nl(jl(e4, t4, r4).map((t5) => _l(e4, t5, t5._ownerScope)), "TSUnionType");
        case "TSExpressionWithTypeArguments":
        case "TSTypeReference": {
          const i5 = $l(t4);
          if (("ExtractPropTypes" === i5 || "ExtractPublicPropTypes" === i5) && t4.typeParameters && "vue" === (null == (s4 = r4.imports[i5]) ? void 0 : s4.source)) return uc(_l(e4, t4.typeParameters.params[0], r4, n4), r4);
          const o3 = Fl(e4, t4, r4);
          if (o3) {
            let r5;
            return ("TSTypeAliasDeclaration" === o3.type || "TSInterfaceDeclaration" === o3.type) && o3.typeParameters && t4.typeParameters && (r5 = /* @__PURE__ */ Object.create(null), o3.typeParameters.params.forEach((e5, s5) => {
              let i6 = n4 && n4[e5.name];
              i6 || (i6 = t4.typeParameters.params[s5]), r5[e5.name] = i6;
            })), _l(e4, o3, o3._ownerScope, r5);
          }
          if ("string" == typeof i5) {
            if (n4 && n4[i5]) return _l(e4, n4[i5], r4, n4);
            if (Rl.has(i5)) return function(e5, t5, r5, n5, s5) {
              const i6 = _l(e5, t5.typeParameters.params[0], n5, s5);
              switch (r5) {
                case "Partial": {
                  const e6 = { props: {}, calls: i6.calls };
                  return Object.keys(i6.props).forEach((t6) => {
                    e6.props[t6] = { ...i6.props[t6], optional: true };
                  }), e6;
                }
                case "Required": {
                  const e6 = { props: {}, calls: i6.calls };
                  return Object.keys(i6.props).forEach((t6) => {
                    e6.props[t6] = { ...i6.props[t6], optional: false };
                  }), e6;
                }
                case "Readonly":
                  return i6;
                case "Pick": {
                  const r7 = Ml(e5, t5.typeParameters.params[1], n5), s7 = { props: {}, calls: i6.calls };
                  for (const e6 of r7) s7.props[e6] = i6.props[e6];
                  return s7;
                }
                case "Omit":
                  const r6 = Ml(e5, t5.typeParameters.params[1], n5), s6 = { props: {}, calls: i6.calls };
                  for (const e6 in i6.props) r6.includes(e6) || (s6.props[e6] = i6.props[e6]);
                  return s6;
              }
            }(e4, t4, i5, r4, n4);
            if ("ReturnType" === i5 && t4.typeParameters) {
              const n5 = function(e5, t5, r5) {
                var n6;
                let s5 = t5;
                if ("TSTypeReference" !== t5.type && "TSTypeQuery" !== t5.type && "TSImportType" !== t5.type || (s5 = Fl(e5, t5, r5)), s5) return "TSFunctionType" === s5.type ? null == (n6 = s5.typeAnnotation) ? void 0 : n6.typeAnnotation : "TSDeclareFunction" === s5.type ? s5.returnType : void 0;
              }(e4, t4.typeParameters.params[0], r4);
              if (n5) return _l(e4, n5, r4);
            }
          }
          return e4.error("Unresolvable type reference or unsupported built-in utility type", t4, r4);
        }
        case "TSImportType": {
          if ("vue" === _(t4.argument) && "Identifier" === (null == (i4 = t4.qualifier) ? void 0 : i4.type) && "ExtractPropTypes" === t4.qualifier.name && t4.typeParameters) return uc(_l(e4, t4.typeParameters.params[0], r4), r4);
          const n5 = Hl(e4, t4.argument, r4, t4.argument.value), s5 = Fl(e4, t4, n5);
          if (s5) return _l(e4, s5, s5._ownerScope);
          break;
        }
        case "TSTypeQuery": {
          const n5 = Fl(e4, t4, r4);
          if (n5) return _l(e4, n5, n5._ownerScope);
        }
      }
      return e4.error(`Unresolvable type: ${t4.type}`, t4, r4);
    }(e3, t3, t3._ownerScope || r3 || Zl(e3), n3);
    return s3 ? t3._resolvedElements = i3 : i3;
  }
  function kl(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Zl(e3), n3 = arguments.length > 3 ? arguments[3] : void 0;
    const s3 = { props: {} };
    for (const i3 of t3) if ("TSPropertySignature" === i3.type || "TSMethodSignature" === i3.type) {
      n3 && (r3 = ec(r3), r3.isGenericScope = true, Object.assign(r3.types, n3)), i3._ownerScope = r3;
      const t4 = _(i3.key);
      if (t4 && !i3.computed) s3.props[t4] = i3;
      else if ("TemplateLiteral" === i3.key.type) for (const t5 of Bl(e3, i3.key, r3)) s3.props[t5] = i3;
      else e3.error("Unsupported computed key in type referenced by a macro", i3.key, r3);
    } else "TSCallSignatureDeclaration" === i3.type && (s3.calls || (s3.calls = [])).push(i3);
    return s3;
  }
  function Nl(e3, t3) {
    if (1 === e3.length) return e3[0];
    const r3 = { props: {} }, { props: n3 } = r3;
    for (const { props: s3, calls: i3 } of e3) {
      for (const e4 in s3) c.hasOwn(n3, e4) ? n3[e4] = Dl(n3[e4].key, { type: t3, types: [n3[e4], s3[e4]] }, n3[e4]._ownerScope, n3[e4].optional || s3[e4].optional) : n3[e4] = s3[e4];
      i3 && (r3.calls || (r3.calls = [])).push(...i3);
    }
    return r3;
  }
  function Dl(e3, t3, r3, n3) {
    return { type: "TSPropertySignature", key: e3, kind: "get", optional: n3, typeAnnotation: { type: "TSTypeAnnotation", typeAnnotation: t3 }, _ownerScope: r3 };
  }
  function jl(e3, t3, r3) {
    var n3, s3;
    if ("TSNumberKeyword" === t3.indexType.type) return Ll(e3, t3.objectType, r3);
    const { indexType: i3, objectType: o3 } = t3, a3 = [];
    let l2, c2;
    "TSStringKeyword" === i3.type ? (c2 = _l(e3, o3, r3), l2 = Object.keys(c2.props)) : (l2 = Ml(e3, i3, r3), c2 = _l(e3, o3, r3));
    for (const e4 of l2) {
      const t4 = null == (s3 = null == (n3 = c2.props[e4]) ? void 0 : n3.typeAnnotation) ? void 0 : s3.typeAnnotation;
      t4 && (t4._ownerScope = c2.props[e4]._ownerScope, a3.push(t4));
    }
    return a3;
  }
  function Ll(e3, t3, r3) {
    if ("TSArrayType" === t3.type) return [t3.elementType];
    if ("TSTupleType" === t3.type) return t3.elementTypes.map((e4) => "TSNamedTupleMember" === e4.type ? e4.elementType : e4);
    if ("TSTypeReference" === t3.type) {
      if ("Array" === $l(t3) && t3.typeParameters) return t3.typeParameters.params;
      {
        const n3 = Fl(e3, t3, r3);
        if (n3) return Ll(e3, n3, r3);
      }
    }
    return e3.error("Failed to resolve element type from target type", t3, r3);
  }
  function Ml(e3, t3, r3) {
    switch (t3.type) {
      case "StringLiteral":
        return [t3.value];
      case "TSLiteralType":
        return Ml(e3, t3.literal, r3);
      case "TSUnionType":
        return t3.types.map((t4) => Ml(e3, t4, r3)).flat();
      case "TemplateLiteral":
        return Bl(e3, t3, r3);
      case "TSTypeReference": {
        const n3 = Fl(e3, t3, r3);
        if (n3) return Ml(e3, n3, r3);
        if ("Identifier" === t3.typeName.type) {
          const n4 = function() {
            let n5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return Ml(e3, t3.typeParameters.params[n5], r3);
          };
          switch (t3.typeName.name) {
            case "Extract":
              return n4(1);
            case "Exclude": {
              const e4 = n4(1);
              return n4().filter((t4) => !e4.includes(t4));
            }
            case "Uppercase":
              return n4().map((e4) => e4.toUpperCase());
            case "Lowercase":
              return n4().map((e4) => e4.toLowerCase());
            case "Capitalize":
              return n4().map(c.capitalize);
            case "Uncapitalize":
              return n4().map((e4) => e4[0].toLowerCase() + e4.slice(1));
            default:
              e3.error("Unsupported type when resolving index type", t3.typeName, r3);
          }
        }
      }
    }
    return e3.error("Failed to resolve index type into finite keys", t3, r3);
  }
  function Bl(e3, t3, r3) {
    if (!t3.expressions.length) return [t3.quasis[0].value.raw];
    const n3 = [], s3 = t3.expressions[0], i3 = t3.quasis[0], o3 = i3 ? i3.value.raw : "", a3 = Ml(e3, s3, r3), l2 = Bl(e3, { ...t3, expressions: t3.expressions.slice(1), quasis: i3 ? t3.quasis.slice(1) : t3.quasis }, r3);
    for (const e4 of a3) for (const t4 of l2) n3.push(o3 + e4 + t4);
    return n3;
  }
  const Rl = /* @__PURE__ */ new Set(["Partial", "Required", "Readonly", "Pick", "Omit"]);
  function Fl(e3, t3, r3, n3) {
    let s3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    const i3 = !(null == r3 ? void 0 : r3.isGenericScope);
    if (i3 && t3._resolvedReference) return t3._resolvedReference;
    const o3 = Ul(e3, r3 || Zl(e3), n3 || $l(t3), t3, s3);
    return i3 ? t3._resolvedReference = o3 : o3;
  }
  function Ul(e3, t3, r3, n3, s3) {
    if ("string" == typeof r3) {
      if (t3.imports[r3]) return function(e4, t4, r4, n4) {
        const { source: s4, imported: i3 } = n4.imports[r4];
        return Fl(e4, t4, Hl(e4, t4, n4, s4), i3, true);
      }(e3, n3, r3, t3);
      {
        const i3 = "TSTypeQuery" === n3.type ? s3 ? t3.exportedDeclares : t3.declares : s3 ? t3.exportedTypes : t3.types;
        if (i3[r3]) return i3[r3];
        {
          const t4 = function(e4) {
            if (e4.options.globalTypeFiles) {
              if (!Gl(e4)) throw new Error("[vue/compiler-sfc] globalTypeFiles requires fs access.");
              return e4.options.globalTypeFiles.map((t5) => Ql(e4, B(t5), true));
            }
          }(e3);
          if (t4) for (const s4 of t4) {
            const t5 = "TSTypeQuery" === n3.type ? s4.declares : s4.types;
            if (t5[r3]) return (e3.deps || (e3.deps = /* @__PURE__ */ new Set())).add(s4.filename), t5[r3];
          }
        }
      }
    } else {
      let i3 = Ul(e3, t3, r3[0], n3, s3);
      if (i3 && ("TSModuleDeclaration" !== i3.type && (i3 = i3._ns), i3)) {
        const s4 = function(e4, t4, r4) {
          if (t4._resolvedChildScope) return t4._resolvedChildScope;
          const n4 = ec(r4);
          if ("TSModuleDeclaration" === t4.body.type) {
            const e5 = t4.body;
            e5._ownerScope = n4;
            const r5 = _(e5.id);
            n4.types[r5] = n4.exportedTypes[r5] = e5;
          } else rc(e4, t4.body.body, n4);
          return t4._resolvedChildScope = n4;
        }(e3, i3, i3._ownerScope || t3);
        return Ul(e3, s4, r3.length > 2 ? r3.slice(1) : r3[r3.length - 1], n3, !i3.declare);
      }
    }
  }
  function $l(e3) {
    const t3 = "TSTypeReference" === e3.type ? e3.typeName : "TSExpressionWithTypeArguments" === e3.type ? e3.expression : "TSImportType" === e3.type ? e3.qualifier : e3.exprName;
    return "Identifier" === (null == t3 ? void 0 : t3.type) ? t3.name : "TSQualifiedName" === (null == t3 ? void 0 : t3.type) ? Vl(t3) : "default";
  }
  function Vl(e3) {
    return "Identifier" === e3.type ? [e3.name] : [...Vl(e3.left), e3.right.name];
  }
  let ql, Wl;
  function Gl(e3) {
    if (e3.fs) return e3.fs;
    !ql && Wl && (ql = Wl());
    const t3 = e3.options.fs || (null == ql ? void 0 : ql.sys);
    return t3 ? e3.fs = { fileExists: (e4) => (e4.endsWith(".vue.ts") && (e4 = e4.replace(/\.ts$/, "")), t3.fileExists(e4)), readFile: (e4) => (e4.endsWith(".vue.ts") && (e4 = e4.replace(/\.ts$/, "")), t3.readFile(e4)), realpath: t3.realpath } : void 0;
  }
  function Hl(e3, t3, r3, n3) {
    let s3;
    try {
      s3 = Gl(e3);
    } catch (n4) {
      return e3.error(n4.message, t3, r3);
    }
    if (!s3) return e3.error("No fs option provided to `compileScript` in non-Node environment. File system access is required for resolving imported types.", t3, r3);
    let i3 = r3.resolvedImportSources[n3];
    if (!i3) {
      if (n3.startsWith("..")) i3 = zl(("win32" === x.platform ? l.join : R)(l.dirname(r3.filename), n3), s3);
      else if (n3.startsWith(".")) i3 = zl(R(l.dirname(r3.filename), n3), s3);
      else {
        if (!ql && (Wl && (ql = Wl()), !ql)) return e3.error(`Failed to resolve import source ${JSON.stringify(n3)}. typescript is required as a peer dep for vue in order to support resolving types from module imports.`, t3, r3);
        i3 = function(e4, t4, r4, n4) {
          var s4, i4;
          const o3 = r4.findConfigFile(e4, n4.fileExists);
          let a3, c2;
          if (o3) {
            let t5;
            const u3 = B(o3), p2 = Kl.get(u3);
            let d2;
            if (p2 ? t5 = p2 : (t5 = Jl(o3, r4, n4).map((e5) => ({ config: e5 })), Kl.set(u3, t5)), 1 === t5.length) d2 = t5[0];
            else {
              for (const r5 of t5) {
                const t6 = B(r5.config.options.pathsBasePath || l.dirname(r5.config.options.configFilePath)), n5 = null == (s4 = r5.config.raw) ? void 0 : s4.include, o4 = null == (i4 = r5.config.raw) ? void 0 : i4.exclude;
                if (!n5 && (!t6 || e4.startsWith(t6)) || n5.some((r6) => tl(e4, R(t6, r6)))) {
                  if (o4 && o4.some((r6) => tl(e4, R(t6, r6)))) continue;
                  d2 = r5;
                  break;
                }
              }
              d2 || (d2 = t5[t5.length - 1]);
            }
            a3 = d2.config.options, c2 = d2.cache || (d2.cache = r4.createModuleResolutionCache(x.cwd(), r4.sys.useCaseSensitiveFileNames ? k : j, a3));
          } else a3 = {};
          const u2 = r4.resolveModuleName(t4, e4, a3, n4, c2);
          if (u2.resolvedModule) {
            let e5 = u2.resolvedModule.resolvedFileName;
            return e5.endsWith(".vue.ts") && (e5 = e5.replace(/\.ts$/, "")), n4.realpath ? n4.realpath(e5) : e5;
          }
        }(r3.filename, n3, ql, s3);
      }
      i3 && (i3 = r3.resolvedImportSources[n3] = B(i3));
    }
    return i3 ? ((e3.deps || (e3.deps = /* @__PURE__ */ new Set())).add(i3), Ql(e3, i3)) : e3.error(`Failed to resolve import source ${JSON.stringify(n3)}.`, t3, r3);
  }
  function zl(e3, t3) {
    const r3 = (e4) => {
      if (t3.fileExists(e4)) return e4;
    };
    return r3(e3 = e3.replace(/\.js$/, "")) || r3(e3 + ".ts") || r3(e3 + ".d.ts") || r3(R(e3, "index.ts")) || r3(R(e3, "index.d.ts"));
  }
  const Kl = de(), Xl = /* @__PURE__ */ new Map();
  function Jl(e3, t3, r3) {
    const n3 = t3.sys, s3 = t3.parseJsonConfigFileContent(t3.readConfigFile(e3, r3.readFile).config, n3, l.dirname(e3), void 0, e3), i3 = [s3];
    if (s3.projectReferences) for (const n4 of s3.projectReferences) Xl.set(n4.path, e3), i3.unshift(...Jl(n4.path, t3, r3));
    return i3;
  }
  const Yl = de();
  function Ql(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    const n3 = Yl.get(t3);
    if (n3) return n3;
    const s3 = Gl(e3).readFile(t3) || "", i3 = function(e4, t4, r4) {
      const n4 = l.extname(e4);
      if (".ts" === n4 || ".tsx" === n4) return g.parse(t4, { plugins: ma(n4.slice(1), r4, e4.endsWith(".d.ts")), sourceType: "module" }).program.body;
      if (".vue" === n4) {
        const { descriptor: { script: e5, scriptSetup: n5 } } = be(t4);
        if (!e5 && !n5) return [];
        const s4 = e5 ? e5.loc.start.offset : 1 / 0, i4 = n5 ? n5.loc.start.offset : 1 / 0, o4 = s4 < i4 ? e5 : n5, a3 = s4 < i4 ? n5 : e5;
        let l2 = " ".repeat(Math.min(s4, i4)) + o4.content;
        a3 && (l2 += " ".repeat(a3.loc.start.offset - e5.loc.end.offset) + a3.content);
        const c2 = (null == e5 ? void 0 : e5.lang) || (null == n5 ? void 0 : n5.lang);
        return g.parse(l2, { plugins: ma(c2, r4), sourceType: "module" }).program.body;
      }
      return [];
    }(t3, s3, e3.options.babelParserPlugins), o3 = new Il(t3, s3, 0, oc(i3));
    return rc(e3, i3, o3, r3), Yl.set(t3, o3), o3;
  }
  function Zl(e3) {
    if (e3.scope) return e3.scope;
    const t3 = "ast" in e3 ? e3.ast : e3.scriptAst ? [...e3.scriptAst.body, ...e3.scriptSetupAst.body] : e3.scriptSetupAst.body, r3 = new Il(e3.filename, e3.source, "startOffset" in e3 ? e3.startOffset : 0, "userImports" in e3 ? Object.create(e3.userImports) : oc(t3));
    return rc(e3, t3, r3), e3.scope = r3;
  }
  function ec(e3) {
    return new Il(e3.filename, e3.source, e3.offset, Object.create(e3.imports), Object.create(e3.types), Object.create(e3.declares));
  }
  const tc = /^Import|^Export/;
  function rc(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    const { types: s3, declares: i3, exportedTypes: o3, exportedDeclares: a3, imports: l2 } = r3, c2 = !!n3 && !t3.some((e4) => tc.test(e4.type));
    for (const e4 of t3) if (n3) {
      if (c2) e4.declare && nc(e4, s3, i3);
      else if ("TSModuleDeclaration" === e4.type && e4.global) for (const t4 of e4.body.body) nc(t4, s3, i3);
    } else nc(e4, s3, i3);
    if (!n3) for (const n4 of t3) if ("ExportNamedDeclaration" === n4.type) {
      if (n4.declaration) nc(n4.declaration, s3, i3), nc(n4.declaration, o3, a3);
      else for (const e4 of n4.specifiers) if ("ExportSpecifier" === e4.type) {
        const t4 = e4.local.name, i4 = _(e4.exported);
        n4.source ? (l2[i4] = { source: n4.source.value, imported: t4 }, o3[i4] = { type: "TSTypeReference", typeName: { type: "Identifier", name: t4 }, _ownerScope: r3 }) : s3[t4] && (o3[i4] = s3[t4]);
      }
    } else if ("ExportAllDeclaration" === n4.type) {
      const t4 = Hl(e3, n4.source, r3, n4.source.value);
      Object.assign(r3.exportedTypes, t4.exportedTypes);
    } else "ExportDefaultDeclaration" === n4.type && n4.declaration && ("Identifier" !== n4.declaration.type ? (nc(n4.declaration, s3, i3, "default"), nc(n4.declaration, o3, a3, "default")) : s3[n4.declaration.name] && (o3.default = s3[n4.declaration.name]));
    for (const e4 of Object.keys(s3)) {
      const t4 = s3[e4];
      t4._ownerScope = r3, t4._ns && (t4._ns._ownerScope = r3);
    }
    for (const e4 of Object.keys(i3)) i3[e4]._ownerScope = r3;
  }
  function nc(e3, t3, r3, n3) {
    switch (e3.type) {
      case "TSInterfaceDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration": {
        const r4 = n3 || _(e3.id);
        let s3 = t3[r4];
        if (s3) {
          if ("TSModuleDeclaration" === e3.type) {
            "TSModuleDeclaration" === s3.type ? sc(s3, e3) : ic(s3, e3);
            break;
          }
          if ("TSModuleDeclaration" === s3.type) {
            t3[r4] = e3, ic(e3, s3);
            break;
          }
          if (s3.type !== e3.type) break;
          "TSInterfaceDeclaration" === e3.type ? s3.body.body.push(...e3.body.body) : s3.members.push(...e3.members);
        } else t3[r4] = e3;
        break;
      }
      case "ClassDeclaration":
        (n3 || e3.id) && (t3[n3 || _(e3.id)] = e3);
        break;
      case "TSTypeAliasDeclaration":
        t3[e3.id.name] = e3.typeParameters ? e3 : e3.typeAnnotation;
        break;
      case "TSDeclareFunction":
        e3.id && (r3[e3.id.name] = e3);
        break;
      case "VariableDeclaration":
        if (e3.declare) for (const t4 of e3.declarations) "Identifier" === t4.id.type && t4.id.typeAnnotation && (r3[t4.id.name] = t4.id.typeAnnotation.typeAnnotation);
    }
  }
  function sc(e3, t3) {
    const r3 = e3.body, n3 = t3.body;
    "TSModuleDeclaration" === r3.type ? "TSModuleDeclaration" === n3.type ? sc(r3, n3) : n3.body.push({ type: "ExportNamedDeclaration", declaration: r3, exportKind: "type", specifiers: [] }) : "TSModuleDeclaration" === n3.type ? r3.body.push({ type: "ExportNamedDeclaration", declaration: n3, exportKind: "type", specifiers: [] }) : r3.body.push(...n3.body);
  }
  function ic(e3, t3) {
    e3._ns ? sc(e3._ns, t3) : e3._ns = t3;
  }
  function oc(e3) {
    const t3 = /* @__PURE__ */ Object.create(null);
    for (const r3 of e3) ac(r3, t3);
    return t3;
  }
  function ac(e3, t3) {
    if ("ImportDeclaration" === e3.type) for (const r3 of e3.specifiers) t3[r3.local.name] = { imported: I(r3), source: e3.source.value };
  }
  function lc(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t3._ownerScope || Zl(e3);
    try {
      switch (t3.type) {
        case "TSStringKeyword":
          return ["String"];
        case "TSNumberKeyword":
          return ["Number"];
        case "TSBooleanKeyword":
          return ["Boolean"];
        case "TSObjectKeyword":
          return ["Object"];
        case "TSNullKeyword":
          return ["null"];
        case "TSTypeLiteral":
        case "TSInterfaceDeclaration": {
          const e4 = /* @__PURE__ */ new Set(), r4 = "TSTypeLiteral" === t3.type ? t3.members : t3.body.body;
          for (const t4 of r4) "TSCallSignatureDeclaration" === t4.type || "TSConstructSignatureDeclaration" === t4.type ? e4.add("Function") : e4.add("Object");
          return e4.size ? Array.from(e4) : ["Object"];
        }
        case "TSPropertySignature":
          if (t3.typeAnnotation) return lc(e3, t3.typeAnnotation.typeAnnotation, r3);
          break;
        case "TSMethodSignature":
        case "TSFunctionType":
          return ["Function"];
        case "TSArrayType":
        case "TSTupleType":
          return ["Array"];
        case "TSLiteralType":
          switch (t3.literal.type) {
            case "StringLiteral":
              return ["String"];
            case "BooleanLiteral":
              return ["Boolean"];
            case "NumericLiteral":
            case "BigIntLiteral":
              return ["Number"];
            default:
              return [T];
          }
        case "TSTypeReference": {
          const n3 = Fl(e3, t3, r3);
          if (n3) return lc(e3, n3, n3._ownerScope);
          if ("Identifier" === t3.typeName.type) switch (t3.typeName.name) {
            case "Array":
            case "Function":
            case "Object":
            case "Set":
            case "Map":
            case "WeakSet":
            case "WeakMap":
            case "Date":
            case "Promise":
            case "Error":
              return [t3.typeName.name];
            case "Partial":
            case "Required":
            case "Readonly":
            case "Record":
            case "Pick":
            case "Omit":
            case "InstanceType":
              return ["Object"];
            case "Uppercase":
            case "Lowercase":
            case "Capitalize":
            case "Uncapitalize":
              return ["String"];
            case "Parameters":
            case "ConstructorParameters":
              return ["Array"];
            case "NonNullable":
              if (t3.typeParameters && t3.typeParameters.params[0]) return lc(e3, t3.typeParameters.params[0], r3).filter((e4) => "null" !== e4);
              break;
            case "Extract":
              if (t3.typeParameters && t3.typeParameters.params[1]) return lc(e3, t3.typeParameters.params[1], r3);
              break;
            case "Exclude":
            case "OmitThisParameter":
              if (t3.typeParameters && t3.typeParameters.params[0]) return lc(e3, t3.typeParameters.params[0], r3);
          }
          break;
        }
        case "TSParenthesizedType":
          return lc(e3, t3.typeAnnotation, r3);
        case "TSUnionType":
          return cc(e3, t3.types, r3);
        case "TSIntersectionType":
          return cc(e3, t3.types, r3).filter((e4) => e4 !== T);
        case "TSEnumDeclaration":
          return function(e4) {
            const t4 = /* @__PURE__ */ new Set();
            for (const r4 of e4.members) if (r4.initializer) switch (r4.initializer.type) {
              case "StringLiteral":
                t4.add("String");
                break;
              case "NumericLiteral":
                t4.add("Number");
            }
            return t4.size ? [...t4] : ["Number"];
          }(t3);
        case "TSSymbolKeyword":
          return ["Symbol"];
        case "TSIndexedAccessType":
          return cc(e3, jl(e3, t3, r3), r3);
        case "ClassDeclaration":
          return ["Object"];
        case "TSImportType": {
          const n3 = Fl(e3, t3, Hl(e3, t3.argument, r3, t3.argument.value));
          if (n3) return lc(e3, n3, n3._ownerScope);
          break;
        }
        case "TSTypeQuery": {
          const n3 = t3.exprName;
          if ("Identifier" === n3.type) {
            const t4 = r3.declares[n3.name];
            if (t4) return lc(e3, t4, t4._ownerScope);
          }
          break;
        }
      }
    } catch (e4) {
    }
    return [T];
  }
  function cc(e3, t3, r3) {
    return 1 === t3.length ? lc(e3, t3[0], r3) : [...new Set([].concat(...t3.map((t4) => lc(e3, t4, r3))))];
  }
  function uc(e3, t3) {
    let { props: r3 } = e3;
    const n3 = { props: {} };
    for (const e4 in r3) {
      const s3 = r3[e4];
      n3.props[e4] = pc(s3.key, s3.typeAnnotation.typeAnnotation, t3);
    }
    return n3;
  }
  function pc(e3, t3, r3) {
    let n3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
    if (arguments.length > 4 && void 0 !== arguments[4] && !arguments[4] || "TSTypeLiteral" !== t3.type) {
      if ("TSTypeReference" === t3.type && "Identifier" === t3.typeName.type) {
        if (t3.typeName.name.endsWith("Constructor")) return Dl(e3, function(e4) {
          const t4 = e4.slice(0, -11);
          switch (t4) {
            case "String":
            case "Number":
            case "Boolean":
              return { type: `TS${t4}Keyword` };
            case "Array":
            case "Function":
            case "Object":
            case "Set":
            case "Map":
            case "WeakSet":
            case "WeakMap":
            case "Date":
            case "Promise":
              return { type: "TSTypeReference", typeName: { type: "Identifier", name: t4 } };
          }
          return { type: "TSNullKeyword" };
        }(t3.typeName.name), r3, n3);
        if ("PropType" === t3.typeName.name && t3.typeParameters) return Dl(e3, t3.typeParameters.params[0], r3, n3);
      }
    } else {
      const n4 = dc(t3, "type");
      if (n4) {
        const s3 = dc(t3, "required");
        return pc(e3, n4, r3, !s3 || "TSLiteralType" !== s3.type || "BooleanLiteral" !== s3.literal.type || !s3.literal.value, false);
      }
    }
    if (("TSTypeReference" === t3.type || "TSImportType" === t3.type) && t3.typeParameters) for (const s3 of t3.typeParameters.params) {
      const t4 = pc(e3, s3, r3, n3);
      if (t4) return t4;
    }
    return Dl(e3, { type: "TSNullKeyword" }, r3, n3);
  }
  function dc(e3, t3) {
    const r3 = e3.members.find((e4) => "TSPropertySignature" === e4.type && !e4.computed && _(e4.key) === t3 && e4.typeAnnotation);
    return r3 && r3.typeAnnotation.typeAnnotation;
  }
  function fc(e3, t3, r3) {
    if ("TSTypeReference" === t3.type) {
      const n4 = Fl(e3, t3, r3);
      n4 && (t3 = n4);
    }
    let n3;
    return n3 = "TSUnionType" === t3.type ? t3.types.flatMap((t4) => fc(e3, t4, r3)) : [t3], n3;
  }
  const hc = "defineModel";
  function mc(e3, t3, r3) {
    if (!C(t3, hc)) return false;
    e3.hasDefineModelCall = true;
    const n3 = t3.typeParameters && t3.typeParameters.params[0] || void 0;
    let s3, i3;
    const a3 = t3.arguments[0] && o2.unwrapTSNode(t3.arguments[0]), l2 = a3 && "StringLiteral" === a3.type;
    l2 ? (s3 = a3.value, i3 = t3.arguments[1]) : (s3 = "modelValue", i3 = a3), e3.modelDecls[s3] && e3.error(`duplicate model name ${JSON.stringify(s3)}`, t3);
    let c2 = i3 && e3.getString(i3), u2 = !i3;
    const p2 = [];
    if (i3 && "ObjectExpression" === i3.type && !i3.properties.some((e4) => "SpreadElement" === e4.type || e4.computed)) {
      let t4 = 0;
      for (let r4 = i3.properties.length - 1; r4 >= 0; r4--) {
        const n4 = i3.properties[r4], s4 = i3.properties[r4 + 1], o3 = n4.start, a4 = s4 ? s4.start : i3.end - 1;
        "ObjectProperty" !== n4.type && "ObjectMethod" !== n4.type || ("Identifier" !== n4.key.type || "get" !== n4.key.name && "set" !== n4.key.name) && ("StringLiteral" !== n4.key.type || "get" !== n4.key.value && "set" !== n4.key.value) ? (t4++, e3.s.remove(e3.startOffset + o3, e3.startOffset + a4), p2.push(n4)) : c2 = c2.slice(0, o3 - i3.start) + c2.slice(a4 - i3.start);
      }
      t4 === i3.properties.length && (u2 = true, e3.s.remove(e3.startOffset + (l2 ? a3.end : i3.start), e3.startOffset + i3.end));
    }
    return e3.modelDecls[s3] = { type: n3, options: c2, runtimeOptionNodes: p2, identifier: r3 && "Identifier" === r3.type ? r3.name : void 0 }, e3.bindingMetadata[s3] = "props", e3.s.overwrite(e3.startOffset + t3.callee.start, e3.startOffset + t3.callee.end, e3.helper("useModel")), e3.s.appendLeft(e3.startOffset + (t3.arguments.length ? t3.arguments[0].start : t3.end - 1), "__props, " + (l2 ? "" : `${JSON.stringify(s3)}${u2 ? "" : ", "}`)), true;
  }
  const yc = "defineProps", gc = "withDefaults";
  function bc(e3, t3, r3) {
    if (!C(t3, yc)) return function(e4, t4, r4) {
      return !!C(t4, gc) && (bc(e4, t4.arguments[0], r4) || e4.error(`${gc}' first argument must be a ${yc} call.`, t4.arguments[0] || t4), e4.propsRuntimeDecl && e4.error(`${gc} can only be used with type-based ${yc} declaration.`, t4), e4.propsDestructureDecl && e4.error(`${gc}() is unnecessary when using destructure with ${yc}().
Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...).`, t4.callee), e4.propsRuntimeDefaults = t4.arguments[1], e4.propsRuntimeDefaults || e4.error(`The 2nd argument of ${gc} is required.`, t4), e4.propsCall = t4, true);
    }(e3, t3, r3);
    if (e3.hasDefinePropsCall && e3.error(`duplicate ${yc}() call`, t3), e3.hasDefinePropsCall = true, e3.propsRuntimeDecl = t3.arguments[0], e3.propsRuntimeDecl) for (const t4 of fa(e3.propsRuntimeDecl)) t4 in e3.bindingMetadata || (e3.bindingMetadata[t4] = "props");
    return t3.typeParameters && (e3.propsRuntimeDecl && e3.error(`${yc}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, t3), e3.propsTypeDecl = t3.typeParameters.params[0]), r3 && "ObjectPattern" === r3.type && function(e4, t4) {
      if (!e4.options.propsDestructure) return;
      qe("This project is using reactive props destructure, which is an experimental feature. It may receive breaking changes or be removed in the future, so use at your own risk.\nTo stay updated, follow the RFC at https://github.com/vuejs/rfcs/discussions/502."), e4.propsDestructureDecl = t4;
      const r4 = (t5, r5, n3) => {
        e4.propsDestructuredBindings[t5] = { local: r5, default: n3 }, r5 !== t5 && (e4.bindingMetadata[r5] = "props-aliased", (e4.bindingMetadata.__propsAliases || (e4.bindingMetadata.__propsAliases = {}))[r5] = t5);
      };
      for (const n3 of t4.properties) if ("ObjectProperty" === n3.type) {
        const t5 = w(n3.key, n3.computed);
        if (t5 || e4.error(`${yc}() destructure cannot use computed key.`, n3.key), "AssignmentPattern" === n3.value.type) {
          const { left: s3, right: i3 } = n3.value;
          "Identifier" !== s3.type && e4.error(`${yc}() destructure does not support nested patterns.`, s3), r4(t5, s3.name, i3);
        } else "Identifier" === n3.value.type ? r4(t5, n3.value.name) : e4.error(`${yc}() destructure does not support nested patterns.`, n3.value);
      } else e4.propsDestructureRestId = n3.argument.name, e4.bindingMetadata[e4.propsDestructureRestId] = "setup-reactive-const";
    }(e3, r3), e3.propsCall = t3, e3.propsDecl = r3, true;
  }
  function vc(e3) {
    const t3 = function(e4, t4) {
      const r4 = [], n4 = _l(e4, t4);
      for (const t5 in n4.props) {
        const s4 = n4.props[t5];
        let i3 = lc(e4, s4), o3 = false;
        i3.includes(T) && (i3.includes("Boolean") || i3.includes("Function") ? (i3 = i3.filter((e5) => e5 !== T), o3 = true) : i3 = ["null"]), r4.push({ key: t5, required: !s4.optional, type: i3 || ["null"], skipCheck: o3 });
      }
      return r4;
    }(e3, e3.propsTypeDecl);
    if (!t3.length) return;
    const r3 = [], n3 = function(e4) {
      return !(!e4.propsRuntimeDefaults || "ObjectExpression" !== e4.propsRuntimeDefaults.type || !e4.propsRuntimeDefaults.properties.every((e5) => "SpreadElement" !== e5.type && (!e5.computed || e5.key.type.endsWith("Literal"))));
    }(e3);
    for (const s4 of t3) r3.push(Ec(e3, s4, n3)), "bindingMetadata" in e3 && !(s4.key in e3.bindingMetadata) && (e3.bindingMetadata[s4.key] = "props");
    let s3 = `{
    ${r3.join(",\n    ")}
  }`;
    return e3.propsRuntimeDefaults && !n3 && (s3 = `/*#__PURE__*/${e3.helper("mergeDefaults")}(${s3}, ${e3.getString(e3.propsRuntimeDefaults)})`), s3;
  }
  function Ec(e3, t3, r3) {
    let n3, { key: s3, required: i3, type: o3, skipCheck: a3 } = t3;
    const l2 = Sc(e3, s3, o3);
    if (l2) n3 = `default: ${l2.valueString}${l2.needSkipFactory ? ", skipFactory: true" : ""}`;
    else if (r3) {
      const t4 = e3.propsRuntimeDefaults.properties.find((e4) => "SpreadElement" !== e4.type && w(e4.key, e4.computed) === s3);
      t4 && (n3 = "ObjectProperty" === t4.type ? `default: ${e3.getString(t4.value)}` : `${t4.async ? "async " : ""}${"method" !== t4.kind ? `${t4.kind} ` : ""}default() ${e3.getString(t4.body)}`);
    }
    const c2 = U(s3);
    return e3.options.isProd ? o3.some((e4) => "Boolean" === e4 || (!r3 || n3) && "Function" === e4) ? `${c2}: { ${P([`type: ${O(o3)}`, n3])} }` : e3.isCE ? n3 ? `${c2}: { ${n3}, type: ${O(o3)} }` : `${c2}: {type: ${O(o3)}}` : `${c2}: ${n3 ? `{ ${n3} }` : "{}"}` : `${c2}: { ${P([`type: ${O(o3)}`, `required: ${i3}`, a3 && "skipCheck: true", n3])} }`;
  }
  function Sc(e3, t3, r3) {
    const n3 = e3.propsDestructuredBindings[t3], s3 = n3 && n3.default;
    if (s3) {
      const n4 = e3.getString(s3), i3 = o2.unwrapTSNode(s3);
      if (r3 && r3.length && !r3.includes("null")) {
        const n5 = function(e4) {
          switch (e4.type) {
            case "StringLiteral":
              return "String";
            case "NumericLiteral":
              return "Number";
            case "BooleanLiteral":
              return "Boolean";
            case "ObjectExpression":
              return "Object";
            case "ArrayExpression":
              return "Array";
            case "FunctionExpression":
            case "ArrowFunctionExpression":
              return "Function";
          }
        }(i3);
        n5 && !r3.includes(n5) && e3.error(`Default value of prop "${t3}" does not match declared type.`, i3);
      }
      const a3 = !r3 && (o2.isFunctionType(i3) || "Identifier" === i3.type);
      return { valueString: a3 || A(i3) || (null == r3 ? void 0 : r3.includes("Function")) ? n4 : `() => (${n4})`, needSkipFactory: a3 };
    }
  }
  const xc = "defineEmits";
  function Tc(e3, t3, r3) {
    return !!C(t3, xc) && (e3.hasDefineEmitCall && e3.error(`duplicate ${xc}() call`, t3), e3.hasDefineEmitCall = true, e3.emitsRuntimeDecl = t3.arguments[0], t3.typeParameters && (e3.emitsRuntimeDecl && e3.error(`${xc}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, t3), e3.emitsTypeDecl = t3.typeParameters.params[0]), e3.emitDecl = r3, true);
  }
  function wc(e3) {
    const t3 = /* @__PURE__ */ new Set(), r3 = e3.emitsTypeDecl;
    if ("TSFunctionType" === r3.type) return Pc(e3, r3.parameters[0], t3), t3;
    const { props: n3, calls: s3 } = _l(e3, r3);
    let i3 = false;
    for (const e4 in n3) t3.add(e4), i3 = true;
    if (s3) {
      i3 && e3.error("defineEmits() type cannot mixed call signature and property syntax.", r3);
      for (const r4 of s3) Pc(e3, r4.parameters[0], t3);
    }
    return t3;
  }
  function Pc(e3, t3, r3) {
    if ("Identifier" === t3.type && t3.typeAnnotation && "TSTypeAnnotation" === t3.typeAnnotation.type) {
      const n3 = fc(e3, t3.typeAnnotation.typeAnnotation);
      for (const e4 of n3) "TSLiteralType" === e4.type && "UnaryExpression" !== e4.literal.type && "TemplateLiteral" !== e4.literal.type && r3.add(String(e4.literal.value));
    }
  }
  const Ac = "defineExpose";
  function Cc(e3, t3) {
    return !!C(t3, Ac) && (e3.hasDefineExposeCall && e3.error(`duplicate ${Ac}() call`, t3), e3.hasDefineExposeCall = true, true);
  }
  const Oc = "defineSlots";
  function Ic(e3, t3, r3) {
    return !!C(t3, Oc) && (e3.hasDefineSlotsCall && e3.error(`duplicate ${Oc}() call`, t3), e3.hasDefineSlotsCall = true, t3.arguments.length > 0 && e3.error(`${Oc}() cannot accept arguments`, t3), r3 && e3.s.overwrite(e3.startOffset + t3.start, e3.startOffset + t3.end, `${e3.helper("useSlots")}()`), true);
  }
  const _c = "defineOptions";
  function kc(e3, t3) {
    if (!C(t3, _c)) return false;
    if (e3.hasDefineOptionsCall && e3.error(`duplicate ${_c}() call`, t3), t3.typeParameters && e3.error(`${_c}() cannot accept type arguments`, t3), !t3.arguments[0]) return true;
    let r3, n3, s3, i3;
    if (e3.hasDefineOptionsCall = true, e3.optionsRuntimeDecl = o2.unwrapTSNode(t3.arguments[0]), "ObjectExpression" === e3.optionsRuntimeDecl.type) for (const t4 of e3.optionsRuntimeDecl.properties) "ObjectProperty" !== t4.type && "ObjectMethod" !== t4.type || "Identifier" !== t4.key.type || ("props" === t4.key.name && (r3 = t4), "emits" === t4.key.name && (n3 = t4), "expose" === t4.key.name && (s3 = t4), "slots" === t4.key.name && (i3 = t4));
    return r3 && e3.error(`${_c}() cannot be used to declare props. Use ${yc}() instead.`, r3), n3 && e3.error(`${_c}() cannot be used to declare emits. Use ${xc}() instead.`, n3), s3 && e3.error(`${_c}() cannot be used to declare expose. Use ${Ac}() instead.`, s3), i3 && e3.error(`${_c}() cannot be used to declare slots. Use ${Oc}() instead.`, i3), true;
  }
  function Nc(e3, t3, r3, n3) {
    const s3 = t3.argument.extra && t3.argument.extra.parenthesized ? t3.argument.extra.parenStart : t3.argument.start, i3 = e3.startOffset, o3 = e3.descriptor.source.slice(s3 + i3, t3.argument.end + i3), a3 = /\bawait\b/.test(o3);
    e3.s.overwrite(t3.start + i3, s3 + i3, `${r3 ? ";" : ""}(
  ([__temp,__restore] = ${e3.helper("withAsyncContext")}(${a3 ? "async " : ""}() => `), e3.s.appendLeft(t3.end + i3, `)),
  ${n3 ? "" : "__temp = "}await __temp,
  __restore()${n3 ? "" : ",\n  __temp"}
)`);
  }
  function Dc(e3, t3, r3) {
    e3[t3.name] = r3;
  }
  function jc(e3, t3, r3, n3, s3) {
    let i3 = false;
    if ("VariableDeclaration" === t3.type) {
      const a3 = "const" === t3.kind;
      i3 = a3 && t3.declarations.every((e4) => "Identifier" === e4.id.type && Fc(e4.init));
      for (const { id: l2, init: c2 } of t3.declarations) {
        const t4 = c2 && o2.unwrapTSNode(c2), u2 = !(!a3 || !C(t4, (e4) => e4 === yc || e4 === xc || e4 === gc));
        if ("Identifier" === l2.type) {
          let o3;
          const c3 = n3.reactive;
          o3 = (s3 || "script" === e3) && (i3 || a3 && Fc(t4)) ? "literal-const" : C(t4, c3) ? a3 ? "setup-reactive-const" : "setup-let" : u2 || a3 && Rc(t4, c3) ? C(t4, yc) ? "setup-reactive-const" : "setup-const" : a3 ? C(t4, (e4) => e4 === n3.ref || e4 === n3.computed || e4 === n3.shallowRef || e4 === n3.customRef || e4 === n3.toRef || e4 === hc) ? "setup-ref" : "setup-maybe-ref" : "setup-let", Dc(r3, l2, o3);
        } else {
          if (C(t4, yc)) continue;
          "ObjectPattern" === l2.type ? Lc(l2, r3, a3, u2) : "ArrayPattern" === l2.type && Mc(l2, r3, a3, u2);
        }
      }
    } else "TSEnumDeclaration" === t3.type ? (i3 = t3.members.every((e4) => !e4.initializer || Fc(e4.initializer)), r3[t3.id.name] = i3 ? "literal-const" : "setup-const") : "FunctionDeclaration" !== t3.type && "ClassDeclaration" !== t3.type || (r3[t3.id.name] = "setup-const");
    return i3;
  }
  function Lc(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    for (const s3 of e3.properties) if ("ObjectProperty" === s3.type) if ("Identifier" === s3.key.type && s3.key === s3.value) {
      const e4 = n3 ? "setup-const" : r3 ? "setup-maybe-ref" : "setup-let";
      Dc(t3, s3.key, e4);
    } else Bc(s3.value, t3, r3, n3);
    else {
      const e4 = r3 ? "setup-const" : "setup-let";
      Dc(t3, s3.argument, e4);
    }
  }
  function Mc(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    for (const s3 of e3.elements) s3 && Bc(s3, t3, r3, n3);
  }
  function Bc(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    if ("Identifier" === e3.type) Dc(t3, e3, n3 ? "setup-const" : r3 ? "setup-maybe-ref" : "setup-let");
    else if ("RestElement" === e3.type) {
      const n4 = r3 ? "setup-const" : "setup-let";
      Dc(t3, e3.argument, n4);
    } else if ("ObjectPattern" === e3.type) Lc(e3, t3, r3);
    else if ("ArrayPattern" === e3.type) Mc(e3, t3, r3);
    else if ("AssignmentPattern" === e3.type) if ("Identifier" === e3.left.type) {
      const s3 = n3 ? "setup-const" : r3 ? "setup-maybe-ref" : "setup-let";
      Dc(t3, e3.left, s3);
    } else Bc(e3.left, t3, r3);
  }
  function Rc(e3, t3) {
    if (C(e3, t3)) return true;
    switch (e3.type) {
      case "UnaryExpression":
      case "BinaryExpression":
      case "ArrayExpression":
      case "ObjectExpression":
      case "FunctionExpression":
      case "ArrowFunctionExpression":
      case "UpdateExpression":
      case "ClassExpression":
      case "TaggedTemplateExpression":
        return true;
      case "SequenceExpression":
        return Rc(e3.expressions[e3.expressions.length - 1], t3);
      default:
        return !!A(e3);
    }
  }
  function Fc(e3) {
    switch ((e3 = o2.unwrapTSNode(e3)).type) {
      case "UnaryExpression":
        return Fc(e3.argument);
      case "LogicalExpression":
      case "BinaryExpression":
        return Fc(e3.left) && Fc(e3.right);
      case "ConditionalExpression":
        return Fc(e3.test) && Fc(e3.consequent) && Fc(e3.alternate);
      case "SequenceExpression":
      case "TemplateLiteral":
        return e3.expressions.every((e4) => Fc(e4));
      case "ParenthesizedExpression":
        return Fc(e3.expression);
      case "StringLiteral":
      case "NumericLiteral":
      case "BooleanLiteral":
      case "NullLiteral":
      case "BigIntLiteral":
        return true;
    }
    return false;
  }
  const Uc = ge, $c = { ...o2.errorMessages, ...o2.DOMErrorMessages }, Vc = m.walk;
  t2.extractIdentifiers = i2.extractIdentifiers, t2.generateCodeFrame = i2.generateCodeFrame, t2.isInDestructureAssignment = i2.isInDestructureAssignment, t2.isStaticProperty = i2.isStaticProperty, t2.walkIdentifiers = i2.walkIdentifiers, t2.MagicString = y, t2.babelParse = g.parse, t2.compileScript = function(e3, t3) {
    var r3;
    t3.id || qe("compileScript now requires passing the `id` option.\nUpgrade your vite or vue-loader version for compatibility with the latest experimental proposals.");
    const n3 = new ha(e3, t3), { script: s3, scriptSetup: i3, source: a3, filename: l2 } = e3, u2 = false !== t3.hoistStatic && !s3, p2 = t3.id ? t3.id.replace(/^data-v-/, "") : "", d2 = s3 && s3.lang, f2 = i3 && i3.lang;
    if (!i3) {
      if (!s3) throw new Error("[@vue/compiler-sfc] SFC contains no <script> tags.");
      return function(e4, t4) {
        var r4;
        const n4 = e4.descriptor.script;
        if (n4.lang && !e4.isJS && !e4.isTS) return n4;
        try {
          let s4 = n4.content, i4 = n4.map;
          const o3 = e4.scriptAst, a4 = ua(o3.body), { cssVars: l3 } = e4.descriptor, { genDefaultAs: c2, isProd: u3 } = e4.options;
          if (l3.length || c2) {
            const n5 = c2 || ba, i5 = new y(s4);
            ya(o3.body, i5, n5), s4 = i5.toString(), l3.length && !(null == (r4 = e4.options.templateOptions) ? void 0 : r4.ssr) && (s4 += function(e5, t5, r5, n6, s5) {
              return `
import { ${z} as _${z} } from 'vue'
const __injectCSSVars__ = () => {
${ee(e5, t5, r5, n6)}}
const __setup__ = ${s5}.setup
${s5}.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
`;
            }(l3, a4, t4, !!u3, n5)), c2 || (s4 += `
export default ${n5}`);
          }
          return { ...n4, content: s4, map: i4, bindings: a4, scriptAst: o3.body };
        } catch (e5) {
          return n4;
        }
      }(n3, p2);
    }
    if (s3 && d2 !== f2) throw new Error("[@vue/compiler-sfc] <script> and <script setup> must have the same language type.");
    if (f2 && !n3.isJS && !n3.isTS) return i3;
    const h2 = /* @__PURE__ */ Object.create(null), g2 = /* @__PURE__ */ Object.create(null);
    let b2, v2 = false, E2 = false;
    const S2 = n3.startOffset, x2 = n3.endOffset, w2 = s3 && s3.loc.start.offset, A2 = s3 && s3.loc.end.offset;
    function _2(e4) {
      const t4 = e4.start + S2;
      let r4 = e4.end + S2;
      for (e4.trailingComments && e4.trailingComments.length > 0 && (r4 = e4.trailingComments[e4.trailingComments.length - 1].end + S2); r4 <= a3.length && /\s/.test(a3.charAt(r4)); ) r4++;
      n3.s.move(t4, r4, 0);
    }
    function k2(t4, r4, s4, i4, o3, a4) {
      let l3 = a4;
      a4 && n3.isTS && e3.template && !e3.template.src && !e3.template.lang && (l3 = fe(r4, e3)), n3.userImports[r4] = { isType: i4, imported: s4, local: r4, source: t4, isFromSetup: o3, isUsedInTemplate: l3 };
    }
    function N2(e4, t4) {
      e4 && o2.walkIdentifiers(e4, (e5) => {
        const r4 = g2[e5.name];
        r4 && "literal-const" !== r4 && n3.error(`\`${t4}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function. If your component options require initialization in the module scope, use a separate normal <script> to export the options instead.`, e5);
      });
    }
    const D2 = n3.scriptAst, j2 = n3.scriptSetupAst;
    if (D2) {
      for (const e4 of D2.body) if ("ImportDeclaration" === e4.type) for (const r4 of e4.specifiers) {
        const n4 = I(r4);
        k2(e4.source.value, r4.local.name, n4, "type" === e4.importKind || "ImportSpecifier" === r4.type && "type" === r4.importKind, false, !t3.inlineTemplate);
      }
    }
    for (const e4 of j2.body) if ("ImportDeclaration" === e4.type) {
      _2(e4);
      let r4 = 0;
      const s4 = (t4) => {
        const s5 = t4 > r4;
        r4++;
        const i4 = e4.specifiers[t4], o3 = e4.specifiers[t4 + 1];
        n3.s.remove(s5 ? e4.specifiers[t4 - 1].end + S2 : i4.start + S2, o3 && !s5 ? o3.start + S2 : i4.end + S2);
      };
      for (let r5 = 0; r5 < e4.specifiers.length; r5++) {
        const i4 = e4.specifiers[r5], o3 = i4.local.name, a4 = I(i4), l3 = e4.source.value, c2 = n3.userImports[o3];
        "vue" !== l3 || a4 !== yc && a4 !== xc && a4 !== Ac ? c2 ? c2.source === l3 && c2.imported === a4 ? s4(r5) : n3.error("different imports aliased to same local name.", i4) : k2(l3, o3, a4, "type" === e4.importKind || "ImportSpecifier" === i4.type && "type" === i4.importKind, true, !t3.inlineTemplate) : (qe(`\`${a4}\` is a compiler macro and no longer needs to be imported.`), s4(r5));
      }
      e4.specifiers.length && r4 === e4.specifiers.length && n3.s.remove(e4.start + S2, e4.end + S2);
    }
    const L2 = {};
    for (const e4 in n3.userImports) {
      const { source: t4, imported: r4, local: s4 } = n3.userImports[e4];
      "vue" === t4 && (L2[r4] = s4);
    }
    if (s3 && D2) {
      for (const e4 of D2.body) if ("ExportDefaultDeclaration" === e4.type) {
        let t4;
        if (b2 = e4, "ObjectExpression" === b2.declaration.type ? t4 = b2.declaration.properties : "CallExpression" === b2.declaration.type && b2.declaration.arguments[0] && "ObjectExpression" === b2.declaration.arguments[0].type && (t4 = b2.declaration.arguments[0].properties), t4) for (const e5 of t4) "ObjectProperty" === e5.type && "Identifier" === e5.key.type && "name" === e5.key.name && (n3.hasDefaultExportName = true), "ObjectMethod" !== e5.type && "ObjectProperty" !== e5.type || "Identifier" !== e5.key.type || "render" !== e5.key.name || (n3.hasDefaultExportRender = true);
        const r4 = e4.start + w2, s4 = e4.declaration.start + w2;
        n3.s.overwrite(r4, s4, `const ${ba} = `);
      } else if ("ExportNamedDeclaration" === e4.type) {
        const t4 = e4.specifiers.find((e5) => "Identifier" === e5.exported.type && "default" === e5.exported.name);
        t4 && (b2 = e4, e4.specifiers.length > 1 ? n3.s.remove(t4.start + w2, t4.end + w2) : n3.s.remove(e4.start + w2, e4.end + w2), e4.source ? n3.s.prepend(`import { ${t4.local.name} as ${ba} } from '${e4.source.value}'
`) : n3.s.appendLeft(A2, `
const ${ba} = ${t4.local.name}
`)), e4.declaration && jc("script", e4.declaration, h2, L2, u2);
      } else "VariableDeclaration" !== e4.type && "FunctionDeclaration" !== e4.type && "ClassDeclaration" !== e4.type && "TSEnumDeclaration" !== e4.type || e4.declare || jc("script", e4, h2, L2, u2);
      w2 > S2 && (/\n$/.test(s3.content.trim()) || n3.s.appendLeft(A2, "\n"), n3.s.move(w2, A2, 0));
    }
    for (const e4 of j2.body) {
      if ("ExpressionStatement" === e4.type) {
        const t5 = o2.unwrapTSNode(e4.expression);
        if (bc(n3, t5) || Tc(n3, t5) || kc(n3, t5) || Ic(n3, t5)) n3.s.remove(e4.start + S2, e4.end + S2);
        else if (Cc(n3, t5)) {
          const e5 = t5.callee;
          n3.s.overwrite(e5.start + S2, e5.end + S2, "__expose");
        } else mc(n3, t5);
      }
      if ("VariableDeclaration" === e4.type && !e4.declare) {
        const t5 = e4.declarations.length;
        let r4, s4 = t5;
        for (let i4 = 0; i4 < t5; i4++) {
          const a4 = e4.declarations[i4], l3 = a4.init && o2.unwrapTSNode(a4.init);
          if (l3) {
            kc(n3, l3) && n3.error(`${_c}() has no returning value, it cannot be assigned.`, e4);
            const o3 = bc(n3, l3, a4.id), c2 = !o3 && Tc(n3, l3, a4.id);
            if (!c2 && (Ic(n3, l3, a4.id) || mc(n3, l3, a4.id)), o3 && !n3.propsDestructureRestId && n3.propsDestructureDecl) if (1 === s4) n3.s.remove(e4.start + S2, e4.end + S2);
            else {
              let o4 = a4.start + S2, l4 = a4.end + S2;
              i4 === t5 - 1 ? o4 = e4.declarations[r4].end + S2 : l4 = e4.declarations[i4 + 1].start + S2, n3.s.remove(o4, l4), s4--;
            }
            else c2 ? n3.s.overwrite(S2 + l3.start, S2 + l3.end, "__emit") : r4 = i4;
          }
        }
      }
      let t4 = false;
      if ("VariableDeclaration" !== e4.type && "FunctionDeclaration" !== e4.type && "ClassDeclaration" !== e4.type && "TSEnumDeclaration" !== e4.type || e4.declare || (t4 = jc("scriptSetup", e4, g2, L2, u2)), u2 && t4 && _2(e4), "VariableDeclaration" === e4.type && !e4.declare || e4.type.endsWith("Statement")) {
        const t5 = [j2.body];
        m.walk(e4, { enter(e5, r4) {
          if (o2.isFunctionType(e5) && this.skip(), "BlockStatement" === e5.type && t5.push(e5.body), "AwaitExpression" === e5.type) {
            v2 = true;
            const s4 = t5[t5.length - 1].some((r5, n4) => (1 === t5.length || n4 > 0) && "ExpressionStatement" === r5.type && r5.start === e5.start);
            Nc(n3, e5, s4, "ExpressionStatement" === r4.type);
          }
        }, exit(e5) {
          "BlockStatement" === e5.type && t5.pop();
        } });
      }
      ("ExportNamedDeclaration" === e4.type && "type" !== e4.exportKind || "ExportAllDeclaration" === e4.type || "ExportDefaultDeclaration" === e4.type) && n3.error("<script setup> cannot contain ES module exports. If you are using a previous version of <script setup>, please consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.", e4), n3.isTS && (e4.type.startsWith("TS") || "ExportNamedDeclaration" === e4.type && "type" === e4.exportKind || "VariableDeclaration" === e4.type && e4.declare) && "TSEnumDeclaration" !== e4.type && _2(e4);
    }
    n3.propsDestructureDecl && function(e4, t4) {
      if (!e4.options.propsDestructure) return;
      const r4 = {}, n4 = [r4];
      let s4 = r4;
      const i4 = /* @__PURE__ */ new WeakSet(), a4 = [], l3 = /* @__PURE__ */ Object.create(null);
      for (const t5 in e4.propsDestructuredBindings) {
        const { local: n5 } = e4.propsDestructuredBindings[t5];
        r4[n5] = true, l3[n5] = t5;
      }
      function u3() {
        n4.push(s4 = Object.create(s4));
      }
      function p3(t5) {
        i4.add(t5), s4 ? s4[t5.name] = false : e4.error("registerBinding called without active scope, something is wrong.", t5);
      }
      function d3(e5) {
        let t5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        for (const r5 of e5.body) if ("VariableDeclaration" === r5.type) f3(r5, t5);
        else if ("FunctionDeclaration" === r5.type || "ClassDeclaration" === r5.type) {
          if (r5.declare || !r5.id) continue;
          p3(r5.id);
        } else "ForOfStatement" !== r5.type && "ForInStatement" !== r5.type || "VariableDeclaration" !== r5.left.type ? "ExportNamedDeclaration" === r5.type && r5.declaration && "VariableDeclaration" === r5.declaration.type ? f3(r5.declaration, t5) : "LabeledStatement" === r5.type && "VariableDeclaration" === r5.body.type && f3(r5.body, t5) : f3(r5.left);
      }
      function f3(e5) {
        let t5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (!e5.declare) for (const r5 of e5.declarations) {
          const e6 = t5 && r5.init && C(o2.unwrapTSNode(r5.init), "defineProps");
          for (const t6 of o2.extractIdentifiers(r5.id)) e6 ? i4.add(t6) : p3(t6);
        }
      }
      function h3(t5, r5) {
        if (C(t5, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : r5)) {
          const n5 = o2.unwrapTSNode(t5.arguments[0]);
          "Identifier" === n5.type && s4[n5.name] && e4.error(`"${n5.name}" is a destructured prop and should not be passed directly to ${r5}(). Pass a getter () => ${n5.name} instead.`, n5);
        }
      }
      const y2 = e4.scriptSetupAst;
      d3(y2, true), m.walk(y2, { enter(r5, n5) {
        return n5 && a4.push(n5), n5 && n5.type.startsWith("TS") && "TSAsExpression" !== n5.type && "TSNonNullExpression" !== n5.type && "TSTypeAssertion" !== n5.type ? this.skip() : (h3(r5, "watch", t4.watch), h3(r5, "toRef", t4.toRef), o2.isFunctionType(r5) ? (u3(), o2.walkFunctionParams(r5, p3), void ("BlockStatement" === r5.body.type && d3(r5.body))) : "CatchClause" === r5.type ? (u3(), r5.param && "Identifier" === r5.param.type && p3(r5.param), void d3(r5.body)) : "BlockStatement" !== r5.type || o2.isFunctionType(n5) ? void ("Identifier" === r5.type && o2.isReferencedIdentifier(r5, n5, a4) && !i4.has(r5) && s4[r5.name] && function(t5, r6, n6) {
          ("AssignmentExpression" === r6.type && t5 === r6.left || "UpdateExpression" === r6.type) && e4.error("Cannot assign to destructured props as they are readonly.", t5), o2.isStaticProperty(r6) && r6.shorthand ? r6.inPattern && !o2.isInDestructureAssignment(r6, n6) || e4.s.appendLeft(t5.end + e4.startOffset, `: ${c.genPropsAccessExp(l3[t5.name])}`) : e4.s.overwrite(t5.start + e4.startOffset, t5.end + e4.startOffset, c.genPropsAccessExp(l3[t5.name]));
        }(r5, n5, a4)) : (u3(), void d3(r5)));
      }, leave(e5, t5) {
        t5 && a4.pop(), ("BlockStatement" === e5.type && !o2.isFunctionType(t5) || o2.isFunctionType(e5)) && (n4.pop(), s4 = n4[n4.length - 1] || null);
      } });
    }(n3, L2), N2(n3.propsRuntimeDecl, yc), N2(n3.propsRuntimeDefaults, yc), N2(n3.propsDestructureDecl, yc), N2(n3.emitsRuntimeDecl, xc), N2(n3.optionsRuntimeDecl, _c);
    for (const { runtimeOptionNodes: e4 } of Object.values(n3.modelDecls)) for (const t4 of e4) N2(t4, hc);
    s3 ? S2 < w2 ? (n3.s.remove(0, S2), n3.s.remove(x2, w2), n3.s.remove(A2, a3.length)) : (n3.s.remove(0, w2), n3.s.remove(A2, S2), n3.s.remove(x2, a3.length)) : (n3.s.remove(0, S2), n3.s.remove(x2, a3.length)), D2 && Object.assign(n3.bindingMetadata, ua(D2.body));
    for (const [e4, { isType: t4, imported: r4, source: s4 }] of Object.entries(n3.userImports)) t4 || (n3.bindingMetadata[e4] = "*" === r4 || "default" === r4 && s4.endsWith(".vue") || "vue" === s4 ? "setup-const" : "setup-maybe-ref");
    for (const e4 in h2) n3.bindingMetadata[e4] = h2[e4];
    for (const e4 in g2) n3.bindingMetadata[e4] = g2[e4];
    e3.cssVars.length && !(null == (r3 = t3.templateOptions) ? void 0 : r3.ssr) && (n3.helperImports.add(z), n3.helperImports.add("unref"), n3.s.prependLeft(S2, `
${ee(e3.cssVars, n3.bindingMetadata, p2, !!t3.isProd)}
`));
    let M2 = "__props";
    if (n3.propsTypeDecl && (M2 += ": any"), n3.propsDecl && (n3.propsDestructureRestId ? (n3.s.overwrite(S2 + n3.propsCall.start, S2 + n3.propsCall.end, `${n3.helper("createPropsRestProxy")}(__props, ${JSON.stringify(Object.keys(n3.propsDestructuredBindings))})`), n3.s.overwrite(S2 + n3.propsDestructureDecl.start, S2 + n3.propsDestructureDecl.end, n3.propsDestructureRestId)) : n3.propsDestructureDecl || n3.s.overwrite(S2 + n3.propsCall.start, S2 + n3.propsCall.end, "__props")), v2) {
      const e4 = n3.isTS ? ": any" : "";
      n3.s.prependLeft(S2, `
let __temp${e4}, __restore${e4}
`);
    }
    const B2 = n3.hasDefineExposeCall || !t3.inlineTemplate ? ["expose: __expose"] : [];
    let R2;
    if (n3.emitDecl && B2.push("emit: __emit"), B2.length && (M2 += `, { ${B2.join(", ")} }`), !t3.inlineTemplate || !e3.template && n3.hasDefaultExportRender) {
      const e4 = { ...h2, ...g2 };
      for (const t4 in n3.userImports) !n3.userImports[t4].isType && n3.userImports[t4].isUsedInTemplate && (e4[t4] = true);
      R2 = "{ ";
      for (const t4 in e4) if (true !== e4[t4] || "vue" === n3.userImports[t4].source || n3.userImports[t4].source.endsWith(".vue")) if ("setup-let" === n3.bindingMetadata[t4]) {
        const e5 = "v" === t4 ? "_v" : "v";
        R2 += `get ${t4}() { return ${t4} }, set ${t4}(${e5}) { ${t4} = ${e5} }, `;
      } else R2 += `${t4}, `;
      else R2 += `get ${t4}() { return ${t4} }, `;
      R2 = R2.replace(/, $/, "") + " }";
    } else if (e3.template && !e3.template.src) {
      t3.templateOptions && t3.templateOptions.ssr && (E2 = true);
      const { code: r4, ast: s4, preamble: i4, tips: u3, errors: d3 } = Ge({ filename: l2, ast: e3.template.ast, source: e3.template.content, inMap: e3.template.map, ...t3.templateOptions, id: p2, scoped: e3.styles.some((e4) => e4.scoped), isProd: t3.isProd, ssrCssVars: e3.cssVars, compilerOptions: { ...t3.templateOptions && t3.templateOptions.compilerOptions, inline: true, isTS: n3.isTS, bindingMetadata: n3.bindingMetadata } });
      u3.length && u3.forEach(qe);
      const f3 = d3[0];
      if ("string" == typeof f3) throw new Error(f3);
      if (f3) throw f3.loc && (f3.message += "\n\n" + e3.filename + "\n" + c.generateCodeFrame(a3, f3.loc.start.offset, f3.loc.end.offset) + "\n"), f3;
      i4 && n3.s.prepend(i4), s4 && s4.helpers.has(o2.UNREF) && n3.helperImports.delete("unref"), R2 = r4;
    } else R2 = "() => {}";
    t3.inlineTemplate ? n3.s.appendRight(x2, `
return ${R2}
}

`) : n3.s.appendRight(x2, `
const __returned__ = ${R2}
Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })
return __returned__
}

`);
    const F2 = t3.genDefaultAs ? `const ${t3.genDefaultAs} =` : "export default";
    let $2 = "";
    if (!n3.hasDefaultExportName && l2 && l2 !== ye) {
      const e4 = l2.match(/([^/\\]+)\.\w+$/);
      e4 && ($2 += `
  __name: '${e4[1]}',`);
    }
    E2 && ($2 += "\n  __ssrInlineRender: true,");
    const V2 = function(e4) {
      let t4;
      if (e4.propsRuntimeDecl) {
        if (t4 = e4.getString(e4.propsRuntimeDecl).trim(), e4.propsDestructureDecl) {
          const r5 = [];
          for (const t5 in e4.propsDestructuredBindings) {
            const n4 = Sc(e4, t5), s4 = U(t5);
            n4 && r5.push(`${s4}: ${n4.valueString}${n4.needSkipFactory ? `, __skip_${s4}: true` : ""}`);
          }
          r5.length && (t4 = `/*#__PURE__*/${e4.helper("mergeDefaults")}(${t4}, {
  ${r5.join(",\n  ")}
})`);
        }
      } else e4.propsTypeDecl && (t4 = vc(e4));
      const r4 = function(e5) {
        if (!e5.hasDefineModelCall) return;
        const t5 = !!e5.options.isProd;
        let r5 = "";
        for (const [n4, { type: s4, options: i4 }] of Object.entries(e5.modelDecls)) {
          let o3 = false, a4 = s4 && lc(e5, s4);
          if (a4) {
            const e6 = a4.includes(T);
            a4 = a4.filter((e7) => e7 !== T && (!t5 || "Boolean" === e7 || "Function" === e7 && i4)), o3 = !t5 && e6 && a4.length > 0;
          }
          let l3 = a4 && a4.length > 0 && O(a4) || void 0;
          const c2 = P([l3 && `type: ${l3}`, o3 && "skipCheck: true"]);
          let u3;
          u3 = l3 && i4 ? e5.isTS ? `{ ${c2}, ...${i4} }` : `Object.assign({ ${c2} }, ${i4})` : i4 || (l3 ? `{ ${c2} }` : "{}"), r5 += `
    ${JSON.stringify(n4)}: ${u3},`, r5 += `
    ${JSON.stringify("modelValue" === n4 ? "modelModifiers" : `${n4}Modifiers`)}: {},`;
        }
        return `{${r5}
  }`;
      }(e4);
      return t4 && r4 ? `/*#__PURE__*/${e4.helper("mergeModels")}(${t4}, ${r4})` : r4 || t4;
    }(n3);
    V2 && ($2 += `
  props: ${V2},`);
    const q2 = function(e4) {
      let t4 = "";
      if (e4.emitsRuntimeDecl) t4 = e4.getString(e4.emitsRuntimeDecl).trim();
      else if (e4.emitsTypeDecl) {
        const r4 = wc(e4);
        t4 = r4.size ? `[${Array.from(r4).map((e5) => JSON.stringify(e5)).join(", ")}]` : "";
      }
      if (e4.hasDefineModelCall) {
        let r4 = `[${Object.keys(e4.modelDecls).map((e5) => JSON.stringify(`update:${e5}`)).join(", ")}]`;
        t4 = t4 ? `/*#__PURE__*/${e4.helper("mergeModels")}(${t4}, ${r4})` : r4;
      }
      return t4;
    }(n3);
    q2 && ($2 += `
  emits: ${q2},`);
    let W2 = "";
    n3.optionsRuntimeDecl && (W2 = i3.content.slice(n3.optionsRuntimeDecl.start, n3.optionsRuntimeDecl.end).trim());
    const G2 = n3.hasDefineExposeCall || t3.inlineTemplate ? "" : "  __expose();\n";
    if (n3.isTS) {
      const e4 = (b2 ? `
  ...${ba},` : "") + (W2 ? `
  ...${W2},` : "");
      n3.s.prependLeft(S2, `
${F2} /*#__PURE__*/${n3.helper("defineComponent")}({${e4}${$2}
  ${v2 ? "async " : ""}setup(${M2}) {
${G2}`), n3.s.appendRight(x2, "})");
    } else b2 || W2 ? (n3.s.prependLeft(S2, `
${F2} /*#__PURE__*/Object.assign(${b2 ? `${ba}, ` : ""}${W2 ? `${W2}, ` : ""}{${$2}
  ${v2 ? "async " : ""}setup(${M2}) {
${G2}`), n3.s.appendRight(x2, "})")) : (n3.s.prependLeft(S2, `
${F2} {${$2}
  ${v2 ? "async " : ""}setup(${M2}) {
${G2}`), n3.s.appendRight(x2, "}"));
    return n3.helperImports.size > 0 && n3.s.prepend(`import { ${[...n3.helperImports].map((e4) => `${e4} as _${e4}`).join(", ")} } from 'vue'
`), { ...i3, bindings: n3.bindingMetadata, imports: n3.userImports, content: n3.s.toString(), map: false !== t3.sourceMap ? n3.s.generateMap({ source: l2, hires: true, includeContent: true }) : void 0, scriptAst: null == D2 ? void 0 : D2.body, scriptSetupAst: null == j2 ? void 0 : j2.body, deps: n3.deps ? [...n3.deps] : void 0 };
  }, t2.compileStyle = function(e3) {
    return ca({ ...e3, isAsync: false });
  }, t2.compileStyleAsync = function(e3) {
    return ca({ ...e3, isAsync: true });
  }, t2.compileTemplate = Ge, t2.errorMessages = $c, t2.extractRuntimeEmits = wc, t2.extractRuntimeProps = vc, t2.inferRuntimeType = lc, t2.invalidateTypeCache = function(e3) {
    e3 = B(e3), Yl.delete(e3), Kl.delete(e3);
    const t3 = Xl.get(e3);
    t3 && Kl.delete(t3);
  }, t2.parse = be, t2.parseCache = Uc, t2.registerTS = function(e3) {
    Wl = () => {
      try {
        return e3();
      } catch (e4) {
        throw "string" == typeof e4.message && e4.message.includes("Cannot find module") ? new Error('Failed to load TypeScript, which is required for resolving imported types. Please make sure "typescript" is installed as a project dependency.') : new Error("Failed to load TypeScript for resolving imported types.");
      }
    };
  }, t2.resolveTypeElements = _l, t2.rewriteDefault = function(e3, t3, r3) {
    const n3 = g.parse(e3, { sourceType: "module", plugins: ma("js", r3) }).program.body, s3 = new y(e3);
    return ya(n3, s3, t3), s3.toString();
  }, t2.rewriteDefaultAST = ya, t2.shouldTransformRef = () => false, t2.version = "3.4.15", t2.walk = Vc;
}, (e2, t2, r2) => {
  e2.exports = r2(502);
}, (e2, t2, r2) => {
  var n2 = r2(311), s2 = r2(314), i2 = r2(86);
  e2.exports = { formats: i2, parse: s2, stringify: n2 };
}, (e2, t2, r2) => {
  var n2 = r2(312), s2 = r2(144), i2 = r2(86), o2 = Object.prototype.hasOwnProperty, a2 = { brackets: function(e3) {
    return e3 + "[]";
  }, comma: "comma", indices: function(e3, t3) {
    return e3 + "[" + t3 + "]";
  }, repeat: function(e3) {
    return e3;
  } }, l = Array.isArray, c = Array.prototype.push, u = function(e3, t3) {
    c.apply(e3, l(t3) ? t3 : [t3]);
  }, p = Date.prototype.toISOString, d = i2.default, f = { addQueryPrefix: false, allowDots: false, charset: "utf-8", charsetSentinel: false, delimiter: "&", encode: true, encoder: s2.encode, encodeValuesOnly: false, format: d, formatter: i2.formatters[d], indices: false, serializeDate: function(e3) {
    return p.call(e3);
  }, skipNulls: false, strictNullHandling: false }, h = {}, m = function e3(t3, r3, i3, o3, a3, c2, p2, d2, m2, y, g, b, v, E, S, x) {
    for (var T, w = t3, P = x, A = 0, C = false; void 0 !== (P = P.get(h)) && !C; ) {
      var O = P.get(t3);
      if (A += 1, void 0 !== O) {
        if (O === A) throw new RangeError("Cyclic object value");
        C = true;
      }
      void 0 === P.get(h) && (A = 0);
    }
    if ("function" == typeof d2 ? w = d2(r3, w) : w instanceof Date ? w = g(w) : "comma" === i3 && l(w) && (w = s2.maybeMap(w, function(e4) {
      return e4 instanceof Date ? g(e4) : e4;
    })), null === w) {
      if (a3) return p2 && !E ? p2(r3, f.encoder, S, "key", b) : r3;
      w = "";
    }
    if ("string" == typeof (T = w) || "number" == typeof T || "boolean" == typeof T || "symbol" == typeof T || "bigint" == typeof T || s2.isBuffer(w)) return p2 ? [v(E ? r3 : p2(r3, f.encoder, S, "key", b)) + "=" + v(p2(w, f.encoder, S, "value", b))] : [v(r3) + "=" + v(String(w))];
    var I, _ = [];
    if (void 0 === w) return _;
    if ("comma" === i3 && l(w)) E && p2 && (w = s2.maybeMap(w, p2)), I = [{ value: w.length > 0 ? w.join(",") || null : void 0 }];
    else if (l(d2)) I = d2;
    else {
      var k = Object.keys(w);
      I = m2 ? k.sort(m2) : k;
    }
    for (var N = o3 && l(w) && 1 === w.length ? r3 + "[]" : r3, D = 0; D < I.length; ++D) {
      var j = I[D], L = "object" == typeof j && void 0 !== j.value ? j.value : w[j];
      if (!c2 || null !== L) {
        var M = l(w) ? "function" == typeof i3 ? i3(N, j) : N : N + (y ? "." + j : "[" + j + "]");
        x.set(t3, A);
        var B = n2();
        B.set(h, x), u(_, e3(L, M, i3, o3, a3, c2, "comma" === i3 && E && l(w) ? null : p2, d2, m2, y, g, b, v, E, S, B));
      }
    }
    return _;
  };
  e2.exports = function(e3, t3) {
    var r3, s3 = e3, c2 = function(e4) {
      if (!e4) return f;
      if (null !== e4.encoder && void 0 !== e4.encoder && "function" != typeof e4.encoder) throw new TypeError("Encoder has to be a function.");
      var t4 = e4.charset || f.charset;
      if (void 0 !== e4.charset && "utf-8" !== e4.charset && "iso-8859-1" !== e4.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      var r4 = i2.default;
      if (void 0 !== e4.format) {
        if (!o2.call(i2.formatters, e4.format)) throw new TypeError("Unknown format option provided.");
        r4 = e4.format;
      }
      var n3 = i2.formatters[r4], s4 = f.filter;
      return ("function" == typeof e4.filter || l(e4.filter)) && (s4 = e4.filter), { addQueryPrefix: "boolean" == typeof e4.addQueryPrefix ? e4.addQueryPrefix : f.addQueryPrefix, allowDots: void 0 === e4.allowDots ? f.allowDots : !!e4.allowDots, charset: t4, charsetSentinel: "boolean" == typeof e4.charsetSentinel ? e4.charsetSentinel : f.charsetSentinel, delimiter: void 0 === e4.delimiter ? f.delimiter : e4.delimiter, encode: "boolean" == typeof e4.encode ? e4.encode : f.encode, encoder: "function" == typeof e4.encoder ? e4.encoder : f.encoder, encodeValuesOnly: "boolean" == typeof e4.encodeValuesOnly ? e4.encodeValuesOnly : f.encodeValuesOnly, filter: s4, format: r4, formatter: n3, serializeDate: "function" == typeof e4.serializeDate ? e4.serializeDate : f.serializeDate, skipNulls: "boolean" == typeof e4.skipNulls ? e4.skipNulls : f.skipNulls, sort: "function" == typeof e4.sort ? e4.sort : null, strictNullHandling: "boolean" == typeof e4.strictNullHandling ? e4.strictNullHandling : f.strictNullHandling };
    }(t3);
    "function" == typeof c2.filter ? s3 = (0, c2.filter)("", s3) : l(c2.filter) && (r3 = c2.filter);
    var p2, d2 = [];
    if ("object" != typeof s3 || null === s3) return "";
    p2 = t3 && t3.arrayFormat in a2 ? t3.arrayFormat : t3 && "indices" in t3 ? t3.indices ? "indices" : "repeat" : "indices";
    var h2 = a2[p2];
    if (t3 && "commaRoundTrip" in t3 && "boolean" != typeof t3.commaRoundTrip) throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var y = "comma" === h2 && t3 && t3.commaRoundTrip;
    r3 || (r3 = Object.keys(s3)), c2.sort && r3.sort(c2.sort);
    for (var g = n2(), b = 0; b < r3.length; ++b) {
      var v = r3[b];
      c2.skipNulls && null === s3[v] || u(d2, m(s3[v], v, h2, y, c2.strictNullHandling, c2.skipNulls, c2.encode ? c2.encoder : null, c2.filter, c2.sort, c2.allowDots, c2.serializeDate, c2.format, c2.formatter, c2.encodeValuesOnly, c2.charset, g));
    }
    var E = d2.join(c2.delimiter), S = true === c2.addQueryPrefix ? "?" : "";
    return c2.charsetSentinel && ("iso-8859-1" === c2.charset ? S += "utf8=%26%2310003%3B&" : S += "utf8=%E2%9C%93&"), E.length > 0 ? S + E : "";
  };
}, (e2, t2, r2) => {
  var n2 = r2(22), s2 = r2(38), i2 = r2(313), o2 = n2("%TypeError%"), a2 = n2("%WeakMap%", true), l = n2("%Map%", true), c = s2("WeakMap.prototype.get", true), u = s2("WeakMap.prototype.set", true), p = s2("WeakMap.prototype.has", true), d = s2("Map.prototype.get", true), f = s2("Map.prototype.set", true), h = s2("Map.prototype.has", true), m = function(e3, t3) {
    for (var r3, n3 = e3; null !== (r3 = n3.next); n3 = r3) if (r3.key === t3) return n3.next = r3.next, r3.next = e3.next, e3.next = r3, r3;
  };
  e2.exports = function() {
    var e3, t3, r3, n3 = { assert: function(e4) {
      if (!n3.has(e4)) throw new o2("Side channel does not contain " + i2(e4));
    }, get: function(n4) {
      if (a2 && n4 && ("object" == typeof n4 || "function" == typeof n4)) {
        if (e3) return c(e3, n4);
      } else if (l) {
        if (t3) return d(t3, n4);
      } else if (r3) return function(e4, t4) {
        var r4 = m(e4, t4);
        return r4 && r4.value;
      }(r3, n4);
    }, has: function(n4) {
      if (a2 && n4 && ("object" == typeof n4 || "function" == typeof n4)) {
        if (e3) return p(e3, n4);
      } else if (l) {
        if (t3) return h(t3, n4);
      } else if (r3) return function(e4, t4) {
        return !!m(e4, t4);
      }(r3, n4);
      return false;
    }, set: function(n4, s3) {
      a2 && n4 && ("object" == typeof n4 || "function" == typeof n4) ? (e3 || (e3 = new a2()), u(e3, n4, s3)) : l ? (t3 || (t3 = new l()), f(t3, n4, s3)) : (r3 || (r3 = { key: {}, next: null }), function(e4, t4, r4) {
        var n5 = m(e4, t4);
        n5 ? n5.value = r4 : e4.next = { key: t4, next: e4.next, value: r4 };
      }(r3, n4, s3));
    } };
    return n3;
  };
}, (e2, t2, r2) => {
  var n2 = "function" == typeof Map && Map.prototype, s2 = Object.getOwnPropertyDescriptor && n2 ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, i2 = n2 && s2 && "function" == typeof s2.get ? s2.get : null, o2 = n2 && Map.prototype.forEach, a2 = "function" == typeof Set && Set.prototype, l = Object.getOwnPropertyDescriptor && a2 ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, c = a2 && l && "function" == typeof l.get ? l.get : null, u = a2 && Set.prototype.forEach, p = "function" == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null, d = "function" == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null, f = "function" == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null, h = Boolean.prototype.valueOf, m = Object.prototype.toString, y = Function.prototype.toString, g = String.prototype.match, b = String.prototype.slice, v = String.prototype.replace, E = String.prototype.toUpperCase, S = String.prototype.toLowerCase, x = RegExp.prototype.test, T = Array.prototype.concat, w = Array.prototype.join, P = Array.prototype.slice, A = Math.floor, C = "function" == typeof BigInt ? BigInt.prototype.valueOf : null, O = Object.getOwnPropertySymbols, I = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol.prototype.toString : null, _ = "function" == typeof Symbol && "object" == typeof Symbol.iterator, k = "function" == typeof Symbol && Symbol.toStringTag && (Symbol.toStringTag, 1) ? Symbol.toStringTag : null, N = Object.prototype.propertyIsEnumerable, D = ("function" == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e3) {
    return e3.__proto__;
  } : null);
  function j(e3, t3) {
    if (e3 === 1 / 0 || e3 === -1 / 0 || e3 != e3 || e3 && e3 > -1e3 && e3 < 1e3 || x.call(/e/, t3)) return t3;
    var r3 = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if ("number" == typeof e3) {
      var n3 = e3 < 0 ? -A(-e3) : A(e3);
      if (n3 !== e3) {
        var s3 = String(n3), i3 = b.call(t3, s3.length + 1);
        return v.call(s3, r3, "$&_") + "." + v.call(v.call(i3, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return v.call(t3, r3, "$&_");
  }
  var L = r2(509), M = L.custom, B = V(M) ? M : null;
  function R(e3, t3, r3) {
    var n3 = "double" === (r3.quoteStyle || t3) ? '"' : "'";
    return n3 + e3 + n3;
  }
  function F(e3) {
    return v.call(String(e3), /"/g, "&quot;");
  }
  function U(e3) {
    return !("[object Array]" !== G(e3) || k && "object" == typeof e3 && k in e3);
  }
  function $(e3) {
    return !("[object RegExp]" !== G(e3) || k && "object" == typeof e3 && k in e3);
  }
  function V(e3) {
    if (_) return e3 && "object" == typeof e3 && e3 instanceof Symbol;
    if ("symbol" == typeof e3) return true;
    if (!e3 || "object" != typeof e3 || !I) return false;
    try {
      return I.call(e3), true;
    } catch (e4) {
    }
    return false;
  }
  e2.exports = function e3(t3, n3, s3, a3) {
    var l2 = n3 || {};
    if (W(l2, "quoteStyle") && "single" !== l2.quoteStyle && "double" !== l2.quoteStyle) throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (W(l2, "maxStringLength") && ("number" == typeof l2.maxStringLength ? l2.maxStringLength < 0 && l2.maxStringLength !== 1 / 0 : null !== l2.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var m2 = !W(l2, "customInspect") || l2.customInspect;
    if ("boolean" != typeof m2 && "symbol" !== m2) throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (W(l2, "indent") && null !== l2.indent && "	" !== l2.indent && !(parseInt(l2.indent, 10) === l2.indent && l2.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (W(l2, "numericSeparator") && "boolean" != typeof l2.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var E2 = l2.numericSeparator;
    if (void 0 === t3) return "undefined";
    if (null === t3) return "null";
    if ("boolean" == typeof t3) return t3 ? "true" : "false";
    if ("string" == typeof t3) return z(t3, l2);
    if ("number" == typeof t3) {
      if (0 === t3) return 1 / 0 / t3 > 0 ? "0" : "-0";
      var x2 = String(t3);
      return E2 ? j(t3, x2) : x2;
    }
    if ("bigint" == typeof t3) {
      var A2 = String(t3) + "n";
      return E2 ? j(t3, A2) : A2;
    }
    var O2 = void 0 === l2.depth ? 5 : l2.depth;
    if (void 0 === s3 && (s3 = 0), s3 >= O2 && O2 > 0 && "object" == typeof t3) return U(t3) ? "[Array]" : "[Object]";
    var M2, q2 = function(e4, t4) {
      var r3;
      if ("	" === e4.indent) r3 = "	";
      else {
        if (!("number" == typeof e4.indent && e4.indent > 0)) return null;
        r3 = w.call(Array(e4.indent + 1), " ");
      }
      return { base: r3, prev: w.call(Array(t4 + 1), r3) };
    }(l2, s3);
    if (void 0 === a3) a3 = [];
    else if (H(a3, t3) >= 0) return "[Circular]";
    function K2(t4, r3, n4) {
      if (r3 && (a3 = P.call(a3)).push(r3), n4) {
        var i3 = { depth: l2.depth };
        return W(l2, "quoteStyle") && (i3.quoteStyle = l2.quoteStyle), e3(t4, i3, s3 + 1, a3);
      }
      return e3(t4, l2, s3 + 1, a3);
    }
    if ("function" == typeof t3 && !$(t3)) {
      var ee = function(e4) {
        if (e4.name) return e4.name;
        var t4 = g.call(y.call(e4), /^function\s*([\w$]+)/);
        return t4 ? t4[1] : null;
      }(t3), te = Z(t3, K2);
      return "[Function" + (ee ? ": " + ee : " (anonymous)") + "]" + (te.length > 0 ? " { " + w.call(te, ", ") + " }" : "");
    }
    if (V(t3)) {
      var re = _ ? v.call(String(t3), /^(Symbol\(.*\))_[^)]*$/, "$1") : I.call(t3);
      return "object" != typeof t3 || _ ? re : X(re);
    }
    if ((M2 = t3) && "object" == typeof M2 && ("undefined" != typeof HTMLElement && M2 instanceof HTMLElement || "string" == typeof M2.nodeName && "function" == typeof M2.getAttribute)) {
      for (var ne = "<" + S.call(String(t3.nodeName)), se = t3.attributes || [], ie = 0; ie < se.length; ie++) ne += " " + se[ie].name + "=" + R(F(se[ie].value), "double", l2);
      return ne += ">", t3.childNodes && t3.childNodes.length && (ne += "..."), ne + "</" + S.call(String(t3.nodeName)) + ">";
    }
    if (U(t3)) {
      if (0 === t3.length) return "[]";
      var oe = Z(t3, K2);
      return q2 && !function(e4) {
        for (var t4 = 0; t4 < e4.length; t4++) if (H(e4[t4], "\n") >= 0) return false;
        return true;
      }(oe) ? "[" + Q(oe, q2) + "]" : "[ " + w.call(oe, ", ") + " ]";
    }
    if (function(e4) {
      return !("[object Error]" !== G(e4) || k && "object" == typeof e4 && k in e4);
    }(t3)) {
      var ae = Z(t3, K2);
      return "cause" in Error.prototype || !("cause" in t3) || N.call(t3, "cause") ? 0 === ae.length ? "[" + String(t3) + "]" : "{ [" + String(t3) + "] " + w.call(ae, ", ") + " }" : "{ [" + String(t3) + "] " + w.call(T.call("[cause]: " + K2(t3.cause), ae), ", ") + " }";
    }
    if ("object" == typeof t3 && m2) {
      if (B && "function" == typeof t3[B] && L) return L(t3, { depth: O2 - s3 });
      if ("symbol" !== m2 && "function" == typeof t3.inspect) return t3.inspect();
    }
    if (function(e4) {
      if (!i2 || !e4 || "object" != typeof e4) return false;
      try {
        i2.call(e4);
        try {
          c.call(e4);
        } catch (e5) {
          return true;
        }
        return e4 instanceof Map;
      } catch (e5) {
      }
      return false;
    }(t3)) {
      var le = [];
      return o2 && o2.call(t3, function(e4, r3) {
        le.push(K2(r3, t3, true) + " => " + K2(e4, t3));
      }), Y("Map", i2.call(t3), le, q2);
    }
    if (function(e4) {
      if (!c || !e4 || "object" != typeof e4) return false;
      try {
        c.call(e4);
        try {
          i2.call(e4);
        } catch (e5) {
          return true;
        }
        return e4 instanceof Set;
      } catch (e5) {
      }
      return false;
    }(t3)) {
      var ce = [];
      return u && u.call(t3, function(e4) {
        ce.push(K2(e4, t3));
      }), Y("Set", c.call(t3), ce, q2);
    }
    if (function(e4) {
      if (!p || !e4 || "object" != typeof e4) return false;
      try {
        p.call(e4, p);
        try {
          d.call(e4, d);
        } catch (e5) {
          return true;
        }
        return e4 instanceof WeakMap;
      } catch (e5) {
      }
      return false;
    }(t3)) return J("WeakMap");
    if (function(e4) {
      if (!d || !e4 || "object" != typeof e4) return false;
      try {
        d.call(e4, d);
        try {
          p.call(e4, p);
        } catch (e5) {
          return true;
        }
        return e4 instanceof WeakSet;
      } catch (e5) {
      }
      return false;
    }(t3)) return J("WeakSet");
    if (function(e4) {
      if (!f || !e4 || "object" != typeof e4) return false;
      try {
        return f.call(e4), true;
      } catch (e5) {
      }
      return false;
    }(t3)) return J("WeakRef");
    if (function(e4) {
      return !("[object Number]" !== G(e4) || k && "object" == typeof e4 && k in e4);
    }(t3)) return X(K2(Number(t3)));
    if (function(e4) {
      if (!e4 || "object" != typeof e4 || !C) return false;
      try {
        return C.call(e4), true;
      } catch (e5) {
      }
      return false;
    }(t3)) return X(K2(C.call(t3)));
    if (function(e4) {
      return !("[object Boolean]" !== G(e4) || k && "object" == typeof e4 && k in e4);
    }(t3)) return X(h.call(t3));
    if (function(e4) {
      return !("[object String]" !== G(e4) || k && "object" == typeof e4 && k in e4);
    }(t3)) return X(K2(String(t3)));
    if ("undefined" != typeof window && t3 === window) return "{ [object Window] }";
    if (t3 === r2.g) return "{ [object globalThis] }";
    if (!function(e4) {
      return !("[object Date]" !== G(e4) || k && "object" == typeof e4 && k in e4);
    }(t3) && !$(t3)) {
      var ue = Z(t3, K2), pe = D ? D(t3) === Object.prototype : t3 instanceof Object || t3.constructor === Object, de = t3 instanceof Object ? "" : "null prototype", fe = !pe && k && Object(t3) === t3 && k in t3 ? b.call(G(t3), 8, -1) : de ? "Object" : "", he = (pe || "function" != typeof t3.constructor ? "" : t3.constructor.name ? t3.constructor.name + " " : "") + (fe || de ? "[" + w.call(T.call([], fe || [], de || []), ": ") + "] " : "");
      return 0 === ue.length ? he + "{}" : q2 ? he + "{" + Q(ue, q2) + "}" : he + "{ " + w.call(ue, ", ") + " }";
    }
    return String(t3);
  };
  var q = Object.prototype.hasOwnProperty || function(e3) {
    return e3 in this;
  };
  function W(e3, t3) {
    return q.call(e3, t3);
  }
  function G(e3) {
    return m.call(e3);
  }
  function H(e3, t3) {
    if (e3.indexOf) return e3.indexOf(t3);
    for (var r3 = 0, n3 = e3.length; r3 < n3; r3++) if (e3[r3] === t3) return r3;
    return -1;
  }
  function z(e3, t3) {
    if (e3.length > t3.maxStringLength) {
      var r3 = e3.length - t3.maxStringLength, n3 = "... " + r3 + " more character" + (r3 > 1 ? "s" : "");
      return z(b.call(e3, 0, t3.maxStringLength), t3) + n3;
    }
    return R(v.call(v.call(e3, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, K), "single", t3);
  }
  function K(e3) {
    var t3 = e3.charCodeAt(0), r3 = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[t3];
    return r3 ? "\\" + r3 : "\\x" + (t3 < 16 ? "0" : "") + E.call(t3.toString(16));
  }
  function X(e3) {
    return "Object(" + e3 + ")";
  }
  function J(e3) {
    return e3 + " { ? }";
  }
  function Y(e3, t3, r3, n3) {
    return e3 + " (" + t3 + ") {" + (n3 ? Q(r3, n3) : w.call(r3, ", ")) + "}";
  }
  function Q(e3, t3) {
    if (0 === e3.length) return "";
    var r3 = "\n" + t3.prev + t3.base;
    return r3 + w.call(e3, "," + r3) + "\n" + t3.prev;
  }
  function Z(e3, t3) {
    var r3 = U(e3), n3 = [];
    if (r3) {
      n3.length = e3.length;
      for (var s3 = 0; s3 < e3.length; s3++) n3[s3] = W(e3, s3) ? t3(e3[s3], e3) : "";
    }
    var i3, o3 = "function" == typeof O ? O(e3) : [];
    if (_) {
      i3 = {};
      for (var a3 = 0; a3 < o3.length; a3++) i3["$" + o3[a3]] = o3[a3];
    }
    for (var l2 in e3) W(e3, l2) && (r3 && String(Number(l2)) === l2 && l2 < e3.length || _ && i3["$" + l2] instanceof Symbol || (x.call(/[^\w$]/, l2) ? n3.push(t3(l2, e3) + ": " + t3(e3[l2], e3)) : n3.push(l2 + ": " + t3(e3[l2], e3))));
    if ("function" == typeof O) for (var c2 = 0; c2 < o3.length; c2++) N.call(e3, o3[c2]) && n3.push("[" + t3(o3[c2]) + "]: " + t3(e3[o3[c2]], e3));
    return n3;
  }
}, (e2, t2, r2) => {
  var n2 = r2(144), s2 = Object.prototype.hasOwnProperty, i2 = Array.isArray, o2 = { allowDots: false, allowPrototypes: false, allowSparse: false, arrayLimit: 20, charset: "utf-8", charsetSentinel: false, comma: false, decoder: n2.decode, delimiter: "&", depth: 5, ignoreQueryPrefix: false, interpretNumericEntities: false, parameterLimit: 1e3, parseArrays: true, plainObjects: false, strictNullHandling: false }, a2 = function(e3) {
    return e3.replace(/&#(\d+);/g, function(e4, t3) {
      return String.fromCharCode(parseInt(t3, 10));
    });
  }, l = function(e3, t3) {
    return e3 && "string" == typeof e3 && t3.comma && e3.indexOf(",") > -1 ? e3.split(",") : e3;
  }, c = function(e3, t3, r3, n3) {
    if (e3) {
      var i3 = r3.allowDots ? e3.replace(/\.([^.[]+)/g, "[$1]") : e3, o3 = /(\[[^[\]]*])/g, a3 = r3.depth > 0 && /(\[[^[\]]*])/.exec(i3), c2 = a3 ? i3.slice(0, a3.index) : i3, u = [];
      if (c2) {
        if (!r3.plainObjects && s2.call(Object.prototype, c2) && !r3.allowPrototypes) return;
        u.push(c2);
      }
      for (var p = 0; r3.depth > 0 && null !== (a3 = o3.exec(i3)) && p < r3.depth; ) {
        if (p += 1, !r3.plainObjects && s2.call(Object.prototype, a3[1].slice(1, -1)) && !r3.allowPrototypes) return;
        u.push(a3[1]);
      }
      return a3 && u.push("[" + i3.slice(a3.index) + "]"), function(e4, t4, r4, n4) {
        for (var s3 = n4 ? t4 : l(t4, r4), i4 = e4.length - 1; i4 >= 0; --i4) {
          var o4, a4 = e4[i4];
          if ("[]" === a4 && r4.parseArrays) o4 = [].concat(s3);
          else {
            o4 = r4.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
            var c3 = "[" === a4.charAt(0) && "]" === a4.charAt(a4.length - 1) ? a4.slice(1, -1) : a4, u2 = parseInt(c3, 10);
            r4.parseArrays || "" !== c3 ? !isNaN(u2) && a4 !== c3 && String(u2) === c3 && u2 >= 0 && r4.parseArrays && u2 <= r4.arrayLimit ? (o4 = [])[u2] = s3 : "__proto__" !== c3 && (o4[c3] = s3) : o4 = { 0: s3 };
          }
          s3 = o4;
        }
        return s3;
      }(u, t3, r3, n3);
    }
  };
  e2.exports = function(e3, t3) {
    var r3 = function(e4) {
      if (!e4) return o2;
      if (null !== e4.decoder && void 0 !== e4.decoder && "function" != typeof e4.decoder) throw new TypeError("Decoder has to be a function.");
      if (void 0 !== e4.charset && "utf-8" !== e4.charset && "iso-8859-1" !== e4.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      var t4 = void 0 === e4.charset ? o2.charset : e4.charset;
      return { allowDots: void 0 === e4.allowDots ? o2.allowDots : !!e4.allowDots, allowPrototypes: "boolean" == typeof e4.allowPrototypes ? e4.allowPrototypes : o2.allowPrototypes, allowSparse: "boolean" == typeof e4.allowSparse ? e4.allowSparse : o2.allowSparse, arrayLimit: "number" == typeof e4.arrayLimit ? e4.arrayLimit : o2.arrayLimit, charset: t4, charsetSentinel: "boolean" == typeof e4.charsetSentinel ? e4.charsetSentinel : o2.charsetSentinel, comma: "boolean" == typeof e4.comma ? e4.comma : o2.comma, decoder: "function" == typeof e4.decoder ? e4.decoder : o2.decoder, delimiter: "string" == typeof e4.delimiter || n2.isRegExp(e4.delimiter) ? e4.delimiter : o2.delimiter, depth: "number" == typeof e4.depth || false === e4.depth ? +e4.depth : o2.depth, ignoreQueryPrefix: true === e4.ignoreQueryPrefix, interpretNumericEntities: "boolean" == typeof e4.interpretNumericEntities ? e4.interpretNumericEntities : o2.interpretNumericEntities, parameterLimit: "number" == typeof e4.parameterLimit ? e4.parameterLimit : o2.parameterLimit, parseArrays: false !== e4.parseArrays, plainObjects: "boolean" == typeof e4.plainObjects ? e4.plainObjects : o2.plainObjects, strictNullHandling: "boolean" == typeof e4.strictNullHandling ? e4.strictNullHandling : o2.strictNullHandling };
    }(t3);
    if ("" === e3 || null == e3) return r3.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    for (var u = "string" == typeof e3 ? function(e4, t4) {
      var r4, c2 = { __proto__: null }, u2 = t4.ignoreQueryPrefix ? e4.replace(/^\?/, "") : e4, p2 = t4.parameterLimit === 1 / 0 ? void 0 : t4.parameterLimit, d2 = u2.split(t4.delimiter, p2), f2 = -1, h2 = t4.charset;
      if (t4.charsetSentinel) for (r4 = 0; r4 < d2.length; ++r4) 0 === d2[r4].indexOf("utf8=") && ("utf8=%E2%9C%93" === d2[r4] ? h2 = "utf-8" : "utf8=%26%2310003%3B" === d2[r4] && (h2 = "iso-8859-1"), f2 = r4, r4 = d2.length);
      for (r4 = 0; r4 < d2.length; ++r4) if (r4 !== f2) {
        var m2, y, g = d2[r4], b = g.indexOf("]="), v = -1 === b ? g.indexOf("=") : b + 1;
        -1 === v ? (m2 = t4.decoder(g, o2.decoder, h2, "key"), y = t4.strictNullHandling ? null : "") : (m2 = t4.decoder(g.slice(0, v), o2.decoder, h2, "key"), y = n2.maybeMap(l(g.slice(v + 1), t4), function(e5) {
          return t4.decoder(e5, o2.decoder, h2, "value");
        })), y && t4.interpretNumericEntities && "iso-8859-1" === h2 && (y = a2(y)), g.indexOf("[]=") > -1 && (y = i2(y) ? [y] : y), s2.call(c2, m2) ? c2[m2] = n2.combine(c2[m2], y) : c2[m2] = y;
      }
      return c2;
    }(e3, r3) : e3, p = r3.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, d = Object.keys(u), f = 0; f < d.length; ++f) {
      var h = d[f], m = c(h, u[h], r3, "string" == typeof e3);
      p = n2.merge(p, m, r3);
    }
    return true === r3.allowSparse ? p : n2.compact(p);
  };
}, (e2, t2, r2) => {
  let n2 = r2(87), s2 = r2(52), i2 = r2(147), o2 = r2(24), a2 = r2(322), l = r2(54), c = r2(324), u = r2(88), p = r2(153), d = r2(56), f = r2(91), h = r2(89), m = r2(55), y = r2(90), g = r2(154), b = r2(92), v = r2(40), E = r2(53);
  function S() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    return 1 === t3.length && Array.isArray(t3[0]) && (t3 = t3[0]), new a2(t3);
  }
  S.plugin = function(e3, t3) {
    let r3, n3 = false;
    function s3() {
      console && console.warn && !n3 && (n3 = true);
      let r4 = t3(...arguments);
      return r4.postcssPlugin = e3, r4.postcssVersion = new a2().version, r4;
    }
    return Object.defineProperty(s3, "postcss", { get: () => (r3 || (r3 = s3()), r3) }), s3.process = function(e4, t4, r4) {
      return S([s3(r4)]).process(e4, t4);
    }, s3;
  }, S.stringify = l, S.parse = y, S.fromJSON = c, S.list = g, S.comment = (e3) => new d(e3), S.atRule = (e3) => new f(e3), S.decl = (e3) => new s2(e3), S.rule = (e3) => new b(e3), S.root = (e3) => new v(e3), S.document = (e3) => new u(e3), S.CssSyntaxError = n2, S.Declaration = s2, S.Container = o2, S.Processor = a2, S.Document = u, S.Comment = d, S.Warning = p, S.AtRule = f, S.Result = h, S.Input = m, S.Rule = b, S.Root = v, S.Node = E, i2.registerPostcss(S), e2.exports = S, S.default = S;
}, (e2) => {
  var t2 = String, r2 = function() {
    return { isColorSupported: false, reset: t2, bold: t2, dim: t2, italic: t2, underline: t2, inverse: t2, hidden: t2, strikethrough: t2, black: t2, red: t2, green: t2, yellow: t2, blue: t2, magenta: t2, cyan: t2, white: t2, gray: t2, bgBlack: t2, bgRed: t2, bgGreen: t2, bgYellow: t2, bgBlue: t2, bgMagenta: t2, bgCyan: t2, bgWhite: t2 };
  };
  e2.exports = r2(), e2.exports.createColors = r2;
}, () => {
}, () => {
}, (e2) => {
  e2.exports = { nanoid: function() {
    let e3 = "", t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 21;
    for (; t2--; ) e3 += "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"[64 * Math.random() | 0];
    return e3;
  }, customAlphabet: function(e3) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 21;
    return function() {
      let r2 = "", n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : t2;
      for (; n2--; ) r2 += e3[Math.random() * e3.length | 0];
      return r2;
    };
  } };
}, (e2, t2, r2) => {
  let n2 = r2(52), s2 = r2(321), i2 = r2(56), o2 = r2(91), a2 = r2(40), l = r2(92);
  const c = { empty: true, space: true };
  e2.exports = class {
    constructor(e3) {
      this.input = e3, this.root = new a2(), this.current = this.root, this.spaces = "", this.semicolon = false, this.customProperty = false, this.createTokenizer(), this.root.source = { input: e3, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(e3) {
      let t3, r3, n3, s3 = new o2();
      s3.name = e3[1].slice(1), "" === s3.name && this.unnamedAtrule(s3, e3), this.init(s3, e3[2]);
      let i3 = false, a3 = false, l2 = [], c2 = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (t3 = (e3 = this.tokenizer.nextToken())[0], "(" === t3 || "[" === t3 ? c2.push("(" === t3 ? ")" : "]") : "{" === t3 && c2.length > 0 ? c2.push("}") : t3 === c2[c2.length - 1] && c2.pop(), 0 === c2.length) {
          if (";" === t3) {
            s3.source.end = this.getPosition(e3[2]), s3.source.end.offset++, this.semicolon = true;
            break;
          }
          if ("{" === t3) {
            a3 = true;
            break;
          }
          if ("}" === t3) {
            if (l2.length > 0) {
              for (n3 = l2.length - 1, r3 = l2[n3]; r3 && "space" === r3[0]; ) r3 = l2[--n3];
              r3 && (s3.source.end = this.getPosition(r3[3] || r3[2]), s3.source.end.offset++);
            }
            this.end(e3);
            break;
          }
          l2.push(e3);
        } else l2.push(e3);
        if (this.tokenizer.endOfFile()) {
          i3 = true;
          break;
        }
      }
      s3.raws.between = this.spacesAndCommentsFromEnd(l2), l2.length ? (s3.raws.afterName = this.spacesAndCommentsFromStart(l2), this.raw(s3, "params", l2), i3 && (e3 = l2[l2.length - 1], s3.source.end = this.getPosition(e3[3] || e3[2]), s3.source.end.offset++, this.spaces = s3.raws.between, s3.raws.between = "")) : (s3.raws.afterName = "", s3.params = ""), a3 && (s3.nodes = [], this.current = s3);
    }
    checkMissedSemicolon(e3) {
      let t3 = this.colon(e3);
      if (false === t3) return;
      let r3, n3 = 0;
      for (let s3 = t3 - 1; s3 >= 0 && (r3 = e3[s3], "space" === r3[0] || (n3 += 1, 2 !== n3)); s3--) ;
      throw this.input.error("Missed semicolon", "word" === r3[0] ? r3[3] + 1 : r3[2]);
    }
    colon(e3) {
      let t3, r3, n3, s3 = 0;
      for (let [i3, o3] of e3.entries()) {
        if (t3 = o3, r3 = t3[0], "(" === r3 && (s3 += 1), ")" === r3 && (s3 -= 1), 0 === s3 && ":" === r3) {
          if (n3) {
            if ("word" === n3[0] && "progid" === n3[1]) continue;
            return i3;
          }
          this.doubleColon(t3);
        }
        n3 = t3;
      }
      return false;
    }
    comment(e3) {
      let t3 = new i2();
      this.init(t3, e3[2]), t3.source.end = this.getPosition(e3[3] || e3[2]), t3.source.end.offset++;
      let r3 = e3[1].slice(2, -2);
      if (/^\s*$/.test(r3)) t3.text = "", t3.raws.left = r3, t3.raws.right = "";
      else {
        let e4 = r3.match(/^(\s*)([^]*\S)(\s*)$/);
        t3.text = e4[2], t3.raws.left = e4[1], t3.raws.right = e4[3];
      }
    }
    createTokenizer() {
      this.tokenizer = s2(this.input);
    }
    decl(e3, t3) {
      let r3 = new n2();
      this.init(r3, e3[0][2]);
      let s3, i3 = e3[e3.length - 1];
      for (";" === i3[0] && (this.semicolon = true, e3.pop()), r3.source.end = this.getPosition(i3[3] || i3[2] || function(e4) {
        for (let t4 = e4.length - 1; t4 >= 0; t4--) {
          let r4 = e4[t4], n3 = r4[3] || r4[2];
          if (n3) return n3;
        }
      }(e3)), r3.source.end.offset++; "word" !== e3[0][0]; ) 1 === e3.length && this.unknownWord(e3), r3.raws.before += e3.shift()[1];
      for (r3.source.start = this.getPosition(e3[0][2]), r3.prop = ""; e3.length; ) {
        let t4 = e3[0][0];
        if (":" === t4 || "space" === t4 || "comment" === t4) break;
        r3.prop += e3.shift()[1];
      }
      for (r3.raws.between = ""; e3.length; ) {
        if (s3 = e3.shift(), ":" === s3[0]) {
          r3.raws.between += s3[1];
          break;
        }
        "word" === s3[0] && /\w/.test(s3[1]) && this.unknownWord([s3]), r3.raws.between += s3[1];
      }
      "_" !== r3.prop[0] && "*" !== r3.prop[0] || (r3.raws.before += r3.prop[0], r3.prop = r3.prop.slice(1));
      let o3, a3 = [];
      for (; e3.length && (o3 = e3[0][0], "space" === o3 || "comment" === o3); ) a3.push(e3.shift());
      this.precheckMissedSemicolon(e3);
      for (let t4 = e3.length - 1; t4 >= 0; t4--) {
        if (s3 = e3[t4], "!important" === s3[1].toLowerCase()) {
          r3.important = true;
          let n3 = this.stringFrom(e3, t4);
          n3 = this.spacesFromEnd(e3) + n3, " !important" !== n3 && (r3.raws.important = n3);
          break;
        }
        if ("important" === s3[1].toLowerCase()) {
          let n3 = e3.slice(0), s4 = "";
          for (let e4 = t4; e4 > 0; e4--) {
            let t5 = n3[e4][0];
            if (0 === s4.trim().indexOf("!") && "space" !== t5) break;
            s4 = n3.pop()[1] + s4;
          }
          0 === s4.trim().indexOf("!") && (r3.important = true, r3.raws.important = s4, e3 = n3);
        }
        if ("space" !== s3[0] && "comment" !== s3[0]) break;
      }
      e3.some((e4) => "space" !== e4[0] && "comment" !== e4[0]) && (r3.raws.between += a3.map((e4) => e4[1]).join(""), a3 = []), this.raw(r3, "value", a3.concat(e3), t3), r3.value.includes(":") && !t3 && this.checkMissedSemicolon(e3);
    }
    doubleColon(e3) {
      throw this.input.error("Double colon", { offset: e3[2] }, { offset: e3[2] + e3[1].length });
    }
    emptyRule(e3) {
      let t3 = new l();
      this.init(t3, e3[2]), t3.selector = "", t3.raws.between = "", this.current = t3;
    }
    end(e3) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e3[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e3);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(e3) {
      if (this.spaces += e3[1], this.current.nodes) {
        let e4 = this.current.nodes[this.current.nodes.length - 1];
        e4 && "rule" === e4.type && !e4.raws.ownSemicolon && (e4.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }
    getPosition(e3) {
      let t3 = this.input.fromOffset(e3);
      return { column: t3.col, line: t3.line, offset: e3 };
    }
    init(e3, t3) {
      this.current.push(e3), e3.source = { input: this.input, start: this.getPosition(t3) }, e3.raws.before = this.spaces, this.spaces = "", "comment" !== e3.type && (this.semicolon = false);
    }
    other(e3) {
      let t3 = false, r3 = null, n3 = false, s3 = null, i3 = [], o3 = e3[1].startsWith("--"), a3 = [], l2 = e3;
      for (; l2; ) {
        if (r3 = l2[0], a3.push(l2), "(" === r3 || "[" === r3) s3 || (s3 = l2), i3.push("(" === r3 ? ")" : "]");
        else if (o3 && n3 && "{" === r3) s3 || (s3 = l2), i3.push("}");
        else if (0 === i3.length) {
          if (";" === r3) {
            if (n3) return void this.decl(a3, o3);
            break;
          }
          if ("{" === r3) return void this.rule(a3);
          if ("}" === r3) {
            this.tokenizer.back(a3.pop()), t3 = true;
            break;
          }
          ":" === r3 && (n3 = true);
        } else r3 === i3[i3.length - 1] && (i3.pop(), 0 === i3.length && (s3 = null));
        l2 = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (t3 = true), i3.length > 0 && this.unclosedBracket(s3), t3 && n3) {
        if (!o3) for (; a3.length && (l2 = a3[a3.length - 1][0], "space" === l2 || "comment" === l2); ) this.tokenizer.back(a3.pop());
        this.decl(a3, o3);
      } else this.unknownWord(a3);
    }
    parse() {
      let e3;
      for (; !this.tokenizer.endOfFile(); ) switch (e3 = this.tokenizer.nextToken(), e3[0]) {
        case "space":
          this.spaces += e3[1];
          break;
        case ";":
          this.freeSemicolon(e3);
          break;
        case "}":
          this.end(e3);
          break;
        case "comment":
          this.comment(e3);
          break;
        case "at-word":
          this.atrule(e3);
          break;
        case "{":
          this.emptyRule(e3);
          break;
        default:
          this.other(e3);
      }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(e3, t3, r3, n3) {
      let s3, i3, o3, a3, l2 = r3.length, u = "", p = true;
      for (let e4 = 0; e4 < l2; e4 += 1) s3 = r3[e4], i3 = s3[0], "space" !== i3 || e4 !== l2 - 1 || n3 ? "comment" === i3 ? (a3 = r3[e4 - 1] ? r3[e4 - 1][0] : "empty", o3 = r3[e4 + 1] ? r3[e4 + 1][0] : "empty", c[a3] || c[o3] || "," === u.slice(-1) ? p = false : u += s3[1]) : u += s3[1] : p = false;
      if (!p) {
        let n4 = r3.reduce((e4, t4) => e4 + t4[1], "");
        e3.raws[t3] = { raw: n4, value: u };
      }
      e3[t3] = u;
    }
    rule(e3) {
      e3.pop();
      let t3 = new l();
      this.init(t3, e3[0][2]), t3.raws.between = this.spacesAndCommentsFromEnd(e3), this.raw(t3, "selector", e3), this.current = t3;
    }
    spacesAndCommentsFromEnd(e3) {
      let t3, r3 = "";
      for (; e3.length && (t3 = e3[e3.length - 1][0], "space" === t3 || "comment" === t3); ) r3 = e3.pop()[1] + r3;
      return r3;
    }
    spacesAndCommentsFromStart(e3) {
      let t3, r3 = "";
      for (; e3.length && (t3 = e3[0][0], "space" === t3 || "comment" === t3); ) r3 += e3.shift()[1];
      return r3;
    }
    spacesFromEnd(e3) {
      let t3, r3 = "";
      for (; e3.length && (t3 = e3[e3.length - 1][0], "space" === t3); ) r3 = e3.pop()[1] + r3;
      return r3;
    }
    stringFrom(e3, t3) {
      let r3 = "";
      for (let n3 = t3; n3 < e3.length; n3++) r3 += e3[n3][1];
      return e3.splice(t3, e3.length - t3), r3;
    }
    unclosedBlock() {
      let e3 = this.current.source.start;
      throw this.input.error("Unclosed block", e3.line, e3.column);
    }
    unclosedBracket(e3) {
      throw this.input.error("Unclosed bracket", { offset: e3[2] }, { offset: e3[2] + 1 });
    }
    unexpectedClose(e3) {
      throw this.input.error("Unexpected }", { offset: e3[2] }, { offset: e3[2] + 1 });
    }
    unknownWord(e3) {
      throw this.input.error("Unknown word", { offset: e3[0][2] }, { offset: e3[0][2] + e3[0][1].length });
    }
    unnamedAtrule(e3, t3) {
      throw this.input.error("At-rule without name", { offset: t3[2] }, { offset: t3[2] + t3[1].length });
    }
  };
}, (e2) => {
  const t2 = "'".charCodeAt(0), r2 = '"'.charCodeAt(0), n2 = "\\".charCodeAt(0), s2 = "/".charCodeAt(0), i2 = "\n".charCodeAt(0), o2 = " ".charCodeAt(0), a2 = "\f".charCodeAt(0), l = "	".charCodeAt(0), c = "\r".charCodeAt(0), u = "[".charCodeAt(0), p = "]".charCodeAt(0), d = "(".charCodeAt(0), f = ")".charCodeAt(0), h = "{".charCodeAt(0), m = "}".charCodeAt(0), y = ";".charCodeAt(0), g = "*".charCodeAt(0), b = ":".charCodeAt(0), v = "@".charCodeAt(0), E = /[\t\n\f\r "#'()/;[\\\]{}]/g, S = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, x = /.[\r\n"'(/\\]/, T = /[\da-f]/i;
  e2.exports = function(e3) {
    let w, P, A, C, O, I, _, k, N, D, j = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, L = e3.css.valueOf(), M = j.ignoreErrors, B = L.length, R = 0, F = [], U = [];
    function $(t3) {
      throw e3.error("Unclosed " + t3, R);
    }
    return { back: function(e4) {
      U.push(e4);
    }, endOfFile: function() {
      return 0 === U.length && R >= B;
    }, nextToken: function(e4) {
      if (U.length) return U.pop();
      if (R >= B) return;
      let j2 = !!e4 && e4.ignoreUnclosed;
      switch (w = L.charCodeAt(R), w) {
        case i2:
        case o2:
        case l:
        case c:
        case a2:
          P = R;
          do {
            P += 1, w = L.charCodeAt(P);
          } while (w === o2 || w === i2 || w === l || w === c || w === a2);
          D = ["space", L.slice(R, P)], R = P - 1;
          break;
        case u:
        case p:
        case h:
        case m:
        case b:
        case y:
        case f: {
          let e5 = String.fromCharCode(w);
          D = [e5, e5, R];
          break;
        }
        case d:
          if (k = F.length ? F.pop()[1] : "", N = L.charCodeAt(R + 1), "url" === k && N !== t2 && N !== r2 && N !== o2 && N !== i2 && N !== l && N !== a2 && N !== c) {
            P = R;
            do {
              if (I = false, P = L.indexOf(")", P + 1), -1 === P) {
                if (M || j2) {
                  P = R;
                  break;
                }
                $("bracket");
              }
              for (_ = P; L.charCodeAt(_ - 1) === n2; ) _ -= 1, I = !I;
            } while (I);
            D = ["brackets", L.slice(R, P + 1), R, P], R = P;
          } else P = L.indexOf(")", R + 1), C = L.slice(R, P + 1), -1 === P || x.test(C) ? D = ["(", "(", R] : (D = ["brackets", C, R, P], R = P);
          break;
        case t2:
        case r2:
          A = w === t2 ? "'" : '"', P = R;
          do {
            if (I = false, P = L.indexOf(A, P + 1), -1 === P) {
              if (M || j2) {
                P = R + 1;
                break;
              }
              $("string");
            }
            for (_ = P; L.charCodeAt(_ - 1) === n2; ) _ -= 1, I = !I;
          } while (I);
          D = ["string", L.slice(R, P + 1), R, P], R = P;
          break;
        case v:
          E.lastIndex = R + 1, E.test(L), P = 0 === E.lastIndex ? L.length - 1 : E.lastIndex - 2, D = ["at-word", L.slice(R, P + 1), R, P], R = P;
          break;
        case n2:
          for (P = R, O = true; L.charCodeAt(P + 1) === n2; ) P += 1, O = !O;
          if (w = L.charCodeAt(P + 1), O && w !== s2 && w !== o2 && w !== i2 && w !== l && w !== c && w !== a2 && (P += 1, T.test(L.charAt(P)))) {
            for (; T.test(L.charAt(P + 1)); ) P += 1;
            L.charCodeAt(P + 1) === o2 && (P += 1);
          }
          D = ["word", L.slice(R, P + 1), R, P], R = P;
          break;
        default:
          w === s2 && L.charCodeAt(R + 1) === g ? (P = L.indexOf("*/", R + 2) + 1, 0 === P && (M || j2 ? P = L.length : $("comment")), D = ["comment", L.slice(R, P + 1), R, P], R = P) : (S.lastIndex = R + 1, S.test(L), P = 0 === S.lastIndex ? L.length - 1 : S.lastIndex - 2, D = ["word", L.slice(R, P + 1), R, P], F.push(D), R = P);
      }
      return R++, D;
    }, position: function() {
      return R;
    } };
  };
}, (e2, t2, r2) => {
  let n2 = r2(323), s2 = r2(147), i2 = r2(88), o2 = r2(40);
  class a2 {
    constructor() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      this.version = "8.4.33", this.plugins = this.normalize(e3);
    }
    normalize(e3) {
      let t3 = [];
      for (let r3 of e3) if (true === r3.postcss ? r3 = r3() : r3.postcss && (r3 = r3.postcss), "object" == typeof r3 && Array.isArray(r3.plugins)) t3 = t3.concat(r3.plugins);
      else if ("object" == typeof r3 && r3.postcssPlugin) t3.push(r3);
      else if ("function" == typeof r3) t3.push(r3);
      else if ("object" != typeof r3 || !r3.parse && !r3.stringify) throw new Error(r3 + " is not a PostCSS plugin");
      return t3;
    }
    process(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return this.plugins.length || t3.parser || t3.stringifier || t3.syntax ? new s2(this, e3, t3) : new n2(this, e3, t3);
    }
    use(e3) {
      return this.plugins = this.plugins.concat(this.normalize([e3])), this;
    }
  }
  e2.exports = a2, a2.default = a2, o2.registerProcessor(a2), i2.registerProcessor(a2);
}, (e2, t2, r2) => {
  let n2 = r2(148), s2 = r2(54), i2 = (r2(152), r2(90));
  const o2 = r2(89);
  class a2 {
    constructor(e3, t3, r3) {
      let i3;
      t3 = t3.toString(), this.stringified = false, this._processor = e3, this._css = t3, this._opts = r3, this._map = void 0;
      let a3 = s2;
      this.result = new o2(this._processor, i3, this._opts), this.result.css = t3;
      let l = this;
      Object.defineProperty(this.result, "root", { get: () => l.root });
      let c = new n2(a3, i3, this._opts, t3);
      if (c.isMap()) {
        let [e4, t4] = c.generate();
        e4 && (this.result.css = e4), t4 && (this.result.map = t4);
      } else c.clearAnnotation(), this.result.css = c.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(e3) {
      return this.async().catch(e3);
    }
    finally(e3) {
      return this.async().then(e3, e3);
    }
    sync() {
      if (this.error) throw this.error;
      return this.result;
    }
    then(e3, t3) {
      return this.async().then(e3, t3);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root) return this._root;
      let e3, t3 = i2;
      try {
        e3 = t3(this._css, this._opts);
      } catch (e4) {
        this.error = e4;
      }
      if (this.error) throw this.error;
      return this._root = e3, e3;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
  }
  e2.exports = a2, a2.default = a2;
}, (e2, t2, r2) => {
  let n2 = r2(52), s2 = r2(151), i2 = r2(56), o2 = r2(91), a2 = r2(55), l = r2(40), c = r2(92);
  function u(e3, t3) {
    if (Array.isArray(e3)) return e3.map((e4) => u(e4));
    let { inputs: r3, ...p } = e3;
    if (r3) {
      t3 = [];
      for (let e4 of r3) {
        let r4 = { ...e4, __proto__: a2.prototype };
        r4.map && (r4.map = { ...r4.map, __proto__: s2.prototype }), t3.push(r4);
      }
    }
    if (p.nodes && (p.nodes = e3.nodes.map((e4) => u(e4, t3))), p.source) {
      let { inputId: e4, ...r4 } = p.source;
      p.source = r4, null != e4 && (p.source.input = t3[e4]);
    }
    if ("root" === p.type) return new l(p);
    if ("decl" === p.type) return new n2(p);
    if ("rule" === p.type) return new c(p);
    if ("comment" === p.type) return new i2(p);
    if ("atrule" === p.type) return new o2(p);
    throw new Error("Unknown node type: " + e3.type);
  }
  e2.exports = u, u.default = u;
}, (e2, t2, r2) => {
  var n2 = r2(31).a, s2 = r2(513);
  class i2 {
    constructor(e3) {
      this.bits = e3 instanceof i2 ? e3.bits.slice() : [];
    }
    add(e3) {
      this.bits[e3 >> 5] |= 1 << (31 & e3);
    }
    has(e3) {
      return !!(this.bits[e3 >> 5] & 1 << (31 & e3));
    }
  }
  class o2 {
    constructor(e3, t3, r3) {
      this.start = e3, this.end = t3, this.original = r3, this.intro = "", this.outro = "", this.content = r3, this.storeName = false, this.edited = false, this.previous = null, this.next = null;
    }
    appendLeft(e3) {
      this.outro += e3;
    }
    appendRight(e3) {
      this.intro = this.intro + e3;
    }
    clone() {
      const e3 = new o2(this.start, this.end, this.original);
      return e3.intro = this.intro, e3.outro = this.outro, e3.content = this.content, e3.storeName = this.storeName, e3.edited = this.edited, e3;
    }
    contains(e3) {
      return this.start < e3 && e3 < this.end;
    }
    eachNext(e3) {
      let t3 = this;
      for (; t3; ) e3(t3), t3 = t3.next;
    }
    eachPrevious(e3) {
      let t3 = this;
      for (; t3; ) e3(t3), t3 = t3.previous;
    }
    edit(e3, t3, r3) {
      return this.content = e3, r3 || (this.intro = "", this.outro = ""), this.storeName = t3, this.edited = true, this;
    }
    prependLeft(e3) {
      this.outro = e3 + this.outro;
    }
    prependRight(e3) {
      this.intro = e3 + this.intro;
    }
    split(e3) {
      const t3 = e3 - this.start, r3 = this.original.slice(0, t3), n3 = this.original.slice(t3);
      this.original = r3;
      const s3 = new o2(e3, this.end, n3);
      return s3.outro = this.outro, this.outro = "", this.end = e3, this.edited ? (s3.edit("", false), this.content = "") : this.content = r3, s3.next = this.next, s3.next && (s3.next.previous = s3), s3.previous = this, this.next = s3, s3;
    }
    toString() {
      return this.intro + this.content + this.outro;
    }
    trimEnd(e3) {
      if (this.outro = this.outro.replace(e3, ""), this.outro.length) return true;
      const t3 = this.content.replace(e3, "");
      return t3.length ? (t3 !== this.content && (this.split(this.start + t3.length).edit("", void 0, true), this.edited && this.edit(t3, this.storeName, true)), true) : (this.edit("", void 0, true), this.intro = this.intro.replace(e3, ""), !!this.intro.length || void 0);
    }
    trimStart(e3) {
      if (this.intro = this.intro.replace(e3, ""), this.intro.length) return true;
      const t3 = this.content.replace(e3, "");
      if (t3.length) {
        if (t3 !== this.content) {
          const e4 = this.split(this.end - t3.length);
          this.edited && e4.edit(t3, this.storeName, true), this.edit("", void 0, true);
        }
        return true;
      }
      return this.edit("", void 0, true), this.outro = this.outro.replace(e3, ""), !!this.outro.length || void 0;
    }
  }
  function a2() {
    return "undefined" != typeof window && "function" == typeof window.btoa ? (e3) => window.btoa(unescape(encodeURIComponent(e3))) : "function" == typeof n2 ? (e3) => n2.from(e3, "utf-8").toString("base64") : () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
  const l = a2();
  class c {
    constructor(e3) {
      this.version = 3, this.file = e3.file, this.sources = e3.sources, this.sourcesContent = e3.sourcesContent, this.names = e3.names, this.mappings = s2.encode(e3.mappings), void 0 !== e3.x_google_ignoreList && (this.x_google_ignoreList = e3.x_google_ignoreList);
    }
    toString() {
      return JSON.stringify(this);
    }
    toUrl() {
      return "data:application/json;charset=utf-8;base64," + l(this.toString());
    }
  }
  function u(e3, t3) {
    const r3 = e3.split(/[/\\]/), n3 = t3.split(/[/\\]/);
    for (r3.pop(); r3[0] === n3[0]; ) r3.shift(), n3.shift();
    if (r3.length) {
      let e4 = r3.length;
      for (; e4--; ) r3[e4] = "..";
    }
    return r3.concat(n3).join("/");
  }
  const p = Object.prototype.toString;
  function d(e3) {
    return "[object Object]" === p.call(e3);
  }
  function f(e3) {
    const t3 = e3.split("\n"), r3 = [];
    for (let e4 = 0, n3 = 0; e4 < t3.length; e4++) r3.push(n3), n3 += t3[e4].length + 1;
    return function(e4) {
      let t4 = 0, n3 = r3.length;
      for (; t4 < n3; ) {
        const s4 = t4 + n3 >> 1;
        e4 < r3[s4] ? n3 = s4 : t4 = s4 + 1;
      }
      const s3 = t4 - 1;
      return { line: s3, column: e4 - r3[s3] };
    };
  }
  const h = /\w/;
  class m {
    constructor(e3) {
      this.hires = e3, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] = [], this.pending = null;
    }
    addEdit(e3, t3, r3, n3) {
      if (t3.length) {
        let s3 = t3.indexOf("\n", 0), i3 = -1;
        for (; s3 >= 0; ) {
          const o4 = [this.generatedCodeColumn, e3, r3.line, r3.column];
          n3 >= 0 && o4.push(n3), this.rawSegments.push(o4), this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, i3 = s3, s3 = t3.indexOf("\n", s3 + 1);
        }
        const o3 = [this.generatedCodeColumn, e3, r3.line, r3.column];
        n3 >= 0 && o3.push(n3), this.rawSegments.push(o3), this.advance(t3.slice(i3 + 1));
      } else this.pending && (this.rawSegments.push(this.pending), this.advance(t3));
      this.pending = null;
    }
    addUneditedChunk(e3, t3, r3, n3, s3) {
      let i3 = t3.start, o3 = true, a3 = false;
      for (; i3 < t3.end; ) {
        if (this.hires || o3 || s3.has(i3)) {
          const t4 = [this.generatedCodeColumn, e3, n3.line, n3.column];
          "boundary" === this.hires ? h.test(r3[i3]) ? a3 || (this.rawSegments.push(t4), a3 = true) : (this.rawSegments.push(t4), a3 = false) : this.rawSegments.push(t4);
        }
        "\n" === r3[i3] ? (n3.line += 1, n3.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, o3 = true) : (n3.column += 1, this.generatedCodeColumn += 1, o3 = false), i3 += 1;
      }
      this.pending = null;
    }
    advance(e3) {
      if (!e3) return;
      const t3 = e3.split("\n");
      if (t3.length > 1) {
        for (let e4 = 0; e4 < t3.length - 1; e4++) this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
      }
      this.generatedCodeColumn += t3[t3.length - 1].length;
    }
  }
  const y = "\n", g = { insertLeft: false, insertRight: false, storeName: false };
  class b {
    constructor(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const r3 = new o2(0, e3.length, e3);
      Object.defineProperties(this, { original: { writable: true, value: e3 }, outro: { writable: true, value: "" }, intro: { writable: true, value: "" }, firstChunk: { writable: true, value: r3 }, lastChunk: { writable: true, value: r3 }, lastSearchedChunk: { writable: true, value: r3 }, byStart: { writable: true, value: {} }, byEnd: { writable: true, value: {} }, filename: { writable: true, value: t3.filename }, indentExclusionRanges: { writable: true, value: t3.indentExclusionRanges }, sourcemapLocations: { writable: true, value: new i2() }, storedNames: { writable: true, value: {} }, indentStr: { writable: true, value: void 0 }, ignoreList: { writable: true, value: t3.ignoreList } }), this.byStart[0] = r3, this.byEnd[e3.length] = r3;
    }
    addSourcemapLocation(e3) {
      this.sourcemapLocations.add(e3);
    }
    append(e3) {
      if ("string" != typeof e3) throw new TypeError("outro content must be a string");
      return this.outro += e3, this;
    }
    appendLeft(e3, t3) {
      if ("string" != typeof t3) throw new TypeError("inserted content must be a string");
      this._split(e3);
      const r3 = this.byEnd[e3];
      return r3 ? r3.appendLeft(t3) : this.intro += t3, this;
    }
    appendRight(e3, t3) {
      if ("string" != typeof t3) throw new TypeError("inserted content must be a string");
      this._split(e3);
      const r3 = this.byStart[e3];
      return r3 ? r3.appendRight(t3) : this.outro += t3, this;
    }
    clone() {
      const e3 = new b(this.original, { filename: this.filename });
      let t3 = this.firstChunk, r3 = e3.firstChunk = e3.lastSearchedChunk = t3.clone();
      for (; t3; ) {
        e3.byStart[r3.start] = r3, e3.byEnd[r3.end] = r3;
        const n3 = t3.next, s3 = n3 && n3.clone();
        s3 && (r3.next = s3, s3.previous = r3, r3 = s3), t3 = n3;
      }
      return e3.lastChunk = r3, this.indentExclusionRanges && (e3.indentExclusionRanges = this.indentExclusionRanges.slice()), e3.sourcemapLocations = new i2(this.sourcemapLocations), e3.intro = this.intro, e3.outro = this.outro, e3;
    }
    generateDecodedMap(e3) {
      e3 = e3 || {};
      const t3 = Object.keys(this.storedNames), r3 = new m(e3.hires), n3 = f(this.original);
      return this.intro && r3.advance(this.intro), this.firstChunk.eachNext((e4) => {
        const s3 = n3(e4.start);
        e4.intro.length && r3.advance(e4.intro), e4.edited ? r3.addEdit(0, e4.content, s3, e4.storeName ? t3.indexOf(e4.original) : -1) : r3.addUneditedChunk(0, e4, this.original, s3, this.sourcemapLocations), e4.outro.length && r3.advance(e4.outro);
      }), { file: e3.file ? e3.file.split(/[/\\]/).pop() : void 0, sources: [e3.source ? u(e3.file || "", e3.source) : e3.file || ""], sourcesContent: e3.includeContent ? [this.original] : void 0, names: t3, mappings: r3.raw, x_google_ignoreList: this.ignoreList ? [0] : void 0 };
    }
    generateMap(e3) {
      return new c(this.generateDecodedMap(e3));
    }
    _ensureindentStr() {
      void 0 === this.indentStr && (this.indentStr = function(e3) {
        const t3 = e3.split("\n"), r3 = t3.filter((e4) => /^\t+/.test(e4)), n3 = t3.filter((e4) => /^ {2,}/.test(e4));
        if (0 === r3.length && 0 === n3.length) return null;
        if (r3.length >= n3.length) return "	";
        const s3 = n3.reduce((e4, t4) => {
          const r4 = /^ +/.exec(t4)[0].length;
          return Math.min(r4, e4);
        }, 1 / 0);
        return new Array(s3 + 1).join(" ");
      }(this.original));
    }
    _getRawIndentString() {
      return this._ensureindentStr(), this.indentStr;
    }
    getIndentString() {
      return this._ensureindentStr(), null === this.indentStr ? "	" : this.indentStr;
    }
    indent(e3, t3) {
      const r3 = /^[^\r\n]/gm;
      if (d(e3) && (t3 = e3, e3 = void 0), void 0 === e3 && (this._ensureindentStr(), e3 = this.indentStr || "	"), "" === e3) return this;
      const n3 = {};
      (t3 = t3 || {}).exclude && ("number" == typeof t3.exclude[0] ? [t3.exclude] : t3.exclude).forEach((e4) => {
        for (let t4 = e4[0]; t4 < e4[1]; t4 += 1) n3[t4] = true;
      });
      let s3 = false !== t3.indentStart;
      const i3 = (t4) => s3 ? `${e3}${t4}` : (s3 = true, t4);
      this.intro = this.intro.replace(r3, i3);
      let o3 = 0, a3 = this.firstChunk;
      for (; a3; ) {
        const t4 = a3.end;
        if (a3.edited) n3[o3] || (a3.content = a3.content.replace(r3, i3), a3.content.length && (s3 = "\n" === a3.content[a3.content.length - 1]));
        else for (o3 = a3.start; o3 < t4; ) {
          if (!n3[o3]) {
            const t5 = this.original[o3];
            "\n" === t5 ? s3 = true : "\r" !== t5 && s3 && (s3 = false, o3 === a3.start || (this._splitChunk(a3, o3), a3 = a3.next), a3.prependRight(e3));
          }
          o3 += 1;
        }
        o3 = a3.end, a3 = a3.next;
      }
      return this.outro = this.outro.replace(r3, i3), this;
    }
    insert() {
      throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
    }
    insertLeft(e3, t3) {
      return g.insertLeft || (g.insertLeft = true), this.appendLeft(e3, t3);
    }
    insertRight(e3, t3) {
      return g.insertRight || (g.insertRight = true), this.prependRight(e3, t3);
    }
    move(e3, t3, r3) {
      if (r3 >= e3 && r3 <= t3) throw new Error("Cannot move a selection inside itself");
      this._split(e3), this._split(t3), this._split(r3);
      const n3 = this.byStart[e3], s3 = this.byEnd[t3], i3 = n3.previous, o3 = s3.next, a3 = this.byStart[r3];
      if (!a3 && s3 === this.lastChunk) return this;
      const l2 = a3 ? a3.previous : this.lastChunk;
      return i3 && (i3.next = o3), o3 && (o3.previous = i3), l2 && (l2.next = n3), a3 && (a3.previous = s3), n3.previous || (this.firstChunk = s3.next), s3.next || (this.lastChunk = n3.previous, this.lastChunk.next = null), n3.previous = l2, s3.next = a3 || null, l2 || (this.firstChunk = n3), a3 || (this.lastChunk = s3), this;
    }
    overwrite(e3, t3, r3, n3) {
      return n3 = n3 || {}, this.update(e3, t3, r3, { ...n3, overwrite: !n3.contentOnly });
    }
    update(e3, t3, r3, n3) {
      if ("string" != typeof r3) throw new TypeError("replacement content must be a string");
      for (; e3 < 0; ) e3 += this.original.length;
      for (; t3 < 0; ) t3 += this.original.length;
      if (t3 > this.original.length) throw new Error("end is out of bounds");
      if (e3 === t3) throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");
      this._split(e3), this._split(t3), true === n3 && (g.storeName || (g.storeName = true), n3 = { storeName: true });
      const s3 = void 0 !== n3 && n3.storeName, i3 = void 0 !== n3 && n3.overwrite;
      if (s3) {
        const r4 = this.original.slice(e3, t3);
        Object.defineProperty(this.storedNames, r4, { writable: true, value: true, enumerable: true });
      }
      const a3 = this.byStart[e3], l2 = this.byEnd[t3];
      if (a3) {
        let e4 = a3;
        for (; e4 !== l2; ) {
          if (e4.next !== this.byStart[e4.end]) throw new Error("Cannot overwrite across a split point");
          e4 = e4.next, e4.edit("", false);
        }
        a3.edit(r3, s3, !i3);
      } else {
        const n4 = new o2(e3, t3, "").edit(r3, s3);
        l2.next = n4, n4.previous = l2;
      }
      return this;
    }
    prepend(e3) {
      if ("string" != typeof e3) throw new TypeError("outro content must be a string");
      return this.intro = e3 + this.intro, this;
    }
    prependLeft(e3, t3) {
      if ("string" != typeof t3) throw new TypeError("inserted content must be a string");
      this._split(e3);
      const r3 = this.byEnd[e3];
      return r3 ? r3.prependLeft(t3) : this.intro = t3 + this.intro, this;
    }
    prependRight(e3, t3) {
      if ("string" != typeof t3) throw new TypeError("inserted content must be a string");
      this._split(e3);
      const r3 = this.byStart[e3];
      return r3 ? r3.prependRight(t3) : this.outro = t3 + this.outro, this;
    }
    remove(e3, t3) {
      for (; e3 < 0; ) e3 += this.original.length;
      for (; t3 < 0; ) t3 += this.original.length;
      if (e3 === t3) return this;
      if (e3 < 0 || t3 > this.original.length) throw new Error("Character is out of bounds");
      if (e3 > t3) throw new Error("end must be greater than start");
      this._split(e3), this._split(t3);
      let r3 = this.byStart[e3];
      for (; r3; ) r3.intro = "", r3.outro = "", r3.edit(""), r3 = t3 > r3.end ? this.byStart[r3.end] : null;
      return this;
    }
    lastChar() {
      if (this.outro.length) return this.outro[this.outro.length - 1];
      let e3 = this.lastChunk;
      do {
        if (e3.outro.length) return e3.outro[e3.outro.length - 1];
        if (e3.content.length) return e3.content[e3.content.length - 1];
        if (e3.intro.length) return e3.intro[e3.intro.length - 1];
      } while (e3 = e3.previous);
      return this.intro.length ? this.intro[this.intro.length - 1] : "";
    }
    lastLine() {
      let e3 = this.outro.lastIndexOf(y);
      if (-1 !== e3) return this.outro.substr(e3 + 1);
      let t3 = this.outro, r3 = this.lastChunk;
      do {
        if (r3.outro.length > 0) {
          if (e3 = r3.outro.lastIndexOf(y), -1 !== e3) return r3.outro.substr(e3 + 1) + t3;
          t3 = r3.outro + t3;
        }
        if (r3.content.length > 0) {
          if (e3 = r3.content.lastIndexOf(y), -1 !== e3) return r3.content.substr(e3 + 1) + t3;
          t3 = r3.content + t3;
        }
        if (r3.intro.length > 0) {
          if (e3 = r3.intro.lastIndexOf(y), -1 !== e3) return r3.intro.substr(e3 + 1) + t3;
          t3 = r3.intro + t3;
        }
      } while (r3 = r3.previous);
      return e3 = this.intro.lastIndexOf(y), -1 !== e3 ? this.intro.substr(e3 + 1) + t3 : this.intro + t3;
    }
    slice() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.original.length;
      for (; e3 < 0; ) e3 += this.original.length;
      for (; t3 < 0; ) t3 += this.original.length;
      let r3 = "", n3 = this.firstChunk;
      for (; n3 && (n3.start > e3 || n3.end <= e3); ) {
        if (n3.start < t3 && n3.end >= t3) return r3;
        n3 = n3.next;
      }
      if (n3 && n3.edited && n3.start !== e3) throw new Error(`Cannot use replaced character ${e3} as slice start anchor.`);
      const s3 = n3;
      for (; n3; ) {
        !n3.intro || s3 === n3 && n3.start !== e3 || (r3 += n3.intro);
        const i3 = n3.start < t3 && n3.end >= t3;
        if (i3 && n3.edited && n3.end !== t3) throw new Error(`Cannot use replaced character ${t3} as slice end anchor.`);
        const o3 = s3 === n3 ? e3 - n3.start : 0, a3 = i3 ? n3.content.length + t3 - n3.end : n3.content.length;
        if (r3 += n3.content.slice(o3, a3), !n3.outro || i3 && n3.end !== t3 || (r3 += n3.outro), i3) break;
        n3 = n3.next;
      }
      return r3;
    }
    snip(e3, t3) {
      const r3 = this.clone();
      return r3.remove(0, e3), r3.remove(t3, r3.original.length), r3;
    }
    _split(e3) {
      if (this.byStart[e3] || this.byEnd[e3]) return;
      let t3 = this.lastSearchedChunk;
      const r3 = e3 > t3.end;
      for (; t3; ) {
        if (t3.contains(e3)) return this._splitChunk(t3, e3);
        t3 = r3 ? this.byStart[t3.end] : this.byEnd[t3.start];
      }
    }
    _splitChunk(e3, t3) {
      if (e3.edited && e3.content.length) {
        const r4 = f(this.original)(t3);
        throw new Error(`Cannot split a chunk that has already been edited (${r4.line}:${r4.column} – "${e3.original}")`);
      }
      const r3 = e3.split(t3);
      return this.byEnd[t3] = e3, this.byStart[t3] = r3, this.byEnd[r3.end] = r3, e3 === this.lastChunk && (this.lastChunk = r3), this.lastSearchedChunk = e3, true;
    }
    toString() {
      let e3 = this.intro, t3 = this.firstChunk;
      for (; t3; ) e3 += t3.toString(), t3 = t3.next;
      return e3 + this.outro;
    }
    isEmpty() {
      let e3 = this.firstChunk;
      do {
        if (e3.intro.length && e3.intro.trim() || e3.content.length && e3.content.trim() || e3.outro.length && e3.outro.trim()) return false;
      } while (e3 = e3.next);
      return true;
    }
    length() {
      let e3 = this.firstChunk, t3 = 0;
      do {
        t3 += e3.intro.length + e3.content.length + e3.outro.length;
      } while (e3 = e3.next);
      return t3;
    }
    trimLines() {
      return this.trim("[\\r\\n]");
    }
    trim(e3) {
      return this.trimStart(e3).trimEnd(e3);
    }
    trimEndAborted(e3) {
      const t3 = new RegExp((e3 || "\\s") + "+$");
      if (this.outro = this.outro.replace(t3, ""), this.outro.length) return true;
      let r3 = this.lastChunk;
      do {
        const e4 = r3.end, n3 = r3.trimEnd(t3);
        if (r3.end !== e4 && (this.lastChunk === r3 && (this.lastChunk = r3.next), this.byEnd[r3.end] = r3, this.byStart[r3.next.start] = r3.next, this.byEnd[r3.next.end] = r3.next), n3) return true;
        r3 = r3.previous;
      } while (r3);
      return false;
    }
    trimEnd(e3) {
      return this.trimEndAborted(e3), this;
    }
    trimStartAborted(e3) {
      const t3 = new RegExp("^" + (e3 || "\\s") + "+");
      if (this.intro = this.intro.replace(t3, ""), this.intro.length) return true;
      let r3 = this.firstChunk;
      do {
        const e4 = r3.end, n3 = r3.trimStart(t3);
        if (r3.end !== e4 && (r3 === this.lastChunk && (this.lastChunk = r3.next), this.byEnd[r3.end] = r3, this.byStart[r3.next.start] = r3.next, this.byEnd[r3.next.end] = r3.next), n3) return true;
        r3 = r3.next;
      } while (r3);
      return false;
    }
    trimStart(e3) {
      return this.trimStartAborted(e3), this;
    }
    hasChanged() {
      return this.original !== this.toString();
    }
    _replaceRegexp(e3, t3) {
      function r3(e4, r4) {
        return "string" == typeof t3 ? t3.replace(/\$(\$|&|\d+)/g, (t4, r5) => "$" === r5 ? "$" : "&" === r5 ? e4[0] : +r5 < e4.length ? e4[+r5] : `$${r5}`) : t3(...e4, e4.index, r4, e4.groups);
      }
      if (e3.global) (function(e4, t4) {
        let r4;
        const n3 = [];
        for (; r4 = e4.exec(t4); ) n3.push(r4);
        return n3;
      })(e3, this.original).forEach((e4) => {
        null != e4.index && this.overwrite(e4.index, e4.index + e4[0].length, r3(e4, this.original));
      });
      else {
        const t4 = this.original.match(e3);
        t4 && null != t4.index && this.overwrite(t4.index, t4.index + t4[0].length, r3(t4, this.original));
      }
      return this;
    }
    _replaceString(e3, t3) {
      const { original: r3 } = this, n3 = r3.indexOf(e3);
      return -1 !== n3 && this.overwrite(n3, n3 + e3.length, t3), this;
    }
    replace(e3, t3) {
      return "string" == typeof e3 ? this._replaceString(e3, t3) : this._replaceRegexp(e3, t3);
    }
    _replaceAllString(e3, t3) {
      const { original: r3 } = this, n3 = e3.length;
      for (let s3 = r3.indexOf(e3); -1 !== s3; s3 = r3.indexOf(e3, s3 + n3)) this.overwrite(s3, s3 + n3, t3);
      return this;
    }
    replaceAll(e3, t3) {
      if ("string" == typeof e3) return this._replaceAllString(e3, t3);
      if (!e3.global) throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");
      return this._replaceRegexp(e3, t3);
    }
  }
  const v = Object.prototype.hasOwnProperty;
  class E {
    constructor() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.intro = e3.intro || "", this.separator = void 0 !== e3.separator ? e3.separator : "\n", this.sources = [], this.uniqueSources = [], this.uniqueSourceIndexByFilename = {};
    }
    addSource(e3) {
      if (e3 instanceof b) return this.addSource({ content: e3, filename: e3.filename, separator: this.separator });
      if (!d(e3) || !e3.content) throw new Error("bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`");
      if (["filename", "ignoreList", "indentExclusionRanges", "separator"].forEach((t3) => {
        v.call(e3, t3) || (e3[t3] = e3.content[t3]);
      }), void 0 === e3.separator && (e3.separator = this.separator), e3.filename) if (v.call(this.uniqueSourceIndexByFilename, e3.filename)) {
        const t3 = this.uniqueSources[this.uniqueSourceIndexByFilename[e3.filename]];
        if (e3.content.original !== t3.content) throw new Error(`Illegal source: same filename (${e3.filename}), different contents`);
      } else this.uniqueSourceIndexByFilename[e3.filename] = this.uniqueSources.length, this.uniqueSources.push({ filename: e3.filename, content: e3.content.original });
      return this.sources.push(e3), this;
    }
    append(e3, t3) {
      return this.addSource({ content: new b(e3), separator: t3 && t3.separator || "" }), this;
    }
    clone() {
      const e3 = new E({ intro: this.intro, separator: this.separator });
      return this.sources.forEach((t3) => {
        e3.addSource({ filename: t3.filename, content: t3.content.clone(), separator: t3.separator });
      }), e3;
    }
    generateDecodedMap() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      const t3 = [];
      let r3;
      this.sources.forEach((e4) => {
        Object.keys(e4.content.storedNames).forEach((e5) => {
          ~t3.indexOf(e5) || t3.push(e5);
        });
      });
      const n3 = new m(e3.hires);
      return this.intro && n3.advance(this.intro), this.sources.forEach((e4, s3) => {
        s3 > 0 && n3.advance(this.separator);
        const i3 = e4.filename ? this.uniqueSourceIndexByFilename[e4.filename] : -1, o3 = e4.content, a3 = f(o3.original);
        o3.intro && n3.advance(o3.intro), o3.firstChunk.eachNext((r4) => {
          const s4 = a3(r4.start);
          r4.intro.length && n3.advance(r4.intro), e4.filename ? r4.edited ? n3.addEdit(i3, r4.content, s4, r4.storeName ? t3.indexOf(r4.original) : -1) : n3.addUneditedChunk(i3, r4, o3.original, s4, o3.sourcemapLocations) : n3.advance(r4.content), r4.outro.length && n3.advance(r4.outro);
        }), o3.outro && n3.advance(o3.outro), e4.ignoreList && -1 !== i3 && (void 0 === r3 && (r3 = []), r3.push(i3));
      }), { file: e3.file ? e3.file.split(/[/\\]/).pop() : void 0, sources: this.uniqueSources.map((t4) => e3.file ? u(e3.file, t4.filename) : t4.filename), sourcesContent: this.uniqueSources.map((t4) => e3.includeContent ? t4.content : null), names: t3, mappings: n3.raw, x_google_ignoreList: r3 };
    }
    generateMap(e3) {
      return new c(this.generateDecodedMap(e3));
    }
    getIndentString() {
      const e3 = {};
      return this.sources.forEach((t3) => {
        const r3 = t3.content._getRawIndentString();
        null !== r3 && (e3[r3] || (e3[r3] = 0), e3[r3] += 1);
      }), Object.keys(e3).sort((t3, r3) => e3[t3] - e3[r3])[0] || "	";
    }
    indent(e3) {
      if (arguments.length || (e3 = this.getIndentString()), "" === e3) return this;
      let t3 = !this.intro || "\n" === this.intro.slice(-1);
      return this.sources.forEach((r3, n3) => {
        const s3 = void 0 !== r3.separator ? r3.separator : this.separator, i3 = t3 || n3 > 0 && /\r?\n$/.test(s3);
        r3.content.indent(e3, { exclude: r3.indentExclusionRanges, indentStart: i3 }), t3 = "\n" === r3.content.lastChar();
      }), this.intro && (this.intro = e3 + this.intro.replace(/^[^\n]/gm, (t4, r3) => r3 > 0 ? e3 + t4 : t4)), this;
    }
    prepend(e3) {
      return this.intro = e3 + this.intro, this;
    }
    toString() {
      const e3 = this.sources.map((e4, t3) => {
        const r3 = void 0 !== e4.separator ? e4.separator : this.separator;
        return (t3 > 0 ? r3 : "") + e4.content.toString();
      }).join("");
      return this.intro + e3;
    }
    isEmpty() {
      return !(this.intro.length && this.intro.trim() || this.sources.some((e3) => !e3.content.isEmpty()));
    }
    length() {
      return this.sources.reduce((e3, t3) => e3 + t3.content.length(), this.intro.length);
    }
    trimLines() {
      return this.trim("[\\r\\n]");
    }
    trim(e3) {
      return this.trimStart(e3).trimEnd(e3);
    }
    trimStart(e3) {
      const t3 = new RegExp("^" + (e3 || "\\s") + "+");
      if (this.intro = this.intro.replace(t3, ""), !this.intro) {
        let t4, r3 = 0;
        do {
          if (t4 = this.sources[r3++], !t4) break;
        } while (!t4.content.trimStartAborted(e3));
      }
      return this;
    }
    trimEnd(e3) {
      const t3 = new RegExp((e3 || "\\s") + "+$");
      let r3, n3 = this.sources.length - 1;
      do {
        if (r3 = this.sources[n3--], !r3) {
          this.intro = this.intro.replace(t3, "");
          break;
        }
      } while (!r3.content.trimEndAborted(e3));
      return this;
    }
  }
  b.Bundle = E, b.SourceMap = c, b.default = b, e2.exports = b;
}, (e2, t2, r2) => {
  var n2, s2 = Object.defineProperty, i2 = Object.getOwnPropertyDescriptor, o2 = Object.getOwnPropertyNames, a2 = Object.prototype.hasOwnProperty, l = {};
  ((e3, t3) => {
    for (var r3 in t3) s2(e3, r3, { get: t3[r3], enumerable: true });
  })(l, { default: () => f }), e2.exports = (n2 = l, ((e3, t3, r3, n3) => {
    if (t3 && "object" == typeof t3 || "function" == typeof t3) for (let r4 of o2(t3)) a2.call(e3, r4) || void 0 === r4 || s2(e3, r4, { get: () => t3[r4], enumerable: !(n3 = i2(t3, r4)) || n3.enumerable });
    return e3;
  })(s2({}, "__esModule", { value: true }), n2));
  var c = r2(21), u = r2(308), p = r2(36), d = r2(93), f = (0, r2(16).declare)((e3, t3) => {
    let r3, n3, { types: s3 } = e3;
    return { name: "babel-plugin-resolve-type", pre(e4) {
      const s4 = e4.opts.filename || "unknown.js";
      n3 = /* @__PURE__ */ new Set(), r3 = { filename: s4, source: e4.code, options: t3, ast: e4.ast.program.body, isCE: false, error(t4, r4) {
        throw new Error(`[@vue/babel-plugin-resolve-type] ${t4}

${s4}
${(0, p.codeFrameColumns)(e4.code, { start: { line: r4.loc.start.line, column: r4.loc.start.column + 1 }, end: { line: r4.loc.end.line, column: r4.loc.end.column + 1 } })}`);
      }, helper: (e5) => (n3.add(e5), `_${e5}`), getString: (t4) => e4.code.slice(t4.start, t4.end), propsTypeDecl: void 0, propsRuntimeDefaults: void 0, propsDestructuredBindings: {}, emitsTypeDecl: void 0 };
    }, visitor: { CallExpression(e4) {
      if (!r3) throw new Error("[@vue/babel-plugin-resolve-type] context is not loaded.");
      const { node: t4 } = e4;
      if (!s3.isIdentifier(t4.callee, { name: "defineComponent" })) return;
      if (!m(e4)) return;
      const n4 = t4.arguments[0];
      if (!n4 || !s3.isFunction(n4)) return;
      let i3 = t4.arguments[1];
      i3 || (i3 = s3.objectExpression([]), t4.arguments.push(i3)), t4.arguments[1] = function(e5, t5) {
        const n5 = e5.params[0];
        if (!n5) return;
        if ("AssignmentPattern" === n5.type ? (r3.propsTypeDecl = h(n5.left), r3.propsRuntimeDefaults = n5.right) : r3.propsTypeDecl = h(n5), !r3.propsTypeDecl) return;
        const i4 = (0, u.extractRuntimeProps)(r3);
        if (!i4) return;
        const o3 = (0, c.parseExpression)(i4);
        return y(s3, t5, s3.objectProperty(s3.identifier("props"), o3));
      }(n4, i3) || i3, t4.arguments[1] = function(e5, t5) {
        var n5;
        const i4 = e5.params[1] && h(e5.params[1]);
        if (!i4 || !s3.isTSTypeReference(i4) || !s3.isIdentifier(i4.typeName, { name: "SetupContext" })) return;
        const o3 = null == (n5 = i4.typeParameters) ? void 0 : n5.params[0];
        if (!o3) return;
        r3.emitsTypeDecl = o3;
        const a3 = (0, u.extractRuntimeEmits)(r3), l2 = s3.arrayExpression(Array.from(a3).map((e6) => s3.stringLiteral(e6)));
        return y(s3, t5, s3.objectProperty(s3.identifier("emits"), l2));
      }(n4, t4.arguments[1]) || i3;
    }, VariableDeclarator(e4) {
      !function(e5) {
        var t4;
        const r4 = e5.get("id"), n4 = e5.get("init");
        if (!(r4 && r4.isIdentifier() && n4 && n4.isCallExpression())) return;
        if (!(null == (t4 = n4.get("callee")) ? void 0 : t4.isIdentifier({ name: "defineComponent" }))) return;
        if (!m(n4)) return;
        const i3 = s3.objectProperty(s3.identifier("name"), s3.stringLiteral(r4.node.name)), { arguments: o3 } = n4.node;
        0 !== o3.length && (1 === o3.length && n4.node.arguments.push(s3.objectExpression([])), o3[1] = y(s3, o3[1], i3));
      }(e4);
    } }, post(e4) {
      for (const t4 of n3) (0, d.addNamed)(e4.path, `_${t4}`, "vue");
    } };
  });
  function h(e3) {
    if ("typeAnnotation" in e3 && e3.typeAnnotation && "TSTypeAnnotation" === e3.typeAnnotation.type) return e3.typeAnnotation.typeAnnotation;
  }
  function m(e3) {
    var t3;
    const r3 = null == (t3 = e3.scope.getBinding("defineComponent")) ? void 0 : t3.path.parent;
    return !r3 || "ImportDeclaration" === r3.type && /^@?vue(\/|$)/.test(r3.source.value);
  }
  function y(e3, t3, r3) {
    if (e3.isObjectExpression(t3)) t3.properties.unshift(r3);
    else if (e3.isExpression(t3)) return e3.objectExpression([r3, e3.spreadElement(t3)]);
    return t3;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.buildScopeIIFE = function(e3, t3) {
    const r3 = [], s2 = [];
    for (const t4 of e3) r3.push(n2.types.identifier(t4)), s2.push(n2.types.identifier(t4));
    return n2.types.returnStatement(n2.types.callExpression(n2.types.arrowFunctionExpression(s2, t3), r3));
  }, t2.collectShadowedParamsNames = function(e3, t3, r3) {
    for (const s2 of Object.keys(e3.getBindingIdentifiers())) {
      var n3;
      const e4 = null == (n3 = t3.bindings[s2]) ? void 0 : n3.constantViolations;
      if (e4) for (const t4 of e4) {
        const e5 = t4.node;
        switch (e5.type) {
          case "VariableDeclarator":
            if (null === e5.init) {
              const e6 = t4.parentPath;
              if (!e6.parentPath.isFor() || e6.parentPath.get("body") === e6) {
                t4.remove();
                break;
              }
            }
            r3.add(s2);
            break;
          case "FunctionDeclaration":
            r3.add(s2);
        }
      }
    }
  }, t2.iifeVisitor = void 0;
  var n2 = r2(1);
  t2.iifeVisitor = { "ReferencedIdentifier|BindingIdentifier"(e3, t3) {
    const { scope: r3, node: n3 } = e3, { name: s2 } = n3;
    ("eval" === s2 || r3.getBinding(s2) === t3.scope.parent.getBinding(s2) && t3.scope.hasOwnBinding(s2)) && (t3.needsOuterBinding = true, e3.stop());
  }, "TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration": (e3) => e3.skip() };
}, (e2, t2, r2) => {
  e2.exports = r2(143);
}, (e2) => {
  function t2(e3) {
    var t3 = new Error("Cannot find module '" + e3 + "'");
    throw t3.code = "MODULE_NOT_FOUND", t3;
  }
  t2.keys = () => [], t2.resolve = t2, t2.id = 329, e2.exports = t2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.buildDynamicImport = function(e3, t3, r3, s2) {
    const i2 = n2.types.isCallExpression(e3) ? e3.arguments[0] : e3.source;
    if (n2.types.isStringLiteral(i2) || n2.types.isTemplateLiteral(i2) && 0 === i2.quasis.length) return t3 ? n2.template.expression.ast`
        Promise.resolve().then(() => ${s2(i2)})
      ` : s2(i2);
    const o2 = n2.types.isTemplateLiteral(i2) ? n2.types.identifier("specifier") : n2.types.templateLiteral([n2.types.templateElement({ raw: "" }), n2.types.templateElement({ raw: "" })], [n2.types.identifier("specifier")]);
    return t3 ? n2.template.expression.ast`
      (specifier =>
        new Promise(r => r(${o2}))
          .then(s => ${s2(n2.types.identifier("s"))})
      )(${i2})
    ` : r3 ? n2.template.expression.ast`
      (specifier =>
        new Promise(r => r(${s2(o2)}))
      )(${i2})
    ` : n2.template.expression.ast`
      (specifier => ${s2(o2)})(${i2})
    `;
  };
  var n2 = r2(1);
  t2.getDynamicImportSource = function(e3) {
    const [t3] = e3.arguments;
    return n2.types.isStringLiteral(t3) || n2.types.isTemplateLiteral(t3) ? t3 : n2.template.expression.ast`\`\${${t3}}\``;
  };
}, (e2, t2, r2) => {
  t2.a = void 0;
  var n2 = r2(16), s2 = r2(495), i2 = r2(298), o2 = r2(500), a2 = r2(305), l = r2(306), c = r2(501);
  function u(e3) {
    switch (e3.parent.type) {
      case "TSTypeReference":
      case "TSExpressionWithTypeArguments":
      case "TSTypeQuery":
        return true;
      case "TSQualifiedName":
        return "TSImportEqualsDeclaration" !== e3.parentPath.findParent((e4) => "TSQualifiedName" !== e4.type).type;
      case "ExportSpecifier":
        return "type" === e3.parent.exportKind || "type" === e3.parentPath.parent.exportKind;
      default:
        return false;
    }
  }
  const p = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakSet();
  function f(e3) {
    const t3 = e3.getBindingIdentifiers();
    for (const r3 of Object.keys(t3)) {
      const n3 = e3.scope.getBinding(r3);
      n3 && n3.identifier === t3[r3] && n3.scope.removeBinding(r3);
    }
    e3.opts.noScope = true, e3.remove(), e3.opts.noScope = false;
  }
  function h(e3, t3, r3, n3) {
    let s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "";
    if ("commonjs" !== t3.file.get("@babel/plugin-transform-modules-*")) throw e3.buildCodeFrameError(`\`${r3}\` is only supported when compiling modules to CommonJS.
Please consider using \`${n3}\`${s3}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`);
  }
  t2.a = (0, n2.declare)((e3, t3) => {
    const { types: r3, template: n3 } = e3;
    e3.assertVersion(7);
    const m = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/, { allowNamespaces: y = true, jsxPragma: g = "React.createElement", jsxPragmaFrag: b = "React.Fragment", onlyRemoveTypeImports: v = false, optimizeConstEnums: E = false } = t3;
    var { allowDeclareFields: S = false } = t3;
    const x = { field(e4) {
      const { node: t4 } = e4;
      if (!S && t4.declare) throw e4.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
      if (t4.declare) {
        if (t4.value) throw e4.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
        t4.decorators || e4.remove();
      } else if (t4.definite) {
        if (t4.value) throw e4.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
        S || t4.decorators || r3.isClassPrivateProperty(t4) || e4.remove();
      } else t4.abstract ? e4.remove() : S || t4.value || t4.decorators || r3.isClassPrivateProperty(t4) || e4.remove();
      t4.accessibility && (t4.accessibility = null), t4.abstract && (t4.abstract = null), t4.readonly && (t4.readonly = null), t4.optional && (t4.optional = null), t4.typeAnnotation && (t4.typeAnnotation = null), t4.definite && (t4.definite = null), t4.declare && (t4.declare = null), t4.override && (t4.override = null);
    }, method(e4) {
      let { node: t4 } = e4;
      t4.accessibility && (t4.accessibility = null), t4.abstract && (t4.abstract = null), t4.optional && (t4.optional = null), t4.override && (t4.override = null);
    }, constructor(e4, t4) {
      e4.node.accessibility && (e4.node.accessibility = null);
      const s3 = [], { scope: o3 } = e4;
      for (const t5 of e4.get("params")) {
        const e5 = t5.node;
        if ("TSParameterProperty" === e5.type) {
          const i3 = e5.parameter;
          if (d.has(i3)) continue;
          let a3;
          if (d.add(i3), r3.isIdentifier(i3)) a3 = i3;
          else {
            if (!r3.isAssignmentPattern(i3) || !r3.isIdentifier(i3.left)) throw t5.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
            a3 = i3.left;
          }
          s3.push(n3.statement.ast`
              this.${r3.cloneNode(a3)} = ${r3.cloneNode(a3)}
            `), t5.replaceWith(t5.get("parameter")), o3.registerBinding("param", t5);
        }
      }
      (0, i2.injectInitialization)(t4, e4, s3);
    } };
    return { name: "transform-typescript", inherits: s2.default, visitor: { Pattern: w, Identifier: w, RestElement: w, Program: { enter(e4, t4) {
      const { file: r4 } = t4;
      let n4 = null, s3 = null;
      const i3 = e4.scope;
      if (l.GLOBAL_TYPES.has(i3) || l.GLOBAL_TYPES.set(i3, /* @__PURE__ */ new Set()), r4.ast.comments) for (const e5 of r4.ast.comments) {
        const t5 = m.exec(e5.value);
        t5 && (t5[1] ? s3 = t5[2] : n4 = t5[2]);
      }
      let o3 = n4 || g;
      o3 && ([o3] = o3.split("."));
      let a3 = s3 || b;
      a3 && ([a3] = a3.split("."));
      for (let r5 of e4.get("body")) if (r5.isImportDeclaration()) {
        if (p.has(t4.file.ast.program) || p.set(t4.file.ast.program, true), "type" === r5.node.importKind) {
          for (const e5 of r5.node.specifiers) (0, l.registerGlobalType)(i3, e5.local.name);
          r5.remove();
          continue;
        }
        const n5 = /* @__PURE__ */ new Set(), s4 = r5.node.specifiers.length, c2 = () => s4 > 0 && s4 === n5.size;
        for (const e5 of r5.node.specifiers) if ("ImportSpecifier" === e5.type && "type" === e5.importKind) {
          (0, l.registerGlobalType)(i3, e5.local.name);
          const t5 = r5.scope.getBinding(e5.local.name);
          t5 && n5.add(t5.path);
        }
        if (v) p.set(e4.node, false);
        else {
          if (0 === r5.node.specifiers.length) {
            p.set(e4.node, false);
            continue;
          }
          for (const t5 of r5.node.specifiers) {
            const s5 = r5.scope.getBinding(t5.local.name);
            s5 && !n5.has(s5.path) && (P({ binding: s5, programPath: e4, pragmaImportName: o3, pragmaFragImportName: a3 }) ? n5.add(s5.path) : p.set(e4.node, false));
          }
        }
        if (c2() && !v) r5.remove();
        else for (const e5 of n5) e5.remove();
      } else if (r5.isExportDeclaration() && (r5 = r5.get("declaration")), r5.isVariableDeclaration({ declare: true })) for (const e5 of Object.keys(r5.getBindingIdentifiers())) (0, l.registerGlobalType)(i3, e5);
      else (r5.isTSTypeAliasDeclaration() || r5.isTSDeclareFunction() && r5.get("id").isIdentifier() || r5.isTSInterfaceDeclaration() || r5.isClassDeclaration({ declare: true }) || r5.isTSEnumDeclaration({ declare: true }) || r5.isTSModuleDeclaration({ declare: true }) && r5.get("id").isIdentifier()) && (0, l.registerGlobalType)(i3, r5.node.id.name);
    }, exit(e4) {
      "module" === e4.node.sourceType && p.get(e4.node) && e4.pushContainer("body", r3.exportNamedDeclaration());
    } }, ExportNamedDeclaration(e4, t4) {
      if (p.has(t4.file.ast.program) || p.set(t4.file.ast.program, true), "type" !== e4.node.exportKind) if (e4.node.source && e4.node.specifiers.length > 0 && e4.node.specifiers.every((e5) => "ExportSpecifier" === e5.type && "type" === e5.exportKind)) e4.remove();
      else if (!e4.node.source && e4.node.specifiers.length > 0 && e4.node.specifiers.every((t5) => r3.isExportSpecifier(t5) && (0, l.isGlobalType)(e4, t5.local.name))) e4.remove();
      else {
        if (r3.isTSModuleDeclaration(e4.node.declaration)) {
          const t5 = e4.node.declaration, { id: n4 } = t5;
          if (r3.isIdentifier(n4)) if (e4.scope.hasOwnBinding(n4.name)) e4.replaceWith(t5);
          else {
            const [s3] = e4.replaceWithMultiple([r3.exportNamedDeclaration(r3.variableDeclaration("let", [r3.variableDeclarator(r3.cloneNode(n4))])), t5]);
            e4.scope.registerDeclaration(s3);
          }
        }
        p.set(t4.file.ast.program, false);
      }
      else e4.remove();
    }, ExportAllDeclaration(e4) {
      "type" === e4.node.exportKind && e4.remove();
    }, ExportSpecifier(e4) {
      (!e4.parent.source && (0, l.isGlobalType)(e4, e4.node.local.name) || "type" === e4.node.exportKind) && e4.remove();
    }, ExportDefaultDeclaration(e4, t4) {
      p.has(t4.file.ast.program) || p.set(t4.file.ast.program, true), r3.isIdentifier(e4.node.declaration) && (0, l.isGlobalType)(e4, e4.node.declaration.name) ? e4.remove() : p.set(t4.file.ast.program, false);
    }, TSDeclareFunction(e4) {
      f(e4);
    }, TSDeclareMethod(e4) {
      f(e4);
    }, VariableDeclaration(e4) {
      e4.node.declare && f(e4);
    }, VariableDeclarator(e4) {
      let { node: t4 } = e4;
      t4.definite && (t4.definite = null);
    }, TSIndexSignature(e4) {
      e4.remove();
    }, ClassDeclaration(e4) {
      const { node: t4 } = e4;
      t4.declare && f(e4);
    }, Class(e4) {
      const { node: t4 } = e4;
      t4.typeParameters && (t4.typeParameters = null), t4.superTypeParameters && (t4.superTypeParameters = null), t4.implements && (t4.implements = null), t4.abstract && (t4.abstract = null), e4.get("body.body").forEach((t5) => {
        t5.isClassMethod() || t5.isClassPrivateMethod() ? "constructor" === t5.node.kind ? x.constructor(t5, e4) : x.method(t5) : (t5.isClassProperty() || t5.isClassPrivateProperty() || t5.isClassAccessorProperty()) && x.field(t5);
      });
    }, Function(e4) {
      const { node: t4 } = e4;
      t4.typeParameters && (t4.typeParameters = null), t4.returnType && (t4.returnType = null);
      const n4 = t4.params;
      n4.length > 0 && r3.isIdentifier(n4[0], { name: "this" }) && n4.shift();
    }, TSModuleDeclaration(e4) {
      (0, c.default)(e4, y);
    }, TSInterfaceDeclaration(e4) {
      e4.remove();
    }, TSTypeAliasDeclaration(e4) {
      e4.remove();
    }, TSEnumDeclaration(e4) {
      E && e4.node.const ? (0, o2.default)(e4, r3) : (0, a2.default)(e4, r3);
    }, TSImportEqualsDeclaration(e4, t4) {
      const { id: n4, moduleReference: s3 } = e4.node;
      let i3, o3;
      r3.isTSExternalModuleReference(s3) ? (h(e4, t4, `import ${n4.name} = require(...);`, `import ${n4.name} from '...';`, " alongside Typescript's --allowSyntheticDefaultImports option"), i3 = r3.callExpression(r3.identifier("require"), [s3.expression]), o3 = "const") : (i3 = T(s3), o3 = "var"), e4.replaceWith(r3.variableDeclaration(o3, [r3.variableDeclarator(n4, i3)])), e4.scope.registerDeclaration(e4);
    }, TSExportAssignment(e4, t4) {
      h(e4, t4, "export = <value>;", "export default <value>;"), e4.replaceWith(n3.statement.ast`module.exports = ${e4.node.expression}`);
    }, TSTypeAssertion(e4) {
      e4.replaceWith(e4.node.expression);
    }, ["TSAsExpression" + (r3.tsSatisfiesExpression ? "|TSSatisfiesExpression" : "")](e4) {
      let { node: t4 } = e4;
      do {
        t4 = t4.expression;
      } while (r3.isTSAsExpression(t4) || null != r3.isTSSatisfiesExpression && r3.isTSSatisfiesExpression(t4));
      e4.replaceWith(t4);
    }, [e3.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](e4) {
      e4.replaceWith(e4.node.expression);
    }, CallExpression(e4) {
      e4.node.typeParameters = null;
    }, OptionalCallExpression(e4) {
      e4.node.typeParameters = null;
    }, NewExpression(e4) {
      e4.node.typeParameters = null;
    }, JSXOpeningElement(e4) {
      e4.node.typeParameters = null;
    }, TaggedTemplateExpression(e4) {
      e4.node.typeParameters = null;
    } } };
    function T(e4) {
      return r3.isTSQualifiedName(e4) ? r3.memberExpression(T(e4.left), e4.right) : e4;
    }
    function w(e4) {
      let { node: t4 } = e4;
      t4.typeAnnotation && (t4.typeAnnotation = null), r3.isIdentifier(t4) && t4.optional && (t4.optional = null);
    }
    function P(e4) {
      let { binding: t4, programPath: r4, pragmaImportName: n4, pragmaFragImportName: s3 } = e4;
      for (const e5 of t4.referencePaths) if (!u(e5)) return false;
      if (t4.identifier.name !== n4 && t4.identifier.name !== s3) return true;
      let i3 = false;
      return r4.traverse({ "JSXElement|JSXFragment"(e5) {
        i3 = true, e5.stop();
      } }), !i3;
    }
  });
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(16), s2 = r2(298);
  function i2(e3, t3) {
    let r3, n3 = 1;
    do {
      r3 = e3._generateUid("", n3), n3++;
    } while (t3.has(r3));
    return r3;
  }
  t2.default = (0, n2.declare)((e3) => {
    let { types: t3, template: n3, assertVersion: o2 } = e3;
    return o2("^7.12.0"), { name: "transform-class-static-block", inherits: r2(562).a, pre() {
      (0, s2.enableFeature)(this.file, s2.FEATURES.staticBlocks, false);
    }, visitor: { ClassBody(e4) {
      const { scope: r3 } = e4, s3 = /* @__PURE__ */ new Set(), o3 = e4.get("body");
      for (const e5 of o3) e5.isPrivate() && s3.add(e5.get("key.id").node.name);
      for (const e5 of o3) {
        if (!e5.isStaticBlock()) continue;
        const o4 = i2(r3, s3);
        s3.add(o4);
        const a2 = t3.privateName(t3.identifier(o4));
        let l;
        const c = e5.node.body;
        l = 1 === c.length && t3.isExpressionStatement(c[0]) ? t3.inheritsComments(c[0].expression, c[0]) : n3.expression.ast`(() => { ${c} })()`, e5.replaceWith(t3.classPrivateProperty(a2, l, [], true));
      }
    } } };
  });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "convertFunctionParams", { enumerable: true, get: function() {
    return s2.default;
  } }), t2.default = void 0;
  var n2 = r2(16), s2 = r2(563), i2 = r2(564);
  t2.default = (0, n2.declare)((e3, t3) => {
    var r3, n3;
    e3.assertVersion(7);
    const o2 = null != (r3 = e3.assumption("ignoreFunctionLength")) ? r3 : t3.loose, a2 = null == (n3 = e3.assumption("noNewArrows")) || n3;
    return { name: "transform-parameters", visitor: { Function(e4) {
      if (e4.isArrowFunctionExpression() && e4.get("params").some((e5) => e5.isRestElement() || e5.isAssignmentPattern()) && (e4.arrowFunctionToExpression({ allowInsertArrowWithRest: false, noNewArrows: a2 }), !e4.isFunctionExpression())) return;
      const t4 = (0, i2.default)(e4), r4 = (0, s2.default)(e4, o2);
      (t4 || r4) && e4.scope.crawl();
    } } };
  });
}, () => {
}, (e2, t2, r2) => {
  r2.d(t2, { a: () => Ae, b: () => Pe, c: () => ve, d: () => Ee });
  var n2 = r2(10), s2 = r2(1), i2 = r2(21), o2 = r2(36), a2 = r2(491), l = r2(331), c = r2(307), u = r2.n(c), p = r2(308), d = r2(328), f = r2(143), h = r2(0), m = r2(37), y = r2(557), g = r2(93), b = r2(326), v = r2(16), E = r2(558), S = r2(560), x = Object.defineProperty, T = Object.defineProperties, w = Object.getOwnPropertyDescriptors, P = Object.getOwnPropertySymbols, A = Object.prototype.hasOwnProperty, C = Object.prototype.propertyIsEnumerable, O = (e3, t3, r3) => t3 in e3 ? x(e3, t3, { enumerable: true, configurable: true, writable: true, value: r3 }) : e3[t3] = r3, I = (e3, t3) => {
    for (var r3 in t3 || (t3 = {})) A.call(t3, r3) && O(e3, r3, t3[r3]);
    if (P) for (var r3 of P(t3)) C.call(t3, r3) && O(e3, r3, t3[r3]);
    return e3;
  }, _ = (e3, t3) => T(e3, w(t3)), k = ((e3) => (e3[e3.STABLE = 1] = "STABLE", e3[e3.DYNAMIC = 2] = "DYNAMIC", e3[e3.FORWARDED = 3] = "FORWARDED", e3))(k || {}), N = k, D = "Fragment", j = (e3, t3) => e3.get(t3)(), L = (e3) => e3.startsWith("v-") || e3.startsWith("v") && e3.length >= 2 && e3[1] >= "A" && e3[1] <= "Z", M = (e3) => !(e3.match(RegExp(`^_?${D}\\d*$`)) || "KeepAlive" === e3), B = (e3) => {
    const t3 = e3.node.object, r3 = e3.node.property, n3 = h.isJSXMemberExpression(t3) ? B(e3.get("object")) : h.isJSXIdentifier(t3) ? h.identifier(t3.name) : h.nullLiteral(), s3 = h.identifier(r3.name);
    return h.memberExpression(n3, s3);
  }, R = (e3) => {
    const t3 = e3.split(/\r\n|\n|\r/);
    let r3 = 0;
    for (let e4 = 0; e4 < t3.length; e4++) t3[e4].match(/[^ \t]/) && (r3 = e4);
    let n3 = "";
    for (let e4 = 0; e4 < t3.length; e4++) {
      const s3 = t3[e4], i3 = 0 === e4, o3 = e4 === t3.length - 1, a3 = e4 === r3;
      let l2 = s3.replace(/\t/g, " ");
      i3 || (l2 = l2.replace(/^[ ]+/, "")), o3 || (l2 = l2.replace(/[ ]+$/, "")), l2 && (a3 || (l2 += " "), n3 += l2);
    }
    return n3;
  }, F = (e3) => e3.get("expression").node, U = (e3, t3, r3) => {
    e3.scope.hasBinding(t3) && e3.parentPath && (h.isJSXElement(e3.parentPath.node) && e3.parentPath.setData("slotFlag", r3), U(e3.parentPath, t3, r3));
  }, $ = (e3, t3) => {
    const { parentPath: r3 } = e3;
    if (r3.isAssignmentExpression()) {
      const { left: n3 } = r3.node;
      if (h.isIdentifier(n3)) return t3.map((t4) => {
        if (h.isIdentifier(t4) && t4.name === n3.name) {
          const n4 = e3.scope.generateUidIdentifier(t4.name);
          return r3.insertBefore(h.variableDeclaration("const", [h.variableDeclarator(n4, h.callExpression(h.functionExpression(null, [], h.blockStatement([h.returnStatement(t4)])), []))])), n4;
        }
        return t4;
      });
    }
    return t3;
  }, V = /^on[^a-z]/, q = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    if (!(arguments.length > 1 ? arguments[1] : void 0)) return e3;
    const t3 = /* @__PURE__ */ new Map(), r3 = [];
    return e3.forEach((e4) => {
      if (h.isStringLiteral(e4.key)) {
        const { value: n3 } = e4.key, s3 = t3.get(n3);
        s3 ? ("style" === n3 || "class" === n3 || n3.startsWith("on")) && ((e5, t4) => {
          h.isArrayExpression(e5.value) ? e5.value.elements.push(t4.value) : e5.value = h.arrayExpression([e5.value, t4.value]);
        })(s3, e4) : (t3.set(n3, e4), r3.push(e4));
      } else r3.push(e4);
    }), r3;
  }, W = (e3) => {
    if (h.isIdentifier(e3)) return "undefined" === e3.name;
    if (h.isArrayExpression(e3)) {
      const { elements: t3 } = e3;
      return t3.every((e4) => e4 && W(e4));
    }
    return h.isObjectExpression(e3) ? e3.properties.every((e4) => W(e4.value)) : !!h.isLiteral(e3);
  }, G = (e3) => h.isArrayExpression(e3) ? e3.elements.map((e4) => h.isStringLiteral(e4) ? e4.value : "").filter(Boolean) : [], H = (e3, t3, r3, n3) => {
    if ("show" === n3) return j(t3, "vShow");
    if ("model" === n3) {
      let n4;
      const s3 = ((e4) => {
        const t4 = e4.get("attributes").find((e5) => !!e5.isJSXAttribute() && e5.get("name").isJSXIdentifier() && "type" === e5.get("name").node.name);
        return t4 ? t4.get("value").node : null;
      })(e3.parentPath);
      switch (r3.value) {
        case "select":
          n4 = j(t3, "vModelSelect");
          break;
        case "textarea":
          n4 = j(t3, "vModelText");
          break;
        default:
          if (h.isStringLiteral(s3) || !s3) switch (null == s3 ? void 0 : s3.value) {
            case "checkbox":
              n4 = j(t3, "vModelCheckbox");
              break;
            case "radio":
              n4 = j(t3, "vModelRadio");
              break;
            default:
              n4 = j(t3, "vModelText");
          }
          else n4 = j(t3, "vModelDynamic");
      }
      return n4;
    }
    return h.callExpression(j(t3, "resolveDirective"), [h.stringLiteral(n3)]);
  }, z = /^xlink([A-Z])/, K = (e3, t3) => {
    const r3 = ((e4, t4) => {
      var r4, n4;
      const s4 = e4.get("openingElement").get("name");
      if (s4.isJSXIdentifier()) {
        const { name: i4 } = s4.node;
        return E.includes(i4) || S.includes(i4) ? h.stringLiteral(i4) : i4 === D ? j(t4, D) : e4.scope.hasBinding(i4) ? h.identifier(i4) : (null == (n4 = (r4 = t4.opts).isCustomElement) ? void 0 : n4.call(r4, i4)) ? h.stringLiteral(i4) : h.callExpression(j(t4, "resolveComponent"), [h.stringLiteral(i4)]);
      }
      if (s4.isJSXMemberExpression()) return B(s4);
      throw new Error(`getTag: ${s4.type} is not supported`);
    })(e3, t3), n3 = ((e4, t4) => {
      var r4, n4;
      const s4 = e4.get("name");
      if (s4.isJSXMemberExpression()) return M(s4.node.property.name);
      const i4 = s4.node.name;
      return !(null == (n4 = (r4 = t4.opts).isCustomElement) ? void 0 : n4.call(r4, i4)) && M(i4) && !E.includes(i4) && !S.includes(i4);
    })(e3.get("openingElement"), t3), s3 = e3.get("openingElement").get("attributes"), i3 = [], o3 = /* @__PURE__ */ new Set();
    let a3 = null, l2 = 0;
    if (0 === s3.length) return { tag: r3, isComponent: n3, slots: a3, props: h.nullLiteral(), directives: i3, patchFlag: l2, dynamicPropNames: o3 };
    let c2 = [], u2 = false, p2 = false, d2 = false, f2 = false, m2 = false;
    const y2 = [], { mergeProps: b2 = true } = t3.opts;
    s3.forEach((s4) => {
      if (s4.isJSXAttribute()) {
        let b3 = ((e4) => {
          const t4 = e4.node.name;
          return h.isJSXIdentifier(t4) ? t4.name : `${t4.namespace.name}:${t4.name.name}`;
        })(s4);
        const v3 = ((e4, t4) => {
          const r4 = e4.get("value");
          return r4.isJSXElement() ? X(r4, t4) : r4.isStringLiteral() ? h.stringLiteral(R(r4.node.value)) : r4.isJSXExpressionContainer() ? F(r4) : null;
        })(s4, t3);
        if (W(v3) && "ref" !== b3 || (!n3 && (l3 = b3, V.test(l3)) && "onclick" !== b3.toLowerCase() && "onUpdate:modelValue" !== b3 && (f2 = true), "ref" === b3 ? u2 = true : "class" !== b3 || n3 ? "style" !== b3 || n3 ? "key" === b3 || L(b3) || "on" === b3 || o3.add(b3) : d2 = true : p2 = true), t3.opts.transformOn && ("on" === b3 || "nativeOn" === b3)) return t3.get("transformOn") || t3.set("transformOn", (0, g.addDefault)(e3, "@vue/babel-helper-vue-transform-on", { nameHint: "_transformOn" })), void y2.push(h.callExpression(t3.get("transformOn"), [v3 || h.booleanLiteral(true)]));
        if (L(b3)) {
          const { directive: e4, modifiers: l4, values: u3, args: p3, directiveName: d3 } = ((e5) => {
            var t4, r4;
            const { path: n4, value: s5, state: i4, tag: o4, isComponent: a4 } = e5, l5 = [], c3 = [], u4 = [];
            let p4, d4, f3;
            if ("namespace" in n4.node.name) [p4, d4] = e5.name.split(":"), p4 = n4.node.name.namespace.name, d4 = n4.node.name.name.name, f3 = d4.split("_").slice(1);
            else {
              const t5 = e5.name.split("_");
              p4 = t5.shift() || "", f3 = t5;
            }
            p4 = p4.replace(/^v/, "").replace(/^-/, "").replace(/^\S/, (e6) => e6.toLowerCase()), d4 && l5.push(h.stringLiteral(d4.split("_")[0]));
            const m3 = "models" === p4, y3 = "model" === p4;
            if (y3 && !n4.get("value").isJSXExpressionContainer()) throw new Error("You have to use JSX Expression inside your v-model");
            if (m3 && !a4) throw new Error("v-models can only use in custom components");
            const g2 = !["html", "text", "model", "models"].includes(p4) || y3 && !a4;
            let b4 = f3;
            return h.isArrayExpression(s5) ? (m3 ? s5.elements : [s5]).forEach((e6) => {
              if (m3 && !h.isArrayExpression(e6)) throw new Error("You should pass a Two-dimensional Arrays to v-models");
              const { elements: t5 } = e6, [r5, n5, s6] = t5;
              !n5 || h.isArrayExpression(n5) || h.isSpreadElement(n5) ? h.isArrayExpression(n5) ? (g2 || l5.push(h.nullLiteral()), b4 = G(n5)) : g2 || l5.push(h.nullLiteral()) : (l5.push(n5), b4 = G(s6)), u4.push(new Set(b4)), c3.push(r5);
            }) : y3 && !g2 ? (l5.push(h.nullLiteral()), u4.push(new Set(f3))) : u4.push(new Set(f3)), { directiveName: p4, modifiers: u4, values: c3.length ? c3 : [s5], args: l5, directive: g2 ? [H(n4, i4, o4, p4), c3[0] || s5, (null == (t4 = u4[0]) ? void 0 : t4.size) ? l5[0] || h.unaryExpression("void", h.numericLiteral(0), true) : l5[0], !!(null == (r4 = u4[0]) ? void 0 : r4.size) && h.objectExpression([...u4[0]].map((e6) => h.objectProperty(h.identifier(e6), h.booleanLiteral(true))))].filter(Boolean) : void 0 };
          })({ tag: r3, isComponent: n3, name: b3, path: s4, state: t3, value: v3 });
          if ("slots" === d3) return void (a3 = v3);
          e4 ? i3.push(h.arrayExpression(e4)) : "html" === d3 ? (c2.push(h.objectProperty(h.stringLiteral("innerHTML"), u3[0])), o3.add("innerHTML")) : "text" === d3 && (c2.push(h.objectProperty(h.stringLiteral("textContent"), u3[0])), o3.add("textContent")), ["models", "model"].includes(d3) && u3.forEach((t4, r4) => {
            var n4;
            const s5 = p3[r4], i4 = s5 && !h.isStringLiteral(s5) && !h.isNullLiteral(s5);
            e4 || (c2.push(h.objectProperty(h.isNullLiteral(s5) ? h.stringLiteral("modelValue") : s5, t4, i4)), i4 || o3.add((null == s5 ? void 0 : s5.value) || "modelValue"), (null == (n4 = l4[r4]) ? void 0 : n4.size) && c2.push(h.objectProperty(i4 ? h.binaryExpression("+", s5, h.stringLiteral("Modifiers")) : h.stringLiteral(`${(null == s5 ? void 0 : s5.value) || "model"}Modifiers`), h.objectExpression([...l4[r4]].map((e5) => h.objectProperty(h.stringLiteral(e5), h.booleanLiteral(true)))), i4)));
            const a4 = i4 ? h.binaryExpression("+", h.stringLiteral("onUpdate"), s5) : h.stringLiteral(`onUpdate:${(null == s5 ? void 0 : s5.value) || "modelValue"}`);
            c2.push(h.objectProperty(a4, h.arrowFunctionExpression([h.identifier("$event")], h.assignmentExpression("=", t4, h.identifier("$event"))), i4)), i4 ? m2 = true : o3.add(a4.value);
          });
        } else b3.match(z) && (b3 = b3.replace(z, (e4, t4) => `xlink:${t4.toLowerCase()}`)), c2.push(h.objectProperty(h.stringLiteral(b3), v3 || h.booleanLiteral(true)));
      } else c2.length && b2 && (y2.push(h.objectExpression(q(c2, b2))), c2 = []), m2 = true, ((e4, t4, r4, n4) => {
        const s5 = t4.get("argument"), i4 = h.isObjectExpression(s5.node) ? s5.node.properties : void 0;
        i4 ? r4 ? n4.push(h.objectExpression(i4)) : n4.push(...i4) : (s5.isIdentifier() && U(e4, s5.node.name, N.DYNAMIC), n4.push(r4 ? s5.node : h.spreadElement(s5.node)));
      })(e3, s4, b2, b2 ? y2 : c2);
      var l3;
    }), m2 ? l2 |= 16 : (p2 && (l2 |= 2), d2 && (l2 |= 4), o3.size && (l2 |= 8), f2 && (l2 |= 32)), 0 !== l2 && 32 !== l2 || !(u2 || i3.length > 0) || (l2 |= 512);
    let v2 = h.nullLiteral();
    return y2.length ? (c2.length && y2.push(h.objectExpression(q(c2, b2))), v2 = y2.length > 1 ? h.callExpression(j(t3, "mergeProps"), y2) : y2[0]) : c2.length && (v2 = 1 === c2.length && h.isSpreadElement(c2[0]) ? c2[0].argument : h.objectExpression(q(c2, b2))), { tag: r3, props: v2, isComponent: n3, slots: a3, directives: i3, patchFlag: l2, dynamicPropNames: o3 };
  }, X = (e3, t3) => {
    const r3 = ((e4, t4) => e4.map((e5) => {
      if (e5.isJSXText()) {
        const r4 = ((e6) => {
          const t5 = R(e6.node.value);
          return "" !== t5 ? h.stringLiteral(t5) : null;
        })(e5);
        return r4 ? h.callExpression(j(t4, "createTextVNode"), [r4]) : r4;
      }
      if (e5.isJSXExpressionContainer()) {
        const t5 = F(e5);
        if (h.isIdentifier(t5)) {
          const { name: r4 } = t5, { referencePaths: n4 = [] } = e5.scope.getBinding(r4) || {};
          n4.forEach((e6) => {
            U(e6, r4, N.DYNAMIC);
          });
        }
        return t5;
      }
      if (e5.isJSXSpreadChild()) return ((e6) => h.spreadElement(e6.get("expression").node))(e5);
      if (e5.isCallExpression()) return e5.node;
      if (e5.isJSXElement()) return X(e5, t4);
      throw new Error(`getChildren: ${e5.type} is not supported`);
    }).filter((e5) => null != e5 && !h.isJSXEmptyExpression(e5)))(e3.get("children"), t3), { tag: n3, props: s3, isComponent: i3, directives: o3, patchFlag: a3, dynamicPropNames: l2, slots: c2 } = K(e3, t3), { optimize: u2 = false } = t3.opts, p2 = e3.getData("slotFlag") || N.STABLE;
    let d2;
    if (r3.length > 1 || c2) d2 = i3 ? r3.length ? h.objectExpression([!!r3.length && h.objectProperty(h.identifier("default"), h.arrowFunctionExpression([], h.arrayExpression($(e3, r3)))), ...c2 ? h.isObjectExpression(c2) ? c2.properties : [h.spreadElement(c2)] : [], u2 && h.objectProperty(h.identifier("_"), h.numericLiteral(p2))].filter(Boolean)) : c2 : h.arrayExpression(r3);
    else if (1 === r3.length) {
      const { enableObjectSlots: n4 = true } = t3.opts, s4 = r3[0], o4 = h.objectExpression([h.objectProperty(h.identifier("default"), h.arrowFunctionExpression([], h.arrayExpression($(e3, [s4])))), u2 && h.objectProperty(h.identifier("_"), h.numericLiteral(p2))].filter(Boolean));
      if (h.isIdentifier(s4) && i3) d2 = n4 ? h.conditionalExpression(h.callExpression(t3.get("@vue/babel-plugin-jsx/runtimeIsSlot")(), [s4]), s4, o4) : o4;
      else if (h.isCallExpression(s4) && s4.loc && i3) if (n4) {
        const { scope: r4 } = e3, n5 = r4.generateUidIdentifier("slot");
        r4 && r4.push({ id: n5, kind: "let" });
        const i4 = h.objectExpression([h.objectProperty(h.identifier("default"), h.arrowFunctionExpression([], h.arrayExpression($(e3, [n5])))), u2 && h.objectProperty(h.identifier("_"), h.numericLiteral(p2))].filter(Boolean)), o5 = h.assignmentExpression("=", n5, s4), a4 = h.callExpression(t3.get("@vue/babel-plugin-jsx/runtimeIsSlot")(), [o5]);
        d2 = h.conditionalExpression(a4, n5, i4);
      } else d2 = o4;
      else d2 = h.isFunctionExpression(s4) || h.isArrowFunctionExpression(s4) ? h.objectExpression([h.objectProperty(h.identifier("default"), s4)]) : h.isObjectExpression(s4) ? h.objectExpression([...s4.properties, u2 && h.objectProperty(h.identifier("_"), h.numericLiteral(p2))].filter(Boolean)) : i3 ? h.objectExpression([h.objectProperty(h.identifier("default"), h.arrowFunctionExpression([], h.arrayExpression([s4])))]) : h.arrayExpression([s4]);
    }
    const f2 = h.callExpression(j(t3, "createVNode"), [n3, s3, d2 || h.nullLiteral(), !!a3 && u2 && h.numericLiteral(a3), !!l2.size && u2 && h.arrayExpression([...l2.keys()].map((e4) => h.stringLiteral(e4)))].filter(Boolean));
    return o3.length ? h.callExpression(j(t3, "withDirectives"), [f2, h.arrayExpression(o3)]) : f2;
  }, J = { JSXElement: { exit(e3, t3) {
    e3.replaceWith(X(e3, t3));
  } } }, Y = { JSXFragment: { enter(e3, t3) {
    const r3 = j(t3, D);
    e3.replaceWith(((e4, t4) => {
      const r4 = e4.get("children") || [];
      return h.jsxElement(h.jsxOpeningElement(t4, []), h.jsxClosingElement(t4), r4.map((e5) => {
        let { node: t5 } = e5;
        return t5;
      }), false);
    })(e3, h.isIdentifier(r3) ? h.jsxIdentifier(r3.name) : h.jsxMemberExpression(h.jsxIdentifier(r3.object.name), h.jsxIdentifier(r3.property.name))));
  } } }, Q = /\*?\s*@jsx\s+([^\s]+)/;
  function Z(e3) {
    return e3.default || e3;
  }
  var ee = Z(y), te = Z(m), re = (0, v.declare)((e3, t3, r3) => {
    const { types: n3 } = e3;
    let s3;
    return t3.resolveType && ("boolean" == typeof t3.resolveType && (t3.resolveType = {}), s3 = b(e3, t3.resolveType, r3)), _(I({}, s3 || {}), { name: "babel-plugin-jsx", inherits: Z(ee), visitor: _(I(I(I({}, null == s3 ? void 0 : s3.visitor), J), Y), { Program: { enter(e4, t4) {
      if (((e5) => {
        let t5 = false;
        return e5.traverse({ JSXElement(e6) {
          t5 = true, e6.stop();
        }, JSXFragment(e6) {
          t5 = true, e6.stop();
        } }), t5;
      })(e4)) {
        const r4 = ["createVNode", "Fragment", "resolveComponent", "withDirectives", "vShow", "vModelSelect", "vModelText", "vModelCheckbox", "vModelRadio", "vModelText", "vModelDynamic", "resolveDirective", "mergeProps", "createTextVNode", "isVNode"];
        if ((0, g.isModule)(e4)) {
          const s5 = {};
          r4.forEach((r5) => {
            t4.set(r5, () => {
              if (s5[r5]) return n3.cloneNode(s5[r5]);
              const t5 = (0, g.addNamed)(e4, r5, "vue", { ensureLiveReference: true });
              return s5[r5] = t5, t5;
            });
          });
          const { enableObjectSlots: i4 = true } = t4.opts;
          i4 && t4.set("@vue/babel-plugin-jsx/runtimeIsSlot", () => {
            if (s5.runtimeIsSlot) return s5.runtimeIsSlot;
            const { name: r5 } = t4.get("isVNode")(), n4 = e4.scope.generateUidIdentifier("isSlot"), i5 = te.ast`
                    function ${n4.name}(s) {
                      return typeof s === 'function' || (Object.prototype.toString.call(s) === '[object Object]' && !${r5}(s));
                    }
                  `, o3 = e4.get("body").filter((e5) => e5.isImportDeclaration()).pop();
            return o3 && o3.insertAfter(i5), s5.runtimeIsSlot = n4, n4;
          });
        } else {
          let n4;
          r4.forEach((r5) => {
            t4.set(r5, () => (n4 || (n4 = (0, g.addNamespace)(e4, "vue", { ensureLiveReference: true })), h.memberExpression(n4, h.identifier(r5))));
          });
          const s5 = {}, { enableObjectSlots: i4 = true } = t4.opts;
          i4 && t4.set("@vue/babel-plugin-jsx/runtimeIsSlot", () => {
            if (s5.runtimeIsSlot) return s5.runtimeIsSlot;
            const r5 = e4.scope.generateUidIdentifier("isSlot"), { object: i5 } = t4.get("isVNode")(), o3 = te.ast`
                    function ${r5.name}(s) {
                      return typeof s === 'function' || (Object.prototype.toString.call(s) === '[object Object]' && !${i5.name}.isVNode(s));
                    }
                  `, a3 = e4.get("body").filter((e5) => e5.isVariableDeclaration() && e5.node.declarations.some((e6) => {
              var t5;
              return (null == (t5 = e6.id) ? void 0 : t5.name) === n4.name;
            })).pop();
            return a3 && a3.insertAfter(o3), r5;
          });
        }
        const { opts: { pragma: s4 = "" }, file: i3 } = t4;
        if (s4 && t4.set("createVNode", () => h.identifier(s4)), i3.ast.comments) for (const e5 of i3.ast.comments) {
          const r5 = Q.exec(e5.value);
          r5 && t4.set("createVNode", () => h.identifier(r5[1]));
        }
      }
    }, exit(e4) {
      const t4 = e4.get("body"), r4 = /* @__PURE__ */ new Map();
      t4.filter((e5) => h.isImportDeclaration(e5.node) && "vue" === e5.node.source.value).forEach((e5) => {
        const { specifiers: t5 } = e5.node;
        let n5 = false;
        t5.forEach((e6) => {
          !e6.loc && h.isImportSpecifier(e6) && h.isIdentifier(e6.imported) && (r4.set(e6.imported.name, e6), n5 = true);
        }), n5 && e5.remove();
      });
      const n4 = [...r4.keys()].map((e5) => r4.get(e5));
      n4.length && e4.unshiftContainer("body", h.importDeclaration(n4, h.stringLiteral("vue")));
    } } }) });
  });
  const ne = ue(...Object.keys(Object.assign({}, { "@babel/plugin-transform-class-static-block": r2(344), "@babel/plugin-transform-parameters": r2(345) }))), se = false, ie = true, oe = false, ae = "0.9.5";
  function le(e3, t3, r3) {
    return t3 + "\n" + e3;
  }
  function ce(e3, t3, r3, n3, s3) {
    if (!n3) return le(e3, t3);
    const i3 = { start: { line: n3, column: s3 } };
    return le((0, o2.codeFrameColumns)(r3, i3, { message: e3 }), t3);
  }
  function ue() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    return t3.reduce((e4, t4) => e4.append(String(t4)), new (u())()).end();
  }
  async function pe(e3, t3, r3) {
    let n3 = false;
    const s3 = { preventCache: () => n3 = true };
    if (void 0 === e3) return await r3(s3);
    const i3 = ue(...t3), o3 = await e3.get(i3);
    if (void 0 !== o3) return JSON.parse(o3);
    const a3 = await r3(s3);
    return false === n3 && await e3.set(i3, JSON.stringify(a3)), a3;
  }
  class de {
    constructor(e3) {
      this.promise = e3;
    }
  }
  const fe = Object.assign({}, { "@babel/plugin-transform-class-static-block": r2(344), "@babel/plugin-transform-parameters": r2(345) });
  async function he(e3, t3, r3, n3, o3, l2) {
    let c2, u2 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
    try {
      c2 = (0, i2.parse)(e3, { sourceType: t3 ? "module" : "script", sourceFilename: r3.toString(), plugins: [...void 0 !== n3 ? n3 : []] });
    } catch (t4) {
      throw null == l2 || l2("error", "parse script", ce(t4.message, r3.toString(), e3, t4.loc.line, t4.loc.column + 1)), t4;
    }
    var p2;
    p2 = c2, (0, s2.traverse)(p2, { CallExpression(e4) {
      s2.types.isImport(e4.node.callee) && e4.replaceWith(s2.types.callExpression(s2.types.identifier("__vsfcl_import__"), e4.node.arguments));
    } });
    const d2 = function(e4) {
      const t4 = [];
      return (0, s2.traverse)(e4, { ExportAllDeclaration(e5) {
        t4.push(e5.node.source.value);
      }, ImportDeclaration(e5) {
        t4.push(e5.node.source.value);
      }, CallExpression(e5) {
        "require" === e5.node.callee.name && 1 === e5.node.arguments.length && s2.types.isStringLiteral(e5.node.arguments[0]) && t4.push(e5.node.arguments[0].value);
      } }), t4;
    }(c2), f2 = await (0, s2.transformFromAstAsync)(c2, e3, { sourceMaps: oe, plugins: [...t3 ? [a2.a] : [], ...Object.values(fe), ...void 0 !== o3 ? Object.values(o3) : []], babelrc: false, configFile: false, highlightCode: false, compact: !u2, comments: u2, retainLines: u2, sourceType: t3 ? "module" : "script" });
    if (null === f2 || null == f2.code) {
      const e4 = `unable to transform script "${r3.toString()}"`;
      throw null == l2 || l2("error", e4), new Error(e4);
    }
    return [d2, f2.code];
  }
  async function me(e3, t3) {
    const { moduleCache: r3, loadModule: n3, handleModule: s3 } = t3, { id: i3, path: o3, getContent: a3 } = t3.getResource(e3, t3);
    return i3 in r3 ? r3[i3] instanceof de ? await r3[i3].promise : r3[i3] : (r3[i3] = new de((async () => {
      let e4;
      if (n3 && (e4 = await n3(i3, t3)), void 0 === e4) {
        const { getContentData: r4, type: n4 } = await a3();
        if (void 0 !== s3 && (e4 = await s3(n4, r4, o3, t3)), void 0 === e4 && (e4 = await async function(e5, t4, r5, n5) {
          var s4, i4;
          switch (e5) {
            case ".vue":
              return async function(e6, t5, r6) {
                var n6, s5, i5, o4, a4;
                const c2 = t5.toString(), u2 = {}, { delimiters: h2, whitespace: m2, isCustomElement: y2, moduleCache: g2, compiledCache: b2, getResource: v2, addStyle: E2, log: S2, additionalBabelParserPlugins: x2 = [], additionalBabelPlugins: T2 = {}, customBlockHandler: w2, devMode: P2 = false, createCJSModule: A2, processStyles: C2 } = r6, { descriptor: O2, errors: I2 } = (0, p.parse)(e6, { filename: c2, sourceMap: se }), _2 = void 0 !== w2 ? await Promise.all(O2.customBlocks.map((e7) => w2(e7, t5, r6))) : [], k2 = `data-v-${ue(c2)}`, N2 = O2.styles.some((e7) => e7.scoped);
                N2 && (u2.__scopeId = k2), O2.template && O2.template.lang && await me({ refPath: t5, relPath: O2.template.lang }, r6);
                const D2 = O2.template ? { compiler: Object.assign(Object.assign({}, d), { compile: (e7, t6) => f.compile(e7, Object.assign(Object.assign({}, t6), { sourceMap: se })) }), source: O2.template.src ? await (await v2({ refPath: t5, relPath: O2.template.src }, r6).getContent()).getContentData(false) : O2.template.content, filename: O2.filename, isProd: ie, scoped: N2, id: k2, slotted: O2.slotted, compilerOptions: { isCustomElement: y2, whitespace: m2, delimiters: h2, scopeId: N2 ? k2 : void 0, mode: "module" }, preprocessLang: O2.template.lang, preprocessCustomRequire: (e7) => g2[e7] } : void 0;
                if (O2.script || O2.scriptSetup) {
                  (null === (n6 = O2.script) || void 0 === n6 ? void 0 : n6.src) && (O2.script.content = await (await v2({ refPath: t5, relPath: O2.script.src }, r6).getContent()).getContentData(false));
                  const [e7, d2, f2] = await pe(b2, [Ee, ie, P2, null === (s5 = O2.script) || void 0 === s5 ? void 0 : s5.content, null === (i5 = O2.script) || void 0 === i5 ? void 0 : i5.lang, null === (o4 = O2.scriptSetup) || void 0 === o4 ? void 0 : o4.content, null === (a4 = O2.scriptSetup) || void 0 === a4 ? void 0 : a4.lang, x2, Object.keys(T2), ne], async (e8) => {
                    let { preventCache: t6 } = e8;
                    var r7, n7;
                    let s6 = ["jsx"], i6 = { jsx: re };
                    "ts" !== (null === (r7 = O2.script) || void 0 === r7 ? void 0 : r7.lang) && "ts" !== (null === (n7 = O2.scriptSetup) || void 0 === n7 ? void 0 : n7.lang) || (s6 = [...s6, "typescript"], i6 = Object.assign(Object.assign({}, i6), { typescript: l.a }));
                    const o5 = (0, p.compileScript)(O2, { isProd: ie, sourceMap: se, id: k2, babelParserPlugins: [...s6, ...x2], inlineTemplate: false, templateOptions: D2 });
                    return [o5.bindings, ...await he(o5.content, true, c2, [...s6, ...x2], Object.assign(Object.assign({}, i6), T2), S2, P2)];
                  });
                  void 0 !== (null == D2 ? void 0 : D2.compilerOptions) && (D2.compilerOptions.bindingMetadata = e7), await be(t5, d2, r6), Object.assign(u2, (j2 = A2(t5, f2, r6).exports, j2 && j2.__esModule ? j2 : { default: j2 }).default);
                }
                var j2;
                if (null !== O2.template) {
                  const [n7, s6] = await pe(b2, [Ee, P2, D2.source, D2.compilerOptions.delimiters, D2.compilerOptions.whitespace, D2.compilerOptions.scopeId, D2.compilerOptions.bindingMetadata ? Object.entries(D2.compilerOptions.bindingMetadata) : "", x2, Object.keys(T2), ne], async (t6) => {
                    let { preventCache: r7 } = t6;
                    const n8 = (0, p.compileTemplate)(D2);
                    if (n8.errors.length) {
                      r7();
                      for (const t7 of n8.errors) "object" == typeof t7 ? t7.loc ? null == S2 || S2("error", "SFC template", ce(t7.message, c2, e6, t7.loc.start.line + O2.template.loc.start.line - 1, t7.loc.start.column)) : null == S2 || S2("error", "SFC template", le(t7.message, c2)) : null == S2 || S2("error", "SFC template", le(t7, c2));
                    }
                    for (const e7 of n8.tips) null == S2 || S2("info", "SFC template", e7);
                    return await he(n8.code, true, O2.filename, x2, T2, S2, P2);
                  });
                  await be(t5, n7, r6), Object.assign(u2, A2(t5, s6, r6).exports);
                }
                for (const n7 of O2.styles) {
                  const s6 = n7.src ? await (await v2({ refPath: t5, relPath: n7.src }, r6).getContent()).getContentData(false) : n7.content;
                  E2(await pe(b2, [Ee, s6, n7.lang, k2, n7.scoped], async (i6) => {
                    let { preventCache: o5 } = i6;
                    const a5 = void 0 !== C2 ? await C2(s6, n7.lang, t5, r6) : s6;
                    void 0 === a5 && o5(), void 0 === C2 && void 0 !== n7.lang && await me({ refPath: t5, relPath: n7.lang }, r6);
                    const l2 = await (0, p.compileStyleAsync)(Object.assign({ filename: O2.filename, source: a5, isProd: ie, id: k2, scoped: n7.scoped, trim: true }, void 0 === C2 ? { preprocessLang: n7.lang, preprocessCustomRequire: (e7) => g2[e7] } : {}));
                    if (l2.errors.length) {
                      o5();
                      for (const r7 of l2.errors) null == S2 || S2("error", "SFC style", ce(r7.message, t5, e6, r7.line + n7.loc.start.line - 1, r7.column));
                    }
                    return l2.code;
                  }), n7.scoped ? k2 : void 0);
                }
                return void 0 !== w2 && await Promise.all(_2.map((e7) => null == e7 ? void 0 : e7(u2))), u2;
              }(await t4(false), r5, n5);
            case ".js":
              return ge(await t4(false), false, r5, n5);
            case ".mjs":
              return ge(await t4(false), true, r5, n5);
            case ".ts":
              return ge(await t4(false), true, r5, Object.assign(Object.assign({}, n5), { additionalBabelParserPlugins: ["typescript", ...null !== (s4 = n5.additionalBabelParserPlugins) && void 0 !== s4 ? s4 : []], additionalBabelPlugins: Object.assign({ typescript: l.a }, null !== (i4 = n5.additionalBabelPlugins) && void 0 !== i4 ? i4 : {}) }));
          }
        }(n4, r4, o3, t3)), void 0 === e4) throw new TypeError(`Unable to handle ${n4} files (${o3})`);
      }
      return r3[i3] = e4;
    })()), await r3[i3].promise);
  }
  function ye(e3, t3, r3) {
    const { moduleCache: n3, pathResolve: s3, getResource: i3 } = r3, o3 = { exports: {} };
    return Function("exports", "require", "module", "__filename", "__dirname", "__vsfcl_import__", t3).call(o3.exports, o3.exports, function(t4) {
      const { id: s4 } = i3({ refPath: e3, relPath: t4 }, r3);
      if (s4 in n3) return n3[s4];
      throw new Error(`require(${JSON.stringify(s4)}) failed. module not found in moduleCache`);
    }, o3, e3, s3({ refPath: e3, relPath: "." }, r3), async function(t4) {
      return await me({ refPath: e3, relPath: t4 }, r3);
    }), o3;
  }
  async function ge(e3, t3, r3, n3) {
    const { compiledCache: s3, additionalBabelParserPlugins: i3, additionalBabelPlugins: o3, createCJSModule: a3, log: l2 } = n3, [c2, u2] = await pe(s3, [ae, e3, r3, n3.devMode, i3 || "", o3 ? Object.keys(o3) : ""], async () => await he(e3, t3, r3, i3, o3, l2, n3.devMode));
    return await be(r3, c2, n3), a3(r3, u2, n3).exports;
  }
  async function be(e3, t3, r3) {
    await Promise.all(t3.map((t4) => me({ refPath: e3, relPath: t4 }, r3)));
  }
  const ve = "0.9.5", Ee = "3.4.15";
  function Se(e3) {
    throw new ReferenceError(`${e3} is not defined`);
  }
  const xe = (e3) => {
    const t3 = e3.indexOf("?");
    return -1 !== t3 ? e3.slice(0, t3) : e3;
  }, Te = (e3, t3) => {
    let { refPath: r3, relPath: s3 } = e3;
    const { getPathname: i3 } = t3;
    if (void 0 === r3) return s3;
    const o3 = s3.toString();
    return "." !== o3[0] ? s3 : n2.posix.normalize(n2.posix.join(n2.posix.dirname(i3(r3.toString())), o3));
  };
  function we(e3, t3) {
    const { pathResolve: r3, getPathname: s3, getFile: i3, log: o3 } = t3, a3 = r3(e3, t3), l2 = a3.toString();
    return { id: l2, path: a3, getContent: async () => {
      const e4 = await i3(a3);
      return "string" == typeof e4 || e4 instanceof ArrayBuffer ? { type: n2.posix.extname(s3(l2)), getContentData: async (t4) => (e4 instanceof ArrayBuffer !== t4 && (null == o3 || o3("warn", `unexpected data type. ${t4 ? "binary" : "string"} is expected for "${a3}"`)), e4) } : (e4 || null == o3 || o3("error", `There is no file avaialable such as "${a3}"`), { type: void 0 !== e4.type ? e4.type : n2.posix.extname(s3(l2)), getContentData: e4.getContentData });
    } };
  }
  async function Pe(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Se("options");
    var r3;
    const { moduleCache: n3 = Se("options.moduleCache"), getFile: s3 = Se("options.getFile()"), addStyle: i3 = Se("options.addStyle()"), pathResolve: o3 = Te, getResource: a3 = we, createCJSModule: l2 = ye, getPathname: c2 = xe } = t3;
    n3 instanceof Object && Object.setPrototypeOf(n3, null);
    const u2 = Object.assign({ moduleCache: n3, pathResolve: o3, getResource: a3, createCJSModule: l2, getPathname: c2 }, t3);
    return t3.devMode && void 0 === t3.compiledCache && (null === (r3 = t3.log) || void 0 === r3 || r3.call(t3, "info", "options.compiledCache is not defined, performance will be affected")), await me({ refPath: void 0, relPath: e3 }, u2);
  }
  function Ae(e3) {
    return { render: (t3, r3, n3) => {
      try {
        const s3 = e3(t3, r3);
        "string" == typeof s3 ? n3(null, s3) : (s3.then((e4) => {
          n3(null, e4);
        }), s3.catch((e4) => {
          n3(e4, null);
        }));
      } catch (e4) {
        n3(e4, null);
      }
    } };
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  const n2 = (0, r2(164).default)("React.Component");
  t2.default = n2;
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return !!e3 && /^[a-z]/.test(e3);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const t3 = [];
    for (let r3 = 0; r3 < e3.children.length; r3++) {
      let i2 = e3.children[r3];
      (0, n2.isJSXText)(i2) ? (0, s2.default)(i2, t3) : ((0, n2.isJSXExpressionContainer)(i2) && (i2 = i2.expression), (0, n2.isJSXEmptyExpression)(i2) || t3.push(i2));
    }
    return t3;
  };
  var n2 = r2(2), s2 = r2(351);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const r3 = e3.value.split(/\r\n|\n|\r/);
    let i2 = 0;
    for (let e4 = 0; e4 < r3.length; e4++) r3[e4].match(/[^ \t]/) && (i2 = e4);
    let o2 = "";
    for (let e4 = 0; e4 < r3.length; e4++) {
      const t4 = r3[e4], n3 = 0 === e4, s3 = e4 === r3.length - 1, a2 = e4 === i2;
      let l = t4.replace(/\t/g, " ");
      n3 || (l = l.replace(/^[ ]+/, "")), s3 || (l = l.replace(/[ ]+$/, "")), l && (a2 || (l += " "), o2 += l);
    }
    o2 && t3.push((0, s2.inherits)((0, n2.stringLiteral)(o2), e3));
  };
  var n2 = r2(4), s2 = r2(0);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const t3 = s2.BUILDER_KEYS[e3.type];
    for (const r3 of t3) (0, n2.default)(e3, r3, e3[r3]);
    return e3;
  };
  var n2 = r2(97), s2 = r2(0);
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isIdentifierChar = u, t2.isIdentifierName = function(e3) {
    let t3 = true;
    for (let r3 = 0; r3 < e3.length; r3++) {
      let n3 = e3.charCodeAt(r3);
      if (55296 == (64512 & n3) && r3 + 1 < e3.length) {
        const t4 = e3.charCodeAt(++r3);
        56320 == (64512 & t4) && (n3 = 65536 + ((1023 & n3) << 10) + (1023 & t4));
      }
      if (t3) {
        if (t3 = false, !c(n3)) return false;
      } else if (!u(n3)) return false;
    }
    return !t3;
  }, t2.isIdentifierStart = c;
  let r2 = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", n2 = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
  const s2 = new RegExp("[" + r2 + "]"), i2 = new RegExp("[" + r2 + n2 + "]");
  r2 = n2 = null;
  const o2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], a2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function l(e3, t3) {
    let r3 = 65536;
    for (let n3 = 0, s3 = t3.length; n3 < s3; n3 += 2) {
      if (r3 += t3[n3], r3 > e3) return false;
      if (r3 += t3[n3 + 1], r3 >= e3) return true;
    }
    return false;
  }
  function c(e3) {
    return e3 < 65 ? 36 === e3 : e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && s2.test(String.fromCharCode(e3)) : l(e3, o2)));
  }
  function u(e3) {
    return e3 < 48 ? 36 === e3 : e3 < 58 || !(e3 < 65) && (e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && i2.test(String.fromCharCode(e3)) : l(e3, o2) || l(e3, a2))));
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isKeyword = function(e3) {
    return r2.has(e3);
  }, t2.isReservedWord = i2, t2.isStrictBindOnlyReservedWord = a2, t2.isStrictBindReservedWord = function(e3, t3) {
    return o2(e3, t3) || a2(e3);
  }, t2.isStrictReservedWord = o2;
  const r2 = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), n2 = /* @__PURE__ */ new Set(["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"]), s2 = /* @__PURE__ */ new Set(["eval", "arguments"]);
  function i2(e3, t3) {
    return t3 && "await" === e3 || "enum" === e3;
  }
  function o2(e3, t3) {
    return i2(e3, t3) || n2.has(e3);
  }
  function a2(e3) {
    return s2.has(e3);
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.readCodePoint = c, t2.readInt = l, t2.readStringContents = function(e3, t3, r3, n3, s3, a3) {
    const l2 = r3, c2 = n3, u = s3;
    let p = "", d = null, f = r3;
    const { length: h } = t3;
    for (; ; ) {
      if (r3 >= h) {
        a3.unterminated(l2, c2, u), p += t3.slice(f, r3);
        break;
      }
      const m = t3.charCodeAt(r3);
      if (i2(e3, m, t3, r3)) {
        p += t3.slice(f, r3);
        break;
      }
      if (92 === m) {
        p += t3.slice(f, r3);
        const i3 = o2(t3, r3, n3, s3, "template" === e3, a3);
        null !== i3.ch || d ? p += i3.ch : d = { pos: r3, lineStart: n3, curLine: s3 }, { pos: r3, lineStart: n3, curLine: s3 } = i3, f = r3;
      } else 8232 === m || 8233 === m ? (++s3, n3 = ++r3) : 10 === m || 13 === m ? "template" === e3 ? (p += t3.slice(f, r3) + "\n", ++r3, 13 === m && 10 === t3.charCodeAt(r3) && ++r3, ++s3, f = n3 = r3) : a3.unterminated(l2, c2, u) : ++r3;
    }
    return { pos: r3, str: p, firstInvalidLoc: d, lineStart: n3, curLine: s3, containsInvalid: !!d };
  };
  var r2 = function(e3) {
    return e3 >= 48 && e3 <= 57;
  };
  const n2 = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, s2 = { bin: (e3) => 48 === e3 || 49 === e3, oct: (e3) => e3 >= 48 && e3 <= 55, dec: (e3) => e3 >= 48 && e3 <= 57, hex: (e3) => e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102 };
  function i2(e3, t3, r3, n3) {
    return "template" === e3 ? 96 === t3 || 36 === t3 && 123 === r3.charCodeAt(n3 + 1) : t3 === ("double" === e3 ? 34 : 39);
  }
  function o2(e3, t3, r3, n3, s3, i3) {
    const o3 = !s3;
    t3++;
    const l2 = (e4) => ({ pos: t3, ch: e4, lineStart: r3, curLine: n3 }), u = e3.charCodeAt(t3++);
    switch (u) {
      case 110:
        return l2("\n");
      case 114:
        return l2("\r");
      case 120: {
        let s4;
        return { code: s4, pos: t3 } = a2(e3, t3, r3, n3, 2, false, o3, i3), l2(null === s4 ? null : String.fromCharCode(s4));
      }
      case 117: {
        let s4;
        return { code: s4, pos: t3 } = c(e3, t3, r3, n3, o3, i3), l2(null === s4 ? null : String.fromCodePoint(s4));
      }
      case 116:
        return l2("	");
      case 98:
        return l2("\b");
      case 118:
        return l2("\v");
      case 102:
        return l2("\f");
      case 13:
        10 === e3.charCodeAt(t3) && ++t3;
      case 10:
        r3 = t3, ++n3;
      case 8232:
      case 8233:
        return l2("");
      case 56:
      case 57:
        if (s3) return l2(null);
        i3.strictNumericEscape(t3 - 1, r3, n3);
      default:
        if (u >= 48 && u <= 55) {
          const o4 = t3 - 1;
          let a3 = e3.slice(o4, t3 + 2).match(/^[0-7]+/)[0], c2 = parseInt(a3, 8);
          c2 > 255 && (a3 = a3.slice(0, -1), c2 = parseInt(a3, 8)), t3 += a3.length - 1;
          const u2 = e3.charCodeAt(t3);
          if ("0" !== a3 || 56 === u2 || 57 === u2) {
            if (s3) return l2(null);
            i3.strictNumericEscape(o4, r3, n3);
          }
          return l2(String.fromCharCode(c2));
        }
        return l2(String.fromCharCode(u));
    }
  }
  function a2(e3, t3, r3, n3, s3, i3, o3, a3) {
    const c2 = t3;
    let u;
    return { n: u, pos: t3 } = l(e3, t3, r3, n3, 16, s3, i3, false, a3, !o3), null === u && (o3 ? a3.invalidEscapeSequence(c2, r3, n3) : t3 = c2 - 1), { code: u, pos: t3 };
  }
  function l(e3, t3, i3, o3, a3, l2, c2, u, p, d) {
    const f = t3, h = 16 === a3 ? n2.hex : n2.decBinOct, m = 16 === a3 ? s2.hex : 10 === a3 ? s2.dec : 8 === a3 ? s2.oct : s2.bin;
    let y = false, g = 0;
    for (let n3 = 0, s3 = null == l2 ? 1 / 0 : l2; n3 < s3; ++n3) {
      const n4 = e3.charCodeAt(t3);
      let s4;
      if (95 !== n4 || "bail" === u) {
        if (s4 = n4 >= 97 ? n4 - 97 + 10 : n4 >= 65 ? n4 - 65 + 10 : r2(n4) ? n4 - 48 : 1 / 0, s4 >= a3) {
          if (s4 <= 9 && d) return { n: null, pos: t3 };
          if (s4 <= 9 && p.invalidDigit(t3, i3, o3, a3)) s4 = 0;
          else {
            if (!c2) break;
            s4 = 0, y = true;
          }
        }
        ++t3, g = g * a3 + s4;
      } else {
        const r3 = e3.charCodeAt(t3 - 1), n5 = e3.charCodeAt(t3 + 1);
        if (u) {
          if (Number.isNaN(n5) || !m(n5) || h.has(r3) || h.has(n5)) {
            if (d) return { n: null, pos: t3 };
            p.unexpectedNumericSeparator(t3, i3, o3);
          }
        } else {
          if (d) return { n: null, pos: t3 };
          p.numericSeparatorInEscapeSequence(t3, i3, o3);
        }
        ++t3;
      }
    }
    return t3 === f || null != l2 && t3 - f !== l2 || y ? { n: null, pos: t3 } : { n: g, pos: t3 };
  }
  function c(e3, t3, r3, n3, s3, i3) {
    let o3;
    if (123 === e3.charCodeAt(t3)) {
      if (++t3, { code: o3, pos: t3 } = a2(e3, t3, r3, n3, e3.indexOf("}", t3) - t3, true, s3, i3), ++t3, null !== o3 && o3 > 1114111) {
        if (!s3) return { code: null, pos: t3 };
        i3.invalidCodePoint(t3, r3, n3);
      }
    } else ({ code: o3, pos: t3 } = a2(e3, t3, r3, n3, 4, false, s3, i3));
    return { code: o3, pos: t3 };
  }
}, (e2, t2, r2) => {
  var n2 = r2(18);
  const s2 = (0, n2.defineAliasedType)("Flow"), i2 = (e3) => {
    const t3 = "DeclareClass" === e3;
    s2(e3, { builder: ["id", "typeParameters", "extends", "body"], visitor: ["id", "typeParameters", "extends", ...t3 ? ["mixins", "implements"] : [], "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: Object.assign({ id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TypeParameterDeclaration"), extends: (0, n2.validateOptional)((0, n2.arrayOfType)("InterfaceExtends")) }, t3 ? { mixins: (0, n2.validateOptional)((0, n2.arrayOfType)("InterfaceExtends")), implements: (0, n2.validateOptional)((0, n2.arrayOfType)("ClassImplements")) } : {}, { body: (0, n2.validateType)("ObjectTypeAnnotation") }) });
  };
  s2("AnyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("ArrayTypeAnnotation", { visitor: ["elementType"], aliases: ["FlowType"], fields: { elementType: (0, n2.validateType)("FlowType") } }), s2("BooleanTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("BooleanLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("NullLiteralTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("ClassImplements", { visitor: ["id", "typeParameters"], fields: { id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TypeParameterInstantiation") } }), i2("DeclareClass"), s2("DeclareFunction", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)("Identifier"), predicate: (0, n2.validateOptionalType)("DeclaredPredicate") } }), i2("DeclareInterface"), s2("DeclareModule", { builder: ["id", "body", "kind"], visitor: ["id", "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)(["Identifier", "StringLiteral"]), body: (0, n2.validateType)("BlockStatement"), kind: (0, n2.validateOptional)((0, n2.assertOneOf)("CommonJS", "ES")) } }), s2("DeclareModuleExports", { visitor: ["typeAnnotation"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { typeAnnotation: (0, n2.validateType)("TypeAnnotation") } }), s2("DeclareTypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TypeParameterDeclaration"), right: (0, n2.validateType)("FlowType") } }), s2("DeclareOpaqueType", { visitor: ["id", "typeParameters", "supertype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, n2.validateOptionalType)("FlowType"), impltype: (0, n2.validateOptionalType)("FlowType") } }), s2("DeclareVariable", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)("Identifier") } }), s2("DeclareExportDeclaration", { visitor: ["declaration", "specifiers", "source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { declaration: (0, n2.validateOptionalType)("Flow"), specifiers: (0, n2.validateOptional)((0, n2.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])), source: (0, n2.validateOptionalType)("StringLiteral"), default: (0, n2.validateOptional)((0, n2.assertValueType)("boolean")) } }), s2("DeclareExportAllDeclaration", { visitor: ["source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { source: (0, n2.validateType)("StringLiteral"), exportKind: (0, n2.validateOptional)((0, n2.assertOneOf)("type", "value")) } }), s2("DeclaredPredicate", { visitor: ["value"], aliases: ["FlowPredicate"], fields: { value: (0, n2.validateType)("Flow") } }), s2("ExistsTypeAnnotation", { aliases: ["FlowType"] }), s2("FunctionTypeAnnotation", { visitor: ["typeParameters", "params", "rest", "returnType"], aliases: ["FlowType"], fields: { typeParameters: (0, n2.validateOptionalType)("TypeParameterDeclaration"), params: (0, n2.validate)((0, n2.arrayOfType)("FunctionTypeParam")), rest: (0, n2.validateOptionalType)("FunctionTypeParam"), this: (0, n2.validateOptionalType)("FunctionTypeParam"), returnType: (0, n2.validateType)("FlowType") } }), s2("FunctionTypeParam", { visitor: ["name", "typeAnnotation"], fields: { name: (0, n2.validateOptionalType)("Identifier"), typeAnnotation: (0, n2.validateType)("FlowType"), optional: (0, n2.validateOptional)((0, n2.assertValueType)("boolean")) } }), s2("GenericTypeAnnotation", { visitor: ["id", "typeParameters"], aliases: ["FlowType"], fields: { id: (0, n2.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, n2.validateOptionalType)("TypeParameterInstantiation") } }), s2("InferredPredicate", { aliases: ["FlowPredicate"] }), s2("InterfaceExtends", { visitor: ["id", "typeParameters"], fields: { id: (0, n2.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, n2.validateOptionalType)("TypeParameterInstantiation") } }), i2("InterfaceDeclaration"), s2("InterfaceTypeAnnotation", { visitor: ["extends", "body"], aliases: ["FlowType"], fields: { extends: (0, n2.validateOptional)((0, n2.arrayOfType)("InterfaceExtends")), body: (0, n2.validateType)("ObjectTypeAnnotation") } }), s2("IntersectionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, n2.validate)((0, n2.arrayOfType)("FlowType")) } }), s2("MixedTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("EmptyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("NullableTypeAnnotation", { visitor: ["typeAnnotation"], aliases: ["FlowType"], fields: { typeAnnotation: (0, n2.validateType)("FlowType") } }), s2("NumberLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, n2.validate)((0, n2.assertValueType)("number")) } }), s2("NumberTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("ObjectTypeAnnotation", { visitor: ["properties", "indexers", "callProperties", "internalSlots"], aliases: ["FlowType"], builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"], fields: { properties: (0, n2.validate)((0, n2.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])), indexers: { validate: (0, n2.arrayOfType)("ObjectTypeIndexer"), optional: true, default: [] }, callProperties: { validate: (0, n2.arrayOfType)("ObjectTypeCallProperty"), optional: true, default: [] }, internalSlots: { validate: (0, n2.arrayOfType)("ObjectTypeInternalSlot"), optional: true, default: [] }, exact: { validate: (0, n2.assertValueType)("boolean"), default: false }, inexact: (0, n2.validateOptional)((0, n2.assertValueType)("boolean")) } }), s2("ObjectTypeInternalSlot", { visitor: ["id", "value", "optional", "static", "method"], aliases: ["UserWhitespacable"], fields: { id: (0, n2.validateType)("Identifier"), value: (0, n2.validateType)("FlowType"), optional: (0, n2.validate)((0, n2.assertValueType)("boolean")), static: (0, n2.validate)((0, n2.assertValueType)("boolean")), method: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("ObjectTypeCallProperty", { visitor: ["value"], aliases: ["UserWhitespacable"], fields: { value: (0, n2.validateType)("FlowType"), static: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("ObjectTypeIndexer", { visitor: ["id", "key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { id: (0, n2.validateOptionalType)("Identifier"), key: (0, n2.validateType)("FlowType"), value: (0, n2.validateType)("FlowType"), static: (0, n2.validate)((0, n2.assertValueType)("boolean")), variance: (0, n2.validateOptionalType)("Variance") } }), s2("ObjectTypeProperty", { visitor: ["key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { key: (0, n2.validateType)(["Identifier", "StringLiteral"]), value: (0, n2.validateType)("FlowType"), kind: (0, n2.validate)((0, n2.assertOneOf)("init", "get", "set")), static: (0, n2.validate)((0, n2.assertValueType)("boolean")), proto: (0, n2.validate)((0, n2.assertValueType)("boolean")), optional: (0, n2.validate)((0, n2.assertValueType)("boolean")), variance: (0, n2.validateOptionalType)("Variance"), method: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("ObjectTypeSpreadProperty", { visitor: ["argument"], aliases: ["UserWhitespacable"], fields: { argument: (0, n2.validateType)("FlowType") } }), s2("OpaqueType", { visitor: ["id", "typeParameters", "supertype", "impltype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, n2.validateOptionalType)("FlowType"), impltype: (0, n2.validateType)("FlowType") } }), s2("QualifiedTypeIdentifier", { visitor: ["id", "qualification"], fields: { id: (0, n2.validateType)("Identifier"), qualification: (0, n2.validateType)(["Identifier", "QualifiedTypeIdentifier"]) } }), s2("StringLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, n2.validate)((0, n2.assertValueType)("string")) } }), s2("StringTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("SymbolTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("ThisTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("TupleTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, n2.validate)((0, n2.arrayOfType)("FlowType")) } }), s2("TypeofTypeAnnotation", { visitor: ["argument"], aliases: ["FlowType"], fields: { argument: (0, n2.validateType)("FlowType") } }), s2("TypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TypeParameterDeclaration"), right: (0, n2.validateType)("FlowType") } }), s2("TypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n2.validateType)("FlowType") } }), s2("TypeCastExpression", { visitor: ["expression", "typeAnnotation"], aliases: ["ExpressionWrapper", "Expression"], fields: { expression: (0, n2.validateType)("Expression"), typeAnnotation: (0, n2.validateType)("TypeAnnotation") } }), s2("TypeParameter", { visitor: ["bound", "default", "variance"], fields: { name: (0, n2.validate)((0, n2.assertValueType)("string")), bound: (0, n2.validateOptionalType)("TypeAnnotation"), default: (0, n2.validateOptionalType)("FlowType"), variance: (0, n2.validateOptionalType)("Variance") } }), s2("TypeParameterDeclaration", { visitor: ["params"], fields: { params: (0, n2.validate)((0, n2.arrayOfType)("TypeParameter")) } }), s2("TypeParameterInstantiation", { visitor: ["params"], fields: { params: (0, n2.validate)((0, n2.arrayOfType)("FlowType")) } }), s2("UnionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, n2.validate)((0, n2.arrayOfType)("FlowType")) } }), s2("Variance", { builder: ["kind"], fields: { kind: (0, n2.validate)((0, n2.assertOneOf)("minus", "plus")) } }), s2("VoidTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("EnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { id: (0, n2.validateType)("Identifier"), body: (0, n2.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"]) } }), s2("EnumBooleanBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, n2.validate)((0, n2.assertValueType)("boolean")), members: (0, n2.validateArrayOfType)("EnumBooleanMember"), hasUnknownMembers: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("EnumNumberBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, n2.validate)((0, n2.assertValueType)("boolean")), members: (0, n2.validateArrayOfType)("EnumNumberMember"), hasUnknownMembers: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("EnumStringBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, n2.validate)((0, n2.assertValueType)("boolean")), members: (0, n2.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]), hasUnknownMembers: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("EnumSymbolBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { members: (0, n2.validateArrayOfType)("EnumDefaultedMember"), hasUnknownMembers: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("EnumBooleanMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, n2.validateType)("Identifier"), init: (0, n2.validateType)("BooleanLiteral") } }), s2("EnumNumberMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, n2.validateType)("Identifier"), init: (0, n2.validateType)("NumericLiteral") } }), s2("EnumStringMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, n2.validateType)("Identifier"), init: (0, n2.validateType)("StringLiteral") } }), s2("EnumDefaultedMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, n2.validateType)("Identifier") } }), s2("IndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, n2.validateType)("FlowType"), indexType: (0, n2.validateType)("FlowType") } }), s2("OptionalIndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, n2.validateType)("FlowType"), indexType: (0, n2.validateType)("FlowType"), optional: (0, n2.validate)((0, n2.assertValueType)("boolean")) } });
}, (e2, t2, r2) => {
  var n2 = r2(18);
  const s2 = (0, n2.defineAliasedType)("JSX");
  s2("JSXAttribute", { visitor: ["name", "value"], aliases: ["Immutable"], fields: { name: { validate: (0, n2.assertNodeType)("JSXIdentifier", "JSXNamespacedName") }, value: { optional: true, validate: (0, n2.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer") } } }), s2("JSXClosingElement", { visitor: ["name"], aliases: ["Immutable"], fields: { name: { validate: (0, n2.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") } } }), s2("JSXElement", { builder: ["openingElement", "closingElement", "children", "selfClosing"], visitor: ["openingElement", "children", "closingElement"], aliases: ["Immutable", "Expression"], fields: Object.assign({ openingElement: { validate: (0, n2.assertNodeType)("JSXOpeningElement") }, closingElement: { optional: true, validate: (0, n2.assertNodeType)("JSXClosingElement") }, children: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } }, { selfClosing: { validate: (0, n2.assertValueType)("boolean"), optional: true } }) }), s2("JSXEmptyExpression", {}), s2("JSXExpressionContainer", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, n2.assertNodeType)("Expression", "JSXEmptyExpression") } } }), s2("JSXSpreadChild", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, n2.assertNodeType)("Expression") } } }), s2("JSXIdentifier", { builder: ["name"], fields: { name: { validate: (0, n2.assertValueType)("string") } } }), s2("JSXMemberExpression", { visitor: ["object", "property"], fields: { object: { validate: (0, n2.assertNodeType)("JSXMemberExpression", "JSXIdentifier") }, property: { validate: (0, n2.assertNodeType)("JSXIdentifier") } } }), s2("JSXNamespacedName", { visitor: ["namespace", "name"], fields: { namespace: { validate: (0, n2.assertNodeType)("JSXIdentifier") }, name: { validate: (0, n2.assertNodeType)("JSXIdentifier") } } }), s2("JSXOpeningElement", { builder: ["name", "attributes", "selfClosing"], visitor: ["name", "attributes"], aliases: ["Immutable"], fields: { name: { validate: (0, n2.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") }, selfClosing: { default: false }, attributes: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("JSXAttribute", "JSXSpreadAttribute"))) }, typeParameters: { validate: (0, n2.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), s2("JSXSpreadAttribute", { visitor: ["argument"], fields: { argument: { validate: (0, n2.assertNodeType)("Expression") } } }), s2("JSXText", { aliases: ["Immutable"], builder: ["value"], fields: { value: { validate: (0, n2.assertValueType)("string") } } }), s2("JSXFragment", { builder: ["openingFragment", "closingFragment", "children"], visitor: ["openingFragment", "children", "closingFragment"], aliases: ["Immutable", "Expression"], fields: { openingFragment: { validate: (0, n2.assertNodeType)("JSXOpeningFragment") }, closingFragment: { validate: (0, n2.assertNodeType)("JSXClosingFragment") }, children: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } } }), s2("JSXOpeningFragment", { aliases: ["Immutable"] }), s2("JSXClosingFragment", { aliases: ["Immutable"] });
}, (e2, t2, r2) => {
  var n2 = r2(18), s2 = r2(169);
  const i2 = (0, n2.defineAliasedType)("Miscellaneous");
  i2("Noop", { visitor: [] }), i2("Placeholder", { visitor: [], builder: ["expectedNode", "name"], fields: { name: { validate: (0, n2.assertNodeType)("Identifier") }, expectedNode: { validate: (0, n2.assertOneOf)(...s2.PLACEHOLDERS) } } }), i2("V8IntrinsicIdentifier", { builder: ["name"], fields: { name: { validate: (0, n2.assertValueType)("string") } } });
}, (e2, t2, r2) => {
  var n2 = r2(18);
  (0, n2.default)("ArgumentPlaceholder", {}), (0, n2.default)("BindExpression", { visitor: ["object", "callee"], aliases: ["Expression"], fields: { object: { validate: Object.assign(() => {
  }, { oneOfNodeTypes: ["Expression"] }) }, callee: { validate: Object.assign(() => {
  }, { oneOfNodeTypes: ["Expression"] }) } } }), (0, n2.default)("ImportAttribute", { visitor: ["key", "value"], fields: { key: { validate: (0, n2.assertNodeType)("Identifier", "StringLiteral") }, value: { validate: (0, n2.assertNodeType)("StringLiteral") } } }), (0, n2.default)("Decorator", { visitor: ["expression"], fields: { expression: { validate: (0, n2.assertNodeType)("Expression") } } }), (0, n2.default)("DoExpression", { visitor: ["body"], builder: ["body", "async"], aliases: ["Expression"], fields: { body: { validate: (0, n2.assertNodeType)("BlockStatement") }, async: { validate: (0, n2.assertValueType)("boolean"), default: false } } }), (0, n2.default)("ExportDefaultSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, n2.assertNodeType)("Identifier") } } }), (0, n2.default)("RecordExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("ObjectProperty", "SpreadElement"))) } } }), (0, n2.default)("TupleExpression", { fields: { elements: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("Expression", "SpreadElement"))), default: [] } }, visitor: ["elements"], aliases: ["Expression"] }), (0, n2.default)("DecimalLiteral", { builder: ["value"], fields: { value: { validate: (0, n2.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, n2.default)("ModuleExpression", { visitor: ["body"], fields: { body: { validate: (0, n2.assertNodeType)("Program") } }, aliases: ["Expression"] }), (0, n2.default)("TopicReference", { aliases: ["Expression"] }), (0, n2.default)("PipelineTopicExpression", { builder: ["expression"], visitor: ["expression"], fields: { expression: { validate: (0, n2.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, n2.default)("PipelineBareFunction", { builder: ["callee"], visitor: ["callee"], fields: { callee: { validate: (0, n2.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, n2.default)("PipelinePrimaryTopicReference", { aliases: ["Expression"] });
}, (e2, t2, r2) => {
  var n2 = r2(18), s2 = r2(167), i2 = r2(42);
  const o2 = (0, n2.defineAliasedType)("TypeScript"), a2 = (0, n2.assertValueType)("boolean"), l = () => ({ returnType: { validate: (0, n2.assertNodeType)("TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, n2.assertNodeType)("TSTypeParameterDeclaration", "Noop"), optional: true } });
  o2("TSParameterProperty", { aliases: ["LVal"], visitor: ["parameter"], fields: { accessibility: { validate: (0, n2.assertOneOf)("public", "private", "protected"), optional: true }, readonly: { validate: (0, n2.assertValueType)("boolean"), optional: true }, parameter: { validate: (0, n2.assertNodeType)("Identifier", "AssignmentPattern") }, override: { validate: (0, n2.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("Decorator"))), optional: true } } }), o2("TSDeclareFunction", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, s2.functionDeclarationCommon)(), l()) }), o2("TSDeclareMethod", { visitor: ["decorators", "key", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, s2.classMethodOrDeclareMethodCommon)(), l()) }), o2("TSQualifiedName", { aliases: ["TSEntityName"], visitor: ["left", "right"], fields: { left: (0, n2.validateType)("TSEntityName"), right: (0, n2.validateType)("Identifier") } });
  const c = () => ({ typeParameters: (0, n2.validateOptionalType)("TSTypeParameterDeclaration"), parameters: (0, n2.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]), typeAnnotation: (0, n2.validateOptionalType)("TSTypeAnnotation") }), u = { aliases: ["TSTypeElement"], visitor: ["typeParameters", "parameters", "typeAnnotation"], fields: c() };
  o2("TSCallSignatureDeclaration", u), o2("TSConstructSignatureDeclaration", u);
  const p = () => ({ key: (0, n2.validateType)("Expression"), computed: { default: false }, optional: (0, n2.validateOptional)(a2) });
  o2("TSPropertySignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeAnnotation"], fields: Object.assign({}, p(), { readonly: (0, n2.validateOptional)(a2), typeAnnotation: (0, n2.validateOptionalType)("TSTypeAnnotation"), kind: { validate: (0, n2.assertOneOf)("get", "set") } }) }), o2("TSMethodSignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeParameters", "parameters", "typeAnnotation"], fields: Object.assign({}, c(), p(), { kind: { validate: (0, n2.assertOneOf)("method", "get", "set") } }) }), o2("TSIndexSignature", { aliases: ["TSTypeElement"], visitor: ["parameters", "typeAnnotation"], fields: { readonly: (0, n2.validateOptional)(a2), static: (0, n2.validateOptional)(a2), parameters: (0, n2.validateArrayOfType)("Identifier"), typeAnnotation: (0, n2.validateOptionalType)("TSTypeAnnotation") } });
  const d = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (const e3 of d) o2(e3, { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
  o2("TSThisType", { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
  const f = { aliases: ["TSType"], visitor: ["typeParameters", "parameters", "typeAnnotation"] };
  o2("TSFunctionType", Object.assign({}, f, { fields: c() })), o2("TSConstructorType", Object.assign({}, f, { fields: Object.assign({}, c(), { abstract: (0, n2.validateOptional)(a2) }) })), o2("TSTypeReference", { aliases: ["TSType"], visitor: ["typeName", "typeParameters"], fields: { typeName: (0, n2.validateType)("TSEntityName"), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterInstantiation") } }), o2("TSTypePredicate", { aliases: ["TSType"], visitor: ["parameterName", "typeAnnotation"], builder: ["parameterName", "typeAnnotation", "asserts"], fields: { parameterName: (0, n2.validateType)(["Identifier", "TSThisType"]), typeAnnotation: (0, n2.validateOptionalType)("TSTypeAnnotation"), asserts: (0, n2.validateOptional)(a2) } }), o2("TSTypeQuery", { aliases: ["TSType"], visitor: ["exprName", "typeParameters"], fields: { exprName: (0, n2.validateType)(["TSEntityName", "TSImportType"]), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterInstantiation") } }), o2("TSTypeLiteral", { aliases: ["TSType"], visitor: ["members"], fields: { members: (0, n2.validateArrayOfType)("TSTypeElement") } }), o2("TSArrayType", { aliases: ["TSType"], visitor: ["elementType"], fields: { elementType: (0, n2.validateType)("TSType") } }), o2("TSTupleType", { aliases: ["TSType"], visitor: ["elementTypes"], fields: { elementTypes: (0, n2.validateArrayOfType)(["TSType", "TSNamedTupleMember"]) } }), o2("TSOptionalType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n2.validateType)("TSType") } }), o2("TSRestType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n2.validateType)("TSType") } }), o2("TSNamedTupleMember", { visitor: ["label", "elementType"], builder: ["label", "elementType", "optional"], fields: { label: (0, n2.validateType)("Identifier"), optional: { validate: a2, default: false }, elementType: (0, n2.validateType)("TSType") } });
  const h = { aliases: ["TSType"], visitor: ["types"], fields: { types: (0, n2.validateArrayOfType)("TSType") } };
  o2("TSUnionType", h), o2("TSIntersectionType", h), o2("TSConditionalType", { aliases: ["TSType"], visitor: ["checkType", "extendsType", "trueType", "falseType"], fields: { checkType: (0, n2.validateType)("TSType"), extendsType: (0, n2.validateType)("TSType"), trueType: (0, n2.validateType)("TSType"), falseType: (0, n2.validateType)("TSType") } }), o2("TSInferType", { aliases: ["TSType"], visitor: ["typeParameter"], fields: { typeParameter: (0, n2.validateType)("TSTypeParameter") } }), o2("TSParenthesizedType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n2.validateType)("TSType") } }), o2("TSTypeOperator", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { operator: (0, n2.validate)((0, n2.assertValueType)("string")), typeAnnotation: (0, n2.validateType)("TSType") } }), o2("TSIndexedAccessType", { aliases: ["TSType"], visitor: ["objectType", "indexType"], fields: { objectType: (0, n2.validateType)("TSType"), indexType: (0, n2.validateType)("TSType") } }), o2("TSMappedType", { aliases: ["TSType"], visitor: ["typeParameter", "typeAnnotation", "nameType"], fields: { readonly: (0, n2.validateOptional)((0, n2.assertOneOf)(true, false, "+", "-")), typeParameter: (0, n2.validateType)("TSTypeParameter"), optional: (0, n2.validateOptional)((0, n2.assertOneOf)(true, false, "+", "-")), typeAnnotation: (0, n2.validateOptionalType)("TSType"), nameType: (0, n2.validateOptionalType)("TSType") } }), o2("TSLiteralType", { aliases: ["TSType", "TSBaseType"], visitor: ["literal"], fields: { literal: { validate: function() {
    const e3 = (0, n2.assertNodeType)("NumericLiteral", "BigIntLiteral"), t3 = (0, n2.assertOneOf)("-"), r3 = (0, n2.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
    function s3(n3, s4, o3) {
      (0, i2.default)("UnaryExpression", o3) ? (t3(o3, "operator", o3.operator), e3(o3, "argument", o3.argument)) : r3(n3, s4, o3);
    }
    return s3.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], s3;
  }() } } }), o2("TSExpressionWithTypeArguments", { aliases: ["TSType"], visitor: ["expression", "typeParameters"], fields: { expression: (0, n2.validateType)("TSEntityName"), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterInstantiation") } }), o2("TSInterfaceDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "extends", "body"], fields: { declare: (0, n2.validateOptional)(a2), id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterDeclaration"), extends: (0, n2.validateOptional)((0, n2.arrayOfType)("TSExpressionWithTypeArguments")), body: (0, n2.validateType)("TSInterfaceBody") } }), o2("TSInterfaceBody", { visitor: ["body"], fields: { body: (0, n2.validateArrayOfType)("TSTypeElement") } }), o2("TSTypeAliasDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "typeAnnotation"], fields: { declare: (0, n2.validateOptional)(a2), id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterDeclaration"), typeAnnotation: (0, n2.validateType)("TSType") } }), o2("TSInstantiationExpression", { aliases: ["Expression"], visitor: ["expression", "typeParameters"], fields: { expression: (0, n2.validateType)("Expression"), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterInstantiation") } });
  const m = { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression", "typeAnnotation"], fields: { expression: (0, n2.validateType)("Expression"), typeAnnotation: (0, n2.validateType)("TSType") } };
  o2("TSAsExpression", m), o2("TSSatisfiesExpression", m), o2("TSTypeAssertion", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["typeAnnotation", "expression"], fields: { typeAnnotation: (0, n2.validateType)("TSType"), expression: (0, n2.validateType)("Expression") } }), o2("TSEnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "members"], fields: { declare: (0, n2.validateOptional)(a2), const: (0, n2.validateOptional)(a2), id: (0, n2.validateType)("Identifier"), members: (0, n2.validateArrayOfType)("TSEnumMember"), initializer: (0, n2.validateOptionalType)("Expression") } }), o2("TSEnumMember", { visitor: ["id", "initializer"], fields: { id: (0, n2.validateType)(["Identifier", "StringLiteral"]), initializer: (0, n2.validateOptionalType)("Expression") } }), o2("TSModuleDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { declare: (0, n2.validateOptional)(a2), global: (0, n2.validateOptional)(a2), id: (0, n2.validateType)(["Identifier", "StringLiteral"]), body: (0, n2.validateType)(["TSModuleBlock", "TSModuleDeclaration"]) } }), o2("TSModuleBlock", { aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"], visitor: ["body"], fields: { body: (0, n2.validateArrayOfType)("Statement") } }), o2("TSImportType", { aliases: ["TSType"], visitor: ["argument", "qualifier", "typeParameters"], fields: { argument: (0, n2.validateType)("StringLiteral"), qualifier: (0, n2.validateOptionalType)("TSEntityName"), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterInstantiation") } }), o2("TSImportEqualsDeclaration", { aliases: ["Statement"], visitor: ["id", "moduleReference"], fields: { isExport: (0, n2.validate)(a2), id: (0, n2.validateType)("Identifier"), moduleReference: (0, n2.validateType)(["TSEntityName", "TSExternalModuleReference"]), importKind: { validate: (0, n2.assertOneOf)("type", "value"), optional: true } } }), o2("TSExternalModuleReference", { visitor: ["expression"], fields: { expression: (0, n2.validateType)("StringLiteral") } }), o2("TSNonNullExpression", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression"], fields: { expression: (0, n2.validateType)("Expression") } }), o2("TSExportAssignment", { aliases: ["Statement"], visitor: ["expression"], fields: { expression: (0, n2.validateType)("Expression") } }), o2("TSNamespaceExportDeclaration", { aliases: ["Statement"], visitor: ["id"], fields: { id: (0, n2.validateType)("Identifier") } }), o2("TSTypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: { validate: (0, n2.assertNodeType)("TSType") } } }), o2("TSTypeParameterInstantiation", { visitor: ["params"], fields: { params: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("TSType"))) } } }), o2("TSTypeParameterDeclaration", { visitor: ["params"], fields: { params: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("TSTypeParameter"))) } } }), o2("TSTypeParameter", { builder: ["constraint", "default", "name"], visitor: ["constraint", "default"], fields: { name: { validate: (0, n2.assertValueType)("string") }, in: { validate: (0, n2.assertValueType)("boolean"), optional: true }, out: { validate: (0, n2.assertValueType)("boolean"), optional: true }, const: { validate: (0, n2.assertValueType)("boolean"), optional: true }, constraint: { validate: (0, n2.assertNodeType)("TSType"), optional: true }, default: { validate: (0, n2.assertNodeType)("TSType"), optional: true } } });
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.DEPRECATED_ALIASES = void 0, t2.DEPRECATED_ALIASES = { ModuleDeclaration: "ImportOrExportDeclaration" };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    if (!(0, n2.default)(e3)) {
      var t3;
      const r3 = null != (t3 = null == e3 ? void 0 : e3.type) ? t3 : JSON.stringify(e3);
      throw new TypeError(`Not a valid node of type "${r3}"`);
    }
  };
  var n2 = r2(170);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.assertAccessor = function(e3, t3) {
    i2("Accessor", e3, t3);
  }, t2.assertAnyTypeAnnotation = function(e3, t3) {
    i2("AnyTypeAnnotation", e3, t3);
  }, t2.assertArgumentPlaceholder = function(e3, t3) {
    i2("ArgumentPlaceholder", e3, t3);
  }, t2.assertArrayExpression = function(e3, t3) {
    i2("ArrayExpression", e3, t3);
  }, t2.assertArrayPattern = function(e3, t3) {
    i2("ArrayPattern", e3, t3);
  }, t2.assertArrayTypeAnnotation = function(e3, t3) {
    i2("ArrayTypeAnnotation", e3, t3);
  }, t2.assertArrowFunctionExpression = function(e3, t3) {
    i2("ArrowFunctionExpression", e3, t3);
  }, t2.assertAssignmentExpression = function(e3, t3) {
    i2("AssignmentExpression", e3, t3);
  }, t2.assertAssignmentPattern = function(e3, t3) {
    i2("AssignmentPattern", e3, t3);
  }, t2.assertAwaitExpression = function(e3, t3) {
    i2("AwaitExpression", e3, t3);
  }, t2.assertBigIntLiteral = function(e3, t3) {
    i2("BigIntLiteral", e3, t3);
  }, t2.assertBinary = function(e3, t3) {
    i2("Binary", e3, t3);
  }, t2.assertBinaryExpression = function(e3, t3) {
    i2("BinaryExpression", e3, t3);
  }, t2.assertBindExpression = function(e3, t3) {
    i2("BindExpression", e3, t3);
  }, t2.assertBlock = function(e3, t3) {
    i2("Block", e3, t3);
  }, t2.assertBlockParent = function(e3, t3) {
    i2("BlockParent", e3, t3);
  }, t2.assertBlockStatement = function(e3, t3) {
    i2("BlockStatement", e3, t3);
  }, t2.assertBooleanLiteral = function(e3, t3) {
    i2("BooleanLiteral", e3, t3);
  }, t2.assertBooleanLiteralTypeAnnotation = function(e3, t3) {
    i2("BooleanLiteralTypeAnnotation", e3, t3);
  }, t2.assertBooleanTypeAnnotation = function(e3, t3) {
    i2("BooleanTypeAnnotation", e3, t3);
  }, t2.assertBreakStatement = function(e3, t3) {
    i2("BreakStatement", e3, t3);
  }, t2.assertCallExpression = function(e3, t3) {
    i2("CallExpression", e3, t3);
  }, t2.assertCatchClause = function(e3, t3) {
    i2("CatchClause", e3, t3);
  }, t2.assertClass = function(e3, t3) {
    i2("Class", e3, t3);
  }, t2.assertClassAccessorProperty = function(e3, t3) {
    i2("ClassAccessorProperty", e3, t3);
  }, t2.assertClassBody = function(e3, t3) {
    i2("ClassBody", e3, t3);
  }, t2.assertClassDeclaration = function(e3, t3) {
    i2("ClassDeclaration", e3, t3);
  }, t2.assertClassExpression = function(e3, t3) {
    i2("ClassExpression", e3, t3);
  }, t2.assertClassImplements = function(e3, t3) {
    i2("ClassImplements", e3, t3);
  }, t2.assertClassMethod = function(e3, t3) {
    i2("ClassMethod", e3, t3);
  }, t2.assertClassPrivateMethod = function(e3, t3) {
    i2("ClassPrivateMethod", e3, t3);
  }, t2.assertClassPrivateProperty = function(e3, t3) {
    i2("ClassPrivateProperty", e3, t3);
  }, t2.assertClassProperty = function(e3, t3) {
    i2("ClassProperty", e3, t3);
  }, t2.assertCompletionStatement = function(e3, t3) {
    i2("CompletionStatement", e3, t3);
  }, t2.assertConditional = function(e3, t3) {
    i2("Conditional", e3, t3);
  }, t2.assertConditionalExpression = function(e3, t3) {
    i2("ConditionalExpression", e3, t3);
  }, t2.assertContinueStatement = function(e3, t3) {
    i2("ContinueStatement", e3, t3);
  }, t2.assertDebuggerStatement = function(e3, t3) {
    i2("DebuggerStatement", e3, t3);
  }, t2.assertDecimalLiteral = function(e3, t3) {
    i2("DecimalLiteral", e3, t3);
  }, t2.assertDeclaration = function(e3, t3) {
    i2("Declaration", e3, t3);
  }, t2.assertDeclareClass = function(e3, t3) {
    i2("DeclareClass", e3, t3);
  }, t2.assertDeclareExportAllDeclaration = function(e3, t3) {
    i2("DeclareExportAllDeclaration", e3, t3);
  }, t2.assertDeclareExportDeclaration = function(e3, t3) {
    i2("DeclareExportDeclaration", e3, t3);
  }, t2.assertDeclareFunction = function(e3, t3) {
    i2("DeclareFunction", e3, t3);
  }, t2.assertDeclareInterface = function(e3, t3) {
    i2("DeclareInterface", e3, t3);
  }, t2.assertDeclareModule = function(e3, t3) {
    i2("DeclareModule", e3, t3);
  }, t2.assertDeclareModuleExports = function(e3, t3) {
    i2("DeclareModuleExports", e3, t3);
  }, t2.assertDeclareOpaqueType = function(e3, t3) {
    i2("DeclareOpaqueType", e3, t3);
  }, t2.assertDeclareTypeAlias = function(e3, t3) {
    i2("DeclareTypeAlias", e3, t3);
  }, t2.assertDeclareVariable = function(e3, t3) {
    i2("DeclareVariable", e3, t3);
  }, t2.assertDeclaredPredicate = function(e3, t3) {
    i2("DeclaredPredicate", e3, t3);
  }, t2.assertDecorator = function(e3, t3) {
    i2("Decorator", e3, t3);
  }, t2.assertDirective = function(e3, t3) {
    i2("Directive", e3, t3);
  }, t2.assertDirectiveLiteral = function(e3, t3) {
    i2("DirectiveLiteral", e3, t3);
  }, t2.assertDoExpression = function(e3, t3) {
    i2("DoExpression", e3, t3);
  }, t2.assertDoWhileStatement = function(e3, t3) {
    i2("DoWhileStatement", e3, t3);
  }, t2.assertEmptyStatement = function(e3, t3) {
    i2("EmptyStatement", e3, t3);
  }, t2.assertEmptyTypeAnnotation = function(e3, t3) {
    i2("EmptyTypeAnnotation", e3, t3);
  }, t2.assertEnumBody = function(e3, t3) {
    i2("EnumBody", e3, t3);
  }, t2.assertEnumBooleanBody = function(e3, t3) {
    i2("EnumBooleanBody", e3, t3);
  }, t2.assertEnumBooleanMember = function(e3, t3) {
    i2("EnumBooleanMember", e3, t3);
  }, t2.assertEnumDeclaration = function(e3, t3) {
    i2("EnumDeclaration", e3, t3);
  }, t2.assertEnumDefaultedMember = function(e3, t3) {
    i2("EnumDefaultedMember", e3, t3);
  }, t2.assertEnumMember = function(e3, t3) {
    i2("EnumMember", e3, t3);
  }, t2.assertEnumNumberBody = function(e3, t3) {
    i2("EnumNumberBody", e3, t3);
  }, t2.assertEnumNumberMember = function(e3, t3) {
    i2("EnumNumberMember", e3, t3);
  }, t2.assertEnumStringBody = function(e3, t3) {
    i2("EnumStringBody", e3, t3);
  }, t2.assertEnumStringMember = function(e3, t3) {
    i2("EnumStringMember", e3, t3);
  }, t2.assertEnumSymbolBody = function(e3, t3) {
    i2("EnumSymbolBody", e3, t3);
  }, t2.assertExistsTypeAnnotation = function(e3, t3) {
    i2("ExistsTypeAnnotation", e3, t3);
  }, t2.assertExportAllDeclaration = function(e3, t3) {
    i2("ExportAllDeclaration", e3, t3);
  }, t2.assertExportDeclaration = function(e3, t3) {
    i2("ExportDeclaration", e3, t3);
  }, t2.assertExportDefaultDeclaration = function(e3, t3) {
    i2("ExportDefaultDeclaration", e3, t3);
  }, t2.assertExportDefaultSpecifier = function(e3, t3) {
    i2("ExportDefaultSpecifier", e3, t3);
  }, t2.assertExportNamedDeclaration = function(e3, t3) {
    i2("ExportNamedDeclaration", e3, t3);
  }, t2.assertExportNamespaceSpecifier = function(e3, t3) {
    i2("ExportNamespaceSpecifier", e3, t3);
  }, t2.assertExportSpecifier = function(e3, t3) {
    i2("ExportSpecifier", e3, t3);
  }, t2.assertExpression = function(e3, t3) {
    i2("Expression", e3, t3);
  }, t2.assertExpressionStatement = function(e3, t3) {
    i2("ExpressionStatement", e3, t3);
  }, t2.assertExpressionWrapper = function(e3, t3) {
    i2("ExpressionWrapper", e3, t3);
  }, t2.assertFile = function(e3, t3) {
    i2("File", e3, t3);
  }, t2.assertFlow = function(e3, t3) {
    i2("Flow", e3, t3);
  }, t2.assertFlowBaseAnnotation = function(e3, t3) {
    i2("FlowBaseAnnotation", e3, t3);
  }, t2.assertFlowDeclaration = function(e3, t3) {
    i2("FlowDeclaration", e3, t3);
  }, t2.assertFlowPredicate = function(e3, t3) {
    i2("FlowPredicate", e3, t3);
  }, t2.assertFlowType = function(e3, t3) {
    i2("FlowType", e3, t3);
  }, t2.assertFor = function(e3, t3) {
    i2("For", e3, t3);
  }, t2.assertForInStatement = function(e3, t3) {
    i2("ForInStatement", e3, t3);
  }, t2.assertForOfStatement = function(e3, t3) {
    i2("ForOfStatement", e3, t3);
  }, t2.assertForStatement = function(e3, t3) {
    i2("ForStatement", e3, t3);
  }, t2.assertForXStatement = function(e3, t3) {
    i2("ForXStatement", e3, t3);
  }, t2.assertFunction = function(e3, t3) {
    i2("Function", e3, t3);
  }, t2.assertFunctionDeclaration = function(e3, t3) {
    i2("FunctionDeclaration", e3, t3);
  }, t2.assertFunctionExpression = function(e3, t3) {
    i2("FunctionExpression", e3, t3);
  }, t2.assertFunctionParent = function(e3, t3) {
    i2("FunctionParent", e3, t3);
  }, t2.assertFunctionTypeAnnotation = function(e3, t3) {
    i2("FunctionTypeAnnotation", e3, t3);
  }, t2.assertFunctionTypeParam = function(e3, t3) {
    i2("FunctionTypeParam", e3, t3);
  }, t2.assertGenericTypeAnnotation = function(e3, t3) {
    i2("GenericTypeAnnotation", e3, t3);
  }, t2.assertIdentifier = function(e3, t3) {
    i2("Identifier", e3, t3);
  }, t2.assertIfStatement = function(e3, t3) {
    i2("IfStatement", e3, t3);
  }, t2.assertImmutable = function(e3, t3) {
    i2("Immutable", e3, t3);
  }, t2.assertImport = function(e3, t3) {
    i2("Import", e3, t3);
  }, t2.assertImportAttribute = function(e3, t3) {
    i2("ImportAttribute", e3, t3);
  }, t2.assertImportDeclaration = function(e3, t3) {
    i2("ImportDeclaration", e3, t3);
  }, t2.assertImportDefaultSpecifier = function(e3, t3) {
    i2("ImportDefaultSpecifier", e3, t3);
  }, t2.assertImportExpression = function(e3, t3) {
    i2("ImportExpression", e3, t3);
  }, t2.assertImportNamespaceSpecifier = function(e3, t3) {
    i2("ImportNamespaceSpecifier", e3, t3);
  }, t2.assertImportOrExportDeclaration = function(e3, t3) {
    i2("ImportOrExportDeclaration", e3, t3);
  }, t2.assertImportSpecifier = function(e3, t3) {
    i2("ImportSpecifier", e3, t3);
  }, t2.assertIndexedAccessType = function(e3, t3) {
    i2("IndexedAccessType", e3, t3);
  }, t2.assertInferredPredicate = function(e3, t3) {
    i2("InferredPredicate", e3, t3);
  }, t2.assertInterfaceDeclaration = function(e3, t3) {
    i2("InterfaceDeclaration", e3, t3);
  }, t2.assertInterfaceExtends = function(e3, t3) {
    i2("InterfaceExtends", e3, t3);
  }, t2.assertInterfaceTypeAnnotation = function(e3, t3) {
    i2("InterfaceTypeAnnotation", e3, t3);
  }, t2.assertInterpreterDirective = function(e3, t3) {
    i2("InterpreterDirective", e3, t3);
  }, t2.assertIntersectionTypeAnnotation = function(e3, t3) {
    i2("IntersectionTypeAnnotation", e3, t3);
  }, t2.assertJSX = function(e3, t3) {
    i2("JSX", e3, t3);
  }, t2.assertJSXAttribute = function(e3, t3) {
    i2("JSXAttribute", e3, t3);
  }, t2.assertJSXClosingElement = function(e3, t3) {
    i2("JSXClosingElement", e3, t3);
  }, t2.assertJSXClosingFragment = function(e3, t3) {
    i2("JSXClosingFragment", e3, t3);
  }, t2.assertJSXElement = function(e3, t3) {
    i2("JSXElement", e3, t3);
  }, t2.assertJSXEmptyExpression = function(e3, t3) {
    i2("JSXEmptyExpression", e3, t3);
  }, t2.assertJSXExpressionContainer = function(e3, t3) {
    i2("JSXExpressionContainer", e3, t3);
  }, t2.assertJSXFragment = function(e3, t3) {
    i2("JSXFragment", e3, t3);
  }, t2.assertJSXIdentifier = function(e3, t3) {
    i2("JSXIdentifier", e3, t3);
  }, t2.assertJSXMemberExpression = function(e3, t3) {
    i2("JSXMemberExpression", e3, t3);
  }, t2.assertJSXNamespacedName = function(e3, t3) {
    i2("JSXNamespacedName", e3, t3);
  }, t2.assertJSXOpeningElement = function(e3, t3) {
    i2("JSXOpeningElement", e3, t3);
  }, t2.assertJSXOpeningFragment = function(e3, t3) {
    i2("JSXOpeningFragment", e3, t3);
  }, t2.assertJSXSpreadAttribute = function(e3, t3) {
    i2("JSXSpreadAttribute", e3, t3);
  }, t2.assertJSXSpreadChild = function(e3, t3) {
    i2("JSXSpreadChild", e3, t3);
  }, t2.assertJSXText = function(e3, t3) {
    i2("JSXText", e3, t3);
  }, t2.assertLVal = function(e3, t3) {
    i2("LVal", e3, t3);
  }, t2.assertLabeledStatement = function(e3, t3) {
    i2("LabeledStatement", e3, t3);
  }, t2.assertLiteral = function(e3, t3) {
    i2("Literal", e3, t3);
  }, t2.assertLogicalExpression = function(e3, t3) {
    i2("LogicalExpression", e3, t3);
  }, t2.assertLoop = function(e3, t3) {
    i2("Loop", e3, t3);
  }, t2.assertMemberExpression = function(e3, t3) {
    i2("MemberExpression", e3, t3);
  }, t2.assertMetaProperty = function(e3, t3) {
    i2("MetaProperty", e3, t3);
  }, t2.assertMethod = function(e3, t3) {
    i2("Method", e3, t3);
  }, t2.assertMiscellaneous = function(e3, t3) {
    i2("Miscellaneous", e3, t3);
  }, t2.assertMixedTypeAnnotation = function(e3, t3) {
    i2("MixedTypeAnnotation", e3, t3);
  }, t2.assertModuleDeclaration = function(e3, t3) {
    (0, s2.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), i2("ModuleDeclaration", e3, t3);
  }, t2.assertModuleExpression = function(e3, t3) {
    i2("ModuleExpression", e3, t3);
  }, t2.assertModuleSpecifier = function(e3, t3) {
    i2("ModuleSpecifier", e3, t3);
  }, t2.assertNewExpression = function(e3, t3) {
    i2("NewExpression", e3, t3);
  }, t2.assertNoop = function(e3, t3) {
    i2("Noop", e3, t3);
  }, t2.assertNullLiteral = function(e3, t3) {
    i2("NullLiteral", e3, t3);
  }, t2.assertNullLiteralTypeAnnotation = function(e3, t3) {
    i2("NullLiteralTypeAnnotation", e3, t3);
  }, t2.assertNullableTypeAnnotation = function(e3, t3) {
    i2("NullableTypeAnnotation", e3, t3);
  }, t2.assertNumberLiteral = function(e3, t3) {
    (0, s2.default)("assertNumberLiteral", "assertNumericLiteral"), i2("NumberLiteral", e3, t3);
  }, t2.assertNumberLiteralTypeAnnotation = function(e3, t3) {
    i2("NumberLiteralTypeAnnotation", e3, t3);
  }, t2.assertNumberTypeAnnotation = function(e3, t3) {
    i2("NumberTypeAnnotation", e3, t3);
  }, t2.assertNumericLiteral = function(e3, t3) {
    i2("NumericLiteral", e3, t3);
  }, t2.assertObjectExpression = function(e3, t3) {
    i2("ObjectExpression", e3, t3);
  }, t2.assertObjectMember = function(e3, t3) {
    i2("ObjectMember", e3, t3);
  }, t2.assertObjectMethod = function(e3, t3) {
    i2("ObjectMethod", e3, t3);
  }, t2.assertObjectPattern = function(e3, t3) {
    i2("ObjectPattern", e3, t3);
  }, t2.assertObjectProperty = function(e3, t3) {
    i2("ObjectProperty", e3, t3);
  }, t2.assertObjectTypeAnnotation = function(e3, t3) {
    i2("ObjectTypeAnnotation", e3, t3);
  }, t2.assertObjectTypeCallProperty = function(e3, t3) {
    i2("ObjectTypeCallProperty", e3, t3);
  }, t2.assertObjectTypeIndexer = function(e3, t3) {
    i2("ObjectTypeIndexer", e3, t3);
  }, t2.assertObjectTypeInternalSlot = function(e3, t3) {
    i2("ObjectTypeInternalSlot", e3, t3);
  }, t2.assertObjectTypeProperty = function(e3, t3) {
    i2("ObjectTypeProperty", e3, t3);
  }, t2.assertObjectTypeSpreadProperty = function(e3, t3) {
    i2("ObjectTypeSpreadProperty", e3, t3);
  }, t2.assertOpaqueType = function(e3, t3) {
    i2("OpaqueType", e3, t3);
  }, t2.assertOptionalCallExpression = function(e3, t3) {
    i2("OptionalCallExpression", e3, t3);
  }, t2.assertOptionalIndexedAccessType = function(e3, t3) {
    i2("OptionalIndexedAccessType", e3, t3);
  }, t2.assertOptionalMemberExpression = function(e3, t3) {
    i2("OptionalMemberExpression", e3, t3);
  }, t2.assertParenthesizedExpression = function(e3, t3) {
    i2("ParenthesizedExpression", e3, t3);
  }, t2.assertPattern = function(e3, t3) {
    i2("Pattern", e3, t3);
  }, t2.assertPatternLike = function(e3, t3) {
    i2("PatternLike", e3, t3);
  }, t2.assertPipelineBareFunction = function(e3, t3) {
    i2("PipelineBareFunction", e3, t3);
  }, t2.assertPipelinePrimaryTopicReference = function(e3, t3) {
    i2("PipelinePrimaryTopicReference", e3, t3);
  }, t2.assertPipelineTopicExpression = function(e3, t3) {
    i2("PipelineTopicExpression", e3, t3);
  }, t2.assertPlaceholder = function(e3, t3) {
    i2("Placeholder", e3, t3);
  }, t2.assertPrivate = function(e3, t3) {
    i2("Private", e3, t3);
  }, t2.assertPrivateName = function(e3, t3) {
    i2("PrivateName", e3, t3);
  }, t2.assertProgram = function(e3, t3) {
    i2("Program", e3, t3);
  }, t2.assertProperty = function(e3, t3) {
    i2("Property", e3, t3);
  }, t2.assertPureish = function(e3, t3) {
    i2("Pureish", e3, t3);
  }, t2.assertQualifiedTypeIdentifier = function(e3, t3) {
    i2("QualifiedTypeIdentifier", e3, t3);
  }, t2.assertRecordExpression = function(e3, t3) {
    i2("RecordExpression", e3, t3);
  }, t2.assertRegExpLiteral = function(e3, t3) {
    i2("RegExpLiteral", e3, t3);
  }, t2.assertRegexLiteral = function(e3, t3) {
    (0, s2.default)("assertRegexLiteral", "assertRegExpLiteral"), i2("RegexLiteral", e3, t3);
  }, t2.assertRestElement = function(e3, t3) {
    i2("RestElement", e3, t3);
  }, t2.assertRestProperty = function(e3, t3) {
    (0, s2.default)("assertRestProperty", "assertRestElement"), i2("RestProperty", e3, t3);
  }, t2.assertReturnStatement = function(e3, t3) {
    i2("ReturnStatement", e3, t3);
  }, t2.assertScopable = function(e3, t3) {
    i2("Scopable", e3, t3);
  }, t2.assertSequenceExpression = function(e3, t3) {
    i2("SequenceExpression", e3, t3);
  }, t2.assertSpreadElement = function(e3, t3) {
    i2("SpreadElement", e3, t3);
  }, t2.assertSpreadProperty = function(e3, t3) {
    (0, s2.default)("assertSpreadProperty", "assertSpreadElement"), i2("SpreadProperty", e3, t3);
  }, t2.assertStandardized = function(e3, t3) {
    i2("Standardized", e3, t3);
  }, t2.assertStatement = function(e3, t3) {
    i2("Statement", e3, t3);
  }, t2.assertStaticBlock = function(e3, t3) {
    i2("StaticBlock", e3, t3);
  }, t2.assertStringLiteral = function(e3, t3) {
    i2("StringLiteral", e3, t3);
  }, t2.assertStringLiteralTypeAnnotation = function(e3, t3) {
    i2("StringLiteralTypeAnnotation", e3, t3);
  }, t2.assertStringTypeAnnotation = function(e3, t3) {
    i2("StringTypeAnnotation", e3, t3);
  }, t2.assertSuper = function(e3, t3) {
    i2("Super", e3, t3);
  }, t2.assertSwitchCase = function(e3, t3) {
    i2("SwitchCase", e3, t3);
  }, t2.assertSwitchStatement = function(e3, t3) {
    i2("SwitchStatement", e3, t3);
  }, t2.assertSymbolTypeAnnotation = function(e3, t3) {
    i2("SymbolTypeAnnotation", e3, t3);
  }, t2.assertTSAnyKeyword = function(e3, t3) {
    i2("TSAnyKeyword", e3, t3);
  }, t2.assertTSArrayType = function(e3, t3) {
    i2("TSArrayType", e3, t3);
  }, t2.assertTSAsExpression = function(e3, t3) {
    i2("TSAsExpression", e3, t3);
  }, t2.assertTSBaseType = function(e3, t3) {
    i2("TSBaseType", e3, t3);
  }, t2.assertTSBigIntKeyword = function(e3, t3) {
    i2("TSBigIntKeyword", e3, t3);
  }, t2.assertTSBooleanKeyword = function(e3, t3) {
    i2("TSBooleanKeyword", e3, t3);
  }, t2.assertTSCallSignatureDeclaration = function(e3, t3) {
    i2("TSCallSignatureDeclaration", e3, t3);
  }, t2.assertTSConditionalType = function(e3, t3) {
    i2("TSConditionalType", e3, t3);
  }, t2.assertTSConstructSignatureDeclaration = function(e3, t3) {
    i2("TSConstructSignatureDeclaration", e3, t3);
  }, t2.assertTSConstructorType = function(e3, t3) {
    i2("TSConstructorType", e3, t3);
  }, t2.assertTSDeclareFunction = function(e3, t3) {
    i2("TSDeclareFunction", e3, t3);
  }, t2.assertTSDeclareMethod = function(e3, t3) {
    i2("TSDeclareMethod", e3, t3);
  }, t2.assertTSEntityName = function(e3, t3) {
    i2("TSEntityName", e3, t3);
  }, t2.assertTSEnumDeclaration = function(e3, t3) {
    i2("TSEnumDeclaration", e3, t3);
  }, t2.assertTSEnumMember = function(e3, t3) {
    i2("TSEnumMember", e3, t3);
  }, t2.assertTSExportAssignment = function(e3, t3) {
    i2("TSExportAssignment", e3, t3);
  }, t2.assertTSExpressionWithTypeArguments = function(e3, t3) {
    i2("TSExpressionWithTypeArguments", e3, t3);
  }, t2.assertTSExternalModuleReference = function(e3, t3) {
    i2("TSExternalModuleReference", e3, t3);
  }, t2.assertTSFunctionType = function(e3, t3) {
    i2("TSFunctionType", e3, t3);
  }, t2.assertTSImportEqualsDeclaration = function(e3, t3) {
    i2("TSImportEqualsDeclaration", e3, t3);
  }, t2.assertTSImportType = function(e3, t3) {
    i2("TSImportType", e3, t3);
  }, t2.assertTSIndexSignature = function(e3, t3) {
    i2("TSIndexSignature", e3, t3);
  }, t2.assertTSIndexedAccessType = function(e3, t3) {
    i2("TSIndexedAccessType", e3, t3);
  }, t2.assertTSInferType = function(e3, t3) {
    i2("TSInferType", e3, t3);
  }, t2.assertTSInstantiationExpression = function(e3, t3) {
    i2("TSInstantiationExpression", e3, t3);
  }, t2.assertTSInterfaceBody = function(e3, t3) {
    i2("TSInterfaceBody", e3, t3);
  }, t2.assertTSInterfaceDeclaration = function(e3, t3) {
    i2("TSInterfaceDeclaration", e3, t3);
  }, t2.assertTSIntersectionType = function(e3, t3) {
    i2("TSIntersectionType", e3, t3);
  }, t2.assertTSIntrinsicKeyword = function(e3, t3) {
    i2("TSIntrinsicKeyword", e3, t3);
  }, t2.assertTSLiteralType = function(e3, t3) {
    i2("TSLiteralType", e3, t3);
  }, t2.assertTSMappedType = function(e3, t3) {
    i2("TSMappedType", e3, t3);
  }, t2.assertTSMethodSignature = function(e3, t3) {
    i2("TSMethodSignature", e3, t3);
  }, t2.assertTSModuleBlock = function(e3, t3) {
    i2("TSModuleBlock", e3, t3);
  }, t2.assertTSModuleDeclaration = function(e3, t3) {
    i2("TSModuleDeclaration", e3, t3);
  }, t2.assertTSNamedTupleMember = function(e3, t3) {
    i2("TSNamedTupleMember", e3, t3);
  }, t2.assertTSNamespaceExportDeclaration = function(e3, t3) {
    i2("TSNamespaceExportDeclaration", e3, t3);
  }, t2.assertTSNeverKeyword = function(e3, t3) {
    i2("TSNeverKeyword", e3, t3);
  }, t2.assertTSNonNullExpression = function(e3, t3) {
    i2("TSNonNullExpression", e3, t3);
  }, t2.assertTSNullKeyword = function(e3, t3) {
    i2("TSNullKeyword", e3, t3);
  }, t2.assertTSNumberKeyword = function(e3, t3) {
    i2("TSNumberKeyword", e3, t3);
  }, t2.assertTSObjectKeyword = function(e3, t3) {
    i2("TSObjectKeyword", e3, t3);
  }, t2.assertTSOptionalType = function(e3, t3) {
    i2("TSOptionalType", e3, t3);
  }, t2.assertTSParameterProperty = function(e3, t3) {
    i2("TSParameterProperty", e3, t3);
  }, t2.assertTSParenthesizedType = function(e3, t3) {
    i2("TSParenthesizedType", e3, t3);
  }, t2.assertTSPropertySignature = function(e3, t3) {
    i2("TSPropertySignature", e3, t3);
  }, t2.assertTSQualifiedName = function(e3, t3) {
    i2("TSQualifiedName", e3, t3);
  }, t2.assertTSRestType = function(e3, t3) {
    i2("TSRestType", e3, t3);
  }, t2.assertTSSatisfiesExpression = function(e3, t3) {
    i2("TSSatisfiesExpression", e3, t3);
  }, t2.assertTSStringKeyword = function(e3, t3) {
    i2("TSStringKeyword", e3, t3);
  }, t2.assertTSSymbolKeyword = function(e3, t3) {
    i2("TSSymbolKeyword", e3, t3);
  }, t2.assertTSThisType = function(e3, t3) {
    i2("TSThisType", e3, t3);
  }, t2.assertTSTupleType = function(e3, t3) {
    i2("TSTupleType", e3, t3);
  }, t2.assertTSType = function(e3, t3) {
    i2("TSType", e3, t3);
  }, t2.assertTSTypeAliasDeclaration = function(e3, t3) {
    i2("TSTypeAliasDeclaration", e3, t3);
  }, t2.assertTSTypeAnnotation = function(e3, t3) {
    i2("TSTypeAnnotation", e3, t3);
  }, t2.assertTSTypeAssertion = function(e3, t3) {
    i2("TSTypeAssertion", e3, t3);
  }, t2.assertTSTypeElement = function(e3, t3) {
    i2("TSTypeElement", e3, t3);
  }, t2.assertTSTypeLiteral = function(e3, t3) {
    i2("TSTypeLiteral", e3, t3);
  }, t2.assertTSTypeOperator = function(e3, t3) {
    i2("TSTypeOperator", e3, t3);
  }, t2.assertTSTypeParameter = function(e3, t3) {
    i2("TSTypeParameter", e3, t3);
  }, t2.assertTSTypeParameterDeclaration = function(e3, t3) {
    i2("TSTypeParameterDeclaration", e3, t3);
  }, t2.assertTSTypeParameterInstantiation = function(e3, t3) {
    i2("TSTypeParameterInstantiation", e3, t3);
  }, t2.assertTSTypePredicate = function(e3, t3) {
    i2("TSTypePredicate", e3, t3);
  }, t2.assertTSTypeQuery = function(e3, t3) {
    i2("TSTypeQuery", e3, t3);
  }, t2.assertTSTypeReference = function(e3, t3) {
    i2("TSTypeReference", e3, t3);
  }, t2.assertTSUndefinedKeyword = function(e3, t3) {
    i2("TSUndefinedKeyword", e3, t3);
  }, t2.assertTSUnionType = function(e3, t3) {
    i2("TSUnionType", e3, t3);
  }, t2.assertTSUnknownKeyword = function(e3, t3) {
    i2("TSUnknownKeyword", e3, t3);
  }, t2.assertTSVoidKeyword = function(e3, t3) {
    i2("TSVoidKeyword", e3, t3);
  }, t2.assertTaggedTemplateExpression = function(e3, t3) {
    i2("TaggedTemplateExpression", e3, t3);
  }, t2.assertTemplateElement = function(e3, t3) {
    i2("TemplateElement", e3, t3);
  }, t2.assertTemplateLiteral = function(e3, t3) {
    i2("TemplateLiteral", e3, t3);
  }, t2.assertTerminatorless = function(e3, t3) {
    i2("Terminatorless", e3, t3);
  }, t2.assertThisExpression = function(e3, t3) {
    i2("ThisExpression", e3, t3);
  }, t2.assertThisTypeAnnotation = function(e3, t3) {
    i2("ThisTypeAnnotation", e3, t3);
  }, t2.assertThrowStatement = function(e3, t3) {
    i2("ThrowStatement", e3, t3);
  }, t2.assertTopicReference = function(e3, t3) {
    i2("TopicReference", e3, t3);
  }, t2.assertTryStatement = function(e3, t3) {
    i2("TryStatement", e3, t3);
  }, t2.assertTupleExpression = function(e3, t3) {
    i2("TupleExpression", e3, t3);
  }, t2.assertTupleTypeAnnotation = function(e3, t3) {
    i2("TupleTypeAnnotation", e3, t3);
  }, t2.assertTypeAlias = function(e3, t3) {
    i2("TypeAlias", e3, t3);
  }, t2.assertTypeAnnotation = function(e3, t3) {
    i2("TypeAnnotation", e3, t3);
  }, t2.assertTypeCastExpression = function(e3, t3) {
    i2("TypeCastExpression", e3, t3);
  }, t2.assertTypeParameter = function(e3, t3) {
    i2("TypeParameter", e3, t3);
  }, t2.assertTypeParameterDeclaration = function(e3, t3) {
    i2("TypeParameterDeclaration", e3, t3);
  }, t2.assertTypeParameterInstantiation = function(e3, t3) {
    i2("TypeParameterInstantiation", e3, t3);
  }, t2.assertTypeScript = function(e3, t3) {
    i2("TypeScript", e3, t3);
  }, t2.assertTypeofTypeAnnotation = function(e3, t3) {
    i2("TypeofTypeAnnotation", e3, t3);
  }, t2.assertUnaryExpression = function(e3, t3) {
    i2("UnaryExpression", e3, t3);
  }, t2.assertUnaryLike = function(e3, t3) {
    i2("UnaryLike", e3, t3);
  }, t2.assertUnionTypeAnnotation = function(e3, t3) {
    i2("UnionTypeAnnotation", e3, t3);
  }, t2.assertUpdateExpression = function(e3, t3) {
    i2("UpdateExpression", e3, t3);
  }, t2.assertUserWhitespacable = function(e3, t3) {
    i2("UserWhitespacable", e3, t3);
  }, t2.assertV8IntrinsicIdentifier = function(e3, t3) {
    i2("V8IntrinsicIdentifier", e3, t3);
  }, t2.assertVariableDeclaration = function(e3, t3) {
    i2("VariableDeclaration", e3, t3);
  }, t2.assertVariableDeclarator = function(e3, t3) {
    i2("VariableDeclarator", e3, t3);
  }, t2.assertVariance = function(e3, t3) {
    i2("Variance", e3, t3);
  }, t2.assertVoidTypeAnnotation = function(e3, t3) {
    i2("VoidTypeAnnotation", e3, t3);
  }, t2.assertWhile = function(e3, t3) {
    i2("While", e3, t3);
  }, t2.assertWhileStatement = function(e3, t3) {
    i2("WhileStatement", e3, t3);
  }, t2.assertWithStatement = function(e3, t3) {
    i2("WithStatement", e3, t3);
  }, t2.assertYieldExpression = function(e3, t3) {
    i2("YieldExpression", e3, t3);
  };
  var n2 = r2(42), s2 = r2(58);
  function i2(e3, t3, r3) {
    if (!(0, n2.default)(e3, t3, r3)) throw new Error(`Expected type "${e3}" with option ${JSON.stringify(r3)}, but instead got "${t3.type}".`);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(4);
  t2.default = function(e3) {
    switch (e3) {
      case "string":
        return (0, n2.stringTypeAnnotation)();
      case "number":
        return (0, n2.numberTypeAnnotation)();
      case "undefined":
        return (0, n2.voidTypeAnnotation)();
      case "boolean":
        return (0, n2.booleanTypeAnnotation)();
      case "function":
        return (0, n2.genericTypeAnnotation)((0, n2.identifier)("Function"));
      case "object":
        return (0, n2.genericTypeAnnotation)((0, n2.identifier)("Object"));
      case "symbol":
        return (0, n2.genericTypeAnnotation)((0, n2.identifier)("Symbol"));
      case "bigint":
        return (0, n2.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + e3);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const t3 = (0, s2.default)(e3);
    return 1 === t3.length ? t3[0] : (0, n2.unionTypeAnnotation)(t3);
  };
  var n2 = r2(4), s2 = r2(171);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const t3 = e3.map((e4) => (0, i2.isTSTypeAnnotation)(e4) ? e4.typeAnnotation : e4), r3 = (0, s2.default)(t3);
    return 1 === r3.length ? r3[0] : (0, n2.tsUnionType)(r3);
  };
  var n2 = r2(4), s2 = r2(367), i2 = r2(2);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3) {
    const r3 = Array.from(t3), i2 = /* @__PURE__ */ new Map(), o2 = /* @__PURE__ */ new Map(), a2 = /* @__PURE__ */ new Set(), l = [];
    for (let t4 = 0; t4 < r3.length; t4++) {
      const c = r3[t4];
      if (c && !(l.indexOf(c) >= 0)) {
        if ((0, n2.isTSAnyKeyword)(c)) return [c];
        if ((0, n2.isTSBaseType)(c)) o2.set(c.type, c);
        else if ((0, n2.isTSUnionType)(c)) a2.has(c.types) || (r3.push(...c.types), a2.add(c.types));
        else if ((0, n2.isTSTypeReference)(c) && c.typeParameters) {
          const t5 = s2(c.typeName);
          if (i2.has(t5)) {
            let r4 = i2.get(t5);
            r4.typeParameters ? c.typeParameters && (r4.typeParameters.params.push(...c.typeParameters.params), r4.typeParameters.params = e3(r4.typeParameters.params)) : r4 = c.typeParameters;
          } else i2.set(t5, c);
        } else l.push(c);
      }
    }
    for (const [, e4] of o2) l.push(e4);
    for (const [, e4] of i2) l.push(e4);
    return l;
  };
  var n2 = r2(2);
  function s2(e3) {
    return (0, n2.isIdentifier)(e3) ? e3.name : `${e3.right.name}.${s2(e3.left)}`;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "AnyTypeAnnotation", { enumerable: true, get: function() {
    return n2.anyTypeAnnotation;
  } }), Object.defineProperty(t2, "ArgumentPlaceholder", { enumerable: true, get: function() {
    return n2.argumentPlaceholder;
  } }), Object.defineProperty(t2, "ArrayExpression", { enumerable: true, get: function() {
    return n2.arrayExpression;
  } }), Object.defineProperty(t2, "ArrayPattern", { enumerable: true, get: function() {
    return n2.arrayPattern;
  } }), Object.defineProperty(t2, "ArrayTypeAnnotation", { enumerable: true, get: function() {
    return n2.arrayTypeAnnotation;
  } }), Object.defineProperty(t2, "ArrowFunctionExpression", { enumerable: true, get: function() {
    return n2.arrowFunctionExpression;
  } }), Object.defineProperty(t2, "AssignmentExpression", { enumerable: true, get: function() {
    return n2.assignmentExpression;
  } }), Object.defineProperty(t2, "AssignmentPattern", { enumerable: true, get: function() {
    return n2.assignmentPattern;
  } }), Object.defineProperty(t2, "AwaitExpression", { enumerable: true, get: function() {
    return n2.awaitExpression;
  } }), Object.defineProperty(t2, "BigIntLiteral", { enumerable: true, get: function() {
    return n2.bigIntLiteral;
  } }), Object.defineProperty(t2, "BinaryExpression", { enumerable: true, get: function() {
    return n2.binaryExpression;
  } }), Object.defineProperty(t2, "BindExpression", { enumerable: true, get: function() {
    return n2.bindExpression;
  } }), Object.defineProperty(t2, "BlockStatement", { enumerable: true, get: function() {
    return n2.blockStatement;
  } }), Object.defineProperty(t2, "BooleanLiteral", { enumerable: true, get: function() {
    return n2.booleanLiteral;
  } }), Object.defineProperty(t2, "BooleanLiteralTypeAnnotation", { enumerable: true, get: function() {
    return n2.booleanLiteralTypeAnnotation;
  } }), Object.defineProperty(t2, "BooleanTypeAnnotation", { enumerable: true, get: function() {
    return n2.booleanTypeAnnotation;
  } }), Object.defineProperty(t2, "BreakStatement", { enumerable: true, get: function() {
    return n2.breakStatement;
  } }), Object.defineProperty(t2, "CallExpression", { enumerable: true, get: function() {
    return n2.callExpression;
  } }), Object.defineProperty(t2, "CatchClause", { enumerable: true, get: function() {
    return n2.catchClause;
  } }), Object.defineProperty(t2, "ClassAccessorProperty", { enumerable: true, get: function() {
    return n2.classAccessorProperty;
  } }), Object.defineProperty(t2, "ClassBody", { enumerable: true, get: function() {
    return n2.classBody;
  } }), Object.defineProperty(t2, "ClassDeclaration", { enumerable: true, get: function() {
    return n2.classDeclaration;
  } }), Object.defineProperty(t2, "ClassExpression", { enumerable: true, get: function() {
    return n2.classExpression;
  } }), Object.defineProperty(t2, "ClassImplements", { enumerable: true, get: function() {
    return n2.classImplements;
  } }), Object.defineProperty(t2, "ClassMethod", { enumerable: true, get: function() {
    return n2.classMethod;
  } }), Object.defineProperty(t2, "ClassPrivateMethod", { enumerable: true, get: function() {
    return n2.classPrivateMethod;
  } }), Object.defineProperty(t2, "ClassPrivateProperty", { enumerable: true, get: function() {
    return n2.classPrivateProperty;
  } }), Object.defineProperty(t2, "ClassProperty", { enumerable: true, get: function() {
    return n2.classProperty;
  } }), Object.defineProperty(t2, "ConditionalExpression", { enumerable: true, get: function() {
    return n2.conditionalExpression;
  } }), Object.defineProperty(t2, "ContinueStatement", { enumerable: true, get: function() {
    return n2.continueStatement;
  } }), Object.defineProperty(t2, "DebuggerStatement", { enumerable: true, get: function() {
    return n2.debuggerStatement;
  } }), Object.defineProperty(t2, "DecimalLiteral", { enumerable: true, get: function() {
    return n2.decimalLiteral;
  } }), Object.defineProperty(t2, "DeclareClass", { enumerable: true, get: function() {
    return n2.declareClass;
  } }), Object.defineProperty(t2, "DeclareExportAllDeclaration", { enumerable: true, get: function() {
    return n2.declareExportAllDeclaration;
  } }), Object.defineProperty(t2, "DeclareExportDeclaration", { enumerable: true, get: function() {
    return n2.declareExportDeclaration;
  } }), Object.defineProperty(t2, "DeclareFunction", { enumerable: true, get: function() {
    return n2.declareFunction;
  } }), Object.defineProperty(t2, "DeclareInterface", { enumerable: true, get: function() {
    return n2.declareInterface;
  } }), Object.defineProperty(t2, "DeclareModule", { enumerable: true, get: function() {
    return n2.declareModule;
  } }), Object.defineProperty(t2, "DeclareModuleExports", { enumerable: true, get: function() {
    return n2.declareModuleExports;
  } }), Object.defineProperty(t2, "DeclareOpaqueType", { enumerable: true, get: function() {
    return n2.declareOpaqueType;
  } }), Object.defineProperty(t2, "DeclareTypeAlias", { enumerable: true, get: function() {
    return n2.declareTypeAlias;
  } }), Object.defineProperty(t2, "DeclareVariable", { enumerable: true, get: function() {
    return n2.declareVariable;
  } }), Object.defineProperty(t2, "DeclaredPredicate", { enumerable: true, get: function() {
    return n2.declaredPredicate;
  } }), Object.defineProperty(t2, "Decorator", { enumerable: true, get: function() {
    return n2.decorator;
  } }), Object.defineProperty(t2, "Directive", { enumerable: true, get: function() {
    return n2.directive;
  } }), Object.defineProperty(t2, "DirectiveLiteral", { enumerable: true, get: function() {
    return n2.directiveLiteral;
  } }), Object.defineProperty(t2, "DoExpression", { enumerable: true, get: function() {
    return n2.doExpression;
  } }), Object.defineProperty(t2, "DoWhileStatement", { enumerable: true, get: function() {
    return n2.doWhileStatement;
  } }), Object.defineProperty(t2, "EmptyStatement", { enumerable: true, get: function() {
    return n2.emptyStatement;
  } }), Object.defineProperty(t2, "EmptyTypeAnnotation", { enumerable: true, get: function() {
    return n2.emptyTypeAnnotation;
  } }), Object.defineProperty(t2, "EnumBooleanBody", { enumerable: true, get: function() {
    return n2.enumBooleanBody;
  } }), Object.defineProperty(t2, "EnumBooleanMember", { enumerable: true, get: function() {
    return n2.enumBooleanMember;
  } }), Object.defineProperty(t2, "EnumDeclaration", { enumerable: true, get: function() {
    return n2.enumDeclaration;
  } }), Object.defineProperty(t2, "EnumDefaultedMember", { enumerable: true, get: function() {
    return n2.enumDefaultedMember;
  } }), Object.defineProperty(t2, "EnumNumberBody", { enumerable: true, get: function() {
    return n2.enumNumberBody;
  } }), Object.defineProperty(t2, "EnumNumberMember", { enumerable: true, get: function() {
    return n2.enumNumberMember;
  } }), Object.defineProperty(t2, "EnumStringBody", { enumerable: true, get: function() {
    return n2.enumStringBody;
  } }), Object.defineProperty(t2, "EnumStringMember", { enumerable: true, get: function() {
    return n2.enumStringMember;
  } }), Object.defineProperty(t2, "EnumSymbolBody", { enumerable: true, get: function() {
    return n2.enumSymbolBody;
  } }), Object.defineProperty(t2, "ExistsTypeAnnotation", { enumerable: true, get: function() {
    return n2.existsTypeAnnotation;
  } }), Object.defineProperty(t2, "ExportAllDeclaration", { enumerable: true, get: function() {
    return n2.exportAllDeclaration;
  } }), Object.defineProperty(t2, "ExportDefaultDeclaration", { enumerable: true, get: function() {
    return n2.exportDefaultDeclaration;
  } }), Object.defineProperty(t2, "ExportDefaultSpecifier", { enumerable: true, get: function() {
    return n2.exportDefaultSpecifier;
  } }), Object.defineProperty(t2, "ExportNamedDeclaration", { enumerable: true, get: function() {
    return n2.exportNamedDeclaration;
  } }), Object.defineProperty(t2, "ExportNamespaceSpecifier", { enumerable: true, get: function() {
    return n2.exportNamespaceSpecifier;
  } }), Object.defineProperty(t2, "ExportSpecifier", { enumerable: true, get: function() {
    return n2.exportSpecifier;
  } }), Object.defineProperty(t2, "ExpressionStatement", { enumerable: true, get: function() {
    return n2.expressionStatement;
  } }), Object.defineProperty(t2, "File", { enumerable: true, get: function() {
    return n2.file;
  } }), Object.defineProperty(t2, "ForInStatement", { enumerable: true, get: function() {
    return n2.forInStatement;
  } }), Object.defineProperty(t2, "ForOfStatement", { enumerable: true, get: function() {
    return n2.forOfStatement;
  } }), Object.defineProperty(t2, "ForStatement", { enumerable: true, get: function() {
    return n2.forStatement;
  } }), Object.defineProperty(t2, "FunctionDeclaration", { enumerable: true, get: function() {
    return n2.functionDeclaration;
  } }), Object.defineProperty(t2, "FunctionExpression", { enumerable: true, get: function() {
    return n2.functionExpression;
  } }), Object.defineProperty(t2, "FunctionTypeAnnotation", { enumerable: true, get: function() {
    return n2.functionTypeAnnotation;
  } }), Object.defineProperty(t2, "FunctionTypeParam", { enumerable: true, get: function() {
    return n2.functionTypeParam;
  } }), Object.defineProperty(t2, "GenericTypeAnnotation", { enumerable: true, get: function() {
    return n2.genericTypeAnnotation;
  } }), Object.defineProperty(t2, "Identifier", { enumerable: true, get: function() {
    return n2.identifier;
  } }), Object.defineProperty(t2, "IfStatement", { enumerable: true, get: function() {
    return n2.ifStatement;
  } }), Object.defineProperty(t2, "Import", { enumerable: true, get: function() {
    return n2.import;
  } }), Object.defineProperty(t2, "ImportAttribute", { enumerable: true, get: function() {
    return n2.importAttribute;
  } }), Object.defineProperty(t2, "ImportDeclaration", { enumerable: true, get: function() {
    return n2.importDeclaration;
  } }), Object.defineProperty(t2, "ImportDefaultSpecifier", { enumerable: true, get: function() {
    return n2.importDefaultSpecifier;
  } }), Object.defineProperty(t2, "ImportExpression", { enumerable: true, get: function() {
    return n2.importExpression;
  } }), Object.defineProperty(t2, "ImportNamespaceSpecifier", { enumerable: true, get: function() {
    return n2.importNamespaceSpecifier;
  } }), Object.defineProperty(t2, "ImportSpecifier", { enumerable: true, get: function() {
    return n2.importSpecifier;
  } }), Object.defineProperty(t2, "IndexedAccessType", { enumerable: true, get: function() {
    return n2.indexedAccessType;
  } }), Object.defineProperty(t2, "InferredPredicate", { enumerable: true, get: function() {
    return n2.inferredPredicate;
  } }), Object.defineProperty(t2, "InterfaceDeclaration", { enumerable: true, get: function() {
    return n2.interfaceDeclaration;
  } }), Object.defineProperty(t2, "InterfaceExtends", { enumerable: true, get: function() {
    return n2.interfaceExtends;
  } }), Object.defineProperty(t2, "InterfaceTypeAnnotation", { enumerable: true, get: function() {
    return n2.interfaceTypeAnnotation;
  } }), Object.defineProperty(t2, "InterpreterDirective", { enumerable: true, get: function() {
    return n2.interpreterDirective;
  } }), Object.defineProperty(t2, "IntersectionTypeAnnotation", { enumerable: true, get: function() {
    return n2.intersectionTypeAnnotation;
  } }), Object.defineProperty(t2, "JSXAttribute", { enumerable: true, get: function() {
    return n2.jsxAttribute;
  } }), Object.defineProperty(t2, "JSXClosingElement", { enumerable: true, get: function() {
    return n2.jsxClosingElement;
  } }), Object.defineProperty(t2, "JSXClosingFragment", { enumerable: true, get: function() {
    return n2.jsxClosingFragment;
  } }), Object.defineProperty(t2, "JSXElement", { enumerable: true, get: function() {
    return n2.jsxElement;
  } }), Object.defineProperty(t2, "JSXEmptyExpression", { enumerable: true, get: function() {
    return n2.jsxEmptyExpression;
  } }), Object.defineProperty(t2, "JSXExpressionContainer", { enumerable: true, get: function() {
    return n2.jsxExpressionContainer;
  } }), Object.defineProperty(t2, "JSXFragment", { enumerable: true, get: function() {
    return n2.jsxFragment;
  } }), Object.defineProperty(t2, "JSXIdentifier", { enumerable: true, get: function() {
    return n2.jsxIdentifier;
  } }), Object.defineProperty(t2, "JSXMemberExpression", { enumerable: true, get: function() {
    return n2.jsxMemberExpression;
  } }), Object.defineProperty(t2, "JSXNamespacedName", { enumerable: true, get: function() {
    return n2.jsxNamespacedName;
  } }), Object.defineProperty(t2, "JSXOpeningElement", { enumerable: true, get: function() {
    return n2.jsxOpeningElement;
  } }), Object.defineProperty(t2, "JSXOpeningFragment", { enumerable: true, get: function() {
    return n2.jsxOpeningFragment;
  } }), Object.defineProperty(t2, "JSXSpreadAttribute", { enumerable: true, get: function() {
    return n2.jsxSpreadAttribute;
  } }), Object.defineProperty(t2, "JSXSpreadChild", { enumerable: true, get: function() {
    return n2.jsxSpreadChild;
  } }), Object.defineProperty(t2, "JSXText", { enumerable: true, get: function() {
    return n2.jsxText;
  } }), Object.defineProperty(t2, "LabeledStatement", { enumerable: true, get: function() {
    return n2.labeledStatement;
  } }), Object.defineProperty(t2, "LogicalExpression", { enumerable: true, get: function() {
    return n2.logicalExpression;
  } }), Object.defineProperty(t2, "MemberExpression", { enumerable: true, get: function() {
    return n2.memberExpression;
  } }), Object.defineProperty(t2, "MetaProperty", { enumerable: true, get: function() {
    return n2.metaProperty;
  } }), Object.defineProperty(t2, "MixedTypeAnnotation", { enumerable: true, get: function() {
    return n2.mixedTypeAnnotation;
  } }), Object.defineProperty(t2, "ModuleExpression", { enumerable: true, get: function() {
    return n2.moduleExpression;
  } }), Object.defineProperty(t2, "NewExpression", { enumerable: true, get: function() {
    return n2.newExpression;
  } }), Object.defineProperty(t2, "Noop", { enumerable: true, get: function() {
    return n2.noop;
  } }), Object.defineProperty(t2, "NullLiteral", { enumerable: true, get: function() {
    return n2.nullLiteral;
  } }), Object.defineProperty(t2, "NullLiteralTypeAnnotation", { enumerable: true, get: function() {
    return n2.nullLiteralTypeAnnotation;
  } }), Object.defineProperty(t2, "NullableTypeAnnotation", { enumerable: true, get: function() {
    return n2.nullableTypeAnnotation;
  } }), Object.defineProperty(t2, "NumberLiteral", { enumerable: true, get: function() {
    return n2.numberLiteral;
  } }), Object.defineProperty(t2, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
    return n2.numberLiteralTypeAnnotation;
  } }), Object.defineProperty(t2, "NumberTypeAnnotation", { enumerable: true, get: function() {
    return n2.numberTypeAnnotation;
  } }), Object.defineProperty(t2, "NumericLiteral", { enumerable: true, get: function() {
    return n2.numericLiteral;
  } }), Object.defineProperty(t2, "ObjectExpression", { enumerable: true, get: function() {
    return n2.objectExpression;
  } }), Object.defineProperty(t2, "ObjectMethod", { enumerable: true, get: function() {
    return n2.objectMethod;
  } }), Object.defineProperty(t2, "ObjectPattern", { enumerable: true, get: function() {
    return n2.objectPattern;
  } }), Object.defineProperty(t2, "ObjectProperty", { enumerable: true, get: function() {
    return n2.objectProperty;
  } }), Object.defineProperty(t2, "ObjectTypeAnnotation", { enumerable: true, get: function() {
    return n2.objectTypeAnnotation;
  } }), Object.defineProperty(t2, "ObjectTypeCallProperty", { enumerable: true, get: function() {
    return n2.objectTypeCallProperty;
  } }), Object.defineProperty(t2, "ObjectTypeIndexer", { enumerable: true, get: function() {
    return n2.objectTypeIndexer;
  } }), Object.defineProperty(t2, "ObjectTypeInternalSlot", { enumerable: true, get: function() {
    return n2.objectTypeInternalSlot;
  } }), Object.defineProperty(t2, "ObjectTypeProperty", { enumerable: true, get: function() {
    return n2.objectTypeProperty;
  } }), Object.defineProperty(t2, "ObjectTypeSpreadProperty", { enumerable: true, get: function() {
    return n2.objectTypeSpreadProperty;
  } }), Object.defineProperty(t2, "OpaqueType", { enumerable: true, get: function() {
    return n2.opaqueType;
  } }), Object.defineProperty(t2, "OptionalCallExpression", { enumerable: true, get: function() {
    return n2.optionalCallExpression;
  } }), Object.defineProperty(t2, "OptionalIndexedAccessType", { enumerable: true, get: function() {
    return n2.optionalIndexedAccessType;
  } }), Object.defineProperty(t2, "OptionalMemberExpression", { enumerable: true, get: function() {
    return n2.optionalMemberExpression;
  } }), Object.defineProperty(t2, "ParenthesizedExpression", { enumerable: true, get: function() {
    return n2.parenthesizedExpression;
  } }), Object.defineProperty(t2, "PipelineBareFunction", { enumerable: true, get: function() {
    return n2.pipelineBareFunction;
  } }), Object.defineProperty(t2, "PipelinePrimaryTopicReference", { enumerable: true, get: function() {
    return n2.pipelinePrimaryTopicReference;
  } }), Object.defineProperty(t2, "PipelineTopicExpression", { enumerable: true, get: function() {
    return n2.pipelineTopicExpression;
  } }), Object.defineProperty(t2, "Placeholder", { enumerable: true, get: function() {
    return n2.placeholder;
  } }), Object.defineProperty(t2, "PrivateName", { enumerable: true, get: function() {
    return n2.privateName;
  } }), Object.defineProperty(t2, "Program", { enumerable: true, get: function() {
    return n2.program;
  } }), Object.defineProperty(t2, "QualifiedTypeIdentifier", { enumerable: true, get: function() {
    return n2.qualifiedTypeIdentifier;
  } }), Object.defineProperty(t2, "RecordExpression", { enumerable: true, get: function() {
    return n2.recordExpression;
  } }), Object.defineProperty(t2, "RegExpLiteral", { enumerable: true, get: function() {
    return n2.regExpLiteral;
  } }), Object.defineProperty(t2, "RegexLiteral", { enumerable: true, get: function() {
    return n2.regexLiteral;
  } }), Object.defineProperty(t2, "RestElement", { enumerable: true, get: function() {
    return n2.restElement;
  } }), Object.defineProperty(t2, "RestProperty", { enumerable: true, get: function() {
    return n2.restProperty;
  } }), Object.defineProperty(t2, "ReturnStatement", { enumerable: true, get: function() {
    return n2.returnStatement;
  } }), Object.defineProperty(t2, "SequenceExpression", { enumerable: true, get: function() {
    return n2.sequenceExpression;
  } }), Object.defineProperty(t2, "SpreadElement", { enumerable: true, get: function() {
    return n2.spreadElement;
  } }), Object.defineProperty(t2, "SpreadProperty", { enumerable: true, get: function() {
    return n2.spreadProperty;
  } }), Object.defineProperty(t2, "StaticBlock", { enumerable: true, get: function() {
    return n2.staticBlock;
  } }), Object.defineProperty(t2, "StringLiteral", { enumerable: true, get: function() {
    return n2.stringLiteral;
  } }), Object.defineProperty(t2, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
    return n2.stringLiteralTypeAnnotation;
  } }), Object.defineProperty(t2, "StringTypeAnnotation", { enumerable: true, get: function() {
    return n2.stringTypeAnnotation;
  } }), Object.defineProperty(t2, "Super", { enumerable: true, get: function() {
    return n2.super;
  } }), Object.defineProperty(t2, "SwitchCase", { enumerable: true, get: function() {
    return n2.switchCase;
  } }), Object.defineProperty(t2, "SwitchStatement", { enumerable: true, get: function() {
    return n2.switchStatement;
  } }), Object.defineProperty(t2, "SymbolTypeAnnotation", { enumerable: true, get: function() {
    return n2.symbolTypeAnnotation;
  } }), Object.defineProperty(t2, "TSAnyKeyword", { enumerable: true, get: function() {
    return n2.tsAnyKeyword;
  } }), Object.defineProperty(t2, "TSArrayType", { enumerable: true, get: function() {
    return n2.tsArrayType;
  } }), Object.defineProperty(t2, "TSAsExpression", { enumerable: true, get: function() {
    return n2.tsAsExpression;
  } }), Object.defineProperty(t2, "TSBigIntKeyword", { enumerable: true, get: function() {
    return n2.tsBigIntKeyword;
  } }), Object.defineProperty(t2, "TSBooleanKeyword", { enumerable: true, get: function() {
    return n2.tsBooleanKeyword;
  } }), Object.defineProperty(t2, "TSCallSignatureDeclaration", { enumerable: true, get: function() {
    return n2.tsCallSignatureDeclaration;
  } }), Object.defineProperty(t2, "TSConditionalType", { enumerable: true, get: function() {
    return n2.tsConditionalType;
  } }), Object.defineProperty(t2, "TSConstructSignatureDeclaration", { enumerable: true, get: function() {
    return n2.tsConstructSignatureDeclaration;
  } }), Object.defineProperty(t2, "TSConstructorType", { enumerable: true, get: function() {
    return n2.tsConstructorType;
  } }), Object.defineProperty(t2, "TSDeclareFunction", { enumerable: true, get: function() {
    return n2.tsDeclareFunction;
  } }), Object.defineProperty(t2, "TSDeclareMethod", { enumerable: true, get: function() {
    return n2.tsDeclareMethod;
  } }), Object.defineProperty(t2, "TSEnumDeclaration", { enumerable: true, get: function() {
    return n2.tsEnumDeclaration;
  } }), Object.defineProperty(t2, "TSEnumMember", { enumerable: true, get: function() {
    return n2.tsEnumMember;
  } }), Object.defineProperty(t2, "TSExportAssignment", { enumerable: true, get: function() {
    return n2.tsExportAssignment;
  } }), Object.defineProperty(t2, "TSExpressionWithTypeArguments", { enumerable: true, get: function() {
    return n2.tsExpressionWithTypeArguments;
  } }), Object.defineProperty(t2, "TSExternalModuleReference", { enumerable: true, get: function() {
    return n2.tsExternalModuleReference;
  } }), Object.defineProperty(t2, "TSFunctionType", { enumerable: true, get: function() {
    return n2.tsFunctionType;
  } }), Object.defineProperty(t2, "TSImportEqualsDeclaration", { enumerable: true, get: function() {
    return n2.tsImportEqualsDeclaration;
  } }), Object.defineProperty(t2, "TSImportType", { enumerable: true, get: function() {
    return n2.tsImportType;
  } }), Object.defineProperty(t2, "TSIndexSignature", { enumerable: true, get: function() {
    return n2.tsIndexSignature;
  } }), Object.defineProperty(t2, "TSIndexedAccessType", { enumerable: true, get: function() {
    return n2.tsIndexedAccessType;
  } }), Object.defineProperty(t2, "TSInferType", { enumerable: true, get: function() {
    return n2.tsInferType;
  } }), Object.defineProperty(t2, "TSInstantiationExpression", { enumerable: true, get: function() {
    return n2.tsInstantiationExpression;
  } }), Object.defineProperty(t2, "TSInterfaceBody", { enumerable: true, get: function() {
    return n2.tsInterfaceBody;
  } }), Object.defineProperty(t2, "TSInterfaceDeclaration", { enumerable: true, get: function() {
    return n2.tsInterfaceDeclaration;
  } }), Object.defineProperty(t2, "TSIntersectionType", { enumerable: true, get: function() {
    return n2.tsIntersectionType;
  } }), Object.defineProperty(t2, "TSIntrinsicKeyword", { enumerable: true, get: function() {
    return n2.tsIntrinsicKeyword;
  } }), Object.defineProperty(t2, "TSLiteralType", { enumerable: true, get: function() {
    return n2.tsLiteralType;
  } }), Object.defineProperty(t2, "TSMappedType", { enumerable: true, get: function() {
    return n2.tsMappedType;
  } }), Object.defineProperty(t2, "TSMethodSignature", { enumerable: true, get: function() {
    return n2.tsMethodSignature;
  } }), Object.defineProperty(t2, "TSModuleBlock", { enumerable: true, get: function() {
    return n2.tsModuleBlock;
  } }), Object.defineProperty(t2, "TSModuleDeclaration", { enumerable: true, get: function() {
    return n2.tsModuleDeclaration;
  } }), Object.defineProperty(t2, "TSNamedTupleMember", { enumerable: true, get: function() {
    return n2.tsNamedTupleMember;
  } }), Object.defineProperty(t2, "TSNamespaceExportDeclaration", { enumerable: true, get: function() {
    return n2.tsNamespaceExportDeclaration;
  } }), Object.defineProperty(t2, "TSNeverKeyword", { enumerable: true, get: function() {
    return n2.tsNeverKeyword;
  } }), Object.defineProperty(t2, "TSNonNullExpression", { enumerable: true, get: function() {
    return n2.tsNonNullExpression;
  } }), Object.defineProperty(t2, "TSNullKeyword", { enumerable: true, get: function() {
    return n2.tsNullKeyword;
  } }), Object.defineProperty(t2, "TSNumberKeyword", { enumerable: true, get: function() {
    return n2.tsNumberKeyword;
  } }), Object.defineProperty(t2, "TSObjectKeyword", { enumerable: true, get: function() {
    return n2.tsObjectKeyword;
  } }), Object.defineProperty(t2, "TSOptionalType", { enumerable: true, get: function() {
    return n2.tsOptionalType;
  } }), Object.defineProperty(t2, "TSParameterProperty", { enumerable: true, get: function() {
    return n2.tsParameterProperty;
  } }), Object.defineProperty(t2, "TSParenthesizedType", { enumerable: true, get: function() {
    return n2.tsParenthesizedType;
  } }), Object.defineProperty(t2, "TSPropertySignature", { enumerable: true, get: function() {
    return n2.tsPropertySignature;
  } }), Object.defineProperty(t2, "TSQualifiedName", { enumerable: true, get: function() {
    return n2.tsQualifiedName;
  } }), Object.defineProperty(t2, "TSRestType", { enumerable: true, get: function() {
    return n2.tsRestType;
  } }), Object.defineProperty(t2, "TSSatisfiesExpression", { enumerable: true, get: function() {
    return n2.tsSatisfiesExpression;
  } }), Object.defineProperty(t2, "TSStringKeyword", { enumerable: true, get: function() {
    return n2.tsStringKeyword;
  } }), Object.defineProperty(t2, "TSSymbolKeyword", { enumerable: true, get: function() {
    return n2.tsSymbolKeyword;
  } }), Object.defineProperty(t2, "TSThisType", { enumerable: true, get: function() {
    return n2.tsThisType;
  } }), Object.defineProperty(t2, "TSTupleType", { enumerable: true, get: function() {
    return n2.tsTupleType;
  } }), Object.defineProperty(t2, "TSTypeAliasDeclaration", { enumerable: true, get: function() {
    return n2.tsTypeAliasDeclaration;
  } }), Object.defineProperty(t2, "TSTypeAnnotation", { enumerable: true, get: function() {
    return n2.tsTypeAnnotation;
  } }), Object.defineProperty(t2, "TSTypeAssertion", { enumerable: true, get: function() {
    return n2.tsTypeAssertion;
  } }), Object.defineProperty(t2, "TSTypeLiteral", { enumerable: true, get: function() {
    return n2.tsTypeLiteral;
  } }), Object.defineProperty(t2, "TSTypeOperator", { enumerable: true, get: function() {
    return n2.tsTypeOperator;
  } }), Object.defineProperty(t2, "TSTypeParameter", { enumerable: true, get: function() {
    return n2.tsTypeParameter;
  } }), Object.defineProperty(t2, "TSTypeParameterDeclaration", { enumerable: true, get: function() {
    return n2.tsTypeParameterDeclaration;
  } }), Object.defineProperty(t2, "TSTypeParameterInstantiation", { enumerable: true, get: function() {
    return n2.tsTypeParameterInstantiation;
  } }), Object.defineProperty(t2, "TSTypePredicate", { enumerable: true, get: function() {
    return n2.tsTypePredicate;
  } }), Object.defineProperty(t2, "TSTypeQuery", { enumerable: true, get: function() {
    return n2.tsTypeQuery;
  } }), Object.defineProperty(t2, "TSTypeReference", { enumerable: true, get: function() {
    return n2.tsTypeReference;
  } }), Object.defineProperty(t2, "TSUndefinedKeyword", { enumerable: true, get: function() {
    return n2.tsUndefinedKeyword;
  } }), Object.defineProperty(t2, "TSUnionType", { enumerable: true, get: function() {
    return n2.tsUnionType;
  } }), Object.defineProperty(t2, "TSUnknownKeyword", { enumerable: true, get: function() {
    return n2.tsUnknownKeyword;
  } }), Object.defineProperty(t2, "TSVoidKeyword", { enumerable: true, get: function() {
    return n2.tsVoidKeyword;
  } }), Object.defineProperty(t2, "TaggedTemplateExpression", { enumerable: true, get: function() {
    return n2.taggedTemplateExpression;
  } }), Object.defineProperty(t2, "TemplateElement", { enumerable: true, get: function() {
    return n2.templateElement;
  } }), Object.defineProperty(t2, "TemplateLiteral", { enumerable: true, get: function() {
    return n2.templateLiteral;
  } }), Object.defineProperty(t2, "ThisExpression", { enumerable: true, get: function() {
    return n2.thisExpression;
  } }), Object.defineProperty(t2, "ThisTypeAnnotation", { enumerable: true, get: function() {
    return n2.thisTypeAnnotation;
  } }), Object.defineProperty(t2, "ThrowStatement", { enumerable: true, get: function() {
    return n2.throwStatement;
  } }), Object.defineProperty(t2, "TopicReference", { enumerable: true, get: function() {
    return n2.topicReference;
  } }), Object.defineProperty(t2, "TryStatement", { enumerable: true, get: function() {
    return n2.tryStatement;
  } }), Object.defineProperty(t2, "TupleExpression", { enumerable: true, get: function() {
    return n2.tupleExpression;
  } }), Object.defineProperty(t2, "TupleTypeAnnotation", { enumerable: true, get: function() {
    return n2.tupleTypeAnnotation;
  } }), Object.defineProperty(t2, "TypeAlias", { enumerable: true, get: function() {
    return n2.typeAlias;
  } }), Object.defineProperty(t2, "TypeAnnotation", { enumerable: true, get: function() {
    return n2.typeAnnotation;
  } }), Object.defineProperty(t2, "TypeCastExpression", { enumerable: true, get: function() {
    return n2.typeCastExpression;
  } }), Object.defineProperty(t2, "TypeParameter", { enumerable: true, get: function() {
    return n2.typeParameter;
  } }), Object.defineProperty(t2, "TypeParameterDeclaration", { enumerable: true, get: function() {
    return n2.typeParameterDeclaration;
  } }), Object.defineProperty(t2, "TypeParameterInstantiation", { enumerable: true, get: function() {
    return n2.typeParameterInstantiation;
  } }), Object.defineProperty(t2, "TypeofTypeAnnotation", { enumerable: true, get: function() {
    return n2.typeofTypeAnnotation;
  } }), Object.defineProperty(t2, "UnaryExpression", { enumerable: true, get: function() {
    return n2.unaryExpression;
  } }), Object.defineProperty(t2, "UnionTypeAnnotation", { enumerable: true, get: function() {
    return n2.unionTypeAnnotation;
  } }), Object.defineProperty(t2, "UpdateExpression", { enumerable: true, get: function() {
    return n2.updateExpression;
  } }), Object.defineProperty(t2, "V8IntrinsicIdentifier", { enumerable: true, get: function() {
    return n2.v8IntrinsicIdentifier;
  } }), Object.defineProperty(t2, "VariableDeclaration", { enumerable: true, get: function() {
    return n2.variableDeclaration;
  } }), Object.defineProperty(t2, "VariableDeclarator", { enumerable: true, get: function() {
    return n2.variableDeclarator;
  } }), Object.defineProperty(t2, "Variance", { enumerable: true, get: function() {
    return n2.variance;
  } }), Object.defineProperty(t2, "VoidTypeAnnotation", { enumerable: true, get: function() {
    return n2.voidTypeAnnotation;
  } }), Object.defineProperty(t2, "WhileStatement", { enumerable: true, get: function() {
    return n2.whileStatement;
  } }), Object.defineProperty(t2, "WithStatement", { enumerable: true, get: function() {
    return n2.withStatement;
  } }), Object.defineProperty(t2, "YieldExpression", { enumerable: true, get: function() {
    return n2.yieldExpression;
  } });
  var n2 = r2(4);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.buildUndefinedNode = function() {
    return (0, n2.unaryExpression)("void", (0, n2.numericLiteral)(0), true);
  };
  var n2 = r2(4);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.default)(e3, false);
  };
  var n2 = r2(27);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.default)(e3);
  };
  var n2 = r2(27);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.default)(e3, true, true);
  };
  var n2 = r2(27);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.default)(e3, false, true);
  };
  var n2 = r2(27);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, s2) {
    return (0, n2.default)(e3, t3, [{ type: s2 ? "CommentLine" : "CommentBlock", value: r3 }]);
  };
  var n2 = r2(172);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return n2.COMMENT_KEYS.forEach((t3) => {
      e3[t3] = null;
    }), e3;
  };
  var n2 = r2(26);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.WHILE_TYPES = t2.USERWHITESPACABLE_TYPES = t2.UNARYLIKE_TYPES = t2.TYPESCRIPT_TYPES = t2.TSTYPE_TYPES = t2.TSTYPEELEMENT_TYPES = t2.TSENTITYNAME_TYPES = t2.TSBASETYPE_TYPES = t2.TERMINATORLESS_TYPES = t2.STATEMENT_TYPES = t2.STANDARDIZED_TYPES = t2.SCOPABLE_TYPES = t2.PUREISH_TYPES = t2.PROPERTY_TYPES = t2.PRIVATE_TYPES = t2.PATTERN_TYPES = t2.PATTERNLIKE_TYPES = t2.OBJECTMEMBER_TYPES = t2.MODULESPECIFIER_TYPES = t2.MODULEDECLARATION_TYPES = t2.MISCELLANEOUS_TYPES = t2.METHOD_TYPES = t2.LVAL_TYPES = t2.LOOP_TYPES = t2.LITERAL_TYPES = t2.JSX_TYPES = t2.IMPORTOREXPORTDECLARATION_TYPES = t2.IMMUTABLE_TYPES = t2.FUNCTION_TYPES = t2.FUNCTIONPARENT_TYPES = t2.FOR_TYPES = t2.FORXSTATEMENT_TYPES = t2.FLOW_TYPES = t2.FLOWTYPE_TYPES = t2.FLOWPREDICATE_TYPES = t2.FLOWDECLARATION_TYPES = t2.FLOWBASEANNOTATION_TYPES = t2.EXPRESSION_TYPES = t2.EXPRESSIONWRAPPER_TYPES = t2.EXPORTDECLARATION_TYPES = t2.ENUMMEMBER_TYPES = t2.ENUMBODY_TYPES = t2.DECLARATION_TYPES = t2.CONDITIONAL_TYPES = t2.COMPLETIONSTATEMENT_TYPES = t2.CLASS_TYPES = t2.BLOCK_TYPES = t2.BLOCKPARENT_TYPES = t2.BINARY_TYPES = t2.ACCESSOR_TYPES = void 0;
  var n2 = r2(9);
  t2.STANDARDIZED_TYPES = n2.FLIPPED_ALIAS_KEYS.Standardized, t2.EXPRESSION_TYPES = n2.FLIPPED_ALIAS_KEYS.Expression, t2.BINARY_TYPES = n2.FLIPPED_ALIAS_KEYS.Binary, t2.SCOPABLE_TYPES = n2.FLIPPED_ALIAS_KEYS.Scopable, t2.BLOCKPARENT_TYPES = n2.FLIPPED_ALIAS_KEYS.BlockParent, t2.BLOCK_TYPES = n2.FLIPPED_ALIAS_KEYS.Block, t2.STATEMENT_TYPES = n2.FLIPPED_ALIAS_KEYS.Statement, t2.TERMINATORLESS_TYPES = n2.FLIPPED_ALIAS_KEYS.Terminatorless, t2.COMPLETIONSTATEMENT_TYPES = n2.FLIPPED_ALIAS_KEYS.CompletionStatement, t2.CONDITIONAL_TYPES = n2.FLIPPED_ALIAS_KEYS.Conditional, t2.LOOP_TYPES = n2.FLIPPED_ALIAS_KEYS.Loop, t2.WHILE_TYPES = n2.FLIPPED_ALIAS_KEYS.While, t2.EXPRESSIONWRAPPER_TYPES = n2.FLIPPED_ALIAS_KEYS.ExpressionWrapper, t2.FOR_TYPES = n2.FLIPPED_ALIAS_KEYS.For, t2.FORXSTATEMENT_TYPES = n2.FLIPPED_ALIAS_KEYS.ForXStatement, t2.FUNCTION_TYPES = n2.FLIPPED_ALIAS_KEYS.Function, t2.FUNCTIONPARENT_TYPES = n2.FLIPPED_ALIAS_KEYS.FunctionParent, t2.PUREISH_TYPES = n2.FLIPPED_ALIAS_KEYS.Pureish, t2.DECLARATION_TYPES = n2.FLIPPED_ALIAS_KEYS.Declaration, t2.PATTERNLIKE_TYPES = n2.FLIPPED_ALIAS_KEYS.PatternLike, t2.LVAL_TYPES = n2.FLIPPED_ALIAS_KEYS.LVal, t2.TSENTITYNAME_TYPES = n2.FLIPPED_ALIAS_KEYS.TSEntityName, t2.LITERAL_TYPES = n2.FLIPPED_ALIAS_KEYS.Literal, t2.IMMUTABLE_TYPES = n2.FLIPPED_ALIAS_KEYS.Immutable, t2.USERWHITESPACABLE_TYPES = n2.FLIPPED_ALIAS_KEYS.UserWhitespacable, t2.METHOD_TYPES = n2.FLIPPED_ALIAS_KEYS.Method, t2.OBJECTMEMBER_TYPES = n2.FLIPPED_ALIAS_KEYS.ObjectMember, t2.PROPERTY_TYPES = n2.FLIPPED_ALIAS_KEYS.Property, t2.UNARYLIKE_TYPES = n2.FLIPPED_ALIAS_KEYS.UnaryLike, t2.PATTERN_TYPES = n2.FLIPPED_ALIAS_KEYS.Pattern, t2.CLASS_TYPES = n2.FLIPPED_ALIAS_KEYS.Class;
  const s2 = t2.IMPORTOREXPORTDECLARATION_TYPES = n2.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
  t2.EXPORTDECLARATION_TYPES = n2.FLIPPED_ALIAS_KEYS.ExportDeclaration, t2.MODULESPECIFIER_TYPES = n2.FLIPPED_ALIAS_KEYS.ModuleSpecifier, t2.ACCESSOR_TYPES = n2.FLIPPED_ALIAS_KEYS.Accessor, t2.PRIVATE_TYPES = n2.FLIPPED_ALIAS_KEYS.Private, t2.FLOW_TYPES = n2.FLIPPED_ALIAS_KEYS.Flow, t2.FLOWTYPE_TYPES = n2.FLIPPED_ALIAS_KEYS.FlowType, t2.FLOWBASEANNOTATION_TYPES = n2.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, t2.FLOWDECLARATION_TYPES = n2.FLIPPED_ALIAS_KEYS.FlowDeclaration, t2.FLOWPREDICATE_TYPES = n2.FLIPPED_ALIAS_KEYS.FlowPredicate, t2.ENUMBODY_TYPES = n2.FLIPPED_ALIAS_KEYS.EnumBody, t2.ENUMMEMBER_TYPES = n2.FLIPPED_ALIAS_KEYS.EnumMember, t2.JSX_TYPES = n2.FLIPPED_ALIAS_KEYS.JSX, t2.MISCELLANEOUS_TYPES = n2.FLIPPED_ALIAS_KEYS.Miscellaneous, t2.TYPESCRIPT_TYPES = n2.FLIPPED_ALIAS_KEYS.TypeScript, t2.TSTYPEELEMENT_TYPES = n2.FLIPPED_ALIAS_KEYS.TSTypeElement, t2.TSTYPE_TYPES = n2.FLIPPED_ALIAS_KEYS.TSType, t2.TSBASETYPE_TYPES = n2.FLIPPED_ALIAS_KEYS.TSBaseType, t2.MODULEDECLARATION_TYPES = s2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "body";
    const r3 = (0, n2.default)(e3[t3], e3);
    return e3[t3] = r3, r3;
  };
  var n2 = r2(177);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return "eval" !== (e3 = (0, n2.default)(e3)) && "arguments" !== e3 || (e3 = "_" + e3), e3;
  };
  var n2 = r2(178);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e3.key || e3.property;
    return !e3.computed && (0, n2.isIdentifier)(t3) && (t3 = (0, s2.stringLiteral)(t3.name)), t3;
  };
  var n2 = r2(2), s2 = r2(4);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(2);
  t2.default = function(e3) {
    if ((0, n2.isExpressionStatement)(e3) && (e3 = e3.expression), (0, n2.isExpression)(e3)) return e3;
    if ((0, n2.isClass)(e3) ? e3.type = "ClassExpression" : (0, n2.isFunction)(e3) && (e3.type = "FunctionExpression"), !(0, n2.isExpression)(e3)) throw new Error(`cannot turn ${e3.type} to an expression`);
    return e3;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = o2;
  var n2 = r2(2), s2 = r2(27), i2 = r2(179);
  function o2(e3) {
    let t3, r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e3.key;
    return "method" === e3.kind ? o2.increment() + "" : (t3 = (0, n2.isIdentifier)(r3) ? r3.name : (0, n2.isStringLiteral)(r3) ? JSON.stringify(r3.value) : JSON.stringify((0, i2.default)((0, s2.default)(r3))), e3.computed && (t3 = `[${t3}]`), e3.static && (t3 = `static:${t3}`), t3);
  }
  o2.uid = 0, o2.increment = function() {
    return o2.uid >= Number.MAX_SAFE_INTEGER ? o2.uid = 0 : o2.uid++;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(2), s2 = r2(4);
  t2.default = function(e3, t3) {
    if ((0, n2.isStatement)(e3)) return e3;
    let r3, i2 = false;
    if ((0, n2.isClass)(e3)) i2 = true, r3 = "ClassDeclaration";
    else if ((0, n2.isFunction)(e3)) i2 = true, r3 = "FunctionDeclaration";
    else if ((0, n2.isAssignmentExpression)(e3)) return (0, s2.expressionStatement)(e3);
    if (i2 && !e3.id && (r3 = false), !r3) {
      if (t3) return false;
      throw new Error(`cannot turn ${e3.type} to a statement`);
    }
    return e3.type = r3, e3;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(43), s2 = r2(4);
  t2.default = function e3(t3) {
    if (void 0 === t3) return (0, s2.identifier)("undefined");
    if (true === t3 || false === t3) return (0, s2.booleanLiteral)(t3);
    if (null === t3) return (0, s2.nullLiteral)();
    if ("string" == typeof t3) return (0, s2.stringLiteral)(t3);
    if ("number" == typeof t3) {
      let e4;
      if (Number.isFinite(t3)) e4 = (0, s2.numericLiteral)(Math.abs(t3));
      else {
        let r3;
        r3 = Number.isNaN(t3) ? (0, s2.numericLiteral)(0) : (0, s2.numericLiteral)(1), e4 = (0, s2.binaryExpression)("/", r3, (0, s2.numericLiteral)(0));
      }
      return (t3 < 0 || Object.is(t3, -0)) && (e4 = (0, s2.unaryExpression)("-", e4)), e4;
    }
    if (function(e4) {
      return "[object RegExp]" === i2(e4);
    }(t3)) {
      const e4 = t3.source, r3 = t3.toString().match(/\/([a-z]+|)$/)[1];
      return (0, s2.regExpLiteral)(e4, r3);
    }
    if (Array.isArray(t3)) return (0, s2.arrayExpression)(t3.map(e3));
    if (function(e4) {
      if ("object" != typeof e4 || null === e4 || "[object Object]" !== Object.prototype.toString.call(e4)) return false;
      const t4 = Object.getPrototypeOf(e4);
      return null === t4 || null === Object.getPrototypeOf(t4);
    }(t3)) {
      const r3 = [];
      for (const i3 of Object.keys(t3)) {
        let o2;
        o2 = (0, n2.default)(i3) ? (0, s2.identifier)(i3) : (0, s2.stringLiteral)(i3), r3.push((0, s2.objectProperty)(o2, e3(t3[i3])));
      }
      return (0, s2.objectExpression)(r3);
    }
    throw new Error("don't know how to turn this value into a node");
  };
  const i2 = Function.call.bind(Object.prototype.toString);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return e3.object = (0, n2.memberExpression)(e3.object, e3.property, e3.computed), e3.property = t3, e3.computed = !!r3, e3;
  };
  var n2 = r2(4);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if (!e3 || !t3) return e3;
    for (const r3 of n2.INHERIT_KEYS.optional) null == e3[r3] && (e3[r3] = t3[r3]);
    for (const r3 of Object.keys(t3)) "_" === r3[0] && "__clone" !== r3 && (e3[r3] = t3[r3]);
    for (const r3 of n2.INHERIT_KEYS.force) e3[r3] = t3[r3];
    return (0, s2.default)(e3, t3), e3;
  };
  var n2 = r2(26), s2 = r2(175);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if ((0, s2.isSuper)(e3.object)) throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return e3.object = (0, n2.memberExpression)(t3, e3.object), e3;
  };
  var n2 = r2(4), s2 = r2(0);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(60);
  t2.default = function(e3, t3) {
    return (0, n2.default)(e3, t3, true);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    "function" == typeof t3 && (t3 = { enter: t3 });
    const { enter: n3, exit: i2 } = t3;
    s2(e3, n3, i2, r3, []);
  };
  var n2 = r2(9);
  function s2(e3, t3, r3, i2, o2) {
    const a2 = n2.VISITOR_KEYS[e3.type];
    if (a2) {
      t3 && t3(e3, o2, i2);
      for (const n3 of a2) {
        const a3 = e3[n3];
        if (Array.isArray(a3)) for (let l = 0; l < a3.length; l++) {
          const c = a3[l];
          c && (o2.push({ node: e3, key: n3, index: l }), s2(c, t3, r3, i2, o2), o2.pop());
        }
        else a3 && (o2.push({ node: e3, key: n3 }), s2(a3, t3, r3, i2, o2), o2.pop());
      }
      r3 && r3(e3, o2, i2);
    }
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    if (r3 && "Identifier" === e3.type && "ObjectProperty" === t3.type && "ObjectExpression" === r3.type) return false;
    const s2 = n2.default.keys[t3.type];
    if (s2) for (let r4 = 0; r4 < s2.length; r4++) {
      const n3 = t3[s2[r4]];
      if (Array.isArray(n3)) {
        if (n3.indexOf(e3) >= 0) return true;
      } else if (n3 === e3) return true;
    }
    return false;
  };
  var n2 = r2(60);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.isFunctionDeclaration)(e3) || (0, n2.isClassDeclaration)(e3) || (0, s2.default)(e3);
  };
  var n2 = r2(2), s2 = r2(182);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return !!(0, n2.default)(e3.type, "Immutable") || !!(0, s2.isIdentifier)(e3) && "undefined" === e3.name;
  };
  var n2 = r2(98), s2 = r2(2);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, r3) {
    if ("object" != typeof t3 || "object" != typeof r3 || null == t3 || null == r3) return t3 === r3;
    if (t3.type !== r3.type) return false;
    const s2 = Object.keys(n2.NODE_FIELDS[t3.type] || t3.type), i2 = n2.VISITOR_KEYS[t3.type];
    for (const n3 of s2) {
      const s3 = t3[n3], o2 = r3[n3];
      if (typeof s3 != typeof o2) return false;
      if (null != s3 || null != o2) {
        if (null == s3 || null == o2) return false;
        if (Array.isArray(s3)) {
          if (!Array.isArray(o2)) return false;
          if (s3.length !== o2.length) return false;
          for (let t4 = 0; t4 < s3.length; t4++) if (!e3(s3[t4], o2[t4])) return false;
        } else if ("object" != typeof s3 || null != i2 && i2.includes(n3)) {
          if (!e3(s3, o2)) return false;
        } else for (const e4 of Object.keys(s3)) if (s3[e4] !== o2[e4]) return false;
      }
    }
    return true;
  };
  var n2 = r2(9);
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r2) {
    switch (t3.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return t3.property === e3 ? !!t3.computed : t3.object === e3;
      case "JSXMemberExpression":
        return t3.object === e3;
      case "VariableDeclarator":
        return t3.init === e3;
      case "ArrowFunctionExpression":
        return t3.body === e3;
      case "PrivateName":
      case "LabeledStatement":
      case "CatchClause":
      case "RestElement":
      case "BreakStatement":
      case "ContinueStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportAttribute":
      case "JSXAttribute":
      case "ObjectPattern":
      case "ArrayPattern":
      case "MetaProperty":
        return false;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return t3.key === e3 && !!t3.computed;
      case "ObjectProperty":
        return t3.key === e3 ? !!t3.computed : !r2 || "ObjectPattern" !== r2.type;
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "TSPropertySignature":
        return t3.key !== e3 || !!t3.computed;
      case "ClassPrivateProperty":
      case "ObjectTypeProperty":
        return t3.key !== e3;
      case "ClassDeclaration":
      case "ClassExpression":
        return t3.superClass === e3;
      case "AssignmentExpression":
      case "AssignmentPattern":
        return t3.right === e3;
      case "ExportSpecifier":
        return (null == r2 || !r2.source) && t3.local === e3;
      case "TSEnumMember":
        return t3.id !== e3;
    }
    return true;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    return (!(0, n2.isBlockStatement)(e3) || !(0, n2.isFunction)(t3) && !(0, n2.isCatchClause)(t3)) && (!(!(0, n2.isPattern)(e3) || !(0, n2.isFunction)(t3) && !(0, n2.isCatchClause)(t3)) || (0, n2.isScopable)(e3));
  };
  var n2 = r2(2);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.isImportDefaultSpecifier)(e3) || (0, n2.isIdentifier)(e3.imported || e3.exported, { name: "default" });
  };
  var n2 = r2(2);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.default)(e3) && !s2.has(e3);
  };
  var n2 = r2(43);
  const s2 = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.isVariableDeclaration)(e3, { kind: "var" }) && !e3[s2.BLOCK_SCOPED_SYMBOL];
  };
  var n2 = r2(2), s2 = r2(26);
}, (e2, t2, r2) => {
  t2.default = function(e3, t3) {
    if (null == e3 || !e3.length) return;
    const r3 = [], s2 = (0, n2.default)(e3, t3, r3);
    if (s2) {
      for (const e4 of r3) t3.push(e4);
      return s2;
    }
  };
  var n2 = r2(399);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, r3, a2) {
    const l = [];
    let c = true;
    for (const u of t3) if ((0, s2.isEmptyStatement)(u) || (c = false), (0, s2.isExpression)(u)) l.push(u);
    else if ((0, s2.isExpressionStatement)(u)) l.push(u.expression);
    else if ((0, s2.isVariableDeclaration)(u)) {
      if ("var" !== u.kind) return;
      for (const e4 of u.declarations) {
        const t4 = (0, n2.default)(e4);
        for (const e5 of Object.keys(t4)) a2.push({ kind: u.kind, id: (0, o2.default)(t4[e5]) });
        e4.init && l.push((0, i2.assignmentExpression)("=", e4.id, e4.init));
      }
      c = true;
    } else if ((0, s2.isIfStatement)(u)) {
      const t4 = u.consequent ? e3([u.consequent], r3, a2) : r3.buildUndefinedNode(), n3 = u.alternate ? e3([u.alternate], r3, a2) : r3.buildUndefinedNode();
      if (!t4 || !n3) return;
      l.push((0, i2.conditionalExpression)(u.test, t4, n3));
    } else if ((0, s2.isBlockStatement)(u)) {
      const t4 = e3(u.body, r3, a2);
      if (!t4) return;
      l.push(t4);
    } else {
      if (!(0, s2.isEmptyStatement)(u)) return;
      0 === t3.indexOf(u) && (c = true);
    }
    return c && l.push(r3.buildUndefinedNode()), 1 === l.length ? l[0] : (0, i2.sequenceExpression)(l);
  };
  var n2 = r2(60), s2 = r2(2), i2 = r2(4), o2 = r2(27);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(28), s2 = r2(0);
  const { VISITOR_KEYS: i2 } = s2;
  t2.default = class {
    constructor(e3, t3, r3, n3) {
      this.queue = null, this.priorityQueue = null, this.parentPath = n3, this.scope = e3, this.state = r3, this.opts = t3;
    }
    shouldVisit(e3) {
      const t3 = this.opts;
      if (t3.enter || t3.exit) return true;
      if (t3[e3.type]) return true;
      const r3 = i2[e3.type];
      if (null == r3 || !r3.length) return false;
      for (const t4 of r3) if (e3[t4]) return true;
      return false;
    }
    create(e3, t3, r3, s3) {
      return n2.default.get({ parentPath: this.parentPath, parent: e3, container: t3, key: r3, listKey: s3 });
    }
    maybeQueue(e3, t3) {
      this.queue && (t3 ? this.queue.push(e3) : this.priorityQueue.push(e3));
    }
    visitMultiple(e3, t3, r3) {
      if (0 === e3.length) return false;
      const n3 = [];
      for (let s3 = 0; s3 < e3.length; s3++) {
        const i3 = e3[s3];
        i3 && this.shouldVisit(i3) && n3.push(this.create(t3, e3, s3, r3));
      }
      return this.visitQueue(n3);
    }
    visitSingle(e3, t3) {
      return !!this.shouldVisit(e3[t3]) && this.visitQueue([this.create(e3, e3, t3)]);
    }
    visitQueue(e3) {
      this.queue = e3, this.priorityQueue = [];
      const t3 = /* @__PURE__ */ new WeakSet();
      let r3 = false;
      for (const n3 of e3) {
        if (n3.resync(), 0 !== n3.contexts.length && n3.contexts[n3.contexts.length - 1] === this || n3.pushContext(this), null === n3.key) continue;
        const { node: s3 } = n3;
        if (!t3.has(s3)) {
          if (s3 && t3.add(s3), n3.visit()) {
            r3 = true;
            break;
          }
          if (this.priorityQueue.length && (r3 = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = e3, r3)) break;
        }
      }
      for (const t4 of e3) t4.popContext();
      return this.queue = null, r3;
    }
    visit(e3, t3) {
      const r3 = e3[t3];
      return !!r3 && (Array.isArray(r3) ? this.visitMultiple(r3, e3, t3) : this.visitSingle(e3, t3));
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(62), s2 = r2(0), i2 = r2(33), o2 = r2(100), a2 = r2(57);
  const l = { ReferencedIdentifier(e3, t3) {
    let { node: r3 } = e3;
    r3.name === t3.oldName && (r3.name = t3.newName);
  }, Scope(e3, t3) {
    e3.scope.bindingIdentifierEquals(t3.oldName, t3.binding.identifier) || (e3.skip(), e3.isMethod() && (0, i2.requeueComputedKeyAndDecorators)(e3));
  }, ObjectProperty(e3, t3) {
    let { node: r3, scope: n3 } = e3;
    const { name: s3 } = r3.key;
    var i3;
    !r3.shorthand || s3 !== t3.oldName && s3 !== t3.newName || n3.getBindingIdentifier(s3) !== t3.binding.identifier || (r3.shorthand = false, null != (i3 = r3.extra) && i3.shorthand && (r3.extra.shorthand = false));
  }, "AssignmentExpression|Declaration|VariableDeclarator"(e3, t3) {
    if (e3.isVariableDeclaration()) return;
    const r3 = e3.getOuterBindingIdentifiers();
    for (const e4 in r3) e4 === t3.oldName && (r3[e4].name = t3.newName);
  } };
  t2.default = class {
    constructor(e3, t3, r3) {
      this.newName = r3, this.oldName = t3, this.binding = e3;
    }
    maybeConvertFromExportDeclaration(e3) {
      const t3 = e3.parentPath;
      if (t3.isExportDeclaration()) {
        if (t3.isExportDefaultDeclaration()) {
          const { declaration: e4 } = t3.node;
          if (s2.isDeclaration(e4) && !e4.id) return;
        }
        t3.isExportAllDeclaration() || (0, n2.default)(t3);
      }
    }
    maybeConvertFromClassFunctionDeclaration(e3) {
      return e3;
    }
    maybeConvertFromClassFunctionExpression(e3) {
      return e3;
    }
    rename() {
      const { binding: e3, oldName: t3, newName: r3 } = this, { scope: n3, path: s3 } = e3, i3 = s3.find((e4) => e4.isDeclaration() || e4.isFunctionExpression() || e4.isClassExpression());
      i3 && i3.getOuterBindingIdentifiers()[t3] === e3.identifier && this.maybeConvertFromExportDeclaration(i3);
      const c = arguments[0] || n3.block;
      (0, o2.traverseNode)(c, (0, a2.explode)(l), n3, this, n3.path, { discriminant: true }), arguments[0] || (n3.removeOwnBinding(t3), n3.bindings[r3] = e3, this.binding.identifier.name = r3), i3 && (this.maybeConvertFromClassFunctionDeclaration(s3), this.maybeConvertFromClassFunctionExpression(s3));
    }
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = class {
    constructor(e3) {
      let { identifier: t3, scope: r2, path: n2, kind: s2 } = e3;
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = true, this.referencePaths = [], this.referenced = false, this.references = 0, this.identifier = t3, this.scope = r2, this.path = n2, this.kind = s2, "var" !== s2 && "hoisted" !== s2 || !function(e4) {
        for (let { parentPath: t4, key: r3 } = e4; t4; { parentPath: t4, key: r3 } = t4) {
          if (t4.isFunctionParent()) return false;
          if (t4.isWhile() || t4.isForXStatement() || t4.isForStatement() && "body" === r3) return true;
        }
        return false;
      }(n2) || this.reassign(n2), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = true;
    }
    setValue(e3) {
      this.hasDeoptedValue || (this.hasValue = true, this.value = e3);
    }
    clearValue() {
      this.hasDeoptedValue = false, this.hasValue = false, this.value = null;
    }
    reassign(e3) {
      this.constant = false, -1 === this.constantViolations.indexOf(e3) && this.constantViolations.push(e3);
    }
    reference(e3) {
      -1 === this.referencePaths.indexOf(e3) && (this.referenced = true, this.references++, this.referencePaths.push(e3));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
}, (e2, t2, r2) => {
  e2.exports = r2(404);
}, (e2) => {
  e2.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(406), s2 = r2(407);
  t2.default = class {
    constructor(e3, t3) {
      var r3;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
      const i2 = this._map = new n2.GenMapping({ sourceRoot: e3.sourceRoot });
      if (this._sourceFileName = null == (r3 = e3.sourceFileName) ? void 0 : r3.replace(/\\/g, "/"), this._rawMappings = void 0, e3.inputSourceMap) {
        this._inputMap = new s2.TraceMap(e3.inputSourceMap);
        const t4 = this._inputMap.resolvedSources;
        if (t4.length) for (let e4 = 0; e4 < t4.length; e4++) {
          var o2;
          (0, n2.setSourceContent)(i2, t4[e4], null == (o2 = this._inputMap.sourcesContent) ? void 0 : o2[e4]);
        }
      }
      if ("string" != typeof t3 || e3.inputSourceMap) {
        if ("object" == typeof t3) for (const e4 of Object.keys(t3)) (0, n2.setSourceContent)(i2, e4.replace(/\\/g, "/"), t3[e4]);
      } else (0, n2.setSourceContent)(i2, this._sourceFileName, t3);
    }
    get() {
      return (0, n2.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, n2.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, n2.allMappings)(this._map));
    }
    mark(e3, t3, r3, i2, o2, a2) {
      var l;
      let c;
      if (this._rawMappings = void 0, null != t3) if (this._inputMap) {
        if (c = (0, s2.originalPositionFor)(this._inputMap, { line: t3, column: r3 }), !c.name && o2) {
          const e4 = (0, s2.originalPositionFor)(this._inputMap, o2);
          e4.name && (i2 = e4.name);
        }
      } else c = { source: (null == a2 ? void 0 : a2.replace(/\\/g, "/")) || this._sourceFileName, line: t3, column: r3 };
      (0, n2.maybeAddMapping)(this._map, { name: i2, generated: e3, source: null == (l = c) ? void 0 : l.source, original: c });
    }
  };
}, () => {
}, () => {
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(409), s2 = r2(184), i2 = r2(0), o2 = r2(155);
  const { isFunction: a2, isStatement: l, isClassBody: c, isTSInterfaceBody: u, isTSEnumDeclaration: p } = i2, d = /e/i, f = /\.0+$/, h = /[\n\r\u2028\u2029]/, m = /[\n\r\u2028\u2029]|\*\//, { needsParens: y } = s2;
  class g {
    constructor(e3, t3) {
      this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentRepeat = 0, this._insideAux = false, this._parenPushNewlineState = null, this._noLineTerminator = false, this._printAuxAfterOnNextUserNode = false, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = false, this._endsWithWord = false, this._lastCommentLine = 0, this._endsWithInnerRaw = false, this._indentInnerComments = true, this.format = e3, this._indentRepeat = e3.indent.style.length, this._inputMap = null == t3 ? void 0 : t3._inputMap, this._buf = new n2.default(t3, e3.indent.style[0]);
    }
    generate(e3) {
      return this.print(e3), this._maybeAddAuxComment(), this._buf.get();
    }
    indent() {
      this.format.compact || this.format.concise || this._indent++;
    }
    dedent() {
      this.format.compact || this.format.concise || this._indent--;
    }
    semicolon() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      this._maybeAddAuxComment(), e3 ? this._appendChar(59) : this._queue(59), this._noLineTerminator = false;
    }
    rightBrace(e3) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e3.loc, -1), this.tokenChar(125);
    }
    rightParens(e3) {
      this.sourceWithOffset("end", e3.loc, -1), this.tokenChar(41);
    }
    space() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (!this.format.compact) {
        if (e3) this._space();
        else if (this._buf.hasContent()) {
          const e4 = this.getLastChar();
          32 !== e4 && 10 !== e4 && this._space();
        }
      }
    }
    word(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      this._maybePrintInnerComments(), (this._endsWithWord || 47 === e3.charCodeAt(0) && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(), this._append(e3, false), this._endsWithWord = true, this._noLineTerminator = t3;
    }
    number(e3, t3) {
      this.word(e3), this._endsWithInteger = Number.isInteger(t3) && !function(e4) {
        if (e4.length > 2 && 48 === e4.charCodeAt(0)) {
          const t4 = e4.charCodeAt(1);
          return 98 === t4 || 111 === t4 || 120 === t4;
        }
        return false;
      }(e3) && !d.test(e3) && !f.test(e3) && 46 !== e3.charCodeAt(e3.length - 1);
    }
    token(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      this._maybePrintInnerComments();
      const r3 = this.getLastChar(), n3 = e3.charCodeAt(0);
      (33 === r3 && ("--" === e3 || 61 === n3) || 43 === n3 && 43 === r3 || 45 === n3 && 45 === r3 || 46 === n3 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(e3, t3), this._noLineTerminator = false;
    }
    tokenChar(e3) {
      this._maybePrintInnerComments();
      const t3 = this.getLastChar();
      (43 === e3 && 43 === t3 || 45 === e3 && 45 === t3 || 46 === e3 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._appendChar(e3), this._noLineTerminator = false;
    }
    newline() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
      if (!(e3 <= 0)) {
        if (!(arguments.length > 1 ? arguments[1] : void 0)) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) return void this.space();
        }
        e3 > 2 && (e3 = 2), e3 -= this._buf.getNewlineCount();
        for (let t3 = 0; t3 < e3; t3++) this._newline();
      }
    }
    endsWith(e3) {
      return this.getLastChar() === e3;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(e3, t3) {
      e3 ? (this._catchUp("start", e3), this._buf.exactSource(e3, t3)) : t3();
    }
    source(e3, t3) {
      t3 && (this._catchUp(e3, t3), this._buf.source(e3, t3));
    }
    sourceWithOffset(e3, t3, r3) {
      t3 && (this._catchUp(e3, t3), this._buf.sourceWithOffset(e3, t3, r3));
    }
    withSource(e3, t3, r3) {
      t3 ? (this._catchUp(e3, t3), this._buf.withSource(e3, t3, r3)) : r3();
    }
    sourceIdentifierName(e3, t3) {
      if (!this._buf._canMarkIdName) return;
      const r3 = this._buf._sourcePosition;
      r3.identifierNamePos = t3, r3.identifierName = e3;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _append(e3, t3) {
      this._maybeAddParen(e3), this._maybeIndent(e3.charCodeAt(0)), this._buf.append(e3, t3), this._endsWithWord = false, this._endsWithInteger = false;
    }
    _appendChar(e3) {
      this._maybeAddParenChar(e3), this._maybeIndent(e3), this._buf.appendChar(e3), this._endsWithWord = false, this._endsWithInteger = false;
    }
    _queue(e3) {
      this._maybeAddParenChar(e3), this._maybeIndent(e3), this._buf.queue(e3), this._endsWithWord = false, this._endsWithInteger = false;
    }
    _maybeIndent(e3) {
      this._indent && 10 !== e3 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(e3) {
      if (this._indent && 10 !== e3 && this.endsWith(10)) return true;
    }
    _maybeAddParenChar(e3) {
      const t3 = this._parenPushNewlineState;
      t3 && 32 !== e3 && (10 === e3 ? (this.tokenChar(40), this.indent(), t3.printed = true) : this._parenPushNewlineState = null);
    }
    _maybeAddParen(e3) {
      const t3 = this._parenPushNewlineState;
      if (!t3) return;
      const r3 = e3.length;
      let n3;
      for (n3 = 0; n3 < r3 && 32 === e3.charCodeAt(n3); n3++) continue;
      if (n3 === r3) return;
      const s3 = e3.charCodeAt(n3);
      if (10 !== s3) {
        if (47 !== s3 || n3 + 1 === r3) return void (this._parenPushNewlineState = null);
        const t4 = e3.charCodeAt(n3 + 1);
        if (42 === t4) return;
        if (47 !== t4) return void (this._parenPushNewlineState = null);
      }
      this.tokenChar(40), this.indent(), t3.printed = true;
    }
    catchUp(e3) {
      if (!this.format.retainLines) return;
      const t3 = e3 - this._buf.getCurrentLine();
      for (let e4 = 0; e4 < t3; e4++) this._newline();
    }
    _catchUp(e3, t3) {
      var r3;
      if (!this.format.retainLines) return;
      const n3 = null == t3 || null == (r3 = t3[e3]) ? void 0 : r3.line;
      if (null != n3) {
        const e4 = n3 - this._buf.getCurrentLine();
        for (let t4 = 0; t4 < e4; t4++) this._newline();
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(e3, t3, r3) {
      if (r3) this._noLineTerminator = true, this.print(e3, t3);
      else {
        const r4 = { printed: false };
        this._parenPushNewlineState = r4, this.print(e3, t3), r4.printed && (this.dedent(), this.newline(), this.tokenChar(41));
      }
    }
    print(e3, t3, r3, n3, s3) {
      var i3, o3;
      if (!e3) return;
      this._endsWithInnerRaw = false;
      const a3 = e3.type, l2 = this.format, c2 = l2.concise;
      e3._compact && (l2.concise = true);
      const u2 = this[a3];
      if (void 0 === u2) throw new ReferenceError(`unknown node of type ${JSON.stringify(a3)} with constructor ${JSON.stringify(e3.constructor.name)}`);
      this._printStack.push(e3);
      const p2 = this._insideAux;
      this._insideAux = null == e3.loc, this._maybeAddAuxComment(this._insideAux && !p2);
      const d2 = null == (i3 = e3.extra) ? void 0 : i3.parenthesized;
      let f2 = s3 || d2 && l2.retainFunctionParens && "FunctionExpression" === a3 || y(e3, t3, this._printStack);
      if (!f2 && d2 && null != (o3 = e3.leadingComments) && o3.length && "CommentBlock" === e3.leadingComments[0].type) switch (null == t3 ? void 0 : t3.type) {
        case "ExpressionStatement":
        case "VariableDeclarator":
        case "AssignmentExpression":
        case "ReturnStatement":
          break;
        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          if (t3.callee !== e3) break;
        default:
          f2 = true;
      }
      f2 && (this.tokenChar(40), this._endsWithInnerRaw = false), this._lastCommentLine = 0, this._printLeadingComments(e3, t3);
      const h2 = "Program" === a3 || "File" === a3 ? null : e3.loc;
      this.exactSource(h2, u2.bind(this, e3, t3)), f2 ? (this._printTrailingComments(e3, t3), this.tokenChar(41), this._noLineTerminator = r3) : r3 && !this._noLineTerminator ? (this._noLineTerminator = true, this._printTrailingComments(e3, t3)) : this._printTrailingComments(e3, t3, n3), this._printStack.pop(), l2.concise = c2, this._insideAux = p2, this._endsWithInnerRaw = false;
    }
    _maybeAddAuxComment(e3) {
      e3 && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = true;
      const e3 = this.format.auxiliaryCommentBefore;
      e3 && this._printComment({ type: "CommentBlock", value: e3 }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = false;
      const e3 = this.format.auxiliaryCommentAfter;
      e3 && this._printComment({ type: "CommentBlock", value: e3 }, 0);
    }
    getPossibleRaw(e3) {
      const t3 = e3.extra;
      if (null != (null == t3 ? void 0 : t3.raw) && null != t3.rawValue && e3.value === t3.rawValue) return t3.raw;
    }
    printJoin(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      if (null == e3 || !e3.length) return;
      let { indent: n3 } = r3;
      if (null == n3 && this.format.retainLines) {
        var s3;
        const t4 = null == (s3 = e3[0].loc) ? void 0 : s3.start.line;
        null != t4 && t4 !== this._buf.getCurrentLine() && (n3 = true);
      }
      n3 && this.indent();
      const i3 = { addNewlines: r3.addNewlines, nextNodeStartLine: 0 }, o3 = r3.separator ? r3.separator.bind(this) : null, a3 = e3.length;
      for (let n4 = 0; n4 < a3; n4++) {
        const s4 = e3[n4];
        var l2;
        if (s4 && (r3.statement && this._printNewline(0 === n4, i3), this.print(s4, t3, void 0, r3.trailingCommentsLineOffset || 0), null == r3.iterator || r3.iterator(s4, n4), n4 < a3 - 1 && (null == o3 || o3()), r3.statement)) if (null != (l2 = s4.trailingComments) && l2.length || (this._lastCommentLine = 0), n4 + 1 === a3) this.newline(1);
        else {
          var c2;
          const t4 = e3[n4 + 1];
          i3.nextNodeStartLine = (null == (c2 = t4.loc) ? void 0 : c2.start.line) || 0, this._printNewline(true, i3);
        }
      }
      n3 && this.dedent();
    }
    printAndIndentOnComments(e3, t3) {
      const r3 = e3.leadingComments && e3.leadingComments.length > 0;
      r3 && this.indent(), this.print(e3, t3), r3 && this.dedent();
    }
    printBlock(e3) {
      const t3 = e3.body;
      "EmptyStatement" !== t3.type && this.space(), this.print(t3, e3);
    }
    _printTrailingComments(e3, t3, r3) {
      const { innerComments: n3, trailingComments: s3 } = e3;
      null != n3 && n3.length && this._printComments(2, n3, e3, t3, r3), null != s3 && s3.length && this._printComments(2, s3, e3, t3, r3);
    }
    _printLeadingComments(e3, t3) {
      const r3 = e3.leadingComments;
      null != r3 && r3.length && this._printComments(0, r3, e3, t3);
    }
    _maybePrintInnerComments() {
      this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = true, this._indentInnerComments = true;
    }
    printInnerComments() {
      const e3 = this._printStack[this._printStack.length - 1], t3 = e3.innerComments;
      if (null == t3 || !t3.length) return;
      const r3 = this.endsWith(32), n3 = this._indentInnerComments, s3 = this._printedComments.size;
      n3 && this.indent(), this._printComments(1, t3, e3), r3 && s3 !== this._printedComments.size && this.space(), n3 && this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = false;
    }
    printSequence(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      r3.statement = true, null != r3.indent || (r3.indent = false), this.printJoin(e3, t3, r3);
    }
    printList(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      null == r3.separator && (r3.separator = b), this.printJoin(e3, t3, r3);
    }
    _printNewline(e3, t3) {
      const r3 = this.format;
      if (r3.retainLines || r3.compact) return;
      if (r3.concise) return void this.space();
      if (!e3) return;
      const n3 = t3.nextNodeStartLine, s3 = this._lastCommentLine;
      if (n3 > 0 && s3 > 0) {
        const e4 = n3 - s3;
        if (e4 >= 0) return void this.newline(e4 || 1);
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(e3) {
      return e3.ignore || this._printedComments.has(e3) ? 0 : this._noLineTerminator && m.test(e3.value) ? 2 : (this._printedComments.add(e3), this.format.shouldPrintComment(e3.value) ? 1 : 0);
    }
    _printComment(e3, t3) {
      const r3 = this._noLineTerminator, n3 = "CommentBlock" === e3.type, s3 = n3 && 1 !== t3 && !this._noLineTerminator;
      s3 && this._buf.hasContent() && 2 !== t3 && this.newline(1);
      const i3 = this.getLastChar();
      let o3;
      if (91 !== i3 && 123 !== i3 && this.space(), n3) {
        const { _parenPushNewlineState: t4 } = this;
        if (false === (null == t4 ? void 0 : t4.printed) && h.test(e3.value) && (this.tokenChar(40), this.indent(), t4.printed = true), o3 = `/*${e3.value}*/`, this.format.indent.adjustMultilineComment) {
          var a3;
          const t5 = null == (a3 = e3.loc) ? void 0 : a3.start.column;
          if (t5) {
            const e4 = new RegExp("\\n\\s{1," + t5 + "}", "g");
            o3 = o3.replace(e4, "\n");
          }
          if (this.format.concise) o3 = o3.replace(/\n(?!$)/g, "\n");
          else {
            let e4 = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (e4 += this._getIndent()), o3 = o3.replace(/\n(?!$)/g, `
${" ".repeat(e4)}`);
          }
        }
      } else o3 = r3 ? `/*${e3.value}*/` : `//${e3.value}`;
      this.endsWith(47) && this._space(), this.source("start", e3.loc), this._append(o3, n3), n3 || r3 || this.newline(1, true), s3 && 3 !== t3 && this.newline(1);
    }
    _printComments(e3, t3, r3, n3) {
      let s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
      const i3 = r3.loc, o3 = t3.length;
      let d2 = !!i3;
      const f2 = d2 ? i3.start.line : 0, m2 = d2 ? i3.end.line : 0;
      let y2 = 0, g2 = 0;
      const b2 = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let i4 = 0; i4 < o3; i4++) {
        const v = t3[i4], E = this._shouldPrintComment(v);
        if (2 === E) {
          d2 = false;
          break;
        }
        if (d2 && v.loc && 1 === E) {
          const t4 = v.loc.start.line, r4 = v.loc.end.line;
          if (0 === e3) {
            let e4 = 0;
            0 === i4 ? !this._buf.hasContent() || "CommentLine" !== v.type && t4 == r4 || (e4 = g2 = 1) : e4 = t4 - y2, y2 = r4, b2(e4), this._printComment(v, 1), i4 + 1 === o3 && (b2(Math.max(f2 - y2, g2)), y2 = f2);
          } else if (1 === e3) {
            const e4 = t4 - (0 === i4 ? f2 : y2);
            y2 = r4, b2(e4), this._printComment(v, 1), i4 + 1 === o3 && (b2(Math.min(1, m2 - y2)), y2 = m2);
          } else {
            const e4 = t4 - (0 === i4 ? m2 - s3 : y2);
            y2 = r4, b2(e4), this._printComment(v, 1);
          }
        } else {
          if (d2 = false, 1 !== E) continue;
          if (1 === o3) {
            const t4 = v.loc ? v.loc.start.line === v.loc.end.line : !h.test(v.value), s4 = t4 && !l(r3) && !c(n3) && !u(n3) && !p(n3);
            0 === e3 ? this._printComment(v, s4 && "ObjectExpression" !== r3.type || t4 && a2(n3, { body: r3 }) ? 1 : 0) : s4 && 2 === e3 ? this._printComment(v, 1) : this._printComment(v, 0);
          } else 1 !== e3 || "ObjectExpression" === r3.type && r3.properties.length > 1 || "ClassBody" === r3.type || "TSInterfaceBody" === r3.type ? this._printComment(v, 0) : this._printComment(v, 0 === i4 ? 2 : i4 === o3 - 1 ? 3 : 0);
        }
      }
      2 === e3 && d2 && y2 && (this._lastCommentLine = y2);
    }
  }
  function b() {
    this.tokenChar(44), this.space();
  }
  Object.assign(g.prototype, o2), g.prototype.Noop = function() {
  }, t2.default = g;
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = class {
    constructor(e3, t3) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = true, this._indentChar = "", this._fastIndentations = [], this._position = { line: 1, column: 0 }, this._sourcePosition = { identifierName: void 0, identifierNamePos: void 0, line: void 0, column: void 0, filename: void 0 }, this._map = e3, this._indentChar = t3;
      for (let e4 = 0; e4 < 64; e4++) this._fastIndentations.push(t3.repeat(e4));
      this._allocQueue();
    }
    _allocQueue() {
      const e3 = this._queue;
      for (let t3 = 0; t3 < 16; t3++) e3.push({ char: 0, repeat: 1, line: void 0, column: void 0, identifierName: void 0, identifierNamePos: void 0, filename: "" });
    }
    _pushQueue(e3, t3, r2, n2, s2) {
      const i2 = this._queueCursor;
      i2 === this._queue.length && this._allocQueue();
      const o2 = this._queue[i2];
      o2.char = e3, o2.repeat = t3, o2.line = r2, o2.column = n2, o2.filename = s2, this._queueCursor++;
    }
    _popQueue() {
      if (0 === this._queueCursor) throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      const e3 = this._map, t3 = { code: (this._buf + this._str).trimRight(), decodedMap: null == e3 ? void 0 : e3.getDecoded(), get __mergedMap() {
        return this.map;
      }, get map() {
        const r2 = e3 ? e3.get() : null;
        return t3.map = r2, r2;
      }, set map(e4) {
        Object.defineProperty(t3, "map", { value: e4, writable: true });
      }, get rawMappings() {
        const r2 = null == e3 ? void 0 : e3.getRawMappings();
        return t3.rawMappings = r2, r2;
      }, set rawMappings(e4) {
        Object.defineProperty(t3, "rawMappings", { value: e4, writable: true });
      } };
      return t3;
    }
    append(e3, t3) {
      this._flush(), this._append(e3, this._sourcePosition, t3);
    }
    appendChar(e3) {
      this._flush(), this._appendChar(e3, 1, this._sourcePosition);
    }
    queue(e3) {
      if (10 === e3) for (; 0 !== this._queueCursor; ) {
        const e4 = this._queue[this._queueCursor - 1].char;
        if (32 !== e4 && 9 !== e4) break;
        this._queueCursor--;
      }
      const t3 = this._sourcePosition;
      this._pushQueue(e3, 1, t3.line, t3.column, t3.filename);
    }
    queueIndentation(e3) {
      0 !== e3 && this._pushQueue(-1, e3, void 0, void 0, void 0);
    }
    _flush() {
      const e3 = this._queueCursor, t3 = this._queue;
      for (let r2 = 0; r2 < e3; r2++) {
        const e4 = t3[r2];
        this._appendChar(e4.char, e4.repeat, e4);
      }
      this._queueCursor = 0;
    }
    _appendChar(e3, t3, r2) {
      if (this._last = e3, -1 === e3) {
        const e4 = this._fastIndentations[t3];
        this._str += void 0 !== e4 ? e4 : t3 > 1 ? this._indentChar.repeat(t3) : this._indentChar;
      } else this._str += t3 > 1 ? String.fromCharCode(e3).repeat(t3) : String.fromCharCode(e3);
      10 !== e3 ? (this._mark(r2.line, r2.column, r2.identifierName, r2.identifierNamePos, r2.filename), this._position.column += t3) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (r2.identifierName = void 0, r2.identifierNamePos = void 0);
    }
    _append(e3, t3, r2) {
      const n2 = e3.length, s2 = this._position;
      if (this._last = e3.charCodeAt(n2 - 1), ++this._appendCount > 4096 ? (this._str, this._buf += this._str, this._str = e3, this._appendCount = 0) : this._str += e3, !r2 && !this._map) return void (s2.column += n2);
      const { column: i2, identifierName: o2, identifierNamePos: a2, filename: l } = t3;
      let c = t3.line;
      null == o2 && null == a2 || !this._canMarkIdName || (t3.identifierName = void 0, t3.identifierNamePos = void 0);
      let u = e3.indexOf("\n"), p = 0;
      for (0 !== u && this._mark(c, i2, o2, a2, l); -1 !== u; ) s2.line++, s2.column = 0, p = u + 1, p < n2 && void 0 !== c && this._mark(++c, 0, null, null, l), u = e3.indexOf("\n", p);
      s2.column += n2 - p;
    }
    _mark(e3, t3, r2, n2, s2) {
      var i2;
      null == (i2 = this._map) || i2.mark(this._position, e3, t3, r2, n2, s2);
    }
    removeTrailingNewline() {
      const e3 = this._queueCursor;
      0 !== e3 && 10 === this._queue[e3 - 1].char && this._queueCursor--;
    }
    removeLastSemicolon() {
      const e3 = this._queueCursor;
      0 !== e3 && 59 === this._queue[e3 - 1].char && this._queueCursor--;
    }
    getLastChar() {
      const e3 = this._queueCursor;
      return 0 !== e3 ? this._queue[e3 - 1].char : this._last;
    }
    getNewlineCount() {
      const e3 = this._queueCursor;
      let t3 = 0;
      if (0 === e3) return 10 === this._last ? 1 : 0;
      for (let r2 = e3 - 1; r2 >= 0 && 10 === this._queue[r2].char; r2--) t3++;
      return t3 === e3 && 10 === this._last ? t3 + 1 : t3;
    }
    endsWithCharAndNewline() {
      const e3 = this._queue, t3 = this._queueCursor;
      if (0 !== t3) {
        if (10 !== e3[t3 - 1].char) return;
        return t3 > 1 ? e3[t3 - 2].char : this._last;
      }
    }
    hasContent() {
      return 0 !== this._queueCursor || !!this._last;
    }
    exactSource(e3, t3) {
      if (!this._map) return void t3();
      this.source("start", e3);
      const r2 = e3.identifierName, n2 = this._sourcePosition;
      r2 && (this._canMarkIdName = false, n2.identifierName = r2), t3(), r2 && (this._canMarkIdName = true, n2.identifierName = void 0, n2.identifierNamePos = void 0), this.source("end", e3);
    }
    source(e3, t3) {
      this._map && this._normalizePosition(e3, t3, 0);
    }
    sourceWithOffset(e3, t3, r2) {
      this._map && this._normalizePosition(e3, t3, r2);
    }
    withSource(e3, t3, r2) {
      this._map && this.source(e3, t3), r2();
    }
    _normalizePosition(e3, t3, r2) {
      const n2 = t3[e3], s2 = this._sourcePosition;
      n2 && (s2.line = n2.line, s2.column = Math.max(n2.column + r2, 0), s2.filename = t3.filename);
    }
    getCurrentColumn() {
      const e3 = this._queue, t3 = this._queueCursor;
      let r2 = -1, n2 = 0;
      for (let s2 = 0; s2 < t3; s2++) {
        const t4 = e3[s2];
        10 === t4.char && (r2 = n2), n2 += t4.repeat;
      }
      return -1 === r2 ? this._position.column + n2 : n2 - 1 - r2;
    }
    getCurrentLine() {
      let e3 = 0;
      const t3 = this._queue;
      for (let r2 = 0; r2 < this._queueCursor; r2++) 10 === t3[r2].char && e3++;
      return this._position.line + e3;
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.nodes = void 0;
  var n2 = r2(0);
  const { FLIPPED_ALIAS_KEYS: s2, isArrayExpression: i2, isAssignmentExpression: o2, isBinary: a2, isBlockStatement: l, isCallExpression: c, isFunction: u, isIdentifier: p, isLiteral: d, isMemberExpression: f, isObjectExpression: h, isOptionalCallExpression: m, isOptionalMemberExpression: y, isStringLiteral: g } = n2;
  function b(e3, t3) {
    return e3 ? (f(e3) || y(e3) ? (b(e3.object, t3), e3.computed && b(e3.property, t3)) : a2(e3) || o2(e3) ? (b(e3.left, t3), b(e3.right, t3)) : c(e3) || m(e3) ? (t3.hasCall = true, b(e3.callee, t3)) : u(e3) ? t3.hasFunction = true : p(e3) && (t3.hasHelper = t3.hasHelper || e3.callee && E(e3.callee)), t3) : t3;
  }
  function v(e3) {
    return b(e3, { hasCall: false, hasFunction: false, hasHelper: false });
  }
  function E(e3) {
    return !!e3 && (f(e3) ? E(e3.object) || E(e3.property) : p(e3) ? "require" === e3.name || 95 === e3.name.charCodeAt(0) : c(e3) ? E(e3.callee) : !(!a2(e3) && !o2(e3)) && (p(e3.left) && E(e3.left) || E(e3.right)));
  }
  function S(e3) {
    return d(e3) || h(e3) || i2(e3) || p(e3) || f(e3);
  }
  const x = t2.nodes = { AssignmentExpression(e3) {
    const t3 = v(e3.right);
    if (t3.hasCall && t3.hasHelper || t3.hasFunction) return t3.hasFunction ? 3 : 2;
  }, SwitchCase: (e3, t3) => (e3.consequent.length || t3.cases[0] === e3 ? 1 : 0) | (e3.consequent.length || t3.cases[t3.cases.length - 1] !== e3 ? 0 : 2), LogicalExpression(e3) {
    if (u(e3.left) || u(e3.right)) return 2;
  }, Literal(e3) {
    if (g(e3) && "use strict" === e3.value) return 2;
  }, CallExpression(e3) {
    if (u(e3.callee) || E(e3)) return 3;
  }, OptionalCallExpression(e3) {
    if (u(e3.callee)) return 3;
  }, VariableDeclaration(e3) {
    for (let t3 = 0; t3 < e3.declarations.length; t3++) {
      const r3 = e3.declarations[t3];
      let n3 = E(r3.id) && !S(r3.init);
      if (!n3 && r3.init) {
        const e4 = v(r3.init);
        n3 = E(r3.init) && e4.hasCall || e4.hasFunction;
      }
      if (n3) return 3;
    }
  }, IfStatement(e3) {
    if (l(e3.consequent)) return 3;
  } };
  x.ObjectProperty = x.ObjectTypeProperty = x.ObjectMethod = function(e3, t3) {
    if (t3.properties[0] === e3) return 1;
  }, x.ObjectTypeCallProperty = function(e3, t3) {
    var r3;
    if (t3.callProperties[0] === e3 && (null == (r3 = t3.properties) || !r3.length)) return 1;
  }, x.ObjectTypeIndexer = function(e3, t3) {
    var r3, n3;
    if (!(t3.indexers[0] !== e3 || null != (r3 = t3.properties) && r3.length || null != (n3 = t3.callProperties) && n3.length)) return 1;
  }, x.ObjectTypeInternalSlot = function(e3, t3) {
    var r3, n3, s3;
    if (!(t3.internalSlots[0] !== e3 || null != (r3 = t3.properties) && r3.length || null != (n3 = t3.callProperties) && n3.length || null != (s3 = t3.indexers) && s3.length)) return 1;
  }, [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function(e3) {
    let [t3, r3] = e3;
    [t3].concat(s2[t3] || []).forEach(function(e4) {
      const t4 = r3 ? 3 : 0;
      x[e4] = () => t4;
    });
  });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrowFunctionExpression = function(e3, t3) {
    return l(t3) || E(e3, t3);
  }, t2.AssignmentExpression = function(e3, t3) {
    return !!d(e3.left) || E(e3, t3);
  }, t2.Binary = function(e3, t3) {
    const r3 = t3.type;
    if ("**" === e3.operator && "BinaryExpression" === r3 && "**" === t3.operator) return t3.left === e3;
    if (g(e3, t3)) return true;
    if (b(e3, t3) || "UnaryExpression" === r3 || "SpreadElement" === r3 || "AwaitExpression" === r3) return true;
    if ("BinaryExpression" === r3 || "LogicalExpression" === r3) {
      const n3 = m.get(t3.operator), s3 = m.get(e3.operator);
      if (n3 === s3 && t3.right === e3 && "LogicalExpression" !== r3 || n3 > s3) return true;
    }
  }, t2.BinaryExpression = function(e3, t3) {
    if ("in" === e3.operator) {
      const e4 = t3.type;
      return "VariableDeclarator" === e4 || "ForStatement" === e4 || "ForInStatement" === e4 || "ForOfStatement" === e4;
    }
    return false;
  }, t2.ClassExpression = function(e3, t3, r3) {
    return S(r3, 5);
  }, t2.ConditionalExpression = E, t2.DoExpression = function(e3, t3, r3) {
    return !e3.async && S(r3, 1);
  }, t2.FunctionExpression = function(e3, t3, r3) {
    return S(r3, 5);
  }, t2.FunctionTypeAnnotation = function(e3, t3, r3) {
    if (r3.length < 3) return;
    const n3 = t3.type;
    return "UnionTypeAnnotation" === n3 || "IntersectionTypeAnnotation" === n3 || "ArrayTypeAnnotation" === n3 || "TypeAnnotation" === n3 && i2(r3[r3.length - 3]);
  }, t2.Identifier = function(e3, t3, r3) {
    var n3;
    const s3 = t3.type;
    if (null != (n3 = e3.extra) && n3.parenthesized && "AssignmentExpression" === s3 && t3.left === e3) {
      const e4 = t3.right.type;
      if (("FunctionExpression" === e4 || "ClassExpression" === e4) && null == t3.right.id) return true;
    }
    return "let" === e3.name ? S(r3, p(t3, { object: e3, computed: true }) || f(t3, { object: e3, computed: true, optional: false }) ? 57 : 32) : "async" === e3.name && c(t3) && e3 === t3.left;
  }, t2.LogicalExpression = function(e3, t3) {
    const r3 = t3.type;
    if (y(r3)) return true;
    if ("LogicalExpression" !== r3) return false;
    switch (e3.operator) {
      case "||":
        return "??" === t3.operator || "&&" === t3.operator;
      case "&&":
        return "??" === t3.operator;
      case "??":
        return "??" !== t3.operator;
    }
  }, t2.NullableTypeAnnotation = function(e3, t3) {
    return s2(t3);
  }, t2.ObjectExpression = function(e3, t3, r3) {
    return S(r3, 3);
  }, t2.OptionalIndexedAccessType = function(e3, t3) {
    return u(t3) && t3.objectType === e3;
  }, t2.OptionalCallExpression = t2.OptionalMemberExpression = function(e3, t3) {
    return a2(t3) && t3.callee === e3 || p(t3) && t3.object === e3;
  }, t2.SequenceExpression = function(e3, t3) {
    const r3 = t3.type;
    return !("ForStatement" === r3 || "ThrowStatement" === r3 || "ReturnStatement" === r3 || "IfStatement" === r3 && t3.test === e3 || "WhileStatement" === r3 && t3.test === e3 || "ForInStatement" === r3 && t3.right === e3 || "SwitchStatement" === r3 && t3.discriminant === e3 || "ExpressionStatement" === r3 && t3.expression === e3);
  }, t2.TSTypeAssertion = t2.TSSatisfiesExpression = t2.TSAsExpression = function() {
    return true;
  }, t2.TSInferType = function(e3, t3) {
    const r3 = t3.type;
    return "TSArrayType" === r3 || "TSOptionalType" === r3;
  }, t2.TSInstantiationExpression = function(e3, t3) {
    const r3 = t3.type;
    return ("CallExpression" === r3 || "OptionalCallExpression" === r3 || "NewExpression" === r3 || "TSInstantiationExpression" === r3) && !!t3.typeParameters;
  }, t2.TSIntersectionType = t2.TSUnionType = function(e3, t3) {
    const r3 = t3.type;
    return "TSArrayType" === r3 || "TSOptionalType" === r3 || "TSIntersectionType" === r3 || "TSUnionType" === r3 || "TSRestType" === r3;
  }, t2.UnaryLike = v, t2.IntersectionTypeAnnotation = t2.UnionTypeAnnotation = function(e3, t3) {
    const r3 = t3.type;
    return "ArrayTypeAnnotation" === r3 || "NullableTypeAnnotation" === r3 || "IntersectionTypeAnnotation" === r3 || "UnionTypeAnnotation" === r3;
  }, t2.UpdateExpression = function(e3, t3) {
    return b(e3, t3) || g(e3, t3);
  }, t2.AwaitExpression = t2.YieldExpression = function(e3, t3) {
    const r3 = t3.type;
    return "BinaryExpression" === r3 || "LogicalExpression" === r3 || "UnaryExpression" === r3 || "SpreadElement" === r3 || b(e3, t3) || "AwaitExpression" === r3 && h(e3) || "ConditionalExpression" === r3 && e3 === t3.test || g(e3, t3);
  };
  var n2 = r2(0);
  const { isArrayTypeAnnotation: s2, isArrowFunctionExpression: i2, isBinaryExpression: o2, isCallExpression: a2, isExportDeclaration: l, isForOfStatement: c, isIndexedAccessType: u, isMemberExpression: p, isObjectPattern: d, isOptionalMemberExpression: f, isYieldExpression: h } = n2, m = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function y(e3) {
    return "TSAsExpression" === e3 || "TSSatisfiesExpression" === e3 || "TSTypeAssertion" === e3;
  }
  const g = (e3, t3) => {
    const r3 = t3.type;
    return ("ClassDeclaration" === r3 || "ClassExpression" === r3) && t3.superClass === e3;
  }, b = (e3, t3) => {
    const r3 = t3.type;
    return ("MemberExpression" === r3 || "OptionalMemberExpression" === r3) && t3.object === e3 || ("CallExpression" === r3 || "OptionalCallExpression" === r3 || "NewExpression" === r3) && t3.callee === e3 || "TaggedTemplateExpression" === r3 && t3.tag === e3 || "TSNonNullExpression" === r3;
  };
  function v(e3, t3) {
    return b(e3, t3) || o2(t3) && "**" === t3.operator && t3.left === e3 || g(e3, t3);
  }
  function E(e3, t3) {
    const r3 = t3.type;
    return !!("UnaryExpression" === r3 || "SpreadElement" === r3 || "BinaryExpression" === r3 || "LogicalExpression" === r3 || "ConditionalExpression" === r3 && t3.test === e3 || "AwaitExpression" === r3 || y(r3)) || v(e3, t3);
  }
  function S(e3, t3) {
    const r3 = 1 & t3, n3 = 2 & t3, s3 = 4 & t3, i3 = 8 & t3, o3 = 16 & t3, a3 = 32 & t3;
    let l2 = e3.length - 1;
    if (l2 <= 0) return;
    let c2 = e3[l2];
    l2--;
    let u2 = e3[l2];
    for (; l2 >= 0; ) {
      const t4 = u2.type;
      if (r3 && "ExpressionStatement" === t4 && u2.expression === c2 || s3 && "ExportDefaultDeclaration" === t4 && c2 === u2.declaration || n3 && "ArrowFunctionExpression" === t4 && u2.body === c2 || i3 && "ForStatement" === t4 && u2.init === c2 || o3 && "ForInStatement" === t4 && u2.left === c2 || a3 && "ForOfStatement" === t4 && u2.left === c2) return true;
      if (!(l2 > 0 && (b(c2, u2) && "NewExpression" !== t4 || "SequenceExpression" === t4 && u2.expressions[0] === c2 || "UpdateExpression" === t4 && !u2.prefix || "ConditionalExpression" === t4 && u2.test === c2 || ("BinaryExpression" === t4 || "LogicalExpression" === t4) && u2.left === c2 || "AssignmentExpression" === t4 && u2.left === c2))) return false;
      c2 = u2, l2--, u2 = e3[l2];
    }
    return false;
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.TaggedTemplateExpression = function(e3) {
    this.print(e3.tag, e3), this.print(e3.typeParameters, e3), this.print(e3.quasi, e3);
  }, t2.TemplateElement = function(e3, t3) {
    const r2 = t3.quasis[0] === e3, n2 = t3.quasis[t3.quasis.length - 1] === e3, s2 = (r2 ? "`" : "}") + e3.value.raw + (n2 ? "`" : "${");
    this.token(s2, true);
  }, t2.TemplateLiteral = function(e3) {
    const t3 = e3.quasis;
    for (let r2 = 0; r2 < t3.length; r2++) this.print(t3[r2], e3), r2 + 1 < t3.length && this.print(e3.expressions[r2], e3);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.LogicalExpression = t2.BinaryExpression = t2.AssignmentExpression = function(e3, t3) {
    const r3 = this.inForStatementInitCounter && "in" === e3.operator && !s2.needsParens(e3, t3);
    r3 && this.tokenChar(40), this.print(e3.left, e3), this.space(), "in" === e3.operator || "instanceof" === e3.operator ? this.word(e3.operator) : this.token(e3.operator), this.space(), this.print(e3.right, e3), r3 && this.tokenChar(41);
  }, t2.AssignmentPattern = function(e3) {
    this.print(e3.left, e3), e3.left.optional && this.tokenChar(63), this.print(e3.left.typeAnnotation, e3), this.space(), this.tokenChar(61), this.space(), this.print(e3.right, e3);
  }, t2.AwaitExpression = function(e3) {
    this.word("await"), e3.argument && (this.space(), this.printTerminatorless(e3.argument, e3, false));
  }, t2.BindExpression = function(e3) {
    this.print(e3.object, e3), this.token("::"), this.print(e3.callee, e3);
  }, t2.CallExpression = function(e3) {
    this.print(e3.callee, e3), this.print(e3.typeArguments, e3), this.print(e3.typeParameters, e3), this.tokenChar(40), this.printList(e3.arguments, e3), this.rightParens(e3);
  }, t2.ConditionalExpression = function(e3) {
    this.print(e3.test, e3), this.space(), this.tokenChar(63), this.space(), this.print(e3.consequent, e3), this.space(), this.tokenChar(58), this.space(), this.print(e3.alternate, e3);
  }, t2.Decorator = function(e3) {
    this.tokenChar(64);
    const { expression: t3 } = e3;
    !function(e4) {
      return "ParenthesizedExpression" !== e4.type && !c("CallExpression" === e4.type ? e4.callee : e4);
    }(t3) ? this.print(t3, e3) : (this.tokenChar(40), this.print(t3, e3), this.tokenChar(41)), this.newline();
  }, t2.DoExpression = function(e3) {
    e3.async && (this.word("async", true), this.space()), this.word("do"), this.space(), this.print(e3.body, e3);
  }, t2.EmptyStatement = function() {
    this.semicolon(true);
  }, t2.ExpressionStatement = function(e3) {
    this.print(e3.expression, e3), this.semicolon();
  }, t2.Import = function() {
    this.word("import");
  }, t2.MemberExpression = function(e3) {
    if (this.print(e3.object, e3), !e3.computed && a2(e3.property)) throw new TypeError("Got a MemberExpression for MemberExpression property");
    let t3 = e3.computed;
    o2(e3.property) && "number" == typeof e3.property.value && (t3 = true), t3 ? (this.tokenChar(91), this.print(e3.property, e3), this.tokenChar(93)) : (this.tokenChar(46), this.print(e3.property, e3));
  }, t2.MetaProperty = function(e3) {
    this.print(e3.meta, e3), this.tokenChar(46), this.print(e3.property, e3);
  }, t2.ModuleExpression = function(e3) {
    this.word("module", true), this.space(), this.tokenChar(123), this.indent();
    const { body: t3 } = e3;
    (t3.body.length || t3.directives.length) && this.newline(), this.print(t3, e3), this.dedent(), this.rightBrace(e3);
  }, t2.NewExpression = function(e3, t3) {
    this.word("new"), this.space(), this.print(e3.callee, e3), (!this.format.minified || 0 !== e3.arguments.length || e3.optional || i2(t3, { callee: e3 }) || a2(t3) || l(t3)) && (this.print(e3.typeArguments, e3), this.print(e3.typeParameters, e3), e3.optional && this.token("?."), this.tokenChar(40), this.printList(e3.arguments, e3), this.rightParens(e3));
  }, t2.OptionalCallExpression = function(e3) {
    this.print(e3.callee, e3), this.print(e3.typeParameters, e3), e3.optional && this.token("?."), this.print(e3.typeArguments, e3), this.tokenChar(40), this.printList(e3.arguments, e3), this.rightParens(e3);
  }, t2.OptionalMemberExpression = function(e3) {
    let { computed: t3 } = e3;
    const { optional: r3, property: n3 } = e3;
    if (this.print(e3.object, e3), !t3 && a2(n3)) throw new TypeError("Got a MemberExpression for MemberExpression property");
    o2(n3) && "number" == typeof n3.value && (t3 = true), r3 && this.token("?."), t3 ? (this.tokenChar(91), this.print(n3, e3), this.tokenChar(93)) : (r3 || this.tokenChar(46), this.print(n3, e3));
  }, t2.ParenthesizedExpression = function(e3) {
    this.tokenChar(40), this.print(e3.expression, e3), this.rightParens(e3);
  }, t2.PrivateName = function(e3) {
    this.tokenChar(35), this.print(e3.id, e3);
  }, t2.SequenceExpression = function(e3) {
    this.printList(e3.expressions, e3);
  }, t2.Super = function() {
    this.word("super");
  }, t2.ThisExpression = function() {
    this.word("this");
  }, t2.UnaryExpression = function(e3) {
    const { operator: t3 } = e3;
    "void" === t3 || "delete" === t3 || "typeof" === t3 || "throw" === t3 ? (this.word(t3), this.space()) : this.token(t3), this.print(e3.argument, e3);
  }, t2.UpdateExpression = function(e3) {
    e3.prefix ? (this.token(e3.operator), this.print(e3.argument, e3)) : (this.printTerminatorless(e3.argument, e3, true), this.token(e3.operator));
  }, t2.V8IntrinsicIdentifier = function(e3) {
    this.tokenChar(37), this.word(e3.name);
  }, t2.YieldExpression = function(e3) {
    this.word("yield", true), e3.delegate ? (this.tokenChar(42), e3.argument && (this.space(), this.print(e3.argument, e3))) : e3.argument && (this.space(), this.printTerminatorless(e3.argument, e3, false));
  }, t2._shouldPrintDecoratorsBeforeExport = function(e3) {
    return "boolean" == typeof this.format.decoratorsBeforeExport ? this.format.decoratorsBeforeExport : "number" == typeof e3.start && e3.start === e3.declaration.start;
  };
  var n2 = r2(0), s2 = r2(184);
  const { isCallExpression: i2, isLiteral: o2, isMemberExpression: a2, isNewExpression: l } = n2;
  function c(e3) {
    switch (e3.type) {
      case "Identifier":
        return true;
      case "MemberExpression":
        return !e3.computed && "Identifier" === e3.property.type && c(e3.object);
      default:
        return false;
    }
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.BreakStatement = function(e3) {
    this.word("break"), u(this, e3.label, e3, true);
  }, t2.CatchClause = function(e3) {
    this.word("catch"), this.space(), e3.param && (this.tokenChar(40), this.print(e3.param, e3), this.print(e3.param.typeAnnotation, e3), this.tokenChar(41), this.space()), this.print(e3.body, e3);
  }, t2.ContinueStatement = function(e3) {
    this.word("continue"), u(this, e3.label, e3, true);
  }, t2.DebuggerStatement = function() {
    this.word("debugger"), this.semicolon();
  }, t2.DoWhileStatement = function(e3) {
    this.word("do"), this.space(), this.print(e3.body, e3), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e3.test, e3), this.tokenChar(41), this.semicolon();
  }, t2.ForOfStatement = t2.ForInStatement = void 0, t2.ForStatement = function(e3) {
    this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(e3.init, e3), this.inForStatementInitCounter--, this.tokenChar(59), e3.test && (this.space(), this.print(e3.test, e3)), this.tokenChar(59), e3.update && (this.space(), this.print(e3.update, e3)), this.tokenChar(41), this.printBlock(e3);
  }, t2.IfStatement = function(e3) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(e3.test, e3), this.tokenChar(41), this.space();
    const t3 = e3.alternate && o2(l(e3.consequent));
    t3 && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e3.consequent, e3), t3 && (this.dedent(), this.newline(), this.tokenChar(125)), e3.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(e3.alternate, e3));
  }, t2.LabeledStatement = function(e3) {
    this.print(e3.label, e3), this.tokenChar(58), this.space(), this.print(e3.body, e3);
  }, t2.ReturnStatement = function(e3) {
    this.word("return"), u(this, e3.argument, e3, false);
  }, t2.SwitchCase = function(e3) {
    e3.test ? (this.word("case"), this.space(), this.print(e3.test, e3), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e3.consequent.length && (this.newline(), this.printSequence(e3.consequent, e3, { indent: true }));
  }, t2.SwitchStatement = function(e3) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(e3.discriminant, e3), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(e3.cases, e3, { indent: true, addNewlines(t3, r3) {
      if (!t3 && e3.cases[e3.cases.length - 1] === r3) return -1;
    } }), this.rightBrace(e3);
  }, t2.ThrowStatement = function(e3) {
    this.word("throw"), u(this, e3.argument, e3, false);
  }, t2.TryStatement = function(e3) {
    this.word("try"), this.space(), this.print(e3.block, e3), this.space(), e3.handlers ? this.print(e3.handlers[0], e3) : this.print(e3.handler, e3), e3.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e3.finalizer, e3));
  }, t2.VariableDeclaration = function(e3, t3) {
    e3.declare && (this.word("declare"), this.space());
    const { kind: r3 } = e3;
    this.word(r3, "using" === r3 || "await using" === r3), this.space();
    let n3 = false;
    if (!s2(t3)) for (const t4 of e3.declarations) t4.init && (n3 = true);
    if (this.printList(e3.declarations, e3, { separator: n3 ? function() {
      this.tokenChar(44), this.newline();
    } : void 0, indent: e3.declarations.length > 1 }), s2(t3)) {
      if (i2(t3)) {
        if (t3.init === e3) return;
      } else if (t3.left === e3) return;
    }
    this.semicolon();
  }, t2.VariableDeclarator = function(e3) {
    this.print(e3.id, e3), e3.definite && this.tokenChar(33), this.print(e3.id.typeAnnotation, e3), e3.init && (this.space(), this.tokenChar(61), this.space(), this.print(e3.init, e3));
  }, t2.WhileStatement = function(e3) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(e3.test, e3), this.tokenChar(41), this.printBlock(e3);
  }, t2.WithStatement = function(e3) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(e3.object, e3), this.tokenChar(41), this.printBlock(e3);
  };
  var n2 = r2(0);
  const { isFor: s2, isForStatement: i2, isIfStatement: o2, isStatement: a2 } = n2;
  function l(e3) {
    const { body: t3 } = e3;
    return false === a2(t3) ? e3 : l(t3);
  }
  function c(e3) {
    this.word("for"), this.space();
    const t3 = "ForOfStatement" === e3.type;
    t3 && e3.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(e3.left, e3), this.space(), this.word(t3 ? "of" : "in"), this.space(), this.print(e3.right, e3), this.tokenChar(41), this.printBlock(e3);
  }
  function u(e3, t3, r3, n3) {
    t3 && (e3.space(), e3.printTerminatorless(t3, r3, n3)), e3.semicolon();
  }
  t2.ForInStatement = c, t2.ForOfStatement = c;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ClassAccessorProperty = function(e3) {
    var t3;
    this.printJoin(e3.decorators, e3);
    const r3 = null == (t3 = e3.key.loc) || null == (t3 = t3.end) ? void 0 : t3.line;
    r3 && this.catchUp(r3), this.tsPrintClassMemberModifiers(e3), this.word("accessor", true), this.space(), e3.computed ? (this.tokenChar(91), this.print(e3.key, e3), this.tokenChar(93)) : (this._variance(e3), this.print(e3.key, e3)), e3.optional && this.tokenChar(63), e3.definite && this.tokenChar(33), this.print(e3.typeAnnotation, e3), e3.value && (this.space(), this.tokenChar(61), this.space(), this.print(e3.value, e3)), this.semicolon();
  }, t2.ClassBody = function(e3) {
    this.tokenChar(123), 0 === e3.body.length ? this.tokenChar(125) : (this.newline(), this.printSequence(e3.body, e3, { indent: true }), this.endsWith(10) || this.newline(), this.rightBrace(e3));
  }, t2.ClassExpression = t2.ClassDeclaration = function(e3, t3) {
    (s2(t3) || i2(t3)) && this._shouldPrintDecoratorsBeforeExport(t3) || this.printJoin(e3.decorators, e3), e3.declare && (this.word("declare"), this.space()), e3.abstract && (this.word("abstract"), this.space()), this.word("class"), e3.id && (this.space(), this.print(e3.id, e3)), this.print(e3.typeParameters, e3), e3.superClass && (this.space(), this.word("extends"), this.space(), this.print(e3.superClass, e3), this.print(e3.superTypeParameters, e3)), e3.implements && (this.space(), this.word("implements"), this.space(), this.printList(e3.implements, e3)), this.space(), this.print(e3.body, e3);
  }, t2.ClassMethod = function(e3) {
    this._classMethodHead(e3), this.space(), this.print(e3.body, e3);
  }, t2.ClassPrivateMethod = function(e3) {
    this._classMethodHead(e3), this.space(), this.print(e3.body, e3);
  }, t2.ClassPrivateProperty = function(e3) {
    this.printJoin(e3.decorators, e3), e3.static && (this.word("static"), this.space()), this.print(e3.key, e3), this.print(e3.typeAnnotation, e3), e3.value && (this.space(), this.tokenChar(61), this.space(), this.print(e3.value, e3)), this.semicolon();
  }, t2.ClassProperty = function(e3) {
    var t3;
    this.printJoin(e3.decorators, e3);
    const r3 = null == (t3 = e3.key.loc) || null == (t3 = t3.end) ? void 0 : t3.line;
    r3 && this.catchUp(r3), this.tsPrintClassMemberModifiers(e3), e3.computed ? (this.tokenChar(91), this.print(e3.key, e3), this.tokenChar(93)) : (this._variance(e3), this.print(e3.key, e3)), e3.optional && this.tokenChar(63), e3.definite && this.tokenChar(33), this.print(e3.typeAnnotation, e3), e3.value && (this.space(), this.tokenChar(61), this.space(), this.print(e3.value, e3)), this.semicolon();
  }, t2.StaticBlock = function(e3) {
    this.word("static"), this.space(), this.tokenChar(123), 0 === e3.body.length ? this.tokenChar(125) : (this.newline(), this.printSequence(e3.body, e3, { indent: true }), this.rightBrace(e3));
  }, t2._classMethodHead = function(e3) {
    var t3;
    this.printJoin(e3.decorators, e3);
    const r3 = null == (t3 = e3.key.loc) || null == (t3 = t3.end) ? void 0 : t3.line;
    r3 && this.catchUp(r3), this.tsPrintClassMemberModifiers(e3), this._methodHead(e3);
  };
  var n2 = r2(0);
  const { isExportDefaultDeclaration: s2, isExportNamedDeclaration: i2 } = n2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrowFunctionExpression = function(e3, t3) {
    let r3;
    e3.async && (this.word("async", true), this.space()), this.format.retainLines || 1 !== e3.params.length || !s2(r3 = e3.params[0]) || function(e4, t4) {
      var r4, n3;
      return !!(e4.typeParameters || e4.returnType || e4.predicate || t4.typeAnnotation || t4.optional || null != (r4 = t4.leadingComments) && r4.length || null != (n3 = t4.trailingComments) && n3.length);
    }(e3, r3) ? this._params(e3, void 0, t3) : this.print(r3, e3, true), this._predicate(e3, true), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(e3.body, e3);
  }, t2.FunctionDeclaration = t2.FunctionExpression = function(e3, t3) {
    this._functionHead(e3, t3), this.space(), this.print(e3.body, e3);
  }, t2._functionHead = function(e3, t3) {
    e3.async && (this.word("async"), this._endsWithInnerRaw = false, this.space()), this.word("function"), e3.generator && (this._endsWithInnerRaw = false, this.tokenChar(42)), this.space(), e3.id && this.print(e3.id, e3), this._params(e3, e3.id, t3), "TSDeclareFunction" !== e3.type && this._predicate(e3);
  }, t2._methodHead = function(e3) {
    const t3 = e3.kind, r3 = e3.key;
    "get" !== t3 && "set" !== t3 || (this.word(t3), this.space()), e3.async && (this.word("async", true), this.space()), "method" !== t3 && "init" !== t3 || e3.generator && this.tokenChar(42), e3.computed ? (this.tokenChar(91), this.print(r3, e3), this.tokenChar(93)) : this.print(r3, e3), e3.optional && this.tokenChar(63), this._params(e3, e3.computed && "StringLiteral" !== e3.key.type ? void 0 : e3.key, void 0);
  }, t2._param = function(e3, t3) {
    this.printJoin(e3.decorators, e3), this.print(e3, t3), e3.optional && this.tokenChar(63), this.print(e3.typeAnnotation, e3);
  }, t2._parameters = function(e3, t3) {
    const r3 = e3.length;
    for (let n3 = 0; n3 < r3; n3++) this._param(e3[n3], t3), n3 < e3.length - 1 && (this.tokenChar(44), this.space());
  }, t2._params = function(e3, t3, r3) {
    this.print(e3.typeParameters, e3);
    const n3 = i2.call(this, t3, r3);
    n3 && this.sourceIdentifierName(n3.name, n3.pos), this.tokenChar(40), this._parameters(e3.params, e3), this.tokenChar(41);
    const s3 = "ArrowFunctionExpression" === e3.type;
    this.print(e3.returnType, e3, s3), this._noLineTerminator = s3;
  }, t2._predicate = function(e3, t3) {
    e3.predicate && (e3.returnType || this.tokenChar(58), this.space(), this.print(e3.predicate, e3, t3));
  };
  var n2 = r2(0);
  const { isIdentifier: s2 } = n2;
  function i2(e3, t3) {
    let r3, n3 = e3;
    if (!n3 && t3) {
      const e4 = t3.type;
      "VariableDeclarator" === e4 ? n3 = t3.id : "AssignmentExpression" === e4 || "AssignmentPattern" === e4 ? n3 = t3.left : "ObjectProperty" === e4 || "ClassProperty" === e4 ? t3.computed && "StringLiteral" !== t3.key.type || (n3 = t3.key) : "ClassPrivateProperty" !== e4 && "ClassAccessorProperty" !== e4 || (n3 = t3.key);
    }
    if (n3) {
      var s3, i3;
      if ("Identifier" === n3.type) r3 = { pos: null == (s3 = n3.loc) ? void 0 : s3.start, name: (null == (i3 = n3.loc) ? void 0 : i3.identifierName) || n3.name };
      else if ("PrivateName" === n3.type) {
        var o2;
        r3 = { pos: null == (o2 = n3.loc) ? void 0 : o2.start, name: "#" + n3.id.name };
      } else if ("StringLiteral" === n3.type) {
        var a2;
        r3 = { pos: null == (a2 = n3.loc) ? void 0 : a2.start, name: n3.value };
      }
      return r3;
    }
  }
}, (e2, t2, r2) => {
  r2(12), t2.byteLength = function(e3) {
    var t3 = l(e3), r3 = t3[0], n3 = t3[1];
    return 3 * (r3 + n3) / 4 - n3;
  }, t2.toByteArray = function(e3) {
    var t3, r3, n3 = l(e3), o3 = n3[0], a3 = n3[1], c2 = new i2(function(e4, t4, r4) {
      return 3 * (t4 + r4) / 4 - r4;
    }(0, o3, a3)), u = 0, p = a3 > 0 ? o3 - 4 : o3;
    for (r3 = 0; r3 < p; r3 += 4) t3 = s2[e3.charCodeAt(r3)] << 18 | s2[e3.charCodeAt(r3 + 1)] << 12 | s2[e3.charCodeAt(r3 + 2)] << 6 | s2[e3.charCodeAt(r3 + 3)], c2[u++] = t3 >> 16 & 255, c2[u++] = t3 >> 8 & 255, c2[u++] = 255 & t3;
    return 2 === a3 && (t3 = s2[e3.charCodeAt(r3)] << 2 | s2[e3.charCodeAt(r3 + 1)] >> 4, c2[u++] = 255 & t3), 1 === a3 && (t3 = s2[e3.charCodeAt(r3)] << 10 | s2[e3.charCodeAt(r3 + 1)] << 4 | s2[e3.charCodeAt(r3 + 2)] >> 2, c2[u++] = t3 >> 8 & 255, c2[u++] = 255 & t3), c2;
  }, t2.fromByteArray = function(e3) {
    for (var t3, r3 = e3.length, s3 = r3 % 3, i3 = [], o3 = 16383, a3 = 0, l2 = r3 - s3; a3 < l2; a3 += o3) i3.push(c(e3, a3, a3 + o3 > l2 ? l2 : a3 + o3));
    return 1 === s3 ? (t3 = e3[r3 - 1], i3.push(n2[t3 >> 2] + n2[t3 << 4 & 63] + "==")) : 2 === s3 && (t3 = (e3[r3 - 2] << 8) + e3[r3 - 1], i3.push(n2[t3 >> 10] + n2[t3 >> 4 & 63] + n2[t3 << 2 & 63] + "=")), i3.join("");
  };
  for (var n2 = [], s2 = [], i2 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a2 = 0; a2 < 64; ++a2) n2[a2] = o2[a2], s2[o2.charCodeAt(a2)] = a2;
  function l(e3) {
    var t3 = e3.length;
    if (t3 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var r3 = e3.indexOf("=");
    return -1 === r3 && (r3 = t3), [r3, r3 === t3 ? 0 : 4 - r3 % 4];
  }
  function c(e3, t3, r3) {
    for (var s3, i3, o3 = [], a3 = t3; a3 < r3; a3 += 3) s3 = (e3[a3] << 16 & 16711680) + (e3[a3 + 1] << 8 & 65280) + (255 & e3[a3 + 2]), o3.push(n2[(i3 = s3) >> 18 & 63] + n2[i3 >> 12 & 63] + n2[i3 >> 6 & 63] + n2[63 & i3]);
    return o3.join("");
  }
  s2["-".charCodeAt(0)] = 62, s2["_".charCodeAt(0)] = 63;
}, (e2, t2) => {
  t2.read = function(e3, t3, r2, n2, s2) {
    var i2, o2, a2 = 8 * s2 - n2 - 1, l = (1 << a2) - 1, c = l >> 1, u = -7, p = r2 ? s2 - 1 : 0, d = r2 ? -1 : 1, f = e3[t3 + p];
    for (p += d, i2 = f & (1 << -u) - 1, f >>= -u, u += a2; u > 0; i2 = 256 * i2 + e3[t3 + p], p += d, u -= 8) ;
    for (o2 = i2 & (1 << -u) - 1, i2 >>= -u, u += n2; u > 0; o2 = 256 * o2 + e3[t3 + p], p += d, u -= 8) ;
    if (0 === i2) i2 = 1 - c;
    else {
      if (i2 === l) return o2 ? NaN : 1 / 0 * (f ? -1 : 1);
      o2 += Math.pow(2, n2), i2 -= c;
    }
    return (f ? -1 : 1) * o2 * Math.pow(2, i2 - n2);
  }, t2.write = function(e3, t3, r2, n2, s2, i2) {
    var o2, a2, l, c = 8 * i2 - s2 - 1, u = (1 << c) - 1, p = u >> 1, d = 23 === s2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n2 ? 0 : i2 - 1, h = n2 ? 1 : -1, m = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
    for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a2 = isNaN(t3) ? 1 : 0, o2 = u) : (o2 = Math.floor(Math.log(t3) / Math.LN2), t3 * (l = Math.pow(2, -o2)) < 1 && (o2--, l *= 2), (t3 += o2 + p >= 1 ? d / l : d * Math.pow(2, 1 - p)) * l >= 2 && (o2++, l /= 2), o2 + p >= u ? (a2 = 0, o2 = u) : o2 + p >= 1 ? (a2 = (t3 * l - 1) * Math.pow(2, s2), o2 += p) : (a2 = t3 * Math.pow(2, p - 1) * Math.pow(2, s2), o2 = 0)); s2 >= 8; e3[r2 + f] = 255 & a2, f += h, a2 /= 256, s2 -= 8) ;
    for (o2 = o2 << s2 | a2, c += s2; c > 0; e3[r2 + f] = 255 & o2, f += h, o2 /= 256, c -= 8) ;
    e3[r2 + f - h] |= 128 * m;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.AnyTypeAnnotation = function() {
    this.word("any");
  }, t2.ArrayTypeAnnotation = function(e3) {
    this.print(e3.elementType, e3, true), this.tokenChar(91), this.tokenChar(93);
  }, t2.BooleanLiteralTypeAnnotation = function(e3) {
    this.word(e3.value ? "true" : "false");
  }, t2.BooleanTypeAnnotation = function() {
    this.word("boolean");
  }, t2.DeclareClass = function(e3, t3) {
    o2(t3) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(e3);
  }, t2.DeclareExportAllDeclaration = function(e3) {
    this.word("declare"), this.space(), s2.ExportAllDeclaration.call(this, e3);
  }, t2.DeclareExportDeclaration = function(e3) {
    this.word("declare"), this.space(), this.word("export"), this.space(), e3.default && (this.word("default"), this.space()), p.call(this, e3);
  }, t2.DeclareFunction = function(e3, t3) {
    o2(t3) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(e3.id, e3), this.print(e3.id.typeAnnotation.typeAnnotation, e3), e3.predicate && (this.space(), this.print(e3.predicate, e3)), this.semicolon();
  }, t2.DeclareInterface = function(e3) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(e3);
  }, t2.DeclareModule = function(e3) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e3.id, e3), this.space(), this.print(e3.body, e3);
  }, t2.DeclareModuleExports = function(e3) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(e3.typeAnnotation, e3);
  }, t2.DeclareOpaqueType = function(e3, t3) {
    o2(t3) || (this.word("declare"), this.space()), this.OpaqueType(e3);
  }, t2.DeclareTypeAlias = function(e3) {
    this.word("declare"), this.space(), this.TypeAlias(e3);
  }, t2.DeclareVariable = function(e3, t3) {
    o2(t3) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(e3.id, e3), this.print(e3.id.typeAnnotation, e3), this.semicolon();
  }, t2.DeclaredPredicate = function(e3) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(e3.value, e3), this.tokenChar(41);
  }, t2.EmptyTypeAnnotation = function() {
    this.word("empty");
  }, t2.EnumBooleanBody = function(e3) {
    const { explicitType: t3 } = e3;
    l(this, "boolean", t3), c(this, e3);
  }, t2.EnumBooleanMember = function(e3) {
    u(this, e3);
  }, t2.EnumDeclaration = function(e3) {
    const { id: t3, body: r3 } = e3;
    this.word("enum"), this.space(), this.print(t3, e3), this.print(r3, e3);
  }, t2.EnumDefaultedMember = function(e3) {
    const { id: t3 } = e3;
    this.print(t3, e3), this.tokenChar(44);
  }, t2.EnumNumberBody = function(e3) {
    const { explicitType: t3 } = e3;
    l(this, "number", t3), c(this, e3);
  }, t2.EnumNumberMember = function(e3) {
    u(this, e3);
  }, t2.EnumStringBody = function(e3) {
    const { explicitType: t3 } = e3;
    l(this, "string", t3), c(this, e3);
  }, t2.EnumStringMember = function(e3) {
    u(this, e3);
  }, t2.EnumSymbolBody = function(e3) {
    l(this, "symbol", true), c(this, e3);
  }, t2.ExistsTypeAnnotation = function() {
    this.tokenChar(42);
  }, t2.FunctionTypeAnnotation = function(e3, t3) {
    this.print(e3.typeParameters, e3), this.tokenChar(40), e3.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(e3.this.typeAnnotation, e3), (e3.params.length || e3.rest) && (this.tokenChar(44), this.space())), this.printList(e3.params, e3), e3.rest && (e3.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(e3.rest, e3)), this.tokenChar(41);
    const r3 = null == t3 ? void 0 : t3.type;
    null != r3 && ("ObjectTypeCallProperty" === r3 || "ObjectTypeInternalSlot" === r3 || "DeclareFunction" === r3 || "ObjectTypeProperty" === r3 && t3.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(e3.returnType, e3);
  }, t2.FunctionTypeParam = function(e3) {
    this.print(e3.name, e3), e3.optional && this.tokenChar(63), e3.name && (this.tokenChar(58), this.space()), this.print(e3.typeAnnotation, e3);
  }, t2.IndexedAccessType = function(e3) {
    this.print(e3.objectType, e3, true), this.tokenChar(91), this.print(e3.indexType, e3), this.tokenChar(93);
  }, t2.InferredPredicate = function() {
    this.tokenChar(37), this.word("checks");
  }, t2.InterfaceDeclaration = function(e3) {
    this.word("interface"), this.space(), this._interfaceish(e3);
  }, t2.GenericTypeAnnotation = t2.ClassImplements = t2.InterfaceExtends = function(e3) {
    this.print(e3.id, e3), this.print(e3.typeParameters, e3, true);
  }, t2.InterfaceTypeAnnotation = function(e3) {
    var t3;
    this.word("interface"), null != (t3 = e3.extends) && t3.length && (this.space(), this.word("extends"), this.space(), this.printList(e3.extends, e3)), this.space(), this.print(e3.body, e3);
  }, t2.IntersectionTypeAnnotation = function(e3) {
    this.printJoin(e3.types, e3, { separator: d });
  }, t2.MixedTypeAnnotation = function() {
    this.word("mixed");
  }, t2.NullLiteralTypeAnnotation = function() {
    this.word("null");
  }, t2.NullableTypeAnnotation = function(e3) {
    this.tokenChar(63), this.print(e3.typeAnnotation, e3);
  }, Object.defineProperty(t2, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
    return i2.NumericLiteral;
  } }), t2.NumberTypeAnnotation = function() {
    this.word("number");
  }, t2.ObjectTypeAnnotation = function(e3) {
    e3.exact ? this.token("{|") : this.tokenChar(123);
    const t3 = [...e3.properties, ...e3.callProperties || [], ...e3.indexers || [], ...e3.internalSlots || []];
    t3.length && (this.newline(), this.space(), this.printJoin(t3, e3, { addNewlines(e4) {
      if (e4 && !t3[0]) return 1;
    }, indent: true, statement: true, iterator: () => {
      (1 !== t3.length || e3.inexact) && (this.tokenChar(44), this.space());
    } }), this.space()), e3.inexact && (this.indent(), this.token("..."), t3.length && this.newline(), this.dedent()), e3.exact ? this.token("|}") : this.tokenChar(125);
  }, t2.ObjectTypeCallProperty = function(e3) {
    e3.static && (this.word("static"), this.space()), this.print(e3.value, e3);
  }, t2.ObjectTypeIndexer = function(e3) {
    e3.static && (this.word("static"), this.space()), this._variance(e3), this.tokenChar(91), e3.id && (this.print(e3.id, e3), this.tokenChar(58), this.space()), this.print(e3.key, e3), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(e3.value, e3);
  }, t2.ObjectTypeInternalSlot = function(e3) {
    e3.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(e3.id, e3), this.tokenChar(93), this.tokenChar(93), e3.optional && this.tokenChar(63), e3.method || (this.tokenChar(58), this.space()), this.print(e3.value, e3);
  }, t2.ObjectTypeProperty = function(e3) {
    e3.proto && (this.word("proto"), this.space()), e3.static && (this.word("static"), this.space()), "get" !== e3.kind && "set" !== e3.kind || (this.word(e3.kind), this.space()), this._variance(e3), this.print(e3.key, e3), e3.optional && this.tokenChar(63), e3.method || (this.tokenChar(58), this.space()), this.print(e3.value, e3);
  }, t2.ObjectTypeSpreadProperty = function(e3) {
    this.token("..."), this.print(e3.argument, e3);
  }, t2.OpaqueType = function(e3) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e3.id, e3), this.print(e3.typeParameters, e3), e3.supertype && (this.tokenChar(58), this.space(), this.print(e3.supertype, e3)), e3.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(e3.impltype, e3)), this.semicolon();
  }, t2.OptionalIndexedAccessType = function(e3) {
    this.print(e3.objectType, e3), e3.optional && this.token("?."), this.tokenChar(91), this.print(e3.indexType, e3), this.tokenChar(93);
  }, t2.QualifiedTypeIdentifier = function(e3) {
    this.print(e3.qualification, e3), this.tokenChar(46), this.print(e3.id, e3);
  }, Object.defineProperty(t2, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
    return i2.StringLiteral;
  } }), t2.StringTypeAnnotation = function() {
    this.word("string");
  }, t2.SymbolTypeAnnotation = function() {
    this.word("symbol");
  }, t2.ThisTypeAnnotation = function() {
    this.word("this");
  }, t2.TupleTypeAnnotation = function(e3) {
    this.tokenChar(91), this.printList(e3.types, e3), this.tokenChar(93);
  }, t2.TypeAlias = function(e3) {
    this.word("type"), this.space(), this.print(e3.id, e3), this.print(e3.typeParameters, e3), this.space(), this.tokenChar(61), this.space(), this.print(e3.right, e3), this.semicolon();
  }, t2.TypeAnnotation = function(e3) {
    this.tokenChar(58), this.space(), e3.optional && this.tokenChar(63), this.print(e3.typeAnnotation, e3);
  }, t2.TypeCastExpression = function(e3) {
    this.tokenChar(40), this.print(e3.expression, e3), this.print(e3.typeAnnotation, e3), this.tokenChar(41);
  }, t2.TypeParameter = function(e3) {
    this._variance(e3), this.word(e3.name), e3.bound && this.print(e3.bound, e3), e3.default && (this.space(), this.tokenChar(61), this.space(), this.print(e3.default, e3));
  }, t2.TypeParameterDeclaration = t2.TypeParameterInstantiation = function(e3) {
    this.tokenChar(60), this.printList(e3.params, e3, {}), this.tokenChar(62);
  }, t2.TypeofTypeAnnotation = function(e3) {
    this.word("typeof"), this.space(), this.print(e3.argument, e3);
  }, t2.UnionTypeAnnotation = function(e3) {
    this.printJoin(e3.types, e3, { separator: f });
  }, t2.Variance = function(e3) {
    "plus" === e3.kind ? this.tokenChar(43) : this.tokenChar(45);
  }, t2.VoidTypeAnnotation = function() {
    this.word("void");
  }, t2._interfaceish = function(e3) {
    var t3, r3, n3;
    (this.print(e3.id, e3), this.print(e3.typeParameters, e3), null != (t3 = e3.extends) && t3.length && (this.space(), this.word("extends"), this.space(), this.printList(e3.extends, e3)), "DeclareClass" === e3.type) && (null != (r3 = e3.mixins) && r3.length && (this.space(), this.word("mixins"), this.space(), this.printList(e3.mixins, e3)), null != (n3 = e3.implements) && n3.length && (this.space(), this.word("implements"), this.space(), this.printList(e3.implements, e3)));
    this.space(), this.print(e3.body, e3);
  }, t2._variance = function(e3) {
    var t3;
    const r3 = null == (t3 = e3.variance) ? void 0 : t3.kind;
    null != r3 && ("plus" === r3 ? this.tokenChar(43) : "minus" === r3 && this.tokenChar(45));
  };
  var n2 = r2(0), s2 = r2(185), i2 = r2(186);
  const { isDeclareExportDeclaration: o2, isStatement: a2 } = n2;
  function l(e3, t3, r3) {
    r3 && (e3.space(), e3.word("of"), e3.space(), e3.word(t3)), e3.space();
  }
  function c(e3, t3) {
    const { members: r3 } = t3;
    e3.token("{"), e3.indent(), e3.newline();
    for (const n3 of r3) e3.print(n3, t3), e3.newline();
    t3.hasUnknownMembers && (e3.token("..."), e3.newline()), e3.dedent(), e3.token("}");
  }
  function u(e3, t3) {
    const { id: r3, init: n3 } = t3;
    e3.print(r3, t3), e3.space(), e3.token("="), e3.space(), e3.print(n3, t3), e3.token(",");
  }
  function p(e3) {
    if (e3.declaration) {
      const t3 = e3.declaration;
      this.print(t3, e3), a2(t3) || this.semicolon();
    } else this.tokenChar(123), e3.specifiers.length && (this.space(), this.printList(e3.specifiers, e3), this.space()), this.tokenChar(125), e3.source && (this.space(), this.word("from"), this.space(), this.print(e3.source, e3)), this.semicolon();
  }
  function d() {
    this.space(), this.tokenChar(38), this.space();
  }
  function f() {
    this.space(), this.tokenChar(124), this.space();
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.BlockStatement = function(e3) {
    var t3;
    this.tokenChar(123);
    const r3 = null == (t3 = e3.directives) ? void 0 : t3.length;
    if (r3) {
      var n3;
      const t4 = e3.body.length ? 2 : 1;
      this.printSequence(e3.directives, e3, { indent: true, trailingCommentsLineOffset: t4 }), null != (n3 = e3.directives[r3 - 1].trailingComments) && n3.length || this.newline(t4);
    }
    this.printSequence(e3.body, e3, { indent: true }), this.rightBrace(e3);
  }, t2.Directive = function(e3) {
    this.print(e3.value, e3), this.semicolon();
  }, t2.DirectiveLiteral = function(e3) {
    const t3 = this.getPossibleRaw(e3);
    if (!this.format.minified && void 0 !== t3) return void this.token(t3);
    const { value: s2 } = e3;
    if (n2.test(s2)) {
      if (r2.test(s2)) throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
      this.token(`'${s2}'`);
    } else this.token(`"${s2}"`);
  }, t2.File = function(e3) {
    e3.program && this.print(e3.program.interpreter, e3), this.print(e3.program, e3);
  }, t2.InterpreterDirective = function(e3) {
    this.token(`#!${e3.value}`), this.newline(1, true);
  }, t2.Placeholder = function(e3) {
    this.token("%%"), this.print(e3.name), this.token("%%"), "Statement" === e3.expectedNode && this.semicolon();
  }, t2.Program = function(e3) {
    var t3;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    const r3 = null == (t3 = e3.directives) ? void 0 : t3.length;
    if (r3) {
      var n3;
      const t4 = e3.body.length ? 2 : 1;
      this.printSequence(e3.directives, e3, { trailingCommentsLineOffset: t4 }), null != (n3 = e3.directives[r3 - 1].trailingComments) && n3.length || this.newline(t4);
    }
    this.printSequence(e3.body, e3);
  };
  const r2 = /(?:^|[^\\])(?:\\\\)*'/, n2 = /(?:^|[^\\])(?:\\\\)*"/;
}, (e2, t2) => {
  function r2() {
    this.space();
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.JSXAttribute = function(e3) {
    this.print(e3.name, e3), e3.value && (this.tokenChar(61), this.print(e3.value, e3));
  }, t2.JSXClosingElement = function(e3) {
    this.token("</"), this.print(e3.name, e3), this.tokenChar(62);
  }, t2.JSXClosingFragment = function() {
    this.token("</"), this.tokenChar(62);
  }, t2.JSXElement = function(e3) {
    const t3 = e3.openingElement;
    if (this.print(t3, e3), !t3.selfClosing) {
      this.indent();
      for (const t4 of e3.children) this.print(t4, e3);
      this.dedent(), this.print(e3.closingElement, e3);
    }
  }, t2.JSXEmptyExpression = function() {
    this.printInnerComments();
  }, t2.JSXExpressionContainer = function(e3) {
    this.tokenChar(123), this.print(e3.expression, e3), this.tokenChar(125);
  }, t2.JSXFragment = function(e3) {
    this.print(e3.openingFragment, e3), this.indent();
    for (const t3 of e3.children) this.print(t3, e3);
    this.dedent(), this.print(e3.closingFragment, e3);
  }, t2.JSXIdentifier = function(e3) {
    this.word(e3.name);
  }, t2.JSXMemberExpression = function(e3) {
    this.print(e3.object, e3), this.tokenChar(46), this.print(e3.property, e3);
  }, t2.JSXNamespacedName = function(e3) {
    this.print(e3.namespace, e3), this.tokenChar(58), this.print(e3.name, e3);
  }, t2.JSXOpeningElement = function(e3) {
    this.tokenChar(60), this.print(e3.name, e3), this.print(e3.typeParameters, e3), e3.attributes.length > 0 && (this.space(), this.printJoin(e3.attributes, e3, { separator: r2 })), e3.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
  }, t2.JSXOpeningFragment = function() {
    this.tokenChar(60), this.tokenChar(62);
  }, t2.JSXSpreadAttribute = function(e3) {
    this.tokenChar(123), this.token("..."), this.print(e3.argument, e3), this.tokenChar(125);
  }, t2.JSXSpreadChild = function(e3) {
    this.tokenChar(123), this.token("..."), this.print(e3.expression, e3), this.tokenChar(125);
  }, t2.JSXText = function(e3) {
    const t3 = this.getPossibleRaw(e3);
    void 0 !== t3 ? this.token(t3, true) : this.token(e3.value, true);
  };
}, (e2, t2) => {
  function r2(e3, t3, r3) {
    if (e3.token("{"), t3.length) {
      e3.indent(), e3.newline();
      for (const n3 of t3) e3.print(n3, r3), e3.newline();
      e3.dedent();
    }
    e3.rightBrace(r3);
  }
  function n2(e3, t3, r3) {
    e3.printJoin(t3.types, t3, { separator() {
      this.space(), this.token(r3), this.space();
    } });
  }
  function s2(e3, t3) {
    true !== t3 && e3.token(t3);
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.TSAnyKeyword = function() {
    this.word("any");
  }, t2.TSArrayType = function(e3) {
    this.print(e3.elementType, e3, true), this.token("[]");
  }, t2.TSSatisfiesExpression = t2.TSAsExpression = function(e3) {
    var t3;
    const { type: r3, expression: n3, typeAnnotation: s3 } = e3, i2 = !(null == (t3 = n3.trailingComments) || !t3.length);
    this.print(n3, e3, true, void 0, i2), this.space(), this.word("TSAsExpression" === r3 ? "as" : "satisfies"), this.space(), this.print(s3, e3);
  }, t2.TSBigIntKeyword = function() {
    this.word("bigint");
  }, t2.TSBooleanKeyword = function() {
    this.word("boolean");
  }, t2.TSCallSignatureDeclaration = function(e3) {
    this.tsPrintSignatureDeclarationBase(e3), this.tokenChar(59);
  }, t2.TSConditionalType = function(e3) {
    this.print(e3.checkType), this.space(), this.word("extends"), this.space(), this.print(e3.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(e3.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e3.falseType);
  }, t2.TSConstructSignatureDeclaration = function(e3) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e3), this.tokenChar(59);
  }, t2.TSConstructorType = function(e3) {
    e3.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e3);
  }, t2.TSDeclareFunction = function(e3, t3) {
    e3.declare && (this.word("declare"), this.space()), this._functionHead(e3, t3), this.tokenChar(59);
  }, t2.TSDeclareMethod = function(e3) {
    this._classMethodHead(e3), this.tokenChar(59);
  }, t2.TSEnumDeclaration = function(e3) {
    const { declare: t3, const: n3, id: s3, members: i2 } = e3;
    t3 && (this.word("declare"), this.space()), n3 && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(s3, e3), this.space(), r2(this, i2, e3);
  }, t2.TSEnumMember = function(e3) {
    const { id: t3, initializer: r3 } = e3;
    this.print(t3, e3), r3 && (this.space(), this.tokenChar(61), this.space(), this.print(r3, e3)), this.tokenChar(44);
  }, t2.TSExportAssignment = function(e3) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e3.expression, e3), this.tokenChar(59);
  }, t2.TSExpressionWithTypeArguments = function(e3) {
    this.print(e3.expression, e3), this.print(e3.typeParameters, e3);
  }, t2.TSExternalModuleReference = function(e3) {
    this.token("require("), this.print(e3.expression, e3), this.tokenChar(41);
  }, t2.TSFunctionType = function(e3) {
    this.tsPrintFunctionOrConstructorType(e3);
  }, t2.TSImportEqualsDeclaration = function(e3) {
    const { isExport: t3, id: r3, moduleReference: n3 } = e3;
    t3 && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r3, e3), this.space(), this.tokenChar(61), this.space(), this.print(n3, e3), this.tokenChar(59);
  }, t2.TSImportType = function(e3) {
    const { argument: t3, qualifier: r3, typeParameters: n3 } = e3;
    this.word("import"), this.tokenChar(40), this.print(t3, e3), this.tokenChar(41), r3 && (this.tokenChar(46), this.print(r3, e3)), n3 && this.print(n3, e3);
  }, t2.TSIndexSignature = function(e3) {
    const { readonly: t3, static: r3 } = e3;
    r3 && (this.word("static"), this.space()), t3 && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e3.parameters, e3), this.tokenChar(93), this.print(e3.typeAnnotation, e3), this.tokenChar(59);
  }, t2.TSIndexedAccessType = function(e3) {
    this.print(e3.objectType, e3, true), this.tokenChar(91), this.print(e3.indexType, e3), this.tokenChar(93);
  }, t2.TSInferType = function(e3) {
    this.token("infer"), this.space(), this.print(e3.typeParameter);
  }, t2.TSInstantiationExpression = function(e3) {
    this.print(e3.expression, e3), this.print(e3.typeParameters, e3);
  }, t2.TSInterfaceBody = function(e3) {
    this.tsPrintTypeLiteralOrInterfaceBody(e3.body, e3);
  }, t2.TSInterfaceDeclaration = function(e3) {
    const { declare: t3, id: r3, typeParameters: n3, extends: s3, body: i2 } = e3;
    t3 && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r3, e3), this.print(n3, e3), null != s3 && s3.length && (this.space(), this.word("extends"), this.space(), this.printList(s3, e3)), this.space(), this.print(i2, e3);
  }, t2.TSIntersectionType = function(e3) {
    n2(this, e3, "&");
  }, t2.TSIntrinsicKeyword = function() {
    this.word("intrinsic");
  }, t2.TSLiteralType = function(e3) {
    this.print(e3.literal, e3);
  }, t2.TSMappedType = function(e3) {
    const { nameType: t3, optional: r3, readonly: n3, typeParameter: i2 } = e3;
    this.tokenChar(123), this.space(), n3 && (s2(this, n3), this.word("readonly"), this.space()), this.tokenChar(91), this.word(i2.name), this.space(), this.word("in"), this.space(), this.print(i2.constraint, i2), t3 && (this.space(), this.word("as"), this.space(), this.print(t3, e3)), this.tokenChar(93), r3 && (s2(this, r3), this.tokenChar(63)), this.tokenChar(58), this.space(), this.print(e3.typeAnnotation, e3), this.space(), this.tokenChar(125);
  }, t2.TSMethodSignature = function(e3) {
    const { kind: t3 } = e3;
    "set" !== t3 && "get" !== t3 || (this.word(t3), this.space()), this.tsPrintPropertyOrMethodName(e3), this.tsPrintSignatureDeclarationBase(e3), this.tokenChar(59);
  }, t2.TSModuleBlock = function(e3) {
    r2(this, e3.body, e3);
  }, t2.TSModuleDeclaration = function(e3) {
    const { declare: t3, id: r3 } = e3;
    if (t3 && (this.word("declare"), this.space()), e3.global || (this.word("Identifier" === r3.type ? "namespace" : "module"), this.space()), this.print(r3, e3), !e3.body) return void this.tokenChar(59);
    let n3 = e3.body;
    for (; "TSModuleDeclaration" === n3.type; ) this.tokenChar(46), this.print(n3.id, n3), n3 = n3.body;
    this.space(), this.print(n3, e3);
  }, t2.TSNamedTupleMember = function(e3) {
    this.print(e3.label, e3), e3.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e3.elementType, e3);
  }, t2.TSNamespaceExportDeclaration = function(e3) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e3.id, e3);
  }, t2.TSNeverKeyword = function() {
    this.word("never");
  }, t2.TSNonNullExpression = function(e3) {
    this.print(e3.expression, e3), this.tokenChar(33);
  }, t2.TSNullKeyword = function() {
    this.word("null");
  }, t2.TSNumberKeyword = function() {
    this.word("number");
  }, t2.TSObjectKeyword = function() {
    this.word("object");
  }, t2.TSOptionalType = function(e3) {
    this.print(e3.typeAnnotation, e3), this.tokenChar(63);
  }, t2.TSParameterProperty = function(e3) {
    e3.accessibility && (this.word(e3.accessibility), this.space()), e3.readonly && (this.word("readonly"), this.space()), this._param(e3.parameter);
  }, t2.TSParenthesizedType = function(e3) {
    this.tokenChar(40), this.print(e3.typeAnnotation, e3), this.tokenChar(41);
  }, t2.TSPropertySignature = function(e3) {
    const { readonly: t3 } = e3;
    t3 && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e3), this.print(e3.typeAnnotation, e3), this.tokenChar(59);
  }, t2.TSQualifiedName = function(e3) {
    this.print(e3.left, e3), this.tokenChar(46), this.print(e3.right, e3);
  }, t2.TSRestType = function(e3) {
    this.token("..."), this.print(e3.typeAnnotation, e3);
  }, t2.TSStringKeyword = function() {
    this.word("string");
  }, t2.TSSymbolKeyword = function() {
    this.word("symbol");
  }, t2.TSThisType = function() {
    this.word("this");
  }, t2.TSTupleType = function(e3) {
    this.tokenChar(91), this.printList(e3.elementTypes, e3), this.tokenChar(93);
  }, t2.TSTypeAliasDeclaration = function(e3) {
    const { declare: t3, id: r3, typeParameters: n3, typeAnnotation: s3 } = e3;
    t3 && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r3, e3), this.print(n3, e3), this.space(), this.tokenChar(61), this.space(), this.print(s3, e3), this.tokenChar(59);
  }, t2.TSTypeAnnotation = function(e3) {
    this.tokenChar(58), this.space(), e3.optional && this.tokenChar(63), this.print(e3.typeAnnotation, e3);
  }, t2.TSTypeAssertion = function(e3) {
    const { typeAnnotation: t3, expression: r3 } = e3;
    this.tokenChar(60), this.print(t3, e3), this.tokenChar(62), this.space(), this.print(r3, e3);
  }, t2.TSTypeLiteral = function(e3) {
    this.tsPrintTypeLiteralOrInterfaceBody(e3.members, e3);
  }, t2.TSTypeOperator = function(e3) {
    this.word(e3.operator), this.space(), this.print(e3.typeAnnotation, e3);
  }, t2.TSTypeParameter = function(e3) {
    e3.in && (this.word("in"), this.space()), e3.out && (this.word("out"), this.space()), this.word(e3.name), e3.constraint && (this.space(), this.word("extends"), this.space(), this.print(e3.constraint, e3)), e3.default && (this.space(), this.tokenChar(61), this.space(), this.print(e3.default, e3));
  }, t2.TSTypeParameterDeclaration = t2.TSTypeParameterInstantiation = function(e3, t3) {
    this.tokenChar(60), this.printList(e3.params, e3, {}), "ArrowFunctionExpression" === t3.type && 1 === e3.params.length && this.tokenChar(44), this.tokenChar(62);
  }, t2.TSTypePredicate = function(e3) {
    e3.asserts && (this.word("asserts"), this.space()), this.print(e3.parameterName), e3.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(e3.typeAnnotation.typeAnnotation));
  }, t2.TSTypeQuery = function(e3) {
    this.word("typeof"), this.space(), this.print(e3.exprName), e3.typeParameters && this.print(e3.typeParameters, e3);
  }, t2.TSTypeReference = function(e3) {
    this.print(e3.typeName, e3, true), this.print(e3.typeParameters, e3, true);
  }, t2.TSUndefinedKeyword = function() {
    this.word("undefined");
  }, t2.TSUnionType = function(e3) {
    n2(this, e3, "|");
  }, t2.TSUnknownKeyword = function() {
    this.word("unknown");
  }, t2.TSVoidKeyword = function() {
    this.word("void");
  }, t2.tsPrintClassMemberModifiers = function(e3) {
    const t3 = "ClassAccessorProperty" === e3.type || "ClassProperty" === e3.type;
    t3 && e3.declare && (this.word("declare"), this.space()), e3.accessibility && (this.word(e3.accessibility), this.space()), e3.static && (this.word("static"), this.space()), e3.override && (this.word("override"), this.space()), e3.abstract && (this.word("abstract"), this.space()), t3 && e3.readonly && (this.word("readonly"), this.space());
  }, t2.tsPrintFunctionOrConstructorType = function(e3) {
    const { typeParameters: t3 } = e3, r3 = e3.parameters;
    this.print(t3, e3), this.tokenChar(40), this._parameters(r3, e3), this.tokenChar(41), this.space(), this.token("=>"), this.space();
    const n3 = e3.typeAnnotation;
    this.print(n3.typeAnnotation, e3);
  }, t2.tsPrintPropertyOrMethodName = function(e3) {
    e3.computed && this.tokenChar(91), this.print(e3.key, e3), e3.computed && this.tokenChar(93), e3.optional && this.tokenChar(63);
  }, t2.tsPrintSignatureDeclarationBase = function(e3) {
    const { typeParameters: t3 } = e3, r3 = e3.parameters;
    this.print(t3, e3), this.tokenChar(40), this._parameters(r3, e3), this.tokenChar(41);
    const n3 = e3.typeAnnotation;
    this.print(n3, e3);
  }, t2.tsPrintTypeLiteralOrInterfaceBody = function(e3, t3) {
    r2(this, e3, t3);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.find = function(e3) {
    let t3 = this;
    do {
      if (e3(t3)) return t3;
    } while (t3 = t3.parentPath);
    return null;
  }, t2.findParent = function(e3) {
    let t3 = this;
    for (; t3 = t3.parentPath; ) if (e3(t3)) return t3;
    return null;
  }, t2.getAncestry = function() {
    let e3 = this;
    const t3 = [];
    do {
      t3.push(e3);
    } while (e3 = e3.parentPath);
    return t3;
  }, t2.getDeepestCommonAncestorFrom = function(e3, t3) {
    if (!e3.length) return this;
    if (1 === e3.length) return e3[0];
    let r3, n3, s3 = 1 / 0;
    const i2 = e3.map((e4) => {
      const t4 = [];
      do {
        t4.unshift(e4);
      } while ((e4 = e4.parentPath) && e4 !== this);
      return t4.length < s3 && (s3 = t4.length), t4;
    }), o2 = i2[0];
    e: for (let e4 = 0; e4 < s3; e4++) {
      const t4 = o2[e4];
      for (const r4 of i2) if (r4[e4] !== t4) break e;
      r3 = e4, n3 = t4;
    }
    if (n3) return t3 ? t3(n3, r3, i2) : n3;
    throw new Error("Couldn't find intersection");
  }, t2.getEarliestCommonAncestorFrom = function(e3) {
    return this.getDeepestCommonAncestorFrom(e3, function(e4, t3, r3) {
      let n3;
      const i2 = s2[e4.type];
      for (const e5 of r3) {
        const r4 = e5[t3 + 1];
        n3 ? (r4.listKey && n3.listKey === r4.listKey && r4.key < n3.key || i2.indexOf(n3.parentKey) > i2.indexOf(r4.parentKey)) && (n3 = r4) : n3 = r4;
      }
      return n3;
    });
  }, t2.getFunctionParent = function() {
    return this.findParent((e3) => e3.isFunction());
  }, t2.getStatementParent = function() {
    let e3 = this;
    do {
      if (!e3.parentPath || Array.isArray(e3.container) && e3.isStatement()) break;
      e3 = e3.parentPath;
    } while (e3);
    if (e3 && (e3.isProgram() || e3.isFile())) throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return e3;
  }, t2.inType = function() {
    let e3 = this;
    for (var t3 = arguments.length, r3 = new Array(t3), n3 = 0; n3 < t3; n3++) r3[n3] = arguments[n3];
    for (; e3; ) {
      for (const t4 of r3) if (e3.node.type === t4) return true;
      e3 = e3.parentPath;
    }
    return false;
  }, t2.isAncestor = function(e3) {
    return e3.isDescendant(this);
  }, t2.isDescendant = function(e3) {
    return !!this.findParent((t3) => t3 === e3);
  };
  var n2 = r2(0);
  const { VISITOR_KEYS: s2 } = n2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._getTypeAnnotation = function() {
    const e3 = this.node;
    if (e3) {
      if (e3.typeAnnotation) return e3.typeAnnotation;
      if (!P.has(e3)) {
        P.add(e3);
        try {
          var t3;
          let r3 = n2[e3.type];
          if (r3) return r3.call(this, e3);
          if (r3 = n2[this.parentPath.type], null != (t3 = r3) && t3.validParent) return this.parentPath.getTypeAnnotation();
        } finally {
          P.delete(e3);
        }
      }
    } else if ("init" === this.key && this.parentPath.isVariableDeclarator()) {
      const e4 = this.parentPath.parentPath, t4 = e4.parentPath;
      return "left" === e4.key && t4.isForInStatement() ? T() : "left" === e4.key && t4.isForOfStatement() ? i2() : w();
    }
  }, t2.baseTypeStrictlyMatches = function(e3) {
    const t3 = this.getTypeAnnotation(), r3 = e3.getTypeAnnotation();
    return !(o2(t3) || !u(t3)) && r3.type === t3.type;
  }, t2.couldBeBaseType = function(e3) {
    const t3 = this.getTypeAnnotation();
    if (o2(t3)) return true;
    if (S(t3)) {
      for (const r3 of t3.types) if (o2(r3) || A(e3, r3, true)) return true;
      return false;
    }
    return A(e3, t3, true);
  }, t2.getTypeAnnotation = function() {
    let e3 = this.getData("typeAnnotation");
    return null != e3 || (e3 = this._getTypeAnnotation() || i2(), (E(e3) || g(e3)) && (e3 = e3.typeAnnotation), this.setData("typeAnnotation", e3)), e3;
  }, t2.isBaseType = function(e3, t3) {
    return A(e3, this.getTypeAnnotation(), t3);
  }, t2.isGenericType = function(e3) {
    const t3 = this.getTypeAnnotation();
    return !("Array" !== e3 || !(y(t3) || a2(t3) || v(t3))) || (p(t3) && d(t3.id, { name: e3 }) || b(t3) && d(t3.typeName, { name: e3 }));
  };
  var n2 = r2(425), s2 = r2(0);
  const { anyTypeAnnotation: i2, isAnyTypeAnnotation: o2, isArrayTypeAnnotation: a2, isBooleanTypeAnnotation: l, isEmptyTypeAnnotation: c, isFlowBaseAnnotation: u, isGenericTypeAnnotation: p, isIdentifier: d, isMixedTypeAnnotation: f, isNumberTypeAnnotation: h, isStringTypeAnnotation: m, isTSArrayType: y, isTSTypeAnnotation: g, isTSTypeReference: b, isTupleTypeAnnotation: v, isTypeAnnotation: E, isUnionTypeAnnotation: S, isVoidTypeAnnotation: x, stringTypeAnnotation: T, voidTypeAnnotation: w } = s2, P = /* @__PURE__ */ new WeakSet();
  function A(e3, t3, r3) {
    if ("string" === e3) return m(t3);
    if ("number" === e3) return h(t3);
    if ("boolean" === e3) return l(t3);
    if ("any" === e3) return o2(t3);
    if ("mixed" === e3) return f(t3);
    if ("empty" === e3) return c(t3);
    if ("void" === e3) return x(t3);
    if (r3) return false;
    throw new Error(`Unknown base type ${e3}`);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrayExpression = A, t2.AssignmentExpression = function() {
    return this.get("right").getTypeAnnotation();
  }, t2.BinaryExpression = function(e3) {
    const t3 = e3.operator;
    if (l.indexOf(t3) >= 0) return b();
    if (o2.indexOf(t3) >= 0) return f();
    if ("+" === t3) {
      const e4 = this.get("right"), t4 = this.get("left");
      return t4.isBaseType("number") && e4.isBaseType("number") ? b() : t4.isBaseType("string") || e4.isBaseType("string") ? v() : S([v(), b()]);
    }
  }, t2.BooleanLiteral = function() {
    return f();
  }, t2.CallExpression = function() {
    const { callee: e3 } = this.node;
    return I(e3) ? d(v()) : O(e3) || _(e3) || T(e3, { name: "Array" }) ? d(p()) : k(e3) ? d(E([v(), p()])) : N(this.get("callee"));
  }, t2.ConditionalExpression = function() {
    const e3 = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, i2.createUnionType)(e3);
  }, t2.ClassDeclaration = t2.ClassExpression = t2.FunctionDeclaration = t2.ArrowFunctionExpression = t2.FunctionExpression = function() {
    return m(y("Function"));
  }, Object.defineProperty(t2, "Identifier", { enumerable: true, get: function() {
    return s2.default;
  } }), t2.LogicalExpression = function() {
    const e3 = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, i2.createUnionType)(e3);
  }, t2.NewExpression = function(e3) {
    if ("Identifier" === e3.callee.type) return m(e3.callee);
  }, t2.NullLiteral = function() {
    return g();
  }, t2.NumericLiteral = function() {
    return b();
  }, t2.ObjectExpression = function() {
    return m(y("Object"));
  }, t2.ParenthesizedExpression = function() {
    return this.get("expression").getTypeAnnotation();
  }, t2.RegExpLiteral = function() {
    return m(y("RegExp"));
  }, t2.RestElement = C, t2.SequenceExpression = function() {
    return this.get("expressions").pop().getTypeAnnotation();
  }, t2.StringLiteral = function() {
    return v();
  }, t2.TSAsExpression = P, t2.TSNonNullExpression = function() {
    return this.get("expression").getTypeAnnotation();
  }, t2.TaggedTemplateExpression = function() {
    return N(this.get("tag"));
  }, t2.TemplateLiteral = function() {
    return v();
  }, t2.TypeCastExpression = w, t2.UnaryExpression = function(e3) {
    const t3 = e3.operator;
    return "void" === t3 ? x() : c.indexOf(t3) >= 0 ? b() : u.indexOf(t3) >= 0 ? v() : a2.indexOf(t3) >= 0 ? f() : void 0;
  }, t2.UpdateExpression = function(e3) {
    const t3 = e3.operator;
    if ("++" === t3 || "--" === t3) return b();
  }, t2.VariableDeclarator = function() {
    if (this.get("id").isIdentifier()) return this.get("init").getTypeAnnotation();
  };
  var n2 = r2(0), s2 = r2(426), i2 = r2(223);
  const { BOOLEAN_BINARY_OPERATORS: o2, BOOLEAN_UNARY_OPERATORS: a2, NUMBER_BINARY_OPERATORS: l, NUMBER_UNARY_OPERATORS: c, STRING_UNARY_OPERATORS: u, anyTypeAnnotation: p, arrayTypeAnnotation: d, booleanTypeAnnotation: f, buildMatchMemberExpression: h, genericTypeAnnotation: m, identifier: y, nullLiteralTypeAnnotation: g, numberTypeAnnotation: b, stringTypeAnnotation: v, tupleTypeAnnotation: E, unionTypeAnnotation: S, voidTypeAnnotation: x, isIdentifier: T } = n2;
  function w(e3) {
    return e3.typeAnnotation;
  }
  function P(e3) {
    return e3.typeAnnotation;
  }
  function A() {
    return m(y("Array"));
  }
  function C() {
    return A();
  }
  w.validParent = true, P.validParent = true, C.validParent = true;
  const O = h("Array.from"), I = h("Object.keys"), _ = h("Object.values"), k = h("Object.entries");
  function N(e3) {
    if ((e3 = e3.resolve()).isFunction()) {
      const { node: t3 } = e3;
      if (t3.async) return t3.generator ? m(y("AsyncIterator")) : m(y("Promise"));
      if (t3.generator) return m(y("Iterator"));
      if (e3.node.returnType) return e3.node.returnType;
    }
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    if (!this.isReferenced()) return;
    const t3 = this.scope.getBinding(e3.name);
    return t3 ? t3.identifier.typeAnnotation ? t3.identifier.typeAnnotation : function(e4, t4, r3) {
      const n3 = [], i3 = [];
      let o3 = c(e4, t4, i3);
      const a3 = p(e4, t4, r3);
      if (a3) {
        const t5 = c(e4, a3.ifStatement);
        o3 = o3.filter((e5) => t5.indexOf(e5) < 0), n3.push(a3.typeAnnotation);
      }
      if (o3.length) {
        o3.push(...i3);
        for (const e5 of o3) n3.push(e5.getTypeAnnotation());
      }
      if (n3.length) return (0, s2.createUnionType)(n3);
    }(t3, this, e3.name) : "undefined" === e3.name ? l() : "NaN" === e3.name || "Infinity" === e3.name ? a2() : void e3.name;
  };
  var n2 = r2(0), s2 = r2(223);
  const { BOOLEAN_NUMBER_BINARY_OPERATORS: i2, createTypeAnnotationBasedOnTypeof: o2, numberTypeAnnotation: a2, voidTypeAnnotation: l } = n2;
  function c(e3, t3, r3) {
    const n3 = e3.constantViolations.slice();
    return n3.unshift(e3.path), n3.filter((e4) => {
      const n4 = (e4 = e4.resolve())._guessExecutionStatusRelativeTo(t3);
      return r3 && "unknown" === n4 && r3.push(e4), "before" === n4;
    });
  }
  function u(e3, t3) {
    const r3 = t3.node.operator, n3 = t3.get("right").resolve(), s3 = t3.get("left").resolve();
    let l2, c2, u2;
    if (s3.isIdentifier({ name: e3 }) ? l2 = n3 : n3.isIdentifier({ name: e3 }) && (l2 = s3), l2) return "===" === r3 ? l2.getTypeAnnotation() : i2.indexOf(r3) >= 0 ? a2() : void 0;
    if ("===" !== r3 && "==" !== r3) return;
    if (s3.isUnaryExpression({ operator: "typeof" }) ? (c2 = s3, u2 = n3) : n3.isUnaryExpression({ operator: "typeof" }) && (c2 = n3, u2 = s3), !c2) return;
    if (!c2.get("argument").isIdentifier({ name: e3 })) return;
    if (u2 = u2.resolve(), !u2.isLiteral()) return;
    const p2 = u2.node.value;
    return "string" == typeof p2 ? o2(p2) : void 0;
  }
  function p(e3, t3, r3) {
    const n3 = function(e4, t4, r4) {
      let n4;
      for (; n4 = t4.parentPath; ) {
        if (n4.isIfStatement() || n4.isConditionalExpression()) {
          if ("test" === t4.key) return;
          return n4;
        }
        if (n4.isFunction() && n4.parentPath.scope.getBinding(r4) !== e4) return;
        t4 = n4;
      }
    }(e3, t3, r3);
    if (!n3) return;
    const i3 = [n3.get("test")], o3 = [];
    for (let e4 = 0; e4 < i3.length; e4++) {
      const t4 = i3[e4];
      if (t4.isLogicalExpression()) "&&" === t4.node.operator && (i3.push(t4.get("left")), i3.push(t4.get("right")));
      else if (t4.isBinaryExpression()) {
        const e5 = u(r3, t4);
        e5 && o3.push(e5);
      }
    }
    return o3.length ? { typeAnnotation: (0, s2.createUnionType)(o3), ifStatement: n3 } : p(e3, n3, r3);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._replaceWith = function(e3) {
    var t3;
    if (!this.container) throw new ReferenceError("Container is falsy");
    this.inList ? M(this.parent, this.key, [e3]) : M(this.parent, this.key, e3), this.debug(`Replace with ${null == e3 ? void 0 : e3.type}`), null == (t3 = (0, o2.getCachedPaths)(this.hub, this.parent)) || t3.set(e3, this).delete(this.node), this.node = this.container[this.key] = e3;
  }, t2.replaceExpressionWithStatements = function(e3) {
    this.resync();
    const t3 = [], r3 = R(e3, t3);
    if (r3) {
      for (const e4 of t3) this.scope.push({ id: e4 });
      return this.replaceWith(r3)[0].get("expressions");
    }
    const n3 = this.getFunctionParent(), i3 = null == n3 ? void 0 : n3.is("async"), o3 = null == n3 ? void 0 : n3.is("generator"), a3 = p([], h(e3));
    this.replaceWith(y(a3, []));
    const l2 = this.get("callee");
    (0, c.default)(l2.get("body"), (e4) => {
      this.scope.push({ id: e4 });
    }, "var");
    const m2 = this.get("callee").getCompletionRecords();
    for (const e4 of m2) {
      if (!e4.isExpressionStatement()) continue;
      const t4 = e4.findParent((e5) => e5.isLoop());
      if (t4) {
        let r4 = t4.getData("expressionReplacementReturnUid");
        r4 ? r4 = S(r4.name) : (r4 = l2.scope.generateDeclaredUidIdentifier("ret"), l2.get("body").pushContainer("body", j(g(r4))), t4.setData("expressionReplacementReturnUid", r4)), e4.get("expression").replaceWith(d("=", g(r4), e4.node.expression));
      } else e4.replaceWith(j(e4.node.expression));
    }
    l2.arrowFunctionToExpression();
    const b2 = l2, v2 = i3 && s2.default.hasType(this.get("callee.body").node, "AwaitExpression", u), E2 = o3 && s2.default.hasType(this.get("callee.body").node, "YieldExpression", u);
    return v2 && (b2.set("async", true), E2 || this.replaceWith(f(this.node))), E2 && (b2.set("generator", true), this.replaceWith(B(this.node, true))), b2.get("body.body");
  }, t2.replaceInline = function(e3) {
    if (this.resync(), Array.isArray(e3)) {
      if (Array.isArray(this.container)) {
        e3 = this._verifyNodeList(e3);
        const t3 = this._containerInsertAfter(e3);
        return this.remove(), t3;
      }
      return this.replaceWithMultiple(e3);
    }
    return this.replaceWith(e3);
  }, t2.replaceWith = function(e3) {
    if (this.resync(), this.removed) throw new Error("You can't replace this node, we've already removed it");
    let t3 = e3 instanceof i2.default ? e3.node : e3;
    if (!t3) throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === t3) return [this];
    if (this.isProgram() && !_(t3)) throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(t3)) throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if ("string" == typeof t3) throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let r3 = "";
    if (this.isNodeType("Statement") && C(t3) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(t3) || this.parentPath.isExportDefaultDeclaration() || (t3 = v(t3), r3 = "expression")), this.isNodeType("Expression") && k(t3) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t3)) return this.replaceExpressionWithStatements([t3]);
    const n3 = this.node;
    return n3 && (w(t3, n3), D(n3)), this._replaceWith(t3), this.type = t3.type, this.setScope(), this.requeue(), [r3 ? this.get(r3) : this];
  }, t2.replaceWithMultiple = function(e3) {
    var t3;
    this.resync(), e3 = this._verifyNodeList(e3), x(e3[0], this.node), T(e3[e3.length - 1], this.node), null == (t3 = (0, o2.getCachedPaths)(this.hub, this.parent)) || t3.delete(this.node), this.node = this.container[this.key] = null;
    const r3 = this.insertAfter(e3);
    return this.node ? this.requeue() : this.remove(), r3;
  }, t2.replaceWithSourceString = function(e3) {
    let t3;
    this.resync();
    try {
      e3 = `(${e3})`, t3 = (0, a2.parse)(e3);
    } catch (t4) {
      const r4 = t4.loc;
      throw r4 && (t4.message += " - make sure this is an expression.\n" + (0, n2.codeFrameColumns)(e3, { start: { line: r4.line, column: r4.column + 1 } }), t4.code = "BABEL_REPLACE_SOURCE_ERROR"), t4;
    }
    const r3 = t3.program.body[0].expression;
    return s2.default.removeProperties(r3), this.replaceWith(r3);
  };
  var n2 = r2(36), s2 = r2(14), i2 = r2(28), o2 = r2(35), a2 = r2(21), l = r2(0), c = r2(429);
  const { FUNCTION_TYPES: u, arrowFunctionExpression: p, assignmentExpression: d, awaitExpression: f, blockStatement: h, buildUndefinedNode: m, callExpression: y, cloneNode: g, conditionalExpression: b, expressionStatement: v, getBindingIdentifiers: E, identifier: S, inheritLeadingComments: x, inheritTrailingComments: T, inheritsComments: w, isBlockStatement: P, isEmptyStatement: A, isExpression: C, isExpressionStatement: O, isIfStatement: I, isProgram: _, isStatement: k, isVariableDeclaration: N, removeComments: D, returnStatement: j, sequenceExpression: L, validate: M, yieldExpression: B } = l;
  function R(e3, t3) {
    const r3 = [];
    let n3 = true;
    for (const s3 of e3) if (A(s3) || (n3 = false), C(s3)) r3.push(s3);
    else if (O(s3)) r3.push(s3.expression);
    else if (N(s3)) {
      if ("var" !== s3.kind) return;
      for (const e4 of s3.declarations) {
        const n4 = E(e4);
        for (const e5 of Object.keys(n4)) t3.push(g(n4[e5]));
        e4.init && r3.push(d("=", e4.id, e4.init));
      }
      n3 = true;
    } else if (I(s3)) {
      const e4 = s3.consequent ? R([s3.consequent], t3) : m(), n4 = s3.alternate ? R([s3.alternate], t3) : m();
      if (!e4 || !n4) return;
      r3.push(b(s3.test, e4, n4));
    } else if (P(s3)) {
      const e4 = R(s3.body, t3);
      if (!e4) return;
      r3.push(e4);
    } else {
      if (!A(s3)) return;
      0 === e3.indexOf(s3) && (n3 = true);
    }
    return n3 && r3.push(m()), 1 === r3.length ? r3[0] : L(r3);
  }
}, () => {
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "var";
    e3.traverse(a2, { kind: r3, emit: t3 });
  };
  var n2 = r2(0);
  const { assignmentExpression: s2, expressionStatement: i2, identifier: o2 } = n2, a2 = { Scope(e3, t3) {
    "let" === t3.kind && e3.skip();
  }, FunctionParent(e3) {
    e3.skip();
  }, VariableDeclaration(e3, t3) {
    if (t3.kind && e3.node.kind !== t3.kind) return;
    const r3 = [], n3 = e3.get("declarations");
    let a3;
    for (const e4 of n3) {
      a3 = e4.node.id, e4.node.init && r3.push(i2(s2("=", e4.node.id, e4.node.init)));
      for (const r4 of Object.keys(e4.getBindingIdentifiers())) t3.emit(o2(r4), r4, null !== e4.node.init);
    }
    e3.parentPath.isFor({ left: e3.node }) ? e3.replaceWith(a3) : e3.replaceWithMultiple(r3);
  } };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.evaluate = function() {
    const e3 = { confident: true, deoptPath: null, seen: /* @__PURE__ */ new Map() };
    let t3 = c(this, e3);
    return e3.confident || (t3 = void 0), { confident: e3.confident, deopt: e3.deoptPath, value: t3 };
  }, t2.evaluateTruthy = function() {
    const e3 = this.evaluate();
    if (e3.confident) return !!e3.value;
  };
  const n2 = ["Number", "String", "Math"], s2 = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null], i2 = ["random"];
  function o2(e3) {
    return n2.includes(e3);
  }
  function a2(e3, t3) {
    t3.confident && (t3.deoptPath = e3, t3.confident = false);
  }
  const l = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
  function c(e3, t3) {
    const { node: n3 } = e3, { seen: p } = t3;
    if (p.has(n3)) {
      const r3 = p.get(n3);
      return r3.resolved ? r3.value : void a2(e3, t3);
    }
    {
      const d = { resolved: false };
      p.set(n3, d);
      const f = function(e4, t4) {
        if (t4.confident) {
          if (e4.isSequenceExpression()) {
            const r3 = e4.get("expressions");
            return c(r3[r3.length - 1], t4);
          }
          if (e4.isStringLiteral() || e4.isNumericLiteral() || e4.isBooleanLiteral()) return e4.node.value;
          if (e4.isNullLiteral()) return null;
          if (e4.isTemplateLiteral()) return u(e4, e4.node.quasis, t4);
          if (e4.isTaggedTemplateExpression() && e4.get("tag").isMemberExpression()) {
            const r3 = e4.get("tag.object"), { node: { name: n4 } } = r3, s3 = e4.get("tag.property");
            if (r3.isIdentifier() && "String" === n4 && !e4.scope.getBinding(n4) && s3.isIdentifier() && "raw" === s3.node.name) return u(e4, e4.node.quasi.quasis, t4, true);
          }
          if (e4.isConditionalExpression()) {
            const r3 = c(e4.get("test"), t4);
            if (!t4.confident) return;
            return c(r3 ? e4.get("consequent") : e4.get("alternate"), t4);
          }
          if (e4.isExpressionWrapper()) return c(e4.get("expression"), t4);
          if (e4.isMemberExpression() && !e4.parentPath.isCallExpression({ callee: e4.node })) {
            const r3 = e4.get("property"), n4 = e4.get("object");
            if (n4.isLiteral()) {
              const s3 = n4.node.value, i3 = typeof s3;
              let o3 = null;
              if (e4.node.computed) {
                if (o3 = c(r3, t4), !t4.confident) return;
              } else r3.isIdentifier() && (o3 = r3.node.name);
              if (!("number" !== i3 && "string" !== i3 || null == o3 || "number" != typeof o3 && "string" != typeof o3)) return s3[o3];
            }
          }
          if (e4.isReferencedIdentifier()) {
            const r3 = e4.scope.getBinding(e4.node.name);
            if (r3) {
              if (r3.constantViolations.length > 0 || e4.node.start < r3.path.node.end) return void a2(r3.path, t4);
              if (r3.hasValue) return r3.value;
            }
            const n4 = e4.node.name;
            if (l.has(n4)) return r3 ? void a2(r3.path, t4) : l.get(n4);
            const s3 = e4.resolve();
            return s3 === e4 ? void a2(e4, t4) : c(s3, t4);
          }
          if (e4.isUnaryExpression({ prefix: true })) {
            if ("void" === e4.node.operator) return;
            const r3 = e4.get("argument");
            if ("typeof" === e4.node.operator && (r3.isFunction() || r3.isClass())) return "function";
            const n4 = c(r3, t4);
            if (!t4.confident) return;
            switch (e4.node.operator) {
              case "!":
                return !n4;
              case "+":
                return +n4;
              case "-":
                return -n4;
              case "~":
                return ~n4;
              case "typeof":
                return typeof n4;
            }
          }
          if (e4.isArrayExpression()) {
            const r3 = [], n4 = e4.get("elements");
            for (const e5 of n4) {
              const n5 = e5.evaluate();
              if (!n5.confident) return void a2(n5.deopt, t4);
              r3.push(n5.value);
            }
            return r3;
          }
          if (e4.isObjectExpression()) {
            const r3 = {}, n4 = e4.get("properties");
            for (const e5 of n4) {
              if (e5.isObjectMethod() || e5.isSpreadElement()) return void a2(e5, t4);
              const n5 = e5.get("key");
              let s3;
              if (e5.node.computed) {
                if (s3 = n5.evaluate(), !s3.confident) return void a2(s3.deopt, t4);
                s3 = s3.value;
              } else s3 = n5.isIdentifier() ? n5.node.name : n5.node.value;
              let i3 = e5.get("value").evaluate();
              if (!i3.confident) return void a2(i3.deopt, t4);
              i3 = i3.value, r3[s3] = i3;
            }
            return r3;
          }
          if (e4.isLogicalExpression()) {
            const r3 = t4.confident, n4 = c(e4.get("left"), t4), s3 = t4.confident;
            t4.confident = r3;
            const i3 = c(e4.get("right"), t4), o3 = t4.confident;
            switch (e4.node.operator) {
              case "||":
                if (t4.confident = s3 && (!!n4 || o3), !t4.confident) return;
                return n4 || i3;
              case "&&":
                if (t4.confident = s3 && (!n4 || o3), !t4.confident) return;
                return n4 && i3;
              case "??":
                if (t4.confident = s3 && (null != n4 || o3), !t4.confident) return;
                return null != n4 ? n4 : i3;
            }
          }
          if (e4.isBinaryExpression()) {
            const r3 = c(e4.get("left"), t4);
            if (!t4.confident) return;
            const n4 = c(e4.get("right"), t4);
            if (!t4.confident) return;
            switch (e4.node.operator) {
              case "-":
                return r3 - n4;
              case "+":
                return r3 + n4;
              case "/":
                return r3 / n4;
              case "*":
                return r3 * n4;
              case "%":
                return r3 % n4;
              case "**":
                return Math.pow(r3, n4);
              case "<":
                return r3 < n4;
              case ">":
                return r3 > n4;
              case "<=":
                return r3 <= n4;
              case ">=":
                return r3 >= n4;
              case "==":
                return r3 == n4;
              case "!=":
                return r3 != n4;
              case "===":
                return r3 === n4;
              case "!==":
                return r3 !== n4;
              case "|":
                return r3 | n4;
              case "&":
                return r3 & n4;
              case "^":
                return r3 ^ n4;
              case "<<":
                return r3 << n4;
              case ">>":
                return r3 >> n4;
              case ">>>":
                return r3 >>> n4;
            }
          }
          if (e4.isCallExpression()) {
            const n4 = e4.get("callee");
            let a3, l2;
            if (n4.isIdentifier() && !e4.scope.getBinding(n4.node.name) && (o2(n4.node.name) || function(e5) {
              return s2.includes(e5);
            }(n4.node.name)) && (l2 = r2.g[n4.node.name]), n4.isMemberExpression()) {
              const e5 = n4.get("object"), t5 = n4.get("property");
              if (e5.isIdentifier() && t5.isIdentifier() && o2(e5.node.name) && !function(e6) {
                return i2.includes(e6);
              }(t5.node.name)) {
                a3 = r2.g[e5.node.name];
                const n5 = t5.node.name;
                Object.hasOwnProperty.call(a3, n5) && (l2 = a3[n5]);
              }
              if (e5.isLiteral() && t5.isIdentifier()) {
                const r3 = typeof e5.node.value;
                "string" !== r3 && "number" !== r3 || (a3 = e5.node.value, l2 = a3[t5.node.name]);
              }
            }
            if (l2) {
              const r3 = e4.get("arguments").map((e5) => c(e5, t4));
              if (!t4.confident) return;
              return l2.apply(a3, r3);
            }
          }
          a2(e4, t4);
        }
      }(e3, t3);
      return t3.confident && (d.resolved = true, d.value = f), f;
    }
  }
  function u(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], s3 = "", i3 = 0;
    const o3 = e3.isTemplateLiteral() ? e3.get("expressions") : e3.get("quasi.expressions");
    for (const e4 of t3) {
      if (!r3.confident) break;
      s3 += n3 ? e4.value.raw : e4.value.cooked;
      const t4 = o3[i3++];
      t4 && (s3 += String(c(t4, r3)));
    }
    if (r3.confident) return s3;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.arrowFunctionToExpression = function() {
    let { allowInsertArrow: e3 = true, allowInsertArrowWithRest: t3 = e3, noNewArrows: r3 = !((e4) => null == (e4 = arguments[0]) ? void 0 : e4.specCompliant)() } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (!this.isArrowFunctionExpression()) throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    const { thisBinding: n3, fnPath: s3 } = D(this, r3, e3, t3);
    if (s3.ensureBlock(), s3.node.type = "FunctionExpression", !r3) {
      const e4 = n3 ? null : s3.scope.generateUidIdentifier("arrowCheckId");
      return e4 && s3.parentPath.scope.push({ id: e4, init: x([]) }), s3.get("body").unshiftContainer("body", f(p(this.hub.addHelper("newArrowCheck"), [I(), h(e4 ? e4.name : n3)]))), s3.replaceWith(p(v((0, i2.default)(this, true) || s3.node, h("bind")), [e4 ? h(e4.name) : I()])), s3.get("callee.object");
    }
    return s3;
  }, t2.ensureBlock = function() {
    const e3 = this.get("body"), t3 = e3.node;
    if (Array.isArray(e3)) throw new Error("Can't convert array path to a block statement");
    if (!t3) throw new Error("Can't convert node without a body");
    if (e3.isBlockStatement()) return t3;
    const r3 = [];
    let n3, s3, i3 = "body";
    e3.isStatement() ? (s3 = "body", n3 = 0, r3.push(e3.node)) : (i3 += ".body.0", this.isFunction() ? (n3 = "argument", r3.push(w(e3.node))) : (n3 = "expression", r3.push(f(e3.node)))), this.node.body = u(r3);
    const o3 = this.get(i3);
    return e3.setup(o3, s3 ? o3.node[s3] : o3.node, s3, n3), this.node;
  }, t2.toComputedKey = function() {
    let e3;
    if (this.isMemberExpression()) e3 = this.node.property;
    else {
      if (!this.isProperty() && !this.isMethod()) throw new ReferenceError("todo");
      e3 = this.node.key;
    }
    return this.node.computed || m(e3) && (e3 = C(e3.name)), e3;
  }, t2.unwrapFunctionEnvironment = function() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    D(this);
  };
  var n2 = r2(0), s2 = r2(33), i2 = r2(119), o2 = r2(57);
  const { arrowFunctionExpression: a2, assignmentExpression: l, binaryExpression: c, blockStatement: u, callExpression: p, conditionalExpression: d, expressionStatement: f, identifier: h, isIdentifier: m, jsxIdentifier: y, logicalExpression: g, LOGICAL_OPERATORS: b, memberExpression: v, metaProperty: E, numericLiteral: S, objectExpression: x, restElement: T, returnStatement: w, sequenceExpression: P, spreadElement: A, stringLiteral: C, super: O, thisExpression: I, toExpression: _, unaryExpression: k } = n2;
  t2.arrowFunctionToShadowed = function() {
    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
  };
  const N = (0, o2.merge)([{ CallExpression(e3, t3) {
    let { allSuperCalls: r3 } = t3;
    e3.get("callee").isSuper() && r3.push(e3);
  } }, s2.default]);
  function D(e3) {
    let t3, r3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], i3 = e3.findParent((e4) => e4.isArrowFunctionExpression() ? (null != t3 || (t3 = e4), false) : e4.isFunction() || e4.isProgram() || e4.isClassProperty({ static: false }) || e4.isClassPrivateProperty({ static: false }));
    const o3 = i3.isClassMethod({ kind: "constructor" });
    if (i3.isClassProperty() || i3.isClassPrivateProperty()) if (t3) i3 = t3;
    else {
      if (!n3) throw e3.buildCodeFrameError("Unable to transform arrow inside class property");
      e3.replaceWith(p(a2([], _(e3.node)), [])), i3 = e3.get("callee"), e3 = i3.get("body");
    }
    const { thisPaths: u2, argumentsPaths: f2, newTargetPaths: m2, superProps: x2, superCalls: w2 } = function(e4) {
      const t4 = [], r4 = [], n4 = [], s4 = [], i4 = [];
      return e4.traverse(B, { thisPaths: t4, argumentsPaths: r4, newTargetPaths: n4, superProps: s4, superCalls: i4 }), { thisPaths: t4, argumentsPaths: r4, newTargetPaths: n4, superProps: s4, superCalls: i4 };
    }(e3);
    if (o3 && w2.length > 0) {
      if (!n3) throw w2[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      if (!s3) throw w2[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      const e4 = [];
      i3.traverse(N, { allSuperCalls: e4 });
      const t4 = function(e5) {
        return M(e5, "supercall", () => {
          const t5 = e5.scope.generateUidIdentifier("args");
          return a2([T(t5)], p(O(), [A(h(t5.name))]));
        });
      }(i3);
      e4.forEach((e5) => {
        const r4 = h(t4);
        r4.loc = e5.node.callee.loc, e5.get("callee").replaceWith(r4);
      });
    }
    if (f2.length > 0) {
      const e4 = M(i3, "arguments", () => {
        const e5 = () => h("arguments");
        return i3.scope.path.isProgram() ? d(c("===", k("typeof", e5()), C("undefined")), i3.scope.buildUndefinedNode(), e5()) : e5();
      });
      f2.forEach((t4) => {
        const r4 = h(e4);
        r4.loc = t4.node.loc, t4.replaceWith(r4);
      });
    }
    if (m2.length > 0) {
      const e4 = M(i3, "newtarget", () => E(h("new"), h("target")));
      m2.forEach((t4) => {
        const r4 = h(e4);
        r4.loc = t4.node.loc, t4.replaceWith(r4);
      });
    }
    if (x2.length > 0) {
      if (!n3) throw x2[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      x2.reduce((e4, t4) => e4.concat(function(e5) {
        if (e5.parentPath.isAssignmentExpression() && "=" !== e5.parentPath.node.operator) {
          const r4 = e5.parentPath, n4 = r4.node.operator.slice(0, -1), s4 = r4.node.right, i4 = function(e6) {
            return b.includes(e6);
          }(n4);
          if (e5.node.computed) {
            const o4 = e5.scope.generateDeclaredUidIdentifier("tmp"), a3 = e5.node.object, c2 = e5.node.property;
            r4.get("left").replaceWith(v(a3, l("=", o4, c2), true)), r4.get("right").replaceWith(t5(i4 ? "=" : n4, v(a3, h(o4.name), true), s4));
          } else {
            const o4 = e5.node.object, a3 = e5.node.property;
            r4.get("left").replaceWith(v(o4, a3)), r4.get("right").replaceWith(t5(i4 ? "=" : n4, v(o4, h(a3.name)), s4));
          }
          return i4 ? r4.replaceWith(g(n4, r4.node.left, r4.node.right)) : r4.node.operator = "=", [r4.get("left"), r4.get("right").get("left")];
        }
        if (e5.parentPath.isUpdateExpression()) {
          const t6 = e5.parentPath, r4 = e5.scope.generateDeclaredUidIdentifier("tmp"), n4 = e5.node.computed ? e5.scope.generateDeclaredUidIdentifier("prop") : null, s4 = [l("=", r4, v(e5.node.object, n4 ? l("=", n4, e5.node.property) : e5.node.property, e5.node.computed)), l("=", v(e5.node.object, n4 ? h(n4.name) : e5.node.property, e5.node.computed), c(e5.parentPath.node.operator[0], h(r4.name), S(1)))];
          return e5.parentPath.node.prefix || s4.push(h(r4.name)), t6.replaceWith(P(s4)), [t6.get("expressions.0.right"), t6.get("expressions.1.left")];
        }
        return [e5];
        function t5(e6, t6, r4) {
          return "=" === e6 ? l("=", t6, r4) : c(e6, t6, r4);
        }
      }(t4)), []).forEach((e4) => {
        const t4 = e4.node.computed ? "" : e4.get("property").node.name, r4 = e4.parentPath, n4 = r4.isAssignmentExpression({ left: e4.node }), s4 = r4.isCallExpression({ callee: e4.node }), o4 = r4.isTaggedTemplateExpression({ tag: e4.node }), c2 = function(e5, t5, r5) {
          return M(e5, `superprop_${t5 ? "set" : "get"}:${r5 || ""}`, () => {
            const n5 = [];
            let s5;
            if (r5) s5 = v(O(), h(r5));
            else {
              const t6 = e5.scope.generateUidIdentifier("prop");
              n5.unshift(t6), s5 = v(O(), h(t6.name), true);
            }
            if (t5) {
              const t6 = e5.scope.generateUidIdentifier("value");
              n5.push(t6), s5 = l("=", s5, h(t6.name));
            }
            return a2(n5, s5);
          });
        }(i3, n4, t4), d2 = [];
        if (e4.node.computed && d2.push(e4.get("property").node), n4) {
          const e5 = r4.node.right;
          d2.push(e5);
        }
        const f3 = p(h(c2), d2);
        s4 ? (r4.unshiftContainer("arguments", I()), e4.replaceWith(v(f3, h("call"))), u2.push(r4.get("arguments.0"))) : n4 ? r4.replaceWith(f3) : o4 ? (e4.replaceWith(p(v(f3, h("bind"), false), [I()])), u2.push(e4.get("arguments.0"))) : e4.replaceWith(f3);
      });
    }
    let D2;
    return (u2.length > 0 || !r3) && (D2 = function(e4, t4) {
      return M(e4, "this", (r4) => {
        if (!t4 || !j(e4)) return I();
        e4.traverse(L, { supers: /* @__PURE__ */ new WeakSet(), thisBinding: r4 });
      });
    }(i3, o3), (r3 || o3 && j(i3)) && (u2.forEach((e4) => {
      const t4 = e4.isJSX() ? y(D2) : h(D2);
      t4.loc = e4.node.loc, e4.replaceWith(t4);
    }), r3 || (D2 = null))), { thisBinding: D2, fnPath: e3 };
  }
  function j(e3) {
    return e3.isClassMethod() && !!e3.parentPath.parentPath.node.superClass;
  }
  const L = (0, o2.merge)([{ CallExpression(e3, t3) {
    let { supers: r3, thisBinding: n3 } = t3;
    e3.get("callee").isSuper() && (r3.has(e3.node) || (r3.add(e3.node), e3.replaceWithMultiple([e3.node, l("=", h(n3), h("this"))])));
  } }, s2.default]);
  function M(e3, t3, r3) {
    const n3 = "binding:" + t3;
    let s3 = e3.getData(n3);
    if (!s3) {
      const i3 = e3.scope.generateUidIdentifier(t3);
      s3 = i3.name, e3.setData(n3, s3), e3.scope.push({ id: i3, init: r3(s3) });
    }
    return s3;
  }
  const B = (0, o2.merge)([{ ThisExpression(e3, t3) {
    let { thisPaths: r3 } = t3;
    r3.push(e3);
  }, JSXIdentifier(e3, t3) {
    let { thisPaths: r3 } = t3;
    "this" === e3.node.name && (e3.parentPath.isJSXMemberExpression({ object: e3.node }) || e3.parentPath.isJSXOpeningElement({ name: e3.node })) && r3.push(e3);
  }, CallExpression(e3, t3) {
    let { superCalls: r3 } = t3;
    e3.get("callee").isSuper() && r3.push(e3);
  }, MemberExpression(e3, t3) {
    let { superProps: r3 } = t3;
    e3.get("object").isSuper() && r3.push(e3);
  }, Identifier(e3, t3) {
    let { argumentsPaths: r3 } = t3;
    if (!e3.isReferencedIdentifier({ name: "arguments" })) return;
    let n3 = e3.scope;
    do {
      if (n3.hasOwnBinding("arguments")) return void n3.rename("arguments");
      if (n3.path.isFunction() && !n3.path.isArrowFunctionExpression()) break;
    } while (n3 = n3.parent);
    r3.push(e3);
  }, MetaProperty(e3, t3) {
    let { newTargetPaths: r3 } = t3;
    e3.get("meta").isIdentifier({ name: "new" }) && e3.get("property").isIdentifier({ name: "target" }) && r3.push(e3);
  } }, s2.default]);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.statements = t2.statement = t2.smart = t2.program = t2.expression = void 0;
  var n2 = r2(0);
  const { assertExpressionStatement: s2 } = n2;
  function i2(e3) {
    return { code: (e4) => `/* @babel/template */;
${e4}`, validate: () => {
    }, unwrap: (t3) => e3(t3.program.body.slice(1)) };
  }
  const o2 = i2((e3) => e3.length > 1 ? e3 : e3[0]);
  t2.smart = o2;
  const a2 = i2((e3) => e3);
  t2.statements = a2;
  const l = i2((e3) => {
    if (0 === e3.length) throw new Error("Found nothing to return.");
    if (e3.length > 1) throw new Error("Found multiple statements but wanted one");
    return e3[0];
  });
  t2.statement = l;
  const c = { code: (e3) => `(
${e3}
)`, validate: (e3) => {
    if (e3.program.body.length > 1) throw new Error("Found multiple statements but wanted one");
    if (0 === c.unwrap(e3).start) throw new Error("Parse result included parens.");
  }, unwrap: (e3) => {
    let { program: t3 } = e3;
    const [r3] = t3.body;
    return s2(r3), r3.expression;
  } };
  t2.expression = c, t2.program = { code: (e3) => e3, validate: () => {
  }, unwrap: (e3) => e3.program };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, r3) {
    const l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap(), u = r3 || (0, n2.validate)(null);
    return Object.assign(function(r4) {
      for (var o3 = arguments.length, c2 = new Array(o3 > 1 ? o3 - 1 : 0), p = 1; p < o3; p++) c2[p - 1] = arguments[p];
      if ("string" == typeof r4) {
        if (c2.length > 1) throw new Error("Unexpected extra params.");
        return a2((0, s2.default)(t3, r4, (0, n2.merge)(u, (0, n2.validate)(c2[0]))));
      }
      if (Array.isArray(r4)) {
        let e4 = l.get(r4);
        return e4 || (e4 = (0, i2.default)(t3, r4, u), l.set(r4, e4)), a2(e4(c2));
      }
      if ("object" == typeof r4 && r4) {
        if (c2.length > 0) throw new Error("Unexpected extra params.");
        return e3(t3, (0, n2.merge)(u, (0, n2.validate)(r4)));
      }
      throw new Error("Unexpected template param " + typeof r4);
    }, { ast: function(e4) {
      for (var r4 = arguments.length, a3 = new Array(r4 > 1 ? r4 - 1 : 0), l2 = 1; l2 < r4; l2++) a3[l2 - 1] = arguments[l2];
      if ("string" == typeof e4) {
        if (a3.length > 1) throw new Error("Unexpected extra params.");
        return (0, s2.default)(t3, e4, (0, n2.merge)((0, n2.merge)(u, (0, n2.validate)(a3[0])), o2))();
      }
      if (Array.isArray(e4)) {
        let r5 = c.get(e4);
        return r5 || (r5 = (0, i2.default)(t3, e4, (0, n2.merge)(u, o2)), c.set(e4, r5)), r5(a3)();
      }
      throw new Error("Unexpected template param " + typeof e4);
    } });
  };
  var n2 = r2(120), s2 = r2(434), i2 = r2(435);
  const o2 = (0, n2.validate)({ placeholderPattern: false });
  function a2(e3) {
    let t3 = "";
    try {
      throw new Error();
    } catch (e4) {
      e4.stack && (t3 = e4.stack.split("\n").slice(3).join("\n"));
    }
    return (r3) => {
      try {
        return e3(r3);
      } catch (e4) {
        throw e4.stack += `
    =============
${t3}`, e4;
      }
    };
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    let o2;
    return t3 = e3.code(t3), (a2) => {
      const l = (0, n2.normalizeReplacements)(a2);
      return o2 || (o2 = (0, s2.default)(e3, t3, r3)), e3.unwrap((0, i2.default)(o2, l));
    };
  };
  var n2 = r2(120), s2 = r2(225), i2 = r2(226);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    const { metadata: o2, names: a2 } = function(e4, t4, r4) {
      let n3 = "BABEL_TPL$";
      const i3 = t4.join("");
      do {
        n3 = "$$" + n3;
      } while (i3.includes(n3));
      const { names: o3, code: a3 } = function(e5, t5) {
        const r5 = [];
        let n4 = e5[0];
        for (let s3 = 1; s3 < e5.length; s3++) {
          const i4 = `${t5}${s3 - 1}`;
          r5.push(i4), n4 += i4 + e5[s3];
        }
        return { names: r5, code: n4 };
      }(t4, n3);
      return { metadata: (0, s2.default)(e4, e4.code(a3), { parser: r4.parser, placeholderWhitelist: new Set(o3.concat(r4.placeholderWhitelist ? Array.from(r4.placeholderWhitelist) : [])), placeholderPattern: r4.placeholderPattern, preserveComments: r4.preserveComments, syntacticPlaceholders: r4.syntacticPlaceholders }), names: o3 };
    }(e3, t3, r3);
    return (t4) => {
      const r4 = {};
      return t4.forEach((e4, t5) => {
        r4[a2[t5]] = e4;
      }), (t5) => {
        const s3 = (0, n2.normalizeReplacements)(t5);
        return s3 && Object.keys(s3).forEach((e4) => {
          if (Object.prototype.hasOwnProperty.call(r4, e4)) throw new Error("Unexpected replacement overlap.");
        }), e3.unwrap((0, i2.default)(o2, s3 ? Object.assign(s3, r4) : r4));
      };
    };
  };
  var n2 = r2(120), s2 = r2(225), i2 = r2(226);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._guessExecutionStatusRelativeTo = function(e3) {
    return b(this, e3, /* @__PURE__ */ new Map());
  }, t2._resolve = function(e3, t3) {
    if (!(t3 && t3.indexOf(this) >= 0)) if ((t3 = t3 || []).push(this), this.isVariableDeclarator()) {
      if (this.get("id").isIdentifier()) return this.get("init").resolve(e3, t3);
    } else if (this.isReferencedIdentifier()) {
      const r3 = this.scope.getBinding(this.node.name);
      if (!r3) return;
      if (!r3.constant) return;
      if ("module" === r3.kind) return;
      if (r3.path !== this) {
        const n3 = r3.path.resolve(e3, t3);
        if (this.find((e4) => e4.node === n3.node)) return;
        return n3;
      }
    } else {
      if (this.isTypeCastExpression()) return this.get("expression").resolve(e3, t3);
      if (e3 && this.isMemberExpression()) {
        const r3 = this.toComputedKey();
        if (!c(r3)) return;
        const n3 = r3.value, s3 = this.get("object").resolve(e3, t3);
        if (s3.isObjectExpression()) {
          const r4 = s3.get("properties");
          for (const s4 of r4) {
            if (!s4.isProperty()) continue;
            const r5 = s4.get("key");
            let i3 = s4.isnt("computed") && r5.isIdentifier({ name: n3 });
            if (i3 = i3 || r5.isLiteral({ value: n3 }), i3) return s4.get("value").resolve(e3, t3);
          }
        } else if (s3.isArrayExpression() && !isNaN(+n3)) {
          const r4 = s3.get("elements")[n3];
          if (r4) return r4.resolve(e3, t3);
        }
      }
    }
  }, t2.canHaveVariableDeclarationOrExpression = function() {
    return ("init" === this.key || "left" === this.key) && this.parentPath.isFor();
  }, t2.canSwapBetweenExpressionAndStatement = function(e3) {
    return !("body" !== this.key || !this.parentPath.isArrowFunctionExpression()) && (this.isExpression() ? o2(e3) : !!this.isBlockStatement() && a2(e3));
  }, t2.equals = function(e3, t3) {
    return this.node[e3] === t3;
  }, t2.getSource = function() {
    const e3 = this.node;
    if (e3.end) {
      const t3 = this.hub.getCode();
      if (t3) return t3.slice(e3.start, e3.end);
    }
    return "";
  }, t2.has = f, t2.is = void 0, t2.isCompletionRecord = function(e3) {
    let t3 = this, r3 = true;
    do {
      const { type: n3, container: s3 } = t3;
      if (!r3 && (t3.isFunction() || "StaticBlock" === n3)) return !!e3;
      if (r3 = false, Array.isArray(s3) && t3.key !== s3.length - 1) return false;
    } while ((t3 = t3.parentPath) && !t3.isProgram() && !t3.isDoExpression());
    return true;
  }, t2.isConstantExpression = function() {
    if (this.isIdentifier()) {
      const e3 = this.scope.getBinding(this.node.name);
      return !!e3 && e3.constant;
    }
    if (this.isLiteral()) return !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every((e3) => e3.isConstantExpression()));
    if (this.isUnaryExpression()) return "void" === this.node.operator && this.get("argument").isConstantExpression();
    if (this.isBinaryExpression()) {
      const { operator: e3 } = this.node;
      return "in" !== e3 && "instanceof" !== e3 && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    return false;
  }, t2.isInStrictMode = function() {
    return !!(this.isProgram() ? this : this.parentPath).find((e3) => {
      if (e3.isProgram({ sourceType: "module" })) return true;
      if (e3.isClass()) return true;
      if (e3.isArrowFunctionExpression() && !e3.get("body").isBlockStatement()) return false;
      let t3;
      if (e3.isFunction()) t3 = e3.node.body;
      else {
        if (!e3.isProgram()) return false;
        t3 = e3.node;
      }
      for (const e4 of t3.directives) if ("use strict" === e4.value.value) return true;
    });
  }, t2.isNodeType = function(e3) {
    return p(this.type, e3);
  }, t2.isStatementOrBlock = function() {
    return !this.parentPath.isLabeledStatement() && !o2(this.container) && s2.includes(this.key);
  }, t2.isStatic = function() {
    return this.scope.isStatic(this.node);
  }, t2.isnt = function(e3) {
    return !this.has(e3);
  }, t2.matchesPattern = function(e3, t3) {
    return d(this.node, e3, t3);
  }, t2.referencesImport = function(e3, t3) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === t3 || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? u(this.node.property, { value: t3 }) : this.node.property.name === t3)) {
        const t4 = this.get("object");
        return t4.isReferencedIdentifier() && t4.referencesImport(e3, "*");
      }
      return false;
    }
    const r3 = this.scope.getBinding(this.node.name);
    if (!r3 || "module" !== r3.kind) return false;
    const n3 = r3.path, s3 = n3.parentPath;
    return !!s3.isImportDeclaration() && (s3.node.source.value === e3 && (!t3 || (!(!n3.isImportDefaultSpecifier() || "default" !== t3) || (!(!n3.isImportNamespaceSpecifier() || "*" !== t3) || !(!n3.isImportSpecifier() || !l(n3.node.imported, { name: t3 }))))));
  }, t2.resolve = function(e3, t3) {
    return this._resolve(e3, t3) || this;
  }, t2.willIMaybeExecuteBefore = function(e3) {
    return "after" !== this._guessExecutionStatusRelativeTo(e3);
  };
  var n2 = r2(0);
  const { STATEMENT_OR_BLOCK_KEYS: s2, VISITOR_KEYS: i2, isBlockStatement: o2, isExpression: a2, isIdentifier: l, isLiteral: c, isStringLiteral: u, isType: p, matchesPattern: d } = n2;
  function f(e3) {
    const t3 = this.node && this.node[e3];
    return t3 && Array.isArray(t3) ? !!t3.length : !!t3;
  }
  function h(e3) {
    return e3.isProgram() ? e3 : (e3.parentPath.scope.getFunctionParent() || e3.parentPath.scope.getProgramParent()).path;
  }
  function m(e3, t3) {
    switch (e3) {
      case "LogicalExpression":
      case "AssignmentPattern":
        return "right" === t3;
      case "ConditionalExpression":
      case "IfStatement":
        return "consequent" === t3 || "alternate" === t3;
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return "body" === t3;
      case "ForStatement":
        return "body" === t3 || "update" === t3;
      case "SwitchStatement":
        return "cases" === t3;
      case "TryStatement":
        return "handler" === t3;
      case "OptionalMemberExpression":
        return "property" === t3;
      case "OptionalCallExpression":
        return "arguments" === t3;
      default:
        return false;
    }
  }
  function y(e3, t3) {
    for (let r3 = 0; r3 < t3; r3++) {
      const t4 = e3[r3];
      if (m(t4.parent.type, t4.parentKey)) return true;
    }
    return false;
  }
  t2.is = f;
  const g = Symbol();
  function b(e3, t3, r3) {
    const n3 = { this: h(e3), target: h(t3) };
    if (n3.target.node !== n3.this.node) return function(e4, t4, r4) {
      let n4, s4 = r4.get(e4.node);
      if (s4) {
        if (n4 = s4.get(t4.node)) return n4 === g ? "unknown" : n4;
      } else r4.set(e4.node, s4 = /* @__PURE__ */ new Map());
      s4.set(t4.node, g);
      const i3 = function(e5, t5, r5) {
        if (!t5.isFunctionDeclaration()) return "before" === b(e5, t5, r5) ? "before" : "unknown";
        if (t5.parentPath.isExportDeclaration()) return "unknown";
        const n5 = t5.scope.getBinding(t5.node.id.name);
        if (!n5.references) return "before";
        const s5 = n5.referencePaths;
        let i4;
        for (const n6 of s5) {
          if (n6.find((e6) => e6.node === t5.node)) continue;
          if ("callee" !== n6.key || !n6.parentPath.isCallExpression()) return "unknown";
          const s6 = b(e5, n6, r5);
          if (i4 && i4 !== s6) return "unknown";
          i4 = s6;
        }
        return i4;
      }(e4, t4, r4);
      return s4.set(t4.node, i3), i3;
    }(e3, n3.target, r3);
    const s3 = { target: t3.getAncestry(), this: e3.getAncestry() };
    if (s3.target.indexOf(e3) >= 0) return "after";
    if (s3.this.indexOf(t3) >= 0) return "before";
    let o3;
    const a3 = { target: 0, this: 0 };
    for (; !o3 && a3.this < s3.this.length; ) {
      const e4 = s3.this[a3.this];
      a3.target = s3.target.indexOf(e4), a3.target >= 0 ? o3 = e4 : a3.this++;
    }
    if (!o3) throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (y(s3.this, a3.this - 1) || y(s3.target, a3.target - 1)) return "unknown";
    const l2 = { this: s3.this[a3.this - 1], target: s3.target[a3.target - 1] };
    if (l2.target.listKey && l2.this.listKey && l2.target.container === l2.this.container) return l2.target.key > l2.this.key ? "before" : "after";
    const c2 = i2[o3.type], u2 = c2.indexOf(l2.this.parentKey);
    return c2.indexOf(l2.target.parentKey) > u2 ? "before" : "after";
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._call = function(e3) {
    if (!e3) return false;
    for (const t3 of e3) {
      if (!t3) continue;
      const e4 = this.node;
      if (!e4) return true;
      const r3 = t3.call(this.state, this, this.state);
      if (r3 && "object" == typeof r3 && "function" == typeof r3.then) throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (r3) throw new Error(`Unexpected return value from visitor method ${t3}`);
      if (this.node !== e4) return true;
      if (this._traverseFlags > 0) return true;
    }
    return false;
  }, t2._getQueueContexts = function() {
    let e3 = this, t3 = this.contexts;
    for (; !t3.length && (e3 = e3.parentPath, e3); ) t3 = e3.contexts;
    return t3;
  }, t2._resyncKey = function() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let e3 = 0; e3 < this.container.length; e3++) if (this.container[e3] === this.node) return void this.setKey(e3);
      } else for (const e3 of Object.keys(this.container)) if (this.container[e3] === this.node) return void this.setKey(e3);
      this.key = null;
    }
  }, t2._resyncList = function() {
    if (!this.parent || !this.inList) return;
    const e3 = this.parent[this.listKey];
    this.container !== e3 && (this.container = e3 || null);
  }, t2._resyncParent = function() {
    this.parentPath && (this.parent = this.parentPath.node);
  }, t2._resyncRemoved = function() {
    null != this.key && this.container && this.container[this.key] === this.node || this._markRemoved();
  }, t2.call = function(e3) {
    const t3 = this.opts;
    return this.debug(e3), !(!this.node || !this._call(t3[e3])) || !!this.node && this._call(null == (r3 = t3[this.node.type]) ? void 0 : r3[e3]);
    var r3;
  }, t2.isBlacklisted = t2.isDenylisted = function() {
    var e3;
    const t3 = null != (e3 = this.opts.denylist) ? e3 : this.opts.blacklist;
    return t3 && t3.indexOf(this.node.type) > -1;
  }, t2.popContext = function() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }, t2.pushContext = function(e3) {
    this.contexts.push(e3), this.setContext(e3);
  }, t2.requeue = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this;
    if (e3.removed) return;
    const t3 = this.contexts;
    for (const r3 of t3) r3.maybeQueue(e3);
  }, t2.resync = function() {
    this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
  }, t2.setContext = function(e3) {
    return null != this.skipKeys && (this.skipKeys = {}), this._traverseFlags = 0, e3 && (this.context = e3, this.state = e3.state, this.opts = e3.opts), this.setScope(), this;
  }, t2.setKey = function(e3) {
    var t3;
    this.key = e3, this.node = this.container[this.key], this.type = null == (t3 = this.node) ? void 0 : t3.type;
  }, t2.setScope = function() {
    var e3, t3;
    if (null != (e3 = this.opts) && e3.noScope) return;
    let r3, n3 = this.parentPath;
    for ((("key" === this.key || "decorators" === this.listKey) && n3.isMethod() || "discriminant" === this.key && n3.isSwitchStatement()) && (n3 = n3.parentPath); n3 && !r3; ) {
      var s3;
      if (null != (s3 = n3.opts) && s3.noScope) return;
      r3 = n3.scope, n3 = n3.parentPath;
    }
    this.scope = this.getScope(r3), null == (t3 = this.scope) || t3.init();
  }, t2.setup = function(e3, t3, r3, n3) {
    this.listKey = r3, this.container = t3, this.parentPath = e3 || this.parentPath, this.setKey(n3);
  }, t2.skip = function() {
    this.shouldSkip = true;
  }, t2.skipKey = function(e3) {
    null == this.skipKeys && (this.skipKeys = {}), this.skipKeys[e3] = true;
  }, t2.stop = function() {
    this._traverseFlags |= s2.SHOULD_SKIP | s2.SHOULD_STOP;
  }, t2.visit = function() {
    var e3, t3;
    if (!this.node) return false;
    if (this.isDenylisted()) return false;
    if (null != (e3 = (t3 = this.opts).shouldSkip) && e3.call(t3, this)) return false;
    const r3 = this.context;
    return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (i2(this, r3), this.debug("Recursing into..."), this.shouldStop = (0, n2.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), i2(this, r3), this.call("exit"), this.shouldStop);
  };
  var n2 = r2(100), s2 = r2(28);
  function i2(e3, t3) {
    e3.context !== t3 && (e3.context = t3, e3.state = t3.state, e3.opts = t3.opts);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._assertUnremoved = function() {
    if (this.removed) throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }, t2._callRemovalHooks = function() {
    if (this.parentPath) {
      for (const e3 of n2.hooks) if (e3(this, this.parentPath)) return true;
    }
  }, t2._markRemoved = function() {
    this._traverseFlags |= i2.SHOULD_SKIP | i2.REMOVED, this.parent && (0, s2.getCachedPaths)(this.hub, this.parent).delete(this.node), this.node = null;
  }, t2._remove = function() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
  }, t2._removeFromScope = function() {
    const e3 = a2(this.node, false, false, true);
    Object.keys(e3).forEach((e4) => this.scope.removeBinding(e4));
  }, t2.remove = function() {
    var e3;
    this._assertUnremoved(), this.resync(), null != (e3 = this.opts) && e3.noScope || this._removeFromScope(), this._callRemovalHooks() || (this.shareCommentsWithSiblings(), this._remove()), this._markRemoved();
  };
  var n2 = r2(439), s2 = r2(35), i2 = r2(28), o2 = r2(0);
  const { getBindingIdentifiers: a2 } = o2;
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.hooks = void 0, t2.hooks = [function(e3, t3) {
    if ("test" === e3.key && (t3.isWhile() || t3.isSwitchCase()) || "declaration" === e3.key && t3.isExportDeclaration() || "body" === e3.key && t3.isLabeledStatement() || "declarations" === e3.listKey && t3.isVariableDeclaration() && 1 === t3.node.declarations.length || "expression" === e3.key && t3.isExpressionStatement()) return t3.remove(), true;
  }, function(e3, t3) {
    if (t3.isSequenceExpression() && 1 === t3.node.expressions.length) return t3.replaceWith(t3.node.expressions[0]), true;
  }, function(e3, t3) {
    if (t3.isBinary()) return "left" === e3.key ? t3.replaceWith(t3.node.right) : t3.replaceWith(t3.node.left), true;
  }, function(e3, t3) {
    if (t3.isIfStatement() && "consequent" === e3.key || "body" === e3.key && (t3.isLoop() || t3.isArrowFunctionExpression())) return e3.replaceWith({ type: "BlockStatement", body: [] }), true;
  }];
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._containerInsert = function(e3, t3) {
    this.updateSiblingKeys(e3, t3.length);
    const r3 = [];
    this.container.splice(e3, 0, ...t3);
    for (let s4 = 0; s4 < t3.length; s4++) {
      var n3;
      const t4 = e3 + s4, i3 = this.getSibling(t4);
      r3.push(i3), null != (n3 = this.context) && n3.queue && i3.pushContext(this.context);
    }
    const s3 = this._getQueueContexts();
    for (const e4 of r3) {
      e4.setScope(), e4.debug("Inserted.");
      for (const t4 of s3) t4.maybeQueue(e4, true);
    }
    return r3;
  }, t2._containerInsertAfter = function(e3) {
    return this._containerInsert(this.key + 1, e3);
  }, t2._containerInsertBefore = function(e3) {
    return this._containerInsert(this.key, e3);
  }, t2._verifyNodeList = function(e3) {
    if (!e3) return [];
    Array.isArray(e3) || (e3 = [e3]);
    for (let t3 = 0; t3 < e3.length; t3++) {
      const r3 = e3[t3];
      let n3;
      if (r3 ? "object" != typeof r3 ? n3 = "contains a non-object node" : r3.type ? r3 instanceof i2.default && (n3 = "has a NodePath when it expected a raw object") : n3 = "without a type" : n3 = "has falsy node", n3) {
        const e4 = Array.isArray(r3) ? "array" : typeof r3;
        throw new Error(`Node list ${n3} with the index of ${t3} and type of ${e4}`);
      }
    }
    return e3;
  }, t2.hoist = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.scope;
    return new s2.default(this, e3).run();
  }, t2.insertAfter = function(e3) {
    if (this._assertUnremoved(), this.isSequenceExpression()) return x(this.get("expressions")).insertAfter(e3);
    const t3 = this._verifyNodeList(e3), { parentPath: r3, parent: n3 } = this;
    if (r3.isExpressionStatement() || r3.isLabeledStatement() || y(n3) || r3.isExportDefaultDeclaration() && this.isDeclaration()) return r3.insertAfter(t3.map((e4) => g(e4) ? f(e4) : e4));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !r3.isJSXElement() || r3.isForStatement() && "init" === this.key) {
      if (this.node) {
        const e4 = this.node;
        let { scope: n4 } = this;
        if (n4.path.isPattern()) return l(e4), this.replaceWith(p(a2([], e4), [])), this.get("callee.body").insertAfter(t3), [this];
        if (T(this)) t3.unshift(e4);
        else if (m(e4) && E(e4.callee)) t3.unshift(e4), t3.push(S());
        else if (function(e5, t4) {
          if (!h(e5) || !b(e5.left)) return false;
          const r4 = t4.getBlockParent();
          return r4.hasOwnBinding(e5.left.name) && r4.getOwnBinding(e5.left.name).constantViolations.length <= 1;
        }(e4, n4)) t3.unshift(e4), t3.push(d(e4.left));
        else if (n4.isPure(e4, true)) t3.push(e4);
        else {
          r3.isMethod({ computed: true, key: e4 }) && (n4 = n4.parent);
          const s3 = n4.generateDeclaredUidIdentifier();
          t3.unshift(f(c("=", d(s3), e4))), t3.push(f(d(s3)));
        }
      }
      return this.replaceExpressionWithStatements(t3);
    }
    if (Array.isArray(this.container)) return this._containerInsertAfter(t3);
    if (this.isStatementOrBlock()) {
      const e4 = this.node, r4 = e4 && (!this.isExpressionStatement() || null != e4.expression);
      return this.replaceWith(u(r4 ? [e4] : [])), this.pushContainer("body", t3);
    }
    throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }, t2.insertBefore = function(e3) {
    this._assertUnremoved();
    const t3 = this._verifyNodeList(e3), { parentPath: r3, parent: n3 } = this;
    if (r3.isExpressionStatement() || r3.isLabeledStatement() || y(n3) || r3.isExportDefaultDeclaration() && this.isDeclaration()) return r3.insertBefore(t3);
    if (this.isNodeType("Expression") && !this.isJSXElement() || r3.isForStatement() && "init" === this.key) return this.node && t3.push(this.node), this.replaceExpressionWithStatements(t3);
    if (Array.isArray(this.container)) return this._containerInsertBefore(t3);
    if (this.isStatementOrBlock()) {
      const e4 = this.node, r4 = e4 && (!this.isExpressionStatement() || null != e4.expression);
      return this.replaceWith(u(r4 ? [e4] : [])), this.unshiftContainer("body", t3);
    }
    throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }, t2.pushContainer = function(e3, t3) {
    this._assertUnremoved();
    const r3 = this._verifyNodeList(t3), n3 = this.node[e3];
    return i2.default.get({ parentPath: this, parent: this.node, container: n3, listKey: e3, key: n3.length }).setContext(this.context).replaceWithMultiple(r3);
  }, t2.unshiftContainer = function(e3, t3) {
    return this._assertUnremoved(), t3 = this._verifyNodeList(t3), i2.default.get({ parentPath: this, parent: this.node, container: this.node[e3], listKey: e3, key: 0 }).setContext(this.context)._containerInsertBefore(t3);
  }, t2.updateSiblingKeys = function(e3, t3) {
    if (!this.parent) return;
    const r3 = (0, n2.getCachedPaths)(this.hub, this.parent) || [];
    for (const [, n3] of r3) "number" == typeof n3.key && n3.key >= e3 && (n3.key += t3);
  };
  var n2 = r2(35), s2 = r2(441), i2 = r2(28), o2 = r2(0);
  const { arrowFunctionExpression: a2, assertExpression: l, assignmentExpression: c, blockStatement: u, callExpression: p, cloneNode: d, expressionStatement: f, isAssignmentExpression: h, isCallExpression: m, isExportNamedDeclaration: y, isExpression: g, isIdentifier: b, isSequenceExpression: v, isSuper: E, thisExpression: S } = o2, x = (e3) => e3[e3.length - 1];
  function T(e3) {
    return v(e3.parent) && (x(e3.parent.expressions) !== e3.node || T(e3.parentPath));
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(0), s2 = n2;
  const { react: i2 } = n2, { cloneNode: o2, jsxExpressionContainer: a2, variableDeclaration: l, variableDeclarator: c } = s2, u = { ReferencedIdentifier(e3, t3) {
    if (e3.isJSXIdentifier() && i2.isCompatTag(e3.node.name) && !e3.parentPath.isJSXMemberExpression()) return;
    if ("this" === e3.node.name) {
      let r4 = e3.scope;
      do {
        if (r4.path.isFunction() && !r4.path.isArrowFunctionExpression()) break;
      } while (r4 = r4.parent);
      r4 && t3.breakOnScopePaths.push(r4.path);
    }
    const r3 = e3.scope.getBinding(e3.node.name);
    if (r3) {
      for (const n3 of r3.constantViolations) if (n3.scope !== r3.path.scope) return t3.mutableBinding = true, void e3.stop();
      r3 === t3.scope.getBinding(e3.node.name) && (t3.bindings[e3.node.name] = r3);
    }
  } };
  t2.default = class {
    constructor(e3, t3) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = false, this.scopes = [], this.scope = t3, this.path = e3, this.attachAfter = false;
    }
    isCompatibleScope(e3) {
      for (const t3 of Object.keys(this.bindings)) {
        const r3 = this.bindings[t3];
        if (!e3.bindingIdentifierEquals(t3, r3.identifier)) return false;
      }
      return true;
    }
    getCompatibleScopes() {
      let e3 = this.path.scope;
      do {
        if (!this.isCompatibleScope(e3)) break;
        if (this.scopes.push(e3), this.breakOnScopePaths.indexOf(e3.path) >= 0) break;
      } while (e3 = e3.parent);
    }
    getAttachmentPath() {
      let e3 = this._getAttachmentPath();
      if (!e3) return;
      let t3 = e3.scope;
      if (t3.path === e3 && (t3 = e3.scope.parent), t3.path.isProgram() || t3.path.isFunction()) for (const r3 of Object.keys(this.bindings)) {
        if (!t3.hasOwnBinding(r3)) continue;
        const n3 = this.bindings[r3];
        if ("param" !== n3.kind && "params" !== n3.path.parentKey && this.getAttachmentParentForPath(n3.path).key >= e3.key) {
          this.attachAfter = true, e3 = n3.path;
          for (const t4 of n3.constantViolations) this.getAttachmentParentForPath(t4).key > e3.key && (e3 = t4);
        }
      }
      return e3;
    }
    _getAttachmentPath() {
      const e3 = this.scopes.pop();
      if (e3) {
        if (e3.path.isFunction()) {
          if (!this.hasOwnParamBindings(e3)) return this.getNextScopeAttachmentParent();
          {
            if (this.scope === e3) return;
            const t3 = e3.path.get("body").get("body");
            for (let e4 = 0; e4 < t3.length; e4++) if (!t3[e4].node._blockHoist) return t3[e4];
          }
        } else if (e3.path.isProgram()) return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      const e3 = this.scopes.pop();
      if (e3) return this.getAttachmentParentForPath(e3.path);
    }
    getAttachmentParentForPath(e3) {
      do {
        if (!e3.parentPath || Array.isArray(e3.container) && e3.isStatement()) return e3;
      } while (e3 = e3.parentPath);
    }
    hasOwnParamBindings(e3) {
      for (const t3 of Object.keys(this.bindings)) {
        if (!e3.hasOwnBinding(t3)) continue;
        const r3 = this.bindings[t3];
        if ("param" === r3.kind && r3.constant) return true;
      }
      return false;
    }
    run() {
      if (this.path.traverse(u, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      const e3 = this.getAttachmentPath();
      if (!e3) return;
      if (e3.getFunctionParent() === this.path.getFunctionParent()) return;
      let t3 = e3.scope.generateUidIdentifier("ref");
      const r3 = c(t3, this.path.node), n3 = this.attachAfter ? "insertAfter" : "insertBefore", [s3] = e3[n3]([e3.isVariableDeclarator() ? r3 : l("var", [r3])]), i3 = this.path.parentPath;
      return i3.isJSXElement() && this.path.container === i3.node.children && (t3 = a2(t3)), this.path.replaceWith(o2(t3)), e3.isVariableDeclarator() ? s3.get("init") : s3.get("declarations.0.init");
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._getKey = function(e3, t3) {
    const r3 = this.node, s3 = r3[e3];
    return Array.isArray(s3) ? s3.map((i3, o3) => n2.default.get({ listKey: e3, parentPath: this, parent: r3, container: s3, key: o3 }).setContext(t3)) : n2.default.get({ parentPath: this, parent: r3, container: r3, key: e3 }).setContext(t3);
  }, t2._getPattern = function(e3, t3) {
    let r3 = this;
    for (const n3 of e3) r3 = "." === n3 ? r3.parentPath : Array.isArray(r3) ? r3[n3] : r3.get(n3, t3);
    return r3;
  }, t2.get = function(e3) {
    let t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    true === t3 && (t3 = this.context);
    const r3 = e3.split(".");
    return 1 === r3.length ? this._getKey(e3, t3) : this._getPattern(r3, t3);
  }, t2.getAllNextSiblings = function() {
    let e3 = this.key, t3 = this.getSibling(++e3);
    const r3 = [];
    for (; t3.node; ) r3.push(t3), t3 = this.getSibling(++e3);
    return r3;
  }, t2.getAllPrevSiblings = function() {
    let e3 = this.key, t3 = this.getSibling(--e3);
    const r3 = [];
    for (; t3.node; ) r3.push(t3), t3 = this.getSibling(--e3);
    return r3;
  }, t2.getBindingIdentifierPaths = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    const r3 = [this], n3 = /* @__PURE__ */ Object.create(null);
    for (; r3.length; ) {
      const s3 = r3.shift();
      if (!s3) continue;
      if (!s3.node) continue;
      const o3 = i2.keys[s3.node.type];
      if (s3.isIdentifier()) e3 ? (n3[s3.node.name] = n3[s3.node.name] || []).push(s3) : n3[s3.node.name] = s3;
      else if (s3.isExportDeclaration()) {
        const e4 = s3.get("declaration");
        a2(e4) && r3.push(e4);
      } else {
        if (t3) {
          if (s3.isFunctionDeclaration()) {
            r3.push(s3.get("id"));
            continue;
          }
          if (s3.isFunctionExpression()) continue;
        }
        if (o3) for (let e4 = 0; e4 < o3.length; e4++) {
          const t4 = o3[e4], n4 = s3.get(t4);
          Array.isArray(n4) ? r3.push(...n4) : n4.node && r3.push(n4);
        }
      }
    }
    return n3;
  }, t2.getBindingIdentifiers = function(e3) {
    return i2(this.node, e3);
  }, t2.getCompletionRecords = function() {
    return y(this, { canHaveBreak: false, shouldPopulateBreak: false, inCaseClause: false }).map((e3) => e3.path);
  }, t2.getNextSibling = function() {
    return this.getSibling(this.key + 1);
  }, t2.getOpposite = function() {
    return "left" === this.key ? this.getSibling("right") : "right" === this.key ? this.getSibling("left") : null;
  }, t2.getOuterBindingIdentifierPaths = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    return this.getBindingIdentifierPaths(e3, true);
  }, t2.getOuterBindingIdentifiers = function(e3) {
    return o2(this.node, e3);
  }, t2.getPrevSibling = function() {
    return this.getSibling(this.key - 1);
  }, t2.getSibling = function(e3) {
    return n2.default.get({ parentPath: this.parentPath, parent: this.parent, container: this.container, listKey: this.listKey, key: e3 }).setContext(this.context);
  };
  var n2 = r2(28), s2 = r2(0);
  const { getBindingIdentifiers: i2, getOuterBindingIdentifiers: o2, isDeclaration: a2, numericLiteral: l, unaryExpression: c } = s2, u = 0, p = 1;
  function d(e3, t3, r3) {
    return e3 && t3.push(...y(e3, r3)), t3;
  }
  function f(e3) {
    e3.forEach((e4) => {
      e4.type = p;
    });
  }
  function h(e3, t3) {
    e3.forEach((e4) => {
      e4.path.isBreakStatement({ label: null }) && (t3 ? e4.path.replaceWith(c("void", l(0))) : e4.path.remove());
    });
  }
  function m(e3, t3) {
    const r3 = [];
    if (t3.canHaveBreak) {
      let n3 = [];
      for (let s3 = 0; s3 < e3.length; s3++) {
        const i3 = e3[s3], o3 = Object.assign({}, t3, { inCaseClause: false });
        i3.isBlockStatement() && (t3.inCaseClause || t3.shouldPopulateBreak) ? o3.shouldPopulateBreak = true : o3.shouldPopulateBreak = false;
        const a3 = y(i3, o3);
        if (a3.length > 0 && a3.every((e4) => e4.type === p)) {
          n3.length > 0 && a3.every((e4) => e4.path.isBreakStatement({ label: null })) ? (f(n3), r3.push(...n3), n3.some((e4) => e4.path.isDeclaration()) && (r3.push(...a3), h(a3, true)), h(a3, false)) : (r3.push(...a3), t3.shouldPopulateBreak || h(a3, true));
          break;
        }
        if (s3 === e3.length - 1) r3.push(...a3);
        else {
          n3 = [];
          for (let e4 = 0; e4 < a3.length; e4++) {
            const t4 = a3[e4];
            t4.type === p && r3.push(t4), t4.type === u && n3.push(t4);
          }
        }
      }
    } else if (e3.length) for (let n3 = e3.length - 1; n3 >= 0; n3--) {
      const s3 = y(e3[n3], t3);
      if (s3.length > 1 || 1 === s3.length && !s3[0].path.isVariableDeclaration()) {
        r3.push(...s3);
        break;
      }
    }
    return r3;
  }
  function y(e3, t3) {
    let r3 = [];
    if (e3.isIfStatement()) r3 = d(e3.get("consequent"), r3, t3), r3 = d(e3.get("alternate"), r3, t3);
    else {
      if (e3.isDoExpression() || e3.isFor() || e3.isWhile() || e3.isLabeledStatement()) return d(e3.get("body"), r3, t3);
      if (e3.isProgram() || e3.isBlockStatement()) return m(e3.get("body"), t3);
      if (e3.isFunction()) return y(e3.get("body"), t3);
      if (e3.isTryStatement()) r3 = d(e3.get("block"), r3, t3), r3 = d(e3.get("handler"), r3, t3);
      else {
        if (e3.isCatchClause()) return d(e3.get("body"), r3, t3);
        if (e3.isSwitchStatement()) return function(e4, t4, r4) {
          let n3 = [];
          for (let s3 = 0; s3 < e4.length; s3++) {
            const i3 = y(e4[s3], r4), o3 = [], a3 = [];
            for (const e5 of i3) e5.type === u && o3.push(e5), e5.type === p && a3.push(e5);
            o3.length && (n3 = o3), t4.push(...a3);
          }
          return t4.push(...n3), t4;
        }(e3.get("cases"), r3, t3);
        if (e3.isSwitchCase()) return m(e3.get("consequent"), { canHaveBreak: true, shouldPopulateBreak: false, inCaseClause: true });
        e3.isBreakStatement() ? r3.push(/* @__PURE__ */ function(e4) {
          return { type: p, path: e4 };
        }(e3)) : r3.push(/* @__PURE__ */ function(e4) {
          return { type: u, path: e4 };
        }(e3));
      }
    }
    return r3;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.addComment = function(e3, t3, r3) {
    s2(this.node, e3, t3, r3);
  }, t2.addComments = function(e3, t3) {
    i2(this.node, e3, t3);
  }, t2.shareCommentsWithSiblings = function() {
    if ("string" == typeof this.key) return;
    const e3 = this.node;
    if (!e3) return;
    const t3 = e3.trailingComments, r3 = e3.leadingComments;
    if (!t3 && !r3) return;
    const n3 = this.getSibling(this.key - 1), s3 = this.getSibling(this.key + 1), i3 = Boolean(n3.node), a2 = Boolean(s3.node);
    i3 && (r3 && n3.addComments("trailing", o2(r3, n3.node.trailingComments)), t3 && !a2 && n3.addComments("trailing", t3)), a2 && (t3 && s3.addComments("leading", o2(t3, s3.node.leadingComments)), r3 && !i3 && s3.addComments("leading", r3));
  };
  var n2 = r2(0);
  const { addComment: s2, addComments: i2 } = n2;
  function o2(e3, t3) {
    if (null == t3 || !t3.length) return e3;
    const r3 = new Set(t3);
    return e3.filter((e4) => !r3.has(e4));
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = class {
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(e3, t3) {
      return new (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : TypeError)(t3);
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(37), s2 = r2(446);
  const i2 = Object.assign({ __proto__: null }, s2.default);
  t2.default = i2;
  const o2 = (e3) => (t3) => ({ minVersion: e3, ast: () => n2.default.program.ast(t3) });
  i2.AwaitValue = o2("7.0.0-beta.0")`
    export default function _AwaitValue(value) {
      this.wrapped = value;
    }
  `, i2.wrapAsyncGenerator = o2("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`, i2.asyncToGenerator = o2("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }
`, i2.classCallCheck = o2("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`, i2.createClass = o2("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
`, i2.defineEnumerableProperties = o2("7.0.0-beta.0")`
    export default function _defineEnumerableProperties(obj, descs) {
      for (var key in descs) {
        var desc = descs[key];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, key, desc);
      }

      // Symbols are not enumerated over by for-in loops. If native
      // Symbols are available, fetch all of the descs object's own
      // symbol properties and define them on our target object too.
      if (Object.getOwnPropertySymbols) {
        var objectSymbols = Object.getOwnPropertySymbols(descs);
        for (var i = 0; i < objectSymbols.length; i++) {
          var sym = objectSymbols[i];
          var desc = descs[sym];
          desc.configurable = desc.enumerable = true;
          if ("value" in desc) desc.writable = true;
          Object.defineProperty(obj, sym, desc);
        }
      }
      return obj;
    }
`, i2.defaults = o2("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`, i2.defineProperty = o2("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  export default function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`, i2.extends = o2("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`, i2.objectSpread = o2("7.0.0-beta.0")`
    import defineProperty from "defineProperty";

    export default function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = (arguments[i] != null) ? Object(arguments[i]) : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
  `, i2.inherits = o2("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    // We can't use defineProperty to set the prototype in a single step because it
    // doesn't work in Chrome <= 36. https://github.com/babel/babel/issues/14056
    // V8 bug: https://bugs.chromium.org/p/v8/issues/detail?id=3334
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`, i2.inheritsLoose = o2("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`, i2.getPrototypeOf = o2("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`, i2.setPrototypeOf = o2("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
    return _setPrototypeOf(o, p);
  }
`, i2.isNativeFunction = o2("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    try {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    } catch (e) {
      // Firefox 31 throws when "toString" is applied to an HTMLElement
      return typeof fn === "function";
    }
  }
`, i2.wrapNativeSuper = o2("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`, i2.instanceof = o2("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`, i2.interopRequireDefault = o2("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`, i2.newArrowCheck = o2("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`, i2.objectDestructuringEmpty = o2("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure " + obj);
  }
`, i2.objectWithoutPropertiesLoose = o2("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`, i2.objectWithoutProperties = o2("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`, i2.assertThisInitialized = o2("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`, i2.possibleConstructorReturn = o2("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return assertThisInitialized(self);
  }
`, i2.createSuper = o2("7.9.0")`
    import getPrototypeOf from "getPrototypeOf";
    import isNativeReflectConstruct from "isNativeReflectConstruct";
    import possibleConstructorReturn from "possibleConstructorReturn";

    export default function _createSuper(Derived) {
      var hasNativeReflectConstruct = isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          // NOTE: This doesn't work if this.__proto__.constructor has been modified.
          var NewTarget = getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return possibleConstructorReturn(this, result);
      }
    }
`, i2.superPropBase = o2("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`, i2.get = o2("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          // STEP 3. If receiver is not present, then set receiver to target.
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
`, i2.set = o2("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new TypeError('failed to set property');
    }

    return value;
  }
`, i2.taggedTemplateLiteral = o2("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`, i2.taggedTemplateLiteralLoose = o2("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`, i2.readOnlyError = o2("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is read-only");
  }
`, i2.writeOnlyError = o2("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is write-only");
  }
`, i2.classNameTDZError = o2("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new ReferenceError("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`, i2.temporalUndefined = o2("7.0.0-beta.0")`
  // This function isn't mean to be called, but to be used as a reference.
  // We can't use a normal object because it isn't hoisted.
  export default function _temporalUndefined() {}
`, i2.tdz = o2("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`, i2.temporalRef = o2("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`, i2.slicedToArray = o2("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`, i2.slicedToArrayLoose = o2("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`, i2.toArray = o2("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`, i2.toConsumableArray = o2("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`, i2.arrayWithoutHoles = o2("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`, i2.arrayWithHoles = o2("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`, i2.maybeArrayLike = o2("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`, i2.iterableToArray = o2("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
`, i2.unsupportedIterableToArray = o2("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`, i2.arrayLikeToArray = o2("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`, i2.nonIterableSpread = o2("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`, i2.nonIterableRest = o2("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`, i2.createForOfIteratorHelper = o2("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`, i2.createForOfIteratorHelperLoose = o2("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length === "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
`, i2.skipFirstGeneratorNext = o2("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`, i2.initializerWarningHelper = o2("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'transform-class-properties is enabled and runs after the decorators transform.'
        );
    }
`, i2.initializerDefineProperty = o2("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`, i2.applyDecoratedDescriptor = o2("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`, i2.classPrivateFieldLooseKey = o2("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`, i2.classPrivateFieldLooseBase = o2("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`, i2.classPrivateFieldGet = o2("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`, i2.classPrivateFieldSet = o2("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`, i2.classPrivateFieldDestructureSet = o2("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`, i2.classExtractFieldDescriptor = o2("7.13.10")`
  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
  }
`, i2.classStaticPrivateFieldSpecGet = o2("7.0.2")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`, i2.classStaticPrivateFieldSpecSet = o2("7.0.2")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`, i2.classStaticPrivateMethodGet = o2("7.3.2")`
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    return method;
  }
`, i2.classStaticPrivateMethodSet = o2("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`, i2.classApplyDescriptorGet = o2("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`, i2.classApplyDescriptorSet = o2("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
`, i2.classApplyDescriptorDestructureSet = o2("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }
`, i2.classStaticPrivateFieldDestructureSet = o2("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`, i2.classCheckPrivateStaticAccess = o2("7.13.10")`
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
  }
`, i2.classCheckPrivateStaticFieldDescriptor = o2("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
  }
`, i2.decorate = o2("7.1.5")`
  import toArray from "toArray";
  import toPropertyKey from "toPropertyKey";

  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () => any,
        set?: (v: any) => void,
        configurable: boolean,
        enumerable: boolean,
      };

  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };

  type Placement = "static" | "prototype" | "own";
  type Key = string | symbol; // PrivateName is not supported yet.

  type ElementDescriptor =
    | {
        kind: "method",
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: "field",
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () => any,
      };

  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
  };

  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: "Descriptor",
    kind: "class",
    elements: ElementDescriptor[],
  };

  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;

  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: "method",
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: "field",
        value: () => any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };

  declare function ClassFactory<C>(initialize: (instance: C) => void): {
    F: Class<C>,
    d: ElementDefinition[]
  }

  */

  /*::
  // Various combinations with/without extras and with one or many finishers

  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };

  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };

  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };

  */

  /*::

  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };

  */

  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
    mixins /*: ?Array<Function> */,
  ) /*: Class<*> */ {
    var api = _getDecoratorsApi();
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],

      // InitializeInstanceElements
      initializeInstanceElements: function(
        /*::<C>*/ O /*: C */,
        elements /*: ElementDescriptor[] */,
      ) {
        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },

      // InitializeClassElements
      initializeClassElements: function(
        /*::<C>*/ F /*: Class<C> */,
        elements /*: ElementDescriptor[] */,
      ) {
        var proto = F.prototype;

        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            var placement = element.placement;
            if (
              element.kind === kind &&
              (placement === "static" || placement === "prototype")
            ) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      // DefineClassElement
      defineClassElement: function(
        /*::<C>*/ receiver /*: C | Class<C> */,
        element /*: ElementDescriptor */,
      ) {
        var descriptor /*: PropertyDescriptor */ = element.descriptor;
        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver),
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      // DecorateClass
      decorateClass: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var newElements /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];
        var placements /*: Placements */ = {
          static: [],
          prototype: [],
          own: [],
        };

        elements.forEach(function(element /*: ElementDescriptor */) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element /*: ElementDescriptor */) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
            element,
            placements,
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return { elements: newElements, finishers: finishers };
        }

        var result /*: ElementsFinishers */ = this.decorateConstructor(
          newElements,
          decorators,
        );
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      // AddElementPlacement
      addElementPlacement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
        silent /*: boolean */,
      ) {
        var keys = placements[element.placement];
        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }
        keys.push(element.key);
      },

      // DecorateElement
      decorateElement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
      ) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i >= 0;
          i--
        ) {
          // (inlined) RemoveElementPlacement
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
            element,
          );
          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
              elementObject,
          );

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras /*: ElementDescriptor[] | void */ =
            elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }
            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      // DecorateConstructor
      decorateConstructor: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var finishers /*: ClassFinisher[] */ = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
            (0, decorators[i])(obj) /*: ClassObject */ || obj,
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &&
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    "Duplicated element (" + elements[j].key + ")",
                  );
                }
              }
            }
          }
        }

        return { elements: elements, finishers: finishers };
      },

      // FromElementDescriptor
      fromElementDescriptor: function(
        element /*: ElementDescriptor */,
      ) /*: ElementObject */ {
        var obj /*: ElementObject */ = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor,
        };

        var desc = {
          value: "Descriptor",
          configurable: true,
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        if (element.kind === "field") obj.initializer = element.initializer;

        return obj;
      },

      // ToElementDescriptors
      toElementDescriptors: function(
        elementObjects /*: ElementObject[] */,
      ) /*: ElementDescriptor[] */ {
        if (elementObjects === undefined) return;
        return toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },

      // ToElementDescriptor
      toElementDescriptor: function(
        elementObject /*: ElementObject */,
      ) /*: ElementDescriptor */ {
        var kind = String(elementObject.kind);
        if (kind !== "method" && kind !== "field") {
          throw new TypeError(
            'An element descriptor\\'s .kind property must be either "method" or' +
              ' "field", but a decorator created an element descriptor with' +
              ' .kind "' +
              kind +
              '"',
          );
        }

        var key = toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);
        if (
          placement !== "static" &&
          placement !== "prototype" &&
          placement !== "own"
        ) {
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"',
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(
            descriptor,
            "get",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "set",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "value",
            "The property descriptor of a field descriptor",
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          "finisher",
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: "Descriptor", configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class") {
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"',
          );
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class<*> */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static
        ? "static"
        : def.kind === "field"
        ? "own"
        : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }

`, i2.classPrivateMethodGet = o2("7.1.6")`
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
  }
`, i2.checkPrivateRedeclaration = o2("7.14.1")`
  export default function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
`, i2.classPrivateFieldInitSpec = o2("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
    checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
`, i2.classPrivateMethodInitSpec = o2("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateMethodInitSpec(obj, privateSet) {
    checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }
`, i2.classPrivateMethodSet = o2("7.1.6")`
    export default function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }
  `, i2.identity = o2("7.17.0")`
  export default function _identity(x) {
    return x;
  }
`, i2.nullishReceiverError = o2("7.22.6")`
  export default function _nullishReceiverError(r) {
    throw new TypeError("Cannot set property of null or undefined.");
  }
`;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(37);
  function s2(e3, t3) {
    return Object.freeze({ minVersion: e3, ast: () => n2.default.program.ast(t3, { preserveComments: true }) });
  }
  t2.default = Object.freeze({ AsyncGenerator: s2("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};'), OverloadYield: s2("7.18.14", "export default function _OverloadYield(t,e){this.v=t,this.k=e}"), applyDecs: s2("7.17.8", 'import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&"undefined"!=typeof console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===o?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}export default function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}'), applyDecs2203: s2("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;export default function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}'), applyDecs2203R: s2("7.20.0", 'import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}'), applyDecs2301: s2("7.21.0", 'import checkInRHS from"checkInRHS";import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((function(e,t){return p.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}'), applyDecs2305: s2("7.21.0", 'import checkInRHS from"checkInRHS";import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";export default function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}function c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeError(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName((function(){return g(this)}),n,"get"),set:function(e){t[4](this,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,t){if(e.v)throw new Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(e,t);return t})),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}'), asyncGeneratorDelegate: s2("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}'), asyncIterator: s2("7.15.9", 'export default function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}'), awaitAsyncGenerator: s2("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}'), callSuper: s2("7.23.8", 'import getPrototypeOf from"getPrototypeOf";import isNativeReflectConstruct from"isNativeReflectConstruct";import possibleConstructorReturn from"possibleConstructorReturn";export default function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Reflect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}'), checkInRHS: s2("7.20.5", `export default function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(null!==e?typeof e:"null"));return e}`), construct: s2("7.0.0-beta.0", 'import setPrototypeOf from"setPrototypeOf";import isNativeReflectConstruct from"isNativeReflectConstruct";export default function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}'), defineAccessor: s2("7.20.7", "export default function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}"), dispose: s2("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=(new Error).stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}export default function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}'), importDeferProxy: s2("7.23.0", "export default function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}"), interopRequireWildcard: s2("7.14.0", 'function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}export default function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&Object.prototype.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.default=e,t&&t.set(e,n),n}'), isNativeReflectConstruct: s2("7.9.0", "export default function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}"), iterableToArrayLimit: s2("7.0.0-beta.0", 'export default function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}'), iterableToArrayLimitLoose: s2("7.0.0-beta.0", 'export default function _iterableToArrayLimitLoose(e,r){var t=e&&("undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"]);if(null!=t){var o,l=[];for(t=t.call(e);e.length<r&&!(o=t.next()).done;)l.push(o.value);return l}}'), jsx: s2("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=new Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}'), objectSpread2: s2("7.5.0", 'import defineProperty from"defineProperty";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}export default function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}'), regeneratorRuntime: s2("7.18.0", `export default function _regeneratorRuntime(){"use strict";
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:function(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw new Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}`), setFunctionName: s2("7.23.6", 'export default function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineProperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}'), toPrimitive: s2("7.1.5", 'export default function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}'), toPropertyKey: s2("7.1.5", 'import toPrimitive from"toPrimitive";export default function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:String(i)}'), typeof: s2("7.0.0-beta.0", 'export default function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}'), using: s2("7.22.0", 'export default function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:n,d:r,a:e}),n}'), usingCtx: s2("7.23.9", 'export default function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,n){var e=new Error;return e.name="SuppressedError",e.suppressed=n,e.error=r,e},n={},e=[];function using(r,n){if(null!=n){if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(r)var o=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==o&&(o=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof o)throw new TypeError("Property [Symbol.dispose] is not a function.");e.push({v:n,d:o,a:r})}return n}return{e:n,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o=this.e;function next(){for(;r=e.pop();)try{var r,t=r.d.call(r.v);if(r.a)return Promise.resolve(t).then(next,err)}catch(r){return err(r)}if(o!==n)throw o}function err(e){return o=o!==n?new r(o,e):e,next()}return next()}}}'), wrapRegExp: s2("7.19.0", 'import setPrototypeOf from"setPrototypeOf";import inherits from"inherits";export default function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=new RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)>/g,(function(e,r){var t=o[r];return"$"+(Array.isArray(t)?t.join("$"):t)})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}') });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(25), s2 = r2(0), i2 = r2(448), o2 = r2(250);
  const { numericLiteral: a2, sequenceExpression: l } = s2;
  t2.default = class {
    constructor(e3, t3, r3) {
      this._defaultOpts = { importedSource: null, importedType: "commonjs", importedInterop: "babel", importingInterop: "babel", ensureLiveReference: false, ensureNoContext: false, importPosition: "before" };
      const n3 = e3.find((e4) => e4.isProgram());
      this._programPath = n3, this._programScope = n3.scope, this._hub = n3.hub, this._defaultOpts = this._applyDefaults(t3, r3, true);
    }
    addDefault(e3, t3) {
      return this.addNamed("default", e3, t3);
    }
    addNamed(e3, t3, r3) {
      return n2("string" == typeof e3), this._generateImport(this._applyDefaults(t3, r3), e3);
    }
    addNamespace(e3, t3) {
      return this._generateImport(this._applyDefaults(e3, t3), null);
    }
    addSideEffect(e3, t3) {
      return this._generateImport(this._applyDefaults(e3, t3), void 0);
    }
    _applyDefaults(e3, t3) {
      let r3, s3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      return "string" == typeof e3 ? r3 = Object.assign({}, this._defaultOpts, { importedSource: e3 }, t3) : (n2(!t3, "Unexpected secondary arguments."), r3 = Object.assign({}, this._defaultOpts, e3)), !s3 && t3 && (void 0 !== t3.nameHint && (r3.nameHint = t3.nameHint), void 0 !== t3.blockHoist && (r3.blockHoist = t3.blockHoist)), r3;
    }
    _generateImport(e3, t3) {
      const r3 = "default" === t3, n3 = !!t3 && !r3, s3 = null === t3, { importedSource: c, importedType: u, importedInterop: p, importingInterop: d, ensureLiveReference: f, ensureNoContext: h, nameHint: m, importPosition: y, blockHoist: g } = e3;
      let b = m || t3;
      const v = (0, o2.default)(this._programPath), E = v && "node" === d, S = v && "babel" === d;
      if ("after" === y && !v) throw new Error('"importPosition": "after" is only supported in modules');
      const x = new i2.default(c, this._programScope, this._hub);
      if ("es6" === u) {
        if (!E && !S) throw new Error("Cannot import an ES6 module from CommonJS");
        x.import(), s3 ? x.namespace(m || c) : (r3 || n3) && x.named(b, t3);
      } else {
        if ("commonjs" !== u) throw new Error(`Unexpected interopType "${u}"`);
        if ("babel" === p) if (E) {
          b = "default" !== b ? b : c;
          const e4 = `${c}$es6Default`;
          x.import(), s3 ? x.default(e4).var(b || c).wildcardInterop() : r3 ? f ? x.default(e4).var(b || c).defaultInterop().read("default") : x.default(e4).var(b).defaultInterop().prop(t3) : n3 && x.default(e4).read(t3);
        } else S ? (x.import(), s3 ? x.namespace(b || c) : (r3 || n3) && x.named(b, t3)) : (x.require(), s3 ? x.var(b || c).wildcardInterop() : (r3 || n3) && f ? r3 ? (b = "default" !== b ? b : c, x.var(b).read(t3), x.defaultInterop()) : x.var(c).read(t3) : r3 ? x.var(b).defaultInterop().prop(t3) : n3 && x.var(b).prop(t3));
        else if ("compiled" === p) E ? (x.import(), s3 ? x.default(b || c) : (r3 || n3) && x.default(c).read(b)) : S ? (x.import(), s3 ? x.namespace(b || c) : (r3 || n3) && x.named(b, t3)) : (x.require(), s3 ? x.var(b || c) : (r3 || n3) && (f ? x.var(c).read(b) : x.prop(t3).var(b)));
        else {
          if ("uncompiled" !== p) throw new Error(`Unknown importedInterop "${p}".`);
          if (r3 && f) throw new Error("No live reference for commonjs default");
          E ? (x.import(), s3 ? x.default(b || c) : r3 ? x.default(b) : n3 && x.default(c).read(b)) : S ? (x.import(), s3 ? x.default(b || c) : r3 ? x.default(b) : n3 && x.named(b, t3)) : (x.require(), s3 ? x.var(b || c) : r3 ? x.var(b) : n3 && (f ? x.var(c).read(b) : x.var(b).prop(t3)));
        }
      }
      const { statements: T, resultName: w } = x.done();
      return this._insertStatements(T, y, g), (r3 || n3) && h && "Identifier" !== w.type ? l([a2(0), w]) : w;
    }
    _insertStatements(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "before", r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3;
      const n3 = this._programPath.get("body");
      if ("after" === t3) {
        for (let t4 = n3.length - 1; t4 >= 0; t4--) if (n3[t4].isImportDeclaration()) return void n3[t4].insertAfter(e3);
      } else {
        e3.forEach((e4) => {
          e4._blockHoist = r3;
        });
        const t4 = n3.find((e4) => {
          const t5 = e4.node._blockHoist;
          return Number.isFinite(t5) && t5 < 4;
        });
        if (t4) return void t4.insertBefore(e3);
      }
      this._programPath.unshiftContainer("body", e3);
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(25), s2 = r2(0);
  const { callExpression: i2, cloneNode: o2, expressionStatement: a2, identifier: l, importDeclaration: c, importDefaultSpecifier: u, importNamespaceSpecifier: p, importSpecifier: d, memberExpression: f, stringLiteral: h, variableDeclaration: m, variableDeclarator: y } = s2;
  t2.default = class {
    constructor(e3, t3, r3) {
      this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = t3, this._hub = r3, this._importedSource = e3;
    }
    done() {
      return { statements: this._statements, resultName: this._resultName };
    }
    import() {
      return this._statements.push(c([], h(this._importedSource))), this;
    }
    require() {
      return this._statements.push(a2(i2(l("require"), [h(this._importedSource)]))), this;
    }
    namespace() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "namespace";
      const t3 = this._scope.generateUidIdentifier(e3), r3 = this._statements[this._statements.length - 1];
      return n2("ImportDeclaration" === r3.type), n2(0 === r3.specifiers.length), r3.specifiers = [p(t3)], this._resultName = o2(t3), this;
    }
    default(e3) {
      const t3 = this._scope.generateUidIdentifier(e3), r3 = this._statements[this._statements.length - 1];
      return n2("ImportDeclaration" === r3.type), n2(0 === r3.specifiers.length), r3.specifiers = [u(t3)], this._resultName = o2(t3), this;
    }
    named(e3, t3) {
      if ("default" === t3) return this.default(e3);
      const r3 = this._scope.generateUidIdentifier(e3), s3 = this._statements[this._statements.length - 1];
      return n2("ImportDeclaration" === s3.type), n2(0 === s3.specifiers.length), s3.specifiers = [d(r3, l(t3))], this._resultName = o2(r3), this;
    }
    var(e3) {
      const t3 = this._scope.generateUidIdentifier(e3);
      let r3 = this._statements[this._statements.length - 1];
      return "ExpressionStatement" !== r3.type && (n2(this._resultName), r3 = a2(this._resultName), this._statements.push(r3)), this._statements[this._statements.length - 1] = m("var", [y(t3, r3.expression)]), this._resultName = o2(t3), this;
    }
    defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    }
    wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    }
    _interop(e3) {
      const t3 = this._statements[this._statements.length - 1];
      return "ExpressionStatement" === t3.type ? t3.expression = i2(e3, [t3.expression]) : "VariableDeclaration" === t3.type ? (n2(1 === t3.declarations.length), t3.declarations[0].init = i2(e3, [t3.declarations[0].init])) : n2.fail("Unexpected type."), this;
    }
    prop(e3) {
      const t3 = this._statements[this._statements.length - 1];
      return "ExpressionStatement" === t3.type ? t3.expression = f(t3.expression, l(e3)) : "VariableDeclaration" === t3.type ? (n2(1 === t3.declarations.length), t3.declarations[0].init = f(t3.declarations[0].init, l(e3))) : n2.fail("Unexpected type:" + t3.type), this;
    }
    read(e3) {
      this._resultName = f(this._resultName, l(e3));
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    (0, s2.traverse)(e3.node, Object.assign({}, a2, { noScope: true }));
  };
  var n2 = r2(33), s2 = r2(1);
  const { numericLiteral: i2, unaryExpression: o2 } = s2.types, a2 = s2.traverse.visitors.merge([n2.default, { ThisExpression(e3) {
    e3.replaceWith(o2("void", i2(0), true));
  } }]);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    const n3 = /* @__PURE__ */ new Map(), s3 = /* @__PURE__ */ new Map(), o3 = (t4) => {
      e3.requeue(t4);
    };
    for (const [e4, r4] of t3.source) {
      for (const [t4, s4] of r4.imports) n3.set(t4, [e4, s4, null]);
      for (const t4 of r4.importsNamespace) n3.set(t4, [e4, null, t4]);
    }
    for (const [e4, r4] of t3.local) {
      let t4 = s3.get(e4);
      t4 || (t4 = [], s3.set(e4, t4)), t4.push(...r4.names);
    }
    const a3 = { metadata: t3, requeueInParent: o3, scope: e3.scope, exported: s3 };
    e3.traverse(P, a3);
    const l2 = /* @__PURE__ */ new Set([...Array.from(n3.keys()), ...Array.from(s3.keys())]);
    (0, i2.default)(e3, l2, false);
    const c2 = { seen: /* @__PURE__ */ new WeakSet(), metadata: t3, requeueInParent: o3, scope: e3.scope, imported: n3, exported: s3, buildImportReference(e4, n4) {
      let [s4, i3, o4] = e4;
      const a4 = t3.source.get(s4);
      var l3;
      if (a4.referenced = true, o4) return a4.wrap && (n4 = null != (l3 = r3(n4, a4.wrap)) ? l3 : n4), n4;
      let c3 = u(a4.name);
      var p2;
      if (a4.wrap && (c3 = null != (p2 = r3(c3, a4.wrap)) ? p2 : c3), "default" === i3 && "node-default" === a4.interop) return c3;
      const d2 = t3.stringSpecifiers.has(i3);
      return v(c3, d2 ? x(i3) : u(i3), d2);
    } };
    e3.traverse(O, c2);
  };
  var n2 = r2(25), s2 = r2(1), i2 = r2(251);
  const { assignmentExpression: o2, cloneNode: a2, expressionStatement: l, getOuterBindingIdentifiers: c, identifier: u, isArrowFunctionExpression: p, isClassExpression: d, isFunctionExpression: f, isIdentifier: h, isMemberExpression: m, isVariableDeclaration: y, jsxIdentifier: g, jsxMemberExpression: b, memberExpression: v, numericLiteral: E, sequenceExpression: S, stringLiteral: x, variableDeclaration: T, variableDeclarator: w } = s2.types, P = { Scope(e3) {
    e3.skip();
  }, ClassDeclaration(e3) {
    const { requeueInParent: t3, exported: r3, metadata: n3 } = this, { id: s3 } = e3.node;
    if (!s3) throw new Error("Expected class to have a name");
    const i3 = s3.name, o3 = r3.get(i3) || [];
    if (o3.length > 0) {
      const r4 = l(A(n3, o3, u(i3), e3.scope));
      r4._blockHoist = e3.node._blockHoist, t3(e3.insertAfter(r4)[0]);
    }
  }, VariableDeclaration(e3) {
    const { requeueInParent: t3, exported: r3, metadata: n3 } = this, s3 = "var" === e3.node.kind;
    for (const i3 of e3.get("declarations")) {
      const { id: o3 } = i3.node;
      let { init: a3 } = i3.node;
      if (!h(o3) || !r3.has(o3.name) || p(a3) || f(a3) && !a3.id || d(a3) && !a3.id) {
        for (const s4 of Object.keys(i3.getOuterBindingIdentifiers())) if (r3.has(s4)) {
          const i4 = l(A(n3, r3.get(s4), u(s4), e3.scope));
          i4._blockHoist = e3.node._blockHoist, t3(e3.insertAfter(i4)[0]);
        }
      } else {
        if (!a3) {
          if (s3) continue;
          a3 = e3.scope.buildUndefinedNode();
        }
        i3.node.init = A(n3, r3.get(o3.name), a3, e3.scope), t3(i3.get("init"));
      }
    }
  } }, A = (e3, t3, r3, n3) => {
    const s3 = e3.exportName;
    for (let e4 = n3; null != e4; e4 = e4.parent) e4.hasOwnBinding(s3) && e4.rename(s3);
    return (t3 || []).reduce((t4, r4) => {
      const { stringSpecifiers: n4 } = e3, i3 = n4.has(r4);
      return o2("=", v(u(s3), i3 ? x(r4) : u(r4), i3), t4);
    }, r3);
  }, C = (e3) => s2.template.expression.ast`
    (function() {
      throw new Error('"' + '${e3}' + '" is read-only.');
    })()
  `, O = { ReferencedIdentifier(e3) {
    const { seen: t3, buildImportReference: r3, scope: n3, imported: s3, requeueInParent: i3 } = this;
    if (t3.has(e3.node)) return;
    t3.add(e3.node);
    const o3 = e3.node.name, a3 = s3.get(o3);
    if (a3) {
      if (function(e4) {
        do {
          switch (e4.parent.type) {
            case "TSTypeAnnotation":
            case "TSTypeAliasDeclaration":
            case "TSTypeReference":
            case "TypeAnnotation":
            case "TypeAlias":
              return true;
            case "ExportSpecifier":
              return "type" === e4.parentPath.parent.exportKind;
            default:
              if (e4.parentPath.isStatement() || e4.parentPath.isExpression()) return false;
          }
        } while (e4 = e4.parentPath);
      }(e3)) throw e3.buildCodeFrameError(`Cannot transform the imported binding "${o3}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
      const t4 = e3.scope.getBinding(o3);
      if (n3.getBinding(o3) !== t4) return;
      const s4 = r3(a3, e3.node);
      if (s4.loc = e3.node.loc, (e3.parentPath.isCallExpression({ callee: e3.node }) || e3.parentPath.isOptionalCallExpression({ callee: e3.node }) || e3.parentPath.isTaggedTemplateExpression({ tag: e3.node })) && m(s4)) e3.replaceWith(S([E(0), s4]));
      else if (e3.isJSXIdentifier() && m(s4)) {
        const { object: t5, property: r4 } = s4;
        e3.replaceWith(b(g(t5.name), g(r4.name)));
      } else e3.replaceWith(s4);
      i3(e3), e3.skip();
    }
  }, UpdateExpression(e3) {
    const { scope: t3, seen: r3, imported: n3, exported: s3, requeueInParent: i3, buildImportReference: l2 } = this;
    if (r3.has(e3.node)) return;
    r3.add(e3.node);
    const c2 = e3.get("argument");
    if (c2.isMemberExpression()) return;
    const p2 = e3.node;
    if (c2.isIdentifier()) {
      const r4 = c2.node.name;
      if (t3.getBinding(r4) !== e3.scope.getBinding(r4)) return;
      const i4 = s3.get(r4), d2 = n3.get(r4);
      if ((null == i4 ? void 0 : i4.length) > 0 || d2) if (d2) e3.replaceWith(o2(p2.operator[0] + "=", l2(d2, c2.node), C(r4)));
      else if (p2.prefix) e3.replaceWith(A(this.metadata, i4, a2(p2), e3.scope));
      else {
        const n4 = t3.generateDeclaredUidIdentifier(r4);
        e3.replaceWith(S([o2("=", a2(n4), a2(p2)), A(this.metadata, i4, u(r4), e3.scope), a2(n4)]));
      }
    }
    i3(e3), e3.skip();
  }, AssignmentExpression: { exit(e3) {
    const { scope: t3, seen: r3, imported: s3, exported: i3, requeueInParent: o3, buildImportReference: a3 } = this;
    if (r3.has(e3.node)) return;
    r3.add(e3.node);
    const c2 = e3.get("left");
    if (!c2.isMemberExpression()) if (c2.isIdentifier()) {
      const r4 = c2.node.name;
      if (t3.getBinding(r4) !== e3.scope.getBinding(r4)) return;
      const l2 = i3.get(r4), u2 = s3.get(r4);
      if ((null == l2 ? void 0 : l2.length) > 0 || u2) {
        n2("=" === e3.node.operator, "Path was not simplified");
        const t4 = e3.node;
        u2 && (t4.left = a3(u2, c2.node), t4.right = S([t4.right, C(r4)])), e3.replaceWith(A(this.metadata, l2, t4, e3.scope)), o3(e3);
      }
    } else {
      const r4 = c2.getOuterBindingIdentifiers(), n3 = Object.keys(r4).filter((r5) => t3.getBinding(r5) === e3.scope.getBinding(r5)), a4 = n3.find((e4) => s3.has(e4));
      a4 && (e3.node.right = S([e3.node.right, C(a4)]));
      const p2 = [];
      if (n3.forEach((t4) => {
        const r5 = i3.get(t4) || [];
        r5.length > 0 && p2.push(A(this.metadata, r5, u(t4), e3.scope));
      }), p2.length > 0) {
        let t4 = S(p2);
        e3.parentPath.isExpressionStatement() && (t4 = l(t4), t4._blockHoist = e3.parentPath.node._blockHoist), o3(e3.insertAfter(t4)[0]);
      }
    }
  } }, "ForOfStatement|ForInStatement"(e3) {
    const { scope: t3, node: r3 } = e3, { left: n3 } = r3, { exported: s3, imported: i3, scope: u2 } = this;
    if (!y(n3)) {
      let r4, p2 = false;
      const d2 = e3.get("body").scope;
      for (const e4 of Object.keys(c(n3))) u2.getBinding(e4) === t3.getBinding(e4) && (s3.has(e4) && (p2 = true, d2.hasOwnBinding(e4) && d2.rename(e4)), i3.has(e4) && !r4 && (r4 = e4));
      if (!p2 && !r4) return;
      e3.ensureBlock();
      const f2 = e3.get("body"), h2 = t3.generateUidIdentifierBasedOnNode(n3);
      e3.get("left").replaceWith(T("let", [w(a2(h2))])), t3.registerDeclaration(e3.get("left")), p2 && f2.unshiftContainer("body", l(o2("=", n3, h2))), r4 && f2.unshiftContainer("body", l(C(r4)));
    }
  } };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.toGetWrapperPayload = function(e3) {
    return (t3, r3) => {
      if (false === e3) return null;
      if ((0, s2.isSideEffectImport)(r3) || r3.reexportAll) return null;
      if (true === e3) return /\./.test(t3) ? null : "lazy";
      if (Array.isArray(e3)) return -1 === e3.indexOf(t3) ? null : "lazy";
      if ("function" == typeof e3) return e3(t3) ? "lazy" : null;
      throw new Error(".lazy must be a boolean, string array, or function");
    };
  }, t2.wrapReference = function(e3, t3) {
    return "lazy" === t3 ? n2.types.callExpression(e3, []) : null;
  };
  var n2 = r2(1), s2 = r2(252);
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = r2;
  {
    const e3 = r2;
    t2.default = r2 = function(t3, r3) {
      var n2, s2, i2, o2;
      return e3(t3, { moduleId: null != (n2 = r3.moduleId) ? n2 : t3.moduleId, moduleIds: null != (s2 = r3.moduleIds) ? s2 : t3.moduleIds, getModuleId: null != (i2 = r3.getModuleId) ? i2 : t3.getModuleId, moduleRoot: null != (o2 = r3.moduleRoot) ? o2 : t3.moduleRoot });
    };
  }
  function r2(e3, t3) {
    const { filename: r3, filenameRelative: n2 = r3, sourceRoot: s2 = t3.moduleRoot } = e3, { moduleId: i2, moduleIds: o2 = !!i2, getModuleId: a2, moduleRoot: l = s2 } = t3;
    if (!o2) return null;
    if (null != i2 && !a2) return i2;
    let c = null != l ? l + "/" : "";
    if (n2) {
      const e4 = null != s2 ? new RegExp("^" + s2 + "/?") : "";
      c += n2.replace(e4, "").replace(/\.(\w*?)$/, "");
    }
    return c = c.replace(/\\/g, "/"), a2 && a2(c) || c;
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(161);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2() {
    const e3 = r2(101);
    return s2 = function() {
      return e3;
    }, e3;
  }
  function i2() {
    const e3 = r2(37);
    return i2 = function() {
      return e3;
    }, e3;
  }
  function o2() {
    const e3 = r2(0);
    return o2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    let t3, r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "global";
    const n3 = { global: O, module: I, umd: _, var: k }[r3];
    if (!n3) throw new Error(`Unsupported output type ${r3}`);
    return t3 = n3(e3), (0, s2().default)(t3).code;
  };
  var a2 = r2(95);
  const { arrayExpression: l, assignmentExpression: c, binaryExpression: u, blockStatement: p, callExpression: d, cloneNode: f, conditionalExpression: h, exportNamedDeclaration: m, exportSpecifier: y, expressionStatement: g, functionExpression: b, identifier: v, memberExpression: E, objectExpression: S, program: x, stringLiteral: T, unaryExpression: w, variableDeclaration: P, variableDeclarator: A } = o2(), C = (e3) => i2().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(e3);
  function O(e3) {
    const t3 = v("babelHelpers"), r3 = [], n3 = b(null, [v("global")], p(r3)), s3 = x([g(d(n3, [h(u("===", w("typeof", v("global")), T("undefined")), v("self"), v("global"))]))]);
    return r3.push(P("var", [A(t3, c("=", E(v("global"), t3), S([])))])), N(r3, t3, e3), s3;
  }
  function I(e3) {
    const t3 = [], r3 = N(t3, null, e3);
    return t3.unshift(m(null, Object.keys(r3).map((e4) => y(f(r3[e4]), v(e4))))), x(t3, [], "module");
  }
  function _(e3) {
    const t3 = v("babelHelpers"), r3 = [];
    return r3.push(P("var", [A(t3, v("global"))])), N(r3, t3, e3), x([C({ FACTORY_PARAMETERS: v("global"), BROWSER_ARGUMENTS: c("=", E(v("root"), t3), S([])), COMMON_ARGUMENTS: v("exports"), AMD_ARGUMENTS: l([T("exports")]), FACTORY_BODY: r3, UMD_ROOT: v("this") })]);
  }
  function k(e3) {
    const t3 = v("babelHelpers"), r3 = [];
    r3.push(P("var", [A(t3, S([]))]));
    const n3 = x(r3);
    return N(r3, t3, e3), r3.push(g(t3)), n3;
  }
  function N(e3, t3, r3) {
    const s3 = (e4) => t3 ? E(t3, v(e4)) : v(`_${e4}`), i3 = {};
    return n2().list.forEach(function(t4) {
      if (r3 && r3.indexOf(t4) < 0) return;
      const o3 = i3[t4] = s3(t4);
      n2().ensure(t4, a2.default);
      const { nodes: l2 } = n2().get(t4, s3, o3);
      e3.push(...l2);
    }), i3;
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var s2 = r2(133), i2 = r2(134), o2 = r2(1), a2 = r2(135), l = r2(83), c = r2(292), u = r2(136);
  function p() {
    const e3 = r2(14);
    return p = function() {
      return e3;
    }, e3;
  }
  var d = r2(84), f = r2(85), h = r2(473), m = r2(474), y = r2(294), g = r2(140);
  function b(e3, t3) {
    return function* (r3, n3) {
      try {
        return yield* t3(r3, n3);
      } catch (t4) {
        var s3;
        throw /^\[BABEL\]/.test(t4.message) || (t4.message = `[BABEL] ${null != (s3 = e3.filename) ? s3 : "unknown file"}: ${t4.message}`), t4;
      }
    };
  }
  t2.default = n2()(function* (e3) {
    var t3;
    const r3 = yield* (0, y.default)(e3);
    if (!r3) return null;
    const { options: n3, context: s3, fileHandling: o3 } = r3;
    if ("ignored" === o3) return null;
    const a3 = {}, { plugins: c2, presets: p2 } = n3;
    if (!c2 || !p2) throw new Error("Assertion failure - plugins and presets exist");
    const d2 = Object.assign({}, s3, { targets: n3.targets }), h2 = (e4) => {
      const t4 = (0, l.getItemDescriptor)(e4);
      if (!t4) throw new Error("Assertion failure - must be config item");
      return t4;
    }, m2 = p2.map(h2), g2 = c2.map(h2), v2 = [[]], E2 = [], S2 = [], x2 = yield* b(s3, function* e4(t4, r4) {
      const n4 = [];
      for (let e5 = 0; e5 < t4.length; e5++) {
        const i3 = t4[e5];
        if (false !== i3.options) {
          try {
            var s4 = yield* O(i3, d2);
          } catch (r5) {
            throw "BABEL_UNKNOWN_OPTION" === r5.code && (0, f.checkNoUnwrappedItemOptionPairs)(t4, e5, "preset", r5), r5;
          }
          S2.push(s4.externalDependencies), i3.ownPass ? n4.push({ preset: s4.chain, pass: [] }) : n4.unshift({ preset: s4.chain, pass: r4 });
        }
      }
      if (n4.length > 0) {
        v2.splice(1, 0, ...n4.map((e5) => e5.pass).filter((e5) => e5 !== r4));
        for (const { preset: t5, pass: r5 } of n4) {
          if (!t5) return true;
          if (r5.push(...t5.plugins), yield* e4(t5.presets, r5)) return true;
          t5.options.forEach((e5) => {
            (0, i2.mergeOptions)(a3, e5);
          });
        }
      }
    })(m2, v2[0]);
    if (x2) return null;
    const w2 = a3;
    (0, i2.mergeOptions)(w2, n3);
    const P2 = Object.assign({}, d2, { assumptions: null != (t3 = w2.assumptions) ? t3 : {} });
    return yield* b(s3, function* () {
      v2[0].unshift(...g2);
      for (const t4 of v2) {
        const r4 = [];
        E2.push(r4);
        for (let n4 = 0; n4 < t4.length; n4++) {
          const s4 = t4[n4];
          if (false !== s4.options) {
            try {
              var e4 = yield* T(s4, P2);
            } catch (e5) {
              throw "BABEL_UNKNOWN_PLUGIN_PROPERTY" === e5.code && (0, f.checkNoUnwrappedItemOptionPairs)(t4, n4, "plugin", e5), e5;
            }
            r4.push(e4), S2.push(e4.externalDependencies);
          }
        }
      }
    })(), w2.plugins = E2[0], w2.presets = E2.slice(1).filter((e4) => e4.length > 0).map((e4) => ({ plugins: e4 })), w2.passPerPreset = w2.presets.length > 0, { options: w2, passes: E2, externalDependencies: (0, u.finalize)(S2) };
  });
  const v = (e3) => (0, d.makeWeakCache)(function(t3, r3) {
    let { value: n3, options: i3, dirname: a3, alias: l2 } = t3;
    return function* () {
      if (false === i3) throw new Error("Assertion failure");
      i3 = i3 || {};
      const t4 = [];
      let c2 = n3;
      if ("function" == typeof n3) {
        const u2 = (0, s2.maybeAsync)(n3, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), p2 = Object.assign({}, o2, e3(r3, t4));
        try {
          c2 = yield* u2(p2, i3, a3);
        } catch (e4) {
          throw l2 && (e4.message += ` (While processing: ${JSON.stringify(l2)})`), e4;
        }
      }
      if (!c2 || "object" != typeof c2) throw new Error("Plugin/Preset did not return an object.");
      if ((0, s2.isThenable)(c2)) throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(l2)})`);
      if (t4.length > 0 && (!r3.configured() || "forever" === r3.mode())) {
        let e4 = `A plugin/preset has external untracked dependencies (${t4[0]}), but the cache `;
        throw r3.configured() ? e4 += " has been configured to never be invalidated. " : e4 += "has not been configured to be invalidated when the external dependencies change. ", e4 += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(l2)})`, new Error(e4);
      }
      return { value: c2, options: i3, dirname: a3, alias: l2, externalDependencies: (0, u.finalize)(t4) };
    }();
  }), E = v(m.makePluginAPI), S = v(m.makePresetAPI), x = (0, d.makeWeakCache)(function(e3, t3) {
    let { value: r3, options: n3, dirname: i3, alias: o3, externalDependencies: l2 } = e3;
    return function* () {
      const e4 = (0, h.validatePluginObject)(r3), c2 = Object.assign({}, e4);
      if (c2.visitor && (c2.visitor = p().default.explode(Object.assign({}, c2.visitor))), c2.inherits) {
        const e5 = { name: void 0, alias: `${o3}$inherits`, value: c2.inherits, options: n3, dirname: i3 }, r4 = yield* (0, s2.forwardAsync)(T, (r5) => t3.invalidate((t4) => r5(e5, t4)));
        c2.pre = I(r4.pre, c2.pre), c2.post = I(r4.post, c2.post), c2.manipulateOptions = I(r4.manipulateOptions, c2.manipulateOptions), c2.visitor = p().default.visitors.merge([r4.visitor || {}, c2.visitor || {}]), r4.externalDependencies.length > 0 && (l2 = 0 === l2.length ? r4.externalDependencies : (0, u.finalize)([l2, r4.externalDependencies]));
      }
      return new a2.default(c2, n3, o3, l2);
    }();
  });
  function* T(e3, t3) {
    if (e3.value instanceof a2.default) {
      if (e3.options) throw new Error("Passed options to an existing Plugin instance will not work.");
      return e3.value;
    }
    return yield* x(yield* E(e3, t3), t3);
  }
  const w = (e3) => e3 && "function" != typeof e3, P = (e3, t3) => {
    if (w(e3.test) || w(e3.include) || w(e3.exclude)) {
      const e4 = t3.name ? `"${t3.name}"` : "/* your preset */";
      throw new g.default([`Preset ${e4} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, { filename: 'file.ts', presets: [${e4}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join("\n"));
    }
  }, A = (e3, t3, r3) => {
    if (!t3.filename) {
      var n3;
      const { options: t4 } = e3;
      P(t4, r3), null == (n3 = t4.overrides) || n3.forEach((e4) => P(e4, r3));
    }
  }, C = (0, d.makeWeakCacheSync)((e3) => {
    let { value: t3, dirname: r3, alias: n3, externalDependencies: s3 } = e3;
    return { options: (0, f.validate)("preset", t3), alias: n3, dirname: r3, externalDependencies: s3 };
  });
  function* O(e3, t3) {
    const r3 = C(yield* S(e3, t3));
    return A(r3, t3, e3), { chain: yield* (0, c.buildPresetChain)(r3, t3), externalDependencies: r3.externalDependencies };
  }
  function I(e3, t3) {
    const r3 = [e3, t3].filter(Boolean);
    return r3.length <= 1 ? r3[0] : function() {
      for (var e4 = arguments.length, t4 = new Array(e4), n3 = 0; n3 < e4; n3++) t4[n3] = arguments[n3];
      for (const e5 of r3) e5.apply(this, t4);
    };
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.once = function(e3) {
    let t3, r3, s2 = false;
    return function* () {
      if (!t3) {
        if (r3) return s2 = true, yield* (0, n2.waitFor)(r3);
        if (yield* (0, n2.isAsync)()) {
          let n3, i2;
          r3 = new Promise((e4, t4) => {
            n3 = e4, i2 = t4;
          });
          try {
            t3 = { ok: true, value: yield* e3() }, r3 = null, s2 && n3(t3.value);
          } catch (e4) {
            t3 = { ok: false, value: e4 }, r3 = null, s2 && i2(e4);
          }
        } else try {
          t3 = { ok: true, value: yield* e3() };
        } catch (e4) {
          t3 = { ok: false, value: e4 };
        }
      }
      if (t3.ok) return t3.value;
      throw t3.value;
    };
  };
  var n2 = r2(133);
}, (e2) => {
  e2.exports = JSON.parse('[{"name":"nodejs","version":"0.2.0","date":"2011-08-26","lts":false,"security":false,"v8":"2.3.8.0"},{"name":"nodejs","version":"0.3.0","date":"2011-08-26","lts":false,"security":false,"v8":"2.5.1.0"},{"name":"nodejs","version":"0.4.0","date":"2011-08-26","lts":false,"security":false,"v8":"3.1.2.0"},{"name":"nodejs","version":"0.5.0","date":"2011-08-26","lts":false,"security":false,"v8":"3.1.8.25"},{"name":"nodejs","version":"0.6.0","date":"2011-11-04","lts":false,"security":false,"v8":"3.6.6.6"},{"name":"nodejs","version":"0.7.0","date":"2012-01-17","lts":false,"security":false,"v8":"3.8.6.0"},{"name":"nodejs","version":"0.8.0","date":"2012-06-22","lts":false,"security":false,"v8":"3.11.10.10"},{"name":"nodejs","version":"0.9.0","date":"2012-07-20","lts":false,"security":false,"v8":"3.11.10.15"},{"name":"nodejs","version":"0.10.0","date":"2013-03-11","lts":false,"security":false,"v8":"3.14.5.8"},{"name":"nodejs","version":"0.11.0","date":"2013-03-28","lts":false,"security":false,"v8":"3.17.13.0"},{"name":"nodejs","version":"0.12.0","date":"2015-02-06","lts":false,"security":false,"v8":"3.28.73.0"},{"name":"nodejs","version":"4.0.0","date":"2015-09-08","lts":false,"security":false,"v8":"4.5.103.30"},{"name":"nodejs","version":"4.1.0","date":"2015-09-17","lts":false,"security":false,"v8":"4.5.103.33"},{"name":"nodejs","version":"4.2.0","date":"2015-10-12","lts":"Argon","security":false,"v8":"4.5.103.35"},{"name":"nodejs","version":"4.3.0","date":"2016-02-09","lts":"Argon","security":false,"v8":"4.5.103.35"},{"name":"nodejs","version":"4.4.0","date":"2016-03-08","lts":"Argon","security":false,"v8":"4.5.103.35"},{"name":"nodejs","version":"4.5.0","date":"2016-08-16","lts":"Argon","security":false,"v8":"4.5.103.37"},{"name":"nodejs","version":"4.6.0","date":"2016-09-27","lts":"Argon","security":true,"v8":"4.5.103.37"},{"name":"nodejs","version":"4.7.0","date":"2016-12-06","lts":"Argon","security":false,"v8":"4.5.103.43"},{"name":"nodejs","version":"4.8.0","date":"2017-02-21","lts":"Argon","security":false,"v8":"4.5.103.45"},{"name":"nodejs","version":"4.9.0","date":"2018-03-28","lts":"Argon","security":true,"v8":"4.5.103.53"},{"name":"nodejs","version":"5.0.0","date":"2015-10-29","lts":false,"security":false,"v8":"4.6.85.28"},{"name":"nodejs","version":"5.1.0","date":"2015-11-17","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.2.0","date":"2015-12-09","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.3.0","date":"2015-12-15","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.4.0","date":"2016-01-06","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.5.0","date":"2016-01-21","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.6.0","date":"2016-02-09","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.7.0","date":"2016-02-23","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.8.0","date":"2016-03-09","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.9.0","date":"2016-03-16","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.10.0","date":"2016-04-01","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.11.0","date":"2016-04-21","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.12.0","date":"2016-06-23","lts":false,"security":false,"v8":"4.6.85.32"},{"name":"nodejs","version":"6.0.0","date":"2016-04-26","lts":false,"security":false,"v8":"5.0.71.35"},{"name":"nodejs","version":"6.1.0","date":"2016-05-05","lts":false,"security":false,"v8":"5.0.71.35"},{"name":"nodejs","version":"6.2.0","date":"2016-05-17","lts":false,"security":false,"v8":"5.0.71.47"},{"name":"nodejs","version":"6.3.0","date":"2016-07-06","lts":false,"security":false,"v8":"5.0.71.52"},{"name":"nodejs","version":"6.4.0","date":"2016-08-12","lts":false,"security":false,"v8":"5.0.71.60"},{"name":"nodejs","version":"6.5.0","date":"2016-08-26","lts":false,"security":false,"v8":"5.1.281.81"},{"name":"nodejs","version":"6.6.0","date":"2016-09-14","lts":false,"security":false,"v8":"5.1.281.83"},{"name":"nodejs","version":"6.7.0","date":"2016-09-27","lts":false,"security":true,"v8":"5.1.281.83"},{"name":"nodejs","version":"6.8.0","date":"2016-10-12","lts":false,"security":false,"v8":"5.1.281.84"},{"name":"nodejs","version":"6.9.0","date":"2016-10-18","lts":"Boron","security":false,"v8":"5.1.281.84"},{"name":"nodejs","version":"6.10.0","date":"2017-02-21","lts":"Boron","security":false,"v8":"5.1.281.93"},{"name":"nodejs","version":"6.11.0","date":"2017-06-06","lts":"Boron","security":false,"v8":"5.1.281.102"},{"name":"nodejs","version":"6.12.0","date":"2017-11-06","lts":"Boron","security":false,"v8":"5.1.281.108"},{"name":"nodejs","version":"6.13.0","date":"2018-02-10","lts":"Boron","security":false,"v8":"5.1.281.111"},{"name":"nodejs","version":"6.14.0","date":"2018-03-28","lts":"Boron","security":true,"v8":"5.1.281.111"},{"name":"nodejs","version":"6.15.0","date":"2018-11-27","lts":"Boron","security":true,"v8":"5.1.281.111"},{"name":"nodejs","version":"6.16.0","date":"2018-12-26","lts":"Boron","security":false,"v8":"5.1.281.111"},{"name":"nodejs","version":"6.17.0","date":"2019-02-28","lts":"Boron","security":true,"v8":"5.1.281.111"},{"name":"nodejs","version":"7.0.0","date":"2016-10-25","lts":false,"security":false,"v8":"5.4.500.36"},{"name":"nodejs","version":"7.1.0","date":"2016-11-08","lts":false,"security":false,"v8":"5.4.500.36"},{"name":"nodejs","version":"7.2.0","date":"2016-11-22","lts":false,"security":false,"v8":"5.4.500.43"},{"name":"nodejs","version":"7.3.0","date":"2016-12-20","lts":false,"security":false,"v8":"5.4.500.45"},{"name":"nodejs","version":"7.4.0","date":"2017-01-04","lts":false,"security":false,"v8":"5.4.500.45"},{"name":"nodejs","version":"7.5.0","date":"2017-01-31","lts":false,"security":false,"v8":"5.4.500.48"},{"name":"nodejs","version":"7.6.0","date":"2017-02-21","lts":false,"security":false,"v8":"5.5.372.40"},{"name":"nodejs","version":"7.7.0","date":"2017-02-28","lts":false,"security":false,"v8":"5.5.372.41"},{"name":"nodejs","version":"7.8.0","date":"2017-03-29","lts":false,"security":false,"v8":"5.5.372.43"},{"name":"nodejs","version":"7.9.0","date":"2017-04-11","lts":false,"security":false,"v8":"5.5.372.43"},{"name":"nodejs","version":"7.10.0","date":"2017-05-02","lts":false,"security":false,"v8":"5.5.372.43"},{"name":"nodejs","version":"8.0.0","date":"2017-05-30","lts":false,"security":false,"v8":"5.8.283.41"},{"name":"nodejs","version":"8.1.0","date":"2017-06-08","lts":false,"security":false,"v8":"5.8.283.41"},{"name":"nodejs","version":"8.2.0","date":"2017-07-19","lts":false,"security":false,"v8":"5.8.283.41"},{"name":"nodejs","version":"8.3.0","date":"2017-08-08","lts":false,"security":false,"v8":"6.0.286.52"},{"name":"nodejs","version":"8.4.0","date":"2017-08-15","lts":false,"security":false,"v8":"6.0.286.52"},{"name":"nodejs","version":"8.5.0","date":"2017-09-12","lts":false,"security":false,"v8":"6.0.287.53"},{"name":"nodejs","version":"8.6.0","date":"2017-09-26","lts":false,"security":false,"v8":"6.0.287.53"},{"name":"nodejs","version":"8.7.0","date":"2017-10-11","lts":false,"security":false,"v8":"6.1.534.42"},{"name":"nodejs","version":"8.8.0","date":"2017-10-24","lts":false,"security":false,"v8":"6.1.534.42"},{"name":"nodejs","version":"8.9.0","date":"2017-10-31","lts":"Carbon","security":false,"v8":"6.1.534.46"},{"name":"nodejs","version":"8.10.0","date":"2018-03-06","lts":"Carbon","security":false,"v8":"6.2.414.50"},{"name":"nodejs","version":"8.11.0","date":"2018-03-28","lts":"Carbon","security":true,"v8":"6.2.414.50"},{"name":"nodejs","version":"8.12.0","date":"2018-09-10","lts":"Carbon","security":false,"v8":"6.2.414.66"},{"name":"nodejs","version":"8.13.0","date":"2018-11-20","lts":"Carbon","security":false,"v8":"6.2.414.72"},{"name":"nodejs","version":"8.14.0","date":"2018-11-27","lts":"Carbon","security":true,"v8":"6.2.414.72"},{"name":"nodejs","version":"8.15.0","date":"2018-12-26","lts":"Carbon","security":false,"v8":"6.2.414.75"},{"name":"nodejs","version":"8.16.0","date":"2019-04-16","lts":"Carbon","security":false,"v8":"6.2.414.77"},{"name":"nodejs","version":"8.17.0","date":"2019-12-17","lts":"Carbon","security":true,"v8":"6.2.414.78"},{"name":"nodejs","version":"9.0.0","date":"2017-10-31","lts":false,"security":false,"v8":"6.2.414.32"},{"name":"nodejs","version":"9.1.0","date":"2017-11-07","lts":false,"security":false,"v8":"6.2.414.32"},{"name":"nodejs","version":"9.2.0","date":"2017-11-14","lts":false,"security":false,"v8":"6.2.414.44"},{"name":"nodejs","version":"9.3.0","date":"2017-12-12","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.4.0","date":"2018-01-10","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.5.0","date":"2018-01-31","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.6.0","date":"2018-02-21","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.7.0","date":"2018-03-01","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.8.0","date":"2018-03-07","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.9.0","date":"2018-03-21","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.10.0","date":"2018-03-28","lts":false,"security":true,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.11.0","date":"2018-04-04","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"10.0.0","date":"2018-04-24","lts":false,"security":false,"v8":"6.6.346.24"},{"name":"nodejs","version":"10.1.0","date":"2018-05-08","lts":false,"security":false,"v8":"6.6.346.27"},{"name":"nodejs","version":"10.2.0","date":"2018-05-23","lts":false,"security":false,"v8":"6.6.346.32"},{"name":"nodejs","version":"10.3.0","date":"2018-05-29","lts":false,"security":false,"v8":"6.6.346.32"},{"name":"nodejs","version":"10.4.0","date":"2018-06-06","lts":false,"security":false,"v8":"6.7.288.43"},{"name":"nodejs","version":"10.5.0","date":"2018-06-20","lts":false,"security":false,"v8":"6.7.288.46"},{"name":"nodejs","version":"10.6.0","date":"2018-07-04","lts":false,"security":false,"v8":"6.7.288.46"},{"name":"nodejs","version":"10.7.0","date":"2018-07-18","lts":false,"security":false,"v8":"6.7.288.49"},{"name":"nodejs","version":"10.8.0","date":"2018-08-01","lts":false,"security":false,"v8":"6.7.288.49"},{"name":"nodejs","version":"10.9.0","date":"2018-08-15","lts":false,"security":false,"v8":"6.8.275.24"},{"name":"nodejs","version":"10.10.0","date":"2018-09-06","lts":false,"security":false,"v8":"6.8.275.30"},{"name":"nodejs","version":"10.11.0","date":"2018-09-19","lts":false,"security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.12.0","date":"2018-10-10","lts":false,"security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.13.0","date":"2018-10-30","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.14.0","date":"2018-11-27","lts":"Dubnium","security":true,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.15.0","date":"2018-12-26","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.16.0","date":"2019-05-28","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.17.0","date":"2019-10-22","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.18.0","date":"2019-12-17","lts":"Dubnium","security":true,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.19.0","date":"2020-02-05","lts":"Dubnium","security":true,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.20.0","date":"2020-03-26","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.21.0","date":"2020-06-02","lts":"Dubnium","security":true,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.22.0","date":"2020-07-21","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.23.0","date":"2020-10-27","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.24.0","date":"2021-02-23","lts":"Dubnium","security":true,"v8":"6.8.275.32"},{"name":"nodejs","version":"11.0.0","date":"2018-10-23","lts":false,"security":false,"v8":"7.0.276.28"},{"name":"nodejs","version":"11.1.0","date":"2018-10-30","lts":false,"security":false,"v8":"7.0.276.32"},{"name":"nodejs","version":"11.2.0","date":"2018-11-15","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.3.0","date":"2018-11-27","lts":false,"security":true,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.4.0","date":"2018-12-07","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.5.0","date":"2018-12-18","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.6.0","date":"2018-12-26","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.7.0","date":"2019-01-17","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.8.0","date":"2019-01-24","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.9.0","date":"2019-01-30","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.10.0","date":"2019-02-14","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.11.0","date":"2019-03-05","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.12.0","date":"2019-03-14","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.13.0","date":"2019-03-28","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.14.0","date":"2019-04-10","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.15.0","date":"2019-04-30","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"12.0.0","date":"2019-04-23","lts":false,"security":false,"v8":"7.4.288.21"},{"name":"nodejs","version":"12.1.0","date":"2019-04-29","lts":false,"security":false,"v8":"7.4.288.21"},{"name":"nodejs","version":"12.2.0","date":"2019-05-07","lts":false,"security":false,"v8":"7.4.288.21"},{"name":"nodejs","version":"12.3.0","date":"2019-05-21","lts":false,"security":false,"v8":"7.4.288.27"},{"name":"nodejs","version":"12.4.0","date":"2019-06-04","lts":false,"security":false,"v8":"7.4.288.27"},{"name":"nodejs","version":"12.5.0","date":"2019-06-26","lts":false,"security":false,"v8":"7.5.288.22"},{"name":"nodejs","version":"12.6.0","date":"2019-07-03","lts":false,"security":false,"v8":"7.5.288.22"},{"name":"nodejs","version":"12.7.0","date":"2019-07-23","lts":false,"security":false,"v8":"7.5.288.22"},{"name":"nodejs","version":"12.8.0","date":"2019-08-06","lts":false,"security":false,"v8":"7.5.288.22"},{"name":"nodejs","version":"12.9.0","date":"2019-08-20","lts":false,"security":false,"v8":"7.6.303.29"},{"name":"nodejs","version":"12.10.0","date":"2019-09-04","lts":false,"security":false,"v8":"7.6.303.29"},{"name":"nodejs","version":"12.11.0","date":"2019-09-25","lts":false,"security":false,"v8":"7.7.299.11"},{"name":"nodejs","version":"12.12.0","date":"2019-10-11","lts":false,"security":false,"v8":"7.7.299.13"},{"name":"nodejs","version":"12.13.0","date":"2019-10-21","lts":"Erbium","security":false,"v8":"7.7.299.13"},{"name":"nodejs","version":"12.14.0","date":"2019-12-17","lts":"Erbium","security":true,"v8":"7.7.299.13"},{"name":"nodejs","version":"12.15.0","date":"2020-02-05","lts":"Erbium","security":true,"v8":"7.7.299.13"},{"name":"nodejs","version":"12.16.0","date":"2020-02-11","lts":"Erbium","security":false,"v8":"7.8.279.23"},{"name":"nodejs","version":"12.17.0","date":"2020-05-26","lts":"Erbium","security":false,"v8":"7.8.279.23"},{"name":"nodejs","version":"12.18.0","date":"2020-06-02","lts":"Erbium","security":true,"v8":"7.8.279.23"},{"name":"nodejs","version":"12.19.0","date":"2020-10-06","lts":"Erbium","security":false,"v8":"7.8.279.23"},{"name":"nodejs","version":"12.20.0","date":"2020-11-24","lts":"Erbium","security":false,"v8":"7.8.279.23"},{"name":"nodejs","version":"12.21.0","date":"2021-02-23","lts":"Erbium","security":true,"v8":"7.8.279.23"},{"name":"nodejs","version":"12.22.0","date":"2021-03-30","lts":"Erbium","security":false,"v8":"7.8.279.23"},{"name":"nodejs","version":"13.0.0","date":"2019-10-22","lts":false,"security":false,"v8":"7.8.279.17"},{"name":"nodejs","version":"13.1.0","date":"2019-11-05","lts":false,"security":false,"v8":"7.8.279.17"},{"name":"nodejs","version":"13.2.0","date":"2019-11-21","lts":false,"security":false,"v8":"7.9.317.23"},{"name":"nodejs","version":"13.3.0","date":"2019-12-03","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.4.0","date":"2019-12-17","lts":false,"security":true,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.5.0","date":"2019-12-18","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.6.0","date":"2020-01-07","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.7.0","date":"2020-01-21","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.8.0","date":"2020-02-05","lts":false,"security":true,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.9.0","date":"2020-02-18","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.10.0","date":"2020-03-04","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.11.0","date":"2020-03-12","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.12.0","date":"2020-03-26","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.13.0","date":"2020-04-14","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.14.0","date":"2020-04-29","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"14.0.0","date":"2020-04-21","lts":false,"security":false,"v8":"8.1.307.30"},{"name":"nodejs","version":"14.1.0","date":"2020-04-29","lts":false,"security":false,"v8":"8.1.307.31"},{"name":"nodejs","version":"14.2.0","date":"2020-05-05","lts":false,"security":false,"v8":"8.1.307.31"},{"name":"nodejs","version":"14.3.0","date":"2020-05-19","lts":false,"security":false,"v8":"8.1.307.31"},{"name":"nodejs","version":"14.4.0","date":"2020-06-02","lts":false,"security":true,"v8":"8.1.307.31"},{"name":"nodejs","version":"14.5.0","date":"2020-06-30","lts":false,"security":false,"v8":"8.3.110.9"},{"name":"nodejs","version":"14.6.0","date":"2020-07-20","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.7.0","date":"2020-07-29","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.8.0","date":"2020-08-11","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.9.0","date":"2020-08-27","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.10.0","date":"2020-09-08","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.11.0","date":"2020-09-15","lts":false,"security":true,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.12.0","date":"2020-09-22","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.13.0","date":"2020-09-29","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.14.0","date":"2020-10-15","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.15.0","date":"2020-10-27","lts":"Fermium","security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.16.0","date":"2021-02-23","lts":"Fermium","security":true,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.17.0","date":"2021-05-11","lts":"Fermium","security":false,"v8":"8.4.371.23"},{"name":"nodejs","version":"14.18.0","date":"2021-09-28","lts":"Fermium","security":false,"v8":"8.4.371.23"},{"name":"nodejs","version":"14.19.0","date":"2022-02-01","lts":"Fermium","security":false,"v8":"8.4.371.23"},{"name":"nodejs","version":"14.20.0","date":"2022-07-07","lts":"Fermium","security":true,"v8":"8.4.371.23"},{"name":"nodejs","version":"14.21.0","date":"2022-11-01","lts":"Fermium","security":false,"v8":"8.4.371.23"},{"name":"nodejs","version":"15.0.0","date":"2020-10-20","lts":false,"security":false,"v8":"8.6.395.16"},{"name":"nodejs","version":"15.1.0","date":"2020-11-04","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.2.0","date":"2020-11-10","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.3.0","date":"2020-11-24","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.4.0","date":"2020-12-09","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.5.0","date":"2020-12-22","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.6.0","date":"2021-01-14","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.7.0","date":"2021-01-25","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.8.0","date":"2021-02-02","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.9.0","date":"2021-02-18","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.10.0","date":"2021-02-23","lts":false,"security":true,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.11.0","date":"2021-03-03","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.12.0","date":"2021-03-17","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.13.0","date":"2021-03-31","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.14.0","date":"2021-04-06","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"16.0.0","date":"2021-04-20","lts":false,"security":false,"v8":"9.0.257.17"},{"name":"nodejs","version":"16.1.0","date":"2021-05-04","lts":false,"security":false,"v8":"9.0.257.24"},{"name":"nodejs","version":"16.2.0","date":"2021-05-19","lts":false,"security":false,"v8":"9.0.257.25"},{"name":"nodejs","version":"16.3.0","date":"2021-06-03","lts":false,"security":false,"v8":"9.0.257.25"},{"name":"nodejs","version":"16.4.0","date":"2021-06-23","lts":false,"security":false,"v8":"9.1.269.36"},{"name":"nodejs","version":"16.5.0","date":"2021-07-14","lts":false,"security":false,"v8":"9.1.269.38"},{"name":"nodejs","version":"16.6.0","date":"2021-07-29","lts":false,"security":true,"v8":"9.2.230.21"},{"name":"nodejs","version":"16.7.0","date":"2021-08-18","lts":false,"security":false,"v8":"9.2.230.21"},{"name":"nodejs","version":"16.8.0","date":"2021-08-25","lts":false,"security":false,"v8":"9.2.230.21"},{"name":"nodejs","version":"16.9.0","date":"2021-09-07","lts":false,"security":false,"v8":"9.3.345.16"},{"name":"nodejs","version":"16.10.0","date":"2021-09-22","lts":false,"security":false,"v8":"9.3.345.19"},{"name":"nodejs","version":"16.11.0","date":"2021-10-08","lts":false,"security":false,"v8":"9.4.146.19"},{"name":"nodejs","version":"16.12.0","date":"2021-10-20","lts":false,"security":false,"v8":"9.4.146.19"},{"name":"nodejs","version":"16.13.0","date":"2021-10-26","lts":"Gallium","security":false,"v8":"9.4.146.19"},{"name":"nodejs","version":"16.14.0","date":"2022-02-08","lts":"Gallium","security":false,"v8":"9.4.146.24"},{"name":"nodejs","version":"16.15.0","date":"2022-04-26","lts":"Gallium","security":false,"v8":"9.4.146.24"},{"name":"nodejs","version":"16.16.0","date":"2022-07-07","lts":"Gallium","security":true,"v8":"9.4.146.24"},{"name":"nodejs","version":"16.17.0","date":"2022-08-16","lts":"Gallium","security":false,"v8":"9.4.146.26"},{"name":"nodejs","version":"16.18.0","date":"2022-10-12","lts":"Gallium","security":false,"v8":"9.4.146.26"},{"name":"nodejs","version":"16.19.0","date":"2022-12-13","lts":"Gallium","security":false,"v8":"9.4.146.26"},{"name":"nodejs","version":"16.20.0","date":"2023-03-28","lts":"Gallium","security":false,"v8":"9.4.146.26"},{"name":"nodejs","version":"17.0.0","date":"2021-10-19","lts":false,"security":false,"v8":"9.5.172.21"},{"name":"nodejs","version":"17.1.0","date":"2021-11-09","lts":false,"security":false,"v8":"9.5.172.25"},{"name":"nodejs","version":"17.2.0","date":"2021-11-30","lts":false,"security":false,"v8":"9.6.180.14"},{"name":"nodejs","version":"17.3.0","date":"2021-12-17","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"17.4.0","date":"2022-01-18","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"17.5.0","date":"2022-02-10","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"17.6.0","date":"2022-02-22","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"17.7.0","date":"2022-03-09","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"17.8.0","date":"2022-03-22","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"17.9.0","date":"2022-04-07","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"18.0.0","date":"2022-04-18","lts":false,"security":false,"v8":"10.1.124.8"},{"name":"nodejs","version":"18.1.0","date":"2022-05-03","lts":false,"security":false,"v8":"10.1.124.8"},{"name":"nodejs","version":"18.2.0","date":"2022-05-17","lts":false,"security":false,"v8":"10.1.124.8"},{"name":"nodejs","version":"18.3.0","date":"2022-06-02","lts":false,"security":false,"v8":"10.2.154.4"},{"name":"nodejs","version":"18.4.0","date":"2022-06-16","lts":false,"security":false,"v8":"10.2.154.4"},{"name":"nodejs","version":"18.5.0","date":"2022-07-06","lts":false,"security":true,"v8":"10.2.154.4"},{"name":"nodejs","version":"18.6.0","date":"2022-07-13","lts":false,"security":false,"v8":"10.2.154.13"},{"name":"nodejs","version":"18.7.0","date":"2022-07-26","lts":false,"security":false,"v8":"10.2.154.13"},{"name":"nodejs","version":"18.8.0","date":"2022-08-24","lts":false,"security":false,"v8":"10.2.154.13"},{"name":"nodejs","version":"18.9.0","date":"2022-09-07","lts":false,"security":false,"v8":"10.2.154.15"},{"name":"nodejs","version":"18.10.0","date":"2022-09-28","lts":false,"security":false,"v8":"10.2.154.15"},{"name":"nodejs","version":"18.11.0","date":"2022-10-13","lts":false,"security":false,"v8":"10.2.154.15"},{"name":"nodejs","version":"18.12.0","date":"2022-10-25","lts":"Hydrogen","security":false,"v8":"10.2.154.15"},{"name":"nodejs","version":"18.13.0","date":"2023-01-05","lts":"Hydrogen","security":false,"v8":"10.2.154.23"},{"name":"nodejs","version":"18.14.0","date":"2023-02-01","lts":"Hydrogen","security":false,"v8":"10.2.154.23"},{"name":"nodejs","version":"18.15.0","date":"2023-03-05","lts":"Hydrogen","security":false,"v8":"10.2.154.26"},{"name":"nodejs","version":"18.16.0","date":"2023-04-12","lts":"Hydrogen","security":false,"v8":"10.2.154.26"},{"name":"nodejs","version":"18.17.0","date":"2023-07-18","lts":"Hydrogen","security":false,"v8":"10.2.154.26"},{"name":"nodejs","version":"18.18.0","date":"2023-09-18","lts":"Hydrogen","security":false,"v8":"10.2.154.26"},{"name":"nodejs","version":"18.19.0","date":"2023-11-29","lts":"Hydrogen","security":false,"v8":"10.2.154.26"},{"name":"nodejs","version":"19.0.0","date":"2022-10-17","lts":false,"security":false,"v8":"10.7.193.13"},{"name":"nodejs","version":"19.1.0","date":"2022-11-14","lts":false,"security":false,"v8":"10.7.193.20"},{"name":"nodejs","version":"19.2.0","date":"2022-11-29","lts":false,"security":false,"v8":"10.8.168.20"},{"name":"nodejs","version":"19.3.0","date":"2022-12-14","lts":false,"security":false,"v8":"10.8.168.21"},{"name":"nodejs","version":"19.4.0","date":"2023-01-05","lts":false,"security":false,"v8":"10.8.168.25"},{"name":"nodejs","version":"19.5.0","date":"2023-01-24","lts":false,"security":false,"v8":"10.8.168.25"},{"name":"nodejs","version":"19.6.0","date":"2023-02-01","lts":false,"security":false,"v8":"10.8.168.25"},{"name":"nodejs","version":"19.7.0","date":"2023-02-21","lts":false,"security":false,"v8":"10.8.168.25"},{"name":"nodejs","version":"19.8.0","date":"2023-03-14","lts":false,"security":false,"v8":"10.8.168.25"},{"name":"nodejs","version":"19.9.0","date":"2023-04-10","lts":false,"security":false,"v8":"10.8.168.25"},{"name":"nodejs","version":"20.0.0","date":"2023-04-17","lts":false,"security":false,"v8":"11.3.244.4"},{"name":"nodejs","version":"20.1.0","date":"2023-05-03","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.2.0","date":"2023-05-16","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.3.0","date":"2023-06-08","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.4.0","date":"2023-07-04","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.5.0","date":"2023-07-19","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.6.0","date":"2023-08-23","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.7.0","date":"2023-09-18","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.8.0","date":"2023-09-28","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.9.0","date":"2023-10-24","lts":"Iron","security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.10.0","date":"2023-11-22","lts":"Iron","security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"21.0.0","date":"2023-10-17","lts":false,"security":false,"v8":"11.8.172.13"},{"name":"nodejs","version":"21.1.0","date":"2023-10-24","lts":false,"security":false,"v8":"11.8.172.15"},{"name":"nodejs","version":"21.2.0","date":"2023-11-14","lts":false,"security":false,"v8":"11.8.172.17"},{"name":"nodejs","version":"21.3.0","date":"2023-11-30","lts":false,"security":false,"v8":"11.8.172.17"}]');
}, (e2, t2, r2) => {
  const n2 = r2(458).browsers, s2 = r2(459).browserVersions, i2 = r2(285);
  function o2(e3) {
    return Object.keys(e3).reduce((t3, r3) => (t3[s2[r3]] = e3[r3], t3), {});
  }
  e2.exports.a = Object.keys(i2).reduce((e3, t3) => {
    let r3 = i2[t3];
    return e3[n2[t3]] = Object.keys(r3).reduce((e4, t4) => ("A" === t4 ? e4.usage_global = o2(r3[t4]) : "C" === t4 ? e4.versions = r3[t4].reduce((e5, t5) => ("" === t5 ? e5.push(null) : e5.push(s2[t5]), e5), []) : "D" === t4 ? e4.prefix_exceptions = o2(r3[t4]) : "E" === t4 ? e4.browser = r3[t4] : "F" === t4 ? e4.release_date = Object.keys(r3[t4]).reduce((e5, n3) => (e5[s2[n3]] = r3[t4][n3], e5), {}) : e4.prefix = r3[t4], e4), {}), e3;
  }, {});
}, (e2, t2, r2) => {
  e2.exports.browsers = r2(283);
}, (e2, t2, r2) => {
  e2.exports.browserVersions = r2(284);
}, (e2) => {
  e2.exports = JSON.parse('{"v0.8":{"start":"2012-06-25","end":"2014-07-31"},"v0.10":{"start":"2013-03-11","end":"2016-10-31"},"v0.12":{"start":"2015-02-06","end":"2016-12-31"},"v4":{"start":"2015-09-08","lts":"2015-10-12","maintenance":"2017-04-01","end":"2018-04-30","codename":"Argon"},"v5":{"start":"2015-10-29","maintenance":"2016-04-30","end":"2016-06-30"},"v6":{"start":"2016-04-26","lts":"2016-10-18","maintenance":"2018-04-30","end":"2019-04-30","codename":"Boron"},"v7":{"start":"2016-10-25","maintenance":"2017-04-30","end":"2017-06-30"},"v8":{"start":"2017-05-30","lts":"2017-10-31","maintenance":"2019-01-01","end":"2019-12-31","codename":"Carbon"},"v9":{"start":"2017-10-01","maintenance":"2018-04-01","end":"2018-06-30"},"v10":{"start":"2018-04-24","lts":"2018-10-30","maintenance":"2020-05-19","end":"2021-04-30","codename":"Dubnium"},"v11":{"start":"2018-10-23","maintenance":"2019-04-22","end":"2019-06-01"},"v12":{"start":"2019-04-23","lts":"2019-10-21","maintenance":"2020-11-30","end":"2022-04-30","codename":"Erbium"},"v13":{"start":"2019-10-22","maintenance":"2020-04-01","end":"2020-06-01"},"v14":{"start":"2020-04-21","lts":"2020-10-27","maintenance":"2021-10-19","end":"2023-04-30","codename":"Fermium"},"v15":{"start":"2020-10-20","maintenance":"2021-04-01","end":"2021-06-01"},"v16":{"start":"2021-04-20","lts":"2021-10-26","maintenance":"2022-10-18","end":"2023-09-11","codename":"Gallium"},"v17":{"start":"2021-10-19","maintenance":"2022-04-01","end":"2022-06-01"},"v18":{"start":"2022-04-19","lts":"2022-10-25","maintenance":"2023-10-18","end":"2025-04-30","codename":"Hydrogen"},"v19":{"start":"2022-10-18","maintenance":"2023-04-01","end":"2023-06-01"},"v20":{"start":"2023-04-18","lts":"2023-10-24","maintenance":"2024-10-22","end":"2026-04-30","codename":"Iron"},"v21":{"start":"2023-10-17","maintenance":"2024-04-01","end":"2024-06-01"},"v22":{"start":"2024-04-23","lts":"2024-10-29","maintenance":"2025-10-21","end":"2027-04-30","codename":""},"v23":{"start":"2024-10-15","maintenance":"2025-04-01","end":"2025-06-01"},"v24":{"start":"2025-04-22","lts":"2025-10-28","maintenance":"2026-10-20","end":"2028-04-30","codename":""}}');
}, () => {
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.OptionValidator = void 0;
  var n2 = r2(290);
  t2.OptionValidator = class {
    constructor(e3) {
      this.descriptor = e3;
    }
    validateTopLevelOptions(e3, t3) {
      const r3 = Object.keys(t3);
      for (const t4 of Object.keys(e3)) if (!r3.includes(t4)) throw new Error(this.formatMessage(`'${t4}' is not a valid top-level option.
- Did you mean '${(0, n2.findSuggestion)(t4, r3)}'?`));
    }
    validateBooleanOption(e3, t3, r3) {
      return void 0 === t3 ? r3 : (this.invariant("boolean" == typeof t3, `'${e3}' option must be a boolean.`), t3);
    }
    validateStringOption(e3, t3, r3) {
      return void 0 === t3 ? r3 : (this.invariant("string" == typeof t3, `'${e3}' option must be a string.`), t3);
    }
    invariant(e3, t3) {
      if (!e3) throw new Error(this.formatMessage(t3));
    }
    formatMessage(e3) {
      return `${this.descriptor}: ${e3}`;
    }
  };
}, (e2, t2, r2) => {
  e2.exports = r2(464);
}, (e2) => {
  e2.exports = JSON.parse('{"es6.module":{"chrome":"61","and_chr":"61","edge":"16","firefox":"60","and_ff":"60","node":"13.2.0","opera":"48","op_mob":"45","safari":"10.1","ios":"10.3","samsung":"8.2","android":"61","electron":"2.0","ios_saf":"10.3"}}');
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.TargetNames = void 0, t2.TargetNames = { node: "node", deno: "deno", chrome: "chrome", opera: "opera", edge: "edge", firefox: "firefox", safari: "safari", ie: "ie", ios: "ios", android: "android", electron: "electron", samsung: "samsung", rhino: "rhino", opera_mobile: "opera_mobile" };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.getInclusionReasons = function(e3, t3, r3) {
    const o2 = r3[e3] || {};
    return Object.keys(t3).reduce((e4, r4) => {
      const a2 = (0, i2.getLowestImplementedVersion)(o2, r4), l = t3[r4];
      if (a2) {
        const t4 = (0, i2.isUnreleasedVersion)(a2, r4);
        (0, i2.isUnreleasedVersion)(l, r4) || !t4 && !n2.lt(l.toString(), (0, i2.semverify)(a2)) || (e4[r4] = (0, s2.prettifyVersion)(l));
      } else e4[r4] = (0, s2.prettifyVersion)(l);
      return e4;
    }, {});
  };
  var n2 = r2(23), s2 = r2(291), i2 = r2(138);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, n3, s3, i3, o3) {
    const l = /* @__PURE__ */ new Set(), c = { compatData: e3, includes: t3, excludes: r3 };
    for (const t4 in e3) if (a2(t4, n3, c)) l.add(t4);
    else if (o3) {
      const e4 = o3.get(t4);
      e4 && l.add(e4);
    }
    return null == s3 || s3.forEach((e4) => !r3.has(e4) && l.add(e4)), null == i3 || i3.forEach((e4) => !t3.has(e4) && l.delete(e4)), l;
  }, t2.isRequired = a2, t2.targetsSupported = o2;
  var n2 = r2(23), s2 = r2(468), i2 = r2(138);
  function o2(e3, t3) {
    const r3 = Object.keys(e3);
    return 0 !== r3.length && 0 === r3.filter((r4) => {
      const s3 = (0, i2.getLowestImplementedVersion)(t3, r4);
      if (!s3) return true;
      const o3 = e3[r4];
      if ((0, i2.isUnreleasedVersion)(o3, r4)) return false;
      if ((0, i2.isUnreleasedVersion)(s3, r4)) return true;
      if (!n2.valid(o3.toString())) throw new Error(`Invalid version passed for target "${r4}": "${o3}". Versions must be in semver format (major.minor.patch)`);
      return n2.gt((0, i2.semverify)(s3), o3.toString());
    }).length;
  }
  function a2(e3, t3) {
    let { compatData: r3 = s2, includes: n3, excludes: i3 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    return !(null != i3 && i3.has(e3) || (null == n3 || !n3.has(e3)) && o2(t3, r3[e3]));
  }
}, (e2, t2, r2) => {
  e2.exports = r2(469);
}, (e2) => {
  e2.exports = JSON.parse('{"transform-unicode-sets-regex":{"chrome":"112","opera":"98","edge":"112","firefox":"116","safari":"tp","node":"20","deno":"1.32","opera_mobile":"75","electron":"24.0"},"bugfix/transform-v8-static-class-fields-redefine-readonly":{"chrome":"98","opera":"84","edge":"98","firefox":"95","safari":"15","node":"12","deno":"1.18","ios":"15","samsung":"11","opera_mobile":"52","electron":"17.0"},"transform-class-static-block":{"chrome":"94","opera":"80","edge":"94","firefox":"93","safari":"16.4","node":"16.11","deno":"1.14","ios":"16.4","samsung":"17","opera_mobile":"66","electron":"15.0"},"proposal-class-static-block":{"chrome":"94","opera":"80","edge":"94","firefox":"93","safari":"16.4","node":"16.11","deno":"1.14","ios":"16.4","samsung":"17","opera_mobile":"66","electron":"15.0"},"transform-private-property-in-object":{"chrome":"91","opera":"77","edge":"91","firefox":"90","safari":"15","node":"16.9","deno":"1.9","ios":"15","samsung":"16","opera_mobile":"64","electron":"13.0"},"proposal-private-property-in-object":{"chrome":"91","opera":"77","edge":"91","firefox":"90","safari":"15","node":"16.9","deno":"1.9","ios":"15","samsung":"16","opera_mobile":"64","electron":"13.0"},"transform-class-properties":{"chrome":"74","opera":"62","edge":"79","firefox":"90","safari":"14.1","node":"12","deno":"1","ios":"14.5","samsung":"11","opera_mobile":"53","electron":"6.0"},"proposal-class-properties":{"chrome":"74","opera":"62","edge":"79","firefox":"90","safari":"14.1","node":"12","deno":"1","ios":"14.5","samsung":"11","opera_mobile":"53","electron":"6.0"},"transform-private-methods":{"chrome":"84","opera":"70","edge":"84","firefox":"90","safari":"15","node":"14.6","deno":"1","ios":"15","samsung":"14","opera_mobile":"60","electron":"10.0"},"proposal-private-methods":{"chrome":"84","opera":"70","edge":"84","firefox":"90","safari":"15","node":"14.6","deno":"1","ios":"15","samsung":"14","opera_mobile":"60","electron":"10.0"},"transform-numeric-separator":{"chrome":"75","opera":"62","edge":"79","firefox":"70","safari":"13","node":"12.5","deno":"1","ios":"13","samsung":"11","rhino":"1.7.14","opera_mobile":"54","electron":"6.0"},"proposal-numeric-separator":{"chrome":"75","opera":"62","edge":"79","firefox":"70","safari":"13","node":"12.5","deno":"1","ios":"13","samsung":"11","rhino":"1.7.14","opera_mobile":"54","electron":"6.0"},"transform-logical-assignment-operators":{"chrome":"85","opera":"71","edge":"85","firefox":"79","safari":"14","node":"15","deno":"1.2","ios":"14","samsung":"14","opera_mobile":"60","electron":"10.0"},"proposal-logical-assignment-operators":{"chrome":"85","opera":"71","edge":"85","firefox":"79","safari":"14","node":"15","deno":"1.2","ios":"14","samsung":"14","opera_mobile":"60","electron":"10.0"},"transform-nullish-coalescing-operator":{"chrome":"80","opera":"67","edge":"80","firefox":"72","safari":"13.1","node":"14","deno":"1","ios":"13.4","samsung":"13","opera_mobile":"57","electron":"8.0"},"proposal-nullish-coalescing-operator":{"chrome":"80","opera":"67","edge":"80","firefox":"72","safari":"13.1","node":"14","deno":"1","ios":"13.4","samsung":"13","opera_mobile":"57","electron":"8.0"},"transform-optional-chaining":{"chrome":"91","opera":"77","edge":"91","firefox":"74","safari":"13.1","node":"16.9","deno":"1.9","ios":"13.4","samsung":"16","opera_mobile":"64","electron":"13.0"},"proposal-optional-chaining":{"chrome":"91","opera":"77","edge":"91","firefox":"74","safari":"13.1","node":"16.9","deno":"1.9","ios":"13.4","samsung":"16","opera_mobile":"64","electron":"13.0"},"transform-json-strings":{"chrome":"66","opera":"53","edge":"79","firefox":"62","safari":"12","node":"10","deno":"1","ios":"12","samsung":"9","rhino":"1.7.14","opera_mobile":"47","electron":"3.0"},"proposal-json-strings":{"chrome":"66","opera":"53","edge":"79","firefox":"62","safari":"12","node":"10","deno":"1","ios":"12","samsung":"9","rhino":"1.7.14","opera_mobile":"47","electron":"3.0"},"transform-optional-catch-binding":{"chrome":"66","opera":"53","edge":"79","firefox":"58","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"proposal-optional-catch-binding":{"chrome":"66","opera":"53","edge":"79","firefox":"58","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"transform-parameters":{"chrome":"49","opera":"36","edge":"18","firefox":"53","safari":"16.3","node":"6","deno":"1","ios":"16.3","samsung":"5","opera_mobile":"36","electron":"0.37"},"transform-async-generator-functions":{"chrome":"63","opera":"50","edge":"79","firefox":"57","safari":"12","node":"10","deno":"1","ios":"12","samsung":"8","opera_mobile":"46","electron":"3.0"},"proposal-async-generator-functions":{"chrome":"63","opera":"50","edge":"79","firefox":"57","safari":"12","node":"10","deno":"1","ios":"12","samsung":"8","opera_mobile":"46","electron":"3.0"},"transform-object-rest-spread":{"chrome":"60","opera":"47","edge":"79","firefox":"55","safari":"11.1","node":"8.3","deno":"1","ios":"11.3","samsung":"8","opera_mobile":"44","electron":"2.0"},"proposal-object-rest-spread":{"chrome":"60","opera":"47","edge":"79","firefox":"55","safari":"11.1","node":"8.3","deno":"1","ios":"11.3","samsung":"8","opera_mobile":"44","electron":"2.0"},"transform-dotall-regex":{"chrome":"62","opera":"49","edge":"79","firefox":"78","safari":"11.1","node":"8.10","deno":"1","ios":"11.3","samsung":"8","opera_mobile":"46","electron":"3.0"},"transform-unicode-property-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"proposal-unicode-property-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"transform-named-capturing-groups-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"transform-async-to-generator":{"chrome":"55","opera":"42","edge":"15","firefox":"52","safari":"11","node":"7.6","deno":"1","ios":"11","samsung":"6","opera_mobile":"42","electron":"1.6"},"transform-exponentiation-operator":{"chrome":"52","opera":"39","edge":"14","firefox":"52","safari":"10.1","node":"7","deno":"1","ios":"10.3","samsung":"6","rhino":"1.7.14","opera_mobile":"41","electron":"1.3"},"transform-template-literals":{"chrome":"41","opera":"28","edge":"13","firefox":"34","safari":"13","node":"4","deno":"1","ios":"13","samsung":"3.4","opera_mobile":"28","electron":"0.21"},"transform-literals":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","deno":"1","ios":"9","samsung":"4","opera_mobile":"32","electron":"0.30"},"transform-function-name":{"chrome":"51","opera":"38","edge":"79","firefox":"53","safari":"10","node":"6.5","deno":"1","ios":"10","samsung":"5","opera_mobile":"41","electron":"1.2"},"transform-arrow-functions":{"chrome":"47","opera":"34","edge":"13","firefox":"43","safari":"10","node":"6","deno":"1","ios":"10","samsung":"5","rhino":"1.7.13","opera_mobile":"34","electron":"0.36"},"transform-block-scoped-functions":{"chrome":"41","opera":"28","edge":"12","firefox":"46","safari":"10","node":"4","deno":"1","ie":"11","ios":"10","samsung":"3.4","opera_mobile":"28","electron":"0.21"},"transform-classes":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-object-super":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-shorthand-properties":{"chrome":"43","opera":"30","edge":"12","firefox":"33","safari":"9","node":"4","deno":"1","ios":"9","samsung":"4","rhino":"1.7.14","opera_mobile":"30","electron":"0.27"},"transform-duplicate-keys":{"chrome":"42","opera":"29","edge":"12","firefox":"34","safari":"9","node":"4","deno":"1","ios":"9","samsung":"3.4","opera_mobile":"29","electron":"0.25"},"transform-computed-properties":{"chrome":"44","opera":"31","edge":"12","firefox":"34","safari":"7.1","node":"4","deno":"1","ios":"8","samsung":"4","opera_mobile":"32","electron":"0.30"},"transform-for-of":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","deno":"1","ios":"10","samsung":"5","opera_mobile":"41","electron":"1.2"},"transform-sticky-regex":{"chrome":"49","opera":"36","edge":"13","firefox":"3","safari":"10","node":"6","deno":"1","ios":"10","samsung":"5","opera_mobile":"36","electron":"0.37"},"transform-unicode-escapes":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","deno":"1","ios":"9","samsung":"4","opera_mobile":"32","electron":"0.30"},"transform-unicode-regex":{"chrome":"50","opera":"37","edge":"13","firefox":"46","safari":"12","node":"6","deno":"1","ios":"12","samsung":"5","opera_mobile":"37","electron":"1.1"},"transform-spread":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-destructuring":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","deno":"1","ios":"10","samsung":"5","opera_mobile":"41","electron":"1.2"},"transform-block-scoping":{"chrome":"50","opera":"37","edge":"14","firefox":"53","safari":"11","node":"6","deno":"1","ios":"11","samsung":"5","opera_mobile":"37","electron":"1.1"},"transform-typeof-symbol":{"chrome":"38","opera":"25","edge":"12","firefox":"36","safari":"9","node":"0.12","deno":"1","ios":"9","samsung":"3","rhino":"1.7.13","opera_mobile":"25","electron":"0.20"},"transform-new-target":{"chrome":"46","opera":"33","edge":"14","firefox":"41","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-regenerator":{"chrome":"50","opera":"37","edge":"13","firefox":"53","safari":"10","node":"6","deno":"1","ios":"10","samsung":"5","opera_mobile":"37","electron":"1.1"},"transform-member-expression-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.4","deno":"1","ie":"9","android":"4","ios":"6","phantom":"1.9","samsung":"1","rhino":"1.7.13","opera_mobile":"12","electron":"0.20"},"transform-property-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.4","deno":"1","ie":"9","android":"4","ios":"6","phantom":"1.9","samsung":"1","rhino":"1.7.13","opera_mobile":"12","electron":"0.20"},"transform-reserved-words":{"chrome":"13","opera":"10.50","edge":"12","firefox":"2","safari":"3.1","node":"0.6","deno":"1","ie":"9","android":"4.4","ios":"6","phantom":"1.9","samsung":"1","rhino":"1.7.13","opera_mobile":"10.1","electron":"0.20"},"transform-export-namespace-from":{"chrome":"72","deno":"1.0","edge":"79","firefox":"80","node":"13.2","opera":"60","opera_mobile":"51","safari":"14.1","ios":"14.5","samsung":"11.0","android":"72","electron":"5.0"},"proposal-export-namespace-from":{"chrome":"72","deno":"1.0","edge":"79","firefox":"80","node":"13.2","opera":"60","opera_mobile":"51","safari":"14.1","ios":"14.5","samsung":"11.0","android":"72","electron":"5.0"}}');
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = { auxiliaryComment: { message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`" }, blacklist: { message: "Put the specific transforms you want in the `plugins` option" }, breakConfig: { message: "This is not a necessary option in Babel 6" }, experimental: { message: "Put the specific transforms you want in the `plugins` option" }, externalHelpers: { message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/" }, extra: { message: "" }, jsxPragma: { message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/" }, loose: { message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option." }, metadataUsedHelpers: { message: "Not required anymore as this is enabled by default" }, modules: { message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules" }, nonStandard: { message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/" }, optional: { message: "Put the specific transforms you want in the `plugins` option" }, sourceMapName: { message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." }, stage: { message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets" }, whitelist: { message: "Put the specific transforms you want in the `plugins` option" }, resolveModuleSource: { version: 6, message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options" }, metadata: { version: 6, message: "Generated plugin metadata is always included in the output result" }, sourceMapTarget: { version: 6, message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." } };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(10);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const r3 = n2().resolve(t3, e3).split(n2().sep);
    return new RegExp(["^", ...r3.map((e4, t4) => {
      const n3 = t4 === r3.length - 1;
      return "**" === e4 ? n3 ? u : c : "*" === e4 ? n3 ? l : a2 : 0 === e4.indexOf("*.") ? o2 + p(e4.slice(1)) + (n3 ? i2 : s2) : p(e4) + (n3 ? i2 : s2);
    })].join(""));
  };
  const s2 = `\\${n2().sep}`, i2 = `(?:${s2}|$)`, o2 = `[^${s2}]+`, a2 = `(?:${o2}${s2})`, l = `(?:${o2}${i2})`, c = `${a2}*?`, u = `${a2}*?${l}?`;
  function p(e3) {
    return e3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ConfigPrinter = t2.ChainFormatter = void 0;
  const s2 = t2.ChainFormatter = { Programmatic: 0, Config: 1 }, i2 = { title(e3, t3, r3) {
    let n3 = "";
    return e3 === s2.Programmatic ? (n3 = "programmatic options", t3 && (n3 += " from " + t3)) : n3 = "config " + r3, n3;
  }, loc(e3, t3) {
    let r3 = "";
    return null != e3 && (r3 += `.overrides[${e3}]`), null != t3 && (r3 += `.env["${t3}"]`), r3;
  }, *optionsAndDescriptors(e3) {
    const t3 = Object.assign({}, e3.options);
    delete t3.overrides, delete t3.env;
    const r3 = [...yield* e3.plugins()];
    r3.length && (t3.plugins = r3.map((e4) => o2(e4)));
    const n3 = [...yield* e3.presets()];
    return n3.length && (t3.presets = [...n3].map((e4) => o2(e4))), JSON.stringify(t3, void 0, 2);
  } };
  function o2(e3) {
    var t3;
    let r3 = null == (t3 = e3.file) ? void 0 : t3.request;
    return null == r3 && ("object" == typeof e3.value ? r3 = e3.value : "function" == typeof e3.value && (r3 = `[Function: ${e3.value.toString().slice(0, 50)} ... ]`)), null == r3 && (r3 = "[Unknown]"), void 0 === e3.options ? r3 : null == e3.name ? [r3, e3.options] : [r3, e3.options, e3.name];
  }
  class a2 {
    constructor() {
      this._stack = [];
    }
    configure(e3, t3, r3) {
      let { callerName: n3, filepath: s3 } = r3;
      return e3 ? (e4, r4, i3) => {
        this._stack.push({ type: t3, callerName: n3, filepath: s3, content: e4, index: r4, envName: i3 });
      } : () => {
      };
    }
    static *format(e3) {
      let t3 = i2.title(e3.type, e3.callerName, e3.filepath);
      const r3 = i2.loc(e3.index, e3.envName);
      return r3 && (t3 += ` ${r3}`), `${t3}
${yield* i2.optionsAndDescriptors(e3.content)}`;
    }
    *output() {
      return 0 === this._stack.length ? "" : (yield* n2().all(this._stack.map((e3) => a2.format(e3)))).join("\n\n");
    }
  }
  t2.ConfigPrinter = a2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.validatePluginObject = function(e3) {
    const t3 = { type: "root", source: "plugin" };
    return Object.keys(e3).forEach((r3) => {
      const n3 = s2[r3];
      if (!n3) {
        const e4 = new Error(`.${r3} is not a valid Plugin property`);
        throw e4.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", e4;
      }
      n3({ type: "option", name: r3, parent: t3 }, e3[r3]);
    }), e3;
  };
  var n2 = r2(293);
  const s2 = { name: n2.assertString, manipulateOptions: n2.assertFunction, pre: n2.assertFunction, post: n2.assertFunction, inherits: n2.assertFunction, visitor: function(e3, t3) {
    const r3 = (0, n2.assertObject)(e3, t3);
    if (r3 && (Object.keys(r3).forEach((e4) => {
      "_exploded" !== e4 && "_verified" !== e4 && function(e5, t4) {
        if (t4 && "object" == typeof t4) Object.keys(t4).forEach((t5) => {
          if ("enter" !== t5 && "exit" !== t5) throw new Error(`.visitor["${e5}"] may only have .enter and/or .exit handlers.`);
        });
        else if ("function" != typeof t4) throw new Error(`.visitor["${e5}"] must be a function`);
      }(e4, r3[e4]);
    }), r3.enter || r3.exit)) throw new Error(`${(0, n2.msg)(e3)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
    return r3;
  }, parserOverride: n2.assertFunction, generatorOverride: n2.assertFunction };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(23);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.makeConfigAPI = o2, t2.makePluginAPI = function(e3, t3) {
    return Object.assign({}, a2(e3, t3), { assumption: (t4) => e3.using((e4) => e4.assumptions[t4]) });
  }, t2.makePresetAPI = a2;
  var s2 = r2(1), i2 = r2(84);
  function o2(e3) {
    return { version: s2.version, cache: e3.simple(), env: (t3) => e3.using((e4) => void 0 === t3 ? e4.envName : "function" == typeof t3 ? (0, i2.assertSimpleType)(t3(e4.envName)) : (Array.isArray(t3) ? t3 : [t3]).some((t4) => {
      if ("string" != typeof t4) throw new Error("Unexpected non-string value");
      return t4 === e4.envName;
    })), async: () => false, caller: (t3) => e3.using((e4) => (0, i2.assertSimpleType)(t3(e4.caller))), assertVersion: l };
  }
  function a2(e3, t3) {
    return Object.assign({}, o2(e3), { targets: () => JSON.parse(e3.using((e4) => JSON.stringify(e4.targets))), addExternalDependency: (e4) => {
      t3.push(e4);
    } });
  }
  function l(e3) {
    if ("number" == typeof e3) {
      if (!Number.isInteger(e3)) throw new Error("Expected string or integer value.");
      e3 = `^${e3}.0.0-0`;
    }
    if ("string" != typeof e3) throw new Error("Expected string or integer value.");
    if (n2().satisfies(s2.version, e3)) return;
    const t3 = Error.stackTraceLimit;
    "number" == typeof t3 && t3 < 25 && (Error.stackTraceLimit = 25);
    const r3 = new Error(`Requires Babel "${e3}", but was loaded with "${s2.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
    throw "number" == typeof t3 && (Error.stackTraceLimit = t3), Object.assign(r3, { code: "BABEL_VERSION_UNSUPPORTED", version: s2.version, range: e3 });
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.transform = void 0, t2.transformAsync = function() {
    return (0, o2.beginHiddenCallStack)(a2.async)(...arguments);
  }, t2.transformSync = function() {
    return (0, o2.beginHiddenCallStack)(a2.sync)(...arguments);
  };
  var s2 = r2(82), i2 = r2(295), o2 = r2(39);
  const a2 = n2()(function* (e3, t3) {
    const r3 = yield* (0, s2.default)(t3);
    return null === r3 ? null : yield* (0, i2.run)(r3, e3);
  });
  t2.transform = function(e3, t3, r3) {
    let n3, s3;
    if ("function" == typeof t3 ? (s3 = t3, n3 = void 0) : (n3 = t3, s3 = r3), void 0 === s3) return (0, o2.beginHiddenCallStack)(a2.sync)(e3, n3);
    (0, o2.beginHiddenCallStack)(a2.errback)(e3, n3, s3);
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  class r2 {
    constructor(e3, t3, r3) {
      this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0, this.key = t3, this.file = e3, this.opts = r3 || {}, this.cwd = e3.opts.cwd, this.filename = e3.opts.filename;
    }
    set(e3, t3) {
      this._map.set(e3, t3);
    }
    get(e3) {
      return this._map.get(e3);
    }
    availableHelper(e3, t3) {
      return this.file.availableHelper(e3, t3);
    }
    addHelper(e3) {
      return this.file.addHelper(e3);
    }
    buildCodeFrameError(e3, t3, r3) {
      return this.file.buildCodeFrameError(e3, t3, r3);
    }
  }
  t2.default = r2, r2.prototype.getModuleName = function() {
    return this.file.getModuleName();
  }, r2.prototype.addImport = function() {
    this.file.addImport();
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(14);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function() {
    return i2 || (i2 = new s2.default(Object.assign({}, o2, { visitor: n2().default.explode(o2.visitor) }), {})), i2;
  };
  var s2 = r2(135);
  let i2;
  const o2 = { name: "internal.blockHoist", visitor: { Block: { exit(e3) {
    let { node: t3 } = e3;
    const { body: r3 } = t3;
    let n3 = Math.pow(2, 30) - 1, s3 = false;
    for (let e4 = 0; e4 < r3.length; e4++) {
      const t4 = a2(r3[e4]);
      if (t4 > n3) {
        s3 = true;
        break;
      }
      n3 = t4;
    }
    s3 && (t3.body = function(e4) {
      const t4 = /* @__PURE__ */ Object.create(null);
      for (let r5 = 0; r5 < e4.length; r5++) {
        const n5 = e4[r5], s4 = a2(n5);
        (t4[s4] || (t4[s4] = [])).push(n5);
      }
      const r4 = Object.keys(t4).map((e5) => +e5).sort((e5, t5) => t5 - e5);
      let n4 = 0;
      for (const s4 of r4) {
        const r5 = t4[s4];
        for (const t5 of r5) e4[n4++] = t5;
      }
      return e4;
    }(r3.slice()));
  } } } };
  function a2(e3) {
    const t3 = null == e3 ? void 0 : e3._blockHoist;
    return null == t3 ? 1 : true === t3 ? 2 : t3;
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(479);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2() {
    const e3 = r2(10);
    return s2 = function() {
      return e3;
    }, e3;
  }
  function i2() {
    const e3 = r2(61);
    return i2 = function() {
      return e3;
    }, e3;
  }
  function o2() {
    const e3 = r2(0);
    return o2 = function() {
      return e3;
    }, e3;
  }
  function a2() {
    const e3 = r2(480);
    return a2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function* (e3, t3, r3, i3) {
    if (r3 = `${r3 || ""}`, i3) {
      if ("Program" === i3.type) i3 = p(i3, [], []);
      else if ("File" !== i3.type) throw new Error("AST root must be a Program or File node");
      t3.cloneInputAst && (i3 = (0, u.default)(i3));
    } else i3 = yield* (0, c.default)(e3, t3, r3);
    let o3 = null;
    if (false !== t3.inputSourceMap) {
      if ("object" == typeof t3.inputSourceMap && (o3 = a2().fromObject(t3.inputSourceMap)), !o3) {
        const e4 = g(h, i3);
        if (e4) try {
          o3 = a2().fromComment("//" + e4);
        } catch (e5) {
          f("discarding unknown inline input sourcemap");
        }
      }
      if (!o3) {
        const e4 = g(m, i3);
        if ("string" == typeof t3.filename && e4) try {
          const r4 = m.exec(e4), i4 = n2().readFileSync(s2().resolve(s2().dirname(t3.filename), r4[1]), "utf8");
          o3 = a2().fromJSON(i4);
        } catch (e5) {
          f("discarding unknown file input sourcemap", e5);
        }
        else e4 && f("discarding un-loadable file input sourcemap");
      }
    }
    return new l.default(t3, { code: r3, ast: i3, inputMap: o3 });
  };
  var l = r2(95), c = r2(297), u = r2(482);
  const { file: p, traverseFast: d } = o2(), f = i2()("babel:transform:file"), h = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/, m = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
  function y(e3, t3, r3) {
    return t3 && (t3 = t3.filter((t4) => {
      let { value: n3 } = t4;
      return !e3.test(n3) || (r3 = n3, false);
    })), [t3, r3];
  }
  function g(e3, t3) {
    let r3 = null;
    return d(t3, (t4) => {
      [t4.leadingComments, r3] = y(e3, t4.leadingComments, r3), [t4.innerComments, r3] = y(e3, t4.innerComments, r3), [t4.trailingComments, r3] = y(e3, t4.trailingComments, r3);
    }), r3;
  }
}, () => {
}, () => {
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, s2) {
    let i2 = `Support for the experimental syntax '${e3}' isn't currently enabled (${t3.line}:${t3.column + 1}):

` + s2;
    const o2 = r2[e3];
    if (o2) {
      const { syntax: e4, transform: t4 } = o2;
      if (e4) {
        const r3 = n2(e4);
        i2 += t4 ? `

Add ${n2(t4)} to the '${t4.name.startsWith("@babel/plugin") ? "plugins" : "presets"}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${r3} to the 'plugins' section to enable parsing.` : `

Add ${r3} to the 'plugins' section of your Babel config to enable parsing.`;
      }
    }
    return i2;
  };
  const r2 = { asyncDoExpressions: { syntax: { name: "@babel/plugin-syntax-async-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions" } }, decimal: { syntax: { name: "@babel/plugin-syntax-decimal", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal" } }, decorators: { syntax: { name: "@babel/plugin-syntax-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators" }, transform: { name: "@babel/plugin-proposal-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators" } }, doExpressions: { syntax: { name: "@babel/plugin-syntax-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions" }, transform: { name: "@babel/plugin-proposal-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions" } }, exportDefaultFrom: { syntax: { name: "@babel/plugin-syntax-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from" }, transform: { name: "@babel/plugin-proposal-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from" } }, flow: { syntax: { name: "@babel/plugin-syntax-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow" }, transform: { name: "@babel/preset-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow" } }, functionBind: { syntax: { name: "@babel/plugin-syntax-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind" }, transform: { name: "@babel/plugin-proposal-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind" } }, functionSent: { syntax: { name: "@babel/plugin-syntax-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent" }, transform: { name: "@babel/plugin-proposal-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent" } }, jsx: { syntax: { name: "@babel/plugin-syntax-jsx", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx" }, transform: { name: "@babel/preset-react", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react" } }, importAttributes: { syntax: { name: "@babel/plugin-syntax-import-attributes", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes" } }, pipelineOperator: { syntax: { name: "@babel/plugin-syntax-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator" }, transform: { name: "@babel/plugin-proposal-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator" } }, recordAndTuple: { syntax: { name: "@babel/plugin-syntax-record-and-tuple", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple" } }, throwExpressions: { syntax: { name: "@babel/plugin-syntax-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions" }, transform: { name: "@babel/plugin-proposal-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions" } }, typescript: { syntax: { name: "@babel/plugin-syntax-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript" }, transform: { name: "@babel/preset-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript" } } };
  Object.assign(r2, { asyncGenerators: { syntax: { name: "@babel/plugin-syntax-async-generators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators" }, transform: { name: "@babel/plugin-transform-async-generator-functions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions" } }, classProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateMethods: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-private-methods", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods" } }, classStaticBlock: { syntax: { name: "@babel/plugin-syntax-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block" }, transform: { name: "@babel/plugin-transform-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block" } }, dynamicImport: { syntax: { name: "@babel/plugin-syntax-dynamic-import", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import" } }, exportNamespaceFrom: { syntax: { name: "@babel/plugin-syntax-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from" }, transform: { name: "@babel/plugin-transform-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from" } }, importAssertions: { syntax: { name: "@babel/plugin-syntax-import-assertions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions" } }, importMeta: { syntax: { name: "@babel/plugin-syntax-import-meta", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta" } }, logicalAssignment: { syntax: { name: "@babel/plugin-syntax-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators" }, transform: { name: "@babel/plugin-transform-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators" } }, moduleStringNames: { syntax: { name: "@babel/plugin-syntax-module-string-names", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names" } }, numericSeparator: { syntax: { name: "@babel/plugin-syntax-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator" }, transform: { name: "@babel/plugin-transform-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator" } }, nullishCoalescingOperator: { syntax: { name: "@babel/plugin-syntax-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator" }, transform: { name: "@babel/plugin-transform-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator" } }, objectRestSpread: { syntax: { name: "@babel/plugin-syntax-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread" }, transform: { name: "@babel/plugin-transform-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread" } }, optionalCatchBinding: { syntax: { name: "@babel/plugin-syntax-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding" }, transform: { name: "@babel/plugin-transform-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding" } }, optionalChaining: { syntax: { name: "@babel/plugin-syntax-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining" }, transform: { name: "@babel/plugin-transform-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining" } }, privateIn: { syntax: { name: "@babel/plugin-syntax-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object" }, transform: { name: "@babel/plugin-transform-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object" } }, regexpUnicodeSets: { syntax: { name: "@babel/plugin-syntax-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md" }, transform: { name: "@babel/plugin-transform-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md" } } });
  const n2 = (e3) => {
    let { name: t3, url: r3 } = e3;
    return `${t3} (${r3})`;
  };
}, (e2, t2) => {
  function r2(e3, t3) {
    if (null !== e3) {
      if (t3.has(e3)) return t3.get(e3);
      let n2;
      if (Array.isArray(e3)) {
        n2 = new Array(e3.length), t3.set(e3, n2);
        for (let s2 = 0; s2 < e3.length; s2++) n2[s2] = "object" != typeof e3[s2] ? e3[s2] : r2(e3[s2], t3);
      } else {
        n2 = {}, t3.set(e3, n2);
        const s2 = Object.keys(e3);
        for (let i2 = 0; i2 < s2.length; i2++) {
          const o2 = s2[i2];
          n2[o2] = "object" != typeof e3[o2] ? e3[o2] : r2(e3[o2], t3);
        }
      }
      return n2;
    }
    return e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return "object" != typeof e3 ? e3 : r2(e3, /* @__PURE__ */ new Map());
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(484);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2() {
    const e3 = r2(101);
    return s2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const { opts: r3, ast: o2, code: a2, inputMap: l } = t3, { generatorOpts: c } = r3;
    c.inputSourceMap = null == l ? void 0 : l.toObject();
    const u = [];
    for (const t4 of e3) for (const e4 of t4) {
      const { generatorOverride: t5 } = e4;
      if (t5) {
        const e5 = t5(o2, c, a2, s2().default);
        void 0 !== e5 && u.push(e5);
      }
    }
    let p;
    if (0 === u.length) p = (0, s2().default)(o2, c, a2);
    else {
      if (1 !== u.length) throw new Error("More than one plugin attempted to override codegen.");
      if (p = u[0], "function" == typeof p.then) throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
    }
    let { code: d, decodedMap: f = p.map } = p;
    return p.__mergedMap ? f = Object.assign({}, p.map) : f && (f = l ? (0, i2.default)(l.toObject(), f, c.sourceFileName) : p.map), "inline" !== r3.sourceMaps && "both" !== r3.sourceMaps || (d += "\n" + n2().fromObject(f).toComment()), "inline" === r3.sourceMaps && (f = null), { outputCode: d, outputMap: f };
  };
  var i2 = r2(485);
}, () => {
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(159);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2(e3) {
    return Object.assign({}, e3, { sourceRoot: null });
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    const i2 = r3.replace(/\\/g, "/");
    let o2 = false;
    const a2 = n2()(s2(t3), (t4, r4) => t4 !== i2 || o2 ? null : (o2 = true, r4.source = "", s2(e3)));
    return "string" == typeof e3.sourceRoot && (a2.sourceRoot = e3.sourceRoot), Object.assign({}, a2);
  };
}, () => {
}, () => {
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.transformFile = void 0, t2.transformFileAsync = function() {
    return Promise.reject(new Error("Transforming files is not supported in browsers"));
  }, t2.transformFileSync = function() {
    throw new Error("Transforming files is not supported in browsers");
  }, t2.transformFile = function(e3, t3, r2) {
    "function" == typeof t3 && (r2 = t3), r2(new Error("Transforming files is not supported in browsers"), null);
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.transformFromAst = void 0, t2.transformFromAstAsync = function() {
    return (0, o2.beginHiddenCallStack)(a2.async)(...arguments);
  }, t2.transformFromAstSync = function() {
    return (0, o2.beginHiddenCallStack)(a2.sync)(...arguments);
  };
  var s2 = r2(82), i2 = r2(295), o2 = r2(39);
  const a2 = n2()(function* (e3, t3, r3) {
    const n3 = yield* (0, s2.default)(r3);
    if (null === n3) return null;
    if (!e3) throw new Error("No AST given");
    return yield* (0, i2.run)(n3, t3, e3);
  });
  t2.transformFromAst = function(e3, t3, r3, n3) {
    let s3, i3;
    if ("function" == typeof r3 ? (i3 = r3, s3 = void 0) : (s3 = r3, i3 = n3), void 0 === i3) return (0, o2.beginHiddenCallStack)(a2.sync)(e3, t3, s3);
    (0, o2.beginHiddenCallStack)(a2.errback)(e3, t3, s3, i3);
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.parse = void 0, t2.parseAsync = function() {
    return (0, a2.beginHiddenCallStack)(l.async)(...arguments);
  }, t2.parseSync = function() {
    return (0, a2.beginHiddenCallStack)(l.sync)(...arguments);
  };
  var s2 = r2(82), i2 = r2(297), o2 = r2(296), a2 = r2(39);
  const l = n2()(function* (e3, t3) {
    const r3 = yield* (0, s2.default)(t3);
    return null === r3 ? null : yield* (0, i2.default)(r3.passes, (0, o2.default)(r3), e3);
  });
  t2.parse = function(e3, t3, r3) {
    if ("function" == typeof t3 && (r3 = t3, t3 = void 0), void 0 === r3) return (0, a2.beginHiddenCallStack)(l.sync)(e3, t3);
    (0, a2.beginHiddenCallStack)(l.errback)(e3, t3, r3);
  };
}, (e2, t2, r2) => {
  t2.a = void 0;
  var n2 = r2(16), s2 = r2(68), i2 = r2(251), o2 = r2(1), a2 = r2(492), l = r2(493), c = r2(494);
  t2.a = (0, n2.declare)((e3, t3) => {
    var r3, n3, u;
    e3.assertVersion(7);
    const { strictNamespace: p = false, mjsStrictNamespace: d = p, allowTopLevelThis: f, strict: h, strictMode: m, noInterop: y, importInterop: g, lazy: b = false, allowCommonJSExports: v = true, loose: E = false } = t3, S = null != (r3 = e3.assumption("constantReexports")) ? r3 : E, x = null != (n3 = e3.assumption("enumerableModuleMeta")) ? n3 : E, T = null != (u = e3.assumption("noIncompleteNsImportDetection")) && u;
    if (!("boolean" == typeof b || "function" == typeof b || Array.isArray(b) && b.every((e4) => "string" == typeof e4))) throw new Error(".lazy must be a boolean, array of strings, or a function");
    if ("boolean" != typeof p) throw new Error(".strictNamespace must be a boolean, or undefined");
    if ("boolean" != typeof d) throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
    const w = (e4) => o2.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${e4}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, P = { ReferencedIdentifier(e4) {
      const t4 = e4.node.name;
      if ("module" !== t4 && "exports" !== t4) return;
      const r4 = e4.scope.getBinding(t4);
      this.scope.getBinding(t4) !== r4 || e4.parentPath.isObjectProperty({ value: e4.node }) && e4.parentPath.parentPath.isObjectPattern() || e4.parentPath.isAssignmentExpression({ left: e4.node }) || e4.isAssignmentExpression({ left: e4.node }) || e4.replaceWith(w(t4));
    }, UpdateExpression(e4) {
      const t4 = e4.get("argument");
      if (!t4.isIdentifier()) return;
      const r4 = t4.node.name;
      if ("module" !== r4 && "exports" !== r4) return;
      const n4 = e4.scope.getBinding(r4);
      this.scope.getBinding(r4) === n4 && e4.replaceWith(o2.types.assignmentExpression(e4.node.operator[0] + "=", t4.node, w(r4)));
    }, AssignmentExpression(e4) {
      const t4 = e4.get("left");
      if (t4.isIdentifier()) {
        const r4 = t4.node.name;
        if ("module" !== r4 && "exports" !== r4) return;
        const n4 = e4.scope.getBinding(r4);
        if (this.scope.getBinding(r4) !== n4) return;
        const s3 = e4.get("right");
        s3.replaceWith(o2.types.sequenceExpression([s3.node, w(r4)]));
      } else if (t4.isPattern()) {
        const r4 = t4.getOuterBindingIdentifiers(), n4 = Object.keys(r4).filter((t5) => ("module" === t5 || "exports" === t5) && this.scope.getBinding(t5) === e4.scope.getBinding(t5))[0];
        if (n4) {
          const t5 = e4.get("right");
          t5.replaceWith(o2.types.sequenceExpression([t5.node, w(n4)]));
        }
      }
    } };
    return { name: "transform-modules-commonjs", pre() {
      this.file.set("@babel/plugin-transform-modules-*", "commonjs"), b && (0, c.defineCommonJSHook)(this.file, (0, l.lazyImportsHook)(b));
    }, visitor: { ["CallExpression" + (e3.types.importExpression ? "|ImportExpression" : "")](e4) {
      if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
      if (e4.isCallExpression() && !o2.types.isImport(e4.node.callee)) return;
      let { scope: t4 } = e4;
      do {
        t4.rename("require");
      } while (t4 = t4.parent);
      (0, a2.transformDynamicImport)(e4, y, this.file);
    }, Program: { exit(e4, r4) {
      if (!(0, s2.isModule)(e4)) return;
      e4.scope.rename("exports"), e4.scope.rename("module"), e4.scope.rename("require"), e4.scope.rename("__filename"), e4.scope.rename("__dirname"), v || ((0, i2.default)(e4, /* @__PURE__ */ new Set(["module", "exports"]), false), e4.traverse(P, { scope: e4.scope }));
      let n4 = (0, s2.getModuleName)(this.file.opts, t3);
      n4 && (n4 = o2.types.stringLiteral(n4));
      const a3 = (0, c.makeInvokers)(this.file), { meta: l2, headers: u2 } = (0, s2.rewriteModuleStatementsAndPrepareHeader)(e4, { exportName: "exports", constantReexports: S, enumerableModuleMeta: x, strict: h, strictMode: m, allowTopLevelThis: f, noInterop: y, importInterop: g, wrapReference: a3.wrapReference, getWrapperPayload: a3.getWrapperPayload, esNamespaceOnly: "string" == typeof r4.filename && /\.mjs$/.test(r4.filename) ? d : p, noIncompleteNsImportDetection: T, filename: this.file.opts.filename });
      for (const [t4, r5] of l2.source) {
        const n5 = o2.types.callExpression(o2.types.identifier("require"), [o2.types.stringLiteral(t4)]);
        let i3;
        if ((0, s2.isSideEffectImport)(r5)) {
          if (b && "function" === r5.wrap) throw new Error("Assertion failure");
          i3 = o2.types.expressionStatement(n5);
        } else {
          const t5 = (0, s2.wrapInterop)(e4, n5, r5.interop) || n5;
          if (r5.wrap) {
            const e5 = a3.buildRequireWrapper(r5.name, t5, r5.wrap, r5.referenced);
            if (false === e5) continue;
            i3 = e5;
          }
          null != i3 || (i3 = o2.template.statement.ast`
                var ${r5.name} = ${t5};
              `);
        }
        i3.loc = r5.loc, u2.push(i3), u2.push(...(0, s2.buildNamespaceInitStatements)(l2, r5, S, a3.wrapReference));
      }
      (0, s2.ensureStatementsHoisted)(u2), e4.unshiftContainer("body", u2), e4.get("body").forEach((e5) => {
        -1 !== u2.indexOf(e5.node) && e5.isVariableDeclaration() && e5.scope.registerDeclaration(e5);
      });
    } } } };
  });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.transformDynamicImport = function(e3, t3, r3) {
    const n3 = t3 ? i2 : o2;
    e3.replaceWith((0, s2.buildDynamicImport)(e3.node, true, false, (e4) => n3(e4, r3)));
  };
  var n2 = r2(1), s2 = r2(68);
  const i2 = (e3) => n2.template.expression.ast`require(${e3})`, o2 = (e3, t3) => n2.types.callExpression(t3.addHelper("interopRequireWildcard"), [i2(e3)]);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.lazyImportsHook = void 0;
  var n2 = r2(1), s2 = r2(68);
  t2.lazyImportsHook = (e3) => ({ name: "@babel/plugin-transform-modules-commonjs/lazy", version: "7.23.3", getWrapperPayload: (t3, r3) => (0, s2.isSideEffectImport)(r3) || r3.reexportAll ? null : true === e3 ? /\./.test(t3) ? null : "lazy/function" : Array.isArray(e3) ? -1 === e3.indexOf(t3) ? null : "lazy/function" : "function" == typeof e3 ? e3(t3) ? "lazy/function" : null : void 0, buildRequireWrapper(e4, t3, r3, s3) {
    if ("lazy/function" === r3) return !!s3 && n2.template.statement.ast`
        function ${e4}() {
          const data = ${t3};
          ${e4} = function(){ return data; };
          return data;
        }
      `;
  }, wrapReference(e4, t3) {
    if ("lazy/function" === t3) return n2.types.callExpression(e4, []);
  } });
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.defineCommonJSHook = function(e3, t3) {
    let n3 = e3.get(r2);
    n3 || e3.set(r2, n3 = []), n3.push(t3);
  }, t2.makeInvokers = function(e3) {
    const t3 = e3.get(r2);
    return { getWrapperPayload() {
      for (var e4 = arguments.length, r3 = new Array(e4), s2 = 0; s2 < e4; s2++) r3[s2] = arguments[s2];
      return n2(t3, (e5) => null == e5.getWrapperPayload ? void 0 : e5.getWrapperPayload(...r3));
    }, wrapReference() {
      for (var e4 = arguments.length, r3 = new Array(e4), s2 = 0; s2 < e4; s2++) r3[s2] = arguments[s2];
      return n2(t3, (e5) => null == e5.wrapReference ? void 0 : e5.wrapReference(...r3));
    }, buildRequireWrapper() {
      for (var e4 = arguments.length, r3 = new Array(e4), s2 = 0; s2 < e4; s2++) r3[s2] = arguments[s2];
      return n2(t3, (e5) => null == e5.buildRequireWrapper ? void 0 : e5.buildRequireWrapper(...r3));
    } };
  };
  const r2 = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
  function n2(e3, t3) {
    if (e3) for (const r3 of e3) {
      const e4 = t3(r3);
      if (null != e4) return e4;
    }
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(16), s2 = function(e3, t3) {
    const r3 = [];
    e3.forEach((e4, n3) => {
      (Array.isArray(e4) ? e4[0] : e4) === t3 && r3.unshift(n3);
    });
    for (const t4 of r3) e3.splice(t4, 1);
  };
  t2.default = (0, n2.declare)((e3, t3) => {
    e3.assertVersion(7);
    const { disallowAmbiguousJSXLike: r3, dts: n3 } = t3;
    var { isTSX: i2 } = t3;
    return { name: "syntax-typescript", manipulateOptions(e4, t4) {
      {
        const { plugins: e5 } = t4;
        s2(e5, "flow"), s2(e5, "jsx"), e5.push("objectRestSpread", "classProperties"), i2 && e5.push("jsx");
      }
      t4.plugins.push(["typescript", { disallowAmbiguousJSXLike: r3, dts: n3 }]);
    } };
  });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, f2) {
    let { assertVersion: E2, assumption: O2 } = e3, { loose: D2 } = t3;
    var L;
    E2("2023-05" === r3 || "2023-01" === r3 ? "^7.21.0" : "2021-12" === r3 ? "^7.16.0" : "^7.19.0");
    const M = /* @__PURE__ */ new WeakSet(), B = null != (L = O2("constantSuper")) ? L : D2, R = /* @__PURE__ */ function(e4, t4) {
      function r4(e5, t5, r5) {
        switch (t5.type) {
          case "StringLiteral":
            return n2.types.stringLiteral(t5.value);
          case "NumericLiteral":
          case "BigIntLiteral": {
            const r6 = t5.value + "";
            return e5.get("key").replaceWith(n2.types.stringLiteral(r6)), n2.types.stringLiteral(r6);
          }
          default: {
            const s3 = e5.scope.maybeGenerateMemoised(t5);
            return e5.get("key").replaceWith(n2.types.assignmentExpression("=", s3, I(r5, t5))), n2.types.cloneNode(s3);
          }
        }
      }
      return { VariableDeclarator(r5, n3) {
        const s3 = r5.node.id;
        if ("Identifier" === s3.type) {
          const i3 = (0, o2.skipTransparentExprWrappers)(r5.get("init"));
          if (e4(i3)) {
            const e5 = s3.name;
            t4(i3, n3, e5);
          }
        }
      }, AssignmentExpression(r5, n3) {
        const s3 = r5.node.left;
        if ("Identifier" === s3.type) {
          const i3 = (0, o2.skipTransparentExprWrappers)(r5.get("right"));
          if (e4(i3)) switch (r5.node.operator) {
            case "=":
            case "&&=":
            case "||=":
            case "??=":
              t4(i3, n3, s3.name);
          }
        }
      }, AssignmentPattern(r5, n3) {
        const s3 = r5.node.left;
        if ("Identifier" === s3.type) {
          const i3 = (0, o2.skipTransparentExprWrappers)(r5.get("right"));
          if (e4(i3)) {
            const e5 = s3.name;
            t4(i3, n3, e5);
          }
        }
      }, ObjectExpression(s3, i3) {
        for (const a3 of s3.get("properties")) {
          const { node: s4 } = a3;
          if ("ObjectProperty" !== s4.type) continue;
          const l2 = s4.key, c2 = (0, o2.skipTransparentExprWrappers)(a3.get("value"));
          if (e4(c2)) {
            if (s4.computed) {
              const e5 = r4(a3, l2, i3);
              t4(c2, i3, e5);
            } else if (!k(l2)) if ("Identifier" === l2.type) t4(c2, i3, l2.name);
            else {
              const e5 = n2.types.stringLiteral(l2.value + "");
              t4(c2, i3, e5);
            }
          }
        }
      }, ClassPrivateProperty(r5, s3) {
        const { node: i3 } = r5, a3 = (0, o2.skipTransparentExprWrappers)(r5.get("value"));
        if (e4(a3)) {
          const e5 = n2.types.stringLiteral("#" + i3.key.id.name);
          t4(a3, s3, e5);
        }
      }, ClassAccessorProperty(s3, i3) {
        const { node: a3 } = s3, l2 = a3.key, c2 = (0, o2.skipTransparentExprWrappers)(s3.get("value"));
        if (e4(c2)) if (a3.computed) {
          const e5 = r4(s3, l2, i3);
          t4(c2, i3, e5);
        } else if ("Identifier" === l2.type) t4(c2, i3, l2.name);
        else if ("PrivateName" === l2.type) {
          const e5 = n2.types.stringLiteral("#" + l2.id.name);
          t4(c2, i3, e5);
        } else {
          const e5 = n2.types.stringLiteral(l2.value + "");
          t4(c2, i3, e5);
        }
      }, ClassProperty(s3, i3) {
        const { node: a3 } = s3, l2 = a3.key, c2 = (0, o2.skipTransparentExprWrappers)(s3.get("value"));
        if (e4(c2)) if (a3.computed) {
          const e5 = r4(s3, l2, i3);
          t4(c2, i3, e5);
        } else if ("Identifier" === l2.type) t4(c2, i3, l2.name);
        else {
          const e5 = n2.types.stringLiteral(l2.value + "");
          t4(c2, i3, e5);
        }
      } };
    }(j, F);
    function F(e4, t4, i3) {
      var o3;
      if (M.has(e4)) return;
      const { node: f3 } = e4;
      null != i3 || (i3 = null == (o3 = f3.id) ? void 0 : o3.name);
      const E3 = function(e5, t5, r4, i4, o4, f4) {
        const E4 = e5.get("body.body"), O3 = e5.node.decorators;
        let k2 = false;
        const N2 = /* @__PURE__ */ function(e6) {
          let t6;
          return () => (t6 || (t6 = function(e7) {
            const t7 = [], r5 = /* @__PURE__ */ new Set();
            return e7.traverse({ PrivateName(e8) {
              r5.add(e8.node.id.name);
            } }), () => {
              let e8;
              do {
                a2(t7), e8 = String.fromCharCode(...t7);
              } while (r5.has(e8));
              return n2.types.privateName(n2.types.identifier(e8));
            };
          }(e6)), t6());
        }(e5), D3 = [], j2 = e5.scope.parent, L2 = (e6, t6) => {
          const r5 = j2.generateDeclaredUidIdentifier(t6);
          return D3.push(n2.types.assignmentExpression("=", r5, e6)), n2.types.cloneNode(r5);
        };
        for (const r5 of E4) if (A(r5)) {
          if (r5.node.decorators && r5.node.decorators.length > 0) {
            switch (r5.node.type) {
              case "ClassProperty":
                f4.ClassProperty(r5, t5);
                break;
              case "ClassPrivateProperty":
                f4.ClassPrivateProperty(r5, t5);
                break;
              case "ClassAccessorProperty":
                f4.ClassAccessorProperty(r5, t5);
            }
            k2 = true;
          } else if ("ClassAccessorProperty" === r5.node.type) {
            f4.ClassAccessorProperty(r5, t5);
            const { key: n3, value: s3, static: o5, computed: a3 } = r5.node, u2 = N2(), p2 = l(u2, s3, o5), d2 = r5.get("key"), [h2] = r5.replaceWith(p2);
            c(e5.node.id, h2, a3 && !d2.isConstantExpression() ? L2(I(t5, n3), "computedKey") : n3, u2, i4, a3);
          }
        }
        if (!O3 && !k2) return void (D3.length > 0 && (e5.insertBefore(D3.map((e6) => n2.types.expressionStatement(e6))), e5.scope.crawl()));
        const M2 = [];
        let B2, R2, F2 = false, U = false;
        const $ = /* @__PURE__ */ new Set();
        let V, q, W, G;
        const H = /* @__PURE__ */ new Map(), z = (e6) => {
          const { expression: t6 } = e6;
          if ("2023-05" === i4 && n2.types.isMemberExpression(t6)) {
            let r5;
            n2.types.isSuper(t6.object) || n2.types.isThisExpression(t6.object) ? r5 = L2(n2.types.thisExpression(), "obj") : j2.isStatic(t6.object) ? r5 = t6.object : (r5 = L2(t6.object, "obj"), t6.object = r5), H.set(e6, n2.types.cloneNode(r5));
          }
          j2.isStatic(t6) || (e6.expression = L2(t6, "dec"));
        };
        let K, X = false;
        if (O3) {
          W = j2.generateDeclaredUidIdentifier("initClass"), X = e5.isClassDeclaration(), { id: G, path: e5 } = function(e6, t6) {
            if ("ClassDeclaration" === e6.type) {
              const t7 = e6.node.id, r5 = t7.name, s3 = e6.scope.generateUidIdentifierBasedOnNode(t7), i5 = n2.types.identifier(r5);
              return e6.scope.rename(r5, s3.name), e6.get("id").replaceWith(i5), { id: n2.types.cloneNode(s3), path: e6 };
            }
            {
              let r5;
              e6.node.id ? (t6 = e6.node.id.name, r5 = e6.scope.parent.generateDeclaredUidIdentifier(t6), e6.scope.rename(t6, r5.name)) : r5 = e6.scope.parent.generateDeclaredUidIdentifier("string" == typeof t6 ? t6 : "decorated_class");
              const s3 = n2.types.classExpression("string" == typeof t6 ? n2.types.identifier(t6) : null, e6.node.superClass, e6.node.body), [i5] = e6.replaceWith(n2.types.sequenceExpression([s3, r5]));
              return { id: n2.types.cloneNode(r5), path: i5.get("expressions.0") };
            }
          }(e5, o4), e5.node.decorators = null;
          for (const e6 of O3) z(e6);
        } else e5.node.id || (e5.node.id = e5.scope.generateUidIdentifier("Class")), G = n2.types.cloneNode(e5.node.id);
        let J = false;
        if (k2) for (const o5 of E4) {
          if (!A(o5)) continue;
          const { node: a3 } = o5, f5 = o5.get("decorators"), y2 = Array.isArray(f5) && f5.length > 0;
          if (y2) for (const e6 of f5) z(e6.node);
          const g2 = "computed" in o5.node && true === o5.node.computed;
          g2 && (o5.get("key").isConstantExpression() || (a3.key = L2(I(t5, a3.key), "computedKey")));
          const b2 = v(o5), { key: E5 } = a3, S2 = "PrivateName" === E5.type, x2 = !!o5.node.static;
          let C2 = "computedKey";
          if (S2 ? C2 = E5.id.name : g2 || "Identifier" !== E5.type || (C2 = E5.name), S2 && !x2 && (y2 && (J = true), !n2.types.isClassPrivateProperty(a3) && K || (K = E5)), o5.isClassMethod({ kind: "constructor" }) && (R2 = o5), y2) {
            let a4, y3, v2;
            if (b2 === d) {
              const { value: t6 } = o5.node, r5 = [n2.types.thisExpression()];
              t6 && r5.push(n2.types.cloneNode(t6));
              const s3 = N2(), p2 = o5.scope.parent.generateDeclaredUidIdentifier(`init_${C2}`), d2 = l(s3, n2.types.callExpression(n2.types.cloneNode(p2), r5), x2), [f6] = o5.replaceWith(d2);
              if (S2) {
                y3 = u(s3, i4);
                const e6 = f6.scope.parent.generateDeclaredUidIdentifier(`get_${C2}`), t7 = f6.scope.parent.generateDeclaredUidIdentifier(`set_${C2}`);
                T(f6, E5, e6, t7), a4 = [p2, e6, t7];
              } else c(e5.node.id, f6, E5, s3, i4, g2), a4 = p2;
            } else if (b2 === p) {
              const e6 = o5.scope.parent.generateDeclaredUidIdentifier(`init_${C2}`), t6 = o5.get("value");
              t6.replaceWith(n2.types.callExpression(n2.types.cloneNode(e6), [n2.types.thisExpression(), t6.node].filter((e7) => e7))), a4 = e6, S2 && (y3 = u(E5, i4));
            } else if (S2) {
              a4 = o5.scope.parent.generateDeclaredUidIdentifier(`call_${C2}`), new s2.default({ constantSuper: r4, methodPath: o5, objectRef: G, superRef: e5.node.superClass, file: t5.file, refToPreserve: G }).replace();
              const { params: i5, body: l2, async: c2 } = o5.node;
              if (y3 = [n2.types.functionExpression(void 0, i5.filter(w), l2, c2)], b2 === h || b2 === m) P(o5, n2.types.cloneNode(E5), n2.types.cloneNode(a4), x2);
              else {
                const t6 = o5.node;
                e5.node.body.body.unshift(n2.types.classPrivateProperty(E5, n2.types.cloneNode(a4), [], t6.static)), $.add(E5.id.name), o5.remove();
              }
            }
            v2 = g2 ? n2.types.cloneNode(E5) : "PrivateName" === E5.type ? n2.types.stringLiteral(E5.id.name) : "Identifier" === E5.type ? n2.types.stringLiteral(E5.name) : n2.types.cloneNode(E5), M2.push({ kind: b2, decorators: f5.map((e6) => e6.node.expression), decoratorsThis: f5.map((e6) => H.get(e6.node)), name: v2, isStatic: x2, privateMethods: y3, locals: a4 }), b2 !== p && (x2 ? U = true : F2 = true), o5.node && (o5.node.decorators = null), B2 || x2 || b2 !== p && b2 !== d || (B2 = o5);
          }
        }
        const Y = function(e6, t6) {
          return n2.types.arrayExpression(S(e6).map((e7) => {
            const { decs: r5, hasThis: s3 } = x(e7.decorators, e7.decoratorsThis, t6);
            let i5 = e7.kind;
            return e7.isStatic && (i5 += "2023-05" === t6 ? g : y), s3 && (i5 += b), n2.types.arrayExpression([1 === r5.length ? r5[0] : n2.types.arrayExpression(r5), n2.types.numericLiteral(i5), e7.name, ...e7.privateMethods || []]);
          }));
        }(M2, i4);
        let Q = 0, Z = [];
        if (O3) {
          const { hasThis: e6, decs: t6 } = x(O3.map((e7) => e7.expression), O3.map((e7) => H.get(e7)), i4);
          Q = e6 ? 1 : 0, Z = t6;
        }
        const ee = function(e6) {
          const t6 = [];
          for (const r5 of S(e6)) {
            const { locals: e7 } = r5;
            Array.isArray(e7) ? t6.push(...e7) : void 0 !== e7 && t6.push(e7);
          }
          return t6;
        }(M2);
        if (F2) {
          V = j2.generateDeclaredUidIdentifier("initProto"), ee.push(V);
          const t6 = n2.types.callExpression(n2.types.cloneNode(V), [n2.types.thisExpression()]);
          if (B2) {
            const e6 = B2.get("value"), r5 = [t6];
            e6.node && r5.push(e6.node), e6.replaceWith(n2.types.sequenceExpression(r5));
          } else if (R2) e5.node.superClass ? R2.traverse({ CallExpression: { exit(e6) {
            e6.get("callee").isSuper() && (e6.replaceWith(n2.types.callExpression(n2.types.cloneNode(V), [e6.node])), e6.skip());
          } }, ClassMethod(e6) {
            "constructor" === e6.node.kind && e6.skip();
          } }) : R2.node.body.body.unshift(n2.types.expressionStatement(t6));
          else {
            const r5 = [n2.types.expressionStatement(t6)];
            e5.node.superClass && r5.unshift(n2.types.expressionStatement(n2.types.callExpression(n2.types.super(), [n2.types.spreadElement(n2.types.identifier("args"))]))), e5.node.body.body.unshift(n2.types.classMethod("constructor", n2.types.identifier("constructor"), [n2.types.restElement(n2.types.identifier("args"))], n2.types.blockStatement(r5)));
          }
        }
        U && (q = j2.generateDeclaredUidIdentifier("initStatic"), ee.push(q)), $.size > 0 && e5.traverse({ PrivateName(e6) {
          if (!$.has(e6.node.id.name)) return;
          const t6 = e6.parentPath, r5 = t6.parentPath;
          if ("AssignmentExpression" === r5.node.type && r5.node.left === t6.node || "UpdateExpression" === r5.node.type || "RestElement" === r5.node.type || "ArrayPattern" === r5.node.type || "ObjectProperty" === r5.node.type && r5.node.value === t6.node && "ObjectPattern" === r5.parentPath.type || "ForOfStatement" === r5.node.type && r5.node.left === t6.node) throw e6.buildCodeFrameError(`Decorated private methods are not updatable, but "#${e6.node.id.name}" is updated via this expression.`);
        } });
        const te = [];
        let re = false;
        const ne = W && n2.types.callExpression(n2.types.cloneNode(W), []), se = e5.node;
        if (O3) {
          te.push(G, W);
          const r5 = [];
          let s3 = [];
          if (e5.get("body.body").forEach((e6) => {
            if (e6.isStaticBlock()) return s3.push(e6.node), void e6.remove();
            const t6 = e6.isClassProperty() || e6.isClassPrivateProperty();
            if ((t6 || e6.isClassPrivateMethod()) && e6.node.static) {
              if (t6 && s3.length > 0) {
                const t7 = s3.map(C);
                e6.node.value && t7.push(e6.node.value), e6.node.value = 0 === (i5 = t7).length ? n2.types.unaryExpression("void", n2.types.numericLiteral(0)) : 1 === i5.length ? i5[0] : n2.types.sequenceExpression(i5), s3 = [];
              }
              e6.node.static = false, r5.push(e6.node), e6.remove();
            }
            var i5;
          }), r5.length > 0 || s3.length > 0) {
            const i5 = n2.template.expression.ast`
        class extends ${t5.addHelper("identity")} {}
      `;
            i5.body.body = [n2.types.staticBlock([n2.types.toStatement(se, true) || n2.types.expressionStatement(se)]), ...r5];
            const o5 = [], a3 = n2.types.newExpression(i5, []);
            s3.length > 0 && o5.push(...s3.map(C)), ne && (re = true, o5.push(ne)), o5.length > 0 ? (o5.unshift(n2.types.callExpression(n2.types.super(), [n2.types.cloneNode(G)])), i5.body.body.push(n2.types.classMethod("constructor", n2.types.identifier("constructor"), [], n2.types.blockStatement([n2.types.expressionStatement(n2.types.sequenceExpression(o5))])))) : a3.arguments.push(n2.types.cloneNode(G)), e5.replaceWith(a3);
          }
        }
        !re && ne && e5.node.body.body.push(n2.types.staticBlock([n2.types.expressionStatement(ne)]));
        let { superClass: ie } = se;
        if (ie && "2023-05" === i4) {
          const t6 = e5.scope.maybeGenerateMemoised(ie);
          t6 && (se.superClass = n2.types.assignmentExpression("=", t6, ie), ie = t6);
        }
        return se.body.body.unshift(n2.types.staticBlock([n2.types.expressionStatement(_(ee, te, Y, n2.types.arrayExpression(Z), n2.types.numericLiteral(Q), J ? K : null, "object" == typeof o4 ? o4 : void 0, n2.types.cloneNode(ie), t5, i4)), U && n2.types.expressionStatement(n2.types.callExpression(n2.types.cloneNode(q), [n2.types.thisExpression()]))].filter(Boolean))), e5.insertBefore(D3.map((e6) => n2.types.expressionStatement(e6))), X && e5.insertBefore(n2.types.variableDeclaration("let", [n2.types.variableDeclarator(n2.types.cloneNode(G))])), e5.scope.crawl(), e5;
      }(e4, t4, B, r3, i3, R);
      E3 ? M.add(E3) : M.add(e4);
    }
    return { name: "proposal-decorators", inherits: f2, visitor: Object.assign({ ExportDefaultDeclaration(e4, t4) {
      const { declaration: r4 } = e4.node;
      if ("ClassDeclaration" === (null == r4 ? void 0 : r4.type) && N(r4)) {
        const s3 = !r4.id, o3 = (0, i2.default)(e4);
        s3 && F(o3, t4, n2.types.stringLiteral("default"));
      }
    }, ExportNamedDeclaration(e4) {
      const { declaration: t4 } = e4.node;
      "ClassDeclaration" === (null == t4 ? void 0 : t4.type) && N(t4) && (0, i2.default)(e4);
    }, Class(e4, t4) {
      F(e4, t4, void 0);
    } }, R) };
  };
  var n2 = r2(1), s2 = r2(141), i2 = r2(62), o2 = r2(301);
  function a2(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e3.length - 1;
    if (-1 === t3) return void e3.unshift(65);
    const r3 = e3[t3];
    90 === r3 ? e3[t3] = 97 : 122 === r3 ? (e3[t3] = 65, a2(e3, t3 - 1)) : e3[t3] = r3 + 1;
  }
  function l(e3, t3, r3) {
    return "PrivateName" === e3.type ? n2.types.classPrivateProperty(e3, t3, void 0, r3) : n2.types.classProperty(e3, t3, void 0, void 0, r3);
  }
  function c(e3, t3, r3, s3, i3) {
    let o3 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
    const { static: a3 } = t3.node, l2 = "2023-05" === i3 && a3 ? e3 : n2.types.thisExpression(), c2 = n2.types.blockStatement([n2.types.returnStatement(n2.types.memberExpression(n2.types.cloneNode(l2), n2.types.cloneNode(s3)))]), u2 = n2.types.blockStatement([n2.types.expressionStatement(n2.types.assignmentExpression("=", n2.types.memberExpression(n2.types.cloneNode(l2), n2.types.cloneNode(s3)), n2.types.identifier("v")))]);
    let p2, d2;
    "PrivateName" === r3.type ? (p2 = n2.types.classPrivateMethod("get", n2.types.cloneNode(r3), [], c2, a3), d2 = n2.types.classPrivateMethod("set", n2.types.cloneNode(r3), [n2.types.identifier("v")], u2, a3)) : (p2 = n2.types.classMethod("get", n2.types.cloneNode(r3), [], c2, o3, a3), d2 = n2.types.classMethod("set", n2.types.cloneNode(r3), [n2.types.identifier("v")], u2, o3, a3)), t3.insertAfter(d2), t3.insertAfter(p2);
  }
  function u(e3, t3) {
    return "2023-05" !== t3 && "2023-01" !== t3 ? [n2.template.expression.ast`
        function () {
          return this.${n2.types.cloneNode(e3)};
        }
      `, n2.template.expression.ast`
        function (value) {
          this.${n2.types.cloneNode(e3)} = value;
        }
      `] : [n2.template.expression.ast`
      o => o.${n2.types.cloneNode(e3)}
    `, n2.template.expression.ast`
      (o, v) => o.${n2.types.cloneNode(e3)} = v
    `];
  }
  const p = 0, d = 1, f = 2, h = 3, m = 4, y = 5, g = 8, b = 16;
  function v(e3) {
    switch (e3.node.type) {
      case "ClassProperty":
      case "ClassPrivateProperty":
        return p;
      case "ClassAccessorProperty":
        return d;
      case "ClassMethod":
      case "ClassPrivateMethod":
        return "get" === e3.node.kind ? h : "set" === e3.node.kind ? m : f;
    }
  }
  function E(e3) {
    return "decorators" in e3;
  }
  function S(e3) {
    const t3 = e3.filter(E);
    return [...t3.filter((e4) => e4.isStatic && e4.kind >= d && e4.kind <= m), ...t3.filter((e4) => !e4.isStatic && e4.kind >= d && e4.kind <= m), ...t3.filter((e4) => e4.isStatic && e4.kind === p), ...t3.filter((e4) => !e4.isStatic && e4.kind === p)];
  }
  function x(e3, t3, r3) {
    const s3 = e3.length, i3 = t3.some(Boolean), o3 = [];
    for (let a3 = 0; a3 < s3; a3++) "2023-05" === r3 && i3 && o3.push(t3[a3] || n2.types.unaryExpression("void", n2.types.numericLiteral(0))), o3.push(e3[a3]);
    return { hasThis: i3, decs: o3 };
  }
  function T(e3, t3, r3, s3) {
    e3.insertAfter(n2.types.classPrivateMethod("get", n2.types.cloneNode(t3), [], n2.types.blockStatement([n2.types.returnStatement(n2.types.callExpression(n2.types.cloneNode(r3), [n2.types.thisExpression()]))]))), e3.insertAfter(n2.types.classPrivateMethod("set", n2.types.cloneNode(t3), [n2.types.identifier("v")], n2.types.blockStatement([n2.types.expressionStatement(n2.types.callExpression(n2.types.cloneNode(s3), [n2.types.thisExpression(), n2.types.identifier("v")]))])));
  }
  function w(e3) {
    return "TSParameterProperty" !== e3.type;
  }
  function P(e3, t3, r3, s3) {
    let i3, o3;
    "set" === e3.node.kind ? (i3 = [n2.types.identifier("v")], o3 = [n2.types.expressionStatement(n2.types.callExpression(r3, [n2.types.thisExpression(), n2.types.identifier("v")]))]) : (i3 = [], o3 = [n2.types.returnStatement(n2.types.callExpression(r3, [n2.types.thisExpression()]))]), e3.replaceWith(n2.types.classPrivateMethod(e3.node.kind, n2.types.cloneNode(t3), i3, n2.types.blockStatement(o3), s3));
  }
  function A(e3) {
    const { type: t3 } = e3;
    return "TSDeclareMethod" !== t3 && "TSIndexSignature" !== t3 && "StaticBlock" !== t3;
  }
  function C(e3) {
    return n2.types.callExpression(n2.types.arrowFunctionExpression([], n2.types.blockStatement(e3.body)), []);
  }
  function O(e3, t3) {
    return n2.types.callExpression(e3.addHelper("setFunctionName"), [n2.types.thisExpression(), t3]);
  }
  function I(e3, t3) {
    return n2.types.callExpression(e3.addHelper("toPropertyKey"), [t3]);
  }
  function _(e3, t3, r3, s3, i3, o3, a3, l2, c2, u2) {
    let p2, d2;
    const f2 = [a3 ? O(c2, a3) : n2.types.thisExpression(), r3, s3];
    if ("2021-12" === u2 || "2022-03" === u2 && !c2.availableHelper("applyDecs2203R")) {
      const r4 = n2.types.arrayPattern([...e3, ...t3]), s4 = n2.types.callExpression(c2.addHelper("2021-12" === u2 ? "applyDecs" : "applyDecs2203"), f2);
      return n2.types.assignmentExpression("=", r4, s4);
    }
    return "2023-05" === u2 ? ((o3 || l2 || 0 !== i3.value) && f2.push(i3), o3 ? f2.push(n2.template.expression.ast`
            _ => ${n2.types.cloneNode(o3)} in _
          `) : l2 && f2.push(n2.types.unaryExpression("void", n2.types.numericLiteral(0))), l2 && f2.push(l2), d2 = n2.types.callExpression(c2.addHelper("applyDecs2305"), f2)) : "2023-01" === u2 ? (o3 && f2.push(n2.template.expression.ast`
            _ => ${n2.types.cloneNode(o3)} in _
          `), d2 = n2.types.callExpression(c2.addHelper("applyDecs2301"), f2)) : d2 = n2.types.callExpression(c2.addHelper("applyDecs2203R"), f2), e3.length > 0 ? t3.length > 0 ? p2 = n2.types.objectPattern([n2.types.objectProperty(n2.types.identifier("e"), n2.types.arrayPattern(e3)), n2.types.objectProperty(n2.types.identifier("c"), n2.types.arrayPattern(t3))]) : (p2 = n2.types.arrayPattern(e3), d2 = n2.types.memberExpression(d2, n2.types.identifier("e"), false, false)) : (p2 = n2.types.arrayPattern(t3), d2 = n2.types.memberExpression(d2, n2.types.identifier("c"), false, false)), n2.types.assignmentExpression("=", p2, d2);
  }
  function k(e3) {
    return "Identifier" === e3.type ? "__proto__" === e3.name : "__proto__" === e3.value;
  }
  function N(e3) {
    return e3.decorators && e3.decorators.length > 0;
  }
  function D(e3) {
    switch (e3.type) {
      case "ClassAccessorProperty":
        return true;
      case "ClassMethod":
      case "ClassProperty":
      case "ClassPrivateMethod":
      case "ClassPrivateProperty":
        return N(e3);
      default:
        return false;
    }
  }
  function j(e3) {
    return e3.isClassExpression({ id: null }) && (N(t3 = e3.node) || t3.body.body.some(D));
    var t3;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.buildCheckInRHS = h, t2.buildFieldsInitNodes = function(e3, t3, r3, i3, o3, a3, l2, c2, p2) {
    var d2;
    let f2, h2 = 0;
    const m2 = [], y2 = [];
    let g2 = false;
    const C2 = [];
    let O2 = null;
    const N = n2.types.isIdentifier(t3) ? () => t3 : () => (null != f2 || (f2 = r3[0].scope.generateUidIdentifierBasedOnNode(t3)), f2), D = null != (d2 = e3) ? d2 : r3[0].scope.generateUidIdentifier("class");
    null != e3 || (e3 = n2.types.cloneNode(p2));
    for (const t4 of r3) {
      t4.isClassProperty() && u.assertFieldTransformed(t4);
      const r4 = !(null != n2.types.isStaticBlock && n2.types.isStaticBlock(t4.node)) && t4.node.static, d3 = !r4, f3 = t4.isPrivate(), O3 = !f3, j = t4.isProperty(), L = !j, M = null == t4.isStaticBlock ? void 0 : t4.isStaticBlock();
      switch (r4 && (h2 |= 1), (r4 || L && f3 || M) && (new s2.default({ methodPath: t4, constantSuper: c2, file: o3, refToPreserve: p2, getSuperRef: N, getObjectRef: () => (h2 |= 2, r4 || M ? D : n2.types.memberExpression(D, n2.types.identifier("prototype"))) }).replace(), I(t4, D, p2) && (h2 |= 2)), g2 = false, true) {
        case M: {
          const e4 = t4.node.body;
          1 === e4.length && n2.types.isExpressionStatement(e4[0]) ? m2.push(k(e4[0], t4)) : m2.push(n2.types.inheritsComments(n2.template.statement.ast`(() => { ${e4} })()`, t4.node));
          break;
        }
        case (r4 && f3 && j && l2):
          m2.push(b(n2.types.cloneNode(e3), t4, i3));
          break;
        case (r4 && f3 && j && !l2):
          m2.push(E(t4, i3));
          break;
        case (r4 && O3 && j && a3):
          if (!_(t4.node)) {
            m2.push(T(n2.types.cloneNode(e3), t4));
            break;
          }
        case (r4 && O3 && j && !a3):
          m2.push(w(n2.types.cloneNode(e3), t4, o3));
          break;
        case (d3 && f3 && j && l2):
          y2.push(b(n2.types.thisExpression(), t4, i3));
          break;
        case (d3 && f3 && j && !l2):
          y2.push(v(n2.types.thisExpression(), t4, i3, o3));
          break;
        case (d3 && f3 && L && l2):
          y2.unshift(S(n2.types.thisExpression(), t4, i3)), C2.push(A(t4, i3, l2));
          break;
        case (d3 && f3 && L && !l2):
          y2.unshift(x(n2.types.thisExpression(), t4, i3, o3)), C2.push(A(t4, i3, l2));
          break;
        case (r4 && f3 && L && !l2):
          m2.unshift(E(t4, i3)), C2.push(A(t4, i3, l2));
          break;
        case (r4 && f3 && L && l2):
          m2.unshift(P(n2.types.cloneNode(e3), t4, 0, i3)), C2.push(A(t4, i3, l2));
          break;
        case (d3 && O3 && j && a3):
          y2.push(T(n2.types.thisExpression(), t4));
          break;
        case (d3 && O3 && j && !a3):
          g2 = true, y2.push(w(n2.types.thisExpression(), t4, o3));
          break;
        default:
          throw new Error("Unreachable.");
      }
    }
    return 2 & h2 && null != p2 && (O2 = n2.types.expressionStatement(n2.types.assignmentExpression("=", n2.types.cloneNode(D), n2.types.cloneNode(p2)))), { staticNodes: m2.filter(Boolean), instanceNodes: y2.filter(Boolean), lastInstanceNodeReturnsThis: g2, pureStaticNodes: C2.filter(Boolean), classBindingNode: O2, wrapClass(t4) {
      for (const e4 of r3) e4.node.leadingComments = null, e4.remove();
      return f2 && (t4.scope.push({ id: n2.types.cloneNode(f2) }), t4.set("superClass", n2.types.assignmentExpression("=", f2, t4.node.superClass))), 0 !== h2 && (t4.isClassExpression() ? (t4.scope.push({ id: e3 }), t4.replaceWith(n2.types.assignmentExpression("=", n2.types.cloneNode(e3), t4.node))) : (null == p2 && (t4.node.id = e3), null != O2 && t4.scope.push({ id: D }))), t4;
    } };
  }, t2.buildPrivateNamesMap = function(e3) {
    const t3 = /* @__PURE__ */ new Map();
    for (const r3 of e3) if (r3.isPrivate()) {
      const { name: e4 } = r3.node.key.id, n3 = t3.has(e4) ? t3.get(e4) : { id: r3.scope.generateUidIdentifier(e4), static: r3.node.static, method: !r3.isProperty() };
      r3.isClassPrivateMethod() && ("get" === r3.node.kind ? n3.getId = r3.scope.generateUidIdentifier(`get_${e4}`) : "set" === r3.node.kind ? n3.setId = r3.scope.generateUidIdentifier(`set_${e4}`) : "method" === r3.node.kind && (n3.methodId = r3.scope.generateUidIdentifier(e4))), t3.set(e4, n3);
    }
    return t3;
  }, t2.buildPrivateNamesNodes = function(e3, t3, r3, s3) {
    const i3 = [];
    for (const [o3, a3] of e3) {
      const { static: e4, method: c2, getId: u2, setId: p2 } = a3, d2 = u2 || p2, f2 = n2.types.cloneNode(a3.id);
      let h2;
      t3 ? h2 = n2.types.callExpression(s3.addHelper("classPrivateFieldLooseKey"), [n2.types.stringLiteral(o3)]) : r3 ? h2 = n2.types.callExpression(n2.types.identifier("Symbol"), [n2.types.stringLiteral(o3)]) : e4 || (h2 = n2.types.newExpression(n2.types.identifier(!c2 || d2 ? "WeakMap" : "WeakSet"), [])), h2 && ((0, l.default)(h2), i3.push(n2.template.statement.ast`var ${f2} = ${h2}`));
    }
    return i3;
  }, t2.transformPrivateNamesUsage = function(e3, t3, r3, n3, s3) {
    let { privateFieldsAsProperties: i3, noDocumentAll: a3, innerBinding: l2 } = n3;
    if (!r3.size) return;
    const c2 = t3.get("body"), u2 = i3 ? g : y;
    (0, o2.default)(c2, d, Object.assign({ privateNamesMap: r3, classRef: e3, file: s3 }, u2, { noDocumentAll: a3, innerBinding: l2 })), c2.traverse(m, { privateNamesMap: r3, classRef: e3, file: s3, privateFieldsAsProperties: i3, innerBinding: l2 });
  };
  var n2 = r2(1), s2 = r2(141), i2 = r2(33), o2 = r2(299), a2 = r2(300), l = r2(302), c = r2(301), u = r2(303);
  function p(e3) {
    const t3 = n2.traverse.visitors.merge([Object.assign({}, e3), i2.default]), r3 = Object.assign({}, e3, { Class(e4) {
      const { privateNamesMap: n3 } = this, s3 = e4.get("body.body"), i3 = new Map(n3), o3 = [];
      for (const e5 of s3) {
        if (!e5.isPrivate()) continue;
        const { name: t4 } = e5.node.key.id;
        i3.delete(t4), o3.push(t4);
      }
      o3.length && (e4.get("body").traverse(t3, Object.assign({}, this, { redeclared: o3 })), e4.traverse(r3, Object.assign({}, this, { privateNamesMap: i3 })), e4.skipKey("body"));
    } });
    return r3;
  }
  const d = p({ PrivateName(e3, t3) {
    let { noDocumentAll: r3 } = t3;
    const { privateNamesMap: n3, redeclared: s3 } = this, { node: i3, parentPath: o3 } = e3;
    if (!o3.isMemberExpression({ property: i3 }) && !o3.isOptionalMemberExpression({ property: i3 })) return;
    const { name: a3 } = i3.id;
    n3.has(a3) && (s3 && s3.includes(a3) || this.handle(o3, r3));
  } });
  function f(e3, t3, r3) {
    for (; null != (n3 = t3) && n3.hasBinding(e3) && !t3.bindingIdentifierEquals(e3, r3); ) {
      var n3;
      t3.rename(e3), t3 = t3.parent;
    }
  }
  function h(e3, t3, r3) {
    return r3 || null == t3.availableHelper || !t3.availableHelper("checkInRHS") ? e3 : n2.types.callExpression(t3.addHelper("checkInRHS"), [e3]);
  }
  const m = p({ BinaryExpression(e3, t3) {
    let { file: r3 } = t3;
    const { operator: s3, left: i3, right: o3 } = e3.node;
    if ("in" !== s3) return;
    if (!n2.types.isPrivateName(i3)) return;
    const { privateFieldsAsProperties: a3, privateNamesMap: l2, redeclared: c2 } = this, { name: u2 } = i3.id;
    if (!l2.has(u2)) return;
    if (c2 && c2.includes(u2)) return;
    if (f(this.classRef.name, e3.scope, this.innerBinding), a3) {
      const { id: t4 } = l2.get(u2);
      return void e3.replaceWith(n2.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${h(o3, r3)}, ${n2.types.cloneNode(t4)})
      `);
    }
    const { id: p2, static: d2 } = l2.get(u2);
    d2 ? e3.replaceWith(n2.template.expression.ast`${h(o3, r3)} === ${n2.types.cloneNode(this.classRef)}`) : e3.replaceWith(n2.template.expression.ast`${n2.types.cloneNode(p2)}.has(${h(o3, r3)})`);
  } }), y = { memoise(e3, t3) {
    const { scope: r3 } = e3, { object: n3 } = e3.node, s3 = r3.maybeGenerateMemoised(n3);
    s3 && this.memoiser.set(n3, s3, t3);
  }, receiver(e3) {
    const { object: t3 } = e3.node;
    return this.memoiser.has(t3) ? n2.types.cloneNode(this.memoiser.get(t3)) : n2.types.cloneNode(t3);
  }, get(e3) {
    const { classRef: t3, privateNamesMap: r3, file: s3, innerBinding: i3 } = this, { name: o3 } = e3.node.property.id, { id: a3, static: l2, method: c2, methodId: u2, getId: p2, setId: d2 } = r3.get(o3), h2 = p2 || d2;
    if (l2) {
      const r4 = c2 && !h2 ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
      return f(t3.name, e3.scope, i3), n2.types.callExpression(s3.addHelper(r4), [this.receiver(e3), n2.types.cloneNode(t3), n2.types.cloneNode(a3)]);
    }
    return c2 ? h2 ? !p2 && d2 && s3.availableHelper("writeOnlyError") ? n2.types.sequenceExpression([this.receiver(e3), n2.types.callExpression(s3.addHelper("writeOnlyError"), [n2.types.stringLiteral(`#${o3}`)])]) : n2.types.callExpression(s3.addHelper("classPrivateFieldGet"), [this.receiver(e3), n2.types.cloneNode(a3)]) : n2.types.callExpression(s3.addHelper("classPrivateMethodGet"), [this.receiver(e3), n2.types.cloneNode(a3), n2.types.cloneNode(u2)]) : n2.types.callExpression(s3.addHelper("classPrivateFieldGet"), [this.receiver(e3), n2.types.cloneNode(a3)]);
  }, boundGet(e3) {
    return this.memoise(e3, 1), n2.types.callExpression(n2.types.memberExpression(this.get(e3), n2.types.identifier("bind")), [this.receiver(e3)]);
  }, set(e3, t3) {
    const { classRef: r3, privateNamesMap: s3, file: i3 } = this, { name: o3 } = e3.node.property.id, { id: a3, static: l2, method: c2, setId: u2, getId: p2 } = s3.get(o3);
    if (l2) {
      const s4 = !c2 || p2 || u2 ? "classStaticPrivateFieldSpecSet" : "classStaticPrivateMethodSet";
      return n2.types.callExpression(i3.addHelper(s4), [this.receiver(e3), n2.types.cloneNode(r3), n2.types.cloneNode(a3), t3]);
    }
    return c2 ? u2 ? n2.types.callExpression(i3.addHelper("classPrivateFieldSet"), [this.receiver(e3), n2.types.cloneNode(a3), t3]) : n2.types.sequenceExpression([this.receiver(e3), t3, n2.types.callExpression(i3.addHelper("readOnlyError"), [n2.types.stringLiteral(`#${o3}`)])]) : n2.types.callExpression(i3.addHelper("classPrivateFieldSet"), [this.receiver(e3), n2.types.cloneNode(a3), t3]);
  }, destructureSet(e3) {
    const { classRef: t3, privateNamesMap: r3, file: s3 } = this, { name: i3 } = e3.node.property.id, { id: o3, static: a3 } = r3.get(i3);
    if (a3) {
      try {
        var l2 = s3.addHelper("classStaticPrivateFieldDestructureSet");
      } catch (e4) {
        throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
      }
      return n2.types.memberExpression(n2.types.callExpression(l2, [this.receiver(e3), n2.types.cloneNode(t3), n2.types.cloneNode(o3)]), n2.types.identifier("value"));
    }
    return n2.types.memberExpression(n2.types.callExpression(s3.addHelper("classPrivateFieldDestructureSet"), [this.receiver(e3), n2.types.cloneNode(o3)]), n2.types.identifier("value"));
  }, call(e3, t3) {
    return this.memoise(e3, 1), (0, a2.default)(this.get(e3), this.receiver(e3), t3, false);
  }, optionalCall(e3, t3) {
    return this.memoise(e3, 1), (0, a2.default)(this.get(e3), this.receiver(e3), t3, true);
  }, delete() {
    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
  } }, g = { get(e3) {
    const { privateNamesMap: t3, file: r3 } = this, { object: s3 } = e3.node, { name: i3 } = e3.node.property.id;
    return n2.template.expression`BASE(REF, PROP)[PROP]`({ BASE: r3.addHelper("classPrivateFieldLooseBase"), REF: n2.types.cloneNode(s3), PROP: n2.types.cloneNode(t3.get(i3).id) });
  }, set() {
    throw new Error("private name handler with loose = true don't need set()");
  }, boundGet(e3) {
    return n2.types.callExpression(n2.types.memberExpression(this.get(e3), n2.types.identifier("bind")), [n2.types.cloneNode(e3.node.object)]);
  }, simpleSet(e3) {
    return this.get(e3);
  }, destructureSet(e3) {
    return this.get(e3);
  }, call(e3, t3) {
    return n2.types.callExpression(this.get(e3), t3);
  }, optionalCall(e3, t3) {
    return n2.types.optionalCallExpression(this.get(e3), t3, true);
  }, delete() {
    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
  } };
  function b(e3, t3, r3) {
    const { id: s3 } = r3.get(t3.node.key.id.name), i3 = t3.node.value || t3.scope.buildUndefinedNode();
    return k(n2.template.statement.ast`
      Object.defineProperty(${e3}, ${n2.types.cloneNode(s3)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${i3}
      });
    `, t3);
  }
  function v(e3, t3, r3, s3) {
    const { id: i3 } = r3.get(t3.node.key.id.name), o3 = t3.node.value || t3.scope.buildUndefinedNode();
    if (!s3.availableHelper("classPrivateFieldInitSpec")) return k(n2.template.statement.ast`${n2.types.cloneNode(i3)}.set(${e3}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${o3},
        })`, t3);
    const a3 = s3.addHelper("classPrivateFieldInitSpec");
    return k(n2.template.statement.ast`${a3}(
      ${n2.types.thisExpression()},
      ${n2.types.cloneNode(i3)},
      {
        writable: true,
        value: ${o3}
      },
    )`, t3);
  }
  function E(e3, t3) {
    const r3 = t3.get(e3.node.key.id.name), { id: s3, getId: i3, setId: o3, initAdded: a3 } = r3, l2 = i3 || o3;
    if (!e3.isProperty() && (a3 || !l2)) return;
    if (l2) return t3.set(e3.node.key.id.name, Object.assign({}, r3, { initAdded: true })), k(n2.template.statement.ast`
        var ${n2.types.cloneNode(s3)} = {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${i3 ? i3.name : e3.scope.buildUndefinedNode()},
          set: ${o3 ? o3.name : e3.scope.buildUndefinedNode()}
        }
      `, e3);
    const c2 = e3.node.value || e3.scope.buildUndefinedNode();
    return k(n2.template.statement.ast`
      var ${n2.types.cloneNode(s3)} = {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${c2}
      };
    `, e3);
  }
  function S(e3, t3, r3) {
    const s3 = r3.get(t3.node.key.id.name), { methodId: i3, id: o3, getId: a3, setId: l2, initAdded: c2 } = s3;
    if (!c2) return i3 ? k(n2.template.statement.ast`
        Object.defineProperty(${e3}, ${o3}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${i3.name}
        });
      `, t3) : a3 || l2 ? (r3.set(t3.node.key.id.name, Object.assign({}, s3, { initAdded: true })), k(n2.template.statement.ast`
        Object.defineProperty(${e3}, ${o3}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${a3 ? a3.name : t3.scope.buildUndefinedNode()},
          set: ${l2 ? l2.name : t3.scope.buildUndefinedNode()}
        });
      `, t3)) : void 0;
  }
  function x(e3, t3, r3, s3) {
    const i3 = r3.get(t3.node.key.id.name), { getId: o3, setId: a3, initAdded: l2 } = i3;
    if (!l2) return o3 || a3 ? function(e4, t4, r4, s4) {
      const i4 = r4.get(t4.node.key.id.name), { id: o4, getId: a4, setId: l3 } = i4;
      if (r4.set(t4.node.key.id.name, Object.assign({}, i4, { initAdded: true })), !s4.availableHelper("classPrivateFieldInitSpec")) return k(n2.template.statement.ast`
          ${o4}.set(${e4}, {
            get: ${a4 ? a4.name : t4.scope.buildUndefinedNode()},
            set: ${l3 ? l3.name : t4.scope.buildUndefinedNode()}
          });
        `, t4);
      const c2 = s4.addHelper("classPrivateFieldInitSpec");
      return k(n2.template.statement.ast`${c2}(
      ${n2.types.thisExpression()},
      ${n2.types.cloneNode(o4)},
      {
        get: ${a4 ? a4.name : t4.scope.buildUndefinedNode()},
        set: ${l3 ? l3.name : t4.scope.buildUndefinedNode()}
      },
    )`, t4);
    }(e3, t3, r3, s3) : function(e4, t4, r4, s4) {
      const i4 = r4.get(t4.node.key.id.name), { id: o4 } = i4;
      if (!s4.availableHelper("classPrivateMethodInitSpec")) return k(n2.template.statement.ast`${o4}.add(${e4})`, t4);
      const a4 = s4.addHelper("classPrivateMethodInitSpec");
      return k(n2.template.statement.ast`${a4}(
      ${n2.types.thisExpression()},
      ${n2.types.cloneNode(o4)}
    )`, t4);
    }(e3, t3, r3, s3);
  }
  function T(e3, t3) {
    const { key: r3, computed: s3 } = t3.node, i3 = t3.node.value || t3.scope.buildUndefinedNode();
    return k(n2.types.expressionStatement(n2.types.assignmentExpression("=", n2.types.memberExpression(e3, r3, s3 || n2.types.isLiteral(r3)), i3)), t3);
  }
  function w(e3, t3, r3) {
    const { key: s3, computed: i3 } = t3.node, o3 = t3.node.value || t3.scope.buildUndefinedNode();
    return k(n2.types.expressionStatement(n2.types.callExpression(r3.addHelper("defineProperty"), [e3, i3 || n2.types.isLiteral(s3) ? s3 : n2.types.stringLiteral(s3.name), o3])), t3);
  }
  function P(e3, t3, r3, s3) {
    const i3 = s3.get(t3.node.key.id.name), { id: o3, methodId: a3, getId: l2, setId: c2, initAdded: u2 } = i3;
    if (!u2) return l2 || c2 ? (s3.set(t3.node.key.id.name, Object.assign({}, i3, { initAdded: true })), k(n2.template.statement.ast`
        Object.defineProperty(${e3}, ${o3}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${l2 ? l2.name : t3.scope.buildUndefinedNode()},
          set: ${c2 ? c2.name : t3.scope.buildUndefinedNode()}
        })
      `, t3)) : k(n2.template.statement.ast`
      Object.defineProperty(${e3}, ${o3}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${a3.name}
      });
    `, t3);
  }
  function A(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    const s3 = t3.get(e3.node.key.id.name), { id: i3, methodId: o3, getId: a3, setId: l2, getterDeclared: c2, setterDeclared: u2, static: p2 } = s3, { params: d2, body: f2, generator: h2, async: m2 } = e3.node, y2 = a3 && !c2 && 0 === d2.length, g2 = l2 && !u2 && d2.length > 0;
    let b2 = o3;
    return y2 ? (t3.set(e3.node.key.id.name, Object.assign({}, s3, { getterDeclared: true })), b2 = a3) : g2 ? (t3.set(e3.node.key.id.name, Object.assign({}, s3, { setterDeclared: true })), b2 = l2) : p2 && !r3 && (b2 = i3), k(n2.types.functionDeclaration(n2.types.cloneNode(b2), d2, f2, h2, m2), e3);
  }
  const C = n2.traverse.visitors.merge([{ UnaryExpression(e3) {
    const { node: t3 } = e3;
    if ("delete" === t3.operator) {
      const r3 = (0, c.skipTransparentExprWrapperNodes)(t3.argument);
      n2.types.isThisExpression(r3) && e3.replaceWith(n2.types.booleanLiteral(true));
    }
  }, ThisExpression(e3, t3) {
    t3.needsClassRef = true, e3.replaceWith(n2.types.cloneNode(t3.classRef));
  }, MetaProperty(e3) {
    const { node: t3, scope: r3 } = e3;
    "new" === t3.meta.name && "target" === t3.property.name && e3.replaceWith(r3.buildUndefinedNode());
  } }, i2.default]), O = { ReferencedIdentifier(e3, t3) {
    e3.scope.bindingIdentifierEquals(e3.node.name, t3.innerBinding) && (t3.needsClassRef = true, e3.node.name = t3.classRef.name);
  } };
  function I(e3, t3, r3) {
    var n3;
    const s3 = { classRef: t3, needsClassRef: false, innerBinding: r3 };
    return e3.isMethod() || e3.traverse(C, s3), null != r3 && null != (n3 = s3.classRef) && n3.name && s3.classRef.name !== r3.name && e3.traverse(O, s3), s3.needsClassRef;
  }
  function _(e3) {
    let { key: t3, computed: r3 } = e3;
    return "Identifier" === t3.type ? !r3 && ("name" === t3.name || "length" === t3.name) : "StringLiteral" === t3.type && ("name" === t3.value || "length" === t3.value);
  }
  function k(e3, t3) {
    return n2.types.inheritLeadingComments(e3, t3.node), n2.types.inheritInnerComments(e3, t3.node), e3;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.extractComputedKeys = function(e3, t3, r3) {
    const s3 = [], i3 = { classBinding: e3.node.id && e3.scope.getBinding(e3.node.id.name), file: r3 };
    for (const r4 of t3) {
      const t4 = r4.get("key");
      t4.isReferencedIdentifier() ? a2(t4, i3) : t4.traverse(l, i3);
      const o3 = r4.node;
      if (!t4.isConstantExpression()) {
        const r5 = e3.scope, i4 = n2.types.isIdentifier(t4.node) && r5.hasUid(t4.node.name), a3 = t4.isAssignmentExpression({ operator: "=" }) && n2.types.isIdentifier(t4.node.left) && r5.hasUid(t4.node.left.name);
        if (i4) continue;
        if (a3) s3.push(n2.types.expressionStatement(n2.types.cloneNode(o3.key))), o3.key = n2.types.cloneNode(o3.key.left);
        else {
          const t5 = e3.scope.generateUidIdentifierBasedOnNode(o3.key);
          r5.push({ id: t5, kind: "let" }), s3.push(n2.types.expressionStatement(n2.types.assignmentExpression("=", n2.types.cloneNode(t5), o3.key))), o3.key = n2.types.cloneNode(t5);
        }
      }
    }
    return s3;
  }, t2.injectInitialization = function(e3, t3, r3, s3, a3) {
    if (!r3.length) return;
    const l2 = !!e3.node.superClass;
    if (!t3) {
      const r4 = n2.types.classMethod("constructor", n2.types.identifier("constructor"), [], n2.types.blockStatement([]));
      l2 && (r4.params = [n2.types.restElement(n2.types.identifier("args"))], r4.body.body.push(n2.template.statement.ast`super(...args)`)), [t3] = e3.get("body").unshiftContainer("body", r4);
    }
    if (s3 && s3(o2, { scope: t3.scope }), l2) {
      const e4 = [];
      t3.traverse(i2, e4);
      let s4 = true;
      for (const t4 of e4) if (s4 ? s4 = false : r3 = r3.map((e5) => n2.types.cloneNode(e5)), t4.parentPath.isExpressionStatement()) t4.insertAfter(r3);
      else {
        const e5 = [t4.node, ...r3.map((e6) => n2.types.toExpression(e6))];
        a3 || e5.push(n2.types.thisExpression()), t4.replaceWith(n2.types.sequenceExpression(e5));
      }
    } else t3.get("body").unshiftContainer("body", r3);
  };
  var n2 = r2(1), s2 = r2(33);
  const i2 = n2.traverse.visitors.merge([{ Super(e3) {
    const { node: t3, parentPath: r3 } = e3;
    r3.isCallExpression({ callee: t3 }) && this.push(r3);
  } }, s2.default]), o2 = { "TSTypeAnnotation|TypeAnnotation"(e3) {
    e3.skip();
  }, ReferencedIdentifier(e3, t3) {
    let { scope: r3 } = t3;
    r3.hasOwnBinding(e3.node.name) && (r3.rename(e3.node.name), e3.skip());
  } };
  function a2(e3, t3) {
    if (t3.classBinding && t3.classBinding === e3.scope.getBinding(e3.node.name)) {
      const r3 = t3.file.addHelper("classNameTDZError"), s3 = n2.types.callExpression(r3, [n2.types.stringLiteral(e3.node.name)]);
      e3.replaceWith(n2.types.sequenceExpression([s3, e3.node])), e3.skip();
    }
  }
  const l = { ReferencedIdentifier: a2 };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.FEATURES = void 0, t2.enableFeature = function(e3, t3, r3) {
    let n3;
    u(e3, t3) && !c(e3, t3) || (e3.set(o2, e3.get(o2) | t3), "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" === r3 ? (d(e3, t3, true), e3.set(l, e3.get(l) | t3)) : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" === r3 ? (d(e3, t3, false), e3.set(l, e3.get(l) | t3)) : d(e3, t3, r3));
    for (const [t4, r4] of i2) {
      if (!u(e3, t4)) continue;
      if (c(e3, t4)) continue;
      const r5 = p(e3, t4);
      if (n3 === !r5) throw new Error("'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).");
      n3 = r5;
    }
    if (void 0 !== n3) for (const [t4, r4] of i2) u(e3, t4) && p(e3, t4) !== n3 && d(e3, t4, n3);
  }, t2.isLoose = p, t2.shouldTransform = function(e3, t3) {
    let r3 = null, i3 = null, o3 = null, a3 = null, l2 = null;
    (0, n2.hasOwnDecorators)(e3.node) && (r3 = e3.get("decorators.0"));
    for (const t4 of e3.get("body.body")) !r3 && (0, n2.hasOwnDecorators)(t4.node) && (r3 = t4.get("decorators.0")), !i3 && t4.isClassProperty() && (i3 = t4), !o3 && t4.isClassPrivateProperty() && (o3 = t4), !a3 && null != t4.isClassPrivateMethod && t4.isClassPrivateMethod() && (a3 = t4), !l2 && null != t4.isStaticBlock && t4.isStaticBlock() && (l2 = t4);
    if (r3 && o3) throw o3.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
    if (r3 && a3) throw a3.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
    if (r3 && !u(t3, s2.decorators)) throw e3.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:\n	["@babel/plugin-proposal-decorators", { "version": "legacy" }]\n	["@babel/plugin-transform-class-properties", { "loose": true }]');
    if (a3 && !u(t3, s2.privateMethods)) throw a3.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");
    if ((i3 || o3) && !u(t3, s2.fields) && !u(t3, s2.privateMethods)) throw e3.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");
    if (l2 && !u(t3, s2.staticBlocks)) throw e3.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");
    return !!(r3 || a3 || l2) || !(!i3 && !o3 || !u(t3, s2.fields));
  };
  var n2 = r2(304);
  const s2 = t2.FEATURES = Object.freeze({ fields: 2, privateMethods: 4, decorators: 8, privateIn: 16, staticBlocks: 32 }), i2 = /* @__PURE__ */ new Map([[s2.fields, "@babel/plugin-transform-class-properties"], [s2.privateMethods, "@babel/plugin-transform-private-methods"], [s2.privateIn, "@babel/plugin-transform-private-property-in-object"]]), o2 = "@babel/plugin-class-features/featuresKey", a2 = "@babel/plugin-class-features/looseKey";
  var l = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing", c = function(e3, t3) {
    return !!(e3.get(l) & t3);
  };
  function u(e3, t3) {
    return !!(e3.get(o2) & t3);
  }
  function p(e3, t3) {
    return !!(e3.get(a2) & t3);
  }
  function d(e3, t3, r3) {
    r3 ? e3.set(a2, e3.get(a2) | t3) : e3.set(a2, e3.get(a2) & ~t3), e3.set(l, e3.get(l) & ~t3);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const { name: r3 } = e3.node.id, s2 = e3.parentPath.isExportNamedDeclaration();
    let i2 = s2;
    !i2 && t3.isProgram(e3.parent) && (i2 = e3.parent.body.some((e4) => t3.isExportNamedDeclaration(e4) && "type" !== e4.exportKind && !e4.source && e4.specifiers.some((e5) => t3.isExportSpecifier(e5) && "type" !== e5.exportKind && e5.local.name === r3)));
    const { enumValues: o2 } = (0, n2.translateEnumValues)(e3, t3);
    if (i2) {
      const n3 = t3.objectExpression(o2.map((e4) => {
        let [r4, n4] = e4;
        return t3.objectProperty(t3.isValidIdentifier(r4) ? t3.identifier(r4) : t3.stringLiteral(r4), n4);
      }));
      return void (e3.scope.hasOwnBinding(r3) ? (s2 ? e3.parentPath : e3).replaceWith(t3.expressionStatement(t3.callExpression(t3.memberExpression(t3.identifier("Object"), t3.identifier("assign")), [e3.node.id, n3]))) : (e3.replaceWith(t3.variableDeclaration("var", [t3.variableDeclarator(e3.node.id, n3)])), e3.scope.registerDeclaration(e3)));
    }
    const a2 = new Map(o2);
    e3.scope.path.traverse({ Scope(e4) {
      e4.scope.hasOwnBinding(r3) && e4.skip();
    }, MemberExpression(e4) {
      if (!t3.isIdentifier(e4.node.object, { name: r3 })) return;
      let n3;
      if (e4.node.computed) {
        if (!t3.isStringLiteral(e4.node.property)) return;
        n3 = e4.node.property.value;
      } else {
        if (!t3.isIdentifier(e4.node.property)) return;
        n3 = e4.node.property.name;
      }
      a2.has(n3) && e4.replaceWith(t3.cloneNode(a2.get(n3)));
    } }), e3.remove();
  };
  var n2 = r2(305);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if (e3.node.declare || "StringLiteral" === e3.node.id.type) return void e3.remove();
    if (!t3) throw e3.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    const r3 = e3.node.id.name, o3 = c(e3, n2.types.cloneNode(e3.node, true));
    if (null === o3) {
      const t4 = e3.findParent((e4) => e4.isProgram());
      (0, s2.registerGlobalType)(t4.scope, r3), e3.remove();
    } else e3.scope.hasOwnBinding(r3) ? e3.replaceWith(o3) : e3.scope.registerDeclaration(e3.replaceWithMultiple([i2(r3), o3])[0]);
  };
  var n2 = r2(1), s2 = r2(306);
  function i2(e3) {
    return n2.types.variableDeclaration("let", [n2.types.variableDeclarator(n2.types.identifier(e3))]);
  }
  function o2(e3, t3) {
    return n2.types.memberExpression(n2.types.identifier(e3), n2.types.identifier(t3));
  }
  function a2(e3, t3, r3) {
    if ("const" !== e3.kind) throw r3.file.buildCodeFrameError(e3, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    const { declarations: s3 } = e3;
    if (s3.every((e4) => n2.types.isIdentifier(e4.id))) {
      for (const e4 of s3) e4.init = n2.types.assignmentExpression("=", o2(t3, e4.id.name), e4.init);
      return [e3];
    }
    const i3 = n2.types.getBindingIdentifiers(e3), a3 = [];
    for (const e4 in i3) a3.push(n2.types.assignmentExpression("=", o2(t3, e4), n2.types.cloneNode(i3[e4])));
    return [e3, n2.types.expressionStatement(n2.types.sequenceExpression(a3))];
  }
  function l(e3, t3) {
    return e3.hub.buildError(t3, "Ambient modules cannot be nested in other modules or namespaces.", Error);
  }
  function c(e3, t3, r3) {
    const s3 = /* @__PURE__ */ new Set(), u = t3.id;
    n2.types.assertIdentifier(u);
    const p = e3.scope.generateUid(u.name), d = n2.types.isTSModuleBlock(t3.body) ? t3.body.body : [n2.types.exportNamedDeclaration(t3.body)];
    let f = true;
    for (let t4 = 0; t4 < d.length; t4++) {
      const r4 = d[t4];
      switch (r4.type) {
        case "TSModuleDeclaration": {
          if (!n2.types.isIdentifier(r4.id)) throw l(e3, r4);
          const o3 = c(e3, r4);
          if (null !== o3) {
            f = false;
            const e4 = r4.id.name;
            s3.has(e4) ? d[t4] = o3 : (s3.add(e4), d.splice(t4++, 1, i2(e4), o3));
          }
          continue;
        }
        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration":
          f = false, s3.add(r4.id.name);
          continue;
        case "VariableDeclaration":
          f = false;
          for (const e4 in n2.types.getBindingIdentifiers(r4)) s3.add(e4);
          continue;
        default:
          f && (f = n2.types.isTypeScript(r4));
          continue;
        case "ExportNamedDeclaration":
      }
      if (!("declare" in r4.declaration) || !r4.declaration.declare) switch (r4.declaration.type) {
        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration": {
          f = false;
          const e4 = r4.declaration.id.name;
          s3.add(e4), d.splice(t4++, 1, r4.declaration, n2.types.expressionStatement(n2.types.assignmentExpression("=", o2(p, e4), n2.types.identifier(e4))));
          break;
        }
        case "VariableDeclaration": {
          f = false;
          const n3 = a2(r4.declaration, p, e3.hub);
          d.splice(t4, n3.length, ...n3), t4 += n3.length - 1;
          break;
        }
        case "TSModuleDeclaration": {
          if (!n2.types.isIdentifier(r4.declaration.id)) throw l(e3, r4.declaration);
          const o3 = c(e3, r4.declaration, n2.types.identifier(p));
          if (null !== o3) {
            f = false;
            const e4 = r4.declaration.id.name;
            s3.has(e4) ? d[t4] = o3 : (s3.add(e4), d.splice(t4++, 1, i2(e4), o3));
          } else d.splice(t4, 1), t4--;
        }
      }
    }
    if (f) return null;
    let h = n2.types.objectExpression([]);
    if (r3) {
      const e4 = n2.types.memberExpression(r3, u);
      h = n2.template.expression.ast`
      ${n2.types.cloneNode(e4)} ||
        (${n2.types.cloneNode(e4)} = ${h})
    `;
    }
    return n2.template.statement.ast`
    (function (${n2.types.identifier(p)}) {
      ${d}
    })(${u} || (${n2.types.cloneNode(u)} = ${h}));
  `;
  }
}, (e2, t2, r2) => {
  r2(12), Object.defineProperty(t2, "__esModule", { value: true });
  var n2 = r2(142), s2 = r2(156), i2 = r2(21), o2 = r2(94), a2 = r2(506);
  const l = Symbol(""), c = Symbol(""), u = Symbol(""), p = Symbol(""), d = Symbol(""), f = Symbol(""), h = Symbol(""), m = Symbol(""), y = Symbol(""), g = Symbol(""), b = Symbol(""), v = Symbol(""), E = Symbol(""), S = Symbol(""), x = Symbol(""), T = Symbol(""), w = Symbol(""), P = Symbol(""), A = Symbol(""), C = Symbol(""), O = Symbol(""), I = Symbol(""), _ = Symbol(""), k = Symbol(""), N = Symbol(""), D = Symbol(""), j = Symbol(""), L = Symbol(""), M = Symbol(""), B = Symbol(""), R = Symbol(""), F = Symbol(""), U = Symbol(""), $ = Symbol(""), V = Symbol(""), q = Symbol(""), W = Symbol(""), G = Symbol(""), H = Symbol(""), z = { [l]: "Fragment", [c]: "Teleport", [u]: "Suspense", [p]: "KeepAlive", [d]: "BaseTransition", [f]: "openBlock", [h]: "createBlock", [m]: "createElementBlock", [y]: "createVNode", [g]: "createElementVNode", [b]: "createCommentVNode", [v]: "createTextVNode", [E]: "createStaticVNode", [S]: "resolveComponent", [x]: "resolveDynamicComponent", [T]: "resolveDirective", [w]: "resolveFilter", [P]: "withDirectives", [A]: "renderList", [C]: "renderSlot", [O]: "createSlots", [I]: "toDisplayString", [_]: "mergeProps", [k]: "normalizeClass", [N]: "normalizeStyle", [D]: "normalizeProps", [j]: "guardReactiveProps", [L]: "toHandlers", [M]: "camelize", [B]: "capitalize", [R]: "toHandlerKey", [F]: "setBlockTracking", [U]: "pushScopeId", [$]: "popScopeId", [V]: "withCtx", [q]: "unref", [W]: "isRef", [G]: "withMemo", [H]: "isMemoSame" }, K = { start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 }, source: "" };
  function X(e3) {
    return { type: 0, source: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", children: e3, helpers: /* @__PURE__ */ new Set(), components: [], directives: [], hoists: [], imports: [], cached: 0, temps: 0, codegenNode: void 0, loc: K };
  }
  function J(e3, t3, r3, n3, s3, i3, o3) {
    let a3 = arguments.length > 7 && void 0 !== arguments[7] && arguments[7], l2 = arguments.length > 8 && void 0 !== arguments[8] && arguments[8], c2 = arguments.length > 9 && void 0 !== arguments[9] && arguments[9], u2 = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : K;
    return e3 && (a3 ? (e3.helper(f), e3.helper(le(e3.inSSR, c2))) : e3.helper(ae(e3.inSSR, c2)), o3 && e3.helper(P)), { type: 13, tag: t3, props: r3, children: n3, patchFlag: s3, dynamicProps: i3, directives: o3, isBlock: a3, disableTracking: l2, isComponent: c2, loc: u2 };
  }
  function Y(e3) {
    return { type: 17, loc: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : K, elements: e3 };
  }
  function Q(e3) {
    return { type: 15, loc: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : K, properties: e3 };
  }
  function Z(e3, t3) {
    return { type: 16, loc: K, key: n2.isString(e3) ? ee(e3, true) : e3, value: t3 };
  }
  function ee(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return { type: 4, loc: arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : K, content: e3, isStatic: t3, constType: t3 ? 3 : arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0 };
  }
  function te(e3) {
    return { type: 8, loc: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : K, children: e3 };
  }
  function re(e3) {
    return { type: 14, loc: arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : K, callee: e3, arguments: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [] };
  }
  function ne(e3) {
    return { type: 18, params: e3, returns: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, newline: arguments.length > 2 && void 0 !== arguments[2] && arguments[2], isSlot: arguments.length > 3 && void 0 !== arguments[3] && arguments[3], loc: arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : K };
  }
  function se(e3, t3, r3) {
    return { type: 19, test: e3, consequent: t3, alternate: r3, newline: !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], loc: K };
  }
  function ie(e3, t3) {
    return { type: 20, index: e3, value: t3, isVNode: arguments.length > 2 && void 0 !== arguments[2] && arguments[2], loc: K };
  }
  function oe(e3) {
    return { type: 21, body: e3, loc: K };
  }
  function ae(e3, t3) {
    return e3 || t3 ? y : g;
  }
  function le(e3, t3) {
    return e3 || t3 ? h : m;
  }
  function ce(e3, t3) {
    let { helper: r3, removeHelper: n3, inSSR: s3 } = t3;
    e3.isBlock || (e3.isBlock = true, n3(ae(s3, e3.isComponent)), r3(f), r3(le(s3, e3.isComponent)));
  }
  const ue = new Uint8Array([123, 123]), pe = new Uint8Array([125, 125]);
  function de(e3) {
    return e3 >= 97 && e3 <= 122 || e3 >= 65 && e3 <= 90;
  }
  function fe(e3) {
    return 32 === e3 || 10 === e3 || 9 === e3 || 12 === e3 || 13 === e3;
  }
  function he(e3) {
    return 47 === e3 || 62 === e3 || fe(e3);
  }
  function me(e3) {
    const t3 = new Uint8Array(e3.length);
    for (let r3 = 0; r3 < e3.length; r3++) t3[r3] = e3.charCodeAt(r3);
    return t3;
  }
  const ye = { Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]), CdataEnd: new Uint8Array([93, 93, 62]), CommentEnd: new Uint8Array([45, 45, 62]), ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]), StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]), TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]), TextareaEnd: new Uint8Array([60, 47, 116, 101, 120, 116, 97, 114, 101, 97]) }, ge = { COMPILER_IS_ON_ELEMENT: { message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".', link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html" }, COMPILER_V_BIND_SYNC: { message: (e3) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${e3}.sync\` should be changed to \`v-model:${e3}\`.`, link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html" }, COMPILER_V_BIND_OBJECT_ORDER: { message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.', link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html" }, COMPILER_V_ON_NATIVE: { message: ".native modifier for v-on has been removed as is no longer necessary.", link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html" }, COMPILER_V_IF_V_FOR_PRECEDENCE: { message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.", link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html" }, COMPILER_NATIVE_TEMPLATE: { message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3." }, COMPILER_INLINE_TEMPLATE: { message: '"inline-template" has been removed in Vue 3.', link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html" }, COMPILER_FILTERS: { message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.', link: "https://v3-migration.vuejs.org/breaking-changes/filters.html" } };
  function be(e3, t3) {
    let { compatConfig: r3 } = t3;
    const n3 = r3 && r3[e3];
    return "MODE" === e3 ? n3 || 3 : n3;
  }
  function ve(e3, t3) {
    const r3 = be("MODE", t3), n3 = be(e3, t3);
    return 3 === r3 ? true === n3 : false !== n3;
  }
  function Ee(e3, t3, r3) {
    return ve(e3, t3);
  }
  function Se(e3) {
    throw e3;
  }
  function xe(e3) {
  }
  function Te(e3, t3, r3, n3) {
    const s3 = (r3 || we)[e3] + (n3 || ""), i3 = new SyntaxError(String(s3));
    return i3.code = e3, i3.loc = t3, i3;
  }
  const we = { 0: "Illegal comment.", 1: "CDATA section is allowed only in XML context.", 2: "Duplicate attribute.", 3: "End tag cannot have attributes.", 4: "Illegal '/' in tags.", 5: "Unexpected EOF in tag.", 6: "Unexpected EOF in CDATA section.", 7: "Unexpected EOF in comment.", 8: "Unexpected EOF in script.", 9: "Unexpected EOF in tag.", 10: "Incorrectly closed comment.", 11: "Incorrectly opened comment.", 12: "Illegal tag name. Use '&lt;' to print '<'.", 13: "Attribute value was expected.", 14: "End tag name was expected.", 15: "Whitespace was expected.", 16: "Unexpected '<!--' in comment.", 17: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`, 18: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).", 19: "Attribute name cannot start with '='.", 21: "'<?' is allowed only in XML context.", 20: "Unexpected null character.", 22: "Illegal '/' in tags.", 23: "Invalid end tag.", 24: "Element is missing end tag.", 25: "Interpolation end sign was not found.", 27: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.", 26: "Legal directive name was expected.", 28: "v-if/v-else-if is missing expression.", 29: "v-if/else branches must use unique keys.", 30: "v-else/v-else-if has no adjacent v-if or v-else-if.", 31: "v-for is missing expression.", 32: "v-for has invalid expression.", 33: "<template v-for> key should be placed on the <template> tag.", 34: "v-bind is missing expression.", 35: "v-on is missing expression.", 36: "Unexpected custom directive on <slot> outlet.", 37: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.", 38: "Duplicate slot names found. ", 39: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.", 40: "v-slot can only be used on components or <template> tags.", 41: "v-model is missing expression.", 42: "v-model value must be a valid JavaScript member expression.", 43: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.", 44: "v-model cannot be used on a prop, because local prop bindings are not writable.\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.", 45: "Error parsing JavaScript expression: ", 46: "<KeepAlive> expects exactly one child component.", 51: "@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.", 47: '"prefixIdentifiers" option is not supported in this build of compiler.', 48: "ES module mode is not supported in this build of compiler.", 49: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.', 50: '"scopeId" option is only supported in module mode.', 52: "" };
  function Pe(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : /* @__PURE__ */ Object.create(null);
    const i3 = "Program" === e3.type ? "ExpressionStatement" === e3.body[0].type && e3.body[0].expression : e3;
    o2.walk(e3, { enter(e4, i4) {
      if (i4 && n3.push(i4), i4 && i4.type.startsWith("TS") && !Be.includes(i4.type)) return this.skip();
      if ("Identifier" === e4.type) {
        const o3 = !!s3[e4.name], a3 = Ae(e4, i4, n3);
        (r3 || a3 && !o3) && t3(e4, i4, n3, a3, o3);
      } else "ObjectProperty" === e4.type && "ObjectPattern" === (null == i4 ? void 0 : i4.type) ? e4.inPattern = true : je(e4) ? e4.scopeIds ? e4.scopeIds.forEach((e5) => Ne(e5, s3)) : Ie(e4, (t4) => De(e4, t4, s3)) : "BlockStatement" === e4.type && (e4.scopeIds ? e4.scopeIds.forEach((e5) => Ne(e5, s3)) : _e(e4, (t4) => De(e4, t4, s3)));
    }, leave(e4, t4) {
      if (t4 && n3.pop(), e4 !== i3 && e4.scopeIds) for (const t5 of e4.scopeIds) s3[t5]--, 0 === s3[t5] && delete s3[t5];
    } });
  }
  function Ae(e3, t3, r3) {
    if (!t3) return true;
    if ("arguments" === e3.name) return false;
    if (function(e4, t4, r4) {
      switch (t4.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          return t4.property === e4 ? !!t4.computed : t4.object === e4;
        case "JSXMemberExpression":
          return t4.object === e4;
        case "VariableDeclarator":
          return t4.init === e4;
        case "ArrowFunctionExpression":
          return t4.body === e4;
        case "PrivateName":
        case "LabeledStatement":
        case "CatchClause":
        case "RestElement":
        case "BreakStatement":
        case "ContinueStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ImportAttribute":
        case "JSXAttribute":
        case "ObjectPattern":
        case "ArrayPattern":
        case "MetaProperty":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          return t4.key === e4 && !!t4.computed;
        case "ObjectProperty":
        case "ClassProperty":
        case "TSPropertySignature":
          return t4.key !== e4 || !!t4.computed;
        case "ClassPrivateProperty":
        case "ObjectTypeProperty":
          return t4.key !== e4;
        case "ClassDeclaration":
        case "ClassExpression":
          return t4.superClass === e4;
        case "AssignmentExpression":
        case "AssignmentPattern":
          return t4.right === e4;
        case "ExportSpecifier":
          return t4.local === e4;
        case "TSEnumMember":
          return t4.id !== e4;
      }
      return true;
    }(e3, t3)) return true;
    switch (t3.type) {
      case "AssignmentExpression":
      case "AssignmentPattern":
        return true;
      case "ObjectPattern":
      case "ArrayPattern":
        return Ce(t3, r3);
    }
    return false;
  }
  function Ce(e3, t3) {
    if (e3 && ("ObjectProperty" === e3.type || "ArrayPattern" === e3.type)) {
      let e4 = t3.length;
      for (; e4--; ) {
        const r3 = t3[e4];
        if ("AssignmentExpression" === r3.type) return true;
        if ("ObjectProperty" !== r3.type && !r3.type.endsWith("Pattern")) break;
      }
    }
    return false;
  }
  function Oe(e3) {
    let t3 = e3.length;
    for (; t3--; ) {
      const r3 = e3[t3];
      if ("NewExpression" === r3.type) return true;
      if ("MemberExpression" !== r3.type) break;
    }
    return false;
  }
  function Ie(e3, t3) {
    for (const r3 of e3.params) for (const e4 of ke(r3)) t3(e4);
  }
  function _e(e3, t3) {
    for (const r3 of e3.body) if ("VariableDeclaration" === r3.type) {
      if (r3.declare) continue;
      for (const e4 of r3.declarations) for (const r4 of ke(e4.id)) t3(r4);
    } else if ("FunctionDeclaration" === r3.type || "ClassDeclaration" === r3.type) {
      if (r3.declare || !r3.id) continue;
      t3(r3.id);
    } else if ("ForOfStatement" === r3.type || "ForInStatement" === r3.type || "ForStatement" === r3.type) {
      const e4 = "ForStatement" === r3.type ? r3.init : r3.left;
      if (e4 && "VariableDeclaration" === e4.type) for (const r4 of e4.declarations) for (const e5 of ke(r4.id)) t3(e5);
    }
  }
  function ke(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    switch (e3.type) {
      case "Identifier":
        t3.push(e3);
        break;
      case "MemberExpression":
        let r3 = e3;
        for (; "MemberExpression" === r3.type; ) r3 = r3.object;
        t3.push(r3);
        break;
      case "ObjectPattern":
        for (const r4 of e3.properties) "RestElement" === r4.type ? ke(r4.argument, t3) : ke(r4.value, t3);
        break;
      case "ArrayPattern":
        e3.elements.forEach((e4) => {
          e4 && ke(e4, t3);
        });
        break;
      case "RestElement":
        ke(e3.argument, t3);
        break;
      case "AssignmentPattern":
        ke(e3.left, t3);
    }
    return t3;
  }
  function Ne(e3, t3) {
    e3 in t3 ? t3[e3]++ : t3[e3] = 1;
  }
  function De(e3, t3, r3) {
    const { name: n3 } = t3;
    e3.scopeIds && e3.scopeIds.has(n3) || (Ne(n3, r3), (e3.scopeIds || (e3.scopeIds = /* @__PURE__ */ new Set())).add(n3));
  }
  const je = (e3) => /Function(?:Expression|Declaration)$|Method$/.test(e3.type), Le = (e3) => e3 && ("ObjectProperty" === e3.type || "ObjectMethod" === e3.type) && !e3.computed, Me = (e3, t3) => Le(t3) && t3.key === e3, Be = ["TSAsExpression", "TSTypeAssertion", "TSNonNullExpression", "TSInstantiationExpression", "TSSatisfiesExpression"];
  function Re(e3) {
    return Be.includes(e3.type) ? Re(e3.expression) : e3;
  }
  const Fe = (e3) => 4 === e3.type && e3.isStatic;
  function Ue(e3) {
    switch (e3) {
      case "Teleport":
      case "teleport":
        return c;
      case "Suspense":
      case "suspense":
        return u;
      case "KeepAlive":
      case "keep-alive":
        return p;
      case "BaseTransition":
      case "base-transition":
        return d;
    }
  }
  const $e = /^\d|[^\$\w]/, Ve = (e3) => !$e.test(e3), qe = /[A-Za-z_$\xA0-\uFFFF]/, We = /[\.\?\w$\xA0-\uFFFF]/, Ge = /\s+[.[]\s*|\s*[.[]\s+/g, He = (e3, t3) => {
    try {
      let r3 = i2.parseExpression(e3, { plugins: t3.expressionPlugins });
      return r3 = Re(r3), "MemberExpression" === r3.type || "OptionalMemberExpression" === r3.type || "Identifier" === r3.type && "undefined" !== r3.name;
    } catch (e4) {
      return false;
    }
  }, ze = He;
  function Ke(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t3.length;
    return Xe({ offset: e3.offset, line: e3.line, column: e3.column }, t3, r3);
  }
  function Xe(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t3.length, n3 = 0, s3 = -1;
    for (let e4 = 0; e4 < r3; e4++) 10 === t3.charCodeAt(e4) && (n3++, s3 = e4);
    return e3.offset += r3, e3.line += n3, e3.column = -1 === s3 ? e3.column + r3 : r3 - s3, e3;
  }
  function Je(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    for (let s3 = 0; s3 < e3.props.length; s3++) {
      const i3 = e3.props[s3];
      if (7 === i3.type && (r3 || i3.exp) && (n2.isString(t3) ? i3.name === t3 : t3.test(i3.name))) return i3;
    }
  }
  function Ye(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    for (let s3 = 0; s3 < e3.props.length; s3++) {
      const i3 = e3.props[s3];
      if (6 === i3.type) {
        if (r3) continue;
        if (i3.name === t3 && (i3.value || n3)) return i3;
      } else if ("bind" === i3.name && (i3.exp || n3) && Qe(i3.arg, t3)) return i3;
    }
  }
  function Qe(e3, t3) {
    return !(!e3 || !Fe(e3) || e3.content !== t3);
  }
  function Ze(e3) {
    return 5 === e3.type || 2 === e3.type;
  }
  function et(e3) {
    return 7 === e3.type && "slot" === e3.name;
  }
  function tt(e3) {
    return 1 === e3.type && 3 === e3.tagType;
  }
  function rt(e3) {
    return 1 === e3.type && 2 === e3.tagType;
  }
  const nt = /* @__PURE__ */ new Set([D, j]);
  function st(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    if (e3 && !n2.isString(e3) && 14 === e3.type) {
      const r3 = e3.callee;
      if (!n2.isString(r3) && nt.has(r3)) return st(e3.arguments[0], t3.concat(e3));
    }
    return [e3, t3];
  }
  function it(e3, t3, r3) {
    let s3, i3, o3 = 13 === e3.type ? e3.props : e3.arguments[2], a3 = [];
    if (o3 && !n2.isString(o3) && 14 === o3.type) {
      const e4 = st(o3);
      o3 = e4[0], a3 = e4[1], i3 = a3[a3.length - 1];
    }
    if (null == o3 || n2.isString(o3)) s3 = Q([t3]);
    else if (14 === o3.type) {
      const e4 = o3.arguments[0];
      n2.isString(e4) || 15 !== e4.type ? o3.callee === L ? s3 = re(r3.helper(_), [Q([t3]), o3]) : o3.arguments.unshift(Q([t3])) : ot(t3, e4) || e4.properties.unshift(t3), !s3 && (s3 = o3);
    } else 15 === o3.type ? (ot(t3, o3) || o3.properties.unshift(t3), s3 = o3) : (s3 = re(r3.helper(_), [Q([t3]), o3]), i3 && i3.callee === j && (i3 = a3[a3.length - 2]));
    13 === e3.type ? i3 ? i3.arguments[0] = s3 : e3.props = s3 : i3 ? i3.arguments[0] = s3 : e3.arguments[2] = s3;
  }
  function ot(e3, t3) {
    let r3 = false;
    if (4 === e3.key.type) {
      const n3 = e3.key.content;
      r3 = t3.properties.some((e4) => 4 === e4.key.type && e4.key.content === n3);
    }
    return r3;
  }
  function at(e3, t3) {
    return `_${t3}_${e3.replace(/[^\w]/g, (t4, r3) => "-" === t4 ? "_" : e3.charCodeAt(r3).toString())}`;
  }
  function lt(e3, t3) {
    if (!e3 || 0 === Object.keys(t3).length) return false;
    switch (e3.type) {
      case 1:
        for (let r3 = 0; r3 < e3.props.length; r3++) {
          const n3 = e3.props[r3];
          if (7 === n3.type && (lt(n3.arg, t3) || lt(n3.exp, t3))) return true;
        }
        return e3.children.some((e4) => lt(e4, t3));
      case 11:
        return !!lt(e3.source, t3) || e3.children.some((e4) => lt(e4, t3));
      case 9:
        return e3.branches.some((e4) => lt(e4, t3));
      case 10:
        return !!lt(e3.condition, t3) || e3.children.some((e4) => lt(e4, t3));
      case 4:
        return !e3.isStatic && Ve(e3.content) && !!t3[e3.content];
      case 8:
        return e3.children.some((e4) => n2.isObject(e4) && lt(e4, t3));
      case 5:
      case 12:
        return lt(e3.content, t3);
      default:
        return false;
    }
  }
  function ct(e3) {
    return 14 === e3.type && e3.callee === G ? e3.arguments[1].returns : e3;
  }
  const ut = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, pt = { parseMode: "base", ns: 0, delimiters: ["{{", "}}"], getNamespace: () => 0, isVoidTag: n2.NO, isPreTag: n2.NO, isCustomElement: n2.NO, onError: Se, onWarn: xe, comments: false, prefixIdentifiers: false };
  let dt = pt, ft = null, ht = "", mt = null, yt = null, gt = "", bt = -1, vt = -1, Et = 0, St = false, xt = null;
  const Tt = [], wt = new class {
    constructor(e3, t3) {
      this.stack = e3, this.cbs = t3, this.state = 1, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = 1, this.inRCDATA = false, this.inXML = false, this.inVPre = false, this.newlines = [], this.mode = 0, this.delimiterOpen = ue, this.delimiterClose = pe, this.delimiterIndex = -1, this.currentSequence = void 0, this.sequenceIndex = 0, this.entityDecoder = new s2.EntityDecoder(s2.htmlDecodeTree, (e4, t4) => this.emitCodePoint(e4, t4));
    }
    get inSFCRoot() {
      return 2 === this.mode && 0 === this.stack.length;
    }
    reset() {
      this.state = 1, this.mode = 0, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = 1, this.inRCDATA = false, this.currentSequence = void 0, this.newlines.length = 0, this.delimiterOpen = ue, this.delimiterClose = pe;
    }
    getPos(e3) {
      let t3 = 1, r3 = e3 + 1;
      for (let n3 = this.newlines.length - 1; n3 >= 0; n3--) {
        const s3 = this.newlines[n3];
        if (e3 > s3) {
          t3 = n3 + 2, r3 = e3 - s3;
          break;
        }
      }
      return { column: r3, line: t3, offset: e3 };
    }
    peek() {
      return this.buffer.charCodeAt(this.index + 1);
    }
    stateText(e3) {
      60 === e3 ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = 5, this.sectionStart = this.index) : 38 === e3 ? this.startEntity() : this.inVPre || e3 !== this.delimiterOpen[0] || (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e3));
    }
    stateInterpolationOpen(e3) {
      if (e3 === this.delimiterOpen[this.delimiterIndex]) if (this.delimiterIndex === this.delimiterOpen.length - 1) {
        const e4 = this.index + 1 - this.delimiterOpen.length;
        e4 > this.sectionStart && this.cbs.ontext(this.sectionStart, e4), this.state = 3, this.sectionStart = e4;
      } else this.delimiterIndex++;
      else this.inRCDATA ? (this.state = 32, this.stateInRCDATA(e3)) : (this.state = 1, this.stateText(e3));
    }
    stateInterpolation(e3) {
      e3 === this.delimiterClose[0] && (this.state = 4, this.delimiterIndex = 0, this.stateInterpolationClose(e3));
    }
    stateInterpolationClose(e3) {
      e3 === this.delimiterClose[this.delimiterIndex] ? this.delimiterIndex === this.delimiterClose.length - 1 ? (this.cbs.oninterpolation(this.sectionStart, this.index + 1), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : this.delimiterIndex++ : (this.state = 3, this.stateInterpolation(e3));
    }
    stateSpecialStartSequence(e3) {
      const t3 = this.sequenceIndex === this.currentSequence.length;
      if (t3 ? he(e3) : (32 | e3) === this.currentSequence[this.sequenceIndex]) {
        if (!t3) return void this.sequenceIndex++;
      } else this.inRCDATA = false;
      this.sequenceIndex = 0, this.state = 6, this.stateInTagName(e3);
    }
    stateInRCDATA(e3) {
      if (this.sequenceIndex === this.currentSequence.length) {
        if (62 === e3 || fe(e3)) {
          const t3 = this.index - this.currentSequence.length;
          if (this.sectionStart < t3) {
            const e4 = this.index;
            this.index = t3, this.cbs.ontext(this.sectionStart, t3), this.index = e4;
          }
          return this.sectionStart = t3 + 2, this.stateInClosingTagName(e3), void (this.inRCDATA = false);
        }
        this.sequenceIndex = 0;
      }
      (32 | e3) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : 0 === this.sequenceIndex ? this.currentSequence === ye.TitleEnd || this.currentSequence === ye.TextareaEnd && !this.inSFCRoot ? 38 === e3 ? this.startEntity() : e3 === this.delimiterOpen[0] && (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e3)) : this.fastForwardTo(60) && (this.sequenceIndex = 1) : this.sequenceIndex = Number(60 === e3);
    }
    stateCDATASequence(e3) {
      e3 === ye.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === ye.Cdata.length && (this.state = 28, this.currentSequence = ye.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = 23, this.stateInDeclaration(e3));
    }
    fastForwardTo(e3) {
      for (; ++this.index < this.buffer.length; ) {
        const t3 = this.buffer.charCodeAt(this.index);
        if (10 === t3 && this.newlines.push(this.index), t3 === e3) return true;
      }
      return this.index = this.buffer.length - 1, false;
    }
    stateInCommentLike(e3) {
      e3 === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === ye.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index - 2) : this.cbs.oncomment(this.sectionStart, this.index - 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = 1) : 0 === this.sequenceIndex ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : e3 !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
    }
    startSpecial(e3, t3) {
      this.enterRCDATA(e3, t3), this.state = 31;
    }
    enterRCDATA(e3, t3) {
      this.inRCDATA = true, this.currentSequence = e3, this.sequenceIndex = t3;
    }
    stateBeforeTagName(e3) {
      if (33 === e3) this.state = 22, this.sectionStart = this.index + 1;
      else if (63 === e3) this.state = 24, this.sectionStart = this.index + 1;
      else if (de(e3)) if (this.sectionStart = this.index, 0 === this.mode) this.state = 6;
      else if (this.inSFCRoot) this.state = 34;
      else if (this.inXML) this.state = 6;
      else {
        const t3 = 32 | e3;
        this.state = 116 === t3 ? 30 : 115 === t3 ? 29 : 6;
      }
      else 47 === e3 ? this.state = 8 : (this.state = 1, this.stateText(e3));
    }
    stateInTagName(e3) {
      he(e3) && this.handleTagName(e3);
    }
    stateInSFCRootTagName(e3) {
      if (he(e3)) {
        const t3 = this.buffer.slice(this.sectionStart, this.index);
        "template" !== t3 && this.enterRCDATA(me("</" + t3), 0), this.handleTagName(e3);
      }
    }
    handleTagName(e3) {
      this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e3);
    }
    stateBeforeClosingTagName(e3) {
      fe(e3) || (62 === e3 ? (this.cbs.onerr(14, this.index), this.state = 1, this.sectionStart = this.index + 1) : (this.state = de(e3) ? 9 : 27, this.sectionStart = this.index));
    }
    stateInClosingTagName(e3) {
      (62 === e3 || fe(e3)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = 10, this.stateAfterClosingTagName(e3));
    }
    stateAfterClosingTagName(e3) {
      62 === e3 && (this.state = 1, this.sectionStart = this.index + 1);
    }
    stateBeforeAttrName(e3) {
      62 === e3 ? (this.cbs.onopentagend(this.index), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : 47 === e3 ? (this.state = 7, 62 !== this.peek() && this.cbs.onerr(22, this.index)) : 60 === e3 && 47 === this.peek() ? (this.cbs.onopentagend(this.index), this.state = 5, this.sectionStart = this.index) : fe(e3) || (61 === e3 && this.cbs.onerr(19, this.index), this.handleAttrStart(e3));
    }
    handleAttrStart(e3) {
      118 === e3 && 45 === this.peek() ? (this.state = 13, this.sectionStart = this.index) : 46 === e3 || 58 === e3 || 64 === e3 || 35 === e3 ? (this.cbs.ondirname(this.index, this.index + 1), this.state = 14, this.sectionStart = this.index + 1) : (this.state = 12, this.sectionStart = this.index);
    }
    stateInSelfClosingTag(e3) {
      62 === e3 ? (this.cbs.onselfclosingtag(this.index), this.state = 1, this.sectionStart = this.index + 1, this.inRCDATA = false) : fe(e3) || (this.state = 11, this.stateBeforeAttrName(e3));
    }
    stateInAttrName(e3) {
      61 === e3 || he(e3) ? (this.cbs.onattribname(this.sectionStart, this.index), this.handleAttrNameEnd(e3)) : 34 !== e3 && 39 !== e3 && 60 !== e3 || this.cbs.onerr(17, this.index);
    }
    stateInDirName(e3) {
      61 === e3 || he(e3) ? (this.cbs.ondirname(this.sectionStart, this.index), this.handleAttrNameEnd(e3)) : 58 === e3 ? (this.cbs.ondirname(this.sectionStart, this.index), this.state = 14, this.sectionStart = this.index + 1) : 46 === e3 && (this.cbs.ondirname(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
    }
    stateInDirArg(e3) {
      61 === e3 || he(e3) ? (this.cbs.ondirarg(this.sectionStart, this.index), this.handleAttrNameEnd(e3)) : 91 === e3 ? this.state = 15 : 46 === e3 && (this.cbs.ondirarg(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
    }
    stateInDynamicDirArg(e3) {
      93 === e3 ? this.state = 14 : (61 === e3 || he(e3)) && (this.cbs.ondirarg(this.sectionStart, this.index + 1), this.handleAttrNameEnd(e3), this.cbs.onerr(27, this.index));
    }
    stateInDirModifier(e3) {
      61 === e3 || he(e3) ? (this.cbs.ondirmodifier(this.sectionStart, this.index), this.handleAttrNameEnd(e3)) : 46 === e3 && (this.cbs.ondirmodifier(this.sectionStart, this.index), this.sectionStart = this.index + 1);
    }
    handleAttrNameEnd(e3) {
      this.sectionStart = this.index, this.state = 17, this.cbs.onattribnameend(this.index), this.stateAfterAttrName(e3);
    }
    stateAfterAttrName(e3) {
      61 === e3 ? this.state = 18 : 47 === e3 || 62 === e3 ? (this.cbs.onattribend(0, this.sectionStart), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e3)) : fe(e3) || (this.cbs.onattribend(0, this.sectionStart), this.handleAttrStart(e3));
    }
    stateBeforeAttrValue(e3) {
      34 === e3 ? (this.state = 19, this.sectionStart = this.index + 1) : 39 === e3 ? (this.state = 20, this.sectionStart = this.index + 1) : fe(e3) || (this.sectionStart = this.index, this.state = 21, this.stateInAttrValueNoQuotes(e3));
    }
    handleInAttrValue(e3, t3) {
      e3 === t3 ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(34 === t3 ? 3 : 2, this.index + 1), this.state = 11) : 38 === e3 && this.startEntity();
    }
    stateInAttrValueDoubleQuotes(e3) {
      this.handleInAttrValue(e3, 34);
    }
    stateInAttrValueSingleQuotes(e3) {
      this.handleInAttrValue(e3, 39);
    }
    stateInAttrValueNoQuotes(e3) {
      fe(e3) || 62 === e3 ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(1, this.index), this.state = 11, this.stateBeforeAttrName(e3)) : 34 === e3 || 39 === e3 || 60 === e3 || 61 === e3 || 96 === e3 ? this.cbs.onerr(18, this.index) : 38 === e3 && this.startEntity();
    }
    stateBeforeDeclaration(e3) {
      91 === e3 ? (this.state = 26, this.sequenceIndex = 0) : this.state = 45 === e3 ? 25 : 23;
    }
    stateInDeclaration(e3) {
      (62 === e3 || this.fastForwardTo(62)) && (this.state = 1, this.sectionStart = this.index + 1);
    }
    stateInProcessingInstruction(e3) {
      (62 === e3 || this.fastForwardTo(62)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
    }
    stateBeforeComment(e3) {
      45 === e3 ? (this.state = 28, this.currentSequence = ye.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = 23;
    }
    stateInSpecialComment(e3) {
      (62 === e3 || this.fastForwardTo(62)) && (this.cbs.oncomment(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
    }
    stateBeforeSpecialS(e3) {
      const t3 = 32 | e3;
      t3 === ye.ScriptEnd[3] ? this.startSpecial(ye.ScriptEnd, 4) : t3 === ye.StyleEnd[3] ? this.startSpecial(ye.StyleEnd, 4) : (this.state = 6, this.stateInTagName(e3));
    }
    stateBeforeSpecialT(e3) {
      const t3 = 32 | e3;
      t3 === ye.TitleEnd[3] ? this.startSpecial(ye.TitleEnd, 4) : t3 === ye.TextareaEnd[3] ? this.startSpecial(ye.TextareaEnd, 4) : (this.state = 6, this.stateInTagName(e3));
    }
    startEntity() {
      this.baseState = this.state, this.state = 33, this.entityStart = this.index, this.entityDecoder.startEntity(1 === this.baseState || 32 === this.baseState ? s2.DecodingMode.Legacy : s2.DecodingMode.Attribute);
    }
    stateInEntity() {
      {
        const e3 = this.entityDecoder.write(this.buffer, this.index);
        e3 >= 0 ? (this.state = this.baseState, 0 === e3 && (this.index = this.entityStart)) : this.index = this.buffer.length - 1;
      }
    }
    parse(e3) {
      for (this.buffer = e3; this.index < this.buffer.length; ) {
        const e4 = this.buffer.charCodeAt(this.index);
        switch (10 === e4 && this.newlines.push(this.index), this.state) {
          case 1:
            this.stateText(e4);
            break;
          case 2:
            this.stateInterpolationOpen(e4);
            break;
          case 3:
            this.stateInterpolation(e4);
            break;
          case 4:
            this.stateInterpolationClose(e4);
            break;
          case 31:
            this.stateSpecialStartSequence(e4);
            break;
          case 32:
            this.stateInRCDATA(e4);
            break;
          case 26:
            this.stateCDATASequence(e4);
            break;
          case 19:
            this.stateInAttrValueDoubleQuotes(e4);
            break;
          case 12:
            this.stateInAttrName(e4);
            break;
          case 13:
            this.stateInDirName(e4);
            break;
          case 14:
            this.stateInDirArg(e4);
            break;
          case 15:
            this.stateInDynamicDirArg(e4);
            break;
          case 16:
            this.stateInDirModifier(e4);
            break;
          case 28:
            this.stateInCommentLike(e4);
            break;
          case 27:
            this.stateInSpecialComment(e4);
            break;
          case 11:
            this.stateBeforeAttrName(e4);
            break;
          case 6:
            this.stateInTagName(e4);
            break;
          case 34:
            this.stateInSFCRootTagName(e4);
            break;
          case 9:
            this.stateInClosingTagName(e4);
            break;
          case 5:
            this.stateBeforeTagName(e4);
            break;
          case 17:
            this.stateAfterAttrName(e4);
            break;
          case 20:
            this.stateInAttrValueSingleQuotes(e4);
            break;
          case 18:
            this.stateBeforeAttrValue(e4);
            break;
          case 8:
            this.stateBeforeClosingTagName(e4);
            break;
          case 10:
            this.stateAfterClosingTagName(e4);
            break;
          case 29:
            this.stateBeforeSpecialS(e4);
            break;
          case 30:
            this.stateBeforeSpecialT(e4);
            break;
          case 21:
            this.stateInAttrValueNoQuotes(e4);
            break;
          case 7:
            this.stateInSelfClosingTag(e4);
            break;
          case 23:
            this.stateInDeclaration(e4);
            break;
          case 22:
            this.stateBeforeDeclaration(e4);
            break;
          case 25:
            this.stateBeforeComment(e4);
            break;
          case 24:
            this.stateInProcessingInstruction(e4);
            break;
          case 33:
            this.stateInEntity();
        }
        this.index++;
      }
      this.cleanup(), this.finish();
    }
    cleanup() {
      this.sectionStart !== this.index && (1 === this.state || 32 === this.state && 0 === this.sequenceIndex ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : 19 !== this.state && 20 !== this.state && 21 !== this.state || (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
    }
    finish() {
      33 === this.state && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
    }
    handleTrailingData() {
      const e3 = this.buffer.length;
      this.sectionStart >= e3 || (28 === this.state ? this.currentSequence === ye.CdataEnd ? this.cbs.oncdata(this.sectionStart, e3) : this.cbs.oncomment(this.sectionStart, e3) : 6 === this.state || 11 === this.state || 18 === this.state || 17 === this.state || 12 === this.state || 13 === this.state || 14 === this.state || 15 === this.state || 16 === this.state || 20 === this.state || 19 === this.state || 21 === this.state || 9 === this.state || this.cbs.ontext(this.sectionStart, e3));
    }
    emitCodePoint(e3, t3) {
      1 !== this.baseState && 32 !== this.baseState ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + t3, this.index = this.sectionStart - 1, this.cbs.onattribentity(s2.fromCodePoint(e3), this.entityStart, this.sectionStart)) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + t3, this.index = this.sectionStart - 1, this.cbs.ontextentity(s2.fromCodePoint(e3), this.entityStart, this.sectionStart));
    }
  }(Tt, { onerr: Wt, ontext(e3, t3) {
    It(Ct(e3, t3), e3, t3);
  }, ontextentity(e3, t3, r3) {
    It(e3, t3, r3);
  }, oninterpolation(e3, t3) {
    if (St) return It(Ct(e3, t3), e3, t3);
    let r3 = e3 + wt.delimiterOpen.length, n3 = t3 - wt.delimiterClose.length;
    for (; fe(ht.charCodeAt(r3)); ) r3++;
    for (; fe(ht.charCodeAt(n3 - 1)); ) n3--;
    let i3 = Ct(r3, n3);
    i3.includes("&") && (i3 = s2.decodeHTML(i3)), Ft({ type: 5, content: qt(i3, false, Ut(r3, n3)), loc: Ut(e3, t3) });
  }, onopentagname(e3, t3) {
    const r3 = Ct(e3, t3);
    mt = { type: 1, tag: r3, ns: dt.getNamespace(r3, Tt[0], dt.ns), tagType: 0, props: [], children: [], loc: Ut(e3 - 1, t3), codegenNode: void 0 };
  }, onopentagend(e3) {
    Ot(e3);
  }, onclosetag(e3, t3) {
    const r3 = Ct(e3, t3);
    if (!dt.isVoidTag(r3)) {
      let n3 = false;
      for (let e4 = 0; e4 < Tt.length; e4++) if (Tt[e4].tag.toLowerCase() === r3.toLowerCase()) {
        n3 = true, e4 > 0 && Wt(24, Tt[0].loc.start.offset);
        for (let r4 = 0; r4 <= e4; r4++) _t(Tt.shift(), t3, r4 < e4);
        break;
      }
      n3 || Wt(23, kt(e3, 60));
    }
  }, onselfclosingtag(e3) {
    var t3;
    const r3 = mt.tag;
    mt.isSelfClosing = true, Ot(e3), (null == (t3 = Tt[0]) ? void 0 : t3.tag) === r3 && _t(Tt.shift(), e3);
  }, onattribname(e3, t3) {
    yt = { type: 6, name: Ct(e3, t3), nameLoc: Ut(e3, t3), value: void 0, loc: Ut(e3) };
  }, ondirname(e3, t3) {
    const r3 = Ct(e3, t3), n3 = "." === r3 || ":" === r3 ? "bind" : "@" === r3 ? "on" : "#" === r3 ? "slot" : r3.slice(2);
    if (St || "" !== n3 || Wt(26, e3), St || "" === n3) yt = { type: 6, name: r3, nameLoc: Ut(e3, t3), value: void 0, loc: Ut(e3) };
    else if (yt = { type: 7, name: n3, rawName: r3, exp: void 0, arg: void 0, modifiers: "." === r3 ? ["prop"] : [], loc: Ut(e3) }, "pre" === n3) {
      St = wt.inVPre = true, xt = mt;
      const e4 = mt.props;
      for (let t4 = 0; t4 < e4.length; t4++) 7 === e4[t4].type && (e4[t4] = Vt(e4[t4]));
    }
  }, ondirarg(e3, t3) {
    if (e3 === t3) return;
    const r3 = Ct(e3, t3);
    if (St) yt.name += r3, $t(yt.nameLoc, t3);
    else {
      const n3 = "[" !== r3[0];
      yt.arg = qt(n3 ? r3 : r3.slice(1, -1), n3, Ut(e3, t3), n3 ? 3 : 0);
    }
  }, ondirmodifier(e3, t3) {
    const r3 = Ct(e3, t3);
    if (St) yt.name += "." + r3, $t(yt.nameLoc, t3);
    else if ("slot" === yt.name) {
      const e4 = yt.arg;
      e4 && (e4.content += "." + r3, $t(e4.loc, t3));
    } else yt.modifiers.push(r3);
  }, onattribdata(e3, t3) {
    gt += Ct(e3, t3), bt < 0 && (bt = e3), vt = t3;
  }, onattribentity(e3, t3, r3) {
    gt += e3, bt < 0 && (bt = t3), vt = r3;
  }, onattribnameend(e3) {
    const t3 = yt.loc.start.offset, r3 = Ct(t3, e3);
    7 === yt.type && (yt.rawName = r3), mt.props.some((e4) => (7 === e4.type ? e4.rawName : e4.name) === r3) && Wt(2, t3);
  }, onattribend(e3, t3) {
    if (mt && yt) {
      if ($t(yt.loc, t3), 0 !== e3) if (6 === yt.type) "class" === yt.name && (gt = Rt(gt).trim()), 1 !== e3 || gt || Wt(13, t3), yt.value = { type: 2, content: gt, loc: 1 === e3 ? Ut(bt, vt) : Ut(bt - 1, vt + 1) }, wt.inSFCRoot && "template" === mt.tag && "lang" === yt.name && gt && "html" !== gt && wt.enterRCDATA(me("</template"), 0);
      else {
        let e4 = 0;
        "for" === yt.name ? e4 = 3 : "slot" === yt.name ? e4 = 1 : "on" === yt.name && gt.includes(";") && (e4 = 2), yt.exp = qt(gt, false, Ut(bt, vt), 0, e4), "for" === yt.name && (yt.forParseResult = function(e5) {
          const t5 = e5.loc, r3 = e5.content, n3 = r3.match(ut);
          if (!n3) return;
          const [, s3, i3] = n3, o3 = function(e6, r4) {
            let n4 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            const s4 = t5.start.offset + r4;
            return qt(e6, false, Ut(s4, s4 + e6.length), 0, n4 ? 1 : 0);
          }, a3 = { source: o3(i3.trim(), r3.indexOf(i3, s3.length)), value: void 0, key: void 0, index: void 0, finalized: false };
          let l2 = s3.trim().replace(At, "").trim();
          const c2 = s3.indexOf(l2), u2 = l2.match(Pt);
          if (u2) {
            l2 = l2.replace(Pt, "").trim();
            const e6 = u2[1].trim();
            let t6;
            if (e6 && (t6 = r3.indexOf(e6, c2 + l2.length), a3.key = o3(e6, t6, true)), u2[2]) {
              const n4 = u2[2].trim();
              n4 && (a3.index = o3(n4, r3.indexOf(n4, a3.key ? t6 + e6.length : c2 + l2.length), true));
            }
          }
          return l2 && (a3.value = o3(l2, c2, true)), a3;
        }(yt.exp));
        let t4 = -1;
        "bind" === yt.name && (t4 = yt.modifiers.indexOf("sync")) > -1 && Ee("COMPILER_V_BIND_SYNC", dt, yt.loc, yt.rawName) && (yt.name = "model", yt.modifiers.splice(t4, 1));
      }
      7 === yt.type && "pre" === yt.name || mt.props.push(yt);
    }
    gt = "", bt = vt = -1;
  }, oncomment(e3, t3) {
    dt.comments && Ft({ type: 3, content: Ct(e3, t3), loc: Ut(e3 - 4, t3 + 3) });
  }, onend() {
    const e3 = ht.length;
    if (1 !== wt.state) switch (wt.state) {
      case 5:
      case 8:
        Wt(5, e3);
        break;
      case 3:
      case 4:
        Wt(25, wt.sectionStart);
        break;
      case 28:
        wt.currentSequence === ye.CdataEnd ? Wt(6, e3) : Wt(7, e3);
        break;
      case 6:
      case 7:
      case 9:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
        Wt(9, e3);
    }
    for (let t3 = 0; t3 < Tt.length; t3++) _t(Tt[t3], e3 - 1), Wt(24, Tt[t3].loc.start.offset);
  }, oncdata(e3, t3) {
    0 !== Tt[0].ns ? It(Ct(e3, t3), e3, t3) : Wt(1, e3 - 9);
  }, onprocessinginstruction(e3) {
    0 === (Tt[0] ? Tt[0].ns : dt.ns) && Wt(21, e3 - 1);
  } }), Pt = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, At = /^\(|\)$/g;
  function Ct(e3, t3) {
    return ht.slice(e3, t3);
  }
  function Ot(e3) {
    wt.inSFCRoot && (mt.innerLoc = Ut(e3 + 1, e3 + 1)), Ft(mt);
    const { tag: t3, ns: r3 } = mt;
    0 === r3 && dt.isPreTag(t3) && Et++, dt.isVoidTag(t3) ? _t(mt, e3) : (Tt.unshift(mt), 1 !== r3 && 2 !== r3 || (wt.inXML = true)), mt = null;
  }
  function It(e3, t3, r3) {
    const n3 = Tt[0] || ft, s3 = n3.children[n3.children.length - 1];
    2 === (null == s3 ? void 0 : s3.type) ? (s3.content += e3, $t(s3.loc, r3)) : n3.children.push({ type: 2, content: e3, loc: Ut(t3, r3) });
  }
  function _t(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    $t(e3.loc, r3 ? kt(t3, 60) : t3 + 1), wt.inSFCRoot && (e3.children.length ? e3.innerLoc.end = n2.extend({}, e3.children[e3.children.length - 1].loc.end) : e3.innerLoc.end = n2.extend({}, e3.innerLoc.start), e3.innerLoc.source = Ct(e3.innerLoc.start.offset, e3.innerLoc.end.offset));
    const { tag: s3, ns: i3 } = e3;
    St || ("slot" === s3 ? e3.tagType = 2 : Dt(e3) ? e3.tagType = 3 : function(e4) {
      let { tag: t4, props: r4 } = e4;
      var n3, s4;
      if (dt.isCustomElement(t4)) return false;
      if ("component" === t4 || (s4 = t4.charCodeAt(0)) > 64 && s4 < 91 || Ue(t4) || (null == (n3 = dt.isBuiltInComponent) ? void 0 : n3.call(dt, t4)) || dt.isNativeTag && !dt.isNativeTag(t4)) return true;
      for (let e5 = 0; e5 < r4.length; e5++) {
        const t5 = r4[e5];
        if (6 === t5.type) {
          if ("is" === t5.name && t5.value) {
            if (t5.value.content.startsWith("vue:")) return true;
            if (Ee("COMPILER_IS_ON_ELEMENT", dt, t5.loc)) return true;
          }
        } else if ("bind" === t5.name && Qe(t5.arg, "is") && Ee("COMPILER_IS_ON_ELEMENT", dt, t5.loc)) return true;
      }
      return false;
    }(e3) && (e3.tagType = 1)), wt.inRCDATA || (e3.children = Lt(e3.children, e3.tag)), 0 === i3 && dt.isPreTag(s3) && Et--, xt === e3 && (St = wt.inVPre = false, xt = null), wt.inXML && 0 === (Tt[0] ? Tt[0].ns : dt.ns) && (wt.inXML = false);
    {
      const t4 = e3.props;
      if (!wt.inSFCRoot && ve("COMPILER_NATIVE_TEMPLATE", dt) && "template" === e3.tag && !Dt(e3)) {
        const t5 = Tt[0] || ft, r5 = t5.children.indexOf(e3);
        t5.children.splice(r5, 1, ...e3.children);
      }
      const r4 = t4.find((e4) => 6 === e4.type && "inline-template" === e4.name);
      r4 && Ee("COMPILER_INLINE_TEMPLATE", dt, r4.loc) && e3.children.length && (r4.value = { type: 2, content: Ct(e3.children[0].loc.start.offset, e3.children[e3.children.length - 1].loc.end.offset), loc: r4.loc });
    }
  }
  function kt(e3, t3) {
    let r3 = e3;
    for (; ht.charCodeAt(r3) !== t3 && r3 >= 0; ) r3--;
    return r3;
  }
  const Nt = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
  function Dt(e3) {
    let { tag: t3, props: r3 } = e3;
    if ("template" === t3) {
      for (let e4 = 0; e4 < r3.length; e4++) if (7 === r3[e4].type && Nt.has(r3[e4].name)) return true;
    }
    return false;
  }
  const jt = /\r\n/g;
  function Lt(e3, t3) {
    var r3, n3;
    const s3 = "preserve" !== dt.whitespace;
    let i3 = false;
    for (let t4 = 0; t4 < e3.length; t4++) {
      const o3 = e3[t4];
      if (2 === o3.type) if (Et) o3.content = o3.content.replace(jt, "\n");
      else if (Mt(o3.content)) {
        const a3 = null == (r3 = e3[t4 - 1]) ? void 0 : r3.type, l2 = null == (n3 = e3[t4 + 1]) ? void 0 : n3.type;
        !a3 || !l2 || s3 && (3 === a3 && (3 === l2 || 1 === l2) || 1 === a3 && (3 === l2 || 1 === l2 && Bt(o3.content))) ? (i3 = true, e3[t4] = null) : o3.content = " ";
      } else s3 && (o3.content = Rt(o3.content));
    }
    if (Et && t3 && dt.isPreTag(t3)) {
      const t4 = e3[0];
      t4 && 2 === t4.type && (t4.content = t4.content.replace(/^\r?\n/, ""));
    }
    return i3 ? e3.filter(Boolean) : e3;
  }
  function Mt(e3) {
    for (let t3 = 0; t3 < e3.length; t3++) if (!fe(e3.charCodeAt(t3))) return false;
    return true;
  }
  function Bt(e3) {
    for (let t3 = 0; t3 < e3.length; t3++) {
      const r3 = e3.charCodeAt(t3);
      if (10 === r3 || 13 === r3) return true;
    }
    return false;
  }
  function Rt(e3) {
    let t3 = "", r3 = false;
    for (let n3 = 0; n3 < e3.length; n3++) fe(e3.charCodeAt(n3)) ? r3 || (t3 += " ", r3 = true) : (t3 += e3[n3], r3 = false);
    return t3;
  }
  function Ft(e3) {
    (Tt[0] || ft).children.push(e3);
  }
  function Ut(e3, t3) {
    return { start: wt.getPos(e3), end: null == t3 ? t3 : wt.getPos(t3), source: null == t3 ? t3 : Ct(e3, t3) };
  }
  function $t(e3, t3) {
    e3.end = wt.getPos(t3), e3.source = Ct(e3.start.offset, t3);
  }
  function Vt(e3) {
    const t3 = { type: 6, name: e3.rawName, nameLoc: Ut(e3.loc.start.offset, e3.loc.start.offset + e3.rawName.length), value: void 0, loc: e3.loc };
    if (e3.exp) {
      const r3 = e3.exp.loc;
      r3.end.offset < e3.loc.end.offset && (r3.start.offset--, r3.start.column--, r3.end.offset++, r3.end.column++), t3.value = { type: 2, content: e3.exp.content, loc: r3 };
    }
    return t3;
  }
  function qt(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r3 = arguments.length > 2 ? arguments[2] : void 0, n3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
    const s3 = ee(e3, t3, r3, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0);
    if (!t3 && dt.prefixIdentifiers && 3 !== n3 && e3.trim()) {
      if (Ve(e3)) return s3.ast = null, s3;
      try {
        const t4 = dt.expressionPlugins, r4 = { plugins: t4 ? [...t4, "typescript"] : ["typescript"] };
        s3.ast = 2 === n3 ? i2.parse(` ${e3} `, r4).program : 1 === n3 ? i2.parseExpression(`(${e3})=>{}`, r4) : i2.parseExpression(`(${e3})`, r4);
      } catch (e4) {
        s3.ast = false, Wt(45, r3.start.offset, e4.message);
      }
    }
    return s3;
  }
  function Wt(e3, t3, r3) {
    dt.onError(Te(e3, Ut(t3, t3), void 0, r3));
  }
  function Gt(e3, t3) {
    if (wt.reset(), mt = null, yt = null, gt = "", bt = -1, vt = -1, Tt.length = 0, ht = e3, dt = n2.extend({}, pt), t3) {
      let e4;
      for (e4 in t3) null != t3[e4] && (dt[e4] = t3[e4]);
    }
    wt.mode = "html" === dt.parseMode ? 1 : "sfc" === dt.parseMode ? 2 : 0, wt.inXML = 1 === dt.ns || 2 === dt.ns;
    const r3 = null == t3 ? void 0 : t3.delimiters;
    r3 && (wt.delimiterOpen = me(r3[0]), wt.delimiterClose = me(r3[1]));
    const s3 = ft = X([], e3);
    return wt.parse(ht), s3.loc = Ut(0, e3.length), s3.children = Lt(s3.children), ft = null, s3;
  }
  function Ht(e3, t3) {
    Kt(e3, t3, zt(e3, e3.children[0]));
  }
  function zt(e3, t3) {
    const { children: r3 } = e3;
    return 1 === r3.length && 1 === t3.type && !rt(t3);
  }
  function Kt(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    const { children: s3 } = e3, i3 = s3.length;
    let o3 = 0;
    for (let e4 = 0; e4 < s3.length; e4++) {
      const n3 = s3[e4];
      if (1 === n3.type && 0 === n3.tagType) {
        const e5 = r3 ? 0 : Xt(n3, t3);
        if (e5 > 0) {
          if (e5 >= 2) {
            n3.codegenNode.patchFlag = "-1", n3.codegenNode = t3.hoist(n3.codegenNode), o3++;
            continue;
          }
        } else {
          const e6 = n3.codegenNode;
          if (13 === e6.type) {
            const r4 = er(e6);
            if ((!r4 || 512 === r4 || 1 === r4) && Qt(n3, t3) >= 2) {
              const r5 = Zt(n3);
              r5 && (e6.props = t3.hoist(r5));
            }
            e6.dynamicProps && (e6.dynamicProps = t3.hoist(e6.dynamicProps));
          }
        }
      }
      if (1 === n3.type) {
        const e5 = 1 === n3.tagType;
        e5 && t3.scopes.vSlot++, Kt(n3, t3), e5 && t3.scopes.vSlot--;
      } else if (11 === n3.type) Kt(n3, t3, 1 === n3.children.length);
      else if (9 === n3.type) for (let e5 = 0; e5 < n3.branches.length; e5++) Kt(n3.branches[e5], t3, 1 === n3.branches[e5].children.length);
    }
    if (o3 && t3.transformHoist && t3.transformHoist(s3, t3, e3), o3 && o3 === i3 && 1 === e3.type && 0 === e3.tagType && e3.codegenNode && 13 === e3.codegenNode.type && n2.isArray(e3.codegenNode.children)) {
      const r4 = t3.hoist(Y(e3.codegenNode.children));
      t3.hmr && (r4.content = `[...${r4.content}]`), e3.codegenNode.children = r4;
    }
  }
  function Xt(e3, t3) {
    const { constantCache: r3 } = t3;
    switch (e3.type) {
      case 1:
        if (0 !== e3.tagType) return 0;
        const s3 = r3.get(e3);
        if (void 0 !== s3) return s3;
        const i3 = e3.codegenNode;
        if (13 !== i3.type) return 0;
        if (i3.isBlock && "svg" !== e3.tag && "foreignObject" !== e3.tag) return 0;
        if (er(i3)) return r3.set(e3, 0), 0;
        {
          let n3 = 3;
          const s4 = Qt(e3, t3);
          if (0 === s4) return r3.set(e3, 0), 0;
          s4 < n3 && (n3 = s4);
          for (let s5 = 0; s5 < e3.children.length; s5++) {
            const i4 = Xt(e3.children[s5], t3);
            if (0 === i4) return r3.set(e3, 0), 0;
            i4 < n3 && (n3 = i4);
          }
          if (n3 > 1) for (let s5 = 0; s5 < e3.props.length; s5++) {
            const i4 = e3.props[s5];
            if (7 === i4.type && "bind" === i4.name && i4.exp) {
              const s6 = Xt(i4.exp, t3);
              if (0 === s6) return r3.set(e3, 0), 0;
              s6 < n3 && (n3 = s6);
            }
          }
          if (i3.isBlock) {
            for (let t4 = 0; t4 < e3.props.length; t4++) if (7 === e3.props[t4].type) return r3.set(e3, 0), 0;
            t3.removeHelper(f), t3.removeHelper(le(t3.inSSR, i3.isComponent)), i3.isBlock = false, t3.helper(ae(t3.inSSR, i3.isComponent));
          }
          return r3.set(e3, n3), n3;
        }
      case 2:
      case 3:
        return 3;
      case 9:
      case 11:
      case 10:
      default:
        return 0;
      case 5:
      case 12:
        return Xt(e3.content, t3);
      case 4:
        return e3.constType;
      case 8:
        let o3 = 3;
        for (let r4 = 0; r4 < e3.children.length; r4++) {
          const s4 = e3.children[r4];
          if (n2.isString(s4) || n2.isSymbol(s4)) continue;
          const i4 = Xt(s4, t3);
          if (0 === i4) return 0;
          i4 < o3 && (o3 = i4);
        }
        return o3;
    }
  }
  const Jt = /* @__PURE__ */ new Set([k, N, D, j]);
  function Yt(e3, t3) {
    if (14 === e3.type && !n2.isString(e3.callee) && Jt.has(e3.callee)) {
      const r3 = e3.arguments[0];
      if (4 === r3.type) return Xt(r3, t3);
      if (14 === r3.type) return Yt(r3, t3);
    }
    return 0;
  }
  function Qt(e3, t3) {
    let r3 = 3;
    const n3 = Zt(e3);
    if (n3 && 15 === n3.type) {
      const { properties: e4 } = n3;
      for (let n4 = 0; n4 < e4.length; n4++) {
        const { key: s3, value: i3 } = e4[n4], o3 = Xt(s3, t3);
        if (0 === o3) return o3;
        let a3;
        if (o3 < r3 && (r3 = o3), a3 = 4 === i3.type ? Xt(i3, t3) : 14 === i3.type ? Yt(i3, t3) : 0, 0 === a3) return a3;
        a3 < r3 && (r3 = a3);
      }
    }
    return r3;
  }
  function Zt(e3) {
    const t3 = e3.codegenNode;
    if (13 === t3.type) return t3.props;
  }
  function er(e3) {
    const t3 = e3.patchFlag;
    return t3 ? parseInt(t3, 10) : void 0;
  }
  function tr(e3, t3) {
    let { filename: r3 = "", prefixIdentifiers: s3 = false, hoistStatic: i3 = false, hmr: o3 = false, cacheHandlers: a3 = false, nodeTransforms: l2 = [], directiveTransforms: c2 = {}, transformHoist: u2 = null, isBuiltInComponent: p2 = n2.NOOP, isCustomElement: d2 = n2.NOOP, expressionPlugins: f2 = [], scopeId: h2 = null, slotted: m2 = true, ssr: y2 = false, inSSR: g2 = false, ssrCssVars: b2 = "", bindingMetadata: v2 = n2.EMPTY_OBJ, inline: E2 = false, isTS: S2 = false, onError: x2 = Se, onWarn: T2 = xe, compatConfig: w2 } = t3;
    const P2 = r3.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), A2 = { filename: r3, selfName: P2 && n2.capitalize(n2.camelize(P2[1])), prefixIdentifiers: s3, hoistStatic: i3, hmr: o3, cacheHandlers: a3, nodeTransforms: l2, directiveTransforms: c2, transformHoist: u2, isBuiltInComponent: p2, isCustomElement: d2, expressionPlugins: f2, scopeId: h2, slotted: m2, ssr: y2, inSSR: g2, ssrCssVars: b2, bindingMetadata: v2, inline: E2, isTS: S2, onError: x2, onWarn: T2, compatConfig: w2, root: e3, helpers: /* @__PURE__ */ new Map(), components: /* @__PURE__ */ new Set(), directives: /* @__PURE__ */ new Set(), hoists: [], imports: [], constantCache: /* @__PURE__ */ new WeakMap(), temps: 0, cached: 0, identifiers: /* @__PURE__ */ Object.create(null), scopes: { vFor: 0, vSlot: 0, vPre: 0, vOnce: 0 }, parent: null, currentNode: e3, childIndex: 0, inVOnce: false, helper(e4) {
      const t4 = A2.helpers.get(e4) || 0;
      return A2.helpers.set(e4, t4 + 1), e4;
    }, removeHelper(e4) {
      const t4 = A2.helpers.get(e4);
      if (t4) {
        const r4 = t4 - 1;
        r4 ? A2.helpers.set(e4, r4) : A2.helpers.delete(e4);
      }
    }, helperString: (e4) => `_${z[A2.helper(e4)]}`, replaceNode(e4) {
      A2.parent.children[A2.childIndex] = A2.currentNode = e4;
    }, removeNode(e4) {
      const t4 = A2.parent.children, r4 = e4 ? t4.indexOf(e4) : A2.currentNode ? A2.childIndex : -1;
      e4 && e4 !== A2.currentNode ? A2.childIndex > r4 && (A2.childIndex--, A2.onNodeRemoved()) : (A2.currentNode = null, A2.onNodeRemoved()), A2.parent.children.splice(r4, 1);
    }, onNodeRemoved: n2.NOOP, addIdentifiers(e4) {
      n2.isString(e4) ? C2(e4) : e4.identifiers ? e4.identifiers.forEach(C2) : 4 === e4.type && C2(e4.content);
    }, removeIdentifiers(e4) {
      n2.isString(e4) ? O2(e4) : e4.identifiers ? e4.identifiers.forEach(O2) : 4 === e4.type && O2(e4.content);
    }, hoist(e4) {
      n2.isString(e4) && (e4 = ee(e4)), A2.hoists.push(e4);
      const t4 = ee(`_hoisted_${A2.hoists.length}`, false, e4.loc, 2);
      return t4.hoisted = e4, t4;
    }, cache(e4) {
      let t4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      return ie(A2.cached++, e4, t4);
    } };
    function C2(e4) {
      const { identifiers: t4 } = A2;
      void 0 === t4[e4] && (t4[e4] = 0), t4[e4]++;
    }
    function O2(e4) {
      A2.identifiers[e4]--;
    }
    return A2.filters = /* @__PURE__ */ new Set(), A2;
  }
  function rr(e3, t3) {
    const r3 = tr(e3, t3);
    nr(e3, r3), t3.hoistStatic && Ht(e3, r3), t3.ssr || function(e4, t4) {
      const { helper: r4 } = t4, { children: s3 } = e4;
      if (1 === s3.length) {
        const r5 = s3[0];
        if (zt(e4, r5) && r5.codegenNode) {
          const n3 = r5.codegenNode;
          13 === n3.type && ce(n3, t4), e4.codegenNode = n3;
        } else e4.codegenNode = r5;
      } else if (s3.length > 1) {
        let s4 = 64;
        n2.PatchFlagNames[64], e4.codegenNode = J(t4, r4(l), void 0, e4.children, s4 + "", void 0, void 0, true, void 0, false);
      }
    }(e3, r3), e3.helpers = /* @__PURE__ */ new Set([...r3.helpers.keys()]), e3.components = [...r3.components], e3.directives = [...r3.directives], e3.imports = r3.imports, e3.hoists = r3.hoists, e3.temps = r3.temps, e3.cached = r3.cached, e3.transformed = true, e3.filters = [...r3.filters];
  }
  function nr(e3, t3) {
    t3.currentNode = e3;
    const { nodeTransforms: r3 } = t3, s3 = [];
    for (let i4 = 0; i4 < r3.length; i4++) {
      const o3 = r3[i4](e3, t3);
      if (o3 && (n2.isArray(o3) ? s3.push(...o3) : s3.push(o3)), !t3.currentNode) return;
      e3 = t3.currentNode;
    }
    switch (e3.type) {
      case 3:
        t3.ssr || t3.helper(b);
        break;
      case 5:
        t3.ssr || t3.helper(I);
        break;
      case 9:
        for (let r4 = 0; r4 < e3.branches.length; r4++) nr(e3.branches[r4], t3);
        break;
      case 10:
      case 11:
      case 1:
      case 0:
        !function(e4, t4) {
          let r4 = 0;
          const s4 = () => {
            r4--;
          };
          for (; r4 < e4.children.length; r4++) {
            const i4 = e4.children[r4];
            n2.isString(i4) || (t4.parent = e4, t4.childIndex = r4, t4.onNodeRemoved = s4, nr(i4, t4));
          }
        }(e3, t3);
    }
    t3.currentNode = e3;
    let i3 = s3.length;
    for (; i3--; ) s3[i3]();
  }
  function sr(e3, t3) {
    const r3 = n2.isString(e3) ? (t4) => t4 === e3 : (t4) => e3.test(t4);
    return (e4, n3) => {
      if (1 === e4.type) {
        const { props: s3 } = e4;
        if (3 === e4.tagType && s3.some(et)) return;
        const i3 = [];
        for (let o3 = 0; o3 < s3.length; o3++) {
          const a3 = s3[o3];
          if (7 === a3.type && r3(a3.name)) {
            s3.splice(o3, 1), o3--;
            const r4 = t3(e4, a3, n3);
            r4 && i3.push(r4);
          }
        }
        return i3;
      }
    };
  }
  const ir = "/*#__PURE__*/", or = (e3) => `${z[e3]}: _${z[e3]}`;
  function ar(e3, t3) {
    let { mode: r3 = "function", prefixIdentifiers: n3 = "module" === r3, sourceMap: s3 = false, filename: i3 = "template.vue.html", scopeId: o3 = null, optimizeImports: l2 = false, runtimeGlobalName: c2 = "Vue", runtimeModuleName: u2 = "vue", ssrRuntimeModuleName: p2 = "vue/server-renderer", ssr: d2 = false, isTS: f2 = false, inSSR: h2 = false } = t3;
    const m2 = { mode: r3, prefixIdentifiers: n3, sourceMap: s3, filename: i3, scopeId: o3, optimizeImports: l2, runtimeGlobalName: c2, runtimeModuleName: u2, ssrRuntimeModuleName: p2, ssr: d2, isTS: f2, inSSR: h2, source: e3.source, code: "", column: 1, line: 1, offset: 0, indentLevel: 0, pure: false, map: void 0, helper: (e4) => `_${z[e4]}`, push(e4) {
      let t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -2, r4 = arguments.length > 2 ? arguments[2] : void 0;
      if (m2.code += e4, m2.map) {
        if (r4) {
          let e5;
          if (4 === r4.type && !r4.isStatic) {
            const t5 = r4.content.replace(/^_ctx\./, "");
            t5 !== r4.content && Ve(t5) && (e5 = t5);
          }
          g2(r4.loc.start, e5);
        }
        -3 === t4 ? Xe(m2, e4) : (m2.offset += e4.length, -2 === t4 ? m2.column += e4.length : (-1 === t4 && (t4 = e4.length - 1), m2.line++, m2.column = e4.length - t4)), r4 && r4.loc !== K && g2(r4.loc.end);
      }
    }, indent() {
      y2(++m2.indentLevel);
    }, deindent() {
      arguments.length > 0 && void 0 !== arguments[0] && arguments[0] ? --m2.indentLevel : y2(--m2.indentLevel);
    }, newline() {
      y2(m2.indentLevel);
    } };
    function y2(e4) {
      m2.push("\n" + "  ".repeat(e4), 0);
    }
    function g2(e4) {
      let t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
      const { _names: r4, _mappings: n4 } = m2.map;
      null === t4 || r4.has(t4) || r4.add(t4), n4.add({ originalLine: e4.line, originalColumn: e4.column - 1, generatedLine: m2.line, generatedColumn: m2.column - 1, source: i3, name: t4 });
    }
    return s3 && (m2.map = new a2.SourceMapGenerator(), m2.map.setSourceContent(i3, m2.source), m2.map._sources.add(i3)), m2;
  }
  function lr(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const r3 = ar(e3, t3);
    t3.onContextCreated && t3.onContextCreated(r3);
    const { mode: n3, push: s3, prefixIdentifiers: i3, indent: o3, deindent: a3, newline: l2, scopeId: c2, ssr: u2 } = r3, p2 = Array.from(e3.helpers), d2 = p2.length > 0, f2 = !i3 && "module" !== n3, h2 = null != c2 && "module" === n3, m2 = !!t3.inline, S2 = m2 ? ar(e3, t3) : r3;
    "module" === n3 ? function(e4, t4, r4, n4) {
      const { push: s4, newline: i4, optimizeImports: o4, runtimeModuleName: a4, ssrRuntimeModuleName: l3 } = t4;
      if (r4 && e4.hoists.length && (e4.helpers.add(U), e4.helpers.add($)), e4.helpers.size) {
        const t5 = Array.from(e4.helpers);
        o4 ? (s4(`import { ${t5.map((e5) => z[e5]).join(", ")} } from ${JSON.stringify(a4)}
`, -1), s4(`
// Binding optimization for webpack code-split
const ${t5.map((e5) => `_${z[e5]} = ${z[e5]}`).join(", ")}
`, -1)) : s4(`import { ${t5.map((e5) => `${z[e5]} as _${z[e5]}`).join(", ")} } from ${JSON.stringify(a4)}
`, -1);
      }
      e4.ssrHelpers && e4.ssrHelpers.length && s4(`import { ${e4.ssrHelpers.map((e5) => `${z[e5]} as _${z[e5]}`).join(", ")} } from "${l3}"
`, -1), e4.imports.length && (function(e5, t5) {
        e5.length && e5.forEach((e6) => {
          t5.push("import "), fr(e6.exp, t5), t5.push(` from '${e6.path}'`), t5.newline();
        });
      }(e4.imports, t4), i4()), ur(e4.hoists, t4), i4(), n4 || s4("export ");
    }(e3, S2, h2, m2) : function(e4, t4) {
      const { ssr: r4, prefixIdentifiers: n4, push: s4, newline: i4, runtimeModuleName: o4, runtimeGlobalName: a4, ssrRuntimeModuleName: l3 } = t4, c3 = r4 ? `require(${JSON.stringify(o4)})` : a4, u3 = Array.from(e4.helpers);
      u3.length > 0 && (n4 ? s4(`const { ${u3.map(or).join(", ")} } = ${c3}
`, -1) : (s4(`const _Vue = ${c3}
`, -1), e4.hoists.length && s4(`const { ${[y, g, b, v, E].filter((e5) => u3.includes(e5)).map(or).join(", ")} } = _Vue
`, -1))), e4.ssrHelpers && e4.ssrHelpers.length && s4(`const { ${e4.ssrHelpers.map(or).join(", ")} } = require("${l3}")
`, -1), ur(e4.hoists, t4), i4(), s4("return ");
    }(e3, S2);
    const x2 = u2 ? "ssrRender" : "render", T2 = u2 ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
    t3.bindingMetadata && !t3.inline && T2.push("$props", "$setup", "$data", "$options");
    const w2 = t3.isTS ? T2.map((e4) => `${e4}: any`).join(",") : T2.join(", ");
    if (s3(m2 ? `(${w2}) => {` : `function ${x2}(${w2}) {`), o3(), f2 && (s3("with (_ctx) {"), o3(), d2 && (s3(`const { ${p2.map(or).join(", ")} } = _Vue
`, -1), l2())), e3.components.length && (cr(e3.components, "component", r3), (e3.directives.length || e3.temps > 0) && l2()), e3.directives.length && (cr(e3.directives, "directive", r3), e3.temps > 0 && l2()), e3.filters && e3.filters.length && (l2(), cr(e3.filters, "filter", r3), l2()), e3.temps > 0) {
      s3("let ");
      for (let t4 = 0; t4 < e3.temps; t4++) s3(`${t4 > 0 ? ", " : ""}_temp${t4}`);
    }
    return (e3.components.length || e3.directives.length || e3.temps) && (s3("\n", 0), l2()), u2 || s3("return "), e3.codegenNode ? fr(e3.codegenNode, r3) : s3("null"), f2 && (a3(), s3("}")), a3(), s3("}"), { ast: e3, code: r3.code, preamble: m2 ? S2.code : "", map: r3.map ? r3.map.toJSON() : void 0 };
  }
  function cr(e3, t3, r3) {
    let { helper: n3, push: s3, newline: i3, isTS: o3 } = r3;
    const a3 = n3("filter" === t3 ? w : "component" === t3 ? S : T);
    for (let r4 = 0; r4 < e3.length; r4++) {
      let n4 = e3[r4];
      const l2 = n4.endsWith("__self");
      l2 && (n4 = n4.slice(0, -6)), s3(`const ${at(n4, t3)} = ${a3}(${JSON.stringify(n4)}${l2 ? ", true" : ""})${o3 ? "!" : ""}`), r4 < e3.length - 1 && i3();
    }
  }
  function ur(e3, t3) {
    if (!e3.length) return;
    t3.pure = true;
    const { push: r3, newline: n3, helper: s3, scopeId: i3, mode: o3 } = t3, a3 = null != i3 && "function" !== o3;
    n3(), a3 && (r3(`const _withScopeId = n => (${s3(U)}("${i3}"),n=n(),${s3($)}(),n)`), n3());
    for (let s4 = 0; s4 < e3.length; s4++) {
      const i4 = e3[s4];
      if (i4) {
        const e4 = a3 && 13 === i4.type;
        r3(`const _hoisted_${s4 + 1} = ${e4 ? `${ir} _withScopeId(() => ` : ""}`), fr(i4, t3), e4 && r3(")"), n3();
      }
    }
    t3.pure = false;
  }
  function pr(e3, t3) {
    const r3 = e3.length > 3 || e3.some((e4) => n2.isArray(e4) || !function(e5) {
      return n2.isString(e5) || 4 === e5.type || 2 === e5.type || 5 === e5.type || 8 === e5.type;
    }(e4));
    t3.push("["), r3 && t3.indent(), dr(e3, t3, r3), r3 && t3.deindent(), t3.push("]");
  }
  function dr(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
    const { push: i3, newline: o3 } = t3;
    for (let a3 = 0; a3 < e3.length; a3++) {
      const l2 = e3[a3];
      n2.isString(l2) ? i3(l2, -3) : n2.isArray(l2) ? pr(l2, t3) : fr(l2, t3), a3 < e3.length - 1 && (r3 ? (s3 && i3(","), o3()) : s3 && i3(", "));
    }
  }
  function fr(e3, t3) {
    if (n2.isString(e3)) t3.push(e3, -3);
    else if (n2.isSymbol(e3)) t3.push(t3.helper(e3));
    else switch (e3.type) {
      case 1:
      case 9:
      case 11:
      case 12:
        fr(e3.codegenNode, t3);
        break;
      case 2:
        !function(e4, t4) {
          t4.push(JSON.stringify(e4.content), -3, e4);
        }(e3, t3);
        break;
      case 4:
        hr(e3, t3);
        break;
      case 5:
        !function(e4, t4) {
          const { push: r3, helper: n3, pure: s3 } = t4;
          s3 && r3(ir), r3(`${n3(I)}(`), fr(e4.content, t4), r3(")");
        }(e3, t3);
        break;
      case 8:
        mr(e3, t3);
        break;
      case 3:
        !function(e4, t4) {
          const { push: r3, helper: n3, pure: s3 } = t4;
          s3 && r3(ir), r3(`${n3(b)}(${JSON.stringify(e4.content)})`, -3, e4);
        }(e3, t3);
        break;
      case 13:
        !function(e4, t4) {
          const { push: r3, helper: n3, pure: s3 } = t4, { tag: i3, props: o3, children: a3, patchFlag: l2, dynamicProps: c2, directives: u2, isBlock: p2, disableTracking: d2, isComponent: h2 } = e4;
          u2 && r3(n3(P) + "("), p2 && r3(`(${n3(f)}(${d2 ? "true" : ""}), `), s3 && r3(ir);
          r3(n3(p2 ? le(t4.inSSR, h2) : ae(t4.inSSR, h2)) + "(", -2, e4), dr(function(e5) {
            let t5 = e5.length;
            for (; t5-- && null == e5[t5]; ) ;
            return e5.slice(0, t5 + 1).map((e6) => e6 || "null");
          }([i3, o3, a3, l2, c2]), t4), r3(")"), p2 && r3(")"), u2 && (r3(", "), fr(u2, t4), r3(")"));
        }(e3, t3);
        break;
      case 14:
        !function(e4, t4) {
          const { push: r3, helper: s3, pure: i3 } = t4, o3 = n2.isString(e4.callee) ? e4.callee : s3(e4.callee);
          i3 && r3(ir), r3(o3 + "(", -2, e4), dr(e4.arguments, t4), r3(")");
        }(e3, t3);
        break;
      case 15:
        !function(e4, t4) {
          const { push: r3, indent: n3, deindent: s3, newline: i3 } = t4, { properties: o3 } = e4;
          if (!o3.length) return void r3("{}", -2, e4);
          const a3 = o3.length > 1 || o3.some((e5) => 4 !== e5.value.type);
          r3(a3 ? "{" : "{ "), a3 && n3();
          for (let e5 = 0; e5 < o3.length; e5++) {
            const { key: n4, value: s4 } = o3[e5];
            yr(n4, t4), r3(": "), fr(s4, t4), e5 < o3.length - 1 && (r3(","), i3());
          }
          a3 && s3(), r3(a3 ? "}" : " }");
        }(e3, t3);
        break;
      case 17:
        !function(e4, t4) {
          pr(e4.elements, t4);
        }(e3, t3);
        break;
      case 18:
        !function(e4, t4) {
          const { push: r3, indent: s3, deindent: i3 } = t4, { params: o3, returns: a3, body: l2, newline: c2, isSlot: u2 } = e4;
          u2 && r3(`_${z[V]}(`), r3("(", -2, e4), n2.isArray(o3) ? dr(o3, t4) : o3 && fr(o3, t4), r3(") => "), (c2 || l2) && (r3("{"), s3()), a3 ? (c2 && r3("return "), n2.isArray(a3) ? pr(a3, t4) : fr(a3, t4)) : l2 && fr(l2, t4), (c2 || l2) && (i3(), r3("}")), u2 && (e4.isNonScopedSlot && r3(", undefined, true"), r3(")"));
        }(e3, t3);
        break;
      case 19:
        !function(e4, t4) {
          const { test: r3, consequent: n3, alternate: s3, newline: i3 } = e4, { push: o3, indent: a3, deindent: l2, newline: c2 } = t4;
          if (4 === r3.type) {
            const e5 = !Ve(r3.content);
            e5 && o3("("), hr(r3, t4), e5 && o3(")");
          } else o3("("), fr(r3, t4), o3(")");
          i3 && a3(), t4.indentLevel++, i3 || o3(" "), o3("? "), fr(n3, t4), t4.indentLevel--, i3 && c2(), i3 || o3(" "), o3(": ");
          const u2 = 19 === s3.type;
          u2 || t4.indentLevel++, fr(s3, t4), u2 || t4.indentLevel--, i3 && l2(true);
        }(e3, t3);
        break;
      case 20:
        !function(e4, t4) {
          const { push: r3, helper: n3, indent: s3, deindent: i3, newline: o3 } = t4;
          r3(`_cache[${e4.index}] || (`), e4.isVNode && (s3(), r3(`${n3(F)}(-1),`), o3()), r3(`_cache[${e4.index}] = `), fr(e4.value, t4), e4.isVNode && (r3(","), o3(), r3(`${n3(F)}(1),`), o3(), r3(`_cache[${e4.index}]`), i3()), r3(")");
        }(e3, t3);
        break;
      case 21:
        dr(e3.body, t3, true, false);
        break;
      case 22:
        !function(e4, t4) {
          const { push: r3, indent: s3, deindent: i3 } = t4;
          r3("`");
          const o3 = e4.elements.length, a3 = o3 > 3;
          for (let l2 = 0; l2 < o3; l2++) {
            const o4 = e4.elements[l2];
            n2.isString(o4) ? r3(o4.replace(/(`|\$|\\)/g, "\\$1"), -3) : (r3("${"), a3 && s3(), fr(o4, t4), a3 && i3(), r3("}"));
          }
          r3("`");
        }(e3, t3);
        break;
      case 23:
        gr(e3, t3);
        break;
      case 24:
        !function(e4, t4) {
          fr(e4.left, t4), t4.push(" = "), fr(e4.right, t4);
        }(e3, t3);
        break;
      case 25:
        !function(e4, t4) {
          t4.push("("), dr(e4.expressions, t4), t4.push(")");
        }(e3, t3);
        break;
      case 26:
        !function(e4, t4) {
          let { returns: r3 } = e4;
          t4.push("return "), n2.isArray(r3) ? pr(r3, t4) : fr(r3, t4);
        }(e3, t3);
    }
  }
  function hr(e3, t3) {
    const { content: r3, isStatic: n3 } = e3;
    t3.push(n3 ? JSON.stringify(r3) : r3, -3, e3);
  }
  function mr(e3, t3) {
    for (let r3 = 0; r3 < e3.children.length; r3++) {
      const s3 = e3.children[r3];
      n2.isString(s3) ? t3.push(s3, -3) : fr(s3, t3);
    }
  }
  function yr(e3, t3) {
    const { push: r3 } = t3;
    8 === e3.type ? (r3("["), mr(e3, t3), r3("]")) : e3.isStatic ? r3(Ve(e3.content) ? e3.content : JSON.stringify(e3.content), -2, e3) : r3(`[${e3.content}]`, -3, e3);
  }
  function gr(e3, t3) {
    const { push: r3, indent: n3, deindent: s3 } = t3, { test: i3, consequent: o3, alternate: a3 } = e3;
    r3("if ("), fr(i3, t3), r3(") {"), n3(), fr(o3, t3), s3(), r3("}"), a3 && (r3(" else "), 23 === a3.type ? gr(a3, t3) : (r3("{"), n3(), fr(a3, t3), s3(), r3("}")));
  }
  const br = n2.makeMap("true,false,null,this"), vr = /\w\s*\(|\.[^\d]/, Er = (e3, t3) => {
    if (5 === e3.type) e3.content = Sr(e3.content, t3);
    else if (1 === e3.type) for (let r3 = 0; r3 < e3.props.length; r3++) {
      const n3 = e3.props[r3];
      if (7 === n3.type && "for" !== n3.name) {
        const e4 = n3.exp, r4 = n3.arg;
        !e4 || 4 !== e4.type || "on" === n3.name && r4 || (n3.exp = Sr(e4, t3, "slot" === n3.name)), r4 && 4 === r4.type && !r4.isStatic && (n3.arg = Sr(r4, t3));
      }
    }
  };
  function Sr(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], o3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Object.create(t3.identifiers);
    if (!t3.prefixIdentifiers || !e3.content.trim()) return e3;
    const { inline: a3, bindingMetadata: l2 } = t3, c2 = (e4, r4, s4) => {
      const i3 = n2.hasOwn(l2, e4) && l2[e4];
      if (a3) {
        const a4 = r4 && "AssignmentExpression" === r4.type && r4.left === s4, c3 = r4 && "UpdateExpression" === r4.type && r4.argument === s4, p3 = r4 && Ce(r4, h2), d3 = r4 && Oe(h2), f3 = (e5) => {
          const r5 = `${t3.helperString(q)}(${e5})`;
          return d3 ? `(${r5})` : r5;
        };
        if (Tr(i3) || "setup-reactive-const" === i3 || o3[e4]) return e4;
        if ("setup-ref" === i3) return `${e4}.value`;
        if ("setup-maybe-ref" === i3) return a4 || c3 || p3 ? `${e4}.value` : f3(e4);
        if ("setup-let" === i3) {
          if (a4) {
            const { right: n3, operator: s5 } = r4, i4 = xr(Sr(ee(u2.slice(n3.start - 1, n3.end - 1), false), t3, false, false, m2));
            return `${t3.helperString(W)}(${e4})${t3.isTS ? " //@ts-ignore\n" : ""} ? ${e4}.value ${s5} ${i4} : ${e4}`;
          }
          if (c3) {
            s4.start = r4.start, s4.end = r4.end;
            const { prefix: n3, operator: i4 } = r4, o4 = n3 ? i4 : "", a5 = n3 ? "" : i4;
            return `${t3.helperString(W)}(${e4})${t3.isTS ? " //@ts-ignore\n" : ""} ? ${o4}${e4}.value${a5} : ${o4}${e4}${a5}`;
          }
          return p3 ? e4 : f3(e4);
        }
        if ("props" === i3) return n2.genPropsAccessExp(e4);
        if ("props-aliased" === i3) return n2.genPropsAccessExp(l2.__propsAliases[e4]);
      } else {
        if (i3 && i3.startsWith("setup") || "literal-const" === i3) return `$setup.${e4}`;
        if ("props-aliased" === i3) return `$props['${l2.__propsAliases[e4]}']`;
        if (i3) return `$${i3}.${e4}`;
      }
      return `_ctx.${e4}`;
    }, u2 = e3.content, p2 = vr.test(u2);
    let d2 = e3.ast;
    if (false === d2) return e3;
    if (null === d2 || !d2 && Ve(u2)) {
      const s4 = t3.identifiers[u2], i3 = n2.isGloballyAllowed(u2), o4 = br(u2);
      return r3 || s4 || o4 || i3 && !l2[u2] ? s4 || (e3.constType = o4 ? 3 : 2) : (Tr(l2[u2]) && (e3.constType = 1), e3.content = c2(u2)), e3;
    }
    if (!d2) {
      const n3 = s3 ? ` ${u2} ` : `(${u2})${r3 ? "=>{}" : ""}`;
      try {
        d2 = i2.parse(n3, { plugins: t3.expressionPlugins }).program;
      } catch (r4) {
        return t3.onError(Te(45, e3.loc, void 0, r4.message)), e3;
      }
    }
    const f2 = [], h2 = [], m2 = Object.create(t3.identifiers);
    Pe(d2, (e4, t4, r4, s4, i3) => {
      if (Me(e4, t4)) return;
      if (e4.name.startsWith("_filter_")) return;
      const o4 = s4 && (a4 = e4, !n2.isGloballyAllowed(a4.name) && "require" !== a4.name);
      var a4;
      o4 && !i3 ? (Le(t4) && t4.shorthand && (e4.prefix = `${e4.name}: `), e4.name = c2(e4.name, t4, e4), f2.push(e4)) : (o4 && i3 || p2 || (e4.isConstant = true), f2.push(e4));
    }, true, h2, m2);
    const y2 = [];
    let g2;
    return f2.sort((e4, t4) => e4.start - t4.start), f2.forEach((t4, r4) => {
      const n3 = t4.start - 1, s4 = t4.end - 1, i3 = f2[r4 - 1], o4 = u2.slice(i3 ? i3.end - 1 : 0, n3);
      (o4.length || t4.prefix) && y2.push(o4 + (t4.prefix || ""));
      const a4 = u2.slice(n3, s4);
      y2.push(ee(t4.name, false, { start: Ke(e3.loc.start, a4, n3), end: Ke(e3.loc.start, a4, s4), source: a4 }, t4.isConstant ? 3 : 0)), r4 === f2.length - 1 && s4 < u2.length && y2.push(u2.slice(s4));
    }), y2.length ? (g2 = te(y2, e3.loc), g2.ast = d2) : (g2 = e3, g2.constType = p2 ? 0 : 3), g2.identifiers = Object.keys(m2), g2;
  }
  function xr(e3) {
    return n2.isString(e3) ? e3 : 4 === e3.type ? e3.content : e3.children.map(xr).join("");
  }
  function Tr(e3) {
    return "setup-const" === e3 || "literal-const" === e3;
  }
  const wr = sr(/^(if|else|else-if)$/, (e3, t3, r3) => Pr(e3, t3, r3, (e4, t4, n3) => {
    const s3 = r3.parent.children;
    let i3 = s3.indexOf(e4), o3 = 0;
    for (; i3-- >= 0; ) {
      const e5 = s3[i3];
      e5 && 9 === e5.type && (o3 += e5.branches.length);
    }
    return () => {
      if (n3) e4.codegenNode = Cr(t4, o3, r3);
      else {
        const n4 = function(e5) {
          for (; ; ) if (19 === e5.type) {
            if (19 !== e5.alternate.type) return e5;
            e5 = e5.alternate;
          } else 20 === e5.type && (e5 = e5.value);
        }(e4.codegenNode);
        n4.alternate = Cr(t4, o3 + e4.branches.length - 1, r3);
      }
    };
  }));
  function Pr(e3, t3, r3, n3) {
    if (!("else" === t3.name || t3.exp && t3.exp.content.trim())) {
      const n4 = t3.exp ? t3.exp.loc : e3.loc;
      r3.onError(Te(28, t3.loc)), t3.exp = ee("true", false, n4);
    }
    if (r3.prefixIdentifiers && t3.exp && (t3.exp = Sr(t3.exp, r3)), "if" === t3.name) {
      const s3 = Ar(e3, t3), i3 = { type: 9, loc: e3.loc, branches: [s3] };
      if (r3.replaceNode(i3), n3) return n3(i3, s3, true);
    } else {
      const s3 = r3.parent.children;
      let i3 = s3.indexOf(e3);
      for (; i3-- >= -1; ) {
        const o3 = s3[i3];
        if (o3 && 3 === o3.type) r3.removeNode(o3);
        else {
          if (!o3 || 2 !== o3.type || o3.content.trim().length) {
            if (o3 && 9 === o3.type) {
              "else-if" === t3.name && void 0 === o3.branches[o3.branches.length - 1].condition && r3.onError(Te(30, e3.loc)), r3.removeNode();
              const s4 = Ar(e3, t3);
              {
                const e4 = s4.userKey;
                e4 && o3.branches.forEach((t4) => {
                  let { userKey: n4 } = t4;
                  Ir(n4, e4) && r3.onError(Te(29, s4.userKey.loc));
                });
              }
              o3.branches.push(s4);
              const i4 = n3 && n3(o3, s4, false);
              nr(s4, r3), i4 && i4(), r3.currentNode = null;
            } else r3.onError(Te(30, e3.loc));
            break;
          }
          r3.removeNode(o3);
        }
      }
    }
  }
  function Ar(e3, t3) {
    const r3 = 3 === e3.tagType;
    return { type: 10, loc: e3.loc, condition: "else" === t3.name ? void 0 : t3.exp, children: r3 && !Je(e3, "for") ? e3.children : [e3], userKey: Ye(e3, "key"), isTemplateIf: r3 };
  }
  function Cr(e3, t3, r3) {
    return e3.condition ? se(e3.condition, Or(e3, t3, r3), re(r3.helper(b), ['""', "true"])) : Or(e3, t3, r3);
  }
  function Or(e3, t3, r3) {
    const { helper: s3 } = r3, i3 = Z("key", ee(`${t3}`, false, K, 2)), { children: o3 } = e3, a3 = o3[0];
    if (1 !== o3.length || 1 !== a3.type) {
      if (1 === o3.length && 11 === a3.type) {
        const e4 = a3.codegenNode;
        return it(e4, i3, r3), e4;
      }
      {
        let t4 = 64;
        return n2.PatchFlagNames[64], J(r3, s3(l), Q([i3]), o3, t4 + "", void 0, void 0, true, false, false, e3.loc);
      }
    }
    {
      const e4 = a3.codegenNode, t4 = ct(e4);
      return 13 === t4.type && ce(t4, r3), it(t4, i3, r3), e4;
    }
  }
  function Ir(e3, t3) {
    if (!e3 || e3.type !== t3.type) return false;
    if (6 === e3.type) {
      if (e3.value.content !== t3.value.content) return false;
    } else {
      const r3 = e3.exp, n3 = t3.exp;
      if (r3.type !== n3.type) return false;
      if (4 !== r3.type || r3.isStatic !== n3.isStatic || r3.content !== n3.content) return false;
    }
    return true;
  }
  const _r = sr("for", (e3, t3, r3) => {
    const { helper: n3, removeHelper: s3 } = r3;
    return kr(e3, t3, r3, (t4) => {
      const i3 = re(n3(A), [t4.source]), o3 = tt(e3), a3 = Je(e3, "memo"), c2 = Ye(e3, "key"), u2 = c2 && (6 === c2.type ? ee(c2.value.content, true) : c2.exp), p2 = c2 ? Z("key", u2) : null;
      o3 && (a3 && (a3.exp = Sr(a3.exp, r3)), p2 && 6 !== c2.type && (p2.value = Sr(p2.value, r3)));
      const d2 = 4 === t4.source.type && t4.source.constType > 0, h2 = d2 ? 64 : c2 ? 128 : 256;
      return t4.codegenNode = J(r3, n3(l), void 0, i3, h2 + "", void 0, void 0, true, !d2, false, e3.loc), () => {
        let c3;
        const { children: h3 } = t4;
        o3 && e3.children.some((e4) => {
          if (1 === e4.type) {
            const t5 = Ye(e4, "key");
            if (t5) return r3.onError(Te(33, t5.loc)), true;
          }
        });
        const m2 = 1 !== h3.length || 1 !== h3[0].type, y2 = rt(e3) ? e3 : o3 && 1 === e3.children.length && rt(e3.children[0]) ? e3.children[0] : null;
        if (y2 ? (c3 = y2.codegenNode, o3 && p2 && it(c3, p2, r3)) : m2 ? c3 = J(r3, n3(l), p2 ? Q([p2]) : void 0, e3.children, "64", void 0, void 0, true, void 0, false) : (c3 = h3[0].codegenNode, o3 && p2 && it(c3, p2, r3), c3.isBlock !== !d2 && (c3.isBlock ? (s3(f), s3(le(r3.inSSR, c3.isComponent))) : s3(ae(r3.inSSR, c3.isComponent))), c3.isBlock = !d2, c3.isBlock ? (n3(f), n3(le(r3.inSSR, c3.isComponent))) : n3(ae(r3.inSSR, c3.isComponent))), a3) {
          const e4 = ne(Dr(t4.parseResult, [ee("_cached")]));
          e4.body = oe([te(["const _memo = (", a3.exp, ")"]), te(["if (_cached", ...u2 ? [" && _cached.key === ", u2] : [], ` && ${r3.helperString(H)}(_cached, _memo)) return _cached`]), te(["const _item = ", c3]), ee("_item.memo = _memo"), ee("return _item")]), i3.arguments.push(e4, ee("_cache"), ee(String(r3.cached++)));
        } else i3.arguments.push(ne(Dr(t4.parseResult), c3, true));
      };
    });
  });
  function kr(e3, t3, r3, n3) {
    if (!t3.exp) return void r3.onError(Te(31, t3.loc));
    const s3 = t3.forParseResult;
    if (!s3) return void r3.onError(Te(32, t3.loc));
    Nr(s3, r3);
    const { addIdentifiers: i3, removeIdentifiers: o3, scopes: a3 } = r3, { source: l2, value: c2, key: u2, index: p2 } = s3, d2 = { type: 11, loc: t3.loc, source: l2, valueAlias: c2, keyAlias: u2, objectIndexAlias: p2, parseResult: s3, children: tt(e3) ? e3.children : [e3] };
    r3.replaceNode(d2), a3.vFor++, r3.prefixIdentifiers && (c2 && i3(c2), u2 && i3(u2), p2 && i3(p2));
    const f2 = n3 && n3(d2);
    return () => {
      a3.vFor--, r3.prefixIdentifiers && (c2 && o3(c2), u2 && o3(u2), p2 && o3(p2)), f2 && f2();
    };
  }
  function Nr(e3, t3) {
    e3.finalized || (t3.prefixIdentifiers && (e3.source = Sr(e3.source, t3), e3.key && (e3.key = Sr(e3.key, t3, true)), e3.index && (e3.index = Sr(e3.index, t3, true)), e3.value && (e3.value = Sr(e3.value, t3, true))), e3.finalized = true);
  }
  function Dr(e3) {
    let { value: t3, key: r3, index: n3 } = e3;
    return function(e4) {
      let t4 = e4.length;
      for (; t4-- && !e4[t4]; ) ;
      return e4.slice(0, t4 + 1).map((e5, t5) => e5 || ee("_".repeat(t5 + 1), false));
    }([t3, r3, n3, ...arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []]);
  }
  const jr = ee("undefined", false), Lr = (e3, t3) => {
    if (1 === e3.type && (1 === e3.tagType || 3 === e3.tagType)) {
      const r3 = Je(e3, "slot");
      if (r3) {
        const e4 = r3.exp;
        return t3.prefixIdentifiers && e4 && t3.addIdentifiers(e4), t3.scopes.vSlot++, () => {
          t3.prefixIdentifiers && e4 && t3.removeIdentifiers(e4), t3.scopes.vSlot--;
        };
      }
    }
  }, Mr = (e3, t3) => {
    let r3;
    if (tt(e3) && e3.props.some(et) && (r3 = Je(e3, "for"))) {
      const e4 = r3.forParseResult;
      if (e4) {
        Nr(e4, t3);
        const { value: r4, key: n3, index: s3 } = e4, { addIdentifiers: i3, removeIdentifiers: o3 } = t3;
        return r4 && i3(r4), n3 && i3(n3), s3 && i3(s3), () => {
          r4 && o3(r4), n3 && o3(n3), s3 && o3(s3);
        };
      }
    }
  }, Br = (e3, t3, r3, n3) => ne(e3, r3, false, true, r3.length ? r3[0].loc : n3);
  function Rr(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Br;
    t3.helper(V);
    const { children: n3, loc: s3 } = e3, i3 = [], o3 = [];
    let a3 = t3.scopes.vSlot > 0 || t3.scopes.vFor > 0;
    !t3.ssr && t3.prefixIdentifiers && (a3 = lt(e3, t3.identifiers));
    const l2 = Je(e3, "slot", true);
    if (l2) {
      const { arg: e4, exp: t4 } = l2;
      e4 && !Fe(e4) && (a3 = true), i3.push(Z(e4 || ee("default", true), r3(t4, void 0, n3, s3)));
    }
    let c2 = false, u2 = false;
    const p2 = [], d2 = /* @__PURE__ */ new Set();
    let f2 = 0;
    for (let e4 = 0; e4 < n3.length; e4++) {
      const s4 = n3[e4];
      let h3;
      if (!tt(s4) || !(h3 = Je(s4, "slot", true))) {
        3 !== s4.type && p2.push(s4);
        continue;
      }
      if (l2) {
        t3.onError(Te(37, h3.loc));
        break;
      }
      c2 = true;
      const { children: m3, loc: y2 } = s4, { arg: g2 = ee("default", true), exp: b2, loc: v2 } = h3;
      let E2;
      Fe(g2) ? E2 = g2 ? g2.content : "default" : a3 = true;
      const S2 = Je(s4, "for"), x2 = r3(b2, S2, m3, y2);
      let T2, w2;
      if (T2 = Je(s4, "if")) a3 = true, o3.push(se(T2.exp, Fr(g2, x2, f2++), jr));
      else if (w2 = Je(s4, /^else(-if)?$/, true)) {
        let r4, s5 = e4;
        for (; s5-- && (r4 = n3[s5], 3 === r4.type); ) ;
        if (r4 && tt(r4) && Je(r4, "if")) {
          n3.splice(e4, 1), e4--;
          let t4 = o3[o3.length - 1];
          for (; 19 === t4.alternate.type; ) t4 = t4.alternate;
          t4.alternate = w2.exp ? se(w2.exp, Fr(g2, x2, f2++), jr) : Fr(g2, x2, f2++);
        } else t3.onError(Te(30, w2.loc));
      } else if (S2) {
        a3 = true;
        const e5 = S2.forParseResult;
        e5 ? (Nr(e5, t3), o3.push(re(t3.helper(A), [e5.source, ne(Dr(e5), Fr(g2, x2), true)]))) : t3.onError(Te(32, S2.loc));
      } else {
        if (E2) {
          if (d2.has(E2)) {
            t3.onError(Te(38, v2));
            continue;
          }
          d2.add(E2), "default" === E2 && (u2 = true);
        }
        i3.push(Z(g2, x2));
      }
    }
    if (!l2) {
      const e4 = (e5, n4) => {
        const i4 = r3(e5, void 0, n4, s3);
        return t3.compatConfig && (i4.isNonScopedSlot = true), Z("default", i4);
      };
      c2 ? p2.length && p2.some((e5) => $r(e5)) && (u2 ? t3.onError(Te(39, p2[0].loc)) : i3.push(e4(void 0, p2))) : i3.push(e4(void 0, n3));
    }
    const h2 = a3 ? 2 : Ur(e3.children) ? 3 : 1;
    let m2 = Q(i3.concat(Z("_", ee(h2 + "", false))), s3);
    return o3.length && (m2 = re(t3.helper(O), [m2, Y(o3)])), { slots: m2, hasDynamicSlots: a3 };
  }
  function Fr(e3, t3, r3) {
    const n3 = [Z("name", e3), Z("fn", t3)];
    return null != r3 && n3.push(Z("key", ee(String(r3), true))), Q(n3);
  }
  function Ur(e3) {
    for (let t3 = 0; t3 < e3.length; t3++) {
      const r3 = e3[t3];
      switch (r3.type) {
        case 1:
          if (2 === r3.tagType || Ur(r3.children)) return true;
          break;
        case 9:
          if (Ur(r3.branches)) return true;
          break;
        case 10:
        case 11:
          if (Ur(r3.children)) return true;
      }
    }
    return false;
  }
  function $r(e3) {
    return 2 !== e3.type && 12 !== e3.type || (2 === e3.type ? !!e3.content.trim() : $r(e3.content));
  }
  const Vr = /* @__PURE__ */ new WeakMap(), qr = (e3, t3) => function() {
    if (1 !== (e3 = t3.currentNode).type || 0 !== e3.tagType && 1 !== e3.tagType) return;
    const { tag: r3, props: s3 } = e3, i3 = 1 === e3.tagType;
    let o3 = i3 ? Wr(e3, t3) : `"${r3}"`;
    const a3 = n2.isObject(o3) && o3.callee === x;
    let l2, d2, f2, h2, m2, y2, g2 = 0, b2 = a3 || o3 === c || o3 === u || !i3 && ("svg" === r3 || "foreignObject" === r3);
    if (s3.length > 0) {
      const r4 = Hr(e3, t3, void 0, i3, a3);
      l2 = r4.props, g2 = r4.patchFlag, m2 = r4.dynamicPropNames;
      const n3 = r4.directives;
      y2 = n3 && n3.length ? Y(n3.map((e4) => Xr(e4, t3))) : void 0, r4.shouldUseBlock && (b2 = true);
    }
    if (e3.children.length > 0) if (o3 === p && (b2 = true, g2 |= 1024), i3 && o3 !== c && o3 !== p) {
      const { slots: r4, hasDynamicSlots: n3 } = Rr(e3, t3);
      d2 = r4, n3 && (g2 |= 1024);
    } else if (1 === e3.children.length && o3 !== c) {
      const r4 = e3.children[0], n3 = r4.type, s4 = 5 === n3 || 8 === n3;
      s4 && 0 === Xt(r4, t3) && (g2 |= 1), d2 = s4 || 2 === n3 ? r4 : e3.children;
    } else d2 = e3.children;
    0 !== g2 && (f2 = String(g2), m2 && m2.length && (h2 = function(e4) {
      let t4 = "[";
      for (let r4 = 0, n3 = e4.length; r4 < n3; r4++) t4 += JSON.stringify(e4[r4]), r4 < n3 - 1 && (t4 += ", ");
      return t4 + "]";
    }(m2))), e3.codegenNode = J(t3, o3, l2, d2, f2, h2, y2, !!b2, false, i3, e3.loc);
  };
  function Wr(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], { tag: s3 } = e3;
    const i3 = Jr(s3), o3 = Ye(e3, "is");
    if (o3) if (i3 || ve("COMPILER_IS_ON_ELEMENT", t3)) {
      const e4 = 6 === o3.type ? o3.value && ee(o3.value.content, true) : o3.exp;
      if (e4) return re(t3.helper(x), [e4]);
    } else 6 === o3.type && o3.value.content.startsWith("vue:") && (s3 = o3.value.content.slice(4));
    const a3 = Ue(s3) || t3.isBuiltInComponent(s3);
    if (a3) return r3 || t3.helper(a3), a3;
    {
      const e4 = Gr(s3, t3);
      if (e4) return e4;
      const r4 = s3.indexOf(".");
      if (r4 > 0) {
        const e5 = Gr(s3.slice(0, r4), t3);
        if (e5) return e5 + s3.slice(r4);
      }
    }
    return t3.selfName && n2.capitalize(n2.camelize(s3)) === t3.selfName ? (t3.helper(S), t3.components.add(s3 + "__self"), at(s3, "component")) : (t3.helper(S), t3.components.add(s3), at(s3, "component"));
  }
  function Gr(e3, t3) {
    const r3 = t3.bindingMetadata;
    if (!r3 || false === r3.__isScriptSetup) return;
    const s3 = n2.camelize(e3), i3 = n2.capitalize(s3), o3 = (t4) => r3[e3] === t4 ? e3 : r3[s3] === t4 ? s3 : r3[i3] === t4 ? i3 : void 0, a3 = o3("setup-const") || o3("setup-reactive-const") || o3("literal-const");
    if (a3) return t3.inline ? a3 : `$setup[${JSON.stringify(a3)}]`;
    const l2 = o3("setup-let") || o3("setup-ref") || o3("setup-maybe-ref");
    if (l2) return t3.inline ? `${t3.helperString(q)}(${l2})` : `$setup[${JSON.stringify(l2)}]`;
    const c2 = o3("props");
    return c2 ? `${t3.helperString(q)}(${t3.inline ? "__props" : "$props"}[${JSON.stringify(c2)}])` : void 0;
  }
  function Hr(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e3.props, s3 = arguments.length > 3 ? arguments[3] : void 0, i3 = arguments.length > 4 ? arguments[4] : void 0, o3 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
    const { tag: a3, loc: l2, children: c2 } = e3;
    let u2 = [];
    const p2 = [], d2 = [], f2 = c2.length > 0;
    let h2 = false, m2 = 0, y2 = false, g2 = false, b2 = false, v2 = false, E2 = false, S2 = false;
    const x2 = [], T2 = (e4) => {
      u2.length && (p2.push(Q(zr(u2), l2)), u2 = []), e4 && p2.push(e4);
    }, w2 = (e4) => {
      let { key: r4, value: o4 } = e4;
      if (Fe(r4)) {
        const e5 = r4.content, a4 = n2.isOn(e5);
        if (!a4 || s3 && !i3 || "onclick" === e5.toLowerCase() || "onUpdate:modelValue" === e5 || n2.isReservedProp(e5) || (v2 = true), a4 && n2.isReservedProp(e5) && (S2 = true), a4 && 14 === o4.type && (o4 = o4.arguments[0]), 20 === o4.type || (4 === o4.type || 8 === o4.type) && Xt(o4, t3) > 0) return;
        "ref" === e5 ? y2 = true : "class" === e5 ? g2 = true : "style" === e5 ? b2 = true : "key" === e5 || x2.includes(e5) || x2.push(e5), !s3 || "class" !== e5 && "style" !== e5 || x2.includes(e5) || x2.push(e5);
      } else E2 = true;
    };
    for (let i4 = 0; i4 < r3.length; i4++) {
      const c3 = r3[i4];
      if (6 === c3.type) {
        const { loc: e4, name: r4, nameLoc: n3, value: s4 } = c3;
        let i5 = true;
        if ("ref" === r4 && (y2 = true, t3.scopes.vFor > 0 && u2.push(Z(ee("ref_for", true), ee("true"))), s4 && t3.inline)) {
          const e5 = t3.bindingMetadata[s4.content];
          "setup-let" !== e5 && "setup-ref" !== e5 && "setup-maybe-ref" !== e5 || (i5 = false, u2.push(Z(ee("ref_key", true), ee(s4.content, true, s4.loc))));
        }
        if ("is" === r4 && (Jr(a3) || s4 && s4.content.startsWith("vue:") || ve("COMPILER_IS_ON_ELEMENT", t3))) continue;
        u2.push(Z(ee(r4, true, n3), ee(s4 ? s4.content : "", i5, s4 ? s4.loc : e4)));
      } else {
        const { name: r4, arg: i5, exp: y3, loc: g3, modifiers: b3 } = c3, v3 = "bind" === r4, S3 = "on" === r4;
        if ("slot" === r4) {
          s3 || t3.onError(Te(40, g3));
          continue;
        }
        if ("once" === r4 || "memo" === r4) continue;
        if ("is" === r4 || v3 && Qe(i5, "is") && (Jr(a3) || ve("COMPILER_IS_ON_ELEMENT", t3))) continue;
        if (S3 && o3) continue;
        if ((v3 && Qe(i5, "key") || S3 && f2 && Qe(i5, "vue:before-update")) && (h2 = true), v3 && Qe(i5, "ref") && t3.scopes.vFor > 0 && u2.push(Z(ee("ref_for", true), ee("true"))), !i5 && (v3 || S3)) {
          if (E2 = true, y3) if (v3) {
            if (T2(), ve("COMPILER_V_BIND_OBJECT_ORDER", t3)) {
              p2.unshift(y3);
              continue;
            }
            p2.push(y3);
          } else T2({ type: 14, loc: g3, callee: t3.helper(L), arguments: s3 ? [y3] : [y3, "true"] });
          else t3.onError(Te(v3 ? 34 : 35, g3));
          continue;
        }
        v3 && b3.includes("prop") && (m2 |= 32);
        const x3 = t3.directiveTransforms[r4];
        if (x3) {
          const { props: r5, needRuntime: s4 } = x3(c3, e3, t3);
          !o3 && r5.forEach(w2), S3 && i5 && !Fe(i5) ? T2(Q(r5, l2)) : u2.push(...r5), s4 && (d2.push(c3), n2.isSymbol(s4) && Vr.set(c3, s4));
        } else n2.isBuiltInDirective(r4) || (d2.push(c3), f2 && (h2 = true));
      }
    }
    let P2;
    if (p2.length ? (T2(), P2 = p2.length > 1 ? re(t3.helper(_), p2, l2) : p2[0]) : u2.length && (P2 = Q(zr(u2), l2)), E2 ? m2 |= 16 : (g2 && !s3 && (m2 |= 2), b2 && !s3 && (m2 |= 4), x2.length && (m2 |= 8), v2 && (m2 |= 32)), h2 || 0 !== m2 && 32 !== m2 || !(y2 || S2 || d2.length > 0) || (m2 |= 512), !t3.inSSR && P2) switch (P2.type) {
      case 15:
        let e4 = -1, r4 = -1, n3 = false;
        for (let t4 = 0; t4 < P2.properties.length; t4++) {
          const s5 = P2.properties[t4].key;
          Fe(s5) ? "class" === s5.content ? e4 = t4 : "style" === s5.content && (r4 = t4) : s5.isHandlerKey || (n3 = true);
        }
        const s4 = P2.properties[e4], i4 = P2.properties[r4];
        n3 ? P2 = re(t3.helper(D), [P2]) : (s4 && !Fe(s4.value) && (s4.value = re(t3.helper(k), [s4.value])), i4 && (b2 || 4 === i4.value.type && "[" === i4.value.content.trim()[0] || 17 === i4.value.type) && (i4.value = re(t3.helper(N), [i4.value])));
        break;
      case 14:
        break;
      default:
        P2 = re(t3.helper(D), [re(t3.helper(j), [P2])]);
    }
    return { props: P2, directives: d2, patchFlag: m2, dynamicPropNames: x2, shouldUseBlock: h2 };
  }
  function zr(e3) {
    const t3 = /* @__PURE__ */ new Map(), r3 = [];
    for (let s3 = 0; s3 < e3.length; s3++) {
      const i3 = e3[s3];
      if (8 === i3.key.type || !i3.key.isStatic) {
        r3.push(i3);
        continue;
      }
      const o3 = i3.key.content, a3 = t3.get(o3);
      a3 ? ("style" === o3 || "class" === o3 || n2.isOn(o3)) && Kr(a3, i3) : (t3.set(o3, i3), r3.push(i3));
    }
    return r3;
  }
  function Kr(e3, t3) {
    17 === e3.value.type ? e3.value.elements.push(t3.value) : e3.value = Y([e3.value, t3.value], e3.loc);
  }
  function Xr(e3, t3) {
    const r3 = [], n3 = Vr.get(e3);
    if (n3) r3.push(t3.helperString(n3));
    else {
      const n4 = Gr("v-" + e3.name, t3);
      n4 ? r3.push(n4) : (t3.helper(T), t3.directives.add(e3.name), r3.push(at(e3.name, "directive")));
    }
    const { loc: s3 } = e3;
    if (e3.exp && r3.push(e3.exp), e3.arg && (e3.exp || r3.push("void 0"), r3.push(e3.arg)), Object.keys(e3.modifiers).length) {
      e3.arg || (e3.exp || r3.push("void 0"), r3.push("void 0"));
      const t4 = ee("true", false, s3);
      r3.push(Q(e3.modifiers.map((e4) => Z(e4, t4)), s3));
    }
    return Y(r3, e3.loc);
  }
  function Jr(e3) {
    return "component" === e3 || "Component" === e3;
  }
  const Yr = (e3, t3) => {
    if (rt(e3)) {
      const { children: r3, loc: n3 } = e3, { slotName: s3, slotProps: i3 } = Qr(e3, t3), o3 = [t3.prefixIdentifiers ? "_ctx.$slots" : "$slots", s3, "{}", "undefined", "true"];
      let a3 = 2;
      i3 && (o3[2] = i3, a3 = 3), r3.length && (o3[3] = ne([], r3, false, false, n3), a3 = 4), t3.scopeId && !t3.slotted && (a3 = 5), o3.splice(a3), e3.codegenNode = re(t3.helper(C), o3, n3);
    }
  };
  function Qr(e3, t3) {
    let r3, s3 = '"default"';
    const i3 = [];
    for (let t4 = 0; t4 < e3.props.length; t4++) {
      const r4 = e3.props[t4];
      6 === r4.type ? r4.value && ("name" === r4.name ? s3 = JSON.stringify(r4.value.content) : (r4.name = n2.camelize(r4.name), i3.push(r4))) : "bind" === r4.name && Qe(r4.arg, "name") ? r4.exp && (s3 = r4.exp) : ("bind" === r4.name && r4.arg && Fe(r4.arg) && (r4.arg.content = n2.camelize(r4.arg.content)), i3.push(r4));
    }
    if (i3.length > 0) {
      const { props: n3, directives: s4 } = Hr(e3, t3, i3, false, false);
      r3 = n3, s4.length && t3.onError(Te(36, s4[0].loc));
    }
    return { slotName: s3, slotProps: r3 };
  }
  const Zr = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/, en = (e3, t3, r3, s3) => {
    const { loc: i3, modifiers: o3, arg: a3 } = e3;
    let l2;
    if (e3.exp || o3.length || r3.onError(Te(35, i3)), 4 === a3.type) if (a3.isStatic) {
      let e4 = a3.content;
      e4.startsWith("vue:") && (e4 = `vnode-${e4.slice(4)}`), l2 = ee(0 !== t3.tagType || e4.startsWith("vnode") || !/[A-Z]/.test(e4) ? n2.toHandlerKey(n2.camelize(e4)) : `on:${e4}`, true, a3.loc);
    } else l2 = te([`${r3.helperString(R)}(`, a3, ")"]);
    else l2 = a3, l2.children.unshift(`${r3.helperString(R)}(`), l2.children.push(")");
    let c2 = e3.exp;
    c2 && !c2.content.trim() && (c2 = void 0);
    let u2 = r3.cacheHandlers && !c2 && !r3.inVOnce;
    if (c2) {
      const n3 = ze(c2.content, r3), s4 = !(n3 || Zr.test(c2.content)), i4 = c2.content.includes(";");
      r3.prefixIdentifiers && (s4 && r3.addIdentifiers("$event"), c2 = e3.exp = Sr(c2, r3, false, i4), s4 && r3.removeIdentifiers("$event"), u2 = r3.cacheHandlers && !r3.inVOnce && !(4 === c2.type && c2.constType > 0) && !(n3 && 1 === t3.tagType) && !lt(c2, r3.identifiers), u2 && n3 && (4 === c2.type ? c2.content = `${c2.content} && ${c2.content}(...args)` : c2.children = [...c2.children, " && ", ...c2.children, "(...args)"])), (s4 || u2 && n3) && (c2 = te([`${s4 ? r3.isTS ? "($event: any)" : "$event" : (r3.isTS ? "\n//@ts-ignore\n" : "") + "(...args)"} => ${i4 ? "{" : "("}`, c2, i4 ? "}" : ")"]));
    }
    let p2 = { props: [Z(l2, c2 || ee("() => {}", false, i3))] };
    return s3 && (p2 = s3(p2)), u2 && (p2.props[0].value = r3.cache(p2.props[0].value)), p2.props.forEach((e4) => e4.key.isHandlerKey = true), p2;
  }, tn = (e3, t3, r3) => {
    const { modifiers: s3, loc: i3 } = e3, o3 = e3.arg;
    let { exp: a3 } = e3;
    if (!a3 && 4 === o3.type) {
      const t4 = n2.camelize(o3.content);
      a3 = e3.exp = ee(t4, false, o3.loc), a3 = e3.exp = Sr(a3, r3);
    }
    return 4 !== o3.type ? (o3.children.unshift("("), o3.children.push(') || ""')) : o3.isStatic || (o3.content = `${o3.content} || ""`), s3.includes("camel") && (4 === o3.type ? o3.isStatic ? o3.content = n2.camelize(o3.content) : o3.content = `${r3.helperString(M)}(${o3.content})` : (o3.children.unshift(`${r3.helperString(M)}(`), o3.children.push(")"))), r3.inSSR || (s3.includes("prop") && rn(o3, "."), s3.includes("attr") && rn(o3, "^")), !a3 || 4 === a3.type && !a3.content.trim() ? (r3.onError(Te(34, i3)), { props: [Z(o3, ee("", true, i3))] }) : { props: [Z(o3, a3)] };
  }, rn = (e3, t3) => {
    4 === e3.type ? e3.isStatic ? e3.content = t3 + e3.content : e3.content = `\`${t3}\${${e3.content}}\`` : (e3.children.unshift(`'${t3}' + (`), e3.children.push(")"));
  }, nn = (e3, t3) => {
    if (0 === e3.type || 1 === e3.type || 11 === e3.type || 10 === e3.type) return () => {
      const r3 = e3.children;
      let n3, s3 = false;
      for (let e4 = 0; e4 < r3.length; e4++) {
        const t4 = r3[e4];
        if (Ze(t4)) {
          s3 = true;
          for (let s4 = e4 + 1; s4 < r3.length; s4++) {
            const i3 = r3[s4];
            if (!Ze(i3)) {
              n3 = void 0;
              break;
            }
            n3 || (n3 = r3[e4] = te([t4], t4.loc)), n3.children.push(" + ", i3), r3.splice(s4, 1), s4--;
          }
        }
      }
      if (s3 && (1 !== r3.length || 0 !== e3.type && (1 !== e3.type || 0 !== e3.tagType || e3.props.find((e4) => 7 === e4.type && !t3.directiveTransforms[e4.name]) || "template" === e3.tag))) for (let e4 = 0; e4 < r3.length; e4++) {
        const n4 = r3[e4];
        if (Ze(n4) || 8 === n4.type) {
          const s4 = [];
          2 === n4.type && " " === n4.content || s4.push(n4), t3.ssr || 0 !== Xt(n4, t3) || s4.push("1"), r3[e4] = { type: 12, content: n4, loc: n4.loc, codegenNode: re(t3.helper(v), s4) };
        }
      }
    };
  }, sn = /* @__PURE__ */ new WeakSet(), on = (e3, t3) => {
    if (1 === e3.type && Je(e3, "once", true)) {
      if (sn.has(e3) || t3.inVOnce || t3.inSSR) return;
      return sn.add(e3), t3.inVOnce = true, t3.helper(F), () => {
        t3.inVOnce = false;
        const e4 = t3.currentNode;
        e4.codegenNode && (e4.codegenNode = t3.cache(e4.codegenNode, true));
      };
    }
  }, an = (e3, t3, r3) => {
    const { exp: s3, arg: i3 } = e3;
    if (!s3) return r3.onError(Te(41, e3.loc)), ln();
    const o3 = s3.loc.source, a3 = 4 === s3.type ? s3.content : o3, l2 = r3.bindingMetadata[o3];
    if ("props" === l2 || "props-aliased" === l2) return r3.onError(Te(44, s3.loc)), ln();
    const c2 = r3.inline && ("setup-let" === l2 || "setup-ref" === l2 || "setup-maybe-ref" === l2);
    if (!a3.trim() || !ze(a3, r3) && !c2) return r3.onError(Te(42, s3.loc)), ln();
    if (r3.prefixIdentifiers && Ve(a3) && r3.identifiers[a3]) return r3.onError(Te(43, s3.loc)), ln();
    const u2 = i3 || ee("modelValue", true), p2 = i3 ? Fe(i3) ? `onUpdate:${n2.camelize(i3.content)}` : te(['"onUpdate:" + ', i3]) : "onUpdate:modelValue";
    let d2;
    const f2 = r3.isTS ? "($event: any)" : "$event";
    if (c2) if ("setup-ref" === l2) d2 = te([`${f2} => ((`, ee(o3, false, s3.loc), ").value = $event)"]);
    else {
      const e4 = "setup-let" === l2 ? `${o3} = $event` : "null";
      d2 = te([`${f2} => (${r3.helperString(W)}(${o3}) ? (`, ee(o3, false, s3.loc), `).value = $event : ${e4})`]);
    }
    else d2 = te([`${f2} => ((`, s3, ") = $event)"]);
    const h2 = [Z(u2, e3.exp), Z(p2, d2)];
    if (r3.prefixIdentifiers && !r3.inVOnce && r3.cacheHandlers && !lt(s3, r3.identifiers) && (h2[1].value = r3.cache(h2[1].value)), e3.modifiers.length && 1 === t3.tagType) {
      const t4 = e3.modifiers.map((e4) => (Ve(e4) ? e4 : JSON.stringify(e4)) + ": true").join(", "), r4 = i3 ? Fe(i3) ? `${i3.content}Modifiers` : te([i3, ' + "Modifiers"']) : "modelModifiers";
      h2.push(Z(r4, ee(`{ ${t4} }`, false, e3.loc, 2)));
    }
    return ln(h2);
  };
  function ln() {
    return { props: arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [] };
  }
  const cn = /[\w).+\-_$\]]/, un = (e3, t3) => {
    ve("COMPILER_FILTERS", t3) && (5 === e3.type && pn(e3.content, t3), 1 === e3.type && e3.props.forEach((e4) => {
      7 === e4.type && "for" !== e4.name && e4.exp && pn(e4.exp, t3);
    }));
  };
  function pn(e3, t3) {
    if (4 === e3.type) dn(e3, t3);
    else for (let r3 = 0; r3 < e3.children.length; r3++) {
      const n3 = e3.children[r3];
      "object" == typeof n3 && (4 === n3.type ? dn(n3, t3) : 8 === n3.type ? pn(e3, t3) : 5 === n3.type && pn(n3.content, t3));
    }
  }
  function dn(e3, t3) {
    const r3 = e3.content;
    let n3, s3, i3, o3, a3 = false, l2 = false, c2 = false, u2 = false, p2 = 0, d2 = 0, f2 = 0, h2 = 0, m2 = [];
    for (i3 = 0; i3 < r3.length; i3++) if (s3 = n3, n3 = r3.charCodeAt(i3), a3) 39 === n3 && 92 !== s3 && (a3 = false);
    else if (l2) 34 === n3 && 92 !== s3 && (l2 = false);
    else if (c2) 96 === n3 && 92 !== s3 && (c2 = false);
    else if (u2) 47 === n3 && 92 !== s3 && (u2 = false);
    else if (124 !== n3 || 124 === r3.charCodeAt(i3 + 1) || 124 === r3.charCodeAt(i3 - 1) || p2 || d2 || f2) {
      switch (n3) {
        case 34:
          l2 = true;
          break;
        case 39:
          a3 = true;
          break;
        case 96:
          c2 = true;
          break;
        case 40:
          f2++;
          break;
        case 41:
          f2--;
          break;
        case 91:
          d2++;
          break;
        case 93:
          d2--;
          break;
        case 123:
          p2++;
          break;
        case 125:
          p2--;
      }
      if (47 === n3) {
        let e4, t4 = i3 - 1;
        for (; t4 >= 0 && (e4 = r3.charAt(t4), " " === e4); t4--) ;
        e4 && cn.test(e4) || (u2 = true);
      }
    } else void 0 === o3 ? (h2 = i3 + 1, o3 = r3.slice(0, i3).trim()) : y2();
    function y2() {
      m2.push(r3.slice(h2, i3).trim()), h2 = i3 + 1;
    }
    if (void 0 === o3 ? o3 = r3.slice(0, i3).trim() : 0 !== h2 && y2(), m2.length) {
      for (i3 = 0; i3 < m2.length; i3++) o3 = fn(o3, m2[i3], t3);
      e3.content = o3;
    }
  }
  function fn(e3, t3, r3) {
    r3.helper(w);
    const n3 = t3.indexOf("(");
    if (n3 < 0) return r3.filters.add(t3), `${at(t3, "filter")}(${e3})`;
    {
      const s3 = t3.slice(0, n3), i3 = t3.slice(n3 + 1);
      return r3.filters.add(s3), `${at(s3, "filter")}(${e3}${")" !== i3 ? "," + i3 : i3}`;
    }
  }
  const hn = /* @__PURE__ */ new WeakSet(), mn = (e3, t3) => {
    if (1 === e3.type) {
      const r3 = Je(e3, "memo");
      if (!r3 || hn.has(e3)) return;
      return hn.add(e3), () => {
        const n3 = e3.codegenNode || t3.currentNode.codegenNode;
        n3 && 13 === n3.type && (1 !== e3.tagType && ce(n3, t3), e3.codegenNode = re(t3.helper(G), [r3.exp, ne(void 0, n3), "_cache", String(t3.cached++)]));
      };
    }
  };
  function yn(e3) {
    return [[on, wr, mn, _r, un, ...e3 ? [Mr, Er] : [], Yr, qr, Lr, nn], { on: en, bind: tn, model: an }];
  }
  t2.generateCodeFrame = n2.generateCodeFrame, t2.BASE_TRANSITION = d, t2.BindingTypes = { DATA: "data", PROPS: "props", PROPS_ALIASED: "props-aliased", SETUP_LET: "setup-let", SETUP_CONST: "setup-const", SETUP_REACTIVE_CONST: "setup-reactive-const", SETUP_MAYBE_REF: "setup-maybe-ref", SETUP_REF: "setup-ref", OPTIONS: "options", LITERAL_CONST: "literal-const" }, t2.CAMELIZE = M, t2.CAPITALIZE = B, t2.CREATE_BLOCK = h, t2.CREATE_COMMENT = b, t2.CREATE_ELEMENT_BLOCK = m, t2.CREATE_ELEMENT_VNODE = g, t2.CREATE_SLOTS = O, t2.CREATE_STATIC = E, t2.CREATE_TEXT = v, t2.CREATE_VNODE = y, t2.CompilerDeprecationTypes = { COMPILER_IS_ON_ELEMENT: "COMPILER_IS_ON_ELEMENT", COMPILER_V_BIND_SYNC: "COMPILER_V_BIND_SYNC", COMPILER_V_BIND_OBJECT_ORDER: "COMPILER_V_BIND_OBJECT_ORDER", COMPILER_V_ON_NATIVE: "COMPILER_V_ON_NATIVE", COMPILER_V_IF_V_FOR_PRECEDENCE: "COMPILER_V_IF_V_FOR_PRECEDENCE", COMPILER_NATIVE_TEMPLATE: "COMPILER_NATIVE_TEMPLATE", COMPILER_INLINE_TEMPLATE: "COMPILER_INLINE_TEMPLATE", COMPILER_FILTERS: "COMPILER_FILTERS" }, t2.ConstantTypes = { NOT_CONSTANT: 0, 0: "NOT_CONSTANT", CAN_SKIP_PATCH: 1, 1: "CAN_SKIP_PATCH", CAN_HOIST: 2, 2: "CAN_HOIST", CAN_STRINGIFY: 3, 3: "CAN_STRINGIFY" }, t2.ElementTypes = { ELEMENT: 0, 0: "ELEMENT", COMPONENT: 1, 1: "COMPONENT", SLOT: 2, 2: "SLOT", TEMPLATE: 3, 3: "TEMPLATE" }, t2.ErrorCodes = { ABRUPT_CLOSING_OF_EMPTY_COMMENT: 0, 0: "ABRUPT_CLOSING_OF_EMPTY_COMMENT", CDATA_IN_HTML_CONTENT: 1, 1: "CDATA_IN_HTML_CONTENT", DUPLICATE_ATTRIBUTE: 2, 2: "DUPLICATE_ATTRIBUTE", END_TAG_WITH_ATTRIBUTES: 3, 3: "END_TAG_WITH_ATTRIBUTES", END_TAG_WITH_TRAILING_SOLIDUS: 4, 4: "END_TAG_WITH_TRAILING_SOLIDUS", EOF_BEFORE_TAG_NAME: 5, 5: "EOF_BEFORE_TAG_NAME", EOF_IN_CDATA: 6, 6: "EOF_IN_CDATA", EOF_IN_COMMENT: 7, 7: "EOF_IN_COMMENT", EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT: 8, 8: "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT", EOF_IN_TAG: 9, 9: "EOF_IN_TAG", INCORRECTLY_CLOSED_COMMENT: 10, 10: "INCORRECTLY_CLOSED_COMMENT", INCORRECTLY_OPENED_COMMENT: 11, 11: "INCORRECTLY_OPENED_COMMENT", INVALID_FIRST_CHARACTER_OF_TAG_NAME: 12, 12: "INVALID_FIRST_CHARACTER_OF_TAG_NAME", MISSING_ATTRIBUTE_VALUE: 13, 13: "MISSING_ATTRIBUTE_VALUE", MISSING_END_TAG_NAME: 14, 14: "MISSING_END_TAG_NAME", MISSING_WHITESPACE_BETWEEN_ATTRIBUTES: 15, 15: "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES", NESTED_COMMENT: 16, 16: "NESTED_COMMENT", UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME: 17, 17: "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME", UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE: 18, 18: "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE", UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME: 19, 19: "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME", UNEXPECTED_NULL_CHARACTER: 20, 20: "UNEXPECTED_NULL_CHARACTER", UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME: 21, 21: "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME", UNEXPECTED_SOLIDUS_IN_TAG: 22, 22: "UNEXPECTED_SOLIDUS_IN_TAG", X_INVALID_END_TAG: 23, 23: "X_INVALID_END_TAG", X_MISSING_END_TAG: 24, 24: "X_MISSING_END_TAG", X_MISSING_INTERPOLATION_END: 25, 25: "X_MISSING_INTERPOLATION_END", X_MISSING_DIRECTIVE_NAME: 26, 26: "X_MISSING_DIRECTIVE_NAME", X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END: 27, 27: "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END", X_V_IF_NO_EXPRESSION: 28, 28: "X_V_IF_NO_EXPRESSION", X_V_IF_SAME_KEY: 29, 29: "X_V_IF_SAME_KEY", X_V_ELSE_NO_ADJACENT_IF: 30, 30: "X_V_ELSE_NO_ADJACENT_IF", X_V_FOR_NO_EXPRESSION: 31, 31: "X_V_FOR_NO_EXPRESSION", X_V_FOR_MALFORMED_EXPRESSION: 32, 32: "X_V_FOR_MALFORMED_EXPRESSION", X_V_FOR_TEMPLATE_KEY_PLACEMENT: 33, 33: "X_V_FOR_TEMPLATE_KEY_PLACEMENT", X_V_BIND_NO_EXPRESSION: 34, 34: "X_V_BIND_NO_EXPRESSION", X_V_ON_NO_EXPRESSION: 35, 35: "X_V_ON_NO_EXPRESSION", X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET: 36, 36: "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET", X_V_SLOT_MIXED_SLOT_USAGE: 37, 37: "X_V_SLOT_MIXED_SLOT_USAGE", X_V_SLOT_DUPLICATE_SLOT_NAMES: 38, 38: "X_V_SLOT_DUPLICATE_SLOT_NAMES", X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN: 39, 39: "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN", X_V_SLOT_MISPLACED: 40, 40: "X_V_SLOT_MISPLACED", X_V_MODEL_NO_EXPRESSION: 41, 41: "X_V_MODEL_NO_EXPRESSION", X_V_MODEL_MALFORMED_EXPRESSION: 42, 42: "X_V_MODEL_MALFORMED_EXPRESSION", X_V_MODEL_ON_SCOPE_VARIABLE: 43, 43: "X_V_MODEL_ON_SCOPE_VARIABLE", X_V_MODEL_ON_PROPS: 44, 44: "X_V_MODEL_ON_PROPS", X_INVALID_EXPRESSION: 45, 45: "X_INVALID_EXPRESSION", X_KEEP_ALIVE_INVALID_CHILDREN: 46, 46: "X_KEEP_ALIVE_INVALID_CHILDREN", X_PREFIX_ID_NOT_SUPPORTED: 47, 47: "X_PREFIX_ID_NOT_SUPPORTED", X_MODULE_MODE_NOT_SUPPORTED: 48, 48: "X_MODULE_MODE_NOT_SUPPORTED", X_CACHE_HANDLER_NOT_SUPPORTED: 49, 49: "X_CACHE_HANDLER_NOT_SUPPORTED", X_SCOPE_ID_NOT_SUPPORTED: 50, 50: "X_SCOPE_ID_NOT_SUPPORTED", X_VNODE_HOOKS: 51, 51: "X_VNODE_HOOKS", __EXTEND_POINT__: 52, 52: "__EXTEND_POINT__" }, t2.FRAGMENT = l, t2.GUARD_REACTIVE_PROPS = j, t2.IS_MEMO_SAME = H, t2.IS_REF = W, t2.KEEP_ALIVE = p, t2.MERGE_PROPS = _, t2.NORMALIZE_CLASS = k, t2.NORMALIZE_PROPS = D, t2.NORMALIZE_STYLE = N, t2.Namespaces = { HTML: 0, 0: "HTML", SVG: 1, 1: "SVG", MATH_ML: 2, 2: "MATH_ML" }, t2.NodeTypes = { ROOT: 0, 0: "ROOT", ELEMENT: 1, 1: "ELEMENT", TEXT: 2, 2: "TEXT", COMMENT: 3, 3: "COMMENT", SIMPLE_EXPRESSION: 4, 4: "SIMPLE_EXPRESSION", INTERPOLATION: 5, 5: "INTERPOLATION", ATTRIBUTE: 6, 6: "ATTRIBUTE", DIRECTIVE: 7, 7: "DIRECTIVE", COMPOUND_EXPRESSION: 8, 8: "COMPOUND_EXPRESSION", IF: 9, 9: "IF", IF_BRANCH: 10, 10: "IF_BRANCH", FOR: 11, 11: "FOR", TEXT_CALL: 12, 12: "TEXT_CALL", VNODE_CALL: 13, 13: "VNODE_CALL", JS_CALL_EXPRESSION: 14, 14: "JS_CALL_EXPRESSION", JS_OBJECT_EXPRESSION: 15, 15: "JS_OBJECT_EXPRESSION", JS_PROPERTY: 16, 16: "JS_PROPERTY", JS_ARRAY_EXPRESSION: 17, 17: "JS_ARRAY_EXPRESSION", JS_FUNCTION_EXPRESSION: 18, 18: "JS_FUNCTION_EXPRESSION", JS_CONDITIONAL_EXPRESSION: 19, 19: "JS_CONDITIONAL_EXPRESSION", JS_CACHE_EXPRESSION: 20, 20: "JS_CACHE_EXPRESSION", JS_BLOCK_STATEMENT: 21, 21: "JS_BLOCK_STATEMENT", JS_TEMPLATE_LITERAL: 22, 22: "JS_TEMPLATE_LITERAL", JS_IF_STATEMENT: 23, 23: "JS_IF_STATEMENT", JS_ASSIGNMENT_EXPRESSION: 24, 24: "JS_ASSIGNMENT_EXPRESSION", JS_SEQUENCE_EXPRESSION: 25, 25: "JS_SEQUENCE_EXPRESSION", JS_RETURN_STATEMENT: 26, 26: "JS_RETURN_STATEMENT" }, t2.OPEN_BLOCK = f, t2.POP_SCOPE_ID = $, t2.PUSH_SCOPE_ID = U, t2.RENDER_LIST = A, t2.RENDER_SLOT = C, t2.RESOLVE_COMPONENT = S, t2.RESOLVE_DIRECTIVE = T, t2.RESOLVE_DYNAMIC_COMPONENT = x, t2.RESOLVE_FILTER = w, t2.SET_BLOCK_TRACKING = F, t2.SUSPENSE = u, t2.TELEPORT = c, t2.TO_DISPLAY_STRING = I, t2.TO_HANDLERS = L, t2.TO_HANDLER_KEY = R, t2.TS_NODE_TYPES = Be, t2.UNREF = q, t2.WITH_CTX = V, t2.WITH_DIRECTIVES = P, t2.WITH_MEMO = G, t2.advancePositionWithClone = Ke, t2.advancePositionWithMutation = Xe, t2.assert = function(e3, t3) {
    if (!e3) throw new Error(t3 || "unexpected compiler condition");
  }, t2.baseCompile = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const r3 = t3.onError || Se, s3 = "module" === t3.mode, i3 = true === t3.prefixIdentifiers || s3;
    !i3 && t3.cacheHandlers && r3(Te(49)), t3.scopeId && !s3 && r3(Te(50));
    const o3 = n2.extend({}, t3, { prefixIdentifiers: i3 }), a3 = n2.isString(e3) ? Gt(e3, o3) : e3, [l2, c2] = yn(i3);
    if (t3.isTS) {
      const { expressionPlugins: e4 } = t3;
      e4 && e4.includes("typescript") || (t3.expressionPlugins = [...e4 || [], "typescript"]);
    }
    return rr(a3, n2.extend({}, o3, { nodeTransforms: [...l2, ...t3.nodeTransforms || []], directiveTransforms: n2.extend({}, c2, t3.directiveTransforms || {}) })), lr(a3, o3);
  }, t2.baseParse = Gt, t2.buildDirectiveArgs = Xr, t2.buildProps = Hr, t2.buildSlots = Rr, t2.checkCompatEnabled = Ee, t2.convertToBlock = ce, t2.createArrayExpression = Y, t2.createAssignmentExpression = function(e3, t3) {
    return { type: 24, left: e3, right: t3, loc: K };
  }, t2.createBlockStatement = oe, t2.createCacheExpression = ie, t2.createCallExpression = re, t2.createCompilerError = Te, t2.createCompoundExpression = te, t2.createConditionalExpression = se, t2.createForLoopParams = Dr, t2.createFunctionExpression = ne, t2.createIfStatement = function(e3, t3, r3) {
    return { type: 23, test: e3, consequent: t3, alternate: r3, loc: K };
  }, t2.createInterpolation = function(e3, t3) {
    return { type: 5, loc: t3, content: n2.isString(e3) ? ee(e3, false, t3) : e3 };
  }, t2.createObjectExpression = Q, t2.createObjectProperty = Z, t2.createReturnStatement = function(e3) {
    return { type: 26, returns: e3, loc: K };
  }, t2.createRoot = X, t2.createSequenceExpression = function(e3) {
    return { type: 25, expressions: e3, loc: K };
  }, t2.createSimpleExpression = ee, t2.createStructuralDirectiveTransform = sr, t2.createTemplateLiteral = function(e3) {
    return { type: 22, elements: e3, loc: K };
  }, t2.createTransformContext = tr, t2.createVNodeCall = J, t2.errorMessages = we, t2.extractIdentifiers = ke, t2.findDir = Je, t2.findProp = Ye, t2.forAliasRE = ut, t2.generate = lr, t2.getBaseTransformPreset = yn, t2.getConstantType = Xt, t2.getMemoedVNodeCall = ct, t2.getVNodeBlockHelper = le, t2.getVNodeHelper = ae, t2.hasDynamicKeyVBind = function(e3) {
    return e3.props.some((e4) => !(7 !== e4.type || "bind" !== e4.name || e4.arg && 4 === e4.arg.type && e4.arg.isStatic));
  }, t2.hasScopeRef = lt, t2.helperNameMap = z, t2.injectProp = it, t2.isCoreComponent = Ue, t2.isFunctionType = je, t2.isInDestructureAssignment = Ce, t2.isInNewExpression = Oe, t2.isMemberExpression = ze, t2.isMemberExpressionBrowser = (e3) => {
    e3 = e3.trim().replace(Ge, (e4) => e4.trim());
    let t3 = 0, r3 = [], n3 = 0, s3 = 0, i3 = null;
    for (let o3 = 0; o3 < e3.length; o3++) {
      const a3 = e3.charAt(o3);
      switch (t3) {
        case 0:
          if ("[" === a3) r3.push(t3), t3 = 1, n3++;
          else if ("(" === a3) r3.push(t3), t3 = 2, s3++;
          else if (!(0 === o3 ? qe : We).test(a3)) return false;
          break;
        case 1:
          "'" === a3 || '"' === a3 || "`" === a3 ? (r3.push(t3), t3 = 3, i3 = a3) : "[" === a3 ? n3++ : "]" === a3 && (--n3 || (t3 = r3.pop()));
          break;
        case 2:
          if ("'" === a3 || '"' === a3 || "`" === a3) r3.push(t3), t3 = 3, i3 = a3;
          else if ("(" === a3) s3++;
          else if (")" === a3) {
            if (o3 === e3.length - 1) return false;
            --s3 || (t3 = r3.pop());
          }
          break;
        case 3:
          a3 === i3 && (t3 = r3.pop(), i3 = null);
      }
    }
    return !n3 && !s3;
  }, t2.isMemberExpressionNode = He, t2.isReferencedIdentifier = Ae, t2.isSimpleIdentifier = Ve, t2.isSlotOutlet = rt, t2.isStaticArgOf = Qe, t2.isStaticExp = Fe, t2.isStaticProperty = Le, t2.isStaticPropertyKey = Me, t2.isTemplateNode = tt, t2.isText = Ze, t2.isVSlot = et, t2.locStub = K, t2.noopDirectiveTransform = () => ({ props: [] }), t2.processExpression = Sr, t2.processFor = kr, t2.processIf = Pr, t2.processSlotOutlet = Qr, t2.registerRuntimeHelpers = function(e3) {
    Object.getOwnPropertySymbols(e3).forEach((t3) => {
      z[t3] = e3[t3];
    });
  }, t2.resolveComponentType = Wr, t2.stringifyExpression = xr, t2.toValidAssetId = at, t2.trackSlotScopes = Lr, t2.trackVForSlotScopes = Mr, t2.transform = rr, t2.transformBind = tn, t2.transformElement = qr, t2.transformExpression = Er, t2.transformModel = an, t2.transformOn = en, t2.traverseNode = nr, t2.unwrapTSNode = Re, t2.walkBlockDeclarations = _e, t2.walkFunctionParams = Ie, t2.walkIdentifiers = Pe, t2.warnDeprecation = function(e3, t3, r3) {
    if ("suppress-warning" === be(e3, t3)) return;
    const { message: n3, link: s3 } = ge[e3];
    for (var i3 = arguments.length, o3 = new Array(i3 > 3 ? i3 - 3 : 0), a3 = 3; a3 < i3; a3++) o3[a3 - 3] = arguments[a3];
    const l2 = `(deprecation ${e3}) ${"function" == typeof n3 ? n3(...o3) : n3}${s3 ? `
  Details: ${s3}` : ""}`, c2 = new SyntaxError(l2);
    c2.code = e3, r3 && (c2.loc = r3), t3.onWarn(c2);
  };
}, (e2, t2, r2) => {
  function n2(e3, t3) {
    const r3 = new Set(e3.split(","));
    return t3 ? (e4) => r3.has(e4.toLowerCase()) : (e4) => r3.has(e4);
  }
  Object.defineProperty(t2, "__esModule", { value: true });
  const s2 = Object.assign, i2 = Object.prototype.hasOwnProperty, o2 = Array.isArray, a2 = (e3) => "[object Map]" === m(e3), l = (e3) => "[object Set]" === m(e3), c = (e3) => "[object Date]" === m(e3), u = (e3) => "function" == typeof e3, p = (e3) => "string" == typeof e3, d = (e3) => "symbol" == typeof e3, f = (e3) => null !== e3 && "object" == typeof e3, h = Object.prototype.toString, m = (e3) => h.call(e3), y = (e3) => "[object Object]" === m(e3), g = n2(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), b = n2("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"), v = (e3) => {
    const t3 = /* @__PURE__ */ Object.create(null);
    return (r3) => t3[r3] || (t3[r3] = e3(r3));
  }, E = /-(\w)/g, S = v((e3) => e3.replace(E, (e4, t3) => t3 ? t3.toUpperCase() : "")), x = /\B([A-Z])/g, T = v((e3) => e3.replace(x, "-$1").toLowerCase()), w = v((e3) => e3.charAt(0).toUpperCase() + e3.slice(1)), P = v((e3) => e3 ? `on${w(e3)}` : "");
  let A;
  const C = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/, O = { 1: "TEXT", 2: "CLASS", 4: "STYLE", 8: "PROPS", 16: "FULL_PROPS", 32: "NEED_HYDRATION", 64: "STABLE_FRAGMENT", 128: "KEYED_FRAGMENT", 256: "UNKEYED_FRAGMENT", 512: "NEED_PATCH", 1024: "DYNAMIC_SLOTS", 2048: "DEV_ROOT_FRAGMENT", [-1]: "HOISTED", [-2]: "BAIL" }, I = n2("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error"), _ = I;
  function k(e3) {
    if (o2(e3)) {
      const t3 = {};
      for (let r3 = 0; r3 < e3.length; r3++) {
        const n3 = e3[r3], s3 = p(n3) ? L(n3) : k(n3);
        if (s3) for (const e4 in s3) t3[e4] = s3[e4];
      }
      return t3;
    }
    if (p(e3) || f(e3)) return e3;
  }
  const N = /;(?![^(]*\))/g, D = /:([^]+)/, j = /\/\*[^]*?\*\//g;
  function L(e3) {
    const t3 = {};
    return e3.replace(j, "").split(N).forEach((e4) => {
      if (e4) {
        const r3 = e4.split(D);
        r3.length > 1 && (t3[r3[0].trim()] = r3[1].trim());
      }
    }), t3;
  }
  function M(e3) {
    let t3 = "";
    if (p(e3)) t3 = e3;
    else if (o2(e3)) for (let r3 = 0; r3 < e3.length; r3++) {
      const n3 = M(e3[r3]);
      n3 && (t3 += n3 + " ");
    }
    else if (f(e3)) for (const r3 in e3) e3[r3] && (t3 += r3 + " ");
    return t3.trim();
  }
  const B = n2("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot"), R = n2("svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view"), F = n2("annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics"), U = n2("area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr"), $ = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", V = n2($), q = n2($ + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"), W = /[>/="'\u0009\u000a\u000c\u0020]/, G = {}, H = n2("accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"), z = n2("xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan"), K = /["'&<>]/, X = /^-?>|<!--|-->|--!>|<!-$/g;
  function J(e3, t3) {
    if (e3 === t3) return true;
    let r3 = c(e3), n3 = c(t3);
    if (r3 || n3) return !(!r3 || !n3) && e3.getTime() === t3.getTime();
    if (r3 = d(e3), n3 = d(t3), r3 || n3) return e3 === t3;
    if (r3 = o2(e3), n3 = o2(t3), r3 || n3) return !(!r3 || !n3) && function(e4, t4) {
      if (e4.length !== t4.length) return false;
      let r4 = true;
      for (let n4 = 0; r4 && n4 < e4.length; n4++) r4 = J(e4[n4], t4[n4]);
      return r4;
    }(e3, t3);
    if (r3 = f(e3), n3 = f(t3), r3 || n3) {
      if (!r3 || !n3) return false;
      if (Object.keys(e3).length !== Object.keys(t3).length) return false;
      for (const r4 in e3) {
        const n4 = e3.hasOwnProperty(r4), s3 = t3.hasOwnProperty(r4);
        if (n4 && !s3 || !n4 && s3 || !J(e3[r4], t3[r4])) return false;
      }
    }
    return String(e3) === String(t3);
  }
  const Y = (e3, t3) => t3 && t3.__v_isRef ? Y(e3, t3.value) : a2(t3) ? { [`Map(${t3.size})`]: [...t3.entries()].reduce((e4, t4, r3) => {
    let [n3, s3] = t4;
    return e4[Q(n3, r3) + " =>"] = s3, e4;
  }, {}) } : l(t3) ? { [`Set(${t3.size})`]: [...t3.values()].map((e4) => Q(e4)) } : d(t3) ? Q(t3) : !f(t3) || o2(t3) || y(t3) ? t3 : String(t3), Q = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    var r3;
    return d(e3) ? `Symbol(${null != (r3 = e3.description) ? r3 : t3})` : e3;
  };
  t2.EMPTY_ARR = [], t2.EMPTY_OBJ = {}, t2.NO = () => false, t2.NOOP = () => {
  }, t2.PatchFlagNames = O, t2.PatchFlags = { TEXT: 1, 1: "TEXT", CLASS: 2, 2: "CLASS", STYLE: 4, 4: "STYLE", PROPS: 8, 8: "PROPS", FULL_PROPS: 16, 16: "FULL_PROPS", NEED_HYDRATION: 32, 32: "NEED_HYDRATION", STABLE_FRAGMENT: 64, 64: "STABLE_FRAGMENT", KEYED_FRAGMENT: 128, 128: "KEYED_FRAGMENT", UNKEYED_FRAGMENT: 256, 256: "UNKEYED_FRAGMENT", NEED_PATCH: 512, 512: "NEED_PATCH", DYNAMIC_SLOTS: 1024, 1024: "DYNAMIC_SLOTS", DEV_ROOT_FRAGMENT: 2048, 2048: "DEV_ROOT_FRAGMENT", HOISTED: -1, "-1": "HOISTED", BAIL: -2, "-2": "BAIL" }, t2.ShapeFlags = { ELEMENT: 1, 1: "ELEMENT", FUNCTIONAL_COMPONENT: 2, 2: "FUNCTIONAL_COMPONENT", STATEFUL_COMPONENT: 4, 4: "STATEFUL_COMPONENT", TEXT_CHILDREN: 8, 8: "TEXT_CHILDREN", ARRAY_CHILDREN: 16, 16: "ARRAY_CHILDREN", SLOTS_CHILDREN: 32, 32: "SLOTS_CHILDREN", TELEPORT: 64, 64: "TELEPORT", SUSPENSE: 128, 128: "SUSPENSE", COMPONENT_SHOULD_KEEP_ALIVE: 256, 256: "COMPONENT_SHOULD_KEEP_ALIVE", COMPONENT_KEPT_ALIVE: 512, 512: "COMPONENT_KEPT_ALIVE", COMPONENT: 6, 6: "COMPONENT" }, t2.SlotFlags = { STABLE: 1, 1: "STABLE", DYNAMIC: 2, 2: "DYNAMIC", FORWARDED: 3, 3: "FORWARDED" }, t2.camelize = S, t2.capitalize = w, t2.def = (e3, t3, r3) => {
    Object.defineProperty(e3, t3, { configurable: true, enumerable: false, value: r3 });
  }, t2.escapeHtml = function(e3) {
    const t3 = "" + e3, r3 = K.exec(t3);
    if (!r3) return t3;
    let n3, s3, i3 = "", o3 = 0;
    for (s3 = r3.index; s3 < t3.length; s3++) {
      switch (t3.charCodeAt(s3)) {
        case 34:
          n3 = "&quot;";
          break;
        case 38:
          n3 = "&amp;";
          break;
        case 39:
          n3 = "&#39;";
          break;
        case 60:
          n3 = "&lt;";
          break;
        case 62:
          n3 = "&gt;";
          break;
        default:
          continue;
      }
      o3 !== s3 && (i3 += t3.slice(o3, s3)), o3 = s3 + 1, i3 += n3;
    }
    return o3 !== s3 ? i3 + t3.slice(o3, s3) : i3;
  }, t2.escapeHtmlComment = function(e3) {
    return e3.replace(X, "");
  }, t2.extend = s2, t2.genPropsAccessExp = function(e3) {
    return C.test(e3) ? `__props.${e3}` : `__props[${JSON.stringify(e3)}]`;
  }, t2.generateCodeFrame = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e3.length, n3 = e3.split(/(\r?\n)/);
    const s3 = n3.filter((e4, t4) => t4 % 2 == 1);
    n3 = n3.filter((e4, t4) => t4 % 2 == 0);
    let i3 = 0;
    const o3 = [];
    for (let e4 = 0; e4 < n3.length; e4++) if (i3 += n3[e4].length + (s3[e4] && s3[e4].length || 0), i3 >= t3) {
      for (let a3 = e4 - 2; a3 <= e4 + 2 || r3 > i3; a3++) {
        if (a3 < 0 || a3 >= n3.length) continue;
        const l2 = a3 + 1;
        o3.push(`${l2}${" ".repeat(Math.max(3 - String(l2).length, 0))}|  ${n3[a3]}`);
        const c2 = n3[a3].length, u2 = s3[a3] && s3[a3].length || 0;
        if (a3 === e4) {
          const e5 = t3 - (i3 - (c2 + u2)), n4 = Math.max(1, r3 > i3 ? c2 - e5 : r3 - t3);
          o3.push("   |  " + " ".repeat(e5) + "^".repeat(n4));
        } else if (a3 > e4) {
          if (r3 > i3) {
            const e5 = Math.max(Math.min(r3 - i3, c2), 1);
            o3.push("   |  " + "^".repeat(e5));
          }
          i3 += c2 + u2;
        }
      }
      break;
    }
    return o3.join("\n");
  }, t2.getGlobalThis = () => A || (A = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== r2.g ? r2.g : {}), t2.hasChanged = (e3, t3) => !Object.is(e3, t3), t2.hasOwn = (e3, t3) => i2.call(e3, t3), t2.hyphenate = T, t2.includeBooleanAttr = function(e3) {
    return !!e3 || "" === e3;
  }, t2.invokeArrayFns = (e3, t3) => {
    for (let r3 = 0; r3 < e3.length; r3++) e3[r3](t3);
  }, t2.isArray = o2, t2.isBooleanAttr = q, t2.isBuiltInDirective = b, t2.isDate = c, t2.isFunction = u, t2.isGloballyAllowed = I, t2.isGloballyWhitelisted = _, t2.isHTMLTag = B, t2.isIntegerKey = (e3) => p(e3) && "NaN" !== e3 && "-" !== e3[0] && "" + parseInt(e3, 10) === e3, t2.isKnownHtmlAttr = H, t2.isKnownSvgAttr = z, t2.isMap = a2, t2.isMathMLTag = F, t2.isModelListener = (e3) => e3.startsWith("onUpdate:"), t2.isObject = f, t2.isOn = (e3) => 111 === e3.charCodeAt(0) && 110 === e3.charCodeAt(1) && (e3.charCodeAt(2) > 122 || e3.charCodeAt(2) < 97), t2.isPlainObject = y, t2.isPromise = (e3) => (f(e3) || u(e3)) && u(e3.then) && u(e3.catch), t2.isRegExp = (e3) => "[object RegExp]" === m(e3), t2.isRenderableAttrValue = function(e3) {
    if (null == e3) return false;
    const t3 = typeof e3;
    return "string" === t3 || "number" === t3 || "boolean" === t3;
  }, t2.isReservedProp = g, t2.isSSRSafeAttrName = function(e3) {
    if (G.hasOwnProperty(e3)) return G[e3];
    const t3 = W.test(e3);
    return G[e3] = !t3;
  }, t2.isSVGTag = R, t2.isSet = l, t2.isSpecialBooleanAttr = V, t2.isString = p, t2.isSymbol = d, t2.isVoidTag = U, t2.looseEqual = J, t2.looseIndexOf = function(e3, t3) {
    return e3.findIndex((e4) => J(e4, t3));
  }, t2.looseToNumber = (e3) => {
    const t3 = parseFloat(e3);
    return isNaN(t3) ? e3 : t3;
  }, t2.makeMap = n2, t2.normalizeClass = M, t2.normalizeProps = function(e3) {
    if (!e3) return null;
    let { class: t3, style: r3 } = e3;
    return t3 && !p(t3) && (e3.class = M(t3)), r3 && (e3.style = k(r3)), e3;
  }, t2.normalizeStyle = k, t2.objectToString = h, t2.parseStringStyle = L, t2.propsToAttrMap = { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv" }, t2.remove = (e3, t3) => {
    const r3 = e3.indexOf(t3);
    r3 > -1 && e3.splice(r3, 1);
  }, t2.slotFlagsText = { 1: "STABLE", 2: "DYNAMIC", 3: "FORWARDED" }, t2.stringifyStyle = function(e3) {
    let t3 = "";
    if (!e3 || p(e3)) return t3;
    for (const r3 in e3) {
      const n3 = e3[r3], s3 = r3.startsWith("--") ? r3 : T(r3);
      (p(n3) || "number" == typeof n3) && (t3 += `${s3}:${n3};`);
    }
    return t3;
  }, t2.toDisplayString = (e3) => p(e3) ? e3 : null == e3 ? "" : o2(e3) || f(e3) && (e3.toString === h || !u(e3.toString)) ? JSON.stringify(e3, Y, 2) : String(e3), t2.toHandlerKey = P, t2.toNumber = (e3) => {
    const t3 = p(e3) ? Number(e3) : NaN;
    return isNaN(t3) ? e3 : t3;
  }, t2.toRawType = (e3) => m(e3).slice(8, -1), t2.toTypeString = m;
}, (e2, t2, r2) => {
  r2(12), Object.defineProperty(t2, "__esModule", { value: true }), t2.default = new Uint16Array('ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map(function(e3) {
    return e3.charCodeAt(0);
  }));
}, (e2, t2, r2) => {
  r2(12), Object.defineProperty(t2, "__esModule", { value: true }), t2.default = new Uint16Array("Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map(function(e3) {
    return e3.charCodeAt(0);
  }));
}, () => {
}, () => {
}, (e2, t2, r2) => {
  var n2 = r2(157);
  function s2() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  var i2 = /^([a-z0-9.+-]+:)/i, o2 = /:[0-9]*$/, a2 = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, l = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]), c = ["'"].concat(l), u = ["%", "/", "?", ";", "#"].concat(c), p = ["/", "?", "#"], d = /^[+a-z0-9A-Z_-]{0,63}$/, f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, h = { javascript: true, "javascript:": true }, m = { javascript: true, "javascript:": true }, y = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, g = r2(310);
  function b(e3, t3, r3) {
    if (e3 && "object" == typeof e3 && e3 instanceof s2) return e3;
    var n3 = new s2();
    return n3.parse(e3, t3, r3), n3;
  }
  s2.prototype.parse = function(e3, t3, r3) {
    if ("string" != typeof e3) throw new TypeError("Parameter 'url' must be a string, not " + typeof e3);
    var s3 = e3.indexOf("?"), o3 = -1 !== s3 && s3 < e3.indexOf("#") ? "?" : "#", l2 = e3.split(o3);
    l2[0] = l2[0].replace(/\\/g, "/");
    var b2 = e3 = l2.join(o3);
    if (b2 = b2.trim(), !r3 && 1 === e3.split("#").length) {
      var v = a2.exec(b2);
      if (v) return this.path = b2, this.href = b2, this.pathname = v[1], v[2] ? (this.search = v[2], this.query = t3 ? g.parse(this.search.substr(1)) : this.search.substr(1)) : t3 && (this.search = "", this.query = {}), this;
    }
    var E = i2.exec(b2);
    if (E) {
      var S = (E = E[0]).toLowerCase();
      this.protocol = S, b2 = b2.substr(E.length);
    }
    if (r3 || E || b2.match(/^\/\/[^@/]+@[^@/]+/)) {
      var x = "//" === b2.substr(0, 2);
      !x || E && m[E] || (b2 = b2.substr(2), this.slashes = true);
    }
    if (!m[E] && (x || E && !y[E])) {
      for (var T, w, P = -1, A = 0; A < p.length; A++) -1 !== (C = b2.indexOf(p[A])) && (-1 === P || C < P) && (P = C);
      for (-1 !== (w = -1 === P ? b2.lastIndexOf("@") : b2.lastIndexOf("@", P)) && (T = b2.slice(0, w), b2 = b2.slice(w + 1), this.auth = decodeURIComponent(T)), P = -1, A = 0; A < u.length; A++) {
        var C;
        -1 !== (C = b2.indexOf(u[A])) && (-1 === P || C < P) && (P = C);
      }
      -1 === P && (P = b2.length), this.host = b2.slice(0, P), b2 = b2.slice(P), this.parseHost(), this.hostname = this.hostname || "";
      var O = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
      if (!O) for (var I = this.hostname.split(/\./), _ = (A = 0, I.length); A < _; A++) {
        var k = I[A];
        if (k && !k.match(d)) {
          for (var N = "", D = 0, j = k.length; D < j; D++) k.charCodeAt(D) > 127 ? N += "x" : N += k[D];
          if (!N.match(d)) {
            var L = I.slice(0, A), M = I.slice(A + 1), B = k.match(f);
            B && (L.push(B[1]), M.unshift(B[2])), M.length && (b2 = "/" + M.join(".") + b2), this.hostname = L.join(".");
            break;
          }
        }
      }
      this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), O || (this.hostname = n2.toASCII(this.hostname));
      var R = this.port ? ":" + this.port : "", F = this.hostname || "";
      this.host = F + R, this.href += this.host, O && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== b2[0] && (b2 = "/" + b2));
    }
    if (!h[S]) for (A = 0, _ = c.length; A < _; A++) {
      var U = c[A];
      if (-1 !== b2.indexOf(U)) {
        var $ = encodeURIComponent(U);
        $ === U && ($ = escape(U)), b2 = b2.split(U).join($);
      }
    }
    var V = b2.indexOf("#");
    -1 !== V && (this.hash = b2.substr(V), b2 = b2.slice(0, V));
    var q = b2.indexOf("?");
    if (-1 !== q ? (this.search = b2.substr(q), this.query = b2.substr(q + 1), t3 && (this.query = g.parse(this.query)), b2 = b2.slice(0, q)) : t3 && (this.search = "", this.query = {}), b2 && (this.pathname = b2), y[S] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
      R = this.pathname || "";
      var W = this.search || "";
      this.path = R + W;
    }
    return this.href = this.format(), this;
  }, s2.prototype.format = function() {
    var e3 = this.auth || "";
    e3 && (e3 = (e3 = encodeURIComponent(e3)).replace(/%3A/i, ":"), e3 += "@");
    var t3 = this.protocol || "", r3 = this.pathname || "", n3 = this.hash || "", s3 = false, i3 = "";
    this.host ? s3 = e3 + this.host : this.hostname && (s3 = e3 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (s3 += ":" + this.port)), this.query && "object" == typeof this.query && Object.keys(this.query).length && (i3 = g.stringify(this.query, { arrayFormat: "repeat", addQueryPrefix: false }));
    var o3 = this.search || i3 && "?" + i3 || "";
    return t3 && ":" !== t3.substr(-1) && (t3 += ":"), this.slashes || (!t3 || y[t3]) && false !== s3 ? (s3 = "//" + (s3 || ""), r3 && "/" !== r3.charAt(0) && (r3 = "/" + r3)) : s3 || (s3 = ""), n3 && "#" !== n3.charAt(0) && (n3 = "#" + n3), o3 && "?" !== o3.charAt(0) && (o3 = "?" + o3), t3 + s3 + (r3 = r3.replace(/[?#]/g, function(e4) {
      return encodeURIComponent(e4);
    })) + (o3 = o3.replace("#", "%23")) + n3;
  }, s2.prototype.resolve = function(e3) {
    return this.resolveObject(b(e3, false, true)).format();
  }, s2.prototype.resolveObject = function(e3) {
    if ("string" == typeof e3) {
      var t3 = new s2();
      t3.parse(e3, false, true), e3 = t3;
    }
    for (var r3 = new s2(), n3 = Object.keys(this), i3 = 0; i3 < n3.length; i3++) {
      var o3 = n3[i3];
      r3[o3] = this[o3];
    }
    if (r3.hash = e3.hash, "" === e3.href) return r3.href = r3.format(), r3;
    if (e3.slashes && !e3.protocol) {
      for (var a3 = Object.keys(e3), l2 = 0; l2 < a3.length; l2++) {
        var c2 = a3[l2];
        "protocol" !== c2 && (r3[c2] = e3[c2]);
      }
      return y[r3.protocol] && r3.hostname && !r3.pathname && (r3.pathname = "/", r3.path = r3.pathname), r3.href = r3.format(), r3;
    }
    if (e3.protocol && e3.protocol !== r3.protocol) {
      if (!y[e3.protocol]) {
        for (var u2 = Object.keys(e3), p2 = 0; p2 < u2.length; p2++) {
          var d2 = u2[p2];
          r3[d2] = e3[d2];
        }
        return r3.href = r3.format(), r3;
      }
      if (r3.protocol = e3.protocol, e3.host || m[e3.protocol]) r3.pathname = e3.pathname;
      else {
        for (var f2 = (e3.pathname || "").split("/"); f2.length && !(e3.host = f2.shift()); ) ;
        e3.host || (e3.host = ""), e3.hostname || (e3.hostname = ""), "" !== f2[0] && f2.unshift(""), f2.length < 2 && f2.unshift(""), r3.pathname = f2.join("/");
      }
      if (r3.search = e3.search, r3.query = e3.query, r3.host = e3.host || "", r3.auth = e3.auth, r3.hostname = e3.hostname || e3.host, r3.port = e3.port, r3.pathname || r3.search) {
        var h2 = r3.pathname || "", g2 = r3.search || "";
        r3.path = h2 + g2;
      }
      return r3.slashes = r3.slashes || e3.slashes, r3.href = r3.format(), r3;
    }
    var b2 = r3.pathname && "/" === r3.pathname.charAt(0), v = e3.host || e3.pathname && "/" === e3.pathname.charAt(0), E = v || b2 || r3.host && e3.pathname, S = E, x = r3.pathname && r3.pathname.split("/") || [], T = (f2 = e3.pathname && e3.pathname.split("/") || [], r3.protocol && !y[r3.protocol]);
    if (T && (r3.hostname = "", r3.port = null, r3.host && ("" === x[0] ? x[0] = r3.host : x.unshift(r3.host)), r3.host = "", e3.protocol && (e3.hostname = null, e3.port = null, e3.host && ("" === f2[0] ? f2[0] = e3.host : f2.unshift(e3.host)), e3.host = null), E = E && ("" === f2[0] || "" === x[0])), v) r3.host = e3.host || "" === e3.host ? e3.host : r3.host, r3.hostname = e3.hostname || "" === e3.hostname ? e3.hostname : r3.hostname, r3.search = e3.search, r3.query = e3.query, x = f2;
    else if (f2.length) x || (x = []), x.pop(), x = x.concat(f2), r3.search = e3.search, r3.query = e3.query;
    else if (null != e3.search) return T && (r3.host = x.shift(), r3.hostname = r3.host, (O = !!(r3.host && r3.host.indexOf("@") > 0) && r3.host.split("@")) && (r3.auth = O.shift(), r3.hostname = O.shift(), r3.host = r3.hostname)), r3.search = e3.search, r3.query = e3.query, null === r3.pathname && null === r3.search || (r3.path = (r3.pathname ? r3.pathname : "") + (r3.search ? r3.search : "")), r3.href = r3.format(), r3;
    if (!x.length) return r3.pathname = null, r3.search ? r3.path = "/" + r3.search : r3.path = null, r3.href = r3.format(), r3;
    for (var w = x.slice(-1)[0], P = (r3.host || e3.host || x.length > 1) && ("." === w || ".." === w) || "" === w, A = 0, C = x.length; C >= 0; C--) "." === (w = x[C]) ? x.splice(C, 1) : ".." === w ? (x.splice(C, 1), A++) : A && (x.splice(C, 1), A--);
    if (!E && !S) for (; A--; A) x.unshift("..");
    !E || "" === x[0] || x[0] && "/" === x[0].charAt(0) || x.unshift(""), P && "/" !== x.join("/").substr(-1) && x.push("");
    var O, I = "" === x[0] || x[0] && "/" === x[0].charAt(0);
    return T && (r3.hostname = I ? "" : x.length ? x.shift() : "", r3.host = r3.hostname, (O = !!(r3.host && r3.host.indexOf("@") > 0) && r3.host.split("@")) && (r3.auth = O.shift(), r3.hostname = O.shift(), r3.host = r3.hostname)), (E = E || r3.host && x.length) && !I && x.unshift(""), x.length > 0 ? r3.pathname = x.join("/") : (r3.pathname = null, r3.path = null), null === r3.pathname && null === r3.search || (r3.path = (r3.pathname ? r3.pathname : "") + (r3.search ? r3.search : "")), r3.auth = e3.auth || r3.auth, r3.slashes = r3.slashes || e3.slashes, r3.href = r3.format(), r3;
  }, s2.prototype.parseHost = function() {
    var e3 = this.host, t3 = o2.exec(e3);
    t3 && (":" !== (t3 = t3[0]) && (this.port = t3.substr(1)), e3 = e3.substr(0, e3.length - t3.length)), e3 && (this.hostname = e3);
  }, t2.parse = b, t2.resolve = function(e3, t3) {
    return b(e3, false, true).resolve(t3);
  }, t2.resolveObject = function(e3, t3) {
    return e3 ? b(e3, false, true).resolveObject(t3) : t3;
  }, t2.format = function(e3) {
    return "string" == typeof e3 && (e3 = b(e3)), e3 instanceof s2 ? e3.format() : s2.prototype.format.call(e3);
  }, t2.Url = s2;
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(16);
  t2.default = (0, n2.declare)((e3) => (e3.assertVersion(7), { name: "syntax-jsx", manipulateOptions(e4, t3) {
    t3.plugins.some((e5) => "typescript" === (Array.isArray(e5) ? e5[0] : e5)) || t3.plugins.push("jsx");
  } }));
}, (e2, t2, r2) => {
  e2.exports = r2(559);
}, (e2) => {
  e2.exports = JSON.parse('["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","label","legend","li","link","main","map","mark","math","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rb","rp","rt","rtc","ruby","s","samp","script","search","section","select","slot","small","source","span","strong","style","sub","summary","sup","svg","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr"]');
}, (e2, t2, r2) => {
  e2.exports = r2(561);
}, (e2) => {
  e2.exports = JSON.parse('["a","altGlyph","altGlyphDef","altGlyphItem","animate","animateColor","animateMotion","animateTransform","circle","clipPath","color-profile","cursor","defs","desc","ellipse","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","filter","font","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignObject","g","glyph","glyphRef","hkern","image","line","linearGradient","marker","mask","metadata","missing-glyph","mpath","path","pattern","polygon","polyline","radialGradient","rect","script","set","stop","style","svg","switch","symbol","text","textPath","title","tref","tspan","use","view","vkern"]');
}, (e2, t2, r2) => {
  t2.a = void 0;
  var n2 = (0, r2(16).declare)((e3) => (e3.assertVersion(7), { name: "syntax-class-static-block", manipulateOptions(e4, t3) {
    t3.plugins.push("classStaticBlock");
  } }));
  t2.a = n2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, c) {
    const u = e3.get("params");
    if (u.every((e4) => e4.isIdentifier())) return false;
    const { node: p, scope: d } = e3, f = [], h = /* @__PURE__ */ new Set();
    for (const e4 of u) (0, s2.collectShadowedParamsNames)(e4, d, h);
    const m = { needsOuterBinding: false, scope: d };
    if (0 === h.size) {
      for (const e4 of u) if (e4.isIdentifier() || e4.traverse(s2.iifeVisitor, m), m.needsOuterBinding) break;
    }
    let y = null;
    for (let s3 = 0; s3 < u.length; s3++) {
      const h2 = u[s3];
      if (r3 && !r3(s3)) continue;
      const m2 = [];
      c && c(e3, h2, m2);
      const g2 = h2.isAssignmentPattern();
      if (g2 && (t3 || n2.types.isMethod(p, { kind: "set" }))) {
        const e4 = h2.get("left"), t4 = h2.get("right"), r4 = d.buildUndefinedNode();
        if (e4.isIdentifier()) f.push(o2({ ASSIGNMENT_IDENTIFIER: n2.types.cloneNode(e4.node), DEFAULT_VALUE: t4.node, UNDEFINED: r4 })), h2.replaceWith(e4.node);
        else if (e4.isObjectPattern() || e4.isArrayPattern()) {
          const s4 = d.generateUidIdentifier();
          f.push(a2({ ASSIGNMENT_IDENTIFIER: e4.node, DEFAULT_VALUE: t4.node, PARAMETER_NAME: n2.types.cloneNode(s4), UNDEFINED: r4 })), h2.replaceWith(s4);
        }
      } else if (g2) {
        null === y && (y = s3);
        const e4 = h2.get("left"), t4 = h2.get("right"), r4 = i2({ VARIABLE_NAME: e4.node, DEFAULT_VALUE: t4.node, ARGUMENT_KEY: n2.types.numericLiteral(s3) });
        f.push(r4);
      } else if (null !== y) {
        const e4 = l([h2.node, n2.types.numericLiteral(s3)]);
        f.push(e4);
      } else if (h2.isObjectPattern() || h2.isArrayPattern()) {
        const t4 = e3.scope.generateUidIdentifier("ref");
        t4.typeAnnotation = h2.node.typeAnnotation;
        const r4 = n2.types.variableDeclaration("let", [n2.types.variableDeclarator(h2.node, t4)]);
        f.push(r4), h2.replaceWith(n2.types.cloneNode(t4));
      }
      if (m2) for (const e4 of m2) f.push(e4);
    }
    null !== y && (p.params = p.params.slice(0, y)), e3.ensureBlock();
    const { async: g, generator: b } = p;
    if (b || m.needsOuterBinding || h.size > 0) {
      f.push((0, s2.buildScopeIIFE)(h, e3.node.body)), e3.set("body", n2.types.blockStatement(f));
      const t4 = e3.get("body.body"), r4 = t4[t4.length - 1].get("argument.callee");
      r4.arrowFunctionToExpression(), r4.node.generator = b, r4.node.async = g, p.generator = false, p.async = false, g && (e3.node.body = n2.template.statement.ast`{
        try {
          ${e3.node.body.body}
        } catch (e) {
          return Promise.reject(e);
        }
      }`);
    } else e3.get("body").unshiftContainer("body", f);
    return true;
  };
  var n2 = r2(1), s2 = r2(327);
  const i2 = n2.template.statement("\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n"), o2 = n2.template.statement("\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n"), a2 = n2.template.statement("\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n"), l = n2.template.statement("\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n");
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const { node: t3, scope: r3 } = e3;
    if (!function(e4) {
      const t4 = e4.params.length;
      return t4 > 0 && n2.types.isRestElement(e4.params[t4 - 1]);
    }(t3)) return false;
    const o3 = e3.get(`params.${t3.params.length - 1}.argument`);
    if (!o3.isIdentifier()) {
      const t4 = /* @__PURE__ */ new Set();
      (0, s2.collectShadowedParamsNames)(o3, e3.scope, t4);
      let i3 = t4.size > 0;
      if (!i3) {
        const e4 = { needsOuterBinding: false, scope: r3 };
        o3.traverse(s2.iifeVisitor, e4), i3 = e4.needsOuterBinding;
      }
      i3 && (e3.ensureBlock(), e3.set("body", n2.types.blockStatement([(0, s2.buildScopeIIFE)(t4, e3.node.body)])));
    }
    let a3 = o3.node;
    if (t3.params.pop(), n2.types.isPattern(a3)) {
      const s3 = a3;
      a3 = r3.generateUidIdentifier("ref");
      const i3 = n2.types.variableDeclaration("let", [n2.types.variableDeclarator(s3, a3)]);
      e3.ensureBlock(), t3.body.body.unshift(i3);
    } else "arguments" === a3.name && r3.rename(a3.name);
    const l2 = n2.types.identifier("arguments"), c2 = function(e4) {
      let t4 = e4.params.length;
      return t4 > 0 && n2.types.isIdentifier(e4.params[0], { name: "this" }) && (t4 -= 1), t4;
    }(t3), f = { references: [], offset: c2, argumentsNode: l2, outerBinding: r3.getBindingIdentifier(a3.name), candidates: [], name: a3.name, deopted: false };
    if (e3.traverse(u, f), !f.deopted && !f.references.length) {
      for (const { path: e4, cause: t4 } of f.candidates) {
        const r4 = n2.types.cloneNode(l2);
        switch (t4) {
          case "indexGetter":
            p(e4, r4, f.offset);
            break;
          case "lengthGetter":
            d(e4, r4, f.offset);
            break;
          default:
            e4.replaceWith(r4);
        }
      }
      return true;
    }
    f.references.push(...f.candidates.map((e4) => {
      let { path: t4 } = e4;
      return t4;
    }));
    const h = n2.types.numericLiteral(c2), m = r3.generateUidIdentifier("key"), y = r3.generateUidIdentifier("len");
    let g, b;
    c2 ? (g = n2.types.binaryExpression("-", n2.types.cloneNode(m), n2.types.cloneNode(h)), b = n2.types.conditionalExpression(n2.types.binaryExpression(">", n2.types.cloneNode(y), n2.types.cloneNode(h)), n2.types.binaryExpression("-", n2.types.cloneNode(y), n2.types.cloneNode(h)), n2.types.numericLiteral(0))) : (g = n2.types.identifier(m.name), b = n2.types.identifier(y.name));
    const v = i2({ ARGUMENTS: l2, ARRAY_KEY: g, ARRAY_LEN: b, START: h, ARRAY: a3, KEY: m, LEN: y });
    if (f.deopted) t3.body.body.unshift(v);
    else {
      let t4 = e3.getEarliestCommonAncestorFrom(f.references).getStatementParent();
      t4.findParent((e4) => {
        if (!e4.isLoop()) return e4.isFunction();
        t4 = e4;
      }), t4.insertBefore(v);
    }
    return true;
  };
  var n2 = r2(1), s2 = r2(327);
  const i2 = n2.template.statement("\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n"), o2 = n2.template.expression("\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n"), a2 = n2.template.expression("\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n"), l = n2.template.expression("\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n");
  function c(e3, t3) {
    return e3.node.name === t3.name && e3.scope.bindingIdentifierEquals(t3.name, t3.outerBinding);
  }
  const u = { Scope(e3, t3) {
    e3.scope.bindingIdentifierEquals(t3.name, t3.outerBinding) || e3.skip();
  }, Flow(e3) {
    e3.isTypeCastExpression() || e3.skip();
  }, Function(e3, t3) {
    const r3 = t3.noOptimise;
    t3.noOptimise = true, e3.traverse(u, t3), t3.noOptimise = r3, e3.skip();
  }, ReferencedIdentifier(e3, t3) {
    const { node: r3 } = e3;
    if ("arguments" === r3.name && (t3.deopted = true), c(e3, t3)) if (t3.noOptimise) t3.deopted = true;
    else {
      const { parentPath: n3 } = e3;
      if ("params" === n3.listKey && n3.key < t3.offset) return;
      if (n3.isMemberExpression({ object: r3 })) {
        const r4 = n3.parentPath;
        if (!t3.deopted && !(r4.isAssignmentExpression() && n3.node === r4.node.left || r4.isLVal() || r4.isForXStatement() || r4.isUpdateExpression() || r4.isUnaryExpression({ operator: "delete" }) || (r4.isCallExpression() || r4.isNewExpression()) && n3.node === r4.node.callee)) {
          if (n3.node.computed) {
            if (n3.get("property").isBaseType("number")) return void t3.candidates.push({ cause: "indexGetter", path: e3 });
          } else if ("length" === n3.node.property.name) return void t3.candidates.push({ cause: "lengthGetter", path: e3 });
        }
      }
      if (0 === t3.offset && n3.isSpreadElement()) {
        const r4 = n3.parentPath;
        if (r4.isCallExpression() && 1 === r4.node.arguments.length) return void t3.candidates.push({ cause: "argSpread", path: e3 });
      }
      t3.references.push(e3);
    }
  }, BindingIdentifier(e3, t3) {
    c(e3, t3) && (t3.deopted = true);
  } };
  function p(e3, t3, r3) {
    const s3 = n2.types.numericLiteral(r3);
    let i3;
    const l2 = e3.parent;
    i3 = n2.types.isNumericLiteral(l2.property) ? n2.types.numericLiteral(l2.property.value + r3) : 0 === r3 ? l2.property : n2.types.binaryExpression("+", l2.property, n2.types.cloneNode(s3));
    const { scope: c2, parentPath: u2 } = e3;
    if (c2.isPure(i3)) {
      u2.replaceWith(o2({ ARGUMENTS: t3, OFFSET: s3, INDEX: i3 }));
      const e4 = u2, r4 = e4.get("test"), n3 = r4.get("left").evaluate();
      n3.confident && (true === n3.value ? e4.replaceWith(c2.buildUndefinedNode()) : r4.replaceWith(r4.get("right")));
    } else {
      const e4 = c2.generateUidIdentifierBasedOnNode(i3);
      c2.push({ id: e4, kind: "var" }), u2.replaceWith(a2({ ARGUMENTS: t3, OFFSET: s3, INDEX: i3, REF: n2.types.cloneNode(e4) }));
    }
  }
  function d(e3, t3, r3) {
    r3 ? e3.parentPath.replaceWith(l({ ARGUMENTS: t3, OFFSET: n2.types.numericLiteral(r3) })) : e3.replaceWith(t3);
  }
}];
var t = {};
function r(n2) {
  var s2 = t[n2];
  if (void 0 !== s2) return s2.exports;
  var i2 = t[n2] = { id: n2, loaded: false, exports: {} };
  return e[n2].call(i2.exports, i2, i2.exports, r), i2.loaded = true, i2.exports;
}
r.c = t, r.n = (e2) => {
  var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
  return r.d(t2, { a: t2 }), t2;
}, r.d = (e2, t2) => {
  for (var n2 in t2) r.o(t2, n2) && !r.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: true, get: t2[n2] });
}, r.g = function() {
  if ("object" == typeof globalThis) return globalThis;
  try {
    return this || new Function("return this")();
  } catch (e2) {
    if ("object" == typeof window) return window;
  }
}(), r.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r.nmd = (e2) => (e2.paths = [], e2.children || (e2.children = []), e2), r(346);
var n = r(347);
var s = n.a;
var i = n.b;
var o = n.c;
var a = n.d;
export {
  s as buildTemplateProcessor,
  i as loadModule,
  o as version,
  a as vueVersion
};
/*! Bundled license information:

vue3-sfc-loader/dist/vue3-sfc-loader.esm.js:
  (*!
   * vue3-sfc-loader v0.9.5 for vue3
   *
   * @description Vue3 Single File Component loader.
   * @author      Franck FREIBURGER <franck.freiburger@gmail.com>
   * @license     MIT
   * @sources     https://github.com/FranckFreiburger/vue3-sfc-loader
   *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (**
  * @vue/compiler-dom v3.4.15
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*! https://mths.be/punycode v1.4.1 by @mathias *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
  (**
  * @vue/compiler-sfc v3.4.15
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (**
  * @vue/compiler-core v3.4.15
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (**
  * @vue/shared v3.4.15
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
*/
//# sourceMappingURL=vue3-sfc-loader.js.map
