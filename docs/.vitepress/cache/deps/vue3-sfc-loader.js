import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-7AJPX2AP.js";

// node_modules/.pnpm/vue3-sfc-loader@0.9.5_vue@3.5.12_typescript@5.4.5_/node_modules/vue3-sfc-loader/dist/vue3-sfc-loader.esm.js
var e = [(e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true });
  var n2 = { react: true, assertNode: true, createTypeAnnotationBasedOnTypeof: true, createUnionTypeAnnotation: true, createFlowUnionType: true, createTSUnionType: true, cloneNode: true, clone: true, cloneDeep: true, cloneDeepWithoutLoc: true, cloneWithoutLoc: true, addComment: true, addComments: true, inheritInnerComments: true, inheritLeadingComments: true, inheritsComments: true, inheritTrailingComments: true, removeComments: true, ensureBlock: true, toBindingIdentifierName: true, toBlock: true, toComputedKey: true, toExpression: true, toIdentifier: true, toKeyAlias: true, toStatement: true, valueToNode: true, appendToMemberExpression: true, inherits: true, prependToMemberExpression: true, removeProperties: true, removePropertiesDeep: true, removeTypeDuplicates: true, getBindingIdentifiers: true, getOuterBindingIdentifiers: true, traverse: true, traverseFast: true, shallowEqual: true, is: true, isBinding: true, isBlockScoped: true, isImmutable: true, isLet: true, isNode: true, isNodesEquivalent: true, isPlaceholderType: true, isReferenced: true, isScope: true, isSpecifierDefault: true, isType: true, isValidES3Identifier: true, isValidIdentifier: true, isVar: true, matchesPattern: true, validate: true, buildMatchMemberExpression: true, __internal__deprecationWarning: true };
  Object.defineProperty(t2, "__internal__deprecationWarning", { enumerable: true, get: function() {
    return me.default;
  } }), Object.defineProperty(t2, "addComment", { enumerable: true, get: function() {
    return E.default;
  } }), Object.defineProperty(t2, "addComments", { enumerable: true, get: function() {
    return S.default;
  } }), Object.defineProperty(t2, "appendToMemberExpression", { enumerable: true, get: function() {
    return F.default;
  } }), Object.defineProperty(t2, "assertNode", { enumerable: true, get: function() {
    return a2.default;
  } }), Object.defineProperty(t2, "buildMatchMemberExpression", { enumerable: true, get: function() {
    return fe.default;
  } }), Object.defineProperty(t2, "clone", { enumerable: true, get: function() {
    return y.default;
  } }), Object.defineProperty(t2, "cloneDeep", { enumerable: true, get: function() {
    return g.default;
  } }), Object.defineProperty(t2, "cloneDeepWithoutLoc", { enumerable: true, get: function() {
    return b.default;
  } }), Object.defineProperty(t2, "cloneNode", { enumerable: true, get: function() {
    return m.default;
  } }), Object.defineProperty(t2, "cloneWithoutLoc", { enumerable: true, get: function() {
    return v.default;
  } }), Object.defineProperty(t2, "createFlowUnionType", { enumerable: true, get: function() {
    return u.default;
  } }), Object.defineProperty(t2, "createTSUnionType", { enumerable: true, get: function() {
    return p.default;
  } }), Object.defineProperty(t2, "createTypeAnnotationBasedOnTypeof", { enumerable: true, get: function() {
    return c.default;
  } }), Object.defineProperty(t2, "createUnionTypeAnnotation", { enumerable: true, get: function() {
    return u.default;
  } }), Object.defineProperty(t2, "ensureBlock", { enumerable: true, get: function() {
    return I.default;
  } }), Object.defineProperty(t2, "getBindingIdentifiers", { enumerable: true, get: function() {
    return G.default;
  } }), Object.defineProperty(t2, "getOuterBindingIdentifiers", { enumerable: true, get: function() {
    return H.default;
  } }), Object.defineProperty(t2, "inheritInnerComments", { enumerable: true, get: function() {
    return x.default;
  } }), Object.defineProperty(t2, "inheritLeadingComments", { enumerable: true, get: function() {
    return T.default;
  } }), Object.defineProperty(t2, "inheritTrailingComments", { enumerable: true, get: function() {
    return P.default;
  } }), Object.defineProperty(t2, "inherits", { enumerable: true, get: function() {
    return U.default;
  } }), Object.defineProperty(t2, "inheritsComments", { enumerable: true, get: function() {
    return w.default;
  } }), Object.defineProperty(t2, "is", { enumerable: true, get: function() {
    return J.default;
  } }), Object.defineProperty(t2, "isBinding", { enumerable: true, get: function() {
    return Y.default;
  } }), Object.defineProperty(t2, "isBlockScoped", { enumerable: true, get: function() {
    return Q.default;
  } }), Object.defineProperty(t2, "isImmutable", { enumerable: true, get: function() {
    return Z.default;
  } }), Object.defineProperty(t2, "isLet", { enumerable: true, get: function() {
    return ee.default;
  } }), Object.defineProperty(t2, "isNode", { enumerable: true, get: function() {
    return te.default;
  } }), Object.defineProperty(t2, "isNodesEquivalent", { enumerable: true, get: function() {
    return re.default;
  } }), Object.defineProperty(t2, "isPlaceholderType", { enumerable: true, get: function() {
    return ne.default;
  } }), Object.defineProperty(t2, "isReferenced", { enumerable: true, get: function() {
    return se.default;
  } }), Object.defineProperty(t2, "isScope", { enumerable: true, get: function() {
    return ie.default;
  } }), Object.defineProperty(t2, "isSpecifierDefault", { enumerable: true, get: function() {
    return oe.default;
  } }), Object.defineProperty(t2, "isType", { enumerable: true, get: function() {
    return ae.default;
  } }), Object.defineProperty(t2, "isValidES3Identifier", { enumerable: true, get: function() {
    return le.default;
  } }), Object.defineProperty(t2, "isValidIdentifier", { enumerable: true, get: function() {
    return ce.default;
  } }), Object.defineProperty(t2, "isVar", { enumerable: true, get: function() {
    return ue.default;
  } }), Object.defineProperty(t2, "matchesPattern", { enumerable: true, get: function() {
    return pe.default;
  } }), Object.defineProperty(t2, "prependToMemberExpression", { enumerable: true, get: function() {
    return $.default;
  } }), t2.react = void 0, Object.defineProperty(t2, "removeComments", { enumerable: true, get: function() {
    return A.default;
  } }), Object.defineProperty(t2, "removeProperties", { enumerable: true, get: function() {
    return V.default;
  } }), Object.defineProperty(t2, "removePropertiesDeep", { enumerable: true, get: function() {
    return q.default;
  } }), Object.defineProperty(t2, "removeTypeDuplicates", { enumerable: true, get: function() {
    return W.default;
  } }), Object.defineProperty(t2, "shallowEqual", { enumerable: true, get: function() {
    return X.default;
  } }), Object.defineProperty(t2, "toBindingIdentifierName", { enumerable: true, get: function() {
    return _.default;
  } }), Object.defineProperty(t2, "toBlock", { enumerable: true, get: function() {
    return k.default;
  } }), Object.defineProperty(t2, "toComputedKey", { enumerable: true, get: function() {
    return N.default;
  } }), Object.defineProperty(t2, "toExpression", { enumerable: true, get: function() {
    return D.default;
  } }), Object.defineProperty(t2, "toIdentifier", { enumerable: true, get: function() {
    return j.default;
  } }), Object.defineProperty(t2, "toKeyAlias", { enumerable: true, get: function() {
    return L.default;
  } }), Object.defineProperty(t2, "toStatement", { enumerable: true, get: function() {
    return M.default;
  } }), Object.defineProperty(t2, "traverse", { enumerable: true, get: function() {
    return z.default;
  } }), Object.defineProperty(t2, "traverseFast", { enumerable: true, get: function() {
    return K.default;
  } }), Object.defineProperty(t2, "validate", { enumerable: true, get: function() {
    return de.default;
  } }), Object.defineProperty(t2, "valueToNode", { enumerable: true, get: function() {
    return B.default;
  } });
  var s2 = r2(348), i2 = r2(349), o2 = r2(350), a2 = r2(362), l = r2(363);
  Object.keys(l).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === l[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return l[e3];
    } }));
  });
  var c = r2(364), u = r2(365), p = r2(366), d = r2(4);
  Object.keys(d).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === d[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return d[e3];
    } }));
  });
  var f = r2(368);
  Object.keys(f).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === f[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return f[e3];
    } }));
  });
  var h = r2(369);
  Object.keys(h).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === h[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return h[e3];
    } }));
  });
  var m = r2(27), y = r2(370), g = r2(371), b = r2(372), v = r2(373), E = r2(374), S = r2(172), x = r2(173), T = r2(174), w = r2(175), P = r2(176), A = r2(375), C = r2(376);
  Object.keys(C).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === C[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return C[e3];
    } }));
  });
  var O = r2(26);
  Object.keys(O).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === O[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return O[e3];
    } }));
  });
  var I = r2(377), _ = r2(378), k = r2(177), N = r2(379), D = r2(380), j = r2(178), L = r2(381), M = r2(382), B = r2(383), R = r2(9);
  Object.keys(R).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === R[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return R[e3];
    } }));
  });
  var F = r2(384), U = r2(385), $ = r2(386), V = r2(181), q = r2(179), W = r2(171), G = r2(60), H = r2(387), z = r2(388);
  Object.keys(z).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === z[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return z[e3];
    } }));
  });
  var K = r2(180), X = r2(96), J = r2(42), Y = r2(389), Q = r2(390), Z = r2(391), ee = r2(182), te = r2(170), re = r2(392), ne = r2(168), se = r2(393), ie = r2(394), oe = r2(395), ae = r2(98), le = r2(396), ce = r2(43), ue = r2(397), pe = r2(165), de = r2(97), fe = r2(164), he = r2(2);
  Object.keys(he).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n2, e3) || e3 in t2 && t2[e3] === he[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return he[e3];
    } }));
  });
  var me = r2(58);
  t2.react = { isReactComponent: s2.default, isCompatTag: i2.default, buildChildren: o2.default }, t2.toSequenceExpression = r2(398).default;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.DEFAULT_EXTENSIONS = void 0, Object.defineProperty(t2, "File", { enumerable: true, get: function() {
    return n2.default;
  } }), Object.defineProperty(t2, "buildExternalHelpers", { enumerable: true, get: function() {
    return s2.default;
  } }), Object.defineProperty(t2, "createConfigItem", { enumerable: true, get: function() {
    return p.createConfigItem;
  } }), Object.defineProperty(t2, "createConfigItemAsync", { enumerable: true, get: function() {
    return p.createConfigItemAsync;
  } }), Object.defineProperty(t2, "createConfigItemSync", { enumerable: true, get: function() {
    return p.createConfigItemSync;
  } }), Object.defineProperty(t2, "getEnv", { enumerable: true, get: function() {
    return o2.getEnv;
  } }), Object.defineProperty(t2, "loadOptions", { enumerable: true, get: function() {
    return p.loadOptions;
  } }), Object.defineProperty(t2, "loadOptionsAsync", { enumerable: true, get: function() {
    return p.loadOptionsAsync;
  } }), Object.defineProperty(t2, "loadOptionsSync", { enumerable: true, get: function() {
    return p.loadOptionsSync;
  } }), Object.defineProperty(t2, "loadPartialConfig", { enumerable: true, get: function() {
    return p.loadPartialConfig;
  } }), Object.defineProperty(t2, "loadPartialConfigAsync", { enumerable: true, get: function() {
    return p.loadPartialConfigAsync;
  } }), Object.defineProperty(t2, "loadPartialConfigSync", { enumerable: true, get: function() {
    return p.loadPartialConfigSync;
  } }), Object.defineProperty(t2, "parse", { enumerable: true, get: function() {
    return m.parse;
  } }), Object.defineProperty(t2, "parseAsync", { enumerable: true, get: function() {
    return m.parseAsync;
  } }), Object.defineProperty(t2, "parseSync", { enumerable: true, get: function() {
    return m.parseSync;
  } }), Object.defineProperty(t2, "resolvePlugin", { enumerable: true, get: function() {
    return i2.resolvePlugin;
  } }), Object.defineProperty(t2, "resolvePreset", { enumerable: true, get: function() {
    return i2.resolvePreset;
  } }), Object.defineProperty(t2, "template", { enumerable: true, get: function() {
    return u().default;
  } }), Object.defineProperty(t2, "tokTypes", { enumerable: true, get: function() {
    return l().tokTypes;
  } }), Object.defineProperty(t2, "transform", { enumerable: true, get: function() {
    return d.transform;
  } }), Object.defineProperty(t2, "transformAsync", { enumerable: true, get: function() {
    return d.transformAsync;
  } }), Object.defineProperty(t2, "transformFile", { enumerable: true, get: function() {
    return f.transformFile;
  } }), Object.defineProperty(t2, "transformFileAsync", { enumerable: true, get: function() {
    return f.transformFileAsync;
  } }), Object.defineProperty(t2, "transformFileSync", { enumerable: true, get: function() {
    return f.transformFileSync;
  } }), Object.defineProperty(t2, "transformFromAst", { enumerable: true, get: function() {
    return h.transformFromAst;
  } }), Object.defineProperty(t2, "transformFromAstAsync", { enumerable: true, get: function() {
    return h.transformFromAstAsync;
  } }), Object.defineProperty(t2, "transformFromAstSync", { enumerable: true, get: function() {
    return h.transformFromAstSync;
  } }), Object.defineProperty(t2, "transformSync", { enumerable: true, get: function() {
    return d.transformSync;
  } }), Object.defineProperty(t2, "traverse", { enumerable: true, get: function() {
    return c().default;
  } }), t2.version = t2.types = void 0;
  var n2 = r2(95), s2 = r2(453), i2 = r2(81), o2 = r2(278);
  function a2() {
    const e3 = r2(0);
    return a2 = function() {
      return e3;
    }, e3;
  }
  function l() {
    const e3 = r2(21);
    return l = function() {
      return e3;
    }, e3;
  }
  function c() {
    const e3 = r2(14);
    return c = function() {
      return e3;
    }, e3;
  }
  function u() {
    const e3 = r2(37);
    return u = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "types", { enumerable: true, get: function() {
    return a2();
  } });
  var p = r2(82), d = r2(475), f = r2(488), h = r2(489), m = r2(490);
  r2(1), t2.version = "7.23.9", t2.DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]), t2.OptionManager = class {
    init(e3) {
      return (0, p.loadOptionsSync)(e3);
    }
  }, t2.Plugin = function(e3) {
    throw new Error(`The (${e3}) Babel 5 plugin is being run with an unsupported Babel version.`);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isAccessor = function(e3, t3) {
    return !!e3 && ("ClassAccessorProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3)));
  }, t2.isAnyTypeAnnotation = function(e3, t3) {
    return !!e3 && "AnyTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isArgumentPlaceholder = function(e3, t3) {
    return !!e3 && "ArgumentPlaceholder" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isArrayExpression = function(e3, t3) {
    return !!e3 && "ArrayExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isArrayPattern = function(e3, t3) {
    return !!e3 && "ArrayPattern" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isArrayTypeAnnotation = function(e3, t3) {
    return !!e3 && "ArrayTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isArrowFunctionExpression = function(e3, t3) {
    return !!e3 && "ArrowFunctionExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isAssignmentExpression = function(e3, t3) {
    return !!e3 && "AssignmentExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isAssignmentPattern = function(e3, t3) {
    return !!e3 && "AssignmentPattern" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isAwaitExpression = function(e3, t3) {
    return !!e3 && "AwaitExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBigIntLiteral = function(e3, t3) {
    return !!e3 && "BigIntLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBinary = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isBinaryExpression = function(e3, t3) {
    return !!e3 && "BinaryExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBindExpression = function(e3, t3) {
    return !!e3 && "BindExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBlock = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if ("BlockStatement" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isBlockParent = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if ("BlockStatement" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isBlockStatement = function(e3, t3) {
    return !!e3 && "BlockStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBooleanLiteral = function(e3, t3) {
    return !!e3 && "BooleanLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBooleanLiteralTypeAnnotation = function(e3, t3) {
    return !!e3 && "BooleanLiteralTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBooleanTypeAnnotation = function(e3, t3) {
    return !!e3 && "BooleanTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isBreakStatement = function(e3, t3) {
    return !!e3 && "BreakStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isCallExpression = function(e3, t3) {
    return !!e3 && "CallExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isCatchClause = function(e3, t3) {
    return !!e3 && "CatchClause" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClass = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isClassAccessorProperty = function(e3, t3) {
    return !!e3 && "ClassAccessorProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassBody = function(e3, t3) {
    return !!e3 && "ClassBody" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassDeclaration = function(e3, t3) {
    return !!e3 && "ClassDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassExpression = function(e3, t3) {
    return !!e3 && "ClassExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassImplements = function(e3, t3) {
    return !!e3 && "ClassImplements" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassMethod = function(e3, t3) {
    return !!e3 && "ClassMethod" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassPrivateMethod = function(e3, t3) {
    return !!e3 && "ClassPrivateMethod" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassPrivateProperty = function(e3, t3) {
    return !!e3 && "ClassPrivateProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isClassProperty = function(e3, t3) {
    return !!e3 && "ClassProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isCompletionStatement = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isConditional = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isConditionalExpression = function(e3, t3) {
    return !!e3 && "ConditionalExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isContinueStatement = function(e3, t3) {
    return !!e3 && "ContinueStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDebuggerStatement = function(e3, t3) {
    return !!e3 && "DebuggerStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDecimalLiteral = function(e3, t3) {
    return !!e3 && "DecimalLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclaration = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if ("Declaration" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isDeclareClass = function(e3, t3) {
    return !!e3 && "DeclareClass" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareExportAllDeclaration = function(e3, t3) {
    return !!e3 && "DeclareExportAllDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareExportDeclaration = function(e3, t3) {
    return !!e3 && "DeclareExportDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareFunction = function(e3, t3) {
    return !!e3 && "DeclareFunction" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareInterface = function(e3, t3) {
    return !!e3 && "DeclareInterface" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareModule = function(e3, t3) {
    return !!e3 && "DeclareModule" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareModuleExports = function(e3, t3) {
    return !!e3 && "DeclareModuleExports" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareOpaqueType = function(e3, t3) {
    return !!e3 && "DeclareOpaqueType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareTypeAlias = function(e3, t3) {
    return !!e3 && "DeclareTypeAlias" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclareVariable = function(e3, t3) {
    return !!e3 && "DeclareVariable" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDeclaredPredicate = function(e3, t3) {
    return !!e3 && "DeclaredPredicate" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDecorator = function(e3, t3) {
    return !!e3 && "Decorator" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDirective = function(e3, t3) {
    return !!e3 && "Directive" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDirectiveLiteral = function(e3, t3) {
    return !!e3 && "DirectiveLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDoExpression = function(e3, t3) {
    return !!e3 && "DoExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isDoWhileStatement = function(e3, t3) {
    return !!e3 && "DoWhileStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEmptyStatement = function(e3, t3) {
    return !!e3 && "EmptyStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEmptyTypeAnnotation = function(e3, t3) {
    return !!e3 && "EmptyTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumBody = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isEnumBooleanBody = function(e3, t3) {
    return !!e3 && "EnumBooleanBody" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumBooleanMember = function(e3, t3) {
    return !!e3 && "EnumBooleanMember" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumDeclaration = function(e3, t3) {
    return !!e3 && "EnumDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumDefaultedMember = function(e3, t3) {
    return !!e3 && "EnumDefaultedMember" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumMember = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isEnumNumberBody = function(e3, t3) {
    return !!e3 && "EnumNumberBody" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumNumberMember = function(e3, t3) {
    return !!e3 && "EnumNumberMember" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumStringBody = function(e3, t3) {
    return !!e3 && "EnumStringBody" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumStringMember = function(e3, t3) {
    return !!e3 && "EnumStringMember" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isEnumSymbolBody = function(e3, t3) {
    return !!e3 && "EnumSymbolBody" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExistsTypeAnnotation = function(e3, t3) {
    return !!e3 && "ExistsTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExportAllDeclaration = function(e3, t3) {
    return !!e3 && "ExportAllDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExportDeclaration = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isExportDefaultDeclaration = function(e3, t3) {
    return !!e3 && "ExportDefaultDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExportDefaultSpecifier = function(e3, t3) {
    return !!e3 && "ExportDefaultSpecifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExportNamedDeclaration = function(e3, t3) {
    return !!e3 && "ExportNamedDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExportNamespaceSpecifier = function(e3, t3) {
    return !!e3 && "ExportNamespaceSpecifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExportSpecifier = function(e3, t3) {
    return !!e3 && "ExportSpecifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExpression = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e3.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isExpressionStatement = function(e3, t3) {
    return !!e3 && "ExpressionStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isExpressionWrapper = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFile = function(e3, t3) {
    return !!e3 && "File" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isFlow = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFlowBaseAnnotation = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFlowDeclaration = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFlowPredicate = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFlowType = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFor = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isForInStatement = function(e3, t3) {
    return !!e3 && "ForInStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isForOfStatement = function(e3, t3) {
    return !!e3 && "ForOfStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isForStatement = function(e3, t3) {
    return !!e3 && "ForStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isForXStatement = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFunction = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFunctionDeclaration = function(e3, t3) {
    return !!e3 && "FunctionDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isFunctionExpression = function(e3, t3) {
    return !!e3 && "FunctionExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isFunctionParent = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isFunctionTypeAnnotation = function(e3, t3) {
    return !!e3 && "FunctionTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isFunctionTypeParam = function(e3, t3) {
    return !!e3 && "FunctionTypeParam" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isGenericTypeAnnotation = function(e3, t3) {
    return !!e3 && "GenericTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isIdentifier = function(e3, t3) {
    return !!e3 && "Identifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isIfStatement = function(e3, t3) {
    return !!e3 && "IfStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImmutable = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if ("StringLiteral" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isImport = function(e3, t3) {
    return !!e3 && "Import" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImportAttribute = function(e3, t3) {
    return !!e3 && "ImportAttribute" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImportDeclaration = function(e3, t3) {
    return !!e3 && "ImportDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImportDefaultSpecifier = function(e3, t3) {
    return !!e3 && "ImportDefaultSpecifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImportExpression = function(e3, t3) {
    return !!e3 && "ImportExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImportNamespaceSpecifier = function(e3, t3) {
    return !!e3 && "ImportNamespaceSpecifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isImportOrExportDeclaration = i2, t2.isImportSpecifier = function(e3, t3) {
    return !!e3 && "ImportSpecifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isIndexedAccessType = function(e3, t3) {
    return !!e3 && "IndexedAccessType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isInferredPredicate = function(e3, t3) {
    return !!e3 && "InferredPredicate" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isInterfaceDeclaration = function(e3, t3) {
    return !!e3 && "InterfaceDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isInterfaceExtends = function(e3, t3) {
    return !!e3 && "InterfaceExtends" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isInterfaceTypeAnnotation = function(e3, t3) {
    return !!e3 && "InterfaceTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isInterpreterDirective = function(e3, t3) {
    return !!e3 && "InterpreterDirective" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isIntersectionTypeAnnotation = function(e3, t3) {
    return !!e3 && "IntersectionTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSX = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isJSXAttribute = function(e3, t3) {
    return !!e3 && "JSXAttribute" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXClosingElement = function(e3, t3) {
    return !!e3 && "JSXClosingElement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXClosingFragment = function(e3, t3) {
    return !!e3 && "JSXClosingFragment" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXElement = function(e3, t3) {
    return !!e3 && "JSXElement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXEmptyExpression = function(e3, t3) {
    return !!e3 && "JSXEmptyExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXExpressionContainer = function(e3, t3) {
    return !!e3 && "JSXExpressionContainer" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXFragment = function(e3, t3) {
    return !!e3 && "JSXFragment" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXIdentifier = function(e3, t3) {
    return !!e3 && "JSXIdentifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXMemberExpression = function(e3, t3) {
    return !!e3 && "JSXMemberExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXNamespacedName = function(e3, t3) {
    return !!e3 && "JSXNamespacedName" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXOpeningElement = function(e3, t3) {
    return !!e3 && "JSXOpeningElement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXOpeningFragment = function(e3, t3) {
    return !!e3 && "JSXOpeningFragment" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXSpreadAttribute = function(e3, t3) {
    return !!e3 && "JSXSpreadAttribute" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXSpreadChild = function(e3, t3) {
    return !!e3 && "JSXSpreadChild" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isJSXText = function(e3, t3) {
    return !!e3 && "JSXText" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isLVal = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e3.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isLabeledStatement = function(e3, t3) {
    return !!e3 && "LabeledStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isLiteral = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if ("StringLiteral" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isLogicalExpression = function(e3, t3) {
    return !!e3 && "LogicalExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isLoop = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isMemberExpression = function(e3, t3) {
    return !!e3 && "MemberExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isMetaProperty = function(e3, t3) {
    return !!e3 && "MetaProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isMethod = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isMiscellaneous = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isMixedTypeAnnotation = function(e3, t3) {
    return !!e3 && "MixedTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isModuleDeclaration = function(e3, t3) {
    return (0, s2.default)("isModuleDeclaration", "isImportOrExportDeclaration"), i2(e3, t3);
  }, t2.isModuleExpression = function(e3, t3) {
    return !!e3 && "ModuleExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isModuleSpecifier = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isNewExpression = function(e3, t3) {
    return !!e3 && "NewExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNoop = function(e3, t3) {
    return !!e3 && "Noop" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNullLiteral = function(e3, t3) {
    return !!e3 && "NullLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNullLiteralTypeAnnotation = function(e3, t3) {
    return !!e3 && "NullLiteralTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNullableTypeAnnotation = function(e3, t3) {
    return !!e3 && "NullableTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNumberLiteral = function(e3, t3) {
    return (0, s2.default)("isNumberLiteral", "isNumericLiteral"), !!e3 && "NumberLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNumberLiteralTypeAnnotation = function(e3, t3) {
    return !!e3 && "NumberLiteralTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNumberTypeAnnotation = function(e3, t3) {
    return !!e3 && "NumberTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isNumericLiteral = function(e3, t3) {
    return !!e3 && "NumericLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectExpression = function(e3, t3) {
    return !!e3 && "ObjectExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectMember = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isObjectMethod = function(e3, t3) {
    return !!e3 && "ObjectMethod" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectPattern = function(e3, t3) {
    return !!e3 && "ObjectPattern" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectProperty = function(e3, t3) {
    return !!e3 && "ObjectProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectTypeAnnotation = function(e3, t3) {
    return !!e3 && "ObjectTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectTypeCallProperty = function(e3, t3) {
    return !!e3 && "ObjectTypeCallProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectTypeIndexer = function(e3, t3) {
    return !!e3 && "ObjectTypeIndexer" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectTypeInternalSlot = function(e3, t3) {
    return !!e3 && "ObjectTypeInternalSlot" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectTypeProperty = function(e3, t3) {
    return !!e3 && "ObjectTypeProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isObjectTypeSpreadProperty = function(e3, t3) {
    return !!e3 && "ObjectTypeSpreadProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isOpaqueType = function(e3, t3) {
    return !!e3 && "OpaqueType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isOptionalCallExpression = function(e3, t3) {
    return !!e3 && "OptionalCallExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isOptionalIndexedAccessType = function(e3, t3) {
    return !!e3 && "OptionalIndexedAccessType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isOptionalMemberExpression = function(e3, t3) {
    return !!e3 && "OptionalMemberExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isParenthesizedExpression = function(e3, t3) {
    return !!e3 && "ParenthesizedExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isPattern = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if ("Pattern" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isPatternLike = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e3.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isPipelineBareFunction = function(e3, t3) {
    return !!e3 && "PipelineBareFunction" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isPipelinePrimaryTopicReference = function(e3, t3) {
    return !!e3 && "PipelinePrimaryTopicReference" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isPipelineTopicExpression = function(e3, t3) {
    return !!e3 && "PipelineTopicExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isPlaceholder = function(e3, t3) {
    return !!e3 && "Placeholder" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isPrivate = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isPrivateName = function(e3, t3) {
    return !!e3 && "PrivateName" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isProgram = function(e3, t3) {
    return !!e3 && "Program" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isProperty = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isPureish = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if ("StringLiteral" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isQualifiedTypeIdentifier = function(e3, t3) {
    return !!e3 && "QualifiedTypeIdentifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isRecordExpression = function(e3, t3) {
    return !!e3 && "RecordExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isRegExpLiteral = function(e3, t3) {
    return !!e3 && "RegExpLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isRegexLiteral = function(e3, t3) {
    return (0, s2.default)("isRegexLiteral", "isRegExpLiteral"), !!e3 && "RegexLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isRestElement = function(e3, t3) {
    return !!e3 && "RestElement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isRestProperty = function(e3, t3) {
    return (0, s2.default)("isRestProperty", "isRestElement"), !!e3 && "RestProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isReturnStatement = function(e3, t3) {
    return !!e3 && "ReturnStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isScopable = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if ("BlockStatement" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isSequenceExpression = function(e3, t3) {
    return !!e3 && "SequenceExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isSpreadElement = function(e3, t3) {
    return !!e3 && "SpreadElement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isSpreadProperty = function(e3, t3) {
    return (0, s2.default)("isSpreadProperty", "isSpreadElement"), !!e3 && "SpreadProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isStandardized = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (e3.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isStatement = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (e3.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isStaticBlock = function(e3, t3) {
    return !!e3 && "StaticBlock" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isStringLiteral = function(e3, t3) {
    return !!e3 && "StringLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isStringLiteralTypeAnnotation = function(e3, t3) {
    return !!e3 && "StringLiteralTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isStringTypeAnnotation = function(e3, t3) {
    return !!e3 && "StringTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isSuper = function(e3, t3) {
    return !!e3 && "Super" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isSwitchCase = function(e3, t3) {
    return !!e3 && "SwitchCase" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isSwitchStatement = function(e3, t3) {
    return !!e3 && "SwitchStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isSymbolTypeAnnotation = function(e3, t3) {
    return !!e3 && "SymbolTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSAnyKeyword = function(e3, t3) {
    return !!e3 && "TSAnyKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSArrayType = function(e3, t3) {
    return !!e3 && "TSArrayType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSAsExpression = function(e3, t3) {
    return !!e3 && "TSAsExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSBaseType = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isTSBigIntKeyword = function(e3, t3) {
    return !!e3 && "TSBigIntKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSBooleanKeyword = function(e3, t3) {
    return !!e3 && "TSBooleanKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSCallSignatureDeclaration = function(e3, t3) {
    return !!e3 && "TSCallSignatureDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSConditionalType = function(e3, t3) {
    return !!e3 && "TSConditionalType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSConstructSignatureDeclaration = function(e3, t3) {
    return !!e3 && "TSConstructSignatureDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSConstructorType = function(e3, t3) {
    return !!e3 && "TSConstructorType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSDeclareFunction = function(e3, t3) {
    return !!e3 && "TSDeclareFunction" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSDeclareMethod = function(e3, t3) {
    return !!e3 && "TSDeclareMethod" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSEntityName = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if ("Identifier" === e3.expectedNode) break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isTSEnumDeclaration = function(e3, t3) {
    return !!e3 && "TSEnumDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSEnumMember = function(e3, t3) {
    return !!e3 && "TSEnumMember" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSExportAssignment = function(e3, t3) {
    return !!e3 && "TSExportAssignment" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSExpressionWithTypeArguments = function(e3, t3) {
    return !!e3 && "TSExpressionWithTypeArguments" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSExternalModuleReference = function(e3, t3) {
    return !!e3 && "TSExternalModuleReference" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSFunctionType = function(e3, t3) {
    return !!e3 && "TSFunctionType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSImportEqualsDeclaration = function(e3, t3) {
    return !!e3 && "TSImportEqualsDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSImportType = function(e3, t3) {
    return !!e3 && "TSImportType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSIndexSignature = function(e3, t3) {
    return !!e3 && "TSIndexSignature" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSIndexedAccessType = function(e3, t3) {
    return !!e3 && "TSIndexedAccessType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSInferType = function(e3, t3) {
    return !!e3 && "TSInferType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSInstantiationExpression = function(e3, t3) {
    return !!e3 && "TSInstantiationExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSInterfaceBody = function(e3, t3) {
    return !!e3 && "TSInterfaceBody" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSInterfaceDeclaration = function(e3, t3) {
    return !!e3 && "TSInterfaceDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSIntersectionType = function(e3, t3) {
    return !!e3 && "TSIntersectionType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSIntrinsicKeyword = function(e3, t3) {
    return !!e3 && "TSIntrinsicKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSLiteralType = function(e3, t3) {
    return !!e3 && "TSLiteralType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSMappedType = function(e3, t3) {
    return !!e3 && "TSMappedType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSMethodSignature = function(e3, t3) {
    return !!e3 && "TSMethodSignature" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSModuleBlock = function(e3, t3) {
    return !!e3 && "TSModuleBlock" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSModuleDeclaration = function(e3, t3) {
    return !!e3 && "TSModuleDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSNamedTupleMember = function(e3, t3) {
    return !!e3 && "TSNamedTupleMember" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSNamespaceExportDeclaration = function(e3, t3) {
    return !!e3 && "TSNamespaceExportDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSNeverKeyword = function(e3, t3) {
    return !!e3 && "TSNeverKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSNonNullExpression = function(e3, t3) {
    return !!e3 && "TSNonNullExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSNullKeyword = function(e3, t3) {
    return !!e3 && "TSNullKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSNumberKeyword = function(e3, t3) {
    return !!e3 && "TSNumberKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSObjectKeyword = function(e3, t3) {
    return !!e3 && "TSObjectKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSOptionalType = function(e3, t3) {
    return !!e3 && "TSOptionalType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSParameterProperty = function(e3, t3) {
    return !!e3 && "TSParameterProperty" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSParenthesizedType = function(e3, t3) {
    return !!e3 && "TSParenthesizedType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSPropertySignature = function(e3, t3) {
    return !!e3 && "TSPropertySignature" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSQualifiedName = function(e3, t3) {
    return !!e3 && "TSQualifiedName" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSRestType = function(e3, t3) {
    return !!e3 && "TSRestType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSSatisfiesExpression = function(e3, t3) {
    return !!e3 && "TSSatisfiesExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSStringKeyword = function(e3, t3) {
    return !!e3 && "TSStringKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSSymbolKeyword = function(e3, t3) {
    return !!e3 && "TSSymbolKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSThisType = function(e3, t3) {
    return !!e3 && "TSThisType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTupleType = function(e3, t3) {
    return !!e3 && "TSTupleType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSType = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isTSTypeAliasDeclaration = function(e3, t3) {
    return !!e3 && "TSTypeAliasDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeAnnotation = function(e3, t3) {
    return !!e3 && "TSTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeAssertion = function(e3, t3) {
    return !!e3 && "TSTypeAssertion" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeElement = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isTSTypeLiteral = function(e3, t3) {
    return !!e3 && "TSTypeLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeOperator = function(e3, t3) {
    return !!e3 && "TSTypeOperator" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeParameter = function(e3, t3) {
    return !!e3 && "TSTypeParameter" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeParameterDeclaration = function(e3, t3) {
    return !!e3 && "TSTypeParameterDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeParameterInstantiation = function(e3, t3) {
    return !!e3 && "TSTypeParameterInstantiation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypePredicate = function(e3, t3) {
    return !!e3 && "TSTypePredicate" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeQuery = function(e3, t3) {
    return !!e3 && "TSTypeQuery" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSTypeReference = function(e3, t3) {
    return !!e3 && "TSTypeReference" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSUndefinedKeyword = function(e3, t3) {
    return !!e3 && "TSUndefinedKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSUnionType = function(e3, t3) {
    return !!e3 && "TSUnionType" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSUnknownKeyword = function(e3, t3) {
    return !!e3 && "TSUnknownKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTSVoidKeyword = function(e3, t3) {
    return !!e3 && "TSVoidKeyword" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTaggedTemplateExpression = function(e3, t3) {
    return !!e3 && "TaggedTemplateExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTemplateElement = function(e3, t3) {
    return !!e3 && "TemplateElement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTemplateLiteral = function(e3, t3) {
    return !!e3 && "TemplateLiteral" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTerminatorless = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isThisExpression = function(e3, t3) {
    return !!e3 && "ThisExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isThisTypeAnnotation = function(e3, t3) {
    return !!e3 && "ThisTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isThrowStatement = function(e3, t3) {
    return !!e3 && "ThrowStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTopicReference = function(e3, t3) {
    return !!e3 && "TopicReference" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTryStatement = function(e3, t3) {
    return !!e3 && "TryStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTupleExpression = function(e3, t3) {
    return !!e3 && "TupleExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTupleTypeAnnotation = function(e3, t3) {
    return !!e3 && "TupleTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeAlias = function(e3, t3) {
    return !!e3 && "TypeAlias" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeAnnotation = function(e3, t3) {
    return !!e3 && "TypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeCastExpression = function(e3, t3) {
    return !!e3 && "TypeCastExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeParameter = function(e3, t3) {
    return !!e3 && "TypeParameter" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeParameterDeclaration = function(e3, t3) {
    return !!e3 && "TypeParameterDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeParameterInstantiation = function(e3, t3) {
    return !!e3 && "TypeParameterInstantiation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isTypeScript = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isTypeofTypeAnnotation = function(e3, t3) {
    return !!e3 && "TypeofTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isUnaryExpression = function(e3, t3) {
    return !!e3 && "UnaryExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isUnaryLike = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isUnionTypeAnnotation = function(e3, t3) {
    return !!e3 && "UnionTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isUpdateExpression = function(e3, t3) {
    return !!e3 && "UpdateExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isUserWhitespacable = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isV8IntrinsicIdentifier = function(e3, t3) {
    return !!e3 && "V8IntrinsicIdentifier" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isVariableDeclaration = function(e3, t3) {
    return !!e3 && "VariableDeclaration" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isVariableDeclarator = function(e3, t3) {
    return !!e3 && "VariableDeclarator" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isVariance = function(e3, t3) {
    return !!e3 && "Variance" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isVoidTypeAnnotation = function(e3, t3) {
    return !!e3 && "VoidTypeAnnotation" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isWhile = function(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }, t2.isWhileStatement = function(e3, t3) {
    return !!e3 && "WhileStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isWithStatement = function(e3, t3) {
    return !!e3 && "WithStatement" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  }, t2.isYieldExpression = function(e3, t3) {
    return !!e3 && "YieldExpression" === e3.type && (null == t3 || (0, n2.default)(e3, t3));
  };
  var n2 = r2(96), s2 = r2(58);
  function i2(e3, t3) {
    if (!e3) return false;
    switch (e3.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return false;
    }
    return null == t3 || (0, n2.default)(e3, t3);
  }
}, (e2, t2, r2) => {
  const n2 = r2(48), { MAX_LENGTH: s2, MAX_SAFE_INTEGER: i2 } = r2(47), { safeRe: o2, t: a2 } = r2(34), l = r2(75), { compareIdentifiers: c } = r2(128);
  class u {
    constructor(e3, t3) {
      if (t3 = l(t3), e3 instanceof u) {
        if (e3.loose === !!t3.loose && e3.includePrerelease === !!t3.includePrerelease) return e3;
        e3 = e3.version;
      } else if ("string" != typeof e3) throw new TypeError(`Invalid version. Must be a string. Got type "${typeof e3}".`);
      if (e3.length > s2) throw new TypeError(`version is longer than ${s2} characters`);
      n2("SemVer", e3, t3), this.options = t3, this.loose = !!t3.loose, this.includePrerelease = !!t3.includePrerelease;
      const r3 = e3.trim().match(t3.loose ? o2[a2.LOOSE] : o2[a2.FULL]);
      if (!r3) throw new TypeError(`Invalid Version: ${e3}`);
      if (this.raw = e3, this.major = +r3[1], this.minor = +r3[2], this.patch = +r3[3], this.major > i2 || this.major < 0) throw new TypeError("Invalid major version");
      if (this.minor > i2 || this.minor < 0) throw new TypeError("Invalid minor version");
      if (this.patch > i2 || this.patch < 0) throw new TypeError("Invalid patch version");
      r3[4] ? this.prerelease = r3[4].split(".").map((e4) => {
        if (/^[0-9]+$/.test(e4)) {
          const t4 = +e4;
          if (t4 >= 0 && t4 < i2) return t4;
        }
        return e4;
      }) : this.prerelease = [], this.build = r3[5] ? r3[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(e3) {
      if (n2("SemVer.compare", this.version, this.options, e3), !(e3 instanceof u)) {
        if ("string" == typeof e3 && e3 === this.version) return 0;
        e3 = new u(e3, this.options);
      }
      return e3.version === this.version ? 0 : this.compareMain(e3) || this.comparePre(e3);
    }
    compareMain(e3) {
      return e3 instanceof u || (e3 = new u(e3, this.options)), c(this.major, e3.major) || c(this.minor, e3.minor) || c(this.patch, e3.patch);
    }
    comparePre(e3) {
      if (e3 instanceof u || (e3 = new u(e3, this.options)), this.prerelease.length && !e3.prerelease.length) return -1;
      if (!this.prerelease.length && e3.prerelease.length) return 1;
      if (!this.prerelease.length && !e3.prerelease.length) return 0;
      let t3 = 0;
      do {
        const r3 = this.prerelease[t3], s3 = e3.prerelease[t3];
        if (n2("prerelease compare", t3, r3, s3), void 0 === r3 && void 0 === s3) return 0;
        if (void 0 === s3) return 1;
        if (void 0 === r3) return -1;
        if (r3 !== s3) return c(r3, s3);
      } while (++t3);
    }
    compareBuild(e3) {
      e3 instanceof u || (e3 = new u(e3, this.options));
      let t3 = 0;
      do {
        const r3 = this.build[t3], s3 = e3.build[t3];
        if (n2("prerelease compare", t3, r3, s3), void 0 === r3 && void 0 === s3) return 0;
        if (void 0 === s3) return 1;
        if (void 0 === r3) return -1;
        if (r3 !== s3) return c(r3, s3);
      } while (++t3);
    }
    inc(e3, t3, r3) {
      switch (e3) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t3, r3);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t3, r3);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", t3, r3), this.inc("pre", t3, r3);
          break;
        case "prerelease":
          0 === this.prerelease.length && this.inc("patch", t3, r3), this.inc("pre", t3, r3);
          break;
        case "major":
          0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          0 === this.prerelease.length && this.patch++, this.prerelease = [];
          break;
        case "pre": {
          const e4 = Number(r3) ? 1 : 0;
          if (!t3 && false === r3) throw new Error("invalid increment argument: identifier is empty");
          if (0 === this.prerelease.length) this.prerelease = [e4];
          else {
            let n3 = this.prerelease.length;
            for (; --n3 >= 0; ) "number" == typeof this.prerelease[n3] && (this.prerelease[n3]++, n3 = -2);
            if (-1 === n3) {
              if (t3 === this.prerelease.join(".") && false === r3) throw new Error("invalid increment argument: identifier already exists");
              this.prerelease.push(e4);
            }
          }
          if (t3) {
            let n3 = [t3, e4];
            false === r3 && (n3 = [t3]), 0 === c(this.prerelease[0], t3) ? isNaN(this.prerelease[1]) && (this.prerelease = n3) : this.prerelease = n3;
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${e3}`);
      }
      return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
    }
  }
  e2.exports = u;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.anyTypeAnnotation = function() {
    return { type: "AnyTypeAnnotation" };
  }, t2.argumentPlaceholder = function() {
    return { type: "ArgumentPlaceholder" };
  }, t2.arrayExpression = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return (0, n2.default)({ type: "ArrayExpression", elements: e3 });
  }, t2.arrayPattern = function(e3) {
    return (0, n2.default)({ type: "ArrayPattern", elements: e3 });
  }, t2.arrayTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "ArrayTypeAnnotation", elementType: e3 });
  }, t2.arrowFunctionExpression = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return (0, n2.default)({ type: "ArrowFunctionExpression", params: e3, body: t3, async: r3, expression: null });
  }, t2.assignmentExpression = function(e3, t3, r3) {
    return (0, n2.default)({ type: "AssignmentExpression", operator: e3, left: t3, right: r3 });
  }, t2.assignmentPattern = function(e3, t3) {
    return (0, n2.default)({ type: "AssignmentPattern", left: e3, right: t3 });
  }, t2.awaitExpression = function(e3) {
    return (0, n2.default)({ type: "AwaitExpression", argument: e3 });
  }, t2.bigIntLiteral = function(e3) {
    return (0, n2.default)({ type: "BigIntLiteral", value: e3 });
  }, t2.binaryExpression = function(e3, t3, r3) {
    return (0, n2.default)({ type: "BinaryExpression", operator: e3, left: t3, right: r3 });
  }, t2.bindExpression = function(e3, t3) {
    return (0, n2.default)({ type: "BindExpression", object: e3, callee: t3 });
  }, t2.blockStatement = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    return (0, n2.default)({ type: "BlockStatement", body: e3, directives: t3 });
  }, t2.booleanLiteral = function(e3) {
    return (0, n2.default)({ type: "BooleanLiteral", value: e3 });
  }, t2.booleanLiteralTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "BooleanLiteralTypeAnnotation", value: e3 });
  }, t2.booleanTypeAnnotation = function() {
    return { type: "BooleanTypeAnnotation" };
  }, t2.breakStatement = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
    return (0, n2.default)({ type: "BreakStatement", label: e3 });
  }, t2.callExpression = function(e3, t3) {
    return (0, n2.default)({ type: "CallExpression", callee: e3, arguments: t3 });
  }, t2.catchClause = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0;
    return (0, n2.default)({ type: "CatchClause", param: e3, body: t3 });
  }, t2.classAccessorProperty = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o3 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
    return (0, n2.default)({ type: "ClassAccessorProperty", key: e3, value: t3, typeAnnotation: r3, decorators: s3, computed: i3, static: o3 });
  }, t2.classBody = function(e3) {
    return (0, n2.default)({ type: "ClassBody", body: e3 });
  }, t2.classDeclaration = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "ClassDeclaration", id: e3, superClass: t3, body: r3, decorators: s3 });
  }, t2.classExpression = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "ClassExpression", id: e3, superClass: t3, body: r3, decorators: s3 });
  }, t2.classImplements = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "ClassImplements", id: e3, typeParameters: t3 });
  }, t2.classMethod = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "method", t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 ? arguments[3] : void 0, i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o3 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5], a3 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], l2 = arguments.length > 7 && void 0 !== arguments[7] && arguments[7];
    return (0, n2.default)({ type: "ClassMethod", kind: e3, key: t3, params: r3, body: s3, computed: i3, static: o3, generator: a3, async: l2 });
  }, t2.classPrivateMethod = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "method", t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 ? arguments[3] : void 0, i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    return (0, n2.default)({ type: "ClassPrivateMethod", kind: e3, key: t3, params: r3, body: s3, static: i3 });
  }, t2.classPrivateProperty = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    return (0, n2.default)({ type: "ClassPrivateProperty", key: e3, value: t3, decorators: r3, static: s3 });
  }, t2.classProperty = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o3 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
    return (0, n2.default)({ type: "ClassProperty", key: e3, value: t3, typeAnnotation: r3, decorators: s3, computed: i3, static: o3 });
  }, t2.conditionalExpression = function(e3, t3, r3) {
    return (0, n2.default)({ type: "ConditionalExpression", test: e3, consequent: t3, alternate: r3 });
  }, t2.continueStatement = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
    return (0, n2.default)({ type: "ContinueStatement", label: e3 });
  }, t2.debuggerStatement = function() {
    return { type: "DebuggerStatement" };
  }, t2.decimalLiteral = function(e3) {
    return (0, n2.default)({ type: "DecimalLiteral", value: e3 });
  }, t2.declareClass = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "DeclareClass", id: e3, typeParameters: t3, extends: r3, body: s3 });
  }, t2.declareExportAllDeclaration = function(e3) {
    return (0, n2.default)({ type: "DeclareExportAllDeclaration", source: e3 });
  }, t2.declareExportDeclaration = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "DeclareExportDeclaration", declaration: e3, specifiers: t3, source: r3 });
  }, t2.declareFunction = function(e3) {
    return (0, n2.default)({ type: "DeclareFunction", id: e3 });
  }, t2.declareInterface = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "DeclareInterface", id: e3, typeParameters: t3, extends: r3, body: s3 });
  }, t2.declareModule = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "DeclareModule", id: e3, body: t3, kind: r3 });
  }, t2.declareModuleExports = function(e3) {
    return (0, n2.default)({ type: "DeclareModuleExports", typeAnnotation: e3 });
  }, t2.declareOpaqueType = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "DeclareOpaqueType", id: e3, typeParameters: t3, supertype: r3 });
  }, t2.declareTypeAlias = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0;
    return (0, n2.default)({ type: "DeclareTypeAlias", id: e3, typeParameters: t3, right: r3 });
  }, t2.declareVariable = function(e3) {
    return (0, n2.default)({ type: "DeclareVariable", id: e3 });
  }, t2.declaredPredicate = function(e3) {
    return (0, n2.default)({ type: "DeclaredPredicate", value: e3 });
  }, t2.decorator = function(e3) {
    return (0, n2.default)({ type: "Decorator", expression: e3 });
  }, t2.directive = function(e3) {
    return (0, n2.default)({ type: "Directive", value: e3 });
  }, t2.directiveLiteral = function(e3) {
    return (0, n2.default)({ type: "DirectiveLiteral", value: e3 });
  }, t2.doExpression = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return (0, n2.default)({ type: "DoExpression", body: e3, async: t3 });
  }, t2.doWhileStatement = function(e3, t3) {
    return (0, n2.default)({ type: "DoWhileStatement", test: e3, body: t3 });
  }, t2.emptyStatement = function() {
    return { type: "EmptyStatement" };
  }, t2.emptyTypeAnnotation = function() {
    return { type: "EmptyTypeAnnotation" };
  }, t2.enumBooleanBody = function(e3) {
    return (0, n2.default)({ type: "EnumBooleanBody", members: e3, explicitType: null, hasUnknownMembers: null });
  }, t2.enumBooleanMember = function(e3) {
    return (0, n2.default)({ type: "EnumBooleanMember", id: e3, init: null });
  }, t2.enumDeclaration = function(e3, t3) {
    return (0, n2.default)({ type: "EnumDeclaration", id: e3, body: t3 });
  }, t2.enumDefaultedMember = function(e3) {
    return (0, n2.default)({ type: "EnumDefaultedMember", id: e3 });
  }, t2.enumNumberBody = function(e3) {
    return (0, n2.default)({ type: "EnumNumberBody", members: e3, explicitType: null, hasUnknownMembers: null });
  }, t2.enumNumberMember = function(e3, t3) {
    return (0, n2.default)({ type: "EnumNumberMember", id: e3, init: t3 });
  }, t2.enumStringBody = function(e3) {
    return (0, n2.default)({ type: "EnumStringBody", members: e3, explicitType: null, hasUnknownMembers: null });
  }, t2.enumStringMember = function(e3, t3) {
    return (0, n2.default)({ type: "EnumStringMember", id: e3, init: t3 });
  }, t2.enumSymbolBody = function(e3) {
    return (0, n2.default)({ type: "EnumSymbolBody", members: e3, hasUnknownMembers: null });
  }, t2.existsTypeAnnotation = function() {
    return { type: "ExistsTypeAnnotation" };
  }, t2.exportAllDeclaration = function(e3) {
    return (0, n2.default)({ type: "ExportAllDeclaration", source: e3 });
  }, t2.exportDefaultDeclaration = function(e3) {
    return (0, n2.default)({ type: "ExportDefaultDeclaration", declaration: e3 });
  }, t2.exportDefaultSpecifier = function(e3) {
    return (0, n2.default)({ type: "ExportDefaultSpecifier", exported: e3 });
  }, t2.exportNamedDeclaration = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "ExportNamedDeclaration", declaration: e3, specifiers: t3, source: r3 });
  }, t2.exportNamespaceSpecifier = function(e3) {
    return (0, n2.default)({ type: "ExportNamespaceSpecifier", exported: e3 });
  }, t2.exportSpecifier = function(e3, t3) {
    return (0, n2.default)({ type: "ExportSpecifier", local: e3, exported: t3 });
  }, t2.expressionStatement = function(e3) {
    return (0, n2.default)({ type: "ExpressionStatement", expression: e3 });
  }, t2.file = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "File", program: e3, comments: t3, tokens: r3 });
  }, t2.forInStatement = function(e3, t3, r3) {
    return (0, n2.default)({ type: "ForInStatement", left: e3, right: t3, body: r3 });
  }, t2.forOfStatement = function(e3, t3, r3) {
    let s3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    return (0, n2.default)({ type: "ForOfStatement", left: e3, right: t3, body: r3, await: s3 });
  }, t2.forStatement = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "ForStatement", init: e3, test: t3, update: r3, body: s3 });
  }, t2.functionDeclaration = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    return (0, n2.default)({ type: "FunctionDeclaration", id: e3, params: t3, body: r3, generator: s3, async: i3 });
  }, t2.functionExpression = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    return (0, n2.default)({ type: "FunctionExpression", id: e3, params: t3, body: r3, generator: s3, async: i3 });
  }, t2.functionTypeAnnotation = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "FunctionTypeAnnotation", typeParameters: e3, params: t3, rest: r3, returnType: s3 });
  }, t2.functionTypeParam = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0;
    return (0, n2.default)({ type: "FunctionTypeParam", name: e3, typeAnnotation: t3 });
  }, t2.genericTypeAnnotation = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "GenericTypeAnnotation", id: e3, typeParameters: t3 });
  }, t2.identifier = function(e3) {
    return (0, n2.default)({ type: "Identifier", name: e3 });
  }, t2.ifStatement = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "IfStatement", test: e3, consequent: t3, alternate: r3 });
  }, t2.import = function() {
    return { type: "Import" };
  }, t2.importAttribute = function(e3, t3) {
    return (0, n2.default)({ type: "ImportAttribute", key: e3, value: t3 });
  }, t2.importDeclaration = function(e3, t3) {
    return (0, n2.default)({ type: "ImportDeclaration", specifiers: e3, source: t3 });
  }, t2.importDefaultSpecifier = function(e3) {
    return (0, n2.default)({ type: "ImportDefaultSpecifier", local: e3 });
  }, t2.importExpression = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "ImportExpression", source: e3, options: t3 });
  }, t2.importNamespaceSpecifier = function(e3) {
    return (0, n2.default)({ type: "ImportNamespaceSpecifier", local: e3 });
  }, t2.importSpecifier = function(e3, t3) {
    return (0, n2.default)({ type: "ImportSpecifier", local: e3, imported: t3 });
  }, t2.indexedAccessType = function(e3, t3) {
    return (0, n2.default)({ type: "IndexedAccessType", objectType: e3, indexType: t3 });
  }, t2.inferredPredicate = function() {
    return { type: "InferredPredicate" };
  }, t2.interfaceDeclaration = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "InterfaceDeclaration", id: e3, typeParameters: t3, extends: r3, body: s3 });
  }, t2.interfaceExtends = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "InterfaceExtends", id: e3, typeParameters: t3 });
  }, t2.interfaceTypeAnnotation = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0;
    return (0, n2.default)({ type: "InterfaceTypeAnnotation", extends: e3, body: t3 });
  }, t2.interpreterDirective = function(e3) {
    return (0, n2.default)({ type: "InterpreterDirective", value: e3 });
  }, t2.intersectionTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "IntersectionTypeAnnotation", types: e3 });
  }, t2.jSXAttribute = t2.jsxAttribute = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "JSXAttribute", name: e3, value: t3 });
  }, t2.jSXClosingElement = t2.jsxClosingElement = function(e3) {
    return (0, n2.default)({ type: "JSXClosingElement", name: e3 });
  }, t2.jSXClosingFragment = t2.jsxClosingFragment = function() {
    return { type: "JSXClosingFragment" };
  }, t2.jSXElement = t2.jsxElement = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "JSXElement", openingElement: e3, closingElement: t3, children: r3, selfClosing: s3 });
  }, t2.jSXEmptyExpression = t2.jsxEmptyExpression = function() {
    return { type: "JSXEmptyExpression" };
  }, t2.jSXExpressionContainer = t2.jsxExpressionContainer = function(e3) {
    return (0, n2.default)({ type: "JSXExpressionContainer", expression: e3 });
  }, t2.jSXFragment = t2.jsxFragment = function(e3, t3, r3) {
    return (0, n2.default)({ type: "JSXFragment", openingFragment: e3, closingFragment: t3, children: r3 });
  }, t2.jSXIdentifier = t2.jsxIdentifier = function(e3) {
    return (0, n2.default)({ type: "JSXIdentifier", name: e3 });
  }, t2.jSXMemberExpression = t2.jsxMemberExpression = function(e3, t3) {
    return (0, n2.default)({ type: "JSXMemberExpression", object: e3, property: t3 });
  }, t2.jSXNamespacedName = t2.jsxNamespacedName = function(e3, t3) {
    return (0, n2.default)({ type: "JSXNamespacedName", namespace: e3, name: t3 });
  }, t2.jSXOpeningElement = t2.jsxOpeningElement = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return (0, n2.default)({ type: "JSXOpeningElement", name: e3, attributes: t3, selfClosing: r3 });
  }, t2.jSXOpeningFragment = t2.jsxOpeningFragment = function() {
    return { type: "JSXOpeningFragment" };
  }, t2.jSXSpreadAttribute = t2.jsxSpreadAttribute = function(e3) {
    return (0, n2.default)({ type: "JSXSpreadAttribute", argument: e3 });
  }, t2.jSXSpreadChild = t2.jsxSpreadChild = function(e3) {
    return (0, n2.default)({ type: "JSXSpreadChild", expression: e3 });
  }, t2.jSXText = t2.jsxText = function(e3) {
    return (0, n2.default)({ type: "JSXText", value: e3 });
  }, t2.labeledStatement = function(e3, t3) {
    return (0, n2.default)({ type: "LabeledStatement", label: e3, body: t3 });
  }, t2.logicalExpression = function(e3, t3, r3) {
    return (0, n2.default)({ type: "LogicalExpression", operator: e3, left: t3, right: r3 });
  }, t2.memberExpression = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "MemberExpression", object: e3, property: t3, computed: r3, optional: s3 });
  }, t2.metaProperty = function(e3, t3) {
    return (0, n2.default)({ type: "MetaProperty", meta: e3, property: t3 });
  }, t2.mixedTypeAnnotation = function() {
    return { type: "MixedTypeAnnotation" };
  }, t2.moduleExpression = function(e3) {
    return (0, n2.default)({ type: "ModuleExpression", body: e3 });
  }, t2.newExpression = function(e3, t3) {
    return (0, n2.default)({ type: "NewExpression", callee: e3, arguments: t3 });
  }, t2.noop = function() {
    return { type: "Noop" };
  }, t2.nullLiteral = function() {
    return { type: "NullLiteral" };
  }, t2.nullLiteralTypeAnnotation = function() {
    return { type: "NullLiteralTypeAnnotation" };
  }, t2.nullableTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "NullableTypeAnnotation", typeAnnotation: e3 });
  }, t2.numberLiteral = function(e3) {
    return (0, s2.default)("NumberLiteral", "NumericLiteral", "The node type "), i2(e3);
  }, t2.numberLiteralTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "NumberLiteralTypeAnnotation", value: e3 });
  }, t2.numberTypeAnnotation = function() {
    return { type: "NumberTypeAnnotation" };
  }, t2.numericLiteral = i2, t2.objectExpression = function(e3) {
    return (0, n2.default)({ type: "ObjectExpression", properties: e3 });
  }, t2.objectMethod = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "method", t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 ? arguments[3] : void 0, i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o3 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5], a3 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
    return (0, n2.default)({ type: "ObjectMethod", kind: e3, key: t3, params: r3, body: s3, computed: i3, generator: o3, async: a3 });
  }, t2.objectPattern = function(e3) {
    return (0, n2.default)({ type: "ObjectPattern", properties: e3 });
  }, t2.objectProperty = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
    return (0, n2.default)({ type: "ObjectProperty", key: e3, value: t3, computed: r3, shorthand: s3, decorators: i3 });
  }, t2.objectTypeAnnotation = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], i3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    return (0, n2.default)({ type: "ObjectTypeAnnotation", properties: e3, indexers: t3, callProperties: r3, internalSlots: s3, exact: i3 });
  }, t2.objectTypeCallProperty = function(e3) {
    return (0, n2.default)({ type: "ObjectTypeCallProperty", value: e3, static: null });
  }, t2.objectTypeIndexer = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "ObjectTypeIndexer", id: e3, key: t3, value: r3, variance: s3, static: null });
  }, t2.objectTypeInternalSlot = function(e3, t3, r3, s3, i3) {
    return (0, n2.default)({ type: "ObjectTypeInternalSlot", id: e3, value: t3, optional: r3, static: s3, method: i3 });
  }, t2.objectTypeProperty = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "ObjectTypeProperty", key: e3, value: t3, variance: r3, kind: null, method: null, optional: null, proto: null, static: null });
  }, t2.objectTypeSpreadProperty = function(e3) {
    return (0, n2.default)({ type: "ObjectTypeSpreadProperty", argument: e3 });
  }, t2.opaqueType = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "OpaqueType", id: e3, typeParameters: t3, supertype: r3, impltype: s3 });
  }, t2.optionalCallExpression = function(e3, t3, r3) {
    return (0, n2.default)({ type: "OptionalCallExpression", callee: e3, arguments: t3, optional: r3 });
  }, t2.optionalIndexedAccessType = function(e3, t3) {
    return (0, n2.default)({ type: "OptionalIndexedAccessType", objectType: e3, indexType: t3, optional: null });
  }, t2.optionalMemberExpression = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "OptionalMemberExpression", object: e3, property: t3, computed: r3, optional: s3 });
  }, t2.parenthesizedExpression = function(e3) {
    return (0, n2.default)({ type: "ParenthesizedExpression", expression: e3 });
  }, t2.pipelineBareFunction = function(e3) {
    return (0, n2.default)({ type: "PipelineBareFunction", callee: e3 });
  }, t2.pipelinePrimaryTopicReference = function() {
    return { type: "PipelinePrimaryTopicReference" };
  }, t2.pipelineTopicExpression = function(e3) {
    return (0, n2.default)({ type: "PipelineTopicExpression", expression: e3 });
  }, t2.placeholder = function(e3, t3) {
    return (0, n2.default)({ type: "Placeholder", expectedNode: e3, name: t3 });
  }, t2.privateName = function(e3) {
    return (0, n2.default)({ type: "PrivateName", id: e3 });
  }, t2.program = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "script", s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "Program", body: e3, directives: t3, sourceType: r3, interpreter: s3, sourceFile: null });
  }, t2.qualifiedTypeIdentifier = function(e3, t3) {
    return (0, n2.default)({ type: "QualifiedTypeIdentifier", id: e3, qualification: t3 });
  }, t2.recordExpression = function(e3) {
    return (0, n2.default)({ type: "RecordExpression", properties: e3 });
  }, t2.regExpLiteral = o2, t2.regexLiteral = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    return (0, s2.default)("RegexLiteral", "RegExpLiteral", "The node type "), o2(e3, t3);
  }, t2.restElement = a2, t2.restProperty = function(e3) {
    return (0, s2.default)("RestProperty", "RestElement", "The node type "), a2(e3);
  }, t2.returnStatement = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
    return (0, n2.default)({ type: "ReturnStatement", argument: e3 });
  }, t2.sequenceExpression = function(e3) {
    return (0, n2.default)({ type: "SequenceExpression", expressions: e3 });
  }, t2.spreadElement = l, t2.spreadProperty = function(e3) {
    return (0, s2.default)("SpreadProperty", "SpreadElement", "The node type "), l(e3);
  }, t2.staticBlock = function(e3) {
    return (0, n2.default)({ type: "StaticBlock", body: e3 });
  }, t2.stringLiteral = function(e3) {
    return (0, n2.default)({ type: "StringLiteral", value: e3 });
  }, t2.stringLiteralTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "StringLiteralTypeAnnotation", value: e3 });
  }, t2.stringTypeAnnotation = function() {
    return { type: "StringTypeAnnotation" };
  }, t2.super = function() {
    return { type: "Super" };
  }, t2.switchCase = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0;
    return (0, n2.default)({ type: "SwitchCase", test: e3, consequent: t3 });
  }, t2.switchStatement = function(e3, t3) {
    return (0, n2.default)({ type: "SwitchStatement", discriminant: e3, cases: t3 });
  }, t2.symbolTypeAnnotation = function() {
    return { type: "SymbolTypeAnnotation" };
  }, t2.taggedTemplateExpression = function(e3, t3) {
    return (0, n2.default)({ type: "TaggedTemplateExpression", tag: e3, quasi: t3 });
  }, t2.templateElement = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return (0, n2.default)({ type: "TemplateElement", value: e3, tail: t3 });
  }, t2.templateLiteral = function(e3, t3) {
    return (0, n2.default)({ type: "TemplateLiteral", quasis: e3, expressions: t3 });
  }, t2.thisExpression = function() {
    return { type: "ThisExpression" };
  }, t2.thisTypeAnnotation = function() {
    return { type: "ThisTypeAnnotation" };
  }, t2.throwStatement = function(e3) {
    return (0, n2.default)({ type: "ThrowStatement", argument: e3 });
  }, t2.topicReference = function() {
    return { type: "TopicReference" };
  }, t2.tryStatement = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TryStatement", block: e3, handler: t3, finalizer: r3 });
  }, t2.tSAnyKeyword = t2.tsAnyKeyword = function() {
    return { type: "TSAnyKeyword" };
  }, t2.tSArrayType = t2.tsArrayType = function(e3) {
    return (0, n2.default)({ type: "TSArrayType", elementType: e3 });
  }, t2.tSAsExpression = t2.tsAsExpression = function(e3, t3) {
    return (0, n2.default)({ type: "TSAsExpression", expression: e3, typeAnnotation: t3 });
  }, t2.tSBigIntKeyword = t2.tsBigIntKeyword = function() {
    return { type: "TSBigIntKeyword" };
  }, t2.tSBooleanKeyword = t2.tsBooleanKeyword = function() {
    return { type: "TSBooleanKeyword" };
  }, t2.tSCallSignatureDeclaration = t2.tsCallSignatureDeclaration = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSCallSignatureDeclaration", typeParameters: e3, parameters: t3, typeAnnotation: r3 });
  }, t2.tSConditionalType = t2.tsConditionalType = function(e3, t3, r3, s3) {
    return (0, n2.default)({ type: "TSConditionalType", checkType: e3, extendsType: t3, trueType: r3, falseType: s3 });
  }, t2.tSConstructSignatureDeclaration = t2.tsConstructSignatureDeclaration = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSConstructSignatureDeclaration", typeParameters: e3, parameters: t3, typeAnnotation: r3 });
  }, t2.tSConstructorType = t2.tsConstructorType = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSConstructorType", typeParameters: e3, parameters: t3, typeAnnotation: r3 });
  }, t2.tSDeclareFunction = t2.tsDeclareFunction = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "TSDeclareFunction", id: e3, typeParameters: t3, params: r3, returnType: s3 });
  }, t2.tSDeclareMethod = t2.tsDeclareMethod = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0, i3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
    return (0, n2.default)({ type: "TSDeclareMethod", decorators: e3, key: t3, typeParameters: r3, params: s3, returnType: i3 });
  }, t2.tSEnumDeclaration = t2.tsEnumDeclaration = function(e3, t3) {
    return (0, n2.default)({ type: "TSEnumDeclaration", id: e3, members: t3 });
  }, t2.tSEnumMember = t2.tsEnumMember = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSEnumMember", id: e3, initializer: t3 });
  }, t2.tSExportAssignment = t2.tsExportAssignment = function(e3) {
    return (0, n2.default)({ type: "TSExportAssignment", expression: e3 });
  }, t2.tSExpressionWithTypeArguments = t2.tsExpressionWithTypeArguments = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSExpressionWithTypeArguments", expression: e3, typeParameters: t3 });
  }, t2.tSExternalModuleReference = t2.tsExternalModuleReference = function(e3) {
    return (0, n2.default)({ type: "TSExternalModuleReference", expression: e3 });
  }, t2.tSFunctionType = t2.tsFunctionType = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSFunctionType", typeParameters: e3, parameters: t3, typeAnnotation: r3 });
  }, t2.tSImportEqualsDeclaration = t2.tsImportEqualsDeclaration = function(e3, t3) {
    return (0, n2.default)({ type: "TSImportEqualsDeclaration", id: e3, moduleReference: t3, isExport: null });
  }, t2.tSImportType = t2.tsImportType = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSImportType", argument: e3, qualifier: t3, typeParameters: r3 });
  }, t2.tSIndexSignature = t2.tsIndexSignature = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSIndexSignature", parameters: e3, typeAnnotation: t3 });
  }, t2.tSIndexedAccessType = t2.tsIndexedAccessType = function(e3, t3) {
    return (0, n2.default)({ type: "TSIndexedAccessType", objectType: e3, indexType: t3 });
  }, t2.tSInferType = t2.tsInferType = function(e3) {
    return (0, n2.default)({ type: "TSInferType", typeParameter: e3 });
  }, t2.tSInstantiationExpression = t2.tsInstantiationExpression = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSInstantiationExpression", expression: e3, typeParameters: t3 });
  }, t2.tSInterfaceBody = t2.tsInterfaceBody = function(e3) {
    return (0, n2.default)({ type: "TSInterfaceBody", body: e3 });
  }, t2.tSInterfaceDeclaration = t2.tsInterfaceDeclaration = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s3 = arguments.length > 3 ? arguments[3] : void 0;
    return (0, n2.default)({ type: "TSInterfaceDeclaration", id: e3, typeParameters: t3, extends: r3, body: s3 });
  }, t2.tSIntersectionType = t2.tsIntersectionType = function(e3) {
    return (0, n2.default)({ type: "TSIntersectionType", types: e3 });
  }, t2.tSIntrinsicKeyword = t2.tsIntrinsicKeyword = function() {
    return { type: "TSIntrinsicKeyword" };
  }, t2.tSLiteralType = t2.tsLiteralType = function(e3) {
    return (0, n2.default)({ type: "TSLiteralType", literal: e3 });
  }, t2.tSMappedType = t2.tsMappedType = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSMappedType", typeParameter: e3, typeAnnotation: t3, nameType: r3 });
  }, t2.tSMethodSignature = t2.tsMethodSignature = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    return (0, n2.default)({ type: "TSMethodSignature", key: e3, typeParameters: t3, parameters: r3, typeAnnotation: s3, kind: null });
  }, t2.tSModuleBlock = t2.tsModuleBlock = function(e3) {
    return (0, n2.default)({ type: "TSModuleBlock", body: e3 });
  }, t2.tSModuleDeclaration = t2.tsModuleDeclaration = function(e3, t3) {
    return (0, n2.default)({ type: "TSModuleDeclaration", id: e3, body: t3 });
  }, t2.tSNamedTupleMember = t2.tsNamedTupleMember = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return (0, n2.default)({ type: "TSNamedTupleMember", label: e3, elementType: t3, optional: r3 });
  }, t2.tSNamespaceExportDeclaration = t2.tsNamespaceExportDeclaration = function(e3) {
    return (0, n2.default)({ type: "TSNamespaceExportDeclaration", id: e3 });
  }, t2.tSNeverKeyword = t2.tsNeverKeyword = function() {
    return { type: "TSNeverKeyword" };
  }, t2.tSNonNullExpression = t2.tsNonNullExpression = function(e3) {
    return (0, n2.default)({ type: "TSNonNullExpression", expression: e3 });
  }, t2.tSNullKeyword = t2.tsNullKeyword = function() {
    return { type: "TSNullKeyword" };
  }, t2.tSNumberKeyword = t2.tsNumberKeyword = function() {
    return { type: "TSNumberKeyword" };
  }, t2.tSObjectKeyword = t2.tsObjectKeyword = function() {
    return { type: "TSObjectKeyword" };
  }, t2.tSOptionalType = t2.tsOptionalType = function(e3) {
    return (0, n2.default)({ type: "TSOptionalType", typeAnnotation: e3 });
  }, t2.tSParameterProperty = t2.tsParameterProperty = function(e3) {
    return (0, n2.default)({ type: "TSParameterProperty", parameter: e3 });
  }, t2.tSParenthesizedType = t2.tsParenthesizedType = function(e3) {
    return (0, n2.default)({ type: "TSParenthesizedType", typeAnnotation: e3 });
  }, t2.tSPropertySignature = t2.tsPropertySignature = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSPropertySignature", key: e3, typeAnnotation: t3, kind: null });
  }, t2.tSQualifiedName = t2.tsQualifiedName = function(e3, t3) {
    return (0, n2.default)({ type: "TSQualifiedName", left: e3, right: t3 });
  }, t2.tSRestType = t2.tsRestType = function(e3) {
    return (0, n2.default)({ type: "TSRestType", typeAnnotation: e3 });
  }, t2.tSSatisfiesExpression = t2.tsSatisfiesExpression = function(e3, t3) {
    return (0, n2.default)({ type: "TSSatisfiesExpression", expression: e3, typeAnnotation: t3 });
  }, t2.tSStringKeyword = t2.tsStringKeyword = function() {
    return { type: "TSStringKeyword" };
  }, t2.tSSymbolKeyword = t2.tsSymbolKeyword = function() {
    return { type: "TSSymbolKeyword" };
  }, t2.tSThisType = t2.tsThisType = function() {
    return { type: "TSThisType" };
  }, t2.tSTupleType = t2.tsTupleType = function(e3) {
    return (0, n2.default)({ type: "TSTupleType", elementTypes: e3 });
  }, t2.tSTypeAliasDeclaration = t2.tsTypeAliasDeclaration = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0;
    return (0, n2.default)({ type: "TSTypeAliasDeclaration", id: e3, typeParameters: t3, typeAnnotation: r3 });
  }, t2.tSTypeAnnotation = t2.tsTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "TSTypeAnnotation", typeAnnotation: e3 });
  }, t2.tSTypeAssertion = t2.tsTypeAssertion = function(e3, t3) {
    return (0, n2.default)({ type: "TSTypeAssertion", typeAnnotation: e3, expression: t3 });
  }, t2.tSTypeLiteral = t2.tsTypeLiteral = function(e3) {
    return (0, n2.default)({ type: "TSTypeLiteral", members: e3 });
  }, t2.tSTypeOperator = t2.tsTypeOperator = function(e3) {
    return (0, n2.default)({ type: "TSTypeOperator", typeAnnotation: e3, operator: null });
  }, t2.tSTypeParameter = t2.tsTypeParameter = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0;
    return (0, n2.default)({ type: "TSTypeParameter", constraint: e3, default: t3, name: r3 });
  }, t2.tSTypeParameterDeclaration = t2.tsTypeParameterDeclaration = function(e3) {
    return (0, n2.default)({ type: "TSTypeParameterDeclaration", params: e3 });
  }, t2.tSTypeParameterInstantiation = t2.tsTypeParameterInstantiation = function(e3) {
    return (0, n2.default)({ type: "TSTypeParameterInstantiation", params: e3 });
  }, t2.tSTypePredicate = t2.tsTypePredicate = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TSTypePredicate", parameterName: e3, typeAnnotation: t3, asserts: r3 });
  }, t2.tSTypeQuery = t2.tsTypeQuery = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSTypeQuery", exprName: e3, typeParameters: t3 });
  }, t2.tSTypeReference = t2.tsTypeReference = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "TSTypeReference", typeName: e3, typeParameters: t3 });
  }, t2.tSUndefinedKeyword = t2.tsUndefinedKeyword = function() {
    return { type: "TSUndefinedKeyword" };
  }, t2.tSUnionType = t2.tsUnionType = function(e3) {
    return (0, n2.default)({ type: "TSUnionType", types: e3 });
  }, t2.tSUnknownKeyword = t2.tsUnknownKeyword = function() {
    return { type: "TSUnknownKeyword" };
  }, t2.tSVoidKeyword = t2.tsVoidKeyword = function() {
    return { type: "TSVoidKeyword" };
  }, t2.tupleExpression = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return (0, n2.default)({ type: "TupleExpression", elements: e3 });
  }, t2.tupleTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "TupleTypeAnnotation", types: e3 });
  }, t2.typeAlias = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 ? arguments[2] : void 0;
    return (0, n2.default)({ type: "TypeAlias", id: e3, typeParameters: t3, right: r3 });
  }, t2.typeAnnotation = function(e3) {
    return (0, n2.default)({ type: "TypeAnnotation", typeAnnotation: e3 });
  }, t2.typeCastExpression = function(e3, t3) {
    return (0, n2.default)({ type: "TypeCastExpression", expression: e3, typeAnnotation: t3 });
  }, t2.typeParameter = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return (0, n2.default)({ type: "TypeParameter", bound: e3, default: t3, variance: r3, name: null });
  }, t2.typeParameterDeclaration = function(e3) {
    return (0, n2.default)({ type: "TypeParameterDeclaration", params: e3 });
  }, t2.typeParameterInstantiation = function(e3) {
    return (0, n2.default)({ type: "TypeParameterInstantiation", params: e3 });
  }, t2.typeofTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "TypeofTypeAnnotation", argument: e3 });
  }, t2.unaryExpression = function(e3, t3) {
    let r3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    return (0, n2.default)({ type: "UnaryExpression", operator: e3, argument: t3, prefix: r3 });
  }, t2.unionTypeAnnotation = function(e3) {
    return (0, n2.default)({ type: "UnionTypeAnnotation", types: e3 });
  }, t2.updateExpression = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return (0, n2.default)({ type: "UpdateExpression", operator: e3, argument: t3, prefix: r3 });
  }, t2.v8IntrinsicIdentifier = function(e3) {
    return (0, n2.default)({ type: "V8IntrinsicIdentifier", name: e3 });
  }, t2.variableDeclaration = function(e3, t3) {
    return (0, n2.default)({ type: "VariableDeclaration", kind: e3, declarations: t3 });
  }, t2.variableDeclarator = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return (0, n2.default)({ type: "VariableDeclarator", id: e3, init: t3 });
  }, t2.variance = function(e3) {
    return (0, n2.default)({ type: "Variance", kind: e3 });
  }, t2.voidTypeAnnotation = function() {
    return { type: "VoidTypeAnnotation" };
  }, t2.whileStatement = function(e3, t3) {
    return (0, n2.default)({ type: "WhileStatement", test: e3, body: t3 });
  }, t2.withStatement = function(e3, t3) {
    return (0, n2.default)({ type: "WithStatement", object: e3, body: t3 });
  }, t2.yieldExpression = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return (0, n2.default)({ type: "YieldExpression", argument: e3, delegate: t3 });
  };
  var n2 = r2(352), s2 = r2(58);
  function i2(e3) {
    return (0, n2.default)({ type: "NumericLiteral", value: e3 });
  }
  function o2(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    return (0, n2.default)({ type: "RegExpLiteral", pattern: e3, flags: t3 });
  }
  function a2(e3) {
    return (0, n2.default)({ type: "RestElement", argument: e3 });
  }
  function l(e3) {
    return (0, n2.default)({ type: "SpreadElement", argument: e3 });
  }
}, function(e2, t2, r2) {
  var n2 = function(e3) {
    return e3 && e3.Math === Math && e3;
  };
  e2.exports = n2("object" == typeof globalThis && globalThis) || n2("object" == typeof window && window) || n2("object" == typeof self && self) || n2("object" == typeof r2.g && r2.g) || n2("object" == typeof this && this) || /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")();
}, (e2) => {
  var t2 = "object" == typeof document && document.all;
  e2.exports = void 0 === t2 && void 0 !== t2 ? function(e3) {
    return "function" == typeof e3 || e3 === t2;
  } : function(e3) {
    return "function" == typeof e3;
  };
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = (e3, t3, r3) => new n2(e3, r3).compare(new n2(t3, r3));
}, (e2, t2, r2) => {
  class n2 {
    constructor(e3, t3) {
      if (t3 = i2(t3), e3 instanceof n2) return e3.loose === !!t3.loose && e3.includePrerelease === !!t3.includePrerelease ? e3 : new n2(e3.raw, t3);
      if (e3 instanceof o2) return this.raw = e3.value, this.set = [[e3]], this.format(), this;
      if (this.options = t3, this.loose = !!t3.loose, this.includePrerelease = !!t3.includePrerelease, this.raw = e3.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((e4) => this.parseRange(e4.trim())).filter((e4) => e4.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const e4 = this.set[0];
        if (this.set = this.set.filter((e5) => !y(e5[0])), 0 === this.set.length) this.set = [e4];
        else if (this.set.length > 1) {
          for (const e5 of this.set) if (1 === e5.length && g(e5[0])) {
            this.set = [e5];
            break;
          }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((e3) => e3.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(e3) {
      const t3 = ((this.options.includePrerelease && h) | (this.options.loose && m)) + ":" + e3, r3 = s2.get(t3);
      if (r3) return r3;
      const n3 = this.options.loose, i3 = n3 ? c[u.HYPHENRANGELOOSE] : c[u.HYPHENRANGE];
      e3 = e3.replace(i3, I(this.options.includePrerelease)), a2("hyphen replace", e3), e3 = e3.replace(c[u.COMPARATORTRIM], p), a2("comparator trim", e3), e3 = e3.replace(c[u.TILDETRIM], d), a2("tilde trim", e3), e3 = e3.replace(c[u.CARETTRIM], f), a2("caret trim", e3);
      let l2 = e3.split(" ").map((e4) => v(e4, this.options)).join(" ").split(/\s+/).map((e4) => O(e4, this.options));
      n3 && (l2 = l2.filter((e4) => (a2("loose invalid filter", e4, this.options), !!e4.match(c[u.COMPARATORLOOSE])))), a2("range list", l2);
      const g2 = /* @__PURE__ */ new Map(), b2 = l2.map((e4) => new o2(e4, this.options));
      for (const e4 of b2) {
        if (y(e4)) return [e4];
        g2.set(e4.value, e4);
      }
      g2.size > 1 && g2.has("") && g2.delete("");
      const E2 = [...g2.values()];
      return s2.set(t3, E2), E2;
    }
    intersects(e3, t3) {
      if (!(e3 instanceof n2)) throw new TypeError("a Range is required");
      return this.set.some((r3) => b(r3, t3) && e3.set.some((e4) => b(e4, t3) && r3.every((r4) => e4.every((e5) => r4.intersects(e5, t3)))));
    }
    test(e3) {
      if (!e3) return false;
      if ("string" == typeof e3) try {
        e3 = new l(e3, this.options);
      } catch (e4) {
        return false;
      }
      for (let t3 = 0; t3 < this.set.length; t3++) if (_(this.set[t3], e3, this.options)) return true;
      return false;
    }
  }
  e2.exports = n2;
  const s2 = new (r2(132))({ max: 1e3 }), i2 = r2(75), o2 = r2(50), a2 = r2(48), l = r2(3), { safeRe: c, t: u, comparatorTrimReplace: p, tildeTrimReplace: d, caretTrimReplace: f } = r2(34), { FLAG_INCLUDE_PRERELEASE: h, FLAG_LOOSE: m } = r2(47), y = (e3) => "<0.0.0-0" === e3.value, g = (e3) => "" === e3.value, b = (e3, t3) => {
    let r3 = true;
    const n3 = e3.slice();
    let s3 = n3.pop();
    for (; r3 && n3.length; ) r3 = n3.every((e4) => s3.intersects(e4, t3)), s3 = n3.pop();
    return r3;
  }, v = (e3, t3) => (a2("comp", e3, t3), e3 = T(e3, t3), a2("caret", e3), e3 = S(e3, t3), a2("tildes", e3), e3 = P(e3, t3), a2("xrange", e3), e3 = C(e3, t3), a2("stars", e3), e3), E = (e3) => !e3 || "x" === e3.toLowerCase() || "*" === e3, S = (e3, t3) => e3.trim().split(/\s+/).map((e4) => x(e4, t3)).join(" "), x = (e3, t3) => {
    const r3 = t3.loose ? c[u.TILDELOOSE] : c[u.TILDE];
    return e3.replace(r3, (t4, r4, n3, s3, i3) => {
      let o3;
      return a2("tilde", e3, t4, r4, n3, s3, i3), E(r4) ? o3 = "" : E(n3) ? o3 = `>=${r4}.0.0 <${+r4 + 1}.0.0-0` : E(s3) ? o3 = `>=${r4}.${n3}.0 <${r4}.${+n3 + 1}.0-0` : i3 ? (a2("replaceTilde pr", i3), o3 = `>=${r4}.${n3}.${s3}-${i3} <${r4}.${+n3 + 1}.0-0`) : o3 = `>=${r4}.${n3}.${s3} <${r4}.${+n3 + 1}.0-0`, a2("tilde return", o3), o3;
    });
  }, T = (e3, t3) => e3.trim().split(/\s+/).map((e4) => w(e4, t3)).join(" "), w = (e3, t3) => {
    a2("caret", e3, t3);
    const r3 = t3.loose ? c[u.CARETLOOSE] : c[u.CARET], n3 = t3.includePrerelease ? "-0" : "";
    return e3.replace(r3, (t4, r4, s3, i3, o3) => {
      let l2;
      return a2("caret", e3, t4, r4, s3, i3, o3), E(r4) ? l2 = "" : E(s3) ? l2 = `>=${r4}.0.0${n3} <${+r4 + 1}.0.0-0` : E(i3) ? l2 = "0" === r4 ? `>=${r4}.${s3}.0${n3} <${r4}.${+s3 + 1}.0-0` : `>=${r4}.${s3}.0${n3} <${+r4 + 1}.0.0-0` : o3 ? (a2("replaceCaret pr", o3), l2 = "0" === r4 ? "0" === s3 ? `>=${r4}.${s3}.${i3}-${o3} <${r4}.${s3}.${+i3 + 1}-0` : `>=${r4}.${s3}.${i3}-${o3} <${r4}.${+s3 + 1}.0-0` : `>=${r4}.${s3}.${i3}-${o3} <${+r4 + 1}.0.0-0`) : (a2("no pr"), l2 = "0" === r4 ? "0" === s3 ? `>=${r4}.${s3}.${i3}${n3} <${r4}.${s3}.${+i3 + 1}-0` : `>=${r4}.${s3}.${i3}${n3} <${r4}.${+s3 + 1}.0-0` : `>=${r4}.${s3}.${i3} <${+r4 + 1}.0.0-0`), a2("caret return", l2), l2;
    });
  }, P = (e3, t3) => (a2("replaceXRanges", e3, t3), e3.split(/\s+/).map((e4) => A(e4, t3)).join(" ")), A = (e3, t3) => {
    e3 = e3.trim();
    const r3 = t3.loose ? c[u.XRANGELOOSE] : c[u.XRANGE];
    return e3.replace(r3, (r4, n3, s3, i3, o3, l2) => {
      a2("xRange", e3, r4, n3, s3, i3, o3, l2);
      const c2 = E(s3), u2 = c2 || E(i3), p2 = u2 || E(o3), d2 = p2;
      return "=" === n3 && d2 && (n3 = ""), l2 = t3.includePrerelease ? "-0" : "", c2 ? r4 = ">" === n3 || "<" === n3 ? "<0.0.0-0" : "*" : n3 && d2 ? (u2 && (i3 = 0), o3 = 0, ">" === n3 ? (n3 = ">=", u2 ? (s3 = +s3 + 1, i3 = 0, o3 = 0) : (i3 = +i3 + 1, o3 = 0)) : "<=" === n3 && (n3 = "<", u2 ? s3 = +s3 + 1 : i3 = +i3 + 1), "<" === n3 && (l2 = "-0"), r4 = `${n3 + s3}.${i3}.${o3}${l2}`) : u2 ? r4 = `>=${s3}.0.0${l2} <${+s3 + 1}.0.0-0` : p2 && (r4 = `>=${s3}.${i3}.0${l2} <${s3}.${+i3 + 1}.0-0`), a2("xRange return", r4), r4;
    });
  }, C = (e3, t3) => (a2("replaceStars", e3, t3), e3.trim().replace(c[u.STAR], "")), O = (e3, t3) => (a2("replaceGTE0", e3, t3), e3.trim().replace(c[t3.includePrerelease ? u.GTE0PRE : u.GTE0], "")), I = (e3) => (t3, r3, n3, s3, i3, o3, a3, l2, c2, u2, p2, d2, f2) => `${r3 = E(n3) ? "" : E(s3) ? `>=${n3}.0.0${e3 ? "-0" : ""}` : E(i3) ? `>=${n3}.${s3}.0${e3 ? "-0" : ""}` : o3 ? `>=${r3}` : `>=${r3}${e3 ? "-0" : ""}`} ${l2 = E(c2) ? "" : E(u2) ? `<${+c2 + 1}.0.0-0` : E(p2) ? `<${c2}.${+u2 + 1}.0-0` : d2 ? `<=${c2}.${u2}.${p2}-${d2}` : e3 ? `<${c2}.${u2}.${+p2 + 1}-0` : `<=${l2}`}`.trim(), _ = (e3, t3, r3) => {
    for (let r4 = 0; r4 < e3.length; r4++) if (!e3[r4].test(t3)) return false;
    if (t3.prerelease.length && !r3.includePrerelease) {
      for (let r4 = 0; r4 < e3.length; r4++) if (a2(e3[r4].semver), e3[r4].semver !== o2.ANY && e3[r4].semver.prerelease.length > 0) {
        const n3 = e3[r4].semver;
        if (n3.major === t3.major && n3.minor === t3.minor && n3.patch === t3.patch) return true;
      }
      return false;
    }
    return true;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "ALIAS_KEYS", { enumerable: true, get: function() {
    return s2.ALIAS_KEYS;
  } }), Object.defineProperty(t2, "BUILDER_KEYS", { enumerable: true, get: function() {
    return s2.BUILDER_KEYS;
  } }), Object.defineProperty(t2, "DEPRECATED_ALIASES", { enumerable: true, get: function() {
    return o2.DEPRECATED_ALIASES;
  } }), Object.defineProperty(t2, "DEPRECATED_KEYS", { enumerable: true, get: function() {
    return s2.DEPRECATED_KEYS;
  } }), Object.defineProperty(t2, "FLIPPED_ALIAS_KEYS", { enumerable: true, get: function() {
    return s2.FLIPPED_ALIAS_KEYS;
  } }), Object.defineProperty(t2, "NODE_FIELDS", { enumerable: true, get: function() {
    return s2.NODE_FIELDS;
  } }), Object.defineProperty(t2, "NODE_PARENT_VALIDATIONS", { enumerable: true, get: function() {
    return s2.NODE_PARENT_VALIDATIONS;
  } }), Object.defineProperty(t2, "PLACEHOLDERS", { enumerable: true, get: function() {
    return i2.PLACEHOLDERS;
  } }), Object.defineProperty(t2, "PLACEHOLDERS_ALIAS", { enumerable: true, get: function() {
    return i2.PLACEHOLDERS_ALIAS;
  } }), Object.defineProperty(t2, "PLACEHOLDERS_FLIPPED_ALIAS", { enumerable: true, get: function() {
    return i2.PLACEHOLDERS_FLIPPED_ALIAS;
  } }), t2.TYPES = void 0, Object.defineProperty(t2, "VISITOR_KEYS", { enumerable: true, get: function() {
    return s2.VISITOR_KEYS;
  } });
  var n2 = r2(166);
  r2(167), r2(356), r2(357), r2(358), r2(359), r2(360);
  var s2 = r2(18), i2 = r2(169), o2 = r2(361);
  Object.keys(o2.DEPRECATED_ALIASES).forEach((e3) => {
    s2.FLIPPED_ALIAS_KEYS[e3] = s2.FLIPPED_ALIAS_KEYS[o2.DEPRECATED_ALIASES[e3]];
  }), n2(s2.VISITOR_KEYS), n2(s2.ALIAS_KEYS), n2(s2.FLIPPED_ALIAS_KEYS), n2(s2.NODE_FIELDS), n2(s2.BUILDER_KEYS), n2(s2.DEPRECATED_KEYS), n2(i2.PLACEHOLDERS_ALIAS), n2(i2.PLACEHOLDERS_FLIPPED_ALIAS), t2.TYPES = [].concat(Object.keys(s2.VISITOR_KEYS), Object.keys(s2.FLIPPED_ALIAS_KEYS), Object.keys(s2.DEPRECATED_KEYS));
}, (e2, t2, r2) => {
  var n2 = r2(17);
  function s2(e3) {
    if ("string" != typeof e3) throw new TypeError("Path must be a string. Received " + JSON.stringify(e3));
  }
  function i2(e3, t3) {
    for (var r3, n3 = "", s3 = 0, i3 = -1, o3 = 0, a2 = 0; a2 <= e3.length; ++a2) {
      if (a2 < e3.length) r3 = e3.charCodeAt(a2);
      else {
        if (47 === r3) break;
        r3 = 47;
      }
      if (47 === r3) {
        if (i3 === a2 - 1 || 1 === o3) ;
        else if (i3 !== a2 - 1 && 2 === o3) {
          if (n3.length < 2 || 2 !== s3 || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
            if (n3.length > 2) {
              var l = n3.lastIndexOf("/");
              if (l !== n3.length - 1) {
                -1 === l ? (n3 = "", s3 = 0) : s3 = (n3 = n3.slice(0, l)).length - 1 - n3.lastIndexOf("/"), i3 = a2, o3 = 0;
                continue;
              }
            } else if (2 === n3.length || 1 === n3.length) {
              n3 = "", s3 = 0, i3 = a2, o3 = 0;
              continue;
            }
          }
          t3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", s3 = 2);
        } else n3.length > 0 ? n3 += "/" + e3.slice(i3 + 1, a2) : n3 = e3.slice(i3 + 1, a2), s3 = a2 - i3 - 1;
        i3 = a2, o3 = 0;
      } else 46 === r3 && -1 !== o3 ? ++o3 : o3 = -1;
    }
    return n3;
  }
  var o2 = { resolve: function() {
    for (var e3, t3 = "", r3 = false, o3 = arguments.length - 1; o3 >= -1 && !r3; o3--) {
      var a2;
      o3 >= 0 ? a2 = arguments[o3] : (void 0 === e3 && (e3 = n2.cwd()), a2 = e3), s2(a2), 0 !== a2.length && (t3 = a2 + "/" + t3, r3 = 47 === a2.charCodeAt(0));
    }
    return t3 = i2(t3, !r3), r3 ? t3.length > 0 ? "/" + t3 : "/" : t3.length > 0 ? t3 : ".";
  }, normalize: function(e3) {
    if (s2(e3), 0 === e3.length) return ".";
    var t3 = 47 === e3.charCodeAt(0), r3 = 47 === e3.charCodeAt(e3.length - 1);
    return 0 !== (e3 = i2(e3, !t3)).length || t3 || (e3 = "."), e3.length > 0 && r3 && (e3 += "/"), t3 ? "/" + e3 : e3;
  }, isAbsolute: function(e3) {
    return s2(e3), e3.length > 0 && 47 === e3.charCodeAt(0);
  }, join: function() {
    if (0 === arguments.length) return ".";
    for (var e3, t3 = 0; t3 < arguments.length; ++t3) {
      var r3 = arguments[t3];
      s2(r3), r3.length > 0 && (void 0 === e3 ? e3 = r3 : e3 += "/" + r3);
    }
    return void 0 === e3 ? "." : o2.normalize(e3);
  }, relative: function(e3, t3) {
    if (s2(e3), s2(t3), e3 === t3) return "";
    if ((e3 = o2.resolve(e3)) === (t3 = o2.resolve(t3))) return "";
    for (var r3 = 1; r3 < e3.length && 47 === e3.charCodeAt(r3); ++r3) ;
    for (var n3 = e3.length, i3 = n3 - r3, a2 = 1; a2 < t3.length && 47 === t3.charCodeAt(a2); ++a2) ;
    for (var l = t3.length - a2, c = i3 < l ? i3 : l, u = -1, p = 0; p <= c; ++p) {
      if (p === c) {
        if (l > c) {
          if (47 === t3.charCodeAt(a2 + p)) return t3.slice(a2 + p + 1);
          if (0 === p) return t3.slice(a2 + p);
        } else i3 > c && (47 === e3.charCodeAt(r3 + p) ? u = p : 0 === p && (u = 0));
        break;
      }
      var d = e3.charCodeAt(r3 + p);
      if (d !== t3.charCodeAt(a2 + p)) break;
      47 === d && (u = p);
    }
    var f = "";
    for (p = r3 + u + 1; p <= n3; ++p) p !== n3 && 47 !== e3.charCodeAt(p) || (0 === f.length ? f += ".." : f += "/..");
    return f.length > 0 ? f + t3.slice(a2 + u) : (a2 += u, 47 === t3.charCodeAt(a2) && ++a2, t3.slice(a2));
  }, _makeLong: function(e3) {
    return e3;
  }, dirname: function(e3) {
    if (s2(e3), 0 === e3.length) return ".";
    for (var t3 = e3.charCodeAt(0), r3 = 47 === t3, n3 = -1, i3 = true, o3 = e3.length - 1; o3 >= 1; --o3) if (47 === (t3 = e3.charCodeAt(o3))) {
      if (!i3) {
        n3 = o3;
        break;
      }
    } else i3 = false;
    return -1 === n3 ? r3 ? "/" : "." : r3 && 1 === n3 ? "//" : e3.slice(0, n3);
  }, basename: function(e3, t3) {
    if (void 0 !== t3 && "string" != typeof t3) throw new TypeError('"ext" argument must be a string');
    s2(e3);
    var r3, n3 = 0, i3 = -1, o3 = true;
    if (void 0 !== t3 && t3.length > 0 && t3.length <= e3.length) {
      if (t3.length === e3.length && t3 === e3) return "";
      var a2 = t3.length - 1, l = -1;
      for (r3 = e3.length - 1; r3 >= 0; --r3) {
        var c = e3.charCodeAt(r3);
        if (47 === c) {
          if (!o3) {
            n3 = r3 + 1;
            break;
          }
        } else -1 === l && (o3 = false, l = r3 + 1), a2 >= 0 && (c === t3.charCodeAt(a2) ? -1 == --a2 && (i3 = r3) : (a2 = -1, i3 = l));
      }
      return n3 === i3 ? i3 = l : -1 === i3 && (i3 = e3.length), e3.slice(n3, i3);
    }
    for (r3 = e3.length - 1; r3 >= 0; --r3) if (47 === e3.charCodeAt(r3)) {
      if (!o3) {
        n3 = r3 + 1;
        break;
      }
    } else -1 === i3 && (o3 = false, i3 = r3 + 1);
    return -1 === i3 ? "" : e3.slice(n3, i3);
  }, extname: function(e3) {
    s2(e3);
    for (var t3 = -1, r3 = 0, n3 = -1, i3 = true, o3 = 0, a2 = e3.length - 1; a2 >= 0; --a2) {
      var l = e3.charCodeAt(a2);
      if (47 !== l) -1 === n3 && (i3 = false, n3 = a2 + 1), 46 === l ? -1 === t3 ? t3 = a2 : 1 !== o3 && (o3 = 1) : -1 !== t3 && (o3 = -1);
      else if (!i3) {
        r3 = a2 + 1;
        break;
      }
    }
    return -1 === t3 || -1 === n3 || 0 === o3 || 1 === o3 && t3 === n3 - 1 && t3 === r3 + 1 ? "" : e3.slice(t3, n3);
  }, format: function(e3) {
    if (null === e3 || "object" != typeof e3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e3);
    return function(e4, t3) {
      var r3 = t3.dir || t3.root, n3 = t3.base || (t3.name || "") + (t3.ext || "");
      return r3 ? r3 === t3.root ? r3 + n3 : r3 + "/" + n3 : n3;
    }(0, e3);
  }, parse: function(e3) {
    s2(e3);
    var t3 = { root: "", dir: "", base: "", ext: "", name: "" };
    if (0 === e3.length) return t3;
    var r3, n3 = e3.charCodeAt(0), i3 = 47 === n3;
    i3 ? (t3.root = "/", r3 = 1) : r3 = 0;
    for (var o3 = -1, a2 = 0, l = -1, c = true, u = e3.length - 1, p = 0; u >= r3; --u) if (47 !== (n3 = e3.charCodeAt(u))) -1 === l && (c = false, l = u + 1), 46 === n3 ? -1 === o3 ? o3 = u : 1 !== p && (p = 1) : -1 !== o3 && (p = -1);
    else if (!c) {
      a2 = u + 1;
      break;
    }
    return -1 === o3 || -1 === l || 0 === p || 1 === p && o3 === l - 1 && o3 === a2 + 1 ? -1 !== l && (t3.base = t3.name = 0 === a2 && i3 ? e3.slice(1, l) : e3.slice(a2, l)) : (0 === a2 && i3 ? (t3.name = e3.slice(1, o3), t3.base = e3.slice(1, l)) : (t3.name = e3.slice(a2, o3), t3.base = e3.slice(a2, l)), t3.ext = e3.slice(o3, l)), a2 > 0 ? t3.dir = e3.slice(0, a2 - 1) : i3 && (t3.dir = "/"), t3;
  }, sep: "/", delimiter: ":", win32: null, posix: null };
  o2.posix = o2, e2.exports = o2;
}, (e2) => {
  e2.exports = function(e3) {
    try {
      return !!e3();
    } catch (e4) {
      return true;
    }
  };
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(66), i2 = r2(206), o2 = r2(218), a2 = r2(221), l = r2(63), c = r2(11), u = n2.RangeError, p = n2.Int8Array, d = p && p.prototype, f = d && d.set, h = i2.aTypedArray, m = i2.exportTypedArrayMethod, y = !c(function() {
    var e3 = new Uint8ClampedArray(2);
    return s2(f, e3, { length: 1, 0: 3 }, 1), 3 !== e3[1];
  }), g = y && i2.NATIVE_ARRAY_BUFFER_VIEWS && c(function() {
    var e3 = new p(2);
    return e3.set(1), e3.set("2", 1), 0 !== e3[0] || 2 !== e3[1];
  });
  m("set", function(e3) {
    h(this);
    var t3 = a2(arguments.length > 1 ? arguments[1] : void 0, 1), r3 = l(e3);
    if (y) return s2(f, this, r3, t3);
    var n3 = this.length, i3 = o2(r3), c2 = 0;
    if (i3 + t3 > n3) throw new u("Wrong length");
    for (; c2 < i3; ) this[t3 + c2] = r3[c2++];
  }, !y || g);
}, (e2) => {
  const t2 = Symbol.for("gensync:v1:start"), r2 = Symbol.for("gensync:v1:suspend"), n2 = "GENSYNC_EXPECTED_START", s2 = "GENSYNC_EXPECTED_SUSPEND", i2 = "GENSYNC_OPTIONS_ERROR", o2 = "GENSYNC_RACE_NONEMPTY";
  function a2(e3, t3, r3, n3) {
    if (typeof r3 === e3 || n3 && void 0 === r3) return;
    let s3;
    throw s3 = n3 ? `Expected opts.${t3} to be either a ${e3}, or undefined.` : `Expected opts.${t3} to be a ${e3}.`, l(s3, i2);
  }
  function l(e3, t3) {
    return Object.assign(new Error(e3), { code: t3 });
  }
  function c(e3) {
    let { name: n3, arity: s3, sync: i3, async: o3 } = e3;
    return m(n3, s3, function* () {
      const e4 = yield t2;
      for (var n4 = arguments.length, s4 = new Array(n4), a3 = 0; a3 < n4; a3++) s4[a3] = arguments[a3];
      if (!e4) return i3.call(this, s4);
      let l2;
      try {
        o3.call(this, s4, (t3) => {
          l2 || (l2 = { value: t3 }, e4());
        }, (t3) => {
          l2 || (l2 = { err: t3 }, e4());
        });
      } catch (t3) {
        l2 = { err: t3 }, e4();
      }
      if (yield r2, l2.hasOwnProperty("err")) throw l2.err;
      return l2.value;
    });
  }
  function u(e3) {
    let t3;
    for (; !({ value: t3 } = e3.next()).done; ) d(t3, e3);
    return t3;
  }
  function p(e3, t3, r3) {
    !function n3() {
      try {
        let r4;
        for (; !({ value: r4 } = e3.next()).done; ) {
          d(r4, e3);
          let t4 = true, s3 = false;
          const i3 = e3.next(() => {
            t4 ? s3 = true : n3();
          });
          if (t4 = false, f(i3, e3), !s3) return;
        }
        return t3(r4);
      } catch (e4) {
        return r3(e4);
      }
    }();
  }
  function d(e3, r3) {
    e3 !== t2 && h(r3, l(`Got unexpected yielded value in gensync generator: ${JSON.stringify(e3)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`, n2));
  }
  function f(e3, t3) {
    let { value: n3, done: i3 } = e3;
    (i3 || n3 !== r2) && h(t3, l(i3 ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(n3)}. If you get this, it is probably a gensync bug.`, s2));
  }
  function h(e3, t3) {
    throw e3.throw && e3.throw(t3), t3;
  }
  function m(e3, t3, r3) {
    if ("string" == typeof e3) {
      const t4 = Object.getOwnPropertyDescriptor(r3, "name");
      t4 && !t4.configurable || Object.defineProperty(r3, "name", Object.assign(t4 || {}, { configurable: true, value: e3 }));
    }
    if ("number" == typeof t3) {
      const e4 = Object.getOwnPropertyDescriptor(r3, "length");
      e4 && !e4.configurable || Object.defineProperty(r3, "length", Object.assign(e4 || {}, { configurable: true, value: t3 }));
    }
    return r3;
  }
  e2.exports = Object.assign(function(e3) {
    let t3 = e3;
    return t3 = "function" != typeof e3 ? function(e4) {
      let { name: t4, arity: r3, sync: n3, async: s3, errback: o3 } = e4;
      if (a2("string", "name", t4, true), a2("number", "arity", r3, true), a2("function", "sync", n3), a2("function", "async", s3, true), a2("function", "errback", o3, true), s3 && o3) throw l("Expected one of either opts.async or opts.errback, but got _both_.", i2);
      if ("string" != typeof t4) {
        let e5;
        o3 && o3.name && "errback" !== o3.name && (e5 = o3.name), s3 && s3.name && "async" !== s3.name && (e5 = s3.name.replace(/Async$/, "")), n3 && n3.name && "sync" !== n3.name && (e5 = n3.name.replace(/Sync$/, "")), "string" == typeof e5 && (t4 = e5);
      }
      return "number" != typeof r3 && (r3 = n3.length), c({ name: t4, arity: r3, sync: function(e5) {
        return n3.apply(this, e5);
      }, async: function(e5, t5, r4) {
        s3 ? s3.apply(this, e5).then(t5, r4) : o3 ? o3.call(this, ...e5, (e6, n4) => {
          null == e6 ? t5(n4) : r4(e6);
        }) : t5(n3.apply(this, e5));
      } });
    }(e3) : function(e4) {
      return m(e4.name, e4.length, function() {
        for (var t4 = arguments.length, r3 = new Array(t4), n3 = 0; n3 < t4; n3++) r3[n3] = arguments[n3];
        return e4.apply(this, r3);
      });
    }(e3), Object.assign(t3, /* @__PURE__ */ function(e4) {
      const t4 = { sync: function() {
        for (var t5 = arguments.length, r3 = new Array(t5), n3 = 0; n3 < t5; n3++) r3[n3] = arguments[n3];
        return u(e4.apply(this, r3));
      }, async: function() {
        for (var t5 = arguments.length, r3 = new Array(t5), n3 = 0; n3 < t5; n3++) r3[n3] = arguments[n3];
        return new Promise((t6, n4) => {
          p(e4.apply(this, r3), t6, n4);
        });
      }, errback: function() {
        for (var t5 = arguments.length, r3 = new Array(t5), n3 = 0; n3 < t5; n3++) r3[n3] = arguments[n3];
        const s3 = r3.pop();
        if ("function" != typeof s3) throw l("Asynchronous function called without callback", "GENSYNC_ERRBACK_NO_CALLBACK");
        let i3;
        try {
          i3 = e4.apply(this, r3);
        } catch (e5) {
          return void s3(e5);
        }
        p(i3, (e5) => s3(void 0, e5), (e5) => s3(e5));
      } };
      return t4;
    }(t3));
  }, { all: c({ name: "all", arity: 1, sync: function(e3) {
    return Array.from(e3[0]).map((e4) => u(e4));
  }, async: function(e3, t3, r3) {
    const n3 = Array.from(e3[0]);
    if (0 === n3.length) return void Promise.resolve().then(() => t3([]));
    let s3 = 0;
    const i3 = n3.map(() => {
    });
    n3.forEach((e4, n4) => {
      p(e4, (e5) => {
        i3[n4] = e5, s3 += 1, s3 === i3.length && t3(i3);
      }, r3);
    });
  } }), race: c({ name: "race", arity: 1, sync: function(e3) {
    const t3 = Array.from(e3[0]);
    if (0 === t3.length) throw l("Must race at least 1 item", o2);
    return u(t3[0]);
  }, async: function(e3, t3, r3) {
    const n3 = Array.from(e3[0]);
    if (0 === n3.length) throw l("Must race at least 1 item", o2);
    for (const e4 of n3) p(e4, t3, r3);
  } }) });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "Hub", { enumerable: true, get: function() {
    return c.default;
  } }), Object.defineProperty(t2, "NodePath", { enumerable: true, get: function() {
    return a2.default;
  } }), Object.defineProperty(t2, "Scope", { enumerable: true, get: function() {
    return l.default;
  } }), t2.visitors = t2.default = void 0;
  var n2 = r2(57);
  t2.visitors = n2;
  var s2 = r2(0), i2 = r2(35), o2 = r2(100), a2 = r2(28), l = r2(183), c = r2(444);
  const { VISITOR_KEYS: u, removeProperties: p, traverseFast: d } = s2;
  function f(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = arguments.length > 2 ? arguments[2] : void 0, s3 = arguments.length > 3 ? arguments[3] : void 0, i3 = arguments.length > 4 ? arguments[4] : void 0, a3 = arguments.length > 5 ? arguments[5] : void 0;
    if (e3) {
      if (!t3.noScope && !r3 && "Program" !== e3.type && "File" !== e3.type) throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e3.type} node without passing scope and parentPath.`);
      if (!i3 && a3) throw new Error("visitSelf can only be used when providing a NodePath.");
      u[e3.type] && (n2.explode(t3), (0, o2.traverseNode)(e3, t3, r3, s3, i3, null, a3));
    }
  }
  function h(e3, t3) {
    e3.node.type === t3.type && (t3.has = true, e3.stop());
  }
  t2.default = f, f.visitors = n2, f.verify = n2.verify, f.explode = n2.explode, f.cheap = function(e3, t3) {
    d(e3, t3);
  }, f.node = function(e3, t3, r3, n3, s3, i3) {
    (0, o2.traverseNode)(e3, t3, r3, n3, s3, i3);
  }, f.clearNode = function(e3, t3) {
    p(e3, t3);
  }, f.removeProperties = function(e3, t3) {
    return d(e3, f.clearNode, t3), e3;
  }, f.hasType = function(e3, t3, r3) {
    if (null != r3 && r3.includes(e3.type)) return false;
    if (e3.type === t3) return true;
    const n3 = { has: false, type: t3 };
    return f(e3, { noScope: true, denylist: r3, enter: h }, null, n3), n3.has;
  }, f.cache = i2;
}, (e2, t2, r2) => {
  var n2 = r2(11);
  e2.exports = !n2(function() {
    return 7 !== Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1];
  });
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.declare = n2, t2.declarePreset = void 0;
  const r2 = { assertVersion: (e3) => (t3) => {
    !function(e4, t4) {
      if ("number" == typeof e4) {
        if (!Number.isInteger(e4)) throw new Error("Expected string or integer value.");
        e4 = `^${e4}.0.0-0`;
      }
      if ("string" != typeof e4) throw new Error("Expected string or integer value.");
      const r3 = Error.stackTraceLimit;
      let n3;
      throw "number" == typeof r3 && r3 < 25 && (Error.stackTraceLimit = 25), n3 = "7." === t4.slice(0, 2) ? new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${t4}". You'll need to update your @babel/core version.`) : new Error(`Requires Babel "${e4}", but was loaded with "${t4}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), "number" == typeof r3 && (Error.stackTraceLimit = r3), Object.assign(n3, { code: "BABEL_VERSION_UNSUPPORTED", version: t4, range: e4 });
    }(t3, e3.version);
  } };
  function n2(e3) {
    return (t3, n3, s3) => {
      var o3;
      let a2;
      for (const e4 of Object.keys(r2)) t3[e4] || (null != a2 || (a2 = i2(t3)), a2[e4] = r2[e4](a2));
      return e3(null != (o3 = a2) ? o3 : t3, n3 || {}, s3);
    };
  }
  Object.assign(r2, { targets: () => () => ({}), assumption: () => () => {
  } });
  const s2 = n2;
  function i2(e3) {
    let t3 = null;
    return "string" == typeof e3.version && /^7\./.test(e3.version) && (t3 = Object.getPrototypeOf(e3), !t3 || o2(t3, "version") && o2(t3, "transform") && o2(t3, "template") && o2(t3, "types") || (t3 = null)), Object.assign({}, t3, e3);
  }
  function o2(e3, t3) {
    return Object.prototype.hasOwnProperty.call(e3, t3);
  }
  t2.declarePreset = s2;
}, (e2) => {
  var t2, r2, n2 = e2.exports = {};
  function s2() {
    throw new Error("setTimeout has not been defined");
  }
  function i2() {
    throw new Error("clearTimeout has not been defined");
  }
  function o2(e3) {
    if (t2 === setTimeout) return setTimeout(e3, 0);
    if ((t2 === s2 || !t2) && setTimeout) return t2 = setTimeout, setTimeout(e3, 0);
    try {
      return t2(e3, 0);
    } catch (r3) {
      try {
        return t2.call(null, e3, 0);
      } catch (r4) {
        return t2.call(this, e3, 0);
      }
    }
  }
  !function() {
    try {
      t2 = "function" == typeof setTimeout ? setTimeout : s2;
    } catch (e3) {
      t2 = s2;
    }
    try {
      r2 = "function" == typeof clearTimeout ? clearTimeout : i2;
    } catch (e3) {
      r2 = i2;
    }
  }();
  var a2, l = [], c = false, u = -1;
  function p() {
    c && a2 && (c = false, a2.length ? l = a2.concat(l) : u = -1, l.length && d());
  }
  function d() {
    if (!c) {
      var e3 = o2(p);
      c = true;
      for (var t3 = l.length; t3; ) {
        for (a2 = l, l = []; ++u < t3; ) a2 && a2[u].run();
        u = -1, t3 = l.length;
      }
      a2 = null, c = false, function(e4) {
        if (r2 === clearTimeout) return clearTimeout(e4);
        if ((r2 === i2 || !r2) && clearTimeout) return r2 = clearTimeout, clearTimeout(e4);
        try {
          return r2(e4);
        } catch (t4) {
          try {
            return r2.call(null, e4);
          } catch (t5) {
            return r2.call(this, e4);
          }
        }
      }(e3);
    }
  }
  function f(e3, t3) {
    this.fun = e3, this.array = t3;
  }
  function h() {
  }
  n2.nextTick = function(e3) {
    var t3 = new Array(arguments.length - 1);
    if (arguments.length > 1) for (var r3 = 1; r3 < arguments.length; r3++) t3[r3 - 1] = arguments[r3];
    l.push(new f(e3, t3)), 1 !== l.length || c || o2(d);
  }, f.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, n2.title = "browser", n2.browser = true, n2.env = {}, n2.argv = [], n2.version = "", n2.versions = {}, n2.on = h, n2.addListener = h, n2.once = h, n2.off = h, n2.removeListener = h, n2.removeAllListeners = h, n2.emit = h, n2.prependListener = h, n2.prependOnceListener = h, n2.listeners = function(e3) {
    return [];
  }, n2.binding = function(e3) {
    throw new Error("process.binding is not supported");
  }, n2.cwd = function() {
    return "/";
  }, n2.chdir = function(e3) {
    throw new Error("process.chdir is not supported");
  }, n2.umask = function() {
    return 0;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.VISITOR_KEYS = t2.NODE_PARENT_VALIDATIONS = t2.NODE_FIELDS = t2.FLIPPED_ALIAS_KEYS = t2.DEPRECATED_KEYS = t2.BUILDER_KEYS = t2.ALIAS_KEYS = void 0, t2.arrayOf = m, t2.arrayOfType = y, t2.assertEach = g, t2.assertNodeOrValueType = function() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    function i3(e4, r4, i4) {
      for (const o3 of t3) if (d(i4) === o3 || (0, n2.default)(o3, i4)) return void (0, s2.validateChild)(e4, r4, i4);
      throw new TypeError(`Property ${r4} of ${e4.type} expected node to be of a type ${JSON.stringify(t3)} but instead got ${JSON.stringify(null == i4 ? void 0 : i4.type)}`);
    }
    return i3.oneOfNodeOrValueTypes = t3, i3;
  }, t2.assertNodeType = b, t2.assertOneOf = function() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    function n3(e4, r4, n4) {
      if (t3.indexOf(n4) < 0) throw new TypeError(`Property ${r4} expected value to be one of ${JSON.stringify(t3)} but got ${JSON.stringify(n4)}`);
    }
    return n3.oneOf = t3, n3;
  }, t2.assertOptionalChainStart = function() {
    return function(e3) {
      var t3;
      let r3 = e3;
      for (; e3; ) {
        const { type: e4 } = r3;
        if ("OptionalCallExpression" !== e4) {
          if ("OptionalMemberExpression" !== e4) break;
          if (r3.optional) return;
          r3 = r3.object;
        } else {
          if (r3.optional) return;
          r3 = r3.callee;
        }
      }
      throw new TypeError(`Non-optional ${e3.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null == (t3 = r3) ? void 0 : t3.type}`);
    };
  }, t2.assertShape = function(e3) {
    function t3(t4, r3, n3) {
      const i3 = [];
      for (const r4 of Object.keys(e3)) try {
        (0, s2.validateField)(t4, r4, n3[r4], e3[r4]);
      } catch (e4) {
        if (e4 instanceof TypeError) {
          i3.push(e4.message);
          continue;
        }
        throw e4;
      }
      if (i3.length) throw new TypeError(`Property ${r3} of ${t4.type} expected to have the following:
${i3.join("\n")}`);
    }
    return t3.shapeOf = e3, t3;
  }, t2.assertValueType = v, t2.chain = E, t2.default = w, t2.defineAliasedType = function() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    return function(e4) {
      let r4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n3 = r4.aliases;
      var s3;
      n3 || (r4.inherits && (n3 = null == (s3 = T[r4.inherits].aliases) ? void 0 : s3.slice()), null != n3 || (n3 = []), r4.aliases = n3);
      const i3 = t3.filter((e5) => !n3.includes(e5));
      n3.unshift(...i3), w(e4, r4);
    };
  }, t2.typeIs = h, t2.validate = f, t2.validateArrayOfType = function(e3) {
    return f(y(e3));
  }, t2.validateOptional = function(e3) {
    return { validate: e3, optional: true };
  }, t2.validateOptionalType = function(e3) {
    return { validate: h(e3), optional: true };
  }, t2.validateType = function(e3) {
    return f(h(e3));
  };
  var n2 = r2(42), s2 = r2(97);
  const i2 = t2.VISITOR_KEYS = {}, o2 = t2.ALIAS_KEYS = {}, a2 = t2.FLIPPED_ALIAS_KEYS = {}, l = t2.NODE_FIELDS = {}, c = t2.BUILDER_KEYS = {}, u = t2.DEPRECATED_KEYS = {}, p = t2.NODE_PARENT_VALIDATIONS = {};
  function d(e3) {
    return Array.isArray(e3) ? "array" : null === e3 ? "null" : typeof e3;
  }
  function f(e3) {
    return { validate: e3 };
  }
  function h(e3) {
    return "string" == typeof e3 ? b(e3) : b(...e3);
  }
  function m(e3) {
    return E(v("array"), g(e3));
  }
  function y(e3) {
    return m(h(e3));
  }
  function g(e3) {
    function t3(t4, r3, n3) {
      if (Array.isArray(n3)) for (let s3 = 0; s3 < n3.length; s3++) {
        const i3 = `${r3}[${s3}]`, o3 = n3[s3];
        e3(t4, i3, o3);
      }
    }
    return t3.each = e3, t3;
  }
  function b() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    function i3(e4, r4, i4) {
      for (const o3 of t3) if ((0, n2.default)(o3, i4)) return void (0, s2.validateChild)(e4, r4, i4);
      throw new TypeError(`Property ${r4} of ${e4.type} expected node to be of a type ${JSON.stringify(t3)} but instead got ${JSON.stringify(null == i4 ? void 0 : i4.type)}`);
    }
    return i3.oneOfNodeTypes = t3, i3;
  }
  function v(e3) {
    function t3(t4, r3, n3) {
      if (d(n3) !== e3) throw new TypeError(`Property ${r3} expected type of ${e3} but got ${d(n3)}`);
    }
    return t3.type = e3, t3;
  }
  function E() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    function n3() {
      for (const e4 of t3) e4(...arguments);
    }
    if (n3.chainOf = t3, t3.length >= 2 && "type" in t3[0] && "array" === t3[0].type && !("each" in t3[1])) throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return n3;
  }
  const S = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], x = ["default", "optional", "deprecated", "validate"], T = {};
  function w(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const r3 = t3.inherits && T[t3.inherits] || {};
    let n3 = t3.fields;
    if (!n3 && (n3 = {}, r3.fields)) {
      const e4 = Object.getOwnPropertyNames(r3.fields);
      for (const t4 of e4) {
        const e5 = r3.fields[t4], s4 = e5.default;
        if (Array.isArray(s4) ? s4.length > 0 : s4 && "object" == typeof s4) throw new Error("field defaults can only be primitives or empty arrays currently");
        n3[t4] = { default: Array.isArray(s4) ? [] : s4, optional: e5.optional, deprecated: e5.deprecated, validate: e5.validate };
      }
    }
    const s3 = t3.visitor || r3.visitor || [], f2 = t3.aliases || r3.aliases || [], h2 = t3.builder || r3.builder || t3.visitor || [];
    for (const r4 of Object.keys(t3)) if (-1 === S.indexOf(r4)) throw new Error(`Unknown type option "${r4}" on ${e3}`);
    t3.deprecatedAlias && (u[t3.deprecatedAlias] = e3);
    for (const e4 of s3.concat(h2)) n3[e4] = n3[e4] || {};
    for (const t4 of Object.keys(n3)) {
      const r4 = n3[t4];
      void 0 !== r4.default && -1 === h2.indexOf(t4) && (r4.optional = true), void 0 === r4.default ? r4.default = null : r4.validate || null == r4.default || (r4.validate = v(d(r4.default)));
      for (const n4 of Object.keys(r4)) if (-1 === x.indexOf(n4)) throw new Error(`Unknown field key "${n4}" on ${e3}.${t4}`);
    }
    i2[e3] = t3.visitor = s3, c[e3] = t3.builder = h2, l[e3] = t3.fields = n3, o2[e3] = t3.aliases = f2, f2.forEach((t4) => {
      a2[t4] = a2[t4] || [], a2[t4].push(e3);
    }), t3.validate && (p[e3] = t3.validate), T[e3] = t3;
  }
}, (e2, t2, r2) => {
  var n2 = r2(104), s2 = Function.prototype, i2 = s2.call, o2 = n2 && s2.bind.bind(i2, i2);
  e2.exports = n2 ? o2 : function(e3) {
    return function() {
      return i2.apply(e3, arguments);
    };
  };
}, (e2, t2, r2) => {
  var n2 = r2(6);
  e2.exports = function(e3) {
    return "object" == typeof e3 ? null !== e3 : n2(e3);
  };
}, (e2, t2, r2) => {
  function n2(e3, t3) {
    if (null == e3) return {};
    var r3, n3, s3 = {}, i3 = Object.keys(e3);
    for (n3 = 0; n3 < i3.length; n3++) r3 = i3[n3], t3.indexOf(r3) >= 0 || (s3[r3] = e3[r3]);
    return s3;
  }
  r2(44), Object.defineProperty(t2, "__esModule", { value: true });
  class s2 {
    constructor(e3, t3, r3) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = e3, this.column = t3, this.index = r3;
    }
  }
  class i2 {
    constructor(e3, t3) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e3, this.end = t3;
    }
  }
  function o2(e3, t3) {
    const { line: r3, column: n3, index: i3 } = e3;
    return new s2(r3, n3 + t3, i3 + t3);
  }
  const a2 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
  var l = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: a2 }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: a2 } };
  const c = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, u = (e3) => {
    let { type: t3, prefix: r3 } = e3;
    return "UpdateExpression" === t3 ? c.UpdateExpression[String(r3)] : c[t3];
  };
  var p = { AccessorIsGenerator: (e3) => {
    let { kind: t3 } = e3;
    return `A ${t3}ter cannot be a generator.`;
  }, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: (e3) => {
    let { kind: t3 } = e3;
    return `Missing initializer in ${t3} declaration.`;
  }, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: (e3) => {
    let { exportName: t3 } = e3;
    return `\`${t3}\` has already been exported. Exported identifiers must be unique.`;
  }, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: (e3) => {
    let { phase: t3 } = e3;
    return `'import.${t3}(...)' can only be parsed when using the 'createImportExpressions' option.`;
  }, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: (e3) => {
    let { localName: t3, exportName: r3 } = e3;
    return `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${t3}' as '${r3}' } from 'some-module'\`?`;
  }, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: (e3) => {
    let { type: t3 } = e3;
    return `'${"ForInStatement" === t3 ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`;
  }, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: (e3) => {
    let { type: t3 } = e3;
    return `Unsyntactic ${"BreakStatement" === t3 ? "break" : "continue"}.`;
  }, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: (e3) => {
    let { importName: t3 } = e3;
    return `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${t3}" as foo }\`?`;
  }, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: (e3) => {
    let { maxArgumentCount: t3 } = e3;
    return `\`import()\` requires exactly ${1 === t3 ? "one argument" : "one or two arguments"}.`;
  }, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: (e3) => {
    let { radix: t3 } = e3;
    return `Expected number in radix ${t3}.`;
  }, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: (e3) => {
    let { reservedWord: t3 } = e3;
    return `Escape sequence in keyword ${t3}.`;
  }, InvalidIdentifier: (e3) => {
    let { identifierName: t3 } = e3;
    return `Invalid identifier ${t3}.`;
  }, InvalidLhs: (e3) => {
    let { ancestor: t3 } = e3;
    return `Invalid left-hand side in ${u(t3)}.`;
  }, InvalidLhsBinding: (e3) => {
    let { ancestor: t3 } = e3;
    return `Binding invalid left-hand side in ${u(t3)}.`;
  }, InvalidLhsOptionalChaining: (e3) => {
    let { ancestor: t3 } = e3;
    return `Invalid optional chaining in the left-hand side of ${u(t3)}.`;
  }, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: (e3) => {
    let { unexpected: t3 } = e3;
    return `Unexpected character '${t3}'.`;
  }, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: (e3) => {
    let { identifierName: t3 } = e3;
    return `Private name #${t3} is not defined.`;
  }, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: (e3) => {
    let { labelName: t3 } = e3;
    return `Label '${t3}' is already declared.`;
  }, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: (e3) => {
    let { missingPlugin: t3 } = e3;
    return `This experimental syntax requires enabling the parser plugin: ${t3.map((e4) => JSON.stringify(e4)).join(", ")}.`;
  }, MissingOneOfPlugins: (e3) => {
    let { missingPlugin: t3 } = e3;
    return `This experimental syntax requires enabling one of the following parser plugin(s): ${t3.map((e4) => JSON.stringify(e4)).join(", ")}.`;
  }, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: (e3) => {
    let { key: t3 } = e3;
    return `Duplicate key "${t3}" is not allowed in module attributes.`;
  }, ModuleExportNameHasLoneSurrogate: (e3) => {
    let { surrogateCharCode: t3 } = e3;
    return `An export name cannot include a lone surrogate, found '\\u${t3.toString(16)}'.`;
  }, ModuleExportUndefined: (e3) => {
    let { localName: t3 } = e3;
    return `Export '${t3}' is not defined.`;
  }, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: (e3) => {
    let { identifierName: t3 } = e3;
    return `Private names are only allowed in property accesses (\`obj.#${t3}\`) or in \`in\` expressions (\`#${t3} in obj\`).`;
  }, PrivateNameRedeclaration: (e3) => {
    let { identifierName: t3 } = e3;
    return `Duplicate private name #${t3}.`;
  }, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: (e3) => {
    let { keyword: t3 } = e3;
    return `Unexpected keyword '${t3}'.`;
  }, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: (e3) => {
    let { reservedWord: t3 } = e3;
    return `Unexpected reserved word '${t3}'.`;
  }, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: (e3) => {
    let { expected: t3, unexpected: r3 } = e3;
    return `Unexpected token${r3 ? ` '${r3}'.` : ""}${t3 ? `, expected "${t3}"` : ""}`;
  }, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: (e3) => {
    let { target: t3, onlyValidPropertyName: r3 } = e3;
    return `The only valid meta property for ${t3} is ${t3}.${r3}.`;
  }, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: (e3) => {
    let { identifierName: t3 } = e3;
    return `Identifier '${t3}' has already been declared.`;
  }, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." };
  const d = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var f = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: (e3) => {
    let { token: t3 } = e3;
    return `Invalid topic token ${t3}. In order to use ${t3} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${t3}" }.`;
  }, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: (e3) => {
    let { type: t3 } = e3;
    return `Hack-style pipe body cannot be an unparenthesized ${u({ type: t3 })}; please wrap it in parentheses.`;
  }, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' };
  const h = ["toMessage"], m = ["message"];
  function y(e3, t3, r3) {
    Object.defineProperty(e3, t3, { enumerable: false, configurable: true, value: r3 });
  }
  function g(e3) {
    let { toMessage: t3 } = e3, r3 = n2(e3, h);
    return function e4(n3, i3) {
      const o3 = new SyntaxError();
      return Object.assign(o3, r3, { loc: n3, pos: n3.index }), "missingPlugin" in i3 && Object.assign(o3, { missingPlugin: i3.missingPlugin }), y(o3, "clone", function() {
        let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        var r4;
        const { line: o4, column: a3, index: l2 } = null != (r4 = t4.loc) ? r4 : n3;
        return e4(new s2(o4, a3, l2), Object.assign({}, i3, t4.details));
      }), y(o3, "details", i3), Object.defineProperty(o3, "message", { configurable: true, get() {
        const e5 = `${t3(i3)} (${n3.line}:${n3.column})`;
        return this.message = e5, e5;
      }, set(e5) {
        Object.defineProperty(this, "message", { value: e5, writable: true });
      } }), o3;
    };
  }
  function b(e3, t3) {
    if (Array.isArray(e3)) return (t4) => b(t4, e3[0]);
    const r3 = {};
    for (const s3 of Object.keys(e3)) {
      const i3 = e3[s3], o3 = "string" == typeof i3 ? { message: () => i3 } : "function" == typeof i3 ? { message: i3 } : i3, { message: a3 } = o3, l2 = n2(o3, m), c2 = "string" == typeof a3 ? () => a3 : a3;
      r3[s3] = g(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: s3, toMessage: c2 }, t3 ? { syntaxPlugin: t3 } : {}, l2));
    }
    return r3;
  }
  const v = Object.assign({}, b(l), b(p), b({ StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: (e3) => {
    let { referenceName: t3 } = e3;
    return `Assigning to '${t3}' in strict mode.`;
  }, StrictEvalArgumentsBinding: (e3) => {
    let { bindingName: t3 } = e3;
    return `Binding '${t3}' in strict mode.`;
  }, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }), b`pipelineOperator`(f)), { defineProperty: E } = Object, S = (e3, t3) => E(e3, t3, { enumerable: false, value: e3[t3] });
  function x(e3) {
    return e3.loc.start && S(e3.loc.start, "index"), e3.loc.end && S(e3.loc.end, "index"), e3;
  }
  class T {
    constructor(e3, t3) {
      this.token = void 0, this.preserveSpace = void 0, this.token = e3, this.preserveSpace = !!t3;
    }
  }
  const w = { brace: new T("{"), j_oTag: new T("<tag"), j_cTag: new T("</tag"), j_expr: new T("<tag>...</tag>", true) };
  w.template = new T("`", true);
  const P = true, A = true, C = true, O = true, I = true;
  class _ {
    constructor(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e3, this.keyword = t3.keyword, this.beforeExpr = !!t3.beforeExpr, this.startsExpr = !!t3.startsExpr, this.rightAssociative = !!t3.rightAssociative, this.isLoop = !!t3.isLoop, this.isAssign = !!t3.isAssign, this.prefix = !!t3.prefix, this.postfix = !!t3.postfix, this.binop = null != t3.binop ? t3.binop : null, this.updateContext = null;
    }
  }
  const k = /* @__PURE__ */ new Map();
  function N(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    t3.keyword = e3;
    const r3 = $(e3, t3);
    return k.set(e3, r3), r3;
  }
  function D(e3, t3) {
    return $(e3, { beforeExpr: P, binop: t3 });
  }
  let j = -1;
  const L = [], M = [], B = [], R = [], F = [], U = [];
  function $(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var r3, n3, s3, i3;
    return ++j, M.push(e3), B.push(null != (r3 = t3.binop) ? r3 : -1), R.push(null != (n3 = t3.beforeExpr) && n3), F.push(null != (s3 = t3.startsExpr) && s3), U.push(null != (i3 = t3.prefix) && i3), L.push(new _(e3, t3)), j;
  }
  function V(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var r3, n3, s3, i3;
    return ++j, k.set(e3, j), M.push(e3), B.push(null != (r3 = t3.binop) ? r3 : -1), R.push(null != (n3 = t3.beforeExpr) && n3), F.push(null != (s3 = t3.startsExpr) && s3), U.push(null != (i3 = t3.prefix) && i3), L.push(new _("name", t3)), j;
  }
  const q = { bracketL: $("[", { beforeExpr: P, startsExpr: A }), bracketHashL: $("#[", { beforeExpr: P, startsExpr: A }), bracketBarL: $("[|", { beforeExpr: P, startsExpr: A }), bracketR: $("]"), bracketBarR: $("|]"), braceL: $("{", { beforeExpr: P, startsExpr: A }), braceBarL: $("{|", { beforeExpr: P, startsExpr: A }), braceHashL: $("#{", { beforeExpr: P, startsExpr: A }), braceR: $("}"), braceBarR: $("|}"), parenL: $("(", { beforeExpr: P, startsExpr: A }), parenR: $(")"), comma: $(",", { beforeExpr: P }), semi: $(";", { beforeExpr: P }), colon: $(":", { beforeExpr: P }), doubleColon: $("::", { beforeExpr: P }), dot: $("."), question: $("?", { beforeExpr: P }), questionDot: $("?."), arrow: $("=>", { beforeExpr: P }), template: $("template"), ellipsis: $("...", { beforeExpr: P }), backQuote: $("`", { startsExpr: A }), dollarBraceL: $("${", { beforeExpr: P, startsExpr: A }), templateTail: $("...`", { startsExpr: A }), templateNonTail: $("...${", { beforeExpr: P, startsExpr: A }), at: $("@"), hash: $("#", { startsExpr: A }), interpreterDirective: $("#!..."), eq: $("=", { beforeExpr: P, isAssign: O }), assign: $("_=", { beforeExpr: P, isAssign: O }), slashAssign: $("_=", { beforeExpr: P, isAssign: O }), xorAssign: $("_=", { beforeExpr: P, isAssign: O }), moduloAssign: $("_=", { beforeExpr: P, isAssign: O }), incDec: $("++/--", { prefix: I, postfix: true, startsExpr: A }), bang: $("!", { beforeExpr: P, prefix: I, startsExpr: A }), tilde: $("~", { beforeExpr: P, prefix: I, startsExpr: A }), doubleCaret: $("^^", { startsExpr: A }), doubleAt: $("@@", { startsExpr: A }), pipeline: D("|>", 0), nullishCoalescing: D("??", 1), logicalOR: D("||", 1), logicalAND: D("&&", 2), bitwiseOR: D("|", 3), bitwiseXOR: D("^", 4), bitwiseAND: D("&", 5), equality: D("==/!=/===/!==", 6), lt: D("</>/<=/>=", 7), gt: D("</>/<=/>=", 7), relational: D("</>/<=/>=", 7), bitShift: D("<</>>/>>>", 8), bitShiftL: D("<</>>/>>>", 8), bitShiftR: D("<</>>/>>>", 8), plusMin: $("+/-", { beforeExpr: P, binop: 9, prefix: I, startsExpr: A }), modulo: $("%", { binop: 10, startsExpr: A }), star: $("*", { binop: 10 }), slash: D("/", 10), exponent: $("**", { beforeExpr: P, binop: 11, rightAssociative: true }), _in: N("in", { beforeExpr: P, binop: 7 }), _instanceof: N("instanceof", { beforeExpr: P, binop: 7 }), _break: N("break"), _case: N("case", { beforeExpr: P }), _catch: N("catch"), _continue: N("continue"), _debugger: N("debugger"), _default: N("default", { beforeExpr: P }), _else: N("else", { beforeExpr: P }), _finally: N("finally"), _function: N("function", { startsExpr: A }), _if: N("if"), _return: N("return", { beforeExpr: P }), _switch: N("switch"), _throw: N("throw", { beforeExpr: P, prefix: I, startsExpr: A }), _try: N("try"), _var: N("var"), _const: N("const"), _with: N("with"), _new: N("new", { beforeExpr: P, startsExpr: A }), _this: N("this", { startsExpr: A }), _super: N("super", { startsExpr: A }), _class: N("class", { startsExpr: A }), _extends: N("extends", { beforeExpr: P }), _export: N("export"), _import: N("import", { startsExpr: A }), _null: N("null", { startsExpr: A }), _true: N("true", { startsExpr: A }), _false: N("false", { startsExpr: A }), _typeof: N("typeof", { beforeExpr: P, prefix: I, startsExpr: A }), _void: N("void", { beforeExpr: P, prefix: I, startsExpr: A }), _delete: N("delete", { beforeExpr: P, prefix: I, startsExpr: A }), _do: N("do", { isLoop: C, beforeExpr: P }), _for: N("for", { isLoop: C }), _while: N("while", { isLoop: C }), _as: V("as", { startsExpr: A }), _assert: V("assert", { startsExpr: A }), _async: V("async", { startsExpr: A }), _await: V("await", { startsExpr: A }), _defer: V("defer", { startsExpr: A }), _from: V("from", { startsExpr: A }), _get: V("get", { startsExpr: A }), _let: V("let", { startsExpr: A }), _meta: V("meta", { startsExpr: A }), _of: V("of", { startsExpr: A }), _sent: V("sent", { startsExpr: A }), _set: V("set", { startsExpr: A }), _source: V("source", { startsExpr: A }), _static: V("static", { startsExpr: A }), _using: V("using", { startsExpr: A }), _yield: V("yield", { startsExpr: A }), _asserts: V("asserts", { startsExpr: A }), _checks: V("checks", { startsExpr: A }), _exports: V("exports", { startsExpr: A }), _global: V("global", { startsExpr: A }), _implements: V("implements", { startsExpr: A }), _intrinsic: V("intrinsic", { startsExpr: A }), _infer: V("infer", { startsExpr: A }), _is: V("is", { startsExpr: A }), _mixins: V("mixins", { startsExpr: A }), _proto: V("proto", { startsExpr: A }), _require: V("require", { startsExpr: A }), _satisfies: V("satisfies", { startsExpr: A }), _keyof: V("keyof", { startsExpr: A }), _readonly: V("readonly", { startsExpr: A }), _unique: V("unique", { startsExpr: A }), _abstract: V("abstract", { startsExpr: A }), _declare: V("declare", { startsExpr: A }), _enum: V("enum", { startsExpr: A }), _module: V("module", { startsExpr: A }), _namespace: V("namespace", { startsExpr: A }), _interface: V("interface", { startsExpr: A }), _type: V("type", { startsExpr: A }), _opaque: V("opaque", { startsExpr: A }), name: $("name", { startsExpr: A }), string: $("string", { startsExpr: A }), num: $("num", { startsExpr: A }), bigint: $("bigint", { startsExpr: A }), decimal: $("decimal", { startsExpr: A }), regexp: $("regexp", { startsExpr: A }), privateName: $("#name", { startsExpr: A }), eof: $("eof"), jsxName: $("jsxName"), jsxText: $("jsxText", { beforeExpr: true }), jsxTagStart: $("jsxTagStart", { startsExpr: true }), jsxTagEnd: $("jsxTagEnd"), placeholder: $("%%", { startsExpr: true }) };
  function W(e3) {
    return e3 >= 93 && e3 <= 132;
  }
  function G(e3) {
    return e3 >= 58 && e3 <= 132;
  }
  function H(e3) {
    return e3 >= 58 && e3 <= 136;
  }
  function z(e3) {
    return F[e3];
  }
  function K(e3) {
    return e3 >= 129 && e3 <= 131;
  }
  function X(e3) {
    return e3 >= 58 && e3 <= 92;
  }
  function J(e3) {
    return M[e3];
  }
  function Y(e3) {
    return B[e3];
  }
  function Q(e3) {
    return e3 >= 24 && e3 <= 25;
  }
  function Z(e3) {
    return L[e3];
  }
  L[8].updateContext = (e3) => {
    e3.pop();
  }, L[5].updateContext = L[7].updateContext = L[23].updateContext = (e3) => {
    e3.push(w.brace);
  }, L[22].updateContext = (e3) => {
    e3[e3.length - 1] === w.template ? e3.pop() : e3.push(w.template);
  }, L[142].updateContext = (e3) => {
    e3.push(w.j_expr, w.j_oTag);
  };
  let ee = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", te = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
  const re = new RegExp("[" + ee + "]"), ne = new RegExp("[" + ee + te + "]");
  ee = te = null;
  const se = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], ie = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function oe(e3, t3) {
    let r3 = 65536;
    for (let n3 = 0, s3 = t3.length; n3 < s3; n3 += 2) {
      if (r3 += t3[n3], r3 > e3) return false;
      if (r3 += t3[n3 + 1], r3 >= e3) return true;
    }
    return false;
  }
  function ae(e3) {
    return e3 < 65 ? 36 === e3 : e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && re.test(String.fromCharCode(e3)) : oe(e3, se)));
  }
  function le(e3) {
    return e3 < 48 ? 36 === e3 : e3 < 58 || !(e3 < 65) && (e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && ne.test(String.fromCharCode(e3)) : oe(e3, se) || oe(e3, ie))));
  }
  const ce = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), ue = /* @__PURE__ */ new Set(["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"]), pe = /* @__PURE__ */ new Set(["eval", "arguments"]);
  function de(e3, t3) {
    return t3 && "await" === e3 || "enum" === e3;
  }
  function fe(e3, t3) {
    return de(e3, t3) || ue.has(e3);
  }
  function he(e3) {
    return pe.has(e3);
  }
  function me(e3, t3) {
    return fe(e3, t3) || he(e3);
  }
  const ye = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  class ge {
    constructor(e3) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e3;
    }
  }
  class be {
    constructor(e3, t3) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e3, this.inModule = t3;
    }
    get inTopLevel() {
      return (1 & this.currentScope().flags) > 0;
    }
    get inFunction() {
      return (2 & this.currentVarScopeFlags()) > 0;
    }
    get allowSuper() {
      return (16 & this.currentThisScopeFlags()) > 0;
    }
    get allowDirectSuper() {
      return (32 & this.currentThisScopeFlags()) > 0;
    }
    get inClass() {
      return (64 & this.currentThisScopeFlags()) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      const e3 = this.currentThisScopeFlags();
      return (64 & e3) > 0 && 0 == (2 & e3);
    }
    get inStaticBlock() {
      for (let e3 = this.scopeStack.length - 1; ; e3--) {
        const { flags: t3 } = this.scopeStack[e3];
        if (128 & t3) return true;
        if (451 & t3) return false;
      }
    }
    get inNonArrowFunction() {
      return (2 & this.currentThisScopeFlags()) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(e3) {
      return new ge(e3);
    }
    enter(e3) {
      this.scopeStack.push(this.createScope(e3));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(e3) {
      return !!(130 & e3.flags || !this.parser.inModule && 1 & e3.flags);
    }
    declareName(e3, t3, r3) {
      let n3 = this.currentScope();
      if (8 & t3 || 16 & t3) {
        this.checkRedeclarationInScope(n3, e3, t3, r3);
        let s3 = n3.names.get(e3) || 0;
        16 & t3 ? s3 |= 4 : (n3.firstLexicalName || (n3.firstLexicalName = e3), s3 |= 2), n3.names.set(e3, s3), 8 & t3 && this.maybeExportDefined(n3, e3);
      } else if (4 & t3) for (let s3 = this.scopeStack.length - 1; s3 >= 0 && (n3 = this.scopeStack[s3], this.checkRedeclarationInScope(n3, e3, t3, r3), n3.names.set(e3, 1 | (n3.names.get(e3) || 0)), this.maybeExportDefined(n3, e3), !(387 & n3.flags)); --s3) ;
      this.parser.inModule && 1 & n3.flags && this.undefinedExports.delete(e3);
    }
    maybeExportDefined(e3, t3) {
      this.parser.inModule && 1 & e3.flags && this.undefinedExports.delete(t3);
    }
    checkRedeclarationInScope(e3, t3, r3, n3) {
      this.isRedeclaredInScope(e3, t3, r3) && this.parser.raise(v.VarRedeclaration, n3, { identifierName: t3 });
    }
    isRedeclaredInScope(e3, t3, r3) {
      if (!(1 & r3)) return false;
      if (8 & r3) return e3.names.has(t3);
      const n3 = e3.names.get(t3);
      return 16 & r3 ? (2 & n3) > 0 || !this.treatFunctionsAsVarInScope(e3) && (1 & n3) > 0 : (2 & n3) > 0 && !(8 & e3.flags && e3.firstLexicalName === t3) || !this.treatFunctionsAsVarInScope(e3) && (4 & n3) > 0;
    }
    checkLocalExport(e3) {
      const { name: t3 } = e3;
      this.scopeStack[0].names.has(t3) || this.undefinedExports.set(t3, e3.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let e3 = this.scopeStack.length - 1; ; e3--) {
        const { flags: t3 } = this.scopeStack[e3];
        if (387 & t3) return t3;
      }
    }
    currentThisScopeFlags() {
      for (let e3 = this.scopeStack.length - 1; ; e3--) {
        const { flags: t3 } = this.scopeStack[e3];
        if (451 & t3 && !(4 & t3)) return t3;
      }
    }
  }
  class ve extends ge {
    constructor() {
      super(...arguments), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }
  class Ee extends be {
    createScope(e3) {
      return new ve(e3);
    }
    declareName(e3, t3, r3) {
      const n3 = this.currentScope();
      if (2048 & t3) return this.checkRedeclarationInScope(n3, e3, t3, r3), this.maybeExportDefined(n3, e3), void n3.declareFunctions.add(e3);
      super.declareName(e3, t3, r3);
    }
    isRedeclaredInScope(e3, t3, r3) {
      if (super.isRedeclaredInScope(e3, t3, r3)) return true;
      if (2048 & r3 && !e3.declareFunctions.has(t3)) {
        const r4 = e3.names.get(t3);
        return (4 & r4) > 0 || (2 & r4) > 0;
      }
      return false;
    }
    checkLocalExport(e3) {
      this.scopeStack[0].declareFunctions.has(e3.name) || super.checkLocalExport(e3);
    }
  }
  class Se {
    constructor() {
      this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
    }
    hasPlugin(e3) {
      if ("string" == typeof e3) return this.plugins.has(e3);
      {
        const [t3, r3] = e3;
        if (!this.hasPlugin(t3)) return false;
        const n3 = this.plugins.get(t3);
        for (const e4 of Object.keys(r3)) if ((null == n3 ? void 0 : n3[e4]) !== r3[e4]) return false;
        return true;
      }
    }
    getPluginOption(e3, t3) {
      var r3;
      return null == (r3 = this.plugins.get(e3)) ? void 0 : r3[t3];
    }
  }
  function xe(e3, t3) {
    void 0 === e3.trailingComments ? e3.trailingComments = t3 : e3.trailingComments.unshift(...t3);
  }
  function Te(e3, t3) {
    void 0 === e3.innerComments ? e3.innerComments = t3 : e3.innerComments.unshift(...t3);
  }
  function we(e3, t3, r3) {
    let n3 = null, s3 = t3.length;
    for (; null === n3 && s3 > 0; ) n3 = t3[--s3];
    null === n3 || n3.start > r3.start ? Te(e3, r3.comments) : xe(n3, r3.comments);
  }
  class Pe extends Se {
    addComment(e3) {
      this.filename && (e3.loc.filename = this.filename);
      const { commentsLen: t3 } = this.state;
      this.comments.length != t3 && (this.comments.length = t3), this.comments.push(e3), this.state.commentsLen++;
    }
    processComment(e3) {
      const { commentStack: t3 } = this.state, r3 = t3.length;
      if (0 === r3) return;
      let n3 = r3 - 1;
      const s3 = t3[n3];
      s3.start === e3.end && (s3.leadingNode = e3, n3--);
      const { start: i3 } = e3;
      for (; n3 >= 0; n3--) {
        const r4 = t3[n3], s4 = r4.end;
        if (!(s4 > i3)) {
          s4 === i3 && (r4.trailingNode = e3);
          break;
        }
        r4.containingNode = e3, this.finalizeComment(r4), t3.splice(n3, 1);
      }
    }
    finalizeComment(e3) {
      const { comments: t3 } = e3;
      if (null !== e3.leadingNode || null !== e3.trailingNode) null !== e3.leadingNode && xe(e3.leadingNode, t3), null !== e3.trailingNode && function(e4, t4) {
        void 0 === e4.leadingComments ? e4.leadingComments = t4 : e4.leadingComments.unshift(...t4);
      }(e3.trailingNode, t3);
      else {
        const { containingNode: r3, start: n3 } = e3;
        if (44 === this.input.charCodeAt(n3 - 1)) switch (r3.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            we(r3, r3.properties, e3);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
            we(r3, r3.arguments, e3);
            break;
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            we(r3, r3.params, e3);
            break;
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            we(r3, r3.elements, e3);
            break;
          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            we(r3, r3.specifiers, e3);
            break;
          default:
            Te(r3, t3);
        }
        else Te(r3, t3);
      }
    }
    finalizeRemainingComments() {
      const { commentStack: e3 } = this.state;
      for (let t3 = e3.length - 1; t3 >= 0; t3--) this.finalizeComment(e3[t3]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(e3) {
      const { commentStack: t3 } = this.state, { length: r3 } = t3;
      if (0 === r3) return;
      const n3 = t3[r3 - 1];
      n3.leadingNode === e3 && (n3.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(e3) {
      const { commentStack: t3 } = this.state, { length: r3 } = t3;
      0 !== r3 && (t3[r3 - 1].trailingNode === e3 ? t3[r3 - 1].trailingNode = null : r3 >= 2 && t3[r3 - 2].trailingNode === e3 && (t3[r3 - 2].trailingNode = null));
    }
    takeSurroundingComments(e3, t3, r3) {
      const { commentStack: n3 } = this.state, s3 = n3.length;
      if (0 === s3) return;
      let i3 = s3 - 1;
      for (; i3 >= 0; i3--) {
        const s4 = n3[i3], o3 = s4.end;
        if (s4.start === r3) s4.leadingNode = e3;
        else if (o3 === t3) s4.trailingNode = e3;
        else if (o3 < t3) break;
      }
    }
  }
  const Ae = /\r\n?|[\n\u2028\u2029]/, Ce = new RegExp(Ae.source, "g");
  function Oe(e3) {
    switch (e3) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  }
  const Ie = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, _e = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, ke = new RegExp("(?=(" + _e.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function Ne(e3) {
    switch (e3) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  }
  class De {
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [w.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (1 & this.flags) > 0;
    }
    set strict(e3) {
      e3 ? this.flags |= 1 : this.flags &= -2;
    }
    init(e3) {
      let { strictMode: t3, sourceType: r3, startLine: n3, startColumn: i3 } = e3;
      this.strict = false !== t3 && (true === t3 || "module" === r3), this.curLine = n3, this.lineStart = -i3, this.startLoc = this.endLoc = new s2(n3, i3, 0);
    }
    get maybeInArrowParameters() {
      return (2 & this.flags) > 0;
    }
    set maybeInArrowParameters(e3) {
      e3 ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (4 & this.flags) > 0;
    }
    set inType(e3) {
      e3 ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (8 & this.flags) > 0;
    }
    set noAnonFunctionType(e3) {
      e3 ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (16 & this.flags) > 0;
    }
    set hasFlowComment(e3) {
      e3 ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (32 & this.flags) > 0;
    }
    set isAmbientContext(e3) {
      e3 ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (64 & this.flags) > 0;
    }
    set inAbstractClass(e3) {
      e3 ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (128 & this.flags) > 0;
    }
    set inDisallowConditionalTypesContext(e3) {
      e3 ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (256 & this.flags) > 0;
    }
    set soloAwait(e3) {
      e3 ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (512 & this.flags) > 0;
    }
    set inFSharpPipelineDirectBody(e3) {
      e3 ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (1024 & this.flags) > 0;
    }
    set canStartJSXElement(e3) {
      e3 ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (2048 & this.flags) > 0;
    }
    set containsEsc(e3) {
      e3 ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new s2(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      const e3 = new De();
      return e3.flags = this.flags, e3.curLine = this.curLine, e3.lineStart = this.lineStart, e3.startLoc = this.startLoc, e3.endLoc = this.endLoc, e3.errors = this.errors.slice(), e3.potentialArrowAt = this.potentialArrowAt, e3.noArrowAt = this.noArrowAt.slice(), e3.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), e3.topicContext = this.topicContext, e3.labels = this.labels.slice(), e3.commentsLen = this.commentsLen, e3.commentStack = this.commentStack.slice(), e3.pos = this.pos, e3.type = this.type, e3.value = this.value, e3.start = this.start, e3.end = this.end, e3.lastTokEndLoc = this.lastTokEndLoc, e3.lastTokStartLoc = this.lastTokStartLoc, e3.context = this.context.slice(), e3.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, e3.strictErrors = this.strictErrors, e3.tokensLength = this.tokensLength, e3;
    }
  }
  var je = function(e3) {
    return e3 >= 48 && e3 <= 57;
  };
  const Le = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Me = { bin: (e3) => 48 === e3 || 49 === e3, oct: (e3) => e3 >= 48 && e3 <= 55, dec: (e3) => e3 >= 48 && e3 <= 57, hex: (e3) => e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102 };
  function Be(e3, t3, r3, n3, s3, i3) {
    const o3 = r3, a3 = n3, l2 = s3;
    let c2 = "", u2 = null, p2 = r3;
    const { length: d2 } = t3;
    for (; ; ) {
      if (r3 >= d2) {
        i3.unterminated(o3, a3, l2), c2 += t3.slice(p2, r3);
        break;
      }
      const f2 = t3.charCodeAt(r3);
      if (Re(e3, f2, t3, r3)) {
        c2 += t3.slice(p2, r3);
        break;
      }
      if (92 === f2) {
        c2 += t3.slice(p2, r3);
        const o4 = Fe(t3, r3, n3, s3, "template" === e3, i3);
        null !== o4.ch || u2 ? c2 += o4.ch : u2 = { pos: r3, lineStart: n3, curLine: s3 }, { pos: r3, lineStart: n3, curLine: s3 } = o4, p2 = r3;
      } else 8232 === f2 || 8233 === f2 ? (++s3, n3 = ++r3) : 10 === f2 || 13 === f2 ? "template" === e3 ? (c2 += t3.slice(p2, r3) + "\n", ++r3, 13 === f2 && 10 === t3.charCodeAt(r3) && ++r3, ++s3, p2 = n3 = r3) : i3.unterminated(o3, a3, l2) : ++r3;
    }
    return { pos: r3, str: c2, firstInvalidLoc: u2, lineStart: n3, curLine: s3, containsInvalid: !!u2 };
  }
  function Re(e3, t3, r3, n3) {
    return "template" === e3 ? 96 === t3 || 36 === t3 && 123 === r3.charCodeAt(n3 + 1) : t3 === ("double" === e3 ? 34 : 39);
  }
  function Fe(e3, t3, r3, n3, s3, i3) {
    const o3 = !s3;
    t3++;
    const a3 = (e4) => ({ pos: t3, ch: e4, lineStart: r3, curLine: n3 }), l2 = e3.charCodeAt(t3++);
    switch (l2) {
      case 110:
        return a3("\n");
      case 114:
        return a3("\r");
      case 120: {
        let s4;
        return { code: s4, pos: t3 } = Ue(e3, t3, r3, n3, 2, false, o3, i3), a3(null === s4 ? null : String.fromCharCode(s4));
      }
      case 117: {
        let s4;
        return { code: s4, pos: t3 } = Ve(e3, t3, r3, n3, o3, i3), a3(null === s4 ? null : String.fromCodePoint(s4));
      }
      case 116:
        return a3("	");
      case 98:
        return a3("\b");
      case 118:
        return a3("\v");
      case 102:
        return a3("\f");
      case 13:
        10 === e3.charCodeAt(t3) && ++t3;
      case 10:
        r3 = t3, ++n3;
      case 8232:
      case 8233:
        return a3("");
      case 56:
      case 57:
        if (s3) return a3(null);
        i3.strictNumericEscape(t3 - 1, r3, n3);
      default:
        if (l2 >= 48 && l2 <= 55) {
          const o4 = t3 - 1;
          let l3 = e3.slice(o4, t3 + 2).match(/^[0-7]+/)[0], c2 = parseInt(l3, 8);
          c2 > 255 && (l3 = l3.slice(0, -1), c2 = parseInt(l3, 8)), t3 += l3.length - 1;
          const u2 = e3.charCodeAt(t3);
          if ("0" !== l3 || 56 === u2 || 57 === u2) {
            if (s3) return a3(null);
            i3.strictNumericEscape(o4, r3, n3);
          }
          return a3(String.fromCharCode(c2));
        }
        return a3(String.fromCharCode(l2));
    }
  }
  function Ue(e3, t3, r3, n3, s3, i3, o3, a3) {
    const l2 = t3;
    let c2;
    return { n: c2, pos: t3 } = $e(e3, t3, r3, n3, 16, s3, i3, false, a3, !o3), null === c2 && (o3 ? a3.invalidEscapeSequence(l2, r3, n3) : t3 = l2 - 1), { code: c2, pos: t3 };
  }
  function $e(e3, t3, r3, n3, s3, i3, o3, a3, l2, c2) {
    const u2 = t3, p2 = 16 === s3 ? Le.hex : Le.decBinOct, d2 = 16 === s3 ? Me.hex : 10 === s3 ? Me.dec : 8 === s3 ? Me.oct : Me.bin;
    let f2 = false, h2 = 0;
    for (let u3 = 0, m2 = null == i3 ? 1 / 0 : i3; u3 < m2; ++u3) {
      const i4 = e3.charCodeAt(t3);
      let u4;
      if (95 !== i4 || "bail" === a3) {
        if (u4 = i4 >= 97 ? i4 - 97 + 10 : i4 >= 65 ? i4 - 65 + 10 : je(i4) ? i4 - 48 : 1 / 0, u4 >= s3) {
          if (u4 <= 9 && c2) return { n: null, pos: t3 };
          if (u4 <= 9 && l2.invalidDigit(t3, r3, n3, s3)) u4 = 0;
          else {
            if (!o3) break;
            u4 = 0, f2 = true;
          }
        }
        ++t3, h2 = h2 * s3 + u4;
      } else {
        const s4 = e3.charCodeAt(t3 - 1), i5 = e3.charCodeAt(t3 + 1);
        if (a3) {
          if (Number.isNaN(i5) || !d2(i5) || p2.has(s4) || p2.has(i5)) {
            if (c2) return { n: null, pos: t3 };
            l2.unexpectedNumericSeparator(t3, r3, n3);
          }
        } else {
          if (c2) return { n: null, pos: t3 };
          l2.numericSeparatorInEscapeSequence(t3, r3, n3);
        }
        ++t3;
      }
    }
    return t3 === u2 || null != i3 && t3 - u2 !== i3 || f2 ? { n: null, pos: t3 } : { n: h2, pos: t3 };
  }
  function Ve(e3, t3, r3, n3, s3, i3) {
    let o3;
    if (123 === e3.charCodeAt(t3)) {
      if (++t3, { code: o3, pos: t3 } = Ue(e3, t3, r3, n3, e3.indexOf("}", t3) - t3, true, s3, i3), ++t3, null !== o3 && o3 > 1114111) {
        if (!s3) return { code: null, pos: t3 };
        i3.invalidCodePoint(t3, r3, n3);
      }
    } else ({ code: o3, pos: t3 } = Ue(e3, t3, r3, n3, 4, false, s3, i3));
    return { code: o3, pos: t3 };
  }
  function qe(e3, t3, r3) {
    return new s2(r3, e3 - t3, e3);
  }
  const We = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
  class Ge {
    constructor(e3) {
      this.type = e3.type, this.value = e3.value, this.start = e3.start, this.end = e3.end, this.loc = new i2(e3.startLoc, e3.endLoc);
    }
  }
  class He extends Pe {
    constructor(e3, t3) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (e4, t4, r3, n3) => !!this.options.errorRecovery && (this.raise(v.InvalidDigit, qe(e4, t4, r3), { radix: n3 }), true), numericSeparatorInEscapeSequence: this.errorBuilder(v.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(v.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(v.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(v.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (e4, t4, r3) => {
        this.recordStrictModeErrors(v.StrictNumericEscape, qe(e4, t4, r3));
      }, unterminated: (e4, t4, r3) => {
        throw this.raise(v.UnterminatedString, qe(e4 - 1, t4, r3));
      } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(v.StrictNumericEscape), unterminated: (e4, t4, r3) => {
        throw this.raise(v.UnterminatedTemplate, qe(e4, t4, r3));
      } }), this.state = new De(), this.state.init(e3), this.input = t3, this.length = t3.length, this.comments = [], this.isLookahead = false;
    }
    pushToken(e3) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(e3), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Ge(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(e3) {
      return !!this.match(e3) && (this.next(), true);
    }
    match(e3) {
      return this.state.type === e3;
    }
    createLookaheadState(e3) {
      return { pos: e3.pos, value: null, type: e3.type, start: e3.start, end: e3.end, context: [this.curContext()], inType: e3.inType, startLoc: e3.startLoc, lastTokEndLoc: e3.lastTokEndLoc, curLine: e3.curLine, lineStart: e3.lineStart, curPosition: e3.curPosition };
    }
    lookahead() {
      const e3 = this.state;
      this.state = this.createLookaheadState(e3), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
      const t3 = this.state;
      return this.state = e3, t3;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(e3) {
      return Ie.lastIndex = e3, Ie.test(this.input) ? Ie.lastIndex : e3;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(e3) {
      return _e.lastIndex = e3, _e.test(this.input) ? _e.lastIndex : e3;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(e3) {
      let t3 = this.input.charCodeAt(e3);
      if (55296 == (64512 & t3) && ++e3 < this.input.length) {
        const r3 = this.input.charCodeAt(e3);
        56320 == (64512 & r3) && (t3 = 65536 + ((1023 & t3) << 10) + (1023 & r3));
      }
      return t3;
    }
    setStrict(e3) {
      this.state.strict = e3, e3 && (this.state.strictErrors.forEach((e4) => {
        let [t3, r3] = e4;
        return this.raise(t3, r3);
      }), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(139) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(e3) {
      let t3;
      this.isLookahead || (t3 = this.state.curPosition());
      const r3 = this.state.pos, n3 = this.input.indexOf(e3, r3 + 2);
      if (-1 === n3) throw this.raise(v.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = n3 + e3.length, Ce.lastIndex = r3 + 2; Ce.test(this.input) && Ce.lastIndex <= n3; ) ++this.state.curLine, this.state.lineStart = Ce.lastIndex;
      if (this.isLookahead) return;
      const s3 = { type: "CommentBlock", value: this.input.slice(r3 + 2, n3), start: r3, end: n3 + e3.length, loc: new i2(t3, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(s3), s3;
    }
    skipLineComment(e3) {
      const t3 = this.state.pos;
      let r3;
      this.isLookahead || (r3 = this.state.curPosition());
      let n3 = this.input.charCodeAt(this.state.pos += e3);
      if (this.state.pos < this.length) for (; !Oe(n3) && ++this.state.pos < this.length; ) n3 = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      const s3 = this.state.pos, o3 = { type: "CommentLine", value: this.input.slice(t3 + e3, s3), start: t3, end: s3, loc: new i2(r3, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(o3), o3;
    }
    skipSpace() {
      const e3 = this.state.pos, t3 = [];
      e: for (; this.state.pos < this.length; ) {
        const r3 = this.input.charCodeAt(this.state.pos);
        switch (r3) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const e4 = this.skipBlockComment("*/");
                void 0 !== e4 && (this.addComment(e4), this.options.attachComment && t3.push(e4));
                break;
              }
              case 47: {
                const e4 = this.skipLineComment(2);
                void 0 !== e4 && (this.addComment(e4), this.options.attachComment && t3.push(e4));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (Ne(r3)) ++this.state.pos;
            else if (45 === r3 && !this.inModule && this.options.annexB) {
              const r4 = this.state.pos;
              if (45 !== this.input.charCodeAt(r4 + 1) || 62 !== this.input.charCodeAt(r4 + 2) || !(0 === e3 || this.state.lineStart > e3)) break e;
              {
                const e4 = this.skipLineComment(3);
                void 0 !== e4 && (this.addComment(e4), this.options.attachComment && t3.push(e4));
              }
            } else {
              if (60 !== r3 || this.inModule || !this.options.annexB) break e;
              {
                const e4 = this.state.pos;
                if (33 !== this.input.charCodeAt(e4 + 1) || 45 !== this.input.charCodeAt(e4 + 2) || 45 !== this.input.charCodeAt(e4 + 3)) break e;
                {
                  const e5 = this.skipLineComment(4);
                  void 0 !== e5 && (this.addComment(e5), this.options.attachComment && t3.push(e5));
                }
              }
            }
        }
      }
      if (t3.length > 0) {
        const r3 = { start: e3, end: this.state.pos, comments: t3, leadingNode: null, trailingNode: null, containingNode: null };
        this.state.commentStack.push(r3);
      }
    }
    finishToken(e3, t3) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      const r3 = this.state.type;
      this.state.type = e3, this.state.value = t3, this.isLookahead || this.updateContext(r3);
    }
    replaceToken(e3) {
      this.state.type = e3, this.updateContext();
    }
    readToken_numberSign() {
      if (0 === this.state.pos && this.readToken_interpreter()) return;
      const e3 = this.state.pos + 1, t3 = this.codePointAtPos(e3);
      if (t3 >= 48 && t3 <= 57) throw this.raise(v.UnexpectedDigitAfterHash, this.state.curPosition());
      if (123 === t3 || 91 === t3 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), "bar" === this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(123 === t3 ? v.RecordExpressionHashIncorrectStartSyntaxType : v.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, 123 === t3 ? this.finishToken(7) : this.finishToken(1);
      } else ae(t3) ? (++this.state.pos, this.finishToken(138, this.readWord1(t3))) : 92 === t3 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      const e3 = this.input.charCodeAt(this.state.pos + 1);
      e3 >= 48 && e3 <= 57 ? this.readNumber(true) : 46 === e3 && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (0 !== this.state.pos || this.length < 2) return false;
      let e3 = this.input.charCodeAt(this.state.pos + 1);
      if (33 !== e3) return false;
      const t3 = this.state.pos;
      for (this.state.pos += 1; !Oe(e3) && ++this.state.pos < this.length; ) e3 = this.input.charCodeAt(this.state.pos);
      const r3 = this.input.slice(t3 + 2, this.state.pos);
      return this.finishToken(28, r3), true;
    }
    readToken_mult_modulo(e3) {
      let t3 = 42 === e3 ? 55 : 54, r3 = 1, n3 = this.input.charCodeAt(this.state.pos + 1);
      42 === e3 && 42 === n3 && (r3++, n3 = this.input.charCodeAt(this.state.pos + 2), t3 = 57), 61 !== n3 || this.state.inType || (r3++, t3 = 37 === e3 ? 33 : 30), this.finishOp(t3, r3);
    }
    readToken_pipe_amp(e3) {
      const t3 = this.input.charCodeAt(this.state.pos + 1);
      if (t3 !== e3) {
        if (124 === e3) {
          if (62 === t3) return void this.finishOp(39, 2);
          if (this.hasPlugin("recordAndTuple") && 125 === t3) {
            if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(v.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            return this.state.pos += 2, void this.finishToken(9);
          }
          if (this.hasPlugin("recordAndTuple") && 93 === t3) {
            if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(v.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            return this.state.pos += 2, void this.finishToken(4);
          }
        }
        61 !== t3 ? this.finishOp(124 === e3 ? 43 : 45, 1) : this.finishOp(30, 2);
      } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === e3 ? 41 : 42, 2);
    }
    readToken_caret() {
      const e3 = this.input.charCodeAt(this.state.pos + 1);
      61 !== e3 || this.state.inType ? 94 === e3 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), 94 === this.input.codePointAt(this.state.pos) && this.unexpected()) : this.finishOp(44, 1) : this.finishOp(32, 2);
    }
    readToken_atSign() {
      64 === this.input.charCodeAt(this.state.pos + 1) && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(e3) {
      const t3 = this.input.charCodeAt(this.state.pos + 1);
      t3 !== e3 ? 61 === t3 ? this.finishOp(30, 2) : this.finishOp(53, 1) : this.finishOp(34, 2);
    }
    readToken_lt() {
      const { pos: e3 } = this.state, t3 = this.input.charCodeAt(e3 + 1);
      if (60 === t3) return 61 === this.input.charCodeAt(e3 + 2) ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
      61 !== t3 ? this.finishOp(47, 1) : this.finishOp(49, 2);
    }
    readToken_gt() {
      const { pos: e3 } = this.state, t3 = this.input.charCodeAt(e3 + 1);
      if (62 === t3) {
        const t4 = 62 === this.input.charCodeAt(e3 + 2) ? 3 : 2;
        return 61 === this.input.charCodeAt(e3 + t4) ? void this.finishOp(30, t4 + 1) : void this.finishOp(52, t4);
      }
      61 !== t3 ? this.finishOp(48, 1) : this.finishOp(49, 2);
    }
    readToken_eq_excl(e3) {
      const t3 = this.input.charCodeAt(this.state.pos + 1);
      if (61 !== t3) return 61 === e3 && 62 === t3 ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(61 === e3 ? 29 : 35, 1);
      this.finishOp(46, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
    }
    readToken_question() {
      const e3 = this.input.charCodeAt(this.state.pos + 1), t3 = this.input.charCodeAt(this.state.pos + 2);
      63 === e3 ? 61 === t3 ? this.finishOp(30, 3) : this.finishOp(40, 2) : 46 !== e3 || t3 >= 48 && t3 <= 57 ? (++this.state.pos, this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
    }
    getTokenFromCode(e3) {
      switch (e3) {
        case 46:
          return void this.readToken_dot();
        case 40:
          return ++this.state.pos, void this.finishToken(10);
        case 41:
          return ++this.state.pos, void this.finishToken(11);
        case 59:
          return ++this.state.pos, void this.finishToken(13);
        case 44:
          return ++this.state.pos, void this.finishToken(12);
        case 91:
          if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
            if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(v.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          return ++this.state.pos, void this.finishToken(3);
        case 123:
          if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
            if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(v.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          return ++this.state.pos, void this.finishToken(8);
        case 58:
          return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
        case 63:
          return void this.readToken_question();
        case 96:
          return void this.readTemplateToken();
        case 48: {
          const e4 = this.input.charCodeAt(this.state.pos + 1);
          if (120 === e4 || 88 === e4) return void this.readRadixNumber(16);
          if (111 === e4 || 79 === e4) return void this.readRadixNumber(8);
          if (98 === e4 || 66 === e4) return void this.readRadixNumber(2);
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return void this.readNumber(false);
        case 34:
        case 39:
          return void this.readString(e3);
        case 47:
          return void this.readToken_slash();
        case 37:
        case 42:
          return void this.readToken_mult_modulo(e3);
        case 124:
        case 38:
          return void this.readToken_pipe_amp(e3);
        case 94:
          return void this.readToken_caret();
        case 43:
        case 45:
          return void this.readToken_plus_min(e3);
        case 60:
          return void this.readToken_lt();
        case 62:
          return void this.readToken_gt();
        case 61:
        case 33:
          return void this.readToken_eq_excl(e3);
        case 126:
          return void this.finishOp(36, 1);
        case 64:
          return void this.readToken_atSign();
        case 35:
          return void this.readToken_numberSign();
        case 92:
          return void this.readWord();
        default:
          if (ae(e3)) return void this.readWord(e3);
      }
      throw this.raise(v.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(e3) });
    }
    finishOp(e3, t3) {
      const r3 = this.input.slice(this.state.pos, this.state.pos + t3);
      this.state.pos += t3, this.finishToken(e3, r3);
    }
    readRegexp() {
      const e3 = this.state.startLoc, t3 = this.state.start + 1;
      let r3, n3, { pos: s3 } = this.state;
      for (; ; ++s3) {
        if (s3 >= this.length) throw this.raise(v.UnterminatedRegExp, o2(e3, 1));
        const t4 = this.input.charCodeAt(s3);
        if (Oe(t4)) throw this.raise(v.UnterminatedRegExp, o2(e3, 1));
        if (r3) r3 = false;
        else {
          if (91 === t4) n3 = true;
          else if (93 === t4 && n3) n3 = false;
          else if (47 === t4 && !n3) break;
          r3 = 92 === t4;
        }
      }
      const i3 = this.input.slice(t3, s3);
      ++s3;
      let a3 = "";
      const l2 = () => o2(e3, s3 + 2 - t3);
      for (; s3 < this.length; ) {
        const e4 = this.codePointAtPos(s3), t4 = String.fromCharCode(e4);
        if (We.has(e4)) 118 === e4 ? a3.includes("u") && this.raise(v.IncompatibleRegExpUVFlags, l2()) : 117 === e4 && a3.includes("v") && this.raise(v.IncompatibleRegExpUVFlags, l2()), a3.includes(t4) && this.raise(v.DuplicateRegExpFlags, l2());
        else {
          if (!le(e4) && 92 !== e4) break;
          this.raise(v.MalformedRegExpFlags, l2());
        }
        ++s3, a3 += t4;
      }
      this.state.pos = s3, this.finishToken(137, { pattern: i3, flags: a3 });
    }
    readInt(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      const { n: s3, pos: i3 } = $e(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e3, t3, r3, n3, this.errorHandlers_readInt, false);
      return this.state.pos = i3, s3;
    }
    readRadixNumber(e3) {
      const t3 = this.state.curPosition();
      let r3 = false;
      this.state.pos += 2;
      const n3 = this.readInt(e3);
      null == n3 && this.raise(v.InvalidDigit, o2(t3, 2), { radix: e3 });
      const s3 = this.input.charCodeAt(this.state.pos);
      if (110 === s3) ++this.state.pos, r3 = true;
      else if (109 === s3) throw this.raise(v.InvalidDecimal, t3);
      if (ae(this.codePointAtPos(this.state.pos))) throw this.raise(v.NumberIdentifier, this.state.curPosition());
      if (r3) {
        const e4 = this.input.slice(t3.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, e4);
      } else this.finishToken(134, n3);
    }
    readNumber(e3) {
      const t3 = this.state.pos, r3 = this.state.curPosition();
      let n3 = false, s3 = false, i3 = false, a3 = false, l2 = false;
      e3 || null !== this.readInt(10) || this.raise(v.InvalidNumber, this.state.curPosition());
      const c2 = this.state.pos - t3 >= 2 && 48 === this.input.charCodeAt(t3);
      if (c2) {
        const e4 = this.input.slice(t3, this.state.pos);
        if (this.recordStrictModeErrors(v.StrictOctalLiteral, r3), !this.state.strict) {
          const t4 = e4.indexOf("_");
          t4 > 0 && this.raise(v.ZeroDigitNumericSeparator, o2(r3, t4));
        }
        l2 = c2 && !/[89]/.test(e4);
      }
      let u2 = this.input.charCodeAt(this.state.pos);
      if (46 !== u2 || l2 || (++this.state.pos, this.readInt(10), n3 = true, u2 = this.input.charCodeAt(this.state.pos)), 69 !== u2 && 101 !== u2 || l2 || (u2 = this.input.charCodeAt(++this.state.pos), 43 !== u2 && 45 !== u2 || ++this.state.pos, null === this.readInt(10) && this.raise(v.InvalidOrMissingExponent, r3), n3 = true, a3 = true, u2 = this.input.charCodeAt(this.state.pos)), 110 === u2 && ((n3 || c2) && this.raise(v.InvalidBigIntLiteral, r3), ++this.state.pos, s3 = true), 109 === u2 && (this.expectPlugin("decimal", this.state.curPosition()), (a3 || c2) && this.raise(v.InvalidDecimal, r3), ++this.state.pos, i3 = true), ae(this.codePointAtPos(this.state.pos))) throw this.raise(v.NumberIdentifier, this.state.curPosition());
      const p2 = this.input.slice(t3, this.state.pos).replace(/[_mn]/g, "");
      if (s3) return void this.finishToken(135, p2);
      if (i3) return void this.finishToken(136, p2);
      const d2 = l2 ? parseInt(p2, 8) : parseFloat(p2);
      this.finishToken(134, d2);
    }
    readCodePoint(e3) {
      const { code: t3, pos: r3 } = Ve(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e3, this.errorHandlers_readCodePoint);
      return this.state.pos = r3, t3;
    }
    readString(e3) {
      const { str: t3, pos: r3, curLine: n3, lineStart: s3 } = Be(34 === e3 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = r3 + 1, this.state.lineStart = s3, this.state.curLine = n3, this.finishToken(133, t3);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      const e3 = this.input[this.state.pos], { str: t3, firstInvalidLoc: r3, pos: n3, curLine: i3, lineStart: o3 } = Be("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = n3 + 1, this.state.lineStart = o3, this.state.curLine = i3, r3 && (this.state.firstInvalidTemplateEscapePos = new s2(r3.curLine, r3.pos - r3.lineStart, r3.pos)), 96 === this.input.codePointAt(n3) ? this.finishToken(24, r3 ? null : e3 + t3 + "`") : (this.state.pos++, this.finishToken(25, r3 ? null : e3 + t3 + "${"));
    }
    recordStrictModeErrors(e3, t3) {
      const r3 = t3.index;
      this.state.strict && !this.state.strictErrors.has(r3) ? this.raise(e3, t3) : this.state.strictErrors.set(r3, [e3, t3]);
    }
    readWord1(e3) {
      this.state.containsEsc = false;
      let t3 = "";
      const r3 = this.state.pos;
      let n3 = this.state.pos;
      for (void 0 !== e3 && (this.state.pos += e3 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        const e4 = this.codePointAtPos(this.state.pos);
        if (le(e4)) this.state.pos += e4 <= 65535 ? 1 : 2;
        else {
          if (92 !== e4) break;
          {
            this.state.containsEsc = true, t3 += this.input.slice(n3, this.state.pos);
            const e5 = this.state.curPosition(), s3 = this.state.pos === r3 ? ae : le;
            if (117 !== this.input.charCodeAt(++this.state.pos)) {
              this.raise(v.MissingUnicodeEscape, this.state.curPosition()), n3 = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const i3 = this.readCodePoint(true);
            null !== i3 && (s3(i3) || this.raise(v.EscapedCharNotAnIdentifier, e5), t3 += String.fromCodePoint(i3)), n3 = this.state.pos;
          }
        }
      }
      return t3 + this.input.slice(n3, this.state.pos);
    }
    readWord(e3) {
      const t3 = this.readWord1(e3), r3 = k.get(t3);
      void 0 !== r3 ? this.finishToken(r3, J(r3)) : this.finishToken(132, t3);
    }
    checkKeywordEscapes() {
      const { type: e3 } = this.state;
      X(e3) && this.state.containsEsc && this.raise(v.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: J(e3) });
    }
    raise(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      const n3 = e3(t3 instanceof s2 ? t3 : t3.loc.start, r3);
      if (!this.options.errorRecovery) throw n3;
      return this.isLookahead || this.state.errors.push(n3), n3;
    }
    raiseOverwrite(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      const n3 = t3 instanceof s2 ? t3 : t3.loc.start, i3 = n3.index, o3 = this.state.errors;
      for (let t4 = o3.length - 1; t4 >= 0; t4--) {
        const s3 = o3[t4];
        if (s3.loc.index === i3) return o3[t4] = e3(n3, r3);
        if (s3.loc.index < i3) break;
      }
      return this.raise(e3, t3, r3);
    }
    updateContext(e3) {
    }
    unexpected(e3, t3) {
      throw this.raise(v.UnexpectedToken, null != e3 ? e3 : this.state.startLoc, { expected: t3 ? J(t3) : null });
    }
    expectPlugin(e3, t3) {
      if (this.hasPlugin(e3)) return true;
      throw this.raise(v.MissingPlugin, null != t3 ? t3 : this.state.startLoc, { missingPlugin: [e3] });
    }
    expectOnePlugin(e3) {
      if (!e3.some((e4) => this.hasPlugin(e4))) throw this.raise(v.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: e3 });
    }
    errorBuilder(e3) {
      return (t3, r3, n3) => {
        this.raise(e3, qe(t3, r3, n3));
      };
    }
  }
  class ze {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }
  class Ke {
    constructor(e3) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e3;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new ze());
    }
    exit() {
      const e3 = this.stack.pop(), t3 = this.current();
      for (const [r3, n3] of Array.from(e3.undefinedPrivateNames)) t3 ? t3.undefinedPrivateNames.has(r3) || t3.undefinedPrivateNames.set(r3, n3) : this.parser.raise(v.InvalidPrivateFieldResolution, n3, { identifierName: r3 });
    }
    declarePrivateName(e3, t3, r3) {
      const { privateNames: n3, loneAccessors: s3, undefinedPrivateNames: i3 } = this.current();
      let o3 = n3.has(e3);
      if (3 & t3) {
        const r4 = o3 && s3.get(e3);
        r4 ? (o3 = (3 & r4) == (3 & t3) || (4 & r4) != (4 & t3), o3 || s3.delete(e3)) : o3 || s3.set(e3, t3);
      }
      o3 && this.parser.raise(v.PrivateNameRedeclaration, r3, { identifierName: e3 }), n3.add(e3), i3.delete(e3);
    }
    usePrivateName(e3, t3) {
      let r3;
      for (r3 of this.stack) if (r3.privateNames.has(e3)) return;
      r3 ? r3.undefinedPrivateNames.set(e3, t3) : this.parser.raise(v.InvalidPrivateFieldResolution, t3, { identifierName: e3 });
    }
  }
  class Xe {
    constructor() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
      this.type = e3;
    }
    canBeArrowParameterDeclaration() {
      return 2 === this.type || 1 === this.type;
    }
    isCertainlyParameterDeclaration() {
      return 3 === this.type;
    }
  }
  class Je extends Xe {
    constructor(e3) {
      super(e3), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(e3, t3) {
      const r3 = t3.index;
      this.declarationErrors.set(r3, [e3, t3]);
    }
    clearDeclarationError(e3) {
      this.declarationErrors.delete(e3);
    }
    iterateErrors(e3) {
      this.declarationErrors.forEach(e3);
    }
  }
  class Ye {
    constructor(e3) {
      this.parser = void 0, this.stack = [new Xe()], this.parser = e3;
    }
    enter(e3) {
      this.stack.push(e3);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(e3, t3) {
      const r3 = t3.loc.start, { stack: n3 } = this;
      let s3 = n3.length - 1, i3 = n3[s3];
      for (; !i3.isCertainlyParameterDeclaration(); ) {
        if (!i3.canBeArrowParameterDeclaration()) return;
        i3.recordDeclarationError(e3, r3), i3 = n3[--s3];
      }
      this.parser.raise(e3, r3);
    }
    recordArrowParameterBindingError(e3, t3) {
      const { stack: r3 } = this, n3 = r3[r3.length - 1], s3 = t3.loc.start;
      if (n3.isCertainlyParameterDeclaration()) this.parser.raise(e3, s3);
      else {
        if (!n3.canBeArrowParameterDeclaration()) return;
        n3.recordDeclarationError(e3, s3);
      }
    }
    recordAsyncArrowParametersError(e3) {
      const { stack: t3 } = this;
      let r3 = t3.length - 1, n3 = t3[r3];
      for (; n3.canBeArrowParameterDeclaration(); ) 2 === n3.type && n3.recordDeclarationError(v.AwaitBindingIdentifier, e3), n3 = t3[--r3];
    }
    validateAsPattern() {
      const { stack: e3 } = this, t3 = e3[e3.length - 1];
      t3.canBeArrowParameterDeclaration() && t3.iterateErrors((t4) => {
        let [r3, n3] = t4;
        this.parser.raise(r3, n3);
        let s3 = e3.length - 2, i3 = e3[s3];
        for (; i3.canBeArrowParameterDeclaration(); ) i3.clearDeclarationError(n3.index), i3 = e3[--s3];
      });
    }
  }
  function Qe() {
    return new Xe();
  }
  class Ze {
    constructor() {
      this.stacks = [];
    }
    enter(e3) {
      this.stacks.push(e3);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (2 & this.currentFlags()) > 0;
    }
    get hasYield() {
      return (1 & this.currentFlags()) > 0;
    }
    get hasReturn() {
      return (4 & this.currentFlags()) > 0;
    }
    get hasIn() {
      return (8 & this.currentFlags()) > 0;
    }
  }
  function et(e3, t3) {
    return (e3 ? 2 : 0) | (t3 ? 1 : 0);
  }
  class tt extends He {
    addExtra(e3, t3, r3) {
      let n3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      if (!e3) return;
      const s3 = e3.extra = e3.extra || {};
      n3 ? s3[t3] = r3 : Object.defineProperty(s3, t3, { enumerable: n3, value: r3 });
    }
    isContextual(e3) {
      return this.state.type === e3 && !this.state.containsEsc;
    }
    isUnparsedContextual(e3, t3) {
      const r3 = e3 + t3.length;
      if (this.input.slice(e3, r3) === t3) {
        const e4 = this.input.charCodeAt(r3);
        return !(le(e4) || 55296 == (64512 & e4));
      }
      return false;
    }
    isLookaheadContextual(e3) {
      const t3 = this.nextTokenStart();
      return this.isUnparsedContextual(t3, e3);
    }
    eatContextual(e3) {
      return !!this.isContextual(e3) && (this.next(), true);
    }
    expectContextual(e3, t3) {
      if (!this.eatContextual(e3)) {
        if (null != t3) throw this.raise(t3, this.state.startLoc);
        this.unexpected(null, e3);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return Ae.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return ke.lastIndex = this.state.end, ke.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon() {
      (arguments.length > 0 && void 0 !== arguments[0] && !arguments[0] ? this.eat(13) : this.isLineTerminator()) || this.raise(v.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(e3, t3) {
      this.eat(e3) || this.unexpected(t3, e3);
    }
    tryParse(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state.clone();
      const r3 = { node: null };
      try {
        const n3 = e3(function() {
          let e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
          throw r3.node = e4, r3;
        });
        if (this.state.errors.length > t3.errors.length) {
          const e4 = this.state;
          return this.state = t3, this.state.tokensLength = e4.tokensLength, { node: n3, error: e4.errors[t3.errors.length], thrown: false, aborted: false, failState: e4 };
        }
        return { node: n3, error: null, thrown: false, aborted: false, failState: null };
      } catch (e4) {
        const n3 = this.state;
        if (this.state = t3, e4 instanceof SyntaxError) return { node: null, error: e4, thrown: true, aborted: false, failState: n3 };
        if (e4 === r3) return { node: r3.node, error: null, thrown: false, aborted: true, failState: n3 };
        throw e4;
      }
    }
    checkExpressionErrors(e3, t3) {
      if (!e3) return false;
      const { shorthandAssignLoc: r3, doubleProtoLoc: n3, privateKeyLoc: s3, optionalParametersLoc: i3 } = e3;
      if (!t3) return !!(r3 || n3 || i3 || s3);
      null != r3 && this.raise(v.InvalidCoverInitializedName, r3), null != n3 && this.raise(v.DuplicateProto, n3), null != s3 && this.raise(v.UnexpectedPrivateField, s3), null != i3 && this.unexpected(i3);
    }
    isLiteralPropertyName() {
      return H(this.state.type);
    }
    isPrivateName(e3) {
      return "PrivateName" === e3.type;
    }
    getPrivateNameSV(e3) {
      return e3.id.name;
    }
    hasPropertyAsPrivateName(e3) {
      return ("MemberExpression" === e3.type || "OptionalMemberExpression" === e3.type) && this.isPrivateName(e3.property);
    }
    isObjectProperty(e3) {
      return "ObjectProperty" === e3.type;
    }
    isObjectMethod(e3) {
      return "ObjectMethod" === e3.type;
    }
    initializeScopes() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "module" === this.options.sourceType;
      const t3 = this.state.labels;
      this.state.labels = [];
      const r3 = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      const n3 = this.inModule;
      this.inModule = e3;
      const s3 = this.scope, i3 = this.getScopeHandler();
      this.scope = new i3(this, e3);
      const o3 = this.prodParam;
      this.prodParam = new Ze();
      const a3 = this.classScope;
      this.classScope = new Ke(this);
      const l2 = this.expressionScope;
      return this.expressionScope = new Ye(this), () => {
        this.state.labels = t3, this.exportedIdentifiers = r3, this.inModule = n3, this.scope = s3, this.prodParam = o3, this.classScope = a3, this.expressionScope = l2;
      };
    }
    enterInitialScopes() {
      let e3 = 0;
      this.inModule && (e3 |= 2), this.scope.enter(1), this.prodParam.enter(e3);
    }
    checkDestructuringPrivate(e3) {
      const { privateKeyLoc: t3 } = e3;
      null !== t3 && this.expectPlugin("destructuringPrivate", t3);
    }
  }
  class rt {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }
  class nt {
    constructor(e3, t3, r3) {
      this.type = "", this.start = t3, this.end = 0, this.loc = new i2(r3), null != e3 && e3.options.ranges && (this.range = [t3, 0]), null != e3 && e3.filename && (this.loc.filename = e3.filename);
    }
  }
  const st = nt.prototype;
  function it(e3) {
    const { type: t3, start: r3, end: n3, loc: s3, range: i3, extra: o3, name: a3 } = e3, l2 = Object.create(st);
    return l2.type = t3, l2.start = r3, l2.end = n3, l2.loc = s3, l2.range = i3, l2.extra = o3, l2.name = a3, "Placeholder" === t3 && (l2.expectedNode = e3.expectedNode), l2;
  }
  st.__clone = function() {
    const e3 = new nt(void 0, this.start, this.loc.start), t3 = Object.keys(this);
    for (let r3 = 0, n3 = t3.length; r3 < n3; r3++) {
      const n4 = t3[r3];
      "leadingComments" !== n4 && "trailingComments" !== n4 && "innerComments" !== n4 && (e3[n4] = this[n4]);
    }
    return e3;
  };
  class ot extends tt {
    startNode() {
      const e3 = this.state.startLoc;
      return new nt(this, e3.index, e3);
    }
    startNodeAt(e3) {
      return new nt(this, e3.index, e3);
    }
    startNodeAtNode(e3) {
      return this.startNodeAt(e3.loc.start);
    }
    finishNode(e3, t3) {
      return this.finishNodeAt(e3, t3, this.state.lastTokEndLoc);
    }
    finishNodeAt(e3, t3, r3) {
      return e3.type = t3, e3.end = r3.index, e3.loc.end = r3, this.options.ranges && (e3.range[1] = r3.index), this.options.attachComment && this.processComment(e3), e3;
    }
    resetStartLocation(e3, t3) {
      e3.start = t3.index, e3.loc.start = t3, this.options.ranges && (e3.range[0] = t3.index);
    }
    resetEndLocation(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state.lastTokEndLoc;
      e3.end = t3.index, e3.loc.end = t3, this.options.ranges && (e3.range[1] = t3.index);
    }
    resetStartLocationFromNode(e3, t3) {
      this.resetStartLocation(e3, t3.loc.start);
    }
  }
  const at = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), lt = b`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: (e3) => {
    let { reservedType: t3 } = e3;
    return `Cannot overwrite reserved type ${t3}.`;
  }, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: (e3) => {
    let { memberName: t3, enumName: r3 } = e3;
    return `Boolean enum members need to be initialized. Use either \`${t3} = true,\` or \`${t3} = false,\` in enum \`${r3}\`.`;
  }, EnumDuplicateMemberName: (e3) => {
    let { memberName: t3, enumName: r3 } = e3;
    return `Enum member names need to be unique, but the name \`${t3}\` has already been used before in enum \`${r3}\`.`;
  }, EnumInconsistentMemberValues: (e3) => {
    let { enumName: t3 } = e3;
    return `Enum \`${t3}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`;
  }, EnumInvalidExplicitType: (e3) => {
    let { invalidEnumType: t3, enumName: r3 } = e3;
    return `Enum type \`${t3}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${r3}\`.`;
  }, EnumInvalidExplicitTypeUnknownSupplied: (e3) => {
    let { enumName: t3 } = e3;
    return `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t3}\`.`;
  }, EnumInvalidMemberInitializerPrimaryType: (e3) => {
    let { enumName: t3, memberName: r3, explicitType: n3 } = e3;
    return `Enum \`${t3}\` has type \`${n3}\`, so the initializer of \`${r3}\` needs to be a ${n3} literal.`;
  }, EnumInvalidMemberInitializerSymbolType: (e3) => {
    let { enumName: t3, memberName: r3 } = e3;
    return `Symbol enum members cannot be initialized. Use \`${r3},\` in enum \`${t3}\`.`;
  }, EnumInvalidMemberInitializerUnknownType: (e3) => {
    let { enumName: t3, memberName: r3 } = e3;
    return `The enum member initializer for \`${r3}\` needs to be a literal (either a boolean, number, or string) in enum \`${t3}\`.`;
  }, EnumInvalidMemberName: (e3) => {
    let { enumName: t3, memberName: r3, suggestion: n3 } = e3;
    return `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${r3}\`, consider using \`${n3}\`, in enum \`${t3}\`.`;
  }, EnumNumberMemberNotInitialized: (e3) => {
    let { enumName: t3, memberName: r3 } = e3;
    return `Number enum members need to be initialized, e.g. \`${r3} = 1\` in enum \`${t3}\`.`;
  }, EnumStringMemberInconsistentlyInitialized: (e3) => {
    let { enumName: t3 } = e3;
    return `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${t3}\`.`;
  }, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: (e3) => {
    let { reservedType: t3 } = e3;
    return `Unexpected reserved type ${t3}.`;
  }, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: (e3) => {
    let { unsupportedExportKind: t3, suggestion: r3 } = e3;
    return `\`declare export ${t3}\` is not supported. Use \`${r3}\` instead.`;
  }, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
  function ct(e3) {
    return "type" === e3.importKind || "typeof" === e3.importKind;
  }
  const ut = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" }, pt = /\*?\s*@((?:no)?flow)\b/, dt = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "", iexcl: "", cent: "", pound: "", curren: "", yen: "", brvbar: "", sect: "", uml: "", copy: "", ordf: "", laquo: "", not: "", shy: "", reg: "", macr: "", deg: "", plusmn: "", sup2: "", sup3: "", acute: "", micro: "", para: "", middot: "", cedil: "", sup1: "", ordm: "", raquo: "", frac14: "", frac12: "", frac34: "", iquest: "", Agrave: "", Aacute: "", Acirc: "", Atilde: "", Auml: "", Aring: "", AElig: "", Ccedil: "", Egrave: "", Eacute: "", Ecirc: "", Euml: "", Igrave: "", Iacute: "", Icirc: "", Iuml: "", ETH: "", Ntilde: "", Ograve: "", Oacute: "", Ocirc: "", Otilde: "", Ouml: "", times: "", Oslash: "", Ugrave: "", Uacute: "", Ucirc: "", Uuml: "", Yacute: "", THORN: "", szlig: "", agrave: "", aacute: "", acirc: "", atilde: "", auml: "", aring: "", aelig: "", ccedil: "", egrave: "", eacute: "", ecirc: "", euml: "", igrave: "", iacute: "", icirc: "", iuml: "", eth: "", ntilde: "", ograve: "", oacute: "", ocirc: "", otilde: "", ouml: "", divide: "", oslash: "", ugrave: "", uacute: "", ucirc: "", uuml: "", yacute: "", thorn: "", yuml: "", OElig: "", oelig: "", Scaron: "", scaron: "", Yuml: "", fnof: "", circ: "", tilde: "", Alpha: "", Beta: "", Gamma: "", Delta: "", Epsilon: "", Zeta: "", Eta: "", Theta: "", Iota: "", Kappa: "", Lambda: "", Mu: "", Nu: "", Xi: "", Omicron: "", Pi: "", Rho: "", Sigma: "", Tau: "", Upsilon: "", Phi: "", Chi: "", Psi: "", Omega: "", alpha: "", beta: "", gamma: "", delta: "", epsilon: "", zeta: "", eta: "", theta: "", iota: "", kappa: "", lambda: "", mu: "", nu: "", xi: "", omicron: "", pi: "", rho: "", sigmaf: "", sigma: "", tau: "", upsilon: "", phi: "", chi: "", psi: "", omega: "", thetasym: "", upsih: "", piv: "", ensp: "", emsp: "", thinsp: "", zwnj: "", zwj: "", lrm: "", rlm: "", ndash: "", mdash: "", lsquo: "", rsquo: "", sbquo: "", ldquo: "", rdquo: "", bdquo: "", dagger: "", Dagger: "", bull: "", hellip: "", permil: "", prime: "", Prime: "", lsaquo: "", rsaquo: "", oline: "", frasl: "", euro: "", image: "", weierp: "", real: "", trade: "", alefsym: "", larr: "", uarr: "", rarr: "", darr: "", harr: "", crarr: "", lArr: "", uArr: "", rArr: "", dArr: "", hArr: "", forall: "", part: "", exist: "", empty: "", nabla: "", isin: "", notin: "", ni: "", prod: "", sum: "", minus: "", lowast: "", radic: "", prop: "", infin: "", ang: "", and: "", or: "", cap: "", cup: "", int: "", there4: "", sim: "", cong: "", asymp: "", ne: "", equiv: "", le: "", ge: "", sub: "", sup: "", nsub: "", sube: "", supe: "", oplus: "", otimes: "", perp: "", sdot: "", lceil: "", rceil: "", lfloor: "", rfloor: "", lang: "", rang: "", loz: "", spades: "", clubs: "", hearts: "", diams: "" }, ft = b`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: (e3) => {
    let { openingTagName: t3 } = e3;
    return `Expected corresponding JSX closing tag for <${t3}>.`;
  }, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: (e3) => {
    let { unexpected: t3, HTMLEntity: r3 } = e3;
    return `Unexpected token \`${t3}\`. Did you mean \`${r3}\` or \`{'${t3}'}\`?`;
  }, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
  function ht(e3) {
    return !!e3 && ("JSXOpeningFragment" === e3.type || "JSXClosingFragment" === e3.type);
  }
  function mt(e3) {
    if ("JSXIdentifier" === e3.type) return e3.name;
    if ("JSXNamespacedName" === e3.type) return e3.namespace.name + ":" + e3.name.name;
    if ("JSXMemberExpression" === e3.type) return mt(e3.object) + "." + mt(e3.property);
    throw new Error("Node had unexpected type: " + e3.type);
  }
  class yt extends ge {
    constructor() {
      super(...arguments), this.tsNames = /* @__PURE__ */ new Map();
    }
  }
  class gt extends be {
    constructor() {
      super(...arguments), this.importsStack = [];
    }
    createScope(e3) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new yt(e3);
    }
    enter(e3) {
      256 == e3 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e3);
    }
    exit() {
      const e3 = super.exit();
      return 256 == e3 && this.importsStack.pop(), e3;
    }
    hasImport(e3, t3) {
      const r3 = this.importsStack.length;
      if (this.importsStack[r3 - 1].has(e3)) return true;
      if (!t3 && r3 > 1) {
        for (let t4 = 0; t4 < r3 - 1; t4++) if (this.importsStack[t4].has(e3)) return true;
      }
      return false;
    }
    declareName(e3, t3, r3) {
      if (4096 & t3) return this.hasImport(e3, true) && this.parser.raise(v.VarRedeclaration, r3, { identifierName: e3 }), void this.importsStack[this.importsStack.length - 1].add(e3);
      const n3 = this.currentScope();
      let s3 = n3.tsNames.get(e3) || 0;
      if (1024 & t3) return this.maybeExportDefined(n3, e3), void n3.tsNames.set(e3, 16 | s3);
      super.declareName(e3, t3, r3), 2 & t3 && (1 & t3 || (this.checkRedeclarationInScope(n3, e3, t3, r3), this.maybeExportDefined(n3, e3)), s3 |= 1), 256 & t3 && (s3 |= 2), 512 & t3 && (s3 |= 4), 128 & t3 && (s3 |= 8), s3 && n3.tsNames.set(e3, s3);
    }
    isRedeclaredInScope(e3, t3, r3) {
      const n3 = e3.tsNames.get(t3);
      return (2 & n3) > 0 ? !(256 & r3) || !!(512 & r3) != (4 & n3) > 0 : 128 & r3 && (8 & n3) > 0 ? !!(2 & e3.names.get(t3)) && !!(1 & r3) : !!(2 & r3 && (1 & n3) > 0) || super.isRedeclaredInScope(e3, t3, r3);
    }
    checkLocalExport(e3) {
      const { name: t3 } = e3;
      if (!this.hasImport(t3)) {
        for (let e4 = this.scopeStack.length - 1; e4 >= 0; e4--) {
          const r3 = this.scopeStack[e4].tsNames.get(t3);
          if ((1 & r3) > 0 || (16 & r3) > 0) return;
        }
        super.checkLocalExport(e3);
      }
    }
  }
  const bt = (e3) => "ParenthesizedExpression" === e3.type ? bt(e3.expression) : e3;
  class vt extends ot {
    toAssignable(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      var r3, n3;
      let s3;
      switch (("ParenthesizedExpression" === e3.type || null != (r3 = e3.extra) && r3.parenthesized) && (s3 = bt(e3), t3 ? "Identifier" === s3.type ? this.expressionScope.recordArrowParameterBindingError(v.InvalidParenthesizedAssignment, e3) : "MemberExpression" === s3.type || this.isOptionalMemberExpression(s3) || this.raise(v.InvalidParenthesizedAssignment, e3) : this.raise(v.InvalidParenthesizedAssignment, e3)), e3.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e3.type = "ObjectPattern";
          for (let r4 = 0, n4 = e3.properties.length, s4 = n4 - 1; r4 < n4; r4++) {
            var i3;
            const n5 = e3.properties[r4], o3 = r4 === s4;
            this.toAssignableObjectExpressionProp(n5, o3, t3), o3 && "RestElement" === n5.type && null != (i3 = e3.extra) && i3.trailingCommaLoc && this.raise(v.RestTrailingComma, e3.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          const { key: r4, value: n4 } = e3;
          this.isPrivateName(r4) && this.classScope.usePrivateName(this.getPrivateNameSV(r4), r4.loc.start), this.toAssignable(n4, t3);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          e3.type = "ArrayPattern", this.toAssignableList(e3.elements, null == (n3 = e3.extra) ? void 0 : n3.trailingCommaLoc, t3);
          break;
        case "AssignmentExpression":
          "=" !== e3.operator && this.raise(v.MissingEqInAssignment, e3.left.loc.end), e3.type = "AssignmentPattern", delete e3.operator, this.toAssignable(e3.left, t3);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(s3, t3);
      }
    }
    toAssignableObjectExpressionProp(e3, t3, r3) {
      if ("ObjectMethod" === e3.type) this.raise("get" === e3.kind || "set" === e3.kind ? v.PatternHasAccessor : v.PatternHasMethod, e3.key);
      else if ("SpreadElement" === e3.type) {
        e3.type = "RestElement";
        const n3 = e3.argument;
        this.checkToRestConversion(n3, false), this.toAssignable(n3, r3), t3 || this.raise(v.RestTrailingComma, e3);
      } else this.toAssignable(e3, r3);
    }
    toAssignableList(e3, t3, r3) {
      const n3 = e3.length - 1;
      for (let s3 = 0; s3 <= n3; s3++) {
        const i3 = e3[s3];
        if (i3) {
          if ("SpreadElement" === i3.type) {
            i3.type = "RestElement";
            const e4 = i3.argument;
            this.checkToRestConversion(e4, true), this.toAssignable(e4, r3);
          } else this.toAssignable(i3, r3);
          "RestElement" === i3.type && (s3 < n3 ? this.raise(v.RestTrailingComma, i3) : t3 && this.raise(v.RestTrailingComma, t3));
        }
      }
    }
    isAssignable(e3, t3) {
      switch (e3.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return true;
        case "ObjectExpression": {
          const t4 = e3.properties.length - 1;
          return e3.properties.every((e4, r3) => "ObjectMethod" !== e4.type && (r3 === t4 || "SpreadElement" !== e4.type) && this.isAssignable(e4));
        }
        case "ObjectProperty":
          return this.isAssignable(e3.value);
        case "SpreadElement":
          return this.isAssignable(e3.argument);
        case "ArrayExpression":
          return e3.elements.every((e4) => null === e4 || this.isAssignable(e4));
        case "AssignmentExpression":
          return "=" === e3.operator;
        case "ParenthesizedExpression":
          return this.isAssignable(e3.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !t3;
        default:
          return false;
      }
    }
    toReferencedList(e3, t3) {
      return e3;
    }
    toReferencedListDeep(e3, t3) {
      this.toReferencedList(e3, t3);
      for (const t4 of e3) "ArrayExpression" === (null == t4 ? void 0 : t4.type) && this.toReferencedListDeep(t4.elements);
    }
    parseSpread(e3) {
      const t3 = this.startNode();
      return this.next(), t3.argument = this.parseMaybeAssignAllowIn(e3, void 0), this.finishNode(t3, "SpreadElement");
    }
    parseRestBinding() {
      const e3 = this.startNode();
      return this.next(), e3.argument = this.parseBindingAtom(), this.finishNode(e3, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          const e3 = this.startNode();
          return this.next(), e3.elements = this.parseBindingList(3, 93, 1), this.finishNode(e3, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, true);
      }
      return this.parseIdentifier();
    }
    parseBindingList(e3, t3, r3) {
      const n3 = 1 & r3, s3 = [];
      let i3 = true;
      for (; !this.eat(e3); ) if (i3 ? i3 = false : this.expect(12), n3 && this.match(12)) s3.push(null);
      else {
        if (this.eat(e3)) break;
        if (this.match(21)) {
          if (s3.push(this.parseAssignableListItemTypes(this.parseRestBinding(), r3)), !this.checkCommaAfterRest(t3)) {
            this.expect(e3);
            break;
          }
        } else {
          const e4 = [];
          for (this.match(26) && this.hasPlugin("decorators") && this.raise(v.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) e4.push(this.parseDecorator());
          s3.push(this.parseAssignableListItem(r3, e4));
        }
      }
      return s3;
    }
    parseBindingRestProperty(e3) {
      return this.next(), e3.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e3, "RestElement");
    }
    parseBindingProperty() {
      const e3 = this.startNode(), { type: t3, startLoc: r3 } = this.state;
      return 21 === t3 ? this.parseBindingRestProperty(e3) : (138 === t3 ? (this.expectPlugin("destructuringPrivate", r3), this.classScope.usePrivateName(this.state.value, r3), e3.key = this.parsePrivateName()) : this.parsePropertyName(e3), e3.method = false, this.parseObjPropValue(e3, r3, false, false, true, false));
    }
    parseAssignableListItem(e3, t3) {
      const r3 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(r3, e3);
      const n3 = this.parseMaybeDefault(r3.loc.start, r3);
      return t3.length && (r3.decorators = t3), n3;
    }
    parseAssignableListItemTypes(e3, t3) {
      return e3;
    }
    parseMaybeDefault(e3, t3) {
      var r3;
      if (null != e3 || (e3 = this.state.startLoc), t3 = null != (r3 = t3) ? r3 : this.parseBindingAtom(), !this.eat(29)) return t3;
      const n3 = this.startNodeAt(e3);
      return n3.left = t3, n3.right = this.parseMaybeAssignAllowIn(), this.finishNode(n3, "AssignmentPattern");
    }
    isValidLVal(e3, t3, r3) {
      return n3 = { AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, s3 = e3, Object.hasOwnProperty.call(n3, s3) && n3[s3];
      var n3, s3;
    }
    isOptionalMemberExpression(e3) {
      return "OptionalMemberExpression" === e3.type;
    }
    checkLVal(e3, t3) {
      let { in: r3, binding: n3 = 64, checkClashes: s3 = false, strictModeChanged: i3 = false, hasParenthesizedAncestor: o3 = false } = t3;
      var a3;
      const l2 = e3.type;
      if (this.isObjectMethod(e3)) return;
      const c2 = this.isOptionalMemberExpression(e3);
      if (c2 || "MemberExpression" === l2) return c2 && (this.expectPlugin("optionalChainingAssign", e3.loc.start), "AssignmentExpression" !== r3.type && this.raise(v.InvalidLhsOptionalChaining, e3, { ancestor: r3 })), void (64 !== n3 && this.raise(v.InvalidPropertyBindingPattern, e3));
      if ("Identifier" === l2) {
        this.checkIdentifier(e3, n3, i3);
        const { name: t4 } = e3;
        return void (s3 && (s3.has(t4) ? this.raise(v.ParamDupe, e3) : s3.add(t4)));
      }
      const u2 = this.isValidLVal(l2, !(o3 || null != (a3 = e3.extra) && a3.parenthesized) && "AssignmentExpression" === r3.type, n3);
      if (true === u2) return;
      if (false === u2) {
        const t4 = 64 === n3 ? v.InvalidLhs : v.InvalidLhsBinding;
        return void this.raise(t4, e3, { ancestor: r3 });
      }
      const [p2, d2] = Array.isArray(u2) ? u2 : [u2, "ParenthesizedExpression" === l2], f2 = "ArrayPattern" === l2 || "ObjectPattern" === l2 ? { type: l2 } : r3;
      for (const t4 of [].concat(e3[p2])) t4 && this.checkLVal(t4, { in: f2, binding: n3, checkClashes: s3, strictModeChanged: i3, hasParenthesizedAncestor: d2 });
    }
    checkIdentifier(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      this.state.strict && (r3 ? me(e3.name, this.inModule) : he(e3.name)) && (64 === t3 ? this.raise(v.StrictEvalArguments, e3, { referenceName: e3.name }) : this.raise(v.StrictEvalArgumentsBinding, e3, { bindingName: e3.name })), 8192 & t3 && "let" === e3.name && this.raise(v.LetInLexicalBinding, e3), 64 & t3 || this.declareNameFromIdentifier(e3, t3);
    }
    declareNameFromIdentifier(e3, t3) {
      this.scope.declareName(e3.name, t3, e3.loc.start);
    }
    checkToRestConversion(e3, t3) {
      switch (e3.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(e3.expression, t3);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (t3) break;
        default:
          this.raise(v.InvalidRestAssignmentPattern, e3);
      }
    }
    checkCommaAfterRest(e3) {
      return !!this.match(12) && (this.raise(this.lookaheadCharCode() === e3 ? v.RestTrailingComma : v.ElementAfterRest, this.state.startLoc), true);
    }
  }
  function Et(e3) {
    if (!e3) throw new Error("Assert fail");
  }
  const St = b`typescript`({ AbstractMethodHasImplementation: (e3) => {
    let { methodName: t3 } = e3;
    return `Method '${t3}' cannot have an implementation because it is marked abstract.`;
  }, AbstractPropertyHasInitializer: (e3) => {
    let { propertyName: t3 } = e3;
    return `Property '${t3}' cannot have an initializer because it is marked abstract.`;
  }, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: (e3) => {
    let { kind: t3 } = e3;
    return `'declare' is not allowed in ${t3}ters.`;
  }, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: (e3) => {
    let { modifier: t3 } = e3;
    return "Accessibility modifier already seen.";
  }, DuplicateModifier: (e3) => {
    let { modifier: t3 } = e3;
    return `Duplicate modifier: '${t3}'.`;
  }, EmptyHeritageClauseType: (e3) => {
    let { token: t3 } = e3;
    return `'${t3}' list cannot be empty.`;
  }, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: (e3) => {
    let { modifiers: t3 } = e3;
    return `'${t3[0]}' modifier cannot be used with '${t3[1]}' modifier.`;
  }, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: (e3) => {
    let { modifier: t3 } = e3;
    return `Index signatures cannot have an accessibility modifier ('${t3}').`;
  }, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: (e3) => {
    let { modifier: t3 } = e3;
    return `'${t3}' modifier cannot appear on a type member.`;
  }, InvalidModifierOnTypeParameter: (e3) => {
    let { modifier: t3 } = e3;
    return `'${t3}' modifier cannot appear on a type parameter.`;
  }, InvalidModifierOnTypeParameterPositions: (e3) => {
    let { modifier: t3 } = e3;
    return `'${t3}' modifier can only appear on a type parameter of a class, interface or type alias.`;
  }, InvalidModifiersOrder: (e3) => {
    let { orderedModifiers: t3 } = e3;
    return `'${t3[0]}' modifier must precede '${t3[1]}' modifier.`;
  }, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: (e3) => {
    let { modifier: t3 } = e3;
    return `Private elements cannot have an accessibility modifier ('${t3}').`;
  }, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: (e3) => {
    let { typeParameterName: t3 } = e3;
    return `Single type parameter ${t3} should have a trailing comma. Example usage: <${t3},>.`;
  }, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: (e3) => {
    let { type: t3 } = e3;
    return `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${t3}.`;
  } });
  function xt(e3) {
    return "private" === e3 || "public" === e3 || "protected" === e3;
  }
  function Tt(e3) {
    return "in" === e3 || "out" === e3;
  }
  function wt(e3) {
    if ("MemberExpression" !== e3.type) return false;
    const { computed: t3, property: r3 } = e3;
    return (!t3 || "StringLiteral" === r3.type || !("TemplateLiteral" !== r3.type || r3.expressions.length > 0)) && Ct(e3.object);
  }
  function Pt(e3, t3) {
    var r3;
    const { type: n3 } = e3;
    if (null != (r3 = e3.extra) && r3.parenthesized) return false;
    if (t3) {
      if ("Literal" === n3) {
        const { value: t4 } = e3;
        if ("string" == typeof t4 || "boolean" == typeof t4) return true;
      }
    } else if ("StringLiteral" === n3 || "BooleanLiteral" === n3) return true;
    return !(!At(e3, t3) && !function(e4, t4) {
      if ("UnaryExpression" === e4.type) {
        const { operator: r4, argument: n4 } = e4;
        if ("-" === r4 && At(n4, t4)) return true;
      }
      return false;
    }(e3, t3)) || "TemplateLiteral" === n3 && 0 === e3.expressions.length || !!wt(e3);
  }
  function At(e3, t3) {
    return t3 ? "Literal" === e3.type && ("number" == typeof e3.value || "bigint" in e3) : "NumericLiteral" === e3.type || "BigIntLiteral" === e3.type;
  }
  function Ct(e3) {
    return "Identifier" === e3.type || "MemberExpression" === e3.type && !e3.computed && Ct(e3.object);
  }
  const Ot = b`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." });
  function It(e3, t3) {
    const [r3, n3] = "string" == typeof t3 ? [t3, {}] : t3, s3 = Object.keys(n3), i3 = 0 === s3.length;
    return e3.some((e4) => {
      if ("string" == typeof e4) return i3 && e4 === r3;
      {
        const [t4, i4] = e4;
        if (t4 !== r3) return false;
        for (const e5 of s3) if (i4[e5] !== n3[e5]) return false;
        return true;
      }
    });
  }
  function _t(e3, t3, r3) {
    const n3 = e3.find((e4) => Array.isArray(e4) ? e4[0] === t3 : e4 === t3);
    return n3 && Array.isArray(n3) && n3.length > 1 ? n3[1][r3] : null;
  }
  const kt = ["minimal", "fsharp", "hack", "smart"], Nt = ["^^", "@@", "^", "%", "#"], Dt = ["hash", "bar"], jt = { estree: (e3) => class extends e3 {
    parse() {
      const e4 = x(super.parse());
      return this.options.tokens && (e4.tokens = e4.tokens.map(x)), e4;
    }
    parseRegExpLiteral(e4) {
      let { pattern: t3, flags: r3 } = e4, n3 = null;
      try {
        n3 = new RegExp(t3, r3);
      } catch (e5) {
      }
      const s3 = this.estreeParseLiteral(n3);
      return s3.regex = { pattern: t3, flags: r3 }, s3;
    }
    parseBigIntLiteral(e4) {
      let t3;
      try {
        t3 = BigInt(e4);
      } catch (e5) {
        t3 = null;
      }
      const r3 = this.estreeParseLiteral(t3);
      return r3.bigint = String(r3.value || e4), r3;
    }
    parseDecimalLiteral(e4) {
      const t3 = this.estreeParseLiteral(null);
      return t3.decimal = String(t3.value || e4), t3;
    }
    estreeParseLiteral(e4) {
      return this.parseLiteral(e4, "Literal");
    }
    parseStringLiteral(e4) {
      return this.estreeParseLiteral(e4);
    }
    parseNumericLiteral(e4) {
      return this.estreeParseLiteral(e4);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(e4) {
      return this.estreeParseLiteral(e4);
    }
    directiveToStmt(e4) {
      const t3 = e4.value;
      delete e4.value, t3.type = "Literal", t3.raw = t3.extra.raw, t3.value = t3.extra.expressionValue;
      const r3 = e4;
      return r3.type = "ExpressionStatement", r3.expression = t3, r3.directive = t3.extra.rawValue, delete t3.extra, r3;
    }
    initFunction(e4, t3) {
      super.initFunction(e4, t3), e4.expression = false;
    }
    checkDeclaration(e4) {
      null != e4 && this.isObjectProperty(e4) ? this.checkDeclaration(e4.value) : super.checkDeclaration(e4);
    }
    getObjectOrClassMethodParams(e4) {
      return e4.value.params;
    }
    isValidDirective(e4) {
      var t3;
      return "ExpressionStatement" === e4.type && "Literal" === e4.expression.type && "string" == typeof e4.expression.value && !(null != (t3 = e4.expression.extra) && t3.parenthesized);
    }
    parseBlockBody(e4, t3, r3, n3, s3) {
      super.parseBlockBody(e4, t3, r3, n3, s3);
      const i3 = e4.directives.map((e5) => this.directiveToStmt(e5));
      e4.body = i3.concat(e4.body), delete e4.directives;
    }
    pushClassMethod(e4, t3, r3, n3, s3, i3) {
      this.parseMethod(t3, r3, n3, s3, i3, "ClassMethod", true), t3.typeParameters && (t3.value.typeParameters = t3.typeParameters, delete t3.typeParameters), e4.body.push(t3);
    }
    parsePrivateName() {
      const e4 = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e4) : e4;
    }
    convertPrivateNameToPrivateIdentifier(e4) {
      const t3 = super.getPrivateNameSV(e4);
      return delete e4.id, e4.name = t3, e4.type = "PrivateIdentifier", e4;
    }
    isPrivateName(e4) {
      return this.getPluginOption("estree", "classFeatures") ? "PrivateIdentifier" === e4.type : super.isPrivateName(e4);
    }
    getPrivateNameSV(e4) {
      return this.getPluginOption("estree", "classFeatures") ? e4.name : super.getPrivateNameSV(e4);
    }
    parseLiteral(e4, t3) {
      const r3 = super.parseLiteral(e4, t3);
      return r3.raw = r3.extra.raw, delete r3.extra, r3;
    }
    parseFunctionBody(e4, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      super.parseFunctionBody(e4, t3, r3), e4.expression = "BlockStatement" !== e4.body.type;
    }
    parseMethod(e4, t3, r3, n3, s3, i3) {
      let o3 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], a3 = this.startNode();
      return a3.kind = e4.kind, a3 = super.parseMethod(a3, t3, r3, n3, s3, i3, o3), a3.type = "FunctionExpression", delete a3.kind, e4.value = a3, "ClassPrivateMethod" === i3 && (e4.computed = false), this.finishNode(e4, "MethodDefinition");
    }
    parseClassProperty() {
      const e4 = super.parseClassProperty(...arguments);
      return this.getPluginOption("estree", "classFeatures") ? (e4.type = "PropertyDefinition", e4) : e4;
    }
    parseClassPrivateProperty() {
      const e4 = super.parseClassPrivateProperty(...arguments);
      return this.getPluginOption("estree", "classFeatures") ? (e4.type = "PropertyDefinition", e4.computed = false, e4) : e4;
    }
    parseObjectMethod(e4, t3, r3, n3, s3) {
      const i3 = super.parseObjectMethod(e4, t3, r3, n3, s3);
      return i3 && (i3.type = "Property", "method" === i3.kind && (i3.kind = "init"), i3.shorthand = false), i3;
    }
    parseObjectProperty(e4, t3, r3, n3) {
      const s3 = super.parseObjectProperty(e4, t3, r3, n3);
      return s3 && (s3.kind = "init", s3.type = "Property"), s3;
    }
    isValidLVal(e4, t3, r3) {
      return "Property" === e4 ? "value" : super.isValidLVal(e4, t3, r3);
    }
    isAssignable(e4, t3) {
      return null != e4 && this.isObjectProperty(e4) ? this.isAssignable(e4.value, t3) : super.isAssignable(e4, t3);
    }
    toAssignable(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      if (null != e4 && this.isObjectProperty(e4)) {
        const { key: r3, value: n3 } = e4;
        this.isPrivateName(r3) && this.classScope.usePrivateName(this.getPrivateNameSV(r3), r3.loc.start), this.toAssignable(n3, t3);
      } else super.toAssignable(e4, t3);
    }
    toAssignableObjectExpressionProp(e4, t3, r3) {
      "get" === e4.kind || "set" === e4.kind ? this.raise(v.PatternHasAccessor, e4.key) : e4.method ? this.raise(v.PatternHasMethod, e4.key) : super.toAssignableObjectExpressionProp(e4, t3, r3);
    }
    finishCallExpression(e4, t3) {
      const r3 = super.finishCallExpression(e4, t3);
      var n3, s3;
      "Import" === r3.callee.type && (r3.type = "ImportExpression", r3.source = r3.arguments[0], (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (r3.options = null != (n3 = r3.arguments[1]) ? n3 : null, r3.attributes = null != (s3 = r3.arguments[1]) ? s3 : null), delete r3.arguments, delete r3.callee);
      return r3;
    }
    toReferencedArguments(e4) {
      "ImportExpression" !== e4.type && super.toReferencedArguments(e4);
    }
    parseExport(e4, t3) {
      const r3 = this.state.lastTokStartLoc, n3 = super.parseExport(e4, t3);
      switch (n3.type) {
        case "ExportAllDeclaration":
          n3.exported = null;
          break;
        case "ExportNamedDeclaration":
          1 === n3.specifiers.length && "ExportNamespaceSpecifier" === n3.specifiers[0].type && (n3.type = "ExportAllDeclaration", n3.exported = n3.specifiers[0].exported, delete n3.specifiers);
        case "ExportDefaultDeclaration": {
          var s3;
          const { declaration: e5 } = n3;
          "ClassDeclaration" === (null == e5 ? void 0 : e5.type) && (null == (s3 = e5.decorators) ? void 0 : s3.length) > 0 && e5.start === n3.start && this.resetStartLocation(n3, r3);
        }
      }
      return n3;
    }
    parseSubscript(e4, t3, r3, n3) {
      const s3 = super.parseSubscript(e4, t3, r3, n3);
      if (n3.optionalChainMember) {
        if ("OptionalMemberExpression" !== s3.type && "OptionalCallExpression" !== s3.type || (s3.type = s3.type.substring(8)), n3.stop) {
          const e5 = this.startNodeAtNode(s3);
          return e5.expression = s3, this.finishNode(e5, "ChainExpression");
        }
      } else "MemberExpression" !== s3.type && "CallExpression" !== s3.type || (s3.optional = false);
      return s3;
    }
    isOptionalMemberExpression(e4) {
      return "ChainExpression" === e4.type ? "MemberExpression" === e4.expression.type : super.isOptionalMemberExpression(e4);
    }
    hasPropertyAsPrivateName(e4) {
      return "ChainExpression" === e4.type && (e4 = e4.expression), super.hasPropertyAsPrivateName(e4);
    }
    isObjectProperty(e4) {
      return "Property" === e4.type && "init" === e4.kind && !e4.method;
    }
    isObjectMethod(e4) {
      return e4.method || "get" === e4.kind || "set" === e4.kind;
    }
    finishNodeAt(e4, t3, r3) {
      return x(super.finishNodeAt(e4, t3, r3));
    }
    resetStartLocation(e4, t3) {
      super.resetStartLocation(e4, t3), x(e4);
    }
    resetEndLocation(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state.lastTokEndLoc;
      super.resetEndLocation(e4, t3), x(e4);
    }
  }, jsx: (e3) => class extends e3 {
    jsxReadToken() {
      let e4 = "", t3 = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length) throw this.raise(ft.UnterminatedJsxContent, this.state.startLoc);
        const r3 = this.input.charCodeAt(this.state.pos);
        switch (r3) {
          case 60:
          case 123:
            return this.state.pos === this.state.start ? void (60 === r3 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(r3)) : (e4 += this.input.slice(t3, this.state.pos), void this.finishToken(141, e4));
          case 38:
            e4 += this.input.slice(t3, this.state.pos), e4 += this.jsxReadEntity(), t3 = this.state.pos;
            break;
          default:
            Oe(r3) ? (e4 += this.input.slice(t3, this.state.pos), e4 += this.jsxReadNewLine(true), t3 = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(e4) {
      const t3 = this.input.charCodeAt(this.state.pos);
      let r3;
      return ++this.state.pos, 13 === t3 && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, r3 = e4 ? "\n" : "\r\n") : r3 = String.fromCharCode(t3), ++this.state.curLine, this.state.lineStart = this.state.pos, r3;
    }
    jsxReadString(e4) {
      let t3 = "", r3 = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length) throw this.raise(v.UnterminatedString, this.state.startLoc);
        const n3 = this.input.charCodeAt(this.state.pos);
        if (n3 === e4) break;
        38 === n3 ? (t3 += this.input.slice(r3, this.state.pos), t3 += this.jsxReadEntity(), r3 = this.state.pos) : Oe(n3) ? (t3 += this.input.slice(r3, this.state.pos), t3 += this.jsxReadNewLine(false), r3 = this.state.pos) : ++this.state.pos;
      }
      t3 += this.input.slice(r3, this.state.pos++), this.finishToken(133, t3);
    }
    jsxReadEntity() {
      const e4 = ++this.state.pos;
      if (35 === this.codePointAtPos(this.state.pos)) {
        ++this.state.pos;
        let e5 = 10;
        120 === this.codePointAtPos(this.state.pos) && (e5 = 16, ++this.state.pos);
        const t3 = this.readInt(e5, void 0, false, "bail");
        if (null !== t3 && 59 === this.codePointAtPos(this.state.pos)) return ++this.state.pos, String.fromCodePoint(t3);
      } else {
        let t3 = 0, r3 = false;
        for (; t3++ < 10 && this.state.pos < this.length && !(r3 = 59 == this.codePointAtPos(this.state.pos)); ) ++this.state.pos;
        if (r3) {
          const t4 = this.input.slice(e4, this.state.pos), r4 = dt[t4];
          if (++this.state.pos, r4) return r4;
        }
      }
      return this.state.pos = e4, "&";
    }
    jsxReadWord() {
      let e4;
      const t3 = this.state.pos;
      do {
        e4 = this.input.charCodeAt(++this.state.pos);
      } while (le(e4) || 45 === e4);
      this.finishToken(140, this.input.slice(t3, this.state.pos));
    }
    jsxParseIdentifier() {
      const e4 = this.startNode();
      return this.match(140) ? e4.name = this.state.value : X(this.state.type) ? e4.name = J(this.state.type) : this.unexpected(), this.next(), this.finishNode(e4, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      const e4 = this.state.startLoc, t3 = this.jsxParseIdentifier();
      if (!this.eat(14)) return t3;
      const r3 = this.startNodeAt(e4);
      return r3.namespace = t3, r3.name = this.jsxParseIdentifier(), this.finishNode(r3, "JSXNamespacedName");
    }
    jsxParseElementName() {
      const e4 = this.state.startLoc;
      let t3 = this.jsxParseNamespacedName();
      if ("JSXNamespacedName" === t3.type) return t3;
      for (; this.eat(16); ) {
        const r3 = this.startNodeAt(e4);
        r3.object = t3, r3.property = this.jsxParseIdentifier(), t3 = this.finishNode(r3, "JSXMemberExpression");
      }
      return t3;
    }
    jsxParseAttributeValue() {
      let e4;
      switch (this.state.type) {
        case 5:
          return e4 = this.startNode(), this.setContext(w.brace), this.next(), e4 = this.jsxParseExpressionContainer(e4, w.j_oTag), "JSXEmptyExpression" === e4.expression.type && this.raise(ft.AttributeIsEmpty, e4), e4;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(ft.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      const e4 = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(e4, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(e4) {
      return this.next(), e4.expression = this.parseExpression(), this.setContext(w.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e4, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(e4, t3) {
      if (this.match(8)) e4.expression = this.jsxParseEmptyExpression();
      else {
        const t4 = this.parseExpression();
        e4.expression = t4;
      }
      return this.setContext(t3), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e4, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      const e4 = this.startNode();
      return this.match(5) ? (this.setContext(w.brace), this.next(), this.expect(21), e4.argument = this.parseMaybeAssignAllowIn(), this.setContext(w.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e4, "JSXSpreadAttribute")) : (e4.name = this.jsxParseNamespacedName(), e4.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e4, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(e4) {
      const t3 = this.startNodeAt(e4);
      return this.eat(143) ? this.finishNode(t3, "JSXOpeningFragment") : (t3.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(t3));
    }
    jsxParseOpeningElementAfterName(e4) {
      const t3 = [];
      for (; !this.match(56) && !this.match(143); ) t3.push(this.jsxParseAttribute());
      return e4.attributes = t3, e4.selfClosing = this.eat(56), this.expect(143), this.finishNode(e4, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(e4) {
      const t3 = this.startNodeAt(e4);
      return this.eat(143) ? this.finishNode(t3, "JSXClosingFragment") : (t3.name = this.jsxParseElementName(), this.expect(143), this.finishNode(t3, "JSXClosingElement"));
    }
    jsxParseElementAt(e4) {
      const t3 = this.startNodeAt(e4), r3 = [], n3 = this.jsxParseOpeningElementAt(e4);
      let s3 = null;
      if (!n3.selfClosing) {
        e: for (; ; ) switch (this.state.type) {
          case 142:
            if (e4 = this.state.startLoc, this.next(), this.eat(56)) {
              s3 = this.jsxParseClosingElementAt(e4);
              break e;
            }
            r3.push(this.jsxParseElementAt(e4));
            break;
          case 141:
            r3.push(this.parseExprAtom());
            break;
          case 5: {
            const e5 = this.startNode();
            this.setContext(w.brace), this.next(), this.match(21) ? r3.push(this.jsxParseSpreadChild(e5)) : r3.push(this.jsxParseExpressionContainer(e5, w.j_expr));
            break;
          }
          default:
            this.unexpected();
        }
        ht(n3) && !ht(s3) && null !== s3 ? this.raise(ft.MissingClosingTagFragment, s3) : !ht(n3) && ht(s3) ? this.raise(ft.MissingClosingTagElement, s3, { openingTagName: mt(n3.name) }) : ht(n3) || ht(s3) || mt(s3.name) !== mt(n3.name) && this.raise(ft.MissingClosingTagElement, s3, { openingTagName: mt(n3.name) });
      }
      if (ht(n3) ? (t3.openingFragment = n3, t3.closingFragment = s3) : (t3.openingElement = n3, t3.closingElement = s3), t3.children = r3, this.match(47)) throw this.raise(ft.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return ht(n3) ? this.finishNode(t3, "JSXFragment") : this.finishNode(t3, "JSXElement");
    }
    jsxParseElement() {
      const e4 = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(e4);
    }
    setContext(e4) {
      const { context: t3 } = this.state;
      t3[t3.length - 1] = e4;
    }
    parseExprAtom(e4) {
      return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(e4);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(e4) {
      const t3 = this.curContext();
      if (t3 !== w.j_expr) {
        if (t3 === w.j_oTag || t3 === w.j_cTag) {
          if (ae(e4)) return void this.jsxReadWord();
          if (62 === e4) return ++this.state.pos, void this.finishToken(143);
          if ((34 === e4 || 39 === e4) && t3 === w.j_oTag) return void this.jsxReadString(e4);
        }
        if (60 === e4 && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1)) return ++this.state.pos, void this.finishToken(142);
        super.getTokenFromCode(e4);
      } else this.jsxReadToken();
    }
    updateContext(e4) {
      const { context: t3, type: r3 } = this.state;
      if (56 === r3 && 142 === e4) t3.splice(-2, 2, w.j_cTag), this.state.canStartJSXElement = false;
      else if (142 === r3) t3.push(w.j_oTag);
      else if (143 === r3) {
        const r4 = t3[t3.length - 1];
        r4 === w.j_oTag && 56 === e4 || r4 === w.j_cTag ? (t3.pop(), this.state.canStartJSXElement = t3[t3.length - 1] === w.j_expr) : (this.setContext(w.j_expr), this.state.canStartJSXElement = true);
      } else this.state.canStartJSXElement = R[r3];
    }
  }, flow: (e3) => class extends e3 {
    constructor() {
      super(...arguments), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return Ee;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || "flow" === this.flowPragma;
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(e4, t3) {
      133 !== e4 && 13 !== e4 && 28 !== e4 && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(e4, t3);
    }
    addComment(e4) {
      if (void 0 === this.flowPragma) {
        const t3 = pt.exec(e4.value);
        if (t3) if ("flow" === t3[1]) this.flowPragma = "flow";
        else {
          if ("noflow" !== t3[1]) throw new Error("Unexpected flow pragma");
          this.flowPragma = "noflow";
        }
      }
      super.addComment(e4);
    }
    flowParseTypeInitialiser(e4) {
      const t3 = this.state.inType;
      this.state.inType = true, this.expect(e4 || 14);
      const r3 = this.flowParseType();
      return this.state.inType = t3, r3;
    }
    flowParsePredicate() {
      const e4 = this.startNode(), t3 = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > t3.index + 1 && this.raise(lt.UnexpectedSpaceBetweenModuloChecks, t3), this.eat(10) ? (e4.value = super.parseExpression(), this.expect(11), this.finishNode(e4, "DeclaredPredicate")) : this.finishNode(e4, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      const e4 = this.state.inType;
      this.state.inType = true, this.expect(14);
      let t3 = null, r3 = null;
      return this.match(54) ? (this.state.inType = e4, r3 = this.flowParsePredicate()) : (t3 = this.flowParseType(), this.state.inType = e4, this.match(54) && (r3 = this.flowParsePredicate())), [t3, r3];
    }
    flowParseDeclareClass(e4) {
      return this.next(), this.flowParseInterfaceish(e4, true), this.finishNode(e4, "DeclareClass");
    }
    flowParseDeclareFunction(e4) {
      this.next();
      const t3 = e4.id = this.parseIdentifier(), r3 = this.startNode(), n3 = this.startNode();
      this.match(47) ? r3.typeParameters = this.flowParseTypeParameterDeclaration() : r3.typeParameters = null, this.expect(10);
      const s3 = this.flowParseFunctionTypeParams();
      return r3.params = s3.params, r3.rest = s3.rest, r3.this = s3._this, this.expect(11), [r3.returnType, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), n3.typeAnnotation = this.finishNode(r3, "FunctionTypeAnnotation"), t3.typeAnnotation = this.finishNode(n3, "TypeAnnotation"), this.resetEndLocation(t3), this.semicolon(), this.scope.declareName(e4.id.name, 2048, e4.id.loc.start), this.finishNode(e4, "DeclareFunction");
    }
    flowParseDeclare(e4, t3) {
      return this.match(80) ? this.flowParseDeclareClass(e4) : this.match(68) ? this.flowParseDeclareFunction(e4) : this.match(74) ? this.flowParseDeclareVariable(e4) : this.eatContextual(127) ? this.match(16) ? this.flowParseDeclareModuleExports(e4) : (t3 && this.raise(lt.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e4)) : this.isContextual(130) ? this.flowParseDeclareTypeAlias(e4) : this.isContextual(131) ? this.flowParseDeclareOpaqueType(e4) : this.isContextual(129) ? this.flowParseDeclareInterface(e4) : this.match(82) ? this.flowParseDeclareExportDeclaration(e4, t3) : void this.unexpected();
    }
    flowParseDeclareVariable(e4) {
      return this.next(), e4.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e4.id.name, 5, e4.id.loc.start), this.semicolon(), this.finishNode(e4, "DeclareVariable");
    }
    flowParseDeclareModule(e4) {
      this.scope.enter(0), this.match(133) ? e4.id = super.parseExprAtom() : e4.id = this.parseIdentifier();
      const t3 = e4.body = this.startNode(), r3 = t3.body = [];
      for (this.expect(5); !this.match(8); ) {
        let e5 = this.startNode();
        this.match(83) ? (this.next(), this.isContextual(130) || this.match(87) || this.raise(lt.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(e5)) : (this.expectContextual(125, lt.UnsupportedStatementInDeclareModule), e5 = this.flowParseDeclare(e5, true)), r3.push(e5);
      }
      this.scope.exit(), this.expect(8), this.finishNode(t3, "BlockStatement");
      let n3 = null, s3 = false;
      return r3.forEach((e5) => {
        !function(e6) {
          return "DeclareExportAllDeclaration" === e6.type || "DeclareExportDeclaration" === e6.type && (!e6.declaration || "TypeAlias" !== e6.declaration.type && "InterfaceDeclaration" !== e6.declaration.type);
        }(e5) ? "DeclareModuleExports" === e5.type && (s3 && this.raise(lt.DuplicateDeclareModuleExports, e5), "ES" === n3 && this.raise(lt.AmbiguousDeclareModuleKind, e5), n3 = "CommonJS", s3 = true) : ("CommonJS" === n3 && this.raise(lt.AmbiguousDeclareModuleKind, e5), n3 = "ES");
      }), e4.kind = n3 || "CommonJS", this.finishNode(e4, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(e4, t3) {
      if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? e4.declaration = this.flowParseDeclare(this.startNode()) : (e4.declaration = this.flowParseType(), this.semicolon()), e4.default = true, this.finishNode(e4, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !t3) {
        const e5 = this.state.value;
        throw this.raise(lt.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: e5, suggestion: ut[e5] });
      }
      return this.match(74) || this.match(68) || this.match(80) || this.isContextual(131) ? (e4.declaration = this.flowParseDeclare(this.startNode()), e4.default = false, this.finishNode(e4, "DeclareExportDeclaration")) : this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131) ? ("ExportNamedDeclaration" === (e4 = this.parseExport(e4, null)).type && (e4.type = "ExportDeclaration", e4.default = false, delete e4.exportKind), e4.type = "Declare" + e4.type, e4) : void this.unexpected();
    }
    flowParseDeclareModuleExports(e4) {
      return this.next(), this.expectContextual(111), e4.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e4, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(e4) {
      this.next();
      const t3 = this.flowParseTypeAlias(e4);
      return t3.type = "DeclareTypeAlias", t3;
    }
    flowParseDeclareOpaqueType(e4) {
      this.next();
      const t3 = this.flowParseOpaqueType(e4, true);
      return t3.type = "DeclareOpaqueType", t3;
    }
    flowParseDeclareInterface(e4) {
      return this.next(), this.flowParseInterfaceish(e4, false), this.finishNode(e4, "DeclareInterface");
    }
    flowParseInterfaceish(e4, t3) {
      if (e4.id = this.flowParseRestrictedIdentifier(!t3, true), this.scope.declareName(e4.id.name, t3 ? 17 : 8201, e4.id.loc.start), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.extends = [], this.eat(81)) do {
        e4.extends.push(this.flowParseInterfaceExtends());
      } while (!t3 && this.eat(12));
      if (t3) {
        if (e4.implements = [], e4.mixins = [], this.eatContextual(117)) do {
          e4.mixins.push(this.flowParseInterfaceExtends());
        } while (this.eat(12));
        if (this.eatContextual(113)) do {
          e4.implements.push(this.flowParseInterfaceExtends());
        } while (this.eat(12));
      }
      e4.body = this.flowParseObjectType({ allowStatic: t3, allowExact: false, allowSpread: false, allowProto: t3, allowInexact: false });
    }
    flowParseInterfaceExtends() {
      const e4 = this.startNode();
      return e4.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterInstantiation() : e4.typeParameters = null, this.finishNode(e4, "InterfaceExtends");
    }
    flowParseInterface(e4) {
      return this.flowParseInterfaceish(e4, false), this.finishNode(e4, "InterfaceDeclaration");
    }
    checkNotUnderscore(e4) {
      "_" === e4 && this.raise(lt.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(e4, t3, r3) {
      at.has(e4) && this.raise(r3 ? lt.AssignReservedType : lt.UnexpectedReservedType, t3, { reservedType: e4 });
    }
    flowParseRestrictedIdentifier(e4, t3) {
      return this.checkReservedType(this.state.value, this.state.startLoc, t3), this.parseIdentifier(e4);
    }
    flowParseTypeAlias(e4) {
      return e4.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e4.id.name, 8201, e4.id.loc.start), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e4, "TypeAlias");
    }
    flowParseOpaqueType(e4, t3) {
      return this.expectContextual(130), e4.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e4.id.name, 8201, e4.id.loc.start), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.supertype = null, this.match(14) && (e4.supertype = this.flowParseTypeInitialiser(14)), e4.impltype = null, t3 || (e4.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e4, "OpaqueType");
    }
    flowParseTypeParameter() {
      let e4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      const t3 = this.state.startLoc, r3 = this.startNode(), n3 = this.flowParseVariance(), s3 = this.flowParseTypeAnnotatableIdentifier();
      return r3.name = s3.name, r3.variance = n3, r3.bound = s3.typeAnnotation, this.match(29) ? (this.eat(29), r3.default = this.flowParseType()) : e4 && this.raise(lt.MissingTypeParamDefault, t3), this.finishNode(r3, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      const e4 = this.state.inType, t3 = this.startNode();
      t3.params = [], this.state.inType = true, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let r3 = false;
      do {
        const e5 = this.flowParseTypeParameter(r3);
        t3.params.push(e5), e5.default && (r3 = true), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = e4, this.finishNode(t3, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      const e4 = this.startNode(), t3 = this.state.inType;
      e4.params = [], this.state.inType = true, this.expect(47);
      const r3 = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = false; !this.match(48); ) e4.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = r3, this.expect(48), this.state.inType = t3, this.finishNode(e4, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      const e4 = this.startNode(), t3 = this.state.inType;
      for (e4.params = [], this.state.inType = true, this.expect(47); !this.match(48); ) e4.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = t3, this.finishNode(e4, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      const e4 = this.startNode();
      if (this.expectContextual(129), e4.extends = [], this.eat(81)) do {
        e4.extends.push(this.flowParseInterfaceExtends());
      } while (this.eat(12));
      return e4.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e4, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
    }
    flowParseObjectTypeIndexer(e4, t3, r3) {
      return e4.static = t3, 14 === this.lookahead().type ? (e4.id = this.flowParseObjectPropertyKey(), e4.key = this.flowParseTypeInitialiser()) : (e4.id = null, e4.key = this.flowParseType()), this.expect(3), e4.value = this.flowParseTypeInitialiser(), e4.variance = r3, this.finishNode(e4, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(e4, t3) {
      return e4.static = t3, e4.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e4.method = true, e4.optional = false, e4.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e4.loc.start))) : (e4.method = false, this.eat(17) && (e4.optional = true), e4.value = this.flowParseTypeInitialiser()), this.finishNode(e4, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(e4) {
      for (e4.params = [], e4.rest = null, e4.typeParameters = null, e4.this = null, this.match(47) && (e4.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e4.this = this.flowParseFunctionTypeParam(true), e4.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e4.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (e4.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e4.returnType = this.flowParseTypeInitialiser(), this.finishNode(e4, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(e4, t3) {
      const r3 = this.startNode();
      return e4.static = t3, e4.value = this.flowParseObjectTypeMethodish(r3), this.finishNode(e4, "ObjectTypeCallProperty");
    }
    flowParseObjectType(e4) {
      let { allowStatic: t3, allowExact: r3, allowSpread: n3, allowProto: s3, allowInexact: i3 } = e4;
      const o3 = this.state.inType;
      this.state.inType = true;
      const a3 = this.startNode();
      let l2, c2;
      a3.callProperties = [], a3.properties = [], a3.indexers = [], a3.internalSlots = [];
      let u2 = false;
      for (r3 && this.match(6) ? (this.expect(6), l2 = 9, c2 = true) : (this.expect(5), l2 = 8, c2 = false), a3.exact = c2; !this.match(l2); ) {
        let e5 = false, r4 = null, o4 = null;
        const l3 = this.startNode();
        if (s3 && this.isContextual(118)) {
          const e6 = this.lookahead();
          14 !== e6.type && 17 !== e6.type && (this.next(), r4 = this.state.startLoc, t3 = false);
        }
        if (t3 && this.isContextual(106)) {
          const t4 = this.lookahead();
          14 !== t4.type && 17 !== t4.type && (this.next(), e5 = true);
        }
        const p3 = this.flowParseVariance();
        if (this.eat(0)) null != r4 && this.unexpected(r4), this.eat(0) ? (p3 && this.unexpected(p3.loc.start), a3.internalSlots.push(this.flowParseObjectTypeInternalSlot(l3, e5))) : a3.indexers.push(this.flowParseObjectTypeIndexer(l3, e5, p3));
        else if (this.match(10) || this.match(47)) null != r4 && this.unexpected(r4), p3 && this.unexpected(p3.loc.start), a3.callProperties.push(this.flowParseObjectTypeCallProperty(l3, e5));
        else {
          let t4 = "init";
          (this.isContextual(99) || this.isContextual(104)) && H(this.lookahead().type) && (t4 = this.state.value, this.next());
          const s4 = this.flowParseObjectTypeProperty(l3, e5, r4, p3, t4, n3, null != i3 ? i3 : !c2);
          null === s4 ? (u2 = true, o4 = this.state.lastTokStartLoc) : a3.properties.push(s4);
        }
        this.flowObjectTypeSemicolon(), !o4 || this.match(8) || this.match(9) || this.raise(lt.UnexpectedExplicitInexactInObject, o4);
      }
      this.expect(l2), n3 && (a3.inexact = u2);
      const p2 = this.finishNode(a3, "ObjectTypeAnnotation");
      return this.state.inType = o3, p2;
    }
    flowParseObjectTypeProperty(e4, t3, r3, n3, s3, i3, o3) {
      if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (i3 ? o3 || this.raise(lt.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(lt.InexactInsideNonObject, this.state.lastTokStartLoc), n3 && this.raise(lt.InexactVariance, n3), null) : (i3 || this.raise(lt.UnexpectedSpreadType, this.state.lastTokStartLoc), null != r3 && this.unexpected(r3), n3 && this.raise(lt.SpreadVariance, n3), e4.argument = this.flowParseType(), this.finishNode(e4, "ObjectTypeSpreadProperty"));
      {
        e4.key = this.flowParseObjectPropertyKey(), e4.static = t3, e4.proto = null != r3, e4.kind = s3;
        let o4 = false;
        return this.match(47) || this.match(10) ? (e4.method = true, null != r3 && this.unexpected(r3), n3 && this.unexpected(n3.loc.start), e4.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e4.loc.start)), "get" !== s3 && "set" !== s3 || this.flowCheckGetterSetterParams(e4), !i3 && "constructor" === e4.key.name && e4.value.this && this.raise(lt.ThisParamBannedInConstructor, e4.value.this)) : ("init" !== s3 && this.unexpected(), e4.method = false, this.eat(17) && (o4 = true), e4.value = this.flowParseTypeInitialiser(), e4.variance = n3), e4.optional = o4, this.finishNode(e4, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(e4) {
      const t3 = "get" === e4.kind ? 0 : 1, r3 = e4.value.params.length + (e4.value.rest ? 1 : 0);
      e4.value.this && this.raise("get" === e4.kind ? lt.GetterMayNotHaveThisParam : lt.SetterMayNotHaveThisParam, e4.value.this), r3 !== t3 && this.raise("get" === e4.kind ? v.BadGetterArity : v.BadSetterArity, e4), "set" === e4.kind && e4.value.rest && this.raise(v.BadSetterRestParameter, e4);
    }
    flowObjectTypeSemicolon() {
      this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(e4, t3) {
      null != e4 || (e4 = this.state.startLoc);
      let r3 = t3 || this.flowParseRestrictedIdentifier(true);
      for (; this.eat(16); ) {
        const t4 = this.startNodeAt(e4);
        t4.qualification = r3, t4.id = this.flowParseRestrictedIdentifier(true), r3 = this.finishNode(t4, "QualifiedTypeIdentifier");
      }
      return r3;
    }
    flowParseGenericType(e4, t3) {
      const r3 = this.startNodeAt(e4);
      return r3.typeParameters = null, r3.id = this.flowParseQualifiedTypeIdentifier(e4, t3), this.match(47) && (r3.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r3, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      const e4 = this.startNode();
      return this.expect(87), e4.argument = this.flowParsePrimaryType(), this.finishNode(e4, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      const e4 = this.startNode();
      for (e4.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e4.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
      return this.expect(3), this.finishNode(e4, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(e4) {
      let t3 = null, r3 = false, n3 = null;
      const s3 = this.startNode(), i3 = this.lookahead(), o3 = 78 === this.state.type;
      return 14 === i3.type || 17 === i3.type ? (o3 && !e4 && this.raise(lt.ThisParamMustBeFirst, s3), t3 = this.parseIdentifier(o3), this.eat(17) && (r3 = true, o3 && this.raise(lt.ThisParamMayNotBeOptional, s3)), n3 = this.flowParseTypeInitialiser()) : n3 = this.flowParseType(), s3.name = t3, s3.optional = r3, s3.typeAnnotation = n3, this.finishNode(s3, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(e4) {
      const t3 = this.startNodeAt(e4.loc.start);
      return t3.name = null, t3.optional = false, t3.typeAnnotation = e4, this.finishNode(t3, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams() {
      let e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t3 = null, r3 = null;
      for (this.match(78) && (r3 = this.flowParseFunctionTypeParam(true), r3.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e4.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
      return this.eat(21) && (t3 = this.flowParseFunctionTypeParam(false)), { params: e4, rest: t3, _this: r3 };
    }
    flowIdentToTypeAnnotation(e4, t3, r3) {
      switch (r3.name) {
        case "any":
          return this.finishNode(t3, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(t3, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(t3, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(t3, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(t3, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(t3, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(t3, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(r3.name), this.flowParseGenericType(e4, r3);
      }
    }
    flowParsePrimaryType() {
      const e4 = this.state.startLoc, t3 = this.startNode();
      let r3, n3, s3 = false;
      const i3 = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
        case 6:
          return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
        case 0:
          return this.state.noAnonFunctionType = false, n3 = this.flowParseTupleType(), this.state.noAnonFunctionType = i3, n3;
        case 47:
          return t3.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), r3 = this.flowParseFunctionTypeParams(), t3.params = r3.params, t3.rest = r3.rest, t3.this = r3._this, this.expect(11), this.expect(19), t3.returnType = this.flowParseType(), this.finishNode(t3, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21)) if (W(this.state.type) || this.match(78)) {
            const e5 = this.lookahead().type;
            s3 = 17 !== e5 && 14 !== e5;
          } else s3 = true;
          if (s3) {
            if (this.state.noAnonFunctionType = false, n3 = this.flowParseType(), this.state.noAnonFunctionType = i3, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && 19 === this.lookahead().type)) return this.expect(11), n3;
            this.eat(12);
          }
          return r3 = n3 ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(n3)]) : this.flowParseFunctionTypeParams(), t3.params = r3.params, t3.rest = r3.rest, t3.this = r3._this, this.expect(11), this.expect(19), t3.returnType = this.flowParseType(), t3.typeParameters = null, this.finishNode(t3, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return t3.value = this.match(85), this.next(), this.finishNode(t3, "BooleanLiteralTypeAnnotation");
        case 53:
          if ("-" === this.state.value) {
            if (this.next(), this.match(134)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", t3);
            if (this.match(135)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", t3);
            throw this.raise(lt.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          return void this.unexpected();
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(t3, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(t3, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(t3, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(t3, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (X(this.state.type)) {
            const e5 = J(this.state.type);
            return this.next(), super.createIdentifier(t3, e5);
          }
          if (W(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e4, t3, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      const e4 = this.state.startLoc;
      let t3 = this.flowParsePrimaryType(), r3 = false;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        const n3 = this.startNodeAt(e4), s3 = this.eat(18);
        r3 = r3 || s3, this.expect(0), !s3 && this.match(3) ? (n3.elementType = t3, this.next(), t3 = this.finishNode(n3, "ArrayTypeAnnotation")) : (n3.objectType = t3, n3.indexType = this.flowParseType(), this.expect(3), r3 ? (n3.optional = s3, t3 = this.finishNode(n3, "OptionalIndexedAccessType")) : t3 = this.finishNode(n3, "IndexedAccessType"));
      }
      return t3;
    }
    flowParsePrefixType() {
      const e4 = this.startNode();
      return this.eat(17) ? (e4.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e4, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      const e4 = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        const t3 = this.startNodeAt(e4.loc.start);
        return t3.params = [this.reinterpretTypeAsFunctionTypeParam(e4)], t3.rest = null, t3.this = null, t3.returnType = this.flowParseType(), t3.typeParameters = null, this.finishNode(t3, "FunctionTypeAnnotation");
      }
      return e4;
    }
    flowParseIntersectionType() {
      const e4 = this.startNode();
      this.eat(45);
      const t3 = this.flowParseAnonFunctionWithoutParens();
      for (e4.types = [t3]; this.eat(45); ) e4.types.push(this.flowParseAnonFunctionWithoutParens());
      return 1 === e4.types.length ? t3 : this.finishNode(e4, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      const e4 = this.startNode();
      this.eat(43);
      const t3 = this.flowParseIntersectionType();
      for (e4.types = [t3]; this.eat(43); ) e4.types.push(this.flowParseIntersectionType());
      return 1 === e4.types.length ? t3 : this.finishNode(e4, "UnionTypeAnnotation");
    }
    flowParseType() {
      const e4 = this.state.inType;
      this.state.inType = true;
      const t3 = this.flowParseUnionType();
      return this.state.inType = e4, t3;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (132 === this.state.type && "_" === this.state.value) {
        const e4 = this.state.startLoc, t3 = this.parseIdentifier();
        return this.flowParseGenericType(e4, t3);
      }
      return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      const e4 = this.startNode();
      return e4.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e4, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(e4) {
      const t3 = e4 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (t3.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t3)), t3;
    }
    typeCastToParameter(e4) {
      return e4.expression.typeAnnotation = e4.typeAnnotation, this.resetEndLocation(e4.expression, e4.typeAnnotation.loc.end), e4.expression;
    }
    flowParseVariance() {
      let e4 = null;
      return this.match(53) ? (e4 = this.startNode(), "+" === this.state.value ? e4.kind = "plus" : e4.kind = "minus", this.next(), this.finishNode(e4, "Variance")) : e4;
    }
    parseFunctionBody(e4, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      t3 ? this.forwardNoArrowParamsConversionAt(e4, () => super.parseFunctionBody(e4, true, r3)) : super.parseFunctionBody(e4, false, r3);
    }
    parseFunctionBodyAndFinish(e4, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      if (this.match(14)) {
        const t4 = this.startNode();
        [t4.typeAnnotation, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), e4.returnType = t4.typeAnnotation ? this.finishNode(t4, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(e4, t3, r3);
    }
    parseStatementLike(e4) {
      if (this.state.strict && this.isContextual(129)) {
        if (G(this.lookahead().type)) {
          const e5 = this.startNode();
          return this.next(), this.flowParseInterface(e5);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        const e5 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e5);
      }
      const t3 = super.parseStatementLike(e4);
      return void 0 !== this.flowPragma || this.isValidDirective(t3) || (this.flowPragma = null), t3;
    }
    parseExpressionStatement(e4, t3, r3) {
      if ("Identifier" === t3.type) {
        if ("declare" === t3.name) {
          if (this.match(80) || W(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e4);
        } else if (W(this.state.type)) {
          if ("interface" === t3.name) return this.flowParseInterface(e4);
          if ("type" === t3.name) return this.flowParseTypeAlias(e4);
          if ("opaque" === t3.name) return this.flowParseOpaqueType(e4, false);
        }
      }
      return super.parseExpressionStatement(e4, t3, r3);
    }
    shouldParseExportDeclaration() {
      const { type: e4 } = this.state;
      return K(e4) || this.shouldParseEnums() && 126 === e4 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      const { type: e4 } = this.state;
      return K(e4) || this.shouldParseEnums() && 126 === e4 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        const e4 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(e4);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(e4, t3, r3) {
      if (!this.match(17)) return e4;
      if (this.state.maybeInArrowParameters) {
        const t4 = this.lookaheadCharCode();
        if (44 === t4 || 61 === t4 || 58 === t4 || 41 === t4) return this.setOptionalParametersError(r3), e4;
      }
      this.expect(17);
      const n3 = this.state.clone(), s3 = this.state.noArrowAt, i3 = this.startNodeAt(t3);
      let { consequent: o3, failed: a3 } = this.tryParseConditionalConsequent(), [l2, c2] = this.getArrowLikeExpressions(o3);
      if (a3 || c2.length > 0) {
        const e5 = [...s3];
        if (c2.length > 0) {
          this.state = n3, this.state.noArrowAt = e5;
          for (let t4 = 0; t4 < c2.length; t4++) e5.push(c2[t4].start);
          ({ consequent: o3, failed: a3 } = this.tryParseConditionalConsequent()), [l2, c2] = this.getArrowLikeExpressions(o3);
        }
        a3 && l2.length > 1 && this.raise(lt.AmbiguousConditionalArrow, n3.startLoc), a3 && 1 === l2.length && (this.state = n3, e5.push(l2[0].start), this.state.noArrowAt = e5, { consequent: o3, failed: a3 } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(o3, true), this.state.noArrowAt = s3, this.expect(14), i3.test = e4, i3.consequent = o3, i3.alternate = this.forwardNoArrowParamsConversionAt(i3, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(i3, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const e4 = this.parseMaybeAssignAllowIn(), t3 = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), { consequent: e4, failed: t3 };
    }
    getArrowLikeExpressions(e4, t3) {
      const r3 = [e4], n3 = [];
      for (; 0 !== r3.length; ) {
        const e5 = r3.pop();
        "ArrowFunctionExpression" === e5.type ? (e5.typeParameters || !e5.returnType ? this.finishArrowValidation(e5) : n3.push(e5), r3.push(e5.body)) : "ConditionalExpression" === e5.type && (r3.push(e5.consequent), r3.push(e5.alternate));
      }
      return t3 ? (n3.forEach((e5) => this.finishArrowValidation(e5)), [n3, []]) : function(e5, t4) {
        const r4 = [], n4 = [];
        for (let s3 = 0; s3 < e5.length; s3++) (t4(e5[s3]) ? r4 : n4).push(e5[s3]);
        return [r4, n4];
      }(n3, (e5) => e5.params.every((e6) => this.isAssignable(e6, true)));
    }
    finishArrowValidation(e4) {
      var t3;
      this.toAssignableList(e4.params, null == (t3 = e4.extra) ? void 0 : t3.trailingCommaLoc, false), this.scope.enter(6), super.checkParams(e4, false, true), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(e4, t3) {
      let r3;
      return -1 !== this.state.noArrowParamsConversionAt.indexOf(e4.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), r3 = t3(), this.state.noArrowParamsConversionAt.pop()) : r3 = t3(), r3;
    }
    parseParenItem(e4, t3) {
      if (e4 = super.parseParenItem(e4, t3), this.eat(17) && (e4.optional = true, this.resetEndLocation(e4)), this.match(14)) {
        const r3 = this.startNodeAt(t3);
        return r3.expression = e4, r3.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r3, "TypeCastExpression");
      }
      return e4;
    }
    assertModuleNodeAllowed(e4) {
      "ImportDeclaration" === e4.type && ("type" === e4.importKind || "typeof" === e4.importKind) || "ExportNamedDeclaration" === e4.type && "type" === e4.exportKind || "ExportAllDeclaration" === e4.type && "type" === e4.exportKind || super.assertModuleNodeAllowed(e4);
    }
    parseExportDeclaration(e4) {
      if (this.isContextual(130)) {
        e4.exportKind = "type";
        const t3 = this.startNode();
        return this.next(), this.match(5) ? (e4.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e4), null) : this.flowParseTypeAlias(t3);
      }
      if (this.isContextual(131)) {
        e4.exportKind = "type";
        const t3 = this.startNode();
        return this.next(), this.flowParseOpaqueType(t3, false);
      }
      if (this.isContextual(129)) {
        e4.exportKind = "type";
        const t3 = this.startNode();
        return this.next(), this.flowParseInterface(t3);
      }
      if (this.shouldParseEnums() && this.isContextual(126)) {
        e4.exportKind = "value";
        const t3 = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(t3);
      }
      return super.parseExportDeclaration(e4);
    }
    eatExportStar(e4) {
      return !!super.eatExportStar(e4) || !(!this.isContextual(130) || 55 !== this.lookahead().type) && (e4.exportKind = "type", this.next(), this.next(), true);
    }
    maybeParseExportNamespaceSpecifier(e4) {
      const { startLoc: t3 } = this.state, r3 = super.maybeParseExportNamespaceSpecifier(e4);
      return r3 && "type" === e4.exportKind && this.unexpected(t3), r3;
    }
    parseClassId(e4, t3, r3) {
      super.parseClassId(e4, t3, r3), this.match(47) && (e4.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(e4, t3, r3) {
      const { startLoc: n3 } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(e4, t3)) return;
        t3.declare = true;
      }
      super.parseClassMember(e4, t3, r3), t3.declare && ("ClassProperty" !== t3.type && "ClassPrivateProperty" !== t3.type && "PropertyDefinition" !== t3.type ? this.raise(lt.DeclareClassElement, n3) : t3.value && this.raise(lt.DeclareClassFieldInitializer, t3.value));
    }
    isIterator(e4) {
      return "iterator" === e4 || "asyncIterator" === e4;
    }
    readIterator() {
      const e4 = super.readWord1(), t3 = "@@" + e4;
      this.isIterator(e4) && this.state.inType || this.raise(v.InvalidIdentifier, this.state.curPosition(), { identifierName: t3 }), this.finishToken(132, t3);
    }
    getTokenFromCode(e4) {
      const t3 = this.input.charCodeAt(this.state.pos + 1);
      123 === e4 && 124 === t3 ? this.finishOp(6, 2) : !this.state.inType || 62 !== e4 && 60 !== e4 ? this.state.inType && 63 === e4 ? 46 === t3 ? this.finishOp(18, 2) : this.finishOp(17, 1) : function(e5, t4, r3) {
        return 64 === e5 && 64 === t4 && ae(r3);
      }(e4, t3, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e4) : this.finishOp(62 === e4 ? 48 : 47, 1);
    }
    isAssignable(e4, t3) {
      return "TypeCastExpression" === e4.type ? this.isAssignable(e4.expression, t3) : super.isAssignable(e4, t3);
    }
    toAssignable(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      t3 || "AssignmentExpression" !== e4.type || "TypeCastExpression" !== e4.left.type || (e4.left = this.typeCastToParameter(e4.left)), super.toAssignable(e4, t3);
    }
    toAssignableList(e4, t3, r3) {
      for (let t4 = 0; t4 < e4.length; t4++) {
        const r4 = e4[t4];
        "TypeCastExpression" === (null == r4 ? void 0 : r4.type) && (e4[t4] = this.typeCastToParameter(r4));
      }
      super.toAssignableList(e4, t3, r3);
    }
    toReferencedList(e4, t3) {
      for (let n3 = 0; n3 < e4.length; n3++) {
        var r3;
        const s3 = e4[n3];
        !s3 || "TypeCastExpression" !== s3.type || null != (r3 = s3.extra) && r3.parenthesized || !(e4.length > 1) && t3 || this.raise(lt.TypeCastInPattern, s3.typeAnnotation);
      }
      return e4;
    }
    parseArrayLike(e4, t3, r3, n3) {
      const s3 = super.parseArrayLike(e4, t3, r3, n3);
      return t3 && !this.state.maybeInArrowParameters && this.toReferencedList(s3.elements), s3;
    }
    isValidLVal(e4, t3, r3) {
      return "TypeCastExpression" === e4 || super.isValidLVal(e4, t3, r3);
    }
    parseClassProperty(e4) {
      return this.match(14) && (e4.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e4);
    }
    parseClassPrivateProperty(e4) {
      return this.match(14) && (e4.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e4);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(e4) {
      return !this.match(14) && super.isNonstaticConstructor(e4);
    }
    pushClassMethod(e4, t3, r3, n3, s3, i3) {
      if (t3.variance && this.unexpected(t3.variance.loc.start), delete t3.variance, this.match(47) && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e4, t3, r3, n3, s3, i3), t3.params && s3) {
        const e5 = t3.params;
        e5.length > 0 && this.isThisParam(e5[0]) && this.raise(lt.ThisParamBannedInConstructor, t3);
      } else if ("MethodDefinition" === t3.type && s3 && t3.value.params) {
        const e5 = t3.value.params;
        e5.length > 0 && this.isThisParam(e5[0]) && this.raise(lt.ThisParamBannedInConstructor, t3);
      }
    }
    pushClassPrivateMethod(e4, t3, r3, n3) {
      t3.variance && this.unexpected(t3.variance.loc.start), delete t3.variance, this.match(47) && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e4, t3, r3, n3);
    }
    parseClassSuper(e4) {
      if (super.parseClassSuper(e4), e4.superClass && this.match(47) && (e4.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
        this.next();
        const t3 = e4.implements = [];
        do {
          const e5 = this.startNode();
          e5.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? e5.typeParameters = this.flowParseTypeParameterInstantiation() : e5.typeParameters = null, t3.push(this.finishNode(e5, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(e4) {
      super.checkGetterSetterParams(e4);
      const t3 = this.getObjectOrClassMethodParams(e4);
      if (t3.length > 0) {
        const r3 = t3[0];
        this.isThisParam(r3) && "get" === e4.kind ? this.raise(lt.GetterMayNotHaveThisParam, r3) : this.isThisParam(r3) && this.raise(lt.SetterMayNotHaveThisParam, r3);
      }
    }
    parsePropertyNamePrefixOperator(e4) {
      e4.variance = this.flowParseVariance();
    }
    parseObjPropValue(e4, t3, r3, n3, s3, i3, o3) {
      let a3;
      e4.variance && this.unexpected(e4.variance.loc.start), delete e4.variance, this.match(47) && !i3 && (a3 = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      const l2 = super.parseObjPropValue(e4, t3, r3, n3, s3, i3, o3);
      return a3 && ((l2.value || l2).typeParameters = a3), l2;
    }
    parseAssignableListItemTypes(e4) {
      return this.eat(17) && ("Identifier" !== e4.type && this.raise(lt.PatternIsOptional, e4), this.isThisParam(e4) && this.raise(lt.ThisParamMayNotBeOptional, e4), e4.optional = true), this.match(14) ? e4.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e4) && this.raise(lt.ThisParamAnnotationRequired, e4), this.match(29) && this.isThisParam(e4) && this.raise(lt.ThisParamNoDefault, e4), this.resetEndLocation(e4), e4;
    }
    parseMaybeDefault(e4, t3) {
      const r3 = super.parseMaybeDefault(e4, t3);
      return "AssignmentPattern" === r3.type && r3.typeAnnotation && r3.right.start < r3.typeAnnotation.start && this.raise(lt.TypeBeforeInitializer, r3.typeAnnotation), r3;
    }
    checkImportReflection(e4) {
      super.checkImportReflection(e4), e4.module && "value" !== e4.importKind && this.raise(lt.ImportReflectionHasImportType, e4.specifiers[0].loc.start);
    }
    parseImportSpecifierLocal(e4, t3, r3) {
      t3.local = ct(e4) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e4.specifiers.push(this.finishImportSpecifier(t3, r3));
    }
    isPotentialImportPhase(e4) {
      if (super.isPotentialImportPhase(e4)) return true;
      if (this.isContextual(130)) {
        if (!e4) return true;
        const t3 = this.lookaheadCharCode();
        return 123 === t3 || 42 === t3;
      }
      return !e4 && this.isContextual(87);
    }
    applyImportPhase(e4, t3, r3, n3) {
      if (super.applyImportPhase(e4, t3, r3, n3), t3) {
        if (!r3 && this.match(65)) return;
        e4.exportKind = "type" === r3 ? r3 : "value";
      } else "type" === r3 && this.match(55) && this.unexpected(), e4.importKind = "type" === r3 || "typeof" === r3 ? r3 : "value";
    }
    parseImportSpecifier(e4, t3, r3, n3, s3) {
      const i3 = e4.imported;
      let o3 = null;
      "Identifier" === i3.type && ("type" === i3.name ? o3 = "type" : "typeof" === i3.name && (o3 = "typeof"));
      let a3 = false;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        const t4 = this.parseIdentifier(true);
        null === o3 || G(this.state.type) ? (e4.imported = i3, e4.importKind = null, e4.local = this.parseIdentifier()) : (e4.imported = t4, e4.importKind = o3, e4.local = it(t4));
      } else {
        if (null !== o3 && G(this.state.type)) e4.imported = this.parseIdentifier(true), e4.importKind = o3;
        else {
          if (t3) throw this.raise(v.ImportBindingIsString, e4, { importName: i3.value });
          e4.imported = i3, e4.importKind = null;
        }
        this.eatContextual(93) ? e4.local = this.parseIdentifier() : (a3 = true, e4.local = it(e4.imported));
      }
      const l2 = ct(e4);
      return r3 && l2 && this.raise(lt.ImportTypeShorthandOnlyInPureImport, e4), (r3 || l2) && this.checkReservedType(e4.local.name, e4.local.loc.start, true), !a3 || r3 || l2 || this.checkReservedWord(e4.local.name, e4.loc.start, true, true), this.finishImportSpecifier(e4, "ImportSpecifier");
    }
    parseBindingAtom() {
      return 78 === this.state.type ? this.parseIdentifier(true) : super.parseBindingAtom();
    }
    parseFunctionParams(e4, t3) {
      const r3 = e4.kind;
      "get" !== r3 && "set" !== r3 && this.match(47) && (e4.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e4, t3);
    }
    parseVarId(e4, t3) {
      super.parseVarId(e4, t3), this.match(14) && (e4.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e4.id));
    }
    parseAsyncArrowFromCallExpression(e4, t3) {
      if (this.match(14)) {
        const t4 = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true, e4.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = t4;
      }
      return super.parseAsyncArrowFromCallExpression(e4, t3);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(e4, t3) {
      var r3;
      let n3, s3 = null;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (s3 = this.state.clone(), n3 = this.tryParse(() => super.parseMaybeAssign(e4, t3), s3), !n3.error) return n3.node;
        const { context: r4 } = this.state, i4 = r4[r4.length - 1];
        i4 !== w.j_oTag && i4 !== w.j_expr || r4.pop();
      }
      if (null != (r3 = n3) && r3.error || this.match(47)) {
        var i3, o3;
        let r4;
        s3 = s3 || this.state.clone();
        const a3 = this.tryParse((n4) => {
          var s4;
          r4 = this.flowParseTypeParameterDeclaration();
          const i4 = this.forwardNoArrowParamsConversionAt(r4, () => {
            const n5 = super.parseMaybeAssign(e4, t3);
            return this.resetStartLocationFromNode(n5, r4), n5;
          });
          null != (s4 = i4.extra) && s4.parenthesized && n4();
          const o4 = this.maybeUnwrapTypeCastExpression(i4);
          return "ArrowFunctionExpression" !== o4.type && n4(), o4.typeParameters = r4, this.resetStartLocationFromNode(o4, r4), i4;
        }, s3);
        let l2 = null;
        if (a3.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(a3.node).type) {
          if (!a3.error && !a3.aborted) return a3.node.async && this.raise(lt.UnexpectedTypeParameterBeforeAsyncArrowFunction, r4), a3.node;
          l2 = a3.node;
        }
        if (null != (i3 = n3) && i3.node) return this.state = n3.failState, n3.node;
        if (l2) return this.state = a3.failState, l2;
        if (null != (o3 = n3) && o3.thrown) throw n3.error;
        if (a3.thrown) throw a3.error;
        throw this.raise(lt.UnexpectedTokenAfterTypeParameter, r4);
      }
      return super.parseMaybeAssign(e4, t3);
    }
    parseArrow(e4) {
      if (this.match(14)) {
        const t3 = this.tryParse(() => {
          const t4 = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const r3 = this.startNode();
          return [r3.typeAnnotation, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = t4, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r3;
        });
        if (t3.thrown) return null;
        t3.error && (this.state = t3.failState), e4.returnType = t3.node.typeAnnotation ? this.finishNode(t3.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(e4);
    }
    shouldParseArrow(e4) {
      return this.match(14) || super.shouldParseArrow(e4);
    }
    setArrowFunctionParameters(e4, t3) {
      -1 !== this.state.noArrowParamsConversionAt.indexOf(e4.start) ? e4.params = t3 : super.setArrowFunctionParameters(e4, t3);
    }
    checkParams(e4, t3, r3) {
      let n3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      if (!r3 || -1 === this.state.noArrowParamsConversionAt.indexOf(e4.start)) {
        for (let t4 = 0; t4 < e4.params.length; t4++) this.isThisParam(e4.params[t4]) && t4 > 0 && this.raise(lt.ThisParamMustBeFirst, e4.params[t4]);
        super.checkParams(e4, t3, r3, n3);
      }
    }
    parseParenAndDistinguishExpression(e4) {
      return super.parseParenAndDistinguishExpression(e4 && -1 === this.state.noArrowAt.indexOf(this.state.start));
    }
    parseSubscripts(e4, t3, r3) {
      if ("Identifier" === e4.type && "async" === e4.name && -1 !== this.state.noArrowAt.indexOf(t3.index)) {
        this.next();
        const r4 = this.startNodeAt(t3);
        r4.callee = e4, r4.arguments = super.parseCallExpressionArguments(11, false), e4 = this.finishNode(r4, "CallExpression");
      } else if ("Identifier" === e4.type && "async" === e4.name && this.match(47)) {
        const n3 = this.state.clone(), s3 = this.tryParse((e5) => this.parseAsyncArrowWithTypeParameters(t3) || e5(), n3);
        if (!s3.error && !s3.aborted) return s3.node;
        const i3 = this.tryParse(() => super.parseSubscripts(e4, t3, r3), n3);
        if (i3.node && !i3.error) return i3.node;
        if (s3.node) return this.state = s3.failState, s3.node;
        if (i3.node) return this.state = i3.failState, i3.node;
        throw s3.error || i3.error;
      }
      return super.parseSubscripts(e4, t3, r3);
    }
    parseSubscript(e4, t3, r3, n3) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (n3.optionalChainMember = true, r3) return n3.stop = true, e4;
        this.next();
        const s3 = this.startNodeAt(t3);
        return s3.callee = e4, s3.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), s3.arguments = this.parseCallExpressionArguments(11, false), s3.optional = true, this.finishCallExpression(s3, true);
      }
      if (!r3 && this.shouldParseTypes() && this.match(47)) {
        const r4 = this.startNodeAt(t3);
        r4.callee = e4;
        const s3 = this.tryParse(() => (r4.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), r4.arguments = super.parseCallExpressionArguments(11, false), n3.optionalChainMember && (r4.optional = false), this.finishCallExpression(r4, n3.optionalChainMember)));
        if (s3.node) return s3.error && (this.state = s3.failState), s3.node;
      }
      return super.parseSubscript(e4, t3, r3, n3);
    }
    parseNewCallee(e4) {
      super.parseNewCallee(e4);
      let t3 = null;
      this.shouldParseTypes() && this.match(47) && (t3 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e4.typeArguments = t3;
    }
    parseAsyncArrowWithTypeParameters(e4) {
      const t3 = this.startNodeAt(e4);
      if (this.parseFunctionParams(t3, false), this.parseArrow(t3)) return super.parseArrowExpression(t3, void 0, true);
    }
    readToken_mult_modulo(e4) {
      const t3 = this.input.charCodeAt(this.state.pos + 1);
      if (42 === e4 && 47 === t3 && this.state.hasFlowComment) return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
      super.readToken_mult_modulo(e4);
    }
    readToken_pipe_amp(e4) {
      const t3 = this.input.charCodeAt(this.state.pos + 1);
      124 !== e4 || 125 !== t3 ? super.readToken_pipe_amp(e4) : this.finishOp(9, 2);
    }
    parseTopLevel(e4, t3) {
      const r3 = super.parseTopLevel(e4, t3);
      return this.state.hasFlowComment && this.raise(lt.UnterminatedFlowComment, this.state.curPosition()), r3;
    }
    skipBlockComment() {
      if (!this.hasPlugin("flowComments") || !this.skipFlowComment()) return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
      {
        if (this.state.hasFlowComment) throw this.raise(lt.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        const e4 = this.skipFlowComment();
        e4 && (this.state.pos += e4, this.state.hasFlowComment = true);
      }
    }
    skipFlowComment() {
      const { pos: e4 } = this.state;
      let t3 = 2;
      for (; [32, 9].includes(this.input.charCodeAt(e4 + t3)); ) t3++;
      const r3 = this.input.charCodeAt(t3 + e4), n3 = this.input.charCodeAt(t3 + e4 + 1);
      return 58 === r3 && 58 === n3 ? t3 + 2 : "flow-include" === this.input.slice(t3 + e4, t3 + e4 + 12) ? t3 + 12 : 58 === r3 && 58 !== n3 && t3;
    }
    hasFlowCommentCompletion() {
      if (-1 === this.input.indexOf("*/", this.state.pos)) throw this.raise(v.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(e4, t3) {
      let { enumName: r3, memberName: n3 } = t3;
      this.raise(lt.EnumBooleanMemberNotInitialized, e4, { memberName: n3, enumName: r3 });
    }
    flowEnumErrorInvalidMemberInitializer(e4, t3) {
      return this.raise(t3.explicitType ? "symbol" === t3.explicitType ? lt.EnumInvalidMemberInitializerSymbolType : lt.EnumInvalidMemberInitializerPrimaryType : lt.EnumInvalidMemberInitializerUnknownType, e4, t3);
    }
    flowEnumErrorNumberMemberNotInitialized(e4, t3) {
      this.raise(lt.EnumNumberMemberNotInitialized, e4, t3);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(e4, t3) {
      this.raise(lt.EnumStringMemberInconsistentlyInitialized, e4, t3);
    }
    flowEnumMemberInit() {
      const e4 = this.state.startLoc, t3 = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 134: {
          const r3 = this.parseNumericLiteral(this.state.value);
          return t3() ? { type: "number", loc: r3.loc.start, value: r3 } : { type: "invalid", loc: e4 };
        }
        case 133: {
          const r3 = this.parseStringLiteral(this.state.value);
          return t3() ? { type: "string", loc: r3.loc.start, value: r3 } : { type: "invalid", loc: e4 };
        }
        case 85:
        case 86: {
          const r3 = this.parseBooleanLiteral(this.match(85));
          return t3() ? { type: "boolean", loc: r3.loc.start, value: r3 } : { type: "invalid", loc: e4 };
        }
        default:
          return { type: "invalid", loc: e4 };
      }
    }
    flowEnumMemberRaw() {
      const e4 = this.state.startLoc;
      return { id: this.parseIdentifier(true), init: this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e4 } };
    }
    flowEnumCheckExplicitTypeMismatch(e4, t3, r3) {
      const { explicitType: n3 } = t3;
      null !== n3 && n3 !== r3 && this.flowEnumErrorInvalidMemberInitializer(e4, t3);
    }
    flowEnumMembers(e4) {
      let { enumName: t3, explicitType: r3 } = e4;
      const n3 = /* @__PURE__ */ new Set(), s3 = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
      let i3 = false;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          i3 = true;
          break;
        }
        const e5 = this.startNode(), { id: o3, init: a3 } = this.flowEnumMemberRaw(), l2 = o3.name;
        if ("" === l2) continue;
        /^[a-z]/.test(l2) && this.raise(lt.EnumInvalidMemberName, o3, { memberName: l2, suggestion: l2[0].toUpperCase() + l2.slice(1), enumName: t3 }), n3.has(l2) && this.raise(lt.EnumDuplicateMemberName, o3, { memberName: l2, enumName: t3 }), n3.add(l2);
        const c2 = { enumName: t3, explicitType: r3, memberName: l2 };
        switch (e5.id = o3, a3.type) {
          case "boolean":
            this.flowEnumCheckExplicitTypeMismatch(a3.loc, c2, "boolean"), e5.init = a3.value, s3.booleanMembers.push(this.finishNode(e5, "EnumBooleanMember"));
            break;
          case "number":
            this.flowEnumCheckExplicitTypeMismatch(a3.loc, c2, "number"), e5.init = a3.value, s3.numberMembers.push(this.finishNode(e5, "EnumNumberMember"));
            break;
          case "string":
            this.flowEnumCheckExplicitTypeMismatch(a3.loc, c2, "string"), e5.init = a3.value, s3.stringMembers.push(this.finishNode(e5, "EnumStringMember"));
            break;
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(a3.loc, c2);
          case "none":
            switch (r3) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(a3.loc, c2);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(a3.loc, c2);
                break;
              default:
                s3.defaultedMembers.push(this.finishNode(e5, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return { members: s3, hasUnknownMembers: i3 };
    }
    flowEnumStringMembers(e4, t3, r3) {
      let { enumName: n3 } = r3;
      if (0 === e4.length) return t3;
      if (0 === t3.length) return e4;
      if (t3.length > e4.length) {
        for (const t4 of e4) this.flowEnumErrorStringMemberInconsistentlyInitialized(t4, { enumName: n3 });
        return t3;
      }
      for (const e5 of t3) this.flowEnumErrorStringMemberInconsistentlyInitialized(e5, { enumName: n3 });
      return e4;
    }
    flowEnumParseExplicitType(e4) {
      let { enumName: t3 } = e4;
      if (!this.eatContextual(102)) return null;
      if (!W(this.state.type)) throw this.raise(lt.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: t3 });
      const { value: r3 } = this.state;
      return this.next(), "boolean" !== r3 && "number" !== r3 && "string" !== r3 && "symbol" !== r3 && this.raise(lt.EnumInvalidExplicitType, this.state.startLoc, { enumName: t3, invalidEnumType: r3 }), r3;
    }
    flowEnumBody(e4, t3) {
      const r3 = t3.name, n3 = t3.loc.start, s3 = this.flowEnumParseExplicitType({ enumName: r3 });
      this.expect(5);
      const { members: i3, hasUnknownMembers: o3 } = this.flowEnumMembers({ enumName: r3, explicitType: s3 });
      switch (e4.hasUnknownMembers = o3, s3) {
        case "boolean":
          return e4.explicitType = true, e4.members = i3.booleanMembers, this.expect(8), this.finishNode(e4, "EnumBooleanBody");
        case "number":
          return e4.explicitType = true, e4.members = i3.numberMembers, this.expect(8), this.finishNode(e4, "EnumNumberBody");
        case "string":
          return e4.explicitType = true, e4.members = this.flowEnumStringMembers(i3.stringMembers, i3.defaultedMembers, { enumName: r3 }), this.expect(8), this.finishNode(e4, "EnumStringBody");
        case "symbol":
          return e4.members = i3.defaultedMembers, this.expect(8), this.finishNode(e4, "EnumSymbolBody");
        default: {
          const t4 = () => (e4.members = [], this.expect(8), this.finishNode(e4, "EnumStringBody"));
          e4.explicitType = false;
          const s4 = i3.booleanMembers.length, o4 = i3.numberMembers.length, a3 = i3.stringMembers.length, l2 = i3.defaultedMembers.length;
          if (s4 || o4 || a3 || l2) {
            if (s4 || o4) {
              if (!o4 && !a3 && s4 >= l2) {
                for (const e5 of i3.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(e5.loc.start, { enumName: r3, memberName: e5.id.name });
                return e4.members = i3.booleanMembers, this.expect(8), this.finishNode(e4, "EnumBooleanBody");
              }
              if (!s4 && !a3 && o4 >= l2) {
                for (const e5 of i3.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(e5.loc.start, { enumName: r3, memberName: e5.id.name });
                return e4.members = i3.numberMembers, this.expect(8), this.finishNode(e4, "EnumNumberBody");
              }
              return this.raise(lt.EnumInconsistentMemberValues, n3, { enumName: r3 }), t4();
            }
            return e4.members = this.flowEnumStringMembers(i3.stringMembers, i3.defaultedMembers, { enumName: r3 }), this.expect(8), this.finishNode(e4, "EnumStringBody");
          }
          return t4();
        }
      }
    }
    flowParseEnumDeclaration(e4) {
      const t3 = this.parseIdentifier();
      return e4.id = t3, e4.body = this.flowEnumBody(this.startNode(), t3), this.finishNode(e4, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      const e4 = this.nextTokenStart();
      if (60 === this.input.charCodeAt(e4)) {
        const t3 = this.input.charCodeAt(e4 + 1);
        return 60 !== t3 && 61 !== t3;
      }
      return false;
    }
    maybeUnwrapTypeCastExpression(e4) {
      return "TypeCastExpression" === e4.type ? e4.expression : e4;
    }
  }, typescript: (e3) => class extends e3 {
    constructor() {
      super(...arguments), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: St.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: St.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: St.InvalidModifierOnTypeParameter });
    }
    getScopeHandler() {
      return gt;
    }
    tsIsIdentifier() {
      return W(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(e4, t3) {
      if (!W(this.state.type) && 58 !== this.state.type && 75 !== this.state.type) return;
      const r3 = this.state.value;
      if (-1 !== e4.indexOf(r3)) {
        if (t3 && this.tsIsStartOfStaticBlocks()) return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return r3;
      }
    }
    tsParseModifiers(e4, t3) {
      let { allowedModifiers: r3, disallowedModifiers: n3, stopOnStartOfClassStaticBlock: s3, errorTemplate: i3 = St.InvalidModifierOnTypeMember } = e4;
      const o3 = (e5, r4, n4, s4) => {
        r4 === n4 && t3[s4] && this.raise(St.InvalidModifiersOrder, e5, { orderedModifiers: [n4, s4] });
      }, a3 = (e5, r4, n4, s4) => {
        (t3[n4] && r4 === s4 || t3[s4] && r4 === n4) && this.raise(St.IncompatibleModifiers, e5, { modifiers: [n4, s4] });
      };
      for (; ; ) {
        const { startLoc: e5 } = this.state, l2 = this.tsParseModifier(r3.concat(null != n3 ? n3 : []), s3);
        if (!l2) break;
        xt(l2) ? t3.accessibility ? this.raise(St.DuplicateAccessibilityModifier, e5, { modifier: l2 }) : (o3(e5, l2, l2, "override"), o3(e5, l2, l2, "static"), o3(e5, l2, l2, "readonly"), t3.accessibility = l2) : Tt(l2) ? (t3[l2] && this.raise(St.DuplicateModifier, e5, { modifier: l2 }), t3[l2] = true, o3(e5, l2, "in", "out")) : (Object.hasOwnProperty.call(t3, l2) ? this.raise(St.DuplicateModifier, e5, { modifier: l2 }) : (o3(e5, l2, "static", "readonly"), o3(e5, l2, "static", "override"), o3(e5, l2, "override", "readonly"), o3(e5, l2, "abstract", "override"), a3(e5, l2, "declare", "override"), a3(e5, l2, "static", "abstract")), t3[l2] = true), null != n3 && n3.includes(l2) && this.raise(i3, e5, { modifier: l2 });
      }
    }
    tsIsListTerminator(e4) {
      switch (e4) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(e4, t3) {
      const r3 = [];
      for (; !this.tsIsListTerminator(e4); ) r3.push(t3());
      return r3;
    }
    tsParseDelimitedList(e4, t3, r3) {
      return function(e5) {
        if (null == e5) throw new Error(`Unexpected ${e5} value.`);
        return e5;
      }(this.tsParseDelimitedListWorker(e4, t3, true, r3));
    }
    tsParseDelimitedListWorker(e4, t3, r3, n3) {
      const s3 = [];
      let i3 = -1;
      for (; !this.tsIsListTerminator(e4); ) {
        i3 = -1;
        const n4 = t3();
        if (null == n4) return;
        if (s3.push(n4), !this.eat(12)) {
          if (this.tsIsListTerminator(e4)) break;
          return void (r3 && this.expect(12));
        }
        i3 = this.state.lastTokStartLoc.index;
      }
      return n3 && (n3.value = i3), s3;
    }
    tsParseBracketedList(e4, t3, r3, n3, s3) {
      n3 || (r3 ? this.expect(0) : this.expect(47));
      const i3 = this.tsParseDelimitedList(e4, t3, s3);
      return r3 ? this.expect(3) : this.expect(48), i3;
    }
    tsParseImportType() {
      const e4 = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(St.UnsupportedImportTypeArgument, this.state.startLoc), e4.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (e4.qualifier = this.tsParseEntityName()), this.match(47) && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSImportType");
    }
    tsParseEntityName() {
      let e4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], t3 = this.parseIdentifier(e4);
      for (; this.eat(16); ) {
        const r3 = this.startNodeAtNode(t3);
        r3.left = t3, r3.right = this.parseIdentifier(e4), t3 = this.finishNode(r3, "TSQualifiedName");
      }
      return t3;
    }
    tsParseTypeReference() {
      const e4 = this.startNode();
      return e4.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSTypeReference");
    }
    tsParseThisTypePredicate(e4) {
      this.next();
      const t3 = this.startNodeAtNode(e4);
      return t3.parameterName = e4, t3.typeAnnotation = this.tsParseTypeAnnotation(false), t3.asserts = false, this.finishNode(t3, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      const e4 = this.startNode();
      return this.next(), this.finishNode(e4, "TSThisType");
    }
    tsParseTypeQuery() {
      const e4 = this.startNode();
      return this.expect(87), this.match(83) ? e4.exprName = this.tsParseImportType() : e4.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSTypeQuery");
    }
    tsParseTypeParameter(e4) {
      const t3 = this.startNode();
      return e4(t3), t3.name = this.tsParseTypeParameterName(), t3.constraint = this.tsEatThenParseType(81), t3.default = this.tsEatThenParseType(29), this.finishNode(t3, "TSTypeParameter");
    }
    tsTryParseTypeParameters(e4) {
      if (this.match(47)) return this.tsParseTypeParameters(e4);
    }
    tsParseTypeParameters(e4) {
      const t3 = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      const r3 = { value: -1 };
      return t3.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e4), false, true, r3), 0 === t3.params.length && this.raise(St.EmptyTypeParameters, t3), -1 !== r3.value && this.addExtra(t3, "trailingComma", r3.value), this.finishNode(t3, "TSTypeParameterDeclaration");
    }
    tsFillSignature(e4, t3) {
      const r3 = 19 === e4;
      t3.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), t3.parameters = this.tsParseBindingListForSignature(), (r3 || this.match(e4)) && (t3.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(e4));
    }
    tsParseBindingListForSignature() {
      const e4 = super.parseBindingList(11, 41, 2);
      for (const t3 of e4) {
        const { type: e5 } = t3;
        "AssignmentPattern" !== e5 && "TSParameterProperty" !== e5 || this.raise(St.UnsupportedSignatureParameterKind, t3, { type: e5 });
      }
      return e4;
    }
    tsParseTypeMemberSemicolon() {
      this.eat(12) || this.isLineTerminator() || this.expect(13);
    }
    tsParseSignatureMember(e4, t3) {
      return this.tsFillSignature(14, t3), this.tsParseTypeMemberSemicolon(), this.finishNode(t3, e4);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), !!W(this.state.type) && (this.next(), this.match(14));
    }
    tsTryParseIndexSignature(e4) {
      if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
      this.expect(0);
      const t3 = this.parseIdentifier();
      t3.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t3), this.expect(3), e4.parameters = [t3];
      const r3 = this.tsTryParseTypeAnnotation();
      return r3 && (e4.typeAnnotation = r3), this.tsParseTypeMemberSemicolon(), this.finishNode(e4, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(e4, t3) {
      this.eat(17) && (e4.optional = true);
      const r3 = e4;
      if (this.match(10) || this.match(47)) {
        t3 && this.raise(St.ReadonlyForMethodSignature, e4);
        const n3 = r3;
        n3.kind && this.match(47) && this.raise(St.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, n3), this.tsParseTypeMemberSemicolon();
        const s3 = "parameters", i3 = "typeAnnotation";
        if ("get" === n3.kind) n3[s3].length > 0 && (this.raise(v.BadGetterArity, this.state.curPosition()), this.isThisParam(n3[s3][0]) && this.raise(St.AccesorCannotDeclareThisParameter, this.state.curPosition()));
        else if ("set" === n3.kind) {
          if (1 !== n3[s3].length) this.raise(v.BadSetterArity, this.state.curPosition());
          else {
            const e5 = n3[s3][0];
            this.isThisParam(e5) && this.raise(St.AccesorCannotDeclareThisParameter, this.state.curPosition()), "Identifier" === e5.type && e5.optional && this.raise(St.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), "RestElement" === e5.type && this.raise(St.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          n3[i3] && this.raise(St.SetAccesorCannotHaveReturnType, n3[i3]);
        } else n3.kind = "method";
        return this.finishNode(n3, "TSMethodSignature");
      }
      {
        const e5 = r3;
        t3 && (e5.readonly = true);
        const n3 = this.tsTryParseTypeAnnotation();
        return n3 && (e5.typeAnnotation = n3), this.tsParseTypeMemberSemicolon(), this.finishNode(e5, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      const e4 = this.startNode();
      if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", e4);
      if (this.match(77)) {
        const t3 = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e4) : (e4.key = this.createIdentifier(t3, "new"), this.tsParsePropertyOrMethodSignature(e4, false));
      }
      this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, e4);
      return this.tsTryParseIndexSignature(e4) || (super.parsePropertyName(e4), e4.computed || "Identifier" !== e4.key.type || "get" !== e4.key.name && "set" !== e4.key.name || !this.tsTokenCanFollowModifier() || (e4.kind = e4.key.name, super.parsePropertyName(e4)), this.tsParsePropertyOrMethodSignature(e4, !!e4.readonly));
    }
    tsParseTypeLiteral() {
      const e4 = this.startNode();
      return e4.members = this.tsParseObjectTypeMembers(), this.finishNode(e4, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      const e4 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), e4;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(58))));
    }
    tsParseMappedTypeParameter() {
      const e4 = this.startNode();
      return e4.name = this.tsParseTypeParameterName(), e4.constraint = this.tsExpectThenParseType(58), this.finishNode(e4, "TSTypeParameter");
    }
    tsParseMappedType() {
      const e4 = this.startNode();
      return this.expect(5), this.match(53) ? (e4.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e4.readonly = true), this.expect(0), e4.typeParameter = this.tsParseMappedTypeParameter(), e4.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e4.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e4.optional = true), e4.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e4, "TSMappedType");
    }
    tsParseTupleType() {
      const e4 = this.startNode();
      e4.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let t3 = false;
      return e4.elementTypes.forEach((e5) => {
        const { type: r3 } = e5;
        !t3 || "TSRestType" === r3 || "TSOptionalType" === r3 || "TSNamedTupleMember" === r3 && e5.optional || this.raise(St.OptionalTypeBeforeRequired, e5), t3 || (t3 = "TSNamedTupleMember" === r3 && e5.optional || "TSOptionalType" === r3);
      }), this.finishNode(e4, "TSTupleType");
    }
    tsParseTupleElementType() {
      const { startLoc: e4 } = this.state, t3 = this.eat(21);
      let r3, n3, s3, i3;
      const o3 = G(this.state.type) ? this.lookaheadCharCode() : null;
      if (58 === o3) r3 = true, s3 = false, n3 = this.parseIdentifier(true), this.expect(14), i3 = this.tsParseType();
      else if (63 === o3) {
        s3 = true;
        const e5 = this.state.startLoc, t4 = this.state.value, o4 = this.tsParseNonArrayType();
        58 === this.lookaheadCharCode() ? (r3 = true, n3 = this.createIdentifier(this.startNodeAt(e5), t4), this.expect(17), this.expect(14), i3 = this.tsParseType()) : (r3 = false, i3 = o4, this.expect(17));
      } else i3 = this.tsParseType(), s3 = this.eat(17), r3 = this.eat(14);
      if (r3) {
        let e5;
        n3 ? (e5 = this.startNodeAtNode(n3), e5.optional = s3, e5.label = n3, e5.elementType = i3, this.eat(17) && (e5.optional = true, this.raise(St.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (e5 = this.startNodeAtNode(i3), e5.optional = s3, this.raise(St.InvalidTupleMemberLabel, i3), e5.label = i3, e5.elementType = this.tsParseType()), i3 = this.finishNode(e5, "TSNamedTupleMember");
      } else if (s3) {
        const e5 = this.startNodeAtNode(i3);
        e5.typeAnnotation = i3, i3 = this.finishNode(e5, "TSOptionalType");
      }
      if (t3) {
        const t4 = this.startNodeAt(e4);
        t4.typeAnnotation = i3, i3 = this.finishNode(t4, "TSRestType");
      }
      return i3;
    }
    tsParseParenthesizedType() {
      const e4 = this.startNode();
      return this.expect(10), e4.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e4, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(e4, t3) {
      const r3 = this.startNode();
      return "TSConstructorType" === e4 && (r3.abstract = !!t3, t3 && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, r3)), this.finishNode(r3, e4);
    }
    tsParseLiteralTypeNode() {
      const e4 = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          e4.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(e4, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      const e4 = this.startNode();
      return e4.literal = super.parseTemplate(false), this.finishNode(e4, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      const e4 = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e4) : e4;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if ("-" === this.state.value) {
            const e4 = this.startNode(), t3 = this.lookahead();
            return 134 !== t3.type && 135 !== t3.type && this.unexpected(), e4.literal = this.parseMaybeUnary(), this.finishNode(e4, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          const { type: e4 } = this.state;
          if (W(e4) || 88 === e4 || 84 === e4) {
            const t3 = 88 === e4 ? "TSVoidKeyword" : 84 === e4 ? "TSNullKeyword" : function(e5) {
              switch (e5) {
                case "any":
                  return "TSAnyKeyword";
                case "boolean":
                  return "TSBooleanKeyword";
                case "bigint":
                  return "TSBigIntKeyword";
                case "never":
                  return "TSNeverKeyword";
                case "number":
                  return "TSNumberKeyword";
                case "object":
                  return "TSObjectKeyword";
                case "string":
                  return "TSStringKeyword";
                case "symbol":
                  return "TSSymbolKeyword";
                case "undefined":
                  return "TSUndefinedKeyword";
                case "unknown":
                  return "TSUnknownKeyword";
                default:
                  return;
              }
            }(this.state.value);
            if (void 0 !== t3 && 46 !== this.lookaheadCharCode()) {
              const e5 = this.startNode();
              return this.next(), this.finishNode(e5, t3);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let e4 = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); ) if (this.match(3)) {
        const t3 = this.startNodeAtNode(e4);
        t3.elementType = e4, this.expect(3), e4 = this.finishNode(t3, "TSArrayType");
      } else {
        const t3 = this.startNodeAtNode(e4);
        t3.objectType = e4, t3.indexType = this.tsParseType(), this.expect(3), e4 = this.finishNode(t3, "TSIndexedAccessType");
      }
      return e4;
    }
    tsParseTypeOperator() {
      const e4 = this.startNode(), t3 = this.state.value;
      return this.next(), e4.operator = t3, e4.typeAnnotation = this.tsParseTypeOperatorOrHigher(), "readonly" === t3 && this.tsCheckTypeAnnotationForReadOnly(e4), this.finishNode(e4, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(e4) {
      switch (e4.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(St.UnexpectedReadonly, e4);
      }
    }
    tsParseInferType() {
      const e4 = this.startNode();
      this.expectContextual(115);
      const t3 = this.startNode();
      return t3.name = this.tsParseTypeParameterName(), t3.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e4.typeParameter = this.finishNode(t3, "TSTypeParameter"), this.finishNode(e4, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        const e4 = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e4;
      }
    }
    tsParseTypeOperatorOrHigher() {
      var e4;
      return (e4 = this.state.type) >= 121 && e4 <= 123 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(e4, t3, r3) {
      const n3 = this.startNode(), s3 = this.eat(r3), i3 = [];
      do {
        i3.push(t3());
      } while (this.eat(r3));
      return 1 !== i3.length || s3 ? (n3.types = i3, this.finishNode(n3, e4)) : i3[0];
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return !!this.match(47) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (W(this.state.type) || this.match(78)) return this.next(), true;
      if (this.match(5)) {
        const { errors: e4 } = this.state, t3 = e4.length;
        try {
          return this.parseObjectLike(8, true), e4.length === t3;
        } catch (e5) {
          return false;
        }
      }
      if (this.match(0)) {
        this.next();
        const { errors: e4 } = this.state, t3 = e4.length;
        try {
          return super.parseBindingList(3, 93, 1), e4.length === t3;
        } catch (e5) {
          return false;
        }
      }
      return false;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      if (this.next(), this.match(11) || this.match(21)) return true;
      if (this.tsSkipParameterStart()) {
        if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) return true;
        if (this.match(11) && (this.next(), this.match(19))) return true;
      }
      return false;
    }
    tsParseTypeOrTypePredicateAnnotation(e4) {
      return this.tsInType(() => {
        const t3 = this.startNode();
        this.expect(e4);
        const r3 = this.startNode(), n3 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (n3 && this.match(78)) {
          let e5 = this.tsParseThisTypeOrThisTypePredicate();
          return "TSThisType" === e5.type ? (r3.parameterName = e5, r3.asserts = true, r3.typeAnnotation = null, e5 = this.finishNode(r3, "TSTypePredicate")) : (this.resetStartLocationFromNode(e5, r3), e5.asserts = true), t3.typeAnnotation = e5, this.finishNode(t3, "TSTypeAnnotation");
        }
        const s3 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!s3) return n3 ? (r3.parameterName = this.parseIdentifier(), r3.asserts = n3, r3.typeAnnotation = null, t3.typeAnnotation = this.finishNode(r3, "TSTypePredicate"), this.finishNode(t3, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t3);
        const i3 = this.tsParseTypeAnnotation(false);
        return r3.parameterName = s3, r3.typeAnnotation = i3, r3.asserts = n3, t3.typeAnnotation = this.finishNode(r3, "TSTypePredicate"), this.finishNode(t3, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14)) return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      const e4 = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), e4;
    }
    tsParseTypePredicateAsserts() {
      if (109 !== this.state.type) return false;
      const e4 = this.state.containsEsc;
      return this.next(), !(!W(this.state.type) && !this.match(78) || (e4 && this.raise(v.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), 0));
    }
    tsParseTypeAnnotation() {
      let e4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.startNode();
      return this.tsInType(() => {
        e4 && this.expect(14), t3.typeAnnotation = this.tsParseType();
      }), this.finishNode(t3, "TSTypeAnnotation");
    }
    tsParseType() {
      Et(this.state.inType);
      const e4 = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e4;
      const t3 = this.startNodeAtNode(e4);
      return t3.checkType = e4, t3.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), t3.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), t3.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(t3, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && 77 === this.lookahead().type;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(St.ReservedTypeAssertion, this.state.startLoc);
      const e4 = this.startNode();
      return e4.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e4.expression = this.parseMaybeUnary(), this.finishNode(e4, "TSTypeAssertion");
    }
    tsParseHeritageClause(e4) {
      const t3 = this.state.startLoc, r3 = this.tsParseDelimitedList("HeritageClauseElement", () => {
        const e5 = this.startNode();
        return e5.expression = this.tsParseEntityName(), this.match(47) && (e5.typeParameters = this.tsParseTypeArguments()), this.finishNode(e5, "TSExpressionWithTypeArguments");
      });
      return r3.length || this.raise(St.EmptyHeritageClauseType, t3, { token: e4 }), r3;
    }
    tsParseInterfaceDeclaration(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), t3.declare && (e4.declare = true), W(this.state.type) ? (e4.id = this.parseIdentifier(), this.checkIdentifier(e4.id, 130)) : (e4.id = null, this.raise(St.MissingInterfaceName, this.state.startLoc)), e4.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e4.extends = this.tsParseHeritageClause("extends"));
      const r3 = this.startNode();
      return r3.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e4.body = this.finishNode(r3, "TSInterfaceBody"), this.finishNode(e4, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(e4) {
      return e4.id = this.parseIdentifier(), this.checkIdentifier(e4.id, 2), e4.typeAnnotation = this.tsInType(() => {
        if (e4.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && 16 !== this.lookahead().type) {
          const e5 = this.startNode();
          return this.next(), this.finishNode(e5, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(e4, "TSTypeAliasDeclaration");
    }
    tsInNoContext(e4) {
      const t3 = this.state.context;
      this.state.context = [t3[0]];
      try {
        return e4();
      } finally {
        this.state.context = t3;
      }
    }
    tsInType(e4) {
      const t3 = this.state.inType;
      this.state.inType = true;
      try {
        return e4();
      } finally {
        this.state.inType = t3;
      }
    }
    tsInDisallowConditionalTypesContext(e4) {
      const t3 = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = true;
      try {
        return e4();
      } finally {
        this.state.inDisallowConditionalTypesContext = t3;
      }
    }
    tsInAllowConditionalTypesContext(e4) {
      const t3 = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = false;
      try {
        return e4();
      } finally {
        this.state.inDisallowConditionalTypesContext = t3;
      }
    }
    tsEatThenParseType(e4) {
      if (this.match(e4)) return this.tsNextThenParseType();
    }
    tsExpectThenParseType(e4) {
      return this.tsInType(() => (this.expect(e4), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      const e4 = this.startNode();
      return e4.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e4.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e4, "TSEnumMember");
    }
    tsParseEnumDeclaration(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3.const && (e4.const = true), t3.declare && (e4.declare = true), this.expectContextual(126), e4.id = this.parseIdentifier(), this.checkIdentifier(e4.id, e4.const ? 8971 : 8459), this.expect(5), e4.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e4, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      const e4 = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(e4.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e4, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      if (e4.id = this.parseIdentifier(), t3 || this.checkIdentifier(e4.id, 1024), this.eat(16)) {
        const t4 = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(t4, true), e4.body = t4;
      } else this.scope.enter(256), this.prodParam.enter(0), e4.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(e4, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(e4) {
      return this.isContextual(112) ? (e4.global = true, e4.id = this.parseIdentifier()) : this.match(133) ? e4.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), e4.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e4, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(e4, t3, r3) {
      e4.isExport = r3 || false, e4.id = t3 || this.parseIdentifier(), this.checkIdentifier(e4.id, 4096), this.expect(29);
      const n3 = this.tsParseModuleReference();
      return "type" === e4.importKind && "TSExternalModuleReference" !== n3.type && this.raise(St.ImportAliasHasImportType, n3), e4.moduleReference = n3, this.semicolon(), this.finishNode(e4, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && 40 === this.lookaheadCharCode();
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }
    tsParseExternalModuleReference() {
      const e4 = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), e4.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = true, this.finishNode(e4, "TSExternalModuleReference");
    }
    tsLookAhead(e4) {
      const t3 = this.state.clone(), r3 = e4();
      return this.state = t3, r3;
    }
    tsTryParseAndCatch(e4) {
      const t3 = this.tryParse((t4) => e4() || t4());
      if (!t3.aborted && t3.node) return t3.error && (this.state = t3.failState), t3.node;
    }
    tsTryParse(e4) {
      const t3 = this.state.clone(), r3 = e4();
      if (void 0 !== r3 && false !== r3) return r3;
      this.state = t3;
    }
    tsTryParseDeclare(e4) {
      if (this.isLineTerminator()) return;
      let t3, r3 = this.state.type;
      return this.isContextual(100) && (r3 = 74, t3 = "let"), this.tsInAmbientContext(() => {
        switch (r3) {
          case 68:
            return e4.declare = true, super.parseFunctionStatement(e4, false, false);
          case 80:
            return e4.declare = true, this.parseClass(e4, true, false);
          case 126:
            return this.tsParseEnumDeclaration(e4, { declare: true });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(e4);
          case 75:
          case 74:
            return this.match(75) && this.isLookaheadContextual("enum") ? (this.expect(75), this.tsParseEnumDeclaration(e4, { const: true, declare: true })) : (e4.declare = true, this.parseVarStatement(e4, t3 || this.state.value, true));
          case 129: {
            const t4 = this.tsParseInterfaceDeclaration(e4, { declare: true });
            if (t4) return t4;
          }
          default:
            if (W(r3)) return this.tsParseDeclaration(e4, this.state.value, true, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
    }
    tsParseExpressionStatement(e4, t3, r3) {
      switch (t3.name) {
        case "declare": {
          const t4 = this.tsTryParseDeclare(e4);
          return t4 && (t4.declare = true), t4;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            const r4 = e4;
            return r4.global = true, r4.id = t3, r4.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r4, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(e4, t3.name, false, r3);
      }
    }
    tsParseDeclaration(e4, t3, r3, n3) {
      switch (t3) {
        case "abstract":
          if (this.tsCheckLineTerminator(r3) && (this.match(80) || W(this.state.type))) return this.tsParseAbstractDeclaration(e4, n3);
          break;
        case "module":
          if (this.tsCheckLineTerminator(r3)) {
            if (this.match(133)) return this.tsParseAmbientExternalModuleDeclaration(e4);
            if (W(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e4);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(r3) && W(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e4);
          break;
        case "type":
          if (this.tsCheckLineTerminator(r3) && W(this.state.type)) return this.tsParseTypeAliasDeclaration(e4);
      }
    }
    tsCheckLineTerminator(e4) {
      return e4 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(e4) {
      if (!this.match(47)) return;
      const t3 = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      const r3 = this.tsTryParseAndCatch(() => {
        const t4 = this.startNodeAt(e4);
        return t4.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(t4), t4.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), t4;
      });
      return this.state.maybeInArrowParameters = t3, r3 ? super.parseArrowExpression(r3, null, true) : void 0;
    }
    tsParseTypeArgumentsInExpression() {
      if (47 === this.reScan_lt()) return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      const e4 = this.startNode();
      return e4.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), 0 === e4.params.length ? this.raise(St.EmptyTypeArguments, e4) : this.state.inType || this.curContext() !== w.brace || this.reScan_lt_gt(), this.expect(48), this.finishNode(e4, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return (e4 = this.state.type) >= 124 && e4 <= 130;
      var e4;
    }
    isExportDefaultSpecifier() {
      return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(e4, t3) {
      const r3 = this.state.startLoc, n3 = {};
      this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, n3);
      const s3 = n3.accessibility, i3 = n3.override, o3 = n3.readonly;
      4 & e4 || !(s3 || o3 || i3) || this.raise(St.UnexpectedParameterModifier, r3);
      const a3 = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(a3, e4);
      const l2 = this.parseMaybeDefault(a3.loc.start, a3);
      if (s3 || o3 || i3) {
        const e5 = this.startNodeAt(r3);
        return t3.length && (e5.decorators = t3), s3 && (e5.accessibility = s3), o3 && (e5.readonly = o3), i3 && (e5.override = i3), "Identifier" !== l2.type && "AssignmentPattern" !== l2.type && this.raise(St.UnsupportedParameterPropertyKind, e5), e5.parameter = l2, this.finishNode(e5, "TSParameterProperty");
      }
      return t3.length && (a3.decorators = t3), l2;
    }
    isSimpleParameter(e4) {
      return "TSParameterProperty" === e4.type && super.isSimpleParameter(e4.parameter) || super.isSimpleParameter(e4);
    }
    tsDisallowOptionalPattern(e4) {
      for (const t3 of e4.params) "Identifier" !== t3.type && t3.optional && !this.state.isAmbientContext && this.raise(St.PatternIsOptional, t3);
    }
    setArrowFunctionParameters(e4, t3, r3) {
      super.setArrowFunctionParameters(e4, t3, r3), this.tsDisallowOptionalPattern(e4);
    }
    parseFunctionBodyAndFinish(e4, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      this.match(14) && (e4.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      const n3 = "FunctionDeclaration" === t3 ? "TSDeclareFunction" : "ClassMethod" === t3 || "ClassPrivateMethod" === t3 ? "TSDeclareMethod" : void 0;
      return n3 && !this.match(5) && this.isLineTerminator() ? this.finishNode(e4, n3) : "TSDeclareFunction" === n3 && this.state.isAmbientContext && (this.raise(St.DeclareFunctionHasImplementation, e4), e4.declare) ? super.parseFunctionBodyAndFinish(e4, n3, r3) : (this.tsDisallowOptionalPattern(e4), super.parseFunctionBodyAndFinish(e4, t3, r3));
    }
    registerFunctionStatementId(e4) {
      !e4.body && e4.id ? this.checkIdentifier(e4.id, 1024) : super.registerFunctionStatementId(e4);
    }
    tsCheckForInvalidTypeCasts(e4) {
      e4.forEach((e5) => {
        "TSTypeCastExpression" === (null == e5 ? void 0 : e5.type) && this.raise(St.UnexpectedTypeAnnotation, e5.typeAnnotation);
      });
    }
    toReferencedList(e4, t3) {
      return this.tsCheckForInvalidTypeCasts(e4), e4;
    }
    parseArrayLike(e4, t3, r3, n3) {
      const s3 = super.parseArrayLike(e4, t3, r3, n3);
      return "ArrayExpression" === s3.type && this.tsCheckForInvalidTypeCasts(s3.elements), s3;
    }
    parseSubscript(e4, t3, r3, n3) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = false, this.next();
        const r4 = this.startNodeAt(t3);
        return r4.expression = e4, this.finishNode(r4, "TSNonNullExpression");
      }
      let s3 = false;
      if (this.match(18) && 60 === this.lookaheadCharCode()) {
        if (r3) return n3.stop = true, e4;
        n3.optionalChainMember = s3 = true, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let i3;
        const o3 = this.tsTryParseAndCatch(() => {
          if (!r3 && this.atPossibleAsyncArrow(e4)) {
            const e5 = this.tsTryParseGenericAsyncArrowFunction(t3);
            if (e5) return e5;
          }
          const o4 = this.tsParseTypeArgumentsInExpression();
          if (!o4) return;
          if (s3 && !this.match(10)) return void (i3 = this.state.curPosition());
          if (Q(this.state.type)) {
            const r4 = super.parseTaggedTemplateExpression(e4, t3, n3);
            return r4.typeParameters = o4, r4;
          }
          if (!r3 && this.eat(10)) {
            const r4 = this.startNodeAt(t3);
            return r4.callee = e4, r4.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(r4.arguments), r4.typeParameters = o4, n3.optionalChainMember && (r4.optional = s3), this.finishCallExpression(r4, n3.optionalChainMember);
          }
          const a3 = this.state.type;
          if (48 === a3 || 52 === a3 || 10 !== a3 && z(a3) && !this.hasPrecedingLineBreak()) return;
          const l2 = this.startNodeAt(t3);
          return l2.expression = e4, l2.typeParameters = o4, this.finishNode(l2, "TSInstantiationExpression");
        });
        if (i3 && this.unexpected(i3, 10), o3) return "TSInstantiationExpression" === o3.type && (this.match(16) || this.match(18) && 40 !== this.lookaheadCharCode()) && this.raise(St.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), o3;
      }
      return super.parseSubscript(e4, t3, r3, n3);
    }
    parseNewCallee(e4) {
      var t3;
      super.parseNewCallee(e4);
      const { callee: r3 } = e4;
      "TSInstantiationExpression" !== r3.type || null != (t3 = r3.extra) && t3.parenthesized || (e4.typeParameters = r3.typeParameters, e4.callee = r3.expression);
    }
    parseExprOp(e4, t3, r3) {
      let n3;
      if (Y(58) > r3 && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n3 = this.isContextual(120)))) {
        const s3 = this.startNodeAt(t3);
        return s3.expression = e4, s3.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (n3 && this.raise(v.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(s3, n3 ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(s3, t3, r3);
      }
      return super.parseExprOp(e4, t3, r3);
    }
    checkReservedWord(e4, t3, r3, n3) {
      this.state.isAmbientContext || super.checkReservedWord(e4, t3, r3, n3);
    }
    checkImportReflection(e4) {
      super.checkImportReflection(e4), e4.module && "value" !== e4.importKind && this.raise(St.ImportReflectionHasImportType, e4.specifiers[0].loc.start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(e4) {
      if (super.isPotentialImportPhase(e4)) return true;
      if (this.isContextual(130)) {
        const t3 = this.lookaheadCharCode();
        return e4 ? 123 === t3 || 42 === t3 : 61 !== t3;
      }
      return !e4 && this.isContextual(87);
    }
    applyImportPhase(e4, t3, r3, n3) {
      super.applyImportPhase(e4, t3, r3, n3), t3 ? e4.exportKind = "type" === r3 ? "type" : "value" : e4.importKind = "type" === r3 || "typeof" === r3 ? r3 : "value";
    }
    parseImport(e4) {
      if (this.match(133)) return e4.importKind = "value", super.parseImport(e4);
      let t3;
      if (W(this.state.type) && 61 === this.lookaheadCharCode()) return e4.importKind = "value", this.tsParseImportEqualsDeclaration(e4);
      if (this.isContextual(130)) {
        const r3 = this.parseMaybeImportPhase(e4, false);
        if (61 === this.lookaheadCharCode()) return this.tsParseImportEqualsDeclaration(e4, r3);
        t3 = super.parseImportSpecifiersAndAfter(e4, r3);
      } else t3 = super.parseImport(e4);
      return "type" === t3.importKind && t3.specifiers.length > 1 && "ImportDefaultSpecifier" === t3.specifiers[0].type && this.raise(St.TypeImportCannotSpecifyDefaultAndNamed, t3), t3;
    }
    parseExport(e4, t3) {
      if (this.match(83)) {
        this.next();
        let t4 = null;
        return this.isContextual(130) && this.isPotentialImportPhase(false) ? t4 = this.parseMaybeImportPhase(e4, false) : e4.importKind = "value", this.tsParseImportEqualsDeclaration(e4, t4, true);
      }
      if (this.eat(29)) {
        const t4 = e4;
        return t4.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(t4, "TSExportAssignment");
      }
      if (this.eatContextual(93)) {
        const t4 = e4;
        return this.expectContextual(128), t4.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t4, "TSNamespaceExportDeclaration");
      }
      return super.parseExport(e4, t3);
    }
    isAbstractClass() {
      return this.isContextual(124) && 80 === this.lookahead().type;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const e4 = this.startNode();
        return this.next(), e4.abstract = true, this.parseClass(e4, true, true);
      }
      if (this.match(129)) {
        const e4 = this.tsParseInterfaceDeclaration(this.startNode());
        if (e4) return e4;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(e4, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      const { isAmbientContext: n3 } = this.state, s3 = super.parseVarStatement(e4, t3, r3 || n3);
      if (!n3) return s3;
      for (const { id: e5, init: r4 } of s3.declarations) r4 && ("const" !== t3 || e5.typeAnnotation ? this.raise(St.InitializerNotAllowedInAmbientContext, r4) : Pt(r4, this.hasPlugin("estree")) || this.raise(St.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, r4));
      return s3;
    }
    parseStatementContent(e4, t3) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        const e5 = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(e5, { const: true });
      }
      if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        const e5 = this.tsParseInterfaceDeclaration(this.startNode());
        if (e5) return e5;
      }
      return super.parseStatementContent(e4, t3);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(e4, t3) {
      return t3.some((t4) => xt(t4) ? e4.accessibility === t4 : !!e4[t4]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && 123 === this.lookaheadCharCode();
    }
    parseClassMember(e4, t3, r3) {
      const n3 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({ allowedModifiers: n3, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: St.InvalidModifierOnTypeParameterPositions }, t3);
      const s3 = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t3, n3) && this.raise(St.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e4, t3)) : this.parseClassMemberWithIsStatic(e4, t3, r3, !!t3.static);
      };
      t3.declare ? this.tsInAmbientContext(s3) : s3();
    }
    parseClassMemberWithIsStatic(e4, t3, r3, n3) {
      const s3 = this.tsTryParseIndexSignature(t3);
      if (s3) return e4.body.push(s3), t3.abstract && this.raise(St.IndexSignatureHasAbstract, t3), t3.accessibility && this.raise(St.IndexSignatureHasAccessibility, t3, { modifier: t3.accessibility }), t3.declare && this.raise(St.IndexSignatureHasDeclare, t3), void (t3.override && this.raise(St.IndexSignatureHasOverride, t3));
      !this.state.inAbstractClass && t3.abstract && this.raise(St.NonAbstractClassHasAbstractMethod, t3), t3.override && (r3.hadSuperClass || this.raise(St.OverrideNotInSubClass, t3)), super.parseClassMemberWithIsStatic(e4, t3, r3, n3);
    }
    parsePostMemberNameModifiers(e4) {
      this.eat(17) && (e4.optional = true), e4.readonly && this.match(10) && this.raise(St.ClassMethodHasReadonly, e4), e4.declare && this.match(10) && this.raise(St.ClassMethodHasDeclare, e4);
    }
    parseExpressionStatement(e4, t3, r3) {
      return ("Identifier" === t3.type ? this.tsParseExpressionStatement(e4, t3, r3) : void 0) || super.parseExpressionStatement(e4, t3, r3);
    }
    shouldParseExportDeclaration() {
      return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
    }
    parseConditional(e4, t3, r3) {
      if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(e4, t3, r3);
      const n3 = this.tryParse(() => super.parseConditional(e4, t3));
      return n3.node ? (n3.error && (this.state = n3.failState), n3.node) : (n3.error && super.setOptionalParametersError(r3, n3.error), e4);
    }
    parseParenItem(e4, t3) {
      if (e4 = super.parseParenItem(e4, t3), this.eat(17) && (e4.optional = true, this.resetEndLocation(e4)), this.match(14)) {
        const r3 = this.startNodeAt(t3);
        return r3.expression = e4, r3.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r3, "TSTypeCastExpression");
      }
      return e4;
    }
    parseExportDeclaration(e4) {
      if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e4));
      const t3 = this.state.startLoc, r3 = this.eatContextual(125);
      if (r3 && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(St.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      const n3 = W(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e4);
      return n3 ? (("TSInterfaceDeclaration" === n3.type || "TSTypeAliasDeclaration" === n3.type || r3) && (e4.exportKind = "type"), r3 && (this.resetStartLocation(n3, t3), n3.declare = true), n3) : null;
    }
    parseClassId(e4, t3, r3, n3) {
      if ((!t3 || r3) && this.isContextual(113)) return;
      super.parseClassId(e4, t3, r3, e4.declare ? 1024 : 8331);
      const s3 = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      s3 && (e4.typeParameters = s3);
    }
    parseClassPropertyAnnotation(e4) {
      e4.optional || (this.eat(35) ? e4.definite = true : this.eat(17) && (e4.optional = true));
      const t3 = this.tsTryParseTypeAnnotation();
      t3 && (e4.typeAnnotation = t3);
    }
    parseClassProperty(e4) {
      if (this.parseClassPropertyAnnotation(e4), this.state.isAmbientContext && (!e4.readonly || e4.typeAnnotation) && this.match(29) && this.raise(St.DeclareClassFieldHasInitializer, this.state.startLoc), e4.abstract && this.match(29)) {
        const { key: t3 } = e4;
        this.raise(St.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: "Identifier" !== t3.type || e4.computed ? `[${this.input.slice(t3.start, t3.end)}]` : t3.name });
      }
      return super.parseClassProperty(e4);
    }
    parseClassPrivateProperty(e4) {
      return e4.abstract && this.raise(St.PrivateElementHasAbstract, e4), e4.accessibility && this.raise(St.PrivateElementHasAccessibility, e4, { modifier: e4.accessibility }), this.parseClassPropertyAnnotation(e4), super.parseClassPrivateProperty(e4);
    }
    parseClassAccessorProperty(e4) {
      return this.parseClassPropertyAnnotation(e4), e4.optional && this.raise(St.AccessorCannotBeOptional, e4), super.parseClassAccessorProperty(e4);
    }
    pushClassMethod(e4, t3, r3, n3, s3, i3) {
      const o3 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o3 && s3 && this.raise(St.ConstructorHasTypeParameters, o3);
      const { declare: a3 = false, kind: l2 } = t3;
      !a3 || "get" !== l2 && "set" !== l2 || this.raise(St.DeclareAccessor, t3, { kind: l2 }), o3 && (t3.typeParameters = o3), super.pushClassMethod(e4, t3, r3, n3, s3, i3);
    }
    pushClassPrivateMethod(e4, t3, r3, n3) {
      const s3 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      s3 && (t3.typeParameters = s3), super.pushClassPrivateMethod(e4, t3, r3, n3);
    }
    declareClassPrivateMethodInScope(e4, t3) {
      "TSDeclareMethod" !== e4.type && ("MethodDefinition" !== e4.type || e4.value.body) && super.declareClassPrivateMethodInScope(e4, t3);
    }
    parseClassSuper(e4) {
      super.parseClassSuper(e4), e4.superClass && (this.match(47) || this.match(51)) && (e4.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e4.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(e4, t3, r3, n3, s3, i3, o3) {
      const a3 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return a3 && (e4.typeParameters = a3), super.parseObjPropValue(e4, t3, r3, n3, s3, i3, o3);
    }
    parseFunctionParams(e4, t3) {
      const r3 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      r3 && (e4.typeParameters = r3), super.parseFunctionParams(e4, t3);
    }
    parseVarId(e4, t3) {
      super.parseVarId(e4, t3), "Identifier" === e4.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (e4.definite = true);
      const r3 = this.tsTryParseTypeAnnotation();
      r3 && (e4.id.typeAnnotation = r3, this.resetEndLocation(e4.id));
    }
    parseAsyncArrowFromCallExpression(e4, t3) {
      return this.match(14) && (e4.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e4, t3);
    }
    parseMaybeAssign(e4, t3) {
      var r3, n3, s3, i3, o3;
      let a3, l2, c2, u2;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (a3 = this.state.clone(), l2 = this.tryParse(() => super.parseMaybeAssign(e4, t3), a3), !l2.error) return l2.node;
        const { context: r4 } = this.state, n4 = r4[r4.length - 1];
        n4 !== w.j_oTag && n4 !== w.j_expr || r4.pop();
      }
      if (!(null != (r3 = l2) && r3.error || this.match(47))) return super.parseMaybeAssign(e4, t3);
      a3 && a3 !== this.state || (a3 = this.state.clone());
      const p2 = this.tryParse((r4) => {
        var n4, s4;
        u2 = this.tsParseTypeParameters(this.tsParseConstModifier);
        const i4 = super.parseMaybeAssign(e4, t3);
        return ("ArrowFunctionExpression" !== i4.type || null != (n4 = i4.extra) && n4.parenthesized) && r4(), 0 !== (null == (s4 = u2) ? void 0 : s4.params.length) && this.resetStartLocationFromNode(i4, u2), i4.typeParameters = u2, i4;
      }, a3);
      if (!p2.error && !p2.aborted) return u2 && this.reportReservedArrowTypeParam(u2), p2.node;
      if (!l2 && (Et(!this.hasPlugin("jsx")), c2 = this.tryParse(() => super.parseMaybeAssign(e4, t3), a3), !c2.error)) return c2.node;
      if (null != (n3 = l2) && n3.node) return this.state = l2.failState, l2.node;
      if (p2.node) return this.state = p2.failState, u2 && this.reportReservedArrowTypeParam(u2), p2.node;
      if (null != (s3 = c2) && s3.node) return this.state = c2.failState, c2.node;
      throw (null == (i3 = l2) ? void 0 : i3.error) || p2.error || (null == (o3 = c2) ? void 0 : o3.error);
    }
    reportReservedArrowTypeParam(e4) {
      var t3;
      1 !== e4.params.length || e4.params[0].constraint || null != (t3 = e4.extra) && t3.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(St.ReservedArrowTypeParam, e4);
    }
    parseMaybeUnary(e4, t3) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e4, t3);
    }
    parseArrow(e4) {
      if (this.match(14)) {
        const t3 = this.tryParse((e5) => {
          const t4 = this.tsParseTypeOrTypePredicateAnnotation(14);
          return !this.canInsertSemicolon() && this.match(19) || e5(), t4;
        });
        if (t3.aborted) return;
        t3.thrown || (t3.error && (this.state = t3.failState), e4.returnType = t3.node);
      }
      return super.parseArrow(e4);
    }
    parseAssignableListItemTypes(e4, t3) {
      if (!(2 & t3)) return e4;
      this.eat(17) && (e4.optional = true);
      const r3 = this.tsTryParseTypeAnnotation();
      return r3 && (e4.typeAnnotation = r3), this.resetEndLocation(e4), e4;
    }
    isAssignable(e4, t3) {
      switch (e4.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(e4.expression, t3);
        case "TSParameterProperty":
          return true;
        default:
          return super.isAssignable(e4, t3);
      }
    }
    toAssignable(e4) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      switch (e4.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(e4, t3);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          t3 ? this.expressionScope.recordArrowParameterBindingError(St.UnexpectedTypeCastInParameter, e4) : this.raise(St.UnexpectedTypeCastInParameter, e4), this.toAssignable(e4.expression, t3);
          break;
        case "AssignmentExpression":
          t3 || "TSTypeCastExpression" !== e4.left.type || (e4.left = this.typeCastToParameter(e4.left));
        default:
          super.toAssignable(e4, t3);
      }
    }
    toAssignableParenthesizedExpression(e4, t3) {
      switch (e4.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(e4.expression, t3);
          break;
        default:
          super.toAssignable(e4, t3);
      }
    }
    checkToRestConversion(e4, t3) {
      switch (e4.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(e4.expression, false);
          break;
        default:
          super.checkToRestConversion(e4, t3);
      }
    }
    isValidLVal(e4, t3, r3) {
      return n3 = { TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (64 !== r3 || !t3) && ["expression", true], TSSatisfiesExpression: (64 !== r3 || !t3) && ["expression", true], TSTypeAssertion: (64 !== r3 || !t3) && ["expression", true] }, s3 = e4, Object.hasOwnProperty.call(n3, s3) && n3[s3] || super.isValidLVal(e4, t3, r3);
      var n3, s3;
    }
    parseBindingAtom() {
      return 78 === this.state.type ? this.parseIdentifier(true) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(e4) {
      if (this.match(47) || this.match(51)) {
        const t3 = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          const r3 = super.parseMaybeDecoratorArguments(e4);
          return r3.typeParameters = t3, r3;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(e4);
    }
    checkCommaAfterRest(e4) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e4 ? (this.next(), false) : super.checkCommaAfterRest(e4);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(e4, t3) {
      const r3 = super.parseMaybeDefault(e4, t3);
      return "AssignmentPattern" === r3.type && r3.typeAnnotation && r3.right.start < r3.typeAnnotation.start && this.raise(St.TypeAnnotationAfterAssign, r3.typeAnnotation), r3;
    }
    getTokenFromCode(e4) {
      if (this.state.inType) {
        if (62 === e4) return void this.finishOp(48, 1);
        if (60 === e4) return void this.finishOp(47, 1);
      }
      super.getTokenFromCode(e4);
    }
    reScan_lt_gt() {
      const { type: e4 } = this.state;
      47 === e4 ? (this.state.pos -= 1, this.readToken_lt()) : 48 === e4 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      const { type: e4 } = this.state;
      return 51 === e4 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e4;
    }
    toAssignableList(e4, t3, r3) {
      for (let t4 = 0; t4 < e4.length; t4++) {
        const r4 = e4[t4];
        "TSTypeCastExpression" === (null == r4 ? void 0 : r4.type) && (e4[t4] = this.typeCastToParameter(r4));
      }
      super.toAssignableList(e4, t3, r3);
    }
    typeCastToParameter(e4) {
      return e4.expression.typeAnnotation = e4.typeAnnotation, this.resetEndLocation(e4.expression, e4.typeAnnotation.loc.end), e4.expression;
    }
    shouldParseArrow(e4) {
      return this.match(14) ? e4.every((e5) => this.isAssignable(e5, true)) : super.shouldParseArrow(e4);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(e4) {
      if (this.match(47) || this.match(51)) {
        const t3 = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        t3 && (e4.typeParameters = t3);
      }
      return super.jsxParseOpeningElementAfterName(e4);
    }
    getGetterSetterExpectedParamCount(e4) {
      const t3 = super.getGetterSetterExpectedParamCount(e4), r3 = this.getObjectOrClassMethodParams(e4)[0];
      return r3 && this.isThisParam(r3) ? t3 + 1 : t3;
    }
    parseCatchClauseParam() {
      const e4 = super.parseCatchClauseParam(), t3 = this.tsTryParseTypeAnnotation();
      return t3 && (e4.typeAnnotation = t3, this.resetEndLocation(e4)), e4;
    }
    tsInAmbientContext(e4) {
      const t3 = this.state.isAmbientContext;
      this.state.isAmbientContext = true;
      try {
        return e4();
      } finally {
        this.state.isAmbientContext = t3;
      }
    }
    parseClass(e4, t3, r3) {
      const n3 = this.state.inAbstractClass;
      this.state.inAbstractClass = !!e4.abstract;
      try {
        return super.parseClass(e4, t3, r3);
      } finally {
        this.state.inAbstractClass = n3;
      }
    }
    tsParseAbstractDeclaration(e4, t3) {
      if (this.match(80)) return e4.abstract = true, this.maybeTakeDecorators(t3, this.parseClass(e4, true, false));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak()) return e4.abstract = true, this.raise(St.NonClassMethodPropertyHasAbstractModifer, e4), this.tsParseInterfaceDeclaration(e4);
      } else this.unexpected(null, 80);
    }
    parseMethod(e4, t3, r3, n3, s3, i3, o3) {
      const a3 = super.parseMethod(e4, t3, r3, n3, s3, i3, o3);
      if (a3.abstract && (this.hasPlugin("estree") ? a3.value.body : a3.body)) {
        const { key: e5 } = a3;
        this.raise(St.AbstractMethodHasImplementation, a3, { methodName: "Identifier" !== e5.type || a3.computed ? `[${this.input.slice(e5.start, e5.end)}]` : e5.name });
      }
      return a3;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
    }
    parseExportSpecifier(e4, t3, r3, n3) {
      return !t3 && n3 ? (this.parseTypeOnlyImportExportSpecifier(e4, false, r3), this.finishNode(e4, "ExportSpecifier")) : (e4.exportKind = "value", super.parseExportSpecifier(e4, t3, r3, n3));
    }
    parseImportSpecifier(e4, t3, r3, n3, s3) {
      return !t3 && n3 ? (this.parseTypeOnlyImportExportSpecifier(e4, true, r3), this.finishNode(e4, "ImportSpecifier")) : (e4.importKind = "value", super.parseImportSpecifier(e4, t3, r3, n3, r3 ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(e4, t3, r3) {
      const n3 = t3 ? "imported" : "local", s3 = t3 ? "local" : "exported";
      let i3, o3 = e4[n3], a3 = false, l2 = true;
      const c2 = o3.loc.start;
      if (this.isContextual(93)) {
        const e5 = this.parseIdentifier();
        if (this.isContextual(93)) {
          const r4 = this.parseIdentifier();
          G(this.state.type) ? (a3 = true, o3 = e5, i3 = t3 ? this.parseIdentifier() : this.parseModuleExportName(), l2 = false) : (i3 = r4, l2 = false);
        } else G(this.state.type) ? (l2 = false, i3 = t3 ? this.parseIdentifier() : this.parseModuleExportName()) : (a3 = true, o3 = e5);
      } else G(this.state.type) && (a3 = true, t3 ? (o3 = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(o3.name, o3.loc.start, true, true)) : o3 = this.parseModuleExportName());
      a3 && r3 && this.raise(t3 ? St.TypeModifierIsUsedInTypeImports : St.TypeModifierIsUsedInTypeExports, c2), e4[n3] = o3, e4[s3] = i3, e4[t3 ? "importKind" : "exportKind"] = a3 ? "type" : "value", l2 && this.eatContextual(93) && (e4[s3] = t3 ? this.parseIdentifier() : this.parseModuleExportName()), e4[s3] || (e4[s3] = it(e4[n3])), t3 && this.checkIdentifier(e4[s3], a3 ? 4098 : 4096);
    }
  }, v8intrinsic: (e3) => class extends e3 {
    parseV8Intrinsic() {
      if (this.match(54)) {
        const e4 = this.state.startLoc, t3 = this.startNode();
        if (this.next(), W(this.state.type)) {
          const e5 = this.parseIdentifierName(), r3 = this.createIdentifier(t3, e5);
          if (r3.type = "V8IntrinsicIdentifier", this.match(10)) return r3;
        }
        this.unexpected(e4);
      }
    }
    parseExprAtom(e4) {
      return this.parseV8Intrinsic() || super.parseExprAtom(e4);
    }
  }, placeholders: (e3) => class extends e3 {
    parsePlaceholder(e4) {
      if (this.match(144)) {
        const t3 = this.startNode();
        return this.next(), this.assertNoSpace(), t3.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(t3, e4);
      }
    }
    finishPlaceholder(e4, t3) {
      const r3 = !(!e4.expectedNode || "Placeholder" !== e4.type);
      return e4.expectedNode = t3, r3 ? e4 : this.finishNode(e4, "Placeholder");
    }
    getTokenFromCode(e4) {
      37 === e4 && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(144, 2) : super.getTokenFromCode(e4);
    }
    parseExprAtom(e4) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(e4);
    }
    parseIdentifier(e4) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(e4);
    }
    checkReservedWord(e4, t3, r3, n3) {
      void 0 !== e4 && super.checkReservedWord(e4, t3, r3, n3);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(e4, t3, r3) {
      return "Placeholder" === e4 || super.isValidLVal(e4, t3, r3);
    }
    toAssignable(e4, t3) {
      e4 && "Placeholder" === e4.type && "Expression" === e4.expectedNode ? e4.expectedNode = "Pattern" : super.toAssignable(e4, t3);
    }
    chStartsBindingIdentifier(e4, t3) {
      return !!super.chStartsBindingIdentifier(e4, t3) || 144 === this.lookahead().type;
    }
    verifyBreakContinue(e4, t3) {
      e4.label && "Placeholder" === e4.label.type || super.verifyBreakContinue(e4, t3);
    }
    parseExpressionStatement(e4, t3) {
      var r3;
      if ("Placeholder" !== t3.type || null != (r3 = t3.extra) && r3.parenthesized) return super.parseExpressionStatement(e4, t3);
      if (this.match(14)) {
        const r4 = e4;
        return r4.label = this.finishPlaceholder(t3, "Identifier"), this.next(), r4.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(r4, "LabeledStatement");
      }
      return this.semicolon(), e4.name = t3.name, this.finishPlaceholder(e4, "Statement");
    }
    parseBlock(e4, t3, r3) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(e4, t3, r3);
    }
    parseFunctionId(e4) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(e4);
    }
    parseClass(e4, t3, r3) {
      const n3 = t3 ? "ClassDeclaration" : "ClassExpression";
      this.next();
      const s3 = this.state.strict, i3 = this.parsePlaceholder("Identifier");
      if (i3) {
        if (!(this.match(81) || this.match(144) || this.match(5))) {
          if (r3 || !t3) return e4.id = null, e4.body = this.finishPlaceholder(i3, "ClassBody"), this.finishNode(e4, n3);
          throw this.raise(Ot.ClassNameIsRequired, this.state.startLoc);
        }
        e4.id = i3;
      } else this.parseClassId(e4, t3, r3);
      return super.parseClassSuper(e4), e4.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e4.superClass, s3), this.finishNode(e4, n3);
    }
    parseExport(e4, t3) {
      const r3 = this.parsePlaceholder("Identifier");
      if (!r3) return super.parseExport(e4, t3);
      if (!this.isContextual(98) && !this.match(12)) return e4.specifiers = [], e4.source = null, e4.declaration = this.finishPlaceholder(r3, "Declaration"), this.finishNode(e4, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      const n3 = this.startNode();
      return n3.exported = r3, e4.specifiers = [this.finishNode(n3, "ExportDefaultSpecifier")], super.parseExport(e4, t3);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        const e4 = this.nextTokenStart();
        if (this.isUnparsedContextual(e4, "from") && this.input.startsWith(J(144), this.nextTokenStartSince(e4 + 4))) return true;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(e4, t3) {
      var r3;
      return !(null == (r3 = e4.specifiers) || !r3.length) || super.maybeParseExportDefaultSpecifier(e4, t3);
    }
    checkExport(e4) {
      const { specifiers: t3 } = e4;
      null != t3 && t3.length && (e4.specifiers = t3.filter((e5) => "Placeholder" === e5.exported.type)), super.checkExport(e4), e4.specifiers = t3;
    }
    parseImport(e4) {
      const t3 = this.parsePlaceholder("Identifier");
      if (!t3) return super.parseImport(e4);
      if (e4.specifiers = [], !this.isContextual(98) && !this.match(12)) return e4.source = this.finishPlaceholder(t3, "StringLiteral"), this.semicolon(), this.finishNode(e4, "ImportDeclaration");
      const r3 = this.startNodeAtNode(t3);
      return r3.local = t3, e4.specifiers.push(this.finishNode(r3, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e4) || this.parseNamedImportSpecifiers(e4)), this.expectContextual(98), e4.source = this.parseImportSource(), this.semicolon(), this.finishNode(e4, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(Ot.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  } }, Lt = Object.keys(jt), Mt = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createImportExpressions: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
  class Bt extends vt {
    checkProto(e3, t3, r3, n3) {
      if ("SpreadElement" === e3.type || this.isObjectMethod(e3) || e3.computed || e3.shorthand) return;
      const s3 = e3.key;
      if ("__proto__" === ("Identifier" === s3.type ? s3.name : s3.value)) {
        if (t3) return void this.raise(v.RecordNoProto, s3);
        r3.used && (n3 ? null === n3.doubleProtoLoc && (n3.doubleProtoLoc = s3.loc.start) : this.raise(v.DuplicateProto, s3)), r3.used = true;
      }
    }
    shouldExitDescending(e3, t3) {
      return "ArrowFunctionExpression" === e3.type && e3.start === t3;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      const e3 = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), e3.comments = this.comments, e3.errors = this.state.errors, this.options.tokens && (e3.tokens = this.tokens), e3;
    }
    parseExpression(e3, t3) {
      return e3 ? this.disallowInAnd(() => this.parseExpressionBase(t3)) : this.allowInAnd(() => this.parseExpressionBase(t3));
    }
    parseExpressionBase(e3) {
      const t3 = this.state.startLoc, r3 = this.parseMaybeAssign(e3);
      if (this.match(12)) {
        const n3 = this.startNodeAt(t3);
        for (n3.expressions = [r3]; this.eat(12); ) n3.expressions.push(this.parseMaybeAssign(e3));
        return this.toReferencedList(n3.expressions), this.finishNode(n3, "SequenceExpression");
      }
      return r3;
    }
    parseMaybeAssignDisallowIn(e3, t3) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e3, t3));
    }
    parseMaybeAssignAllowIn(e3, t3) {
      return this.allowInAnd(() => this.parseMaybeAssign(e3, t3));
    }
    setOptionalParametersError(e3, t3) {
      var r3;
      e3.optionalParametersLoc = null != (r3 = null == t3 ? void 0 : t3.loc) ? r3 : this.state.startLoc;
    }
    parseMaybeAssign(e3, t3) {
      const r3 = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let e4 = this.parseYield();
        return t3 && (e4 = t3.call(this, e4, r3)), e4;
      }
      let n3;
      e3 ? n3 = false : (e3 = new rt(), n3 = true);
      const { type: s3 } = this.state;
      (10 === s3 || W(s3)) && (this.state.potentialArrowAt = this.state.start);
      let i3 = this.parseMaybeConditional(e3);
      if (t3 && (i3 = t3.call(this, i3, r3)), (o3 = this.state.type) >= 29 && o3 <= 33) {
        const t4 = this.startNodeAt(r3), n4 = this.state.value;
        if (t4.operator = n4, this.match(29)) {
          this.toAssignable(i3, true), t4.left = i3;
          const n5 = r3.index;
          null != e3.doubleProtoLoc && e3.doubleProtoLoc.index >= n5 && (e3.doubleProtoLoc = null), null != e3.shorthandAssignLoc && e3.shorthandAssignLoc.index >= n5 && (e3.shorthandAssignLoc = null), null != e3.privateKeyLoc && e3.privateKeyLoc.index >= n5 && (this.checkDestructuringPrivate(e3), e3.privateKeyLoc = null);
        } else t4.left = i3;
        return this.next(), t4.right = this.parseMaybeAssign(), this.checkLVal(i3, { in: this.finishNode(t4, "AssignmentExpression") }), t4;
      }
      var o3;
      return n3 && this.checkExpressionErrors(e3, true), i3;
    }
    parseMaybeConditional(e3) {
      const t3 = this.state.startLoc, r3 = this.state.potentialArrowAt, n3 = this.parseExprOps(e3);
      return this.shouldExitDescending(n3, r3) ? n3 : this.parseConditional(n3, t3, e3);
    }
    parseConditional(e3, t3, r3) {
      if (this.eat(17)) {
        const r4 = this.startNodeAt(t3);
        return r4.test = e3, r4.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), r4.alternate = this.parseMaybeAssign(), this.finishNode(r4, "ConditionalExpression");
      }
      return e3;
    }
    parseMaybeUnaryOrPrivate(e3) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(e3);
    }
    parseExprOps(e3) {
      const t3 = this.state.startLoc, r3 = this.state.potentialArrowAt, n3 = this.parseMaybeUnaryOrPrivate(e3);
      return this.shouldExitDescending(n3, r3) ? n3 : this.parseExprOp(n3, t3, -1);
    }
    parseExprOp(e3, t3, r3) {
      if (this.isPrivateName(e3)) {
        const t4 = this.getPrivateNameSV(e3);
        (r3 >= Y(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(v.PrivateInExpectedIn, e3, { identifierName: t4 }), this.classScope.usePrivateName(t4, e3.loc.start);
      }
      const n3 = this.state.type;
      if ((s3 = n3) >= 39 && s3 <= 59 && (this.prodParam.hasIn || !this.match(58))) {
        let s4 = Y(n3);
        if (s4 > r3) {
          if (39 === n3) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return e3;
            this.checkPipelineAtInfixOperator(e3, t3);
          }
          const i3 = this.startNodeAt(t3);
          i3.left = e3, i3.operator = this.state.value;
          const o3 = 41 === n3 || 42 === n3, a3 = 40 === n3;
          if (a3 && (s4 = Y(42)), this.next(), 39 === n3 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && 96 === this.state.type && this.prodParam.hasAwait) throw this.raise(v.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          i3.right = this.parseExprOpRightExpr(n3, s4);
          const l2 = this.finishNode(i3, o3 || a3 ? "LogicalExpression" : "BinaryExpression"), c2 = this.state.type;
          if (a3 && (41 === c2 || 42 === c2) || o3 && 40 === c2) throw this.raise(v.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(l2, t3, r3);
        }
      }
      var s3;
      return e3;
    }
    parseExprOpRightExpr(e3, t3) {
      const r3 = this.state.startLoc;
      if (39 === e3) switch (this.getPluginOption("pipelineOperator", "proposal")) {
        case "hack":
          return this.withTopicBindingContext(() => this.parseHackPipeBody());
        case "smart":
          return this.withTopicBindingContext(() => {
            if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(v.PipeBodyIsTighter, this.state.startLoc);
            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e3, t3), r3);
          });
        case "fsharp":
          return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t3));
      }
      return this.parseExprOpBaseRightExpr(e3, t3);
    }
    parseExprOpBaseRightExpr(e3, t3) {
      const r3 = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r3, 57 === e3 ? t3 - 1 : t3);
    }
    parseHackPipeBody() {
      var e3;
      const { startLoc: t3 } = this.state, r3 = this.parseMaybeAssign();
      return !d.has(r3.type) || null != (e3 = r3.extra) && e3.parenthesized || this.raise(v.PipeUnparenthesizedBody, t3, { type: r3.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(v.PipeTopicUnused, t3), r3;
    }
    checkExponentialAfterUnary(e3) {
      this.match(57) && this.raise(v.UnexpectedTokenUnaryExponentiation, e3.argument);
    }
    parseMaybeUnary(e3, t3) {
      const r3 = this.state.startLoc, n3 = this.isContextual(96);
      if (n3 && this.isAwaitAllowed()) {
        this.next();
        const e4 = this.parseAwait(r3);
        return t3 || this.checkExponentialAfterUnary(e4), e4;
      }
      const s3 = this.match(34), i3 = this.startNode();
      if (o3 = this.state.type, U[o3]) {
        i3.operator = this.state.value, i3.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
        const r4 = this.match(89);
        if (this.next(), i3.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e3, true), this.state.strict && r4) {
          const e4 = i3.argument;
          "Identifier" === e4.type ? this.raise(v.StrictDelete, i3) : this.hasPropertyAsPrivateName(e4) && this.raise(v.DeletePrivateField, i3);
        }
        if (!s3) return t3 || this.checkExponentialAfterUnary(i3), this.finishNode(i3, "UnaryExpression");
      }
      var o3;
      const a3 = this.parseUpdate(i3, s3, e3);
      if (n3) {
        const { type: e4 } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? z(e4) : z(e4) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(v.AwaitNotInAsyncContext, r3), this.parseAwait(r3);
      }
      return a3;
    }
    parseUpdate(e3, t3, r3) {
      if (t3) {
        const t4 = e3;
        return this.checkLVal(t4.argument, { in: this.finishNode(t4, "UpdateExpression") }), e3;
      }
      const n3 = this.state.startLoc;
      let s3 = this.parseExprSubscripts(r3);
      if (this.checkExpressionErrors(r3, false)) return s3;
      for (; 34 === this.state.type && !this.canInsertSemicolon(); ) {
        const e4 = this.startNodeAt(n3);
        e4.operator = this.state.value, e4.prefix = false, e4.argument = s3, this.next(), this.checkLVal(s3, { in: s3 = this.finishNode(e4, "UpdateExpression") });
      }
      return s3;
    }
    parseExprSubscripts(e3) {
      const t3 = this.state.startLoc, r3 = this.state.potentialArrowAt, n3 = this.parseExprAtom(e3);
      return this.shouldExitDescending(n3, r3) ? n3 : this.parseSubscripts(n3, t3);
    }
    parseSubscripts(e3, t3, r3) {
      const n3 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(e3), stop: false };
      do {
        e3 = this.parseSubscript(e3, t3, r3, n3), n3.maybeAsyncArrow = false;
      } while (!n3.stop);
      return e3;
    }
    parseSubscript(e3, t3, r3, n3) {
      const { type: s3 } = this.state;
      if (!r3 && 15 === s3) return this.parseBind(e3, t3, r3, n3);
      if (Q(s3)) return this.parseTaggedTemplateExpression(e3, t3, n3);
      let i3 = false;
      if (18 === s3) {
        if (r3 && (this.raise(v.OptionalChainingNoNew, this.state.startLoc), 40 === this.lookaheadCharCode())) return n3.stop = true, e3;
        n3.optionalChainMember = i3 = true, this.next();
      }
      if (!r3 && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(e3, t3, n3, i3);
      {
        const r4 = this.eat(0);
        return r4 || i3 || this.eat(16) ? this.parseMember(e3, t3, n3, r4, i3) : (n3.stop = true, e3);
      }
    }
    parseMember(e3, t3, r3, n3, s3) {
      const i3 = this.startNodeAt(t3);
      return i3.object = e3, i3.computed = n3, n3 ? (i3.property = this.parseExpression(), this.expect(3)) : this.match(138) ? ("Super" === e3.type && this.raise(v.SuperPrivateField, t3), this.classScope.usePrivateName(this.state.value, this.state.startLoc), i3.property = this.parsePrivateName()) : i3.property = this.parseIdentifier(true), r3.optionalChainMember ? (i3.optional = s3, this.finishNode(i3, "OptionalMemberExpression")) : this.finishNode(i3, "MemberExpression");
    }
    parseBind(e3, t3, r3, n3) {
      const s3 = this.startNodeAt(t3);
      return s3.object = e3, this.next(), s3.callee = this.parseNoCallExpr(), n3.stop = true, this.parseSubscripts(this.finishNode(s3, "BindExpression"), t3, r3);
    }
    parseCoverCallAndAsyncArrowHead(e3, t3, r3, n3) {
      const s3 = this.state.maybeInArrowParameters;
      let i3 = null;
      this.state.maybeInArrowParameters = true, this.next();
      const o3 = this.startNodeAt(t3);
      o3.callee = e3;
      const { maybeAsyncArrow: a3, optionalChainMember: l2 } = r3;
      a3 && (this.expressionScope.enter(new Je(2)), i3 = new rt()), l2 && (o3.optional = n3), o3.arguments = n3 ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, "Import" === e3.type, "Super" !== e3.type, o3, i3);
      let c2 = this.finishCallExpression(o3, l2);
      return a3 && this.shouldParseAsyncArrow() && !n3 ? (r3.stop = true, this.checkDestructuringPrivate(i3), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), c2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t3), c2)) : (a3 && (this.checkExpressionErrors(i3, true), this.expressionScope.exit()), this.toReferencedArguments(c2)), this.state.maybeInArrowParameters = s3, c2;
    }
    toReferencedArguments(e3, t3) {
      this.toReferencedListDeep(e3.arguments, t3);
    }
    parseTaggedTemplateExpression(e3, t3, r3) {
      const n3 = this.startNodeAt(t3);
      return n3.tag = e3, n3.quasi = this.parseTemplate(true), r3.optionalChainMember && this.raise(v.OptionalChainingNoTemplate, t3), this.finishNode(n3, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(e3) {
      return "Identifier" === e3.type && "async" === e3.name && this.state.lastTokEndLoc.index === e3.end && !this.canInsertSemicolon() && e3.end - e3.start == 5 && e3.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(e3, t3) {
      if ("Import" === e3.callee.type) if (2 === e3.arguments.length && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), 0 === e3.arguments.length || e3.arguments.length > 2) this.raise(v.ImportCallArity, e3, { maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
      else for (const t4 of e3.arguments) "SpreadElement" === t4.type && this.raise(v.ImportCallSpreadArgument, t4);
      return this.finishNode(e3, t3 ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(e3, t3, r3, n3, s3) {
      const i3 = [];
      let o3 = true;
      const a3 = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = false; !this.eat(e3); ) {
        if (o3) o3 = false;
        else if (this.expect(12), this.match(e3)) {
          !t3 || this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(v.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), n3 && this.addTrailingCommaExtraToNode(n3), this.next();
          break;
        }
        i3.push(this.parseExprListItem(false, s3, r3));
      }
      return this.state.inFSharpPipelineDirectBody = a3, i3;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(e3, t3) {
      var r3;
      return this.resetPreviousNodeTrailingComments(t3), this.expect(19), this.parseArrowExpression(e3, t3.arguments, true, null == (r3 = t3.extra) ? void 0 : r3.trailingCommaLoc), t3.innerComments && Te(e3, t3.innerComments), t3.callee.trailingComments && Te(e3, t3.callee.trailingComments), e3;
    }
    parseNoCallExpr() {
      const e3 = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e3, true);
    }
    parseExprAtom(e3) {
      let t3, r3 = null;
      const { type: n3 } = this.state;
      switch (n3) {
        case 79:
          return this.parseSuper();
        case 83:
          return t3 = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(t3) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(t3) : this.finishNode(t3, "Import") : (this.raise(v.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(t3, "Import"));
        case 78:
          return t3 = this.startNode(), this.next(), this.finishNode(t3, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), false);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(true);
        case 86:
          return this.parseBooleanLiteral(false);
        case 10: {
          const e4 = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(e4);
        }
        case 2:
        case 1:
          return this.parseArrayLike(2 === this.state.type ? 4 : 3, false, true);
        case 0:
          return this.parseArrayLike(3, true, false, e3);
        case 6:
        case 7:
          return this.parseObjectLike(6 === this.state.type ? 9 : 8, false, true);
        case 5:
          return this.parseObjectLike(8, false, false, e3);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          r3 = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(r3, this.startNode()), false);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(false);
        case 15: {
          t3 = this.startNode(), this.next(), t3.object = null;
          const e4 = t3.callee = this.parseNoCallExpr();
          if ("MemberExpression" === e4.type) return this.finishNode(t3, "BindExpression");
          throw this.raise(v.UnsupportedBind, e4);
        }
        case 138:
          return this.raise(v.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          const e4 = this.getPluginOption("pipelineOperator", "proposal");
          if (e4) return this.parseTopicReference(e4);
          this.unexpected();
          break;
        }
        case 47: {
          const e4 = this.input.codePointAt(this.nextTokenStart());
          ae(e4) || 62 === e4 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (W(n3)) {
            if (this.isContextual(127) && 123 === this.lookaheadInLineCharCode()) return this.parseModuleExpression();
            const e4 = this.state.potentialArrowAt === this.state.start, t4 = this.state.containsEsc, r4 = this.parseIdentifier();
            if (!t4 && "async" === r4.name && !this.canInsertSemicolon()) {
              const { type: e5 } = this.state;
              if (68 === e5) return this.resetPreviousNodeTrailingComments(r4), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(r4));
              if (W(e5)) return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(r4)) : r4;
              if (90 === e5) return this.resetPreviousNodeTrailingComments(r4), this.parseDo(this.startNodeAtNode(r4), true);
            }
            return e4 && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(r4), [r4], false)) : r4;
          }
          this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(e3, t3) {
      const r3 = this.getPluginOption("pipelineOperator", "proposal");
      if (r3) return this.state.type = e3, this.state.value = t3, this.state.pos--, this.state.end--, this.state.endLoc = o2(this.state.endLoc, -1), this.parseTopicReference(r3);
      this.unexpected();
    }
    parseTopicReference(e3) {
      const t3 = this.startNode(), r3 = this.state.startLoc, n3 = this.state.type;
      return this.next(), this.finishTopicReference(t3, r3, e3, n3);
    }
    finishTopicReference(e3, t3, r3, n3) {
      if (this.testTopicReferenceConfiguration(r3, t3, n3)) {
        const n4 = "smart" === r3 ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise("smart" === r3 ? v.PrimaryTopicNotAllowed : v.PipeTopicUnbound, t3), this.registerTopicReference(), this.finishNode(e3, n4);
      }
      throw this.raise(v.PipeTopicUnconfiguredToken, t3, { token: J(n3) });
    }
    testTopicReferenceConfiguration(e3, t3, r3) {
      switch (e3) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", { topicToken: J(r3) }]);
        case "smart":
          return 27 === r3;
        default:
          throw this.raise(v.PipeTopicRequiresHackPipes, t3);
      }
    }
    parseAsyncArrowUnaryFunction(e3) {
      this.prodParam.enter(et(true, this.prodParam.hasYield));
      const t3 = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(v.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(e3, t3, true);
    }
    parseDo(e3, t3) {
      this.expectPlugin("doExpressions"), t3 && this.expectPlugin("asyncDoExpressions"), e3.async = t3, this.next();
      const r3 = this.state.labels;
      return this.state.labels = [], t3 ? (this.prodParam.enter(2), e3.body = this.parseBlock(), this.prodParam.exit()) : e3.body = this.parseBlock(), this.state.labels = r3, this.finishNode(e3, "DoExpression");
    }
    parseSuper() {
      const e3 = this.startNode();
      return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(v.UnexpectedSuper, e3) : this.raise(v.SuperNotAllowed, e3), this.match(10) || this.match(0) || this.match(16) || this.raise(v.UnsupportedSuper, e3), this.finishNode(e3, "Super");
    }
    parsePrivateName() {
      const e3 = this.startNode(), t3 = this.startNodeAt(o2(this.state.startLoc, 1)), r3 = this.state.value;
      return this.next(), e3.id = this.createIdentifier(t3, r3), this.finishNode(e3, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      const e3 = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        const t3 = this.createIdentifier(this.startNodeAtNode(e3), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(e3, t3, "sent");
      }
      return this.parseFunction(e3);
    }
    parseMetaProperty(e3, t3, r3) {
      e3.meta = t3;
      const n3 = this.state.containsEsc;
      return e3.property = this.parseIdentifier(true), (e3.property.name !== r3 || n3) && this.raise(v.UnsupportedMetaProperty, e3.property, { target: t3.name, onlyValidPropertyName: r3 }), this.finishNode(e3, "MetaProperty");
    }
    parseImportMetaProperty(e3) {
      const t3 = this.createIdentifier(this.startNodeAtNode(e3), "import");
      if (this.next(), this.isContextual(101)) this.inModule || this.raise(v.ImportMetaOutsideModule, t3), this.sawUnambiguousESM = true;
      else if (this.isContextual(105) || this.isContextual(97)) {
        const t4 = this.isContextual(105);
        if (t4 || this.unexpected(), this.expectPlugin(t4 ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions) throw this.raise(v.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
        return this.next(), e3.phase = t4 ? "source" : "defer", this.parseImportCall(e3);
      }
      return this.parseMetaProperty(e3, t3, "meta");
    }
    parseLiteralAtNode(e3, t3, r3) {
      return this.addExtra(r3, "rawValue", e3), this.addExtra(r3, "raw", this.input.slice(r3.start, this.state.end)), r3.value = e3, this.next(), this.finishNode(r3, t3);
    }
    parseLiteral(e3, t3) {
      const r3 = this.startNode();
      return this.parseLiteralAtNode(e3, t3, r3);
    }
    parseStringLiteral(e3) {
      return this.parseLiteral(e3, "StringLiteral");
    }
    parseNumericLiteral(e3) {
      return this.parseLiteral(e3, "NumericLiteral");
    }
    parseBigIntLiteral(e3) {
      return this.parseLiteral(e3, "BigIntLiteral");
    }
    parseDecimalLiteral(e3) {
      return this.parseLiteral(e3, "DecimalLiteral");
    }
    parseRegExpLiteral(e3) {
      const t3 = this.parseLiteral(e3.value, "RegExpLiteral");
      return t3.pattern = e3.pattern, t3.flags = e3.flags, t3;
    }
    parseBooleanLiteral(e3) {
      const t3 = this.startNode();
      return t3.value = e3, this.next(), this.finishNode(t3, "BooleanLiteral");
    }
    parseNullLiteral() {
      const e3 = this.startNode();
      return this.next(), this.finishNode(e3, "NullLiteral");
    }
    parseParenAndDistinguishExpression(e3) {
      const t3 = this.state.startLoc;
      let r3;
      this.next(), this.expressionScope.enter(new Je(1));
      const n3 = this.state.maybeInArrowParameters, s3 = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
      const i3 = this.state.startLoc, o3 = [], a3 = new rt();
      let l2, c2, u2 = true;
      for (; !this.match(11); ) {
        if (u2) u2 = false;
        else if (this.expect(12, null === a3.optionalParametersLoc ? null : a3.optionalParametersLoc), this.match(11)) {
          c2 = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          const e4 = this.state.startLoc;
          if (l2 = this.state.startLoc, o3.push(this.parseParenItem(this.parseRestBinding(), e4)), !this.checkCommaAfterRest(41)) break;
        } else o3.push(this.parseMaybeAssignAllowIn(a3, this.parseParenItem));
      }
      const p2 = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = n3, this.state.inFSharpPipelineDirectBody = s3;
      let d2 = this.startNodeAt(t3);
      return e3 && this.shouldParseArrow(o3) && (d2 = this.parseArrow(d2)) ? (this.checkDestructuringPrivate(a3), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(d2, o3, false), d2) : (this.expressionScope.exit(), o3.length || this.unexpected(this.state.lastTokStartLoc), c2 && this.unexpected(c2), l2 && this.unexpected(l2), this.checkExpressionErrors(a3, true), this.toReferencedListDeep(o3, true), o3.length > 1 ? (r3 = this.startNodeAt(i3), r3.expressions = o3, this.finishNode(r3, "SequenceExpression"), this.resetEndLocation(r3, p2)) : r3 = o3[0], this.wrapParenthesis(t3, r3));
    }
    wrapParenthesis(e3, t3) {
      if (!this.options.createParenthesizedExpressions) return this.addExtra(t3, "parenthesized", true), this.addExtra(t3, "parenStart", e3.index), this.takeSurroundingComments(t3, e3.index, this.state.lastTokEndLoc.index), t3;
      const r3 = this.startNodeAt(e3);
      return r3.expression = t3, this.finishNode(r3, "ParenthesizedExpression");
    }
    shouldParseArrow(e3) {
      return !this.canInsertSemicolon();
    }
    parseArrow(e3) {
      if (this.eat(19)) return e3;
    }
    parseParenItem(e3, t3) {
      return e3;
    }
    parseNewOrNewTarget() {
      const e3 = this.startNode();
      if (this.next(), this.match(16)) {
        const t3 = this.createIdentifier(this.startNodeAtNode(e3), "new");
        this.next();
        const r3 = this.parseMetaProperty(e3, t3, "target");
        return this.scope.inNonArrowFunction || this.scope.inClass || this.options.allowNewTargetOutsideFunction || this.raise(v.UnexpectedNewTarget, r3), r3;
      }
      return this.parseNew(e3);
    }
    parseNew(e3) {
      if (this.parseNewCallee(e3), this.eat(10)) {
        const t3 = this.parseExprList(11);
        this.toReferencedList(t3), e3.arguments = t3;
      } else e3.arguments = [];
      return this.finishNode(e3, "NewExpression");
    }
    parseNewCallee(e3) {
      const t3 = this.match(83), r3 = this.parseNoCallExpr();
      e3.callee = r3, !t3 || "Import" !== r3.type && "ImportExpression" !== r3.type || this.raise(v.ImportCallNotNewExpression, r3);
    }
    parseTemplateElement(e3) {
      const { start: t3, startLoc: r3, end: n3, value: s3 } = this.state, i3 = t3 + 1, a3 = this.startNodeAt(o2(r3, 1));
      null === s3 && (e3 || this.raise(v.InvalidEscapeSequenceTemplate, o2(this.state.firstInvalidTemplateEscapePos, 1)));
      const l2 = this.match(24), c2 = l2 ? -1 : -2, u2 = n3 + c2;
      a3.value = { raw: this.input.slice(i3, u2).replace(/\r\n?/g, "\n"), cooked: null === s3 ? null : s3.slice(1, c2) }, a3.tail = l2, this.next();
      const p2 = this.finishNode(a3, "TemplateElement");
      return this.resetEndLocation(p2, o2(this.state.lastTokEndLoc, c2)), p2;
    }
    parseTemplate(e3) {
      const t3 = this.startNode();
      t3.expressions = [];
      let r3 = this.parseTemplateElement(e3);
      for (t3.quasis = [r3]; !r3.tail; ) t3.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), t3.quasis.push(r3 = this.parseTemplateElement(e3));
      return this.finishNode(t3, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(e3, t3, r3, n3) {
      r3 && this.expectPlugin("recordAndTuple");
      const s3 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const i3 = /* @__PURE__ */ Object.create(null);
      let o3 = true;
      const a3 = this.startNode();
      for (a3.properties = [], this.next(); !this.match(e3); ) {
        if (o3) o3 = false;
        else if (this.expect(12), this.match(e3)) {
          this.addTrailingCommaExtraToNode(a3);
          break;
        }
        let s4;
        t3 ? s4 = this.parseBindingProperty() : (s4 = this.parsePropertyDefinition(n3), this.checkProto(s4, r3, i3, n3)), r3 && !this.isObjectProperty(s4) && "SpreadElement" !== s4.type && this.raise(v.InvalidRecordProperty, s4), s4.shorthand && this.addExtra(s4, "shorthand", true), a3.properties.push(s4);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = s3;
      let l2 = "ObjectExpression";
      return t3 ? l2 = "ObjectPattern" : r3 && (l2 = "RecordExpression"), this.finishNode(a3, l2);
    }
    addTrailingCommaExtraToNode(e3) {
      this.addExtra(e3, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e3, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    }
    maybeAsyncOrAccessorProp(e3) {
      return !e3.computed && "Identifier" === e3.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(e3) {
      let t3 = [];
      if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(v.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) t3.push(this.parseDecorator());
      const r3 = this.startNode();
      let n3, s3 = false, i3 = false;
      if (this.match(21)) return t3.length && this.unexpected(), this.parseSpread();
      t3.length && (r3.decorators = t3, t3 = []), r3.method = false, e3 && (n3 = this.state.startLoc);
      let o3 = this.eat(55);
      this.parsePropertyNamePrefixOperator(r3);
      const a3 = this.state.containsEsc, l2 = this.parsePropertyName(r3, e3);
      if (!o3 && !a3 && this.maybeAsyncOrAccessorProp(r3)) {
        const e4 = l2.name;
        "async" !== e4 || this.hasPrecedingLineBreak() || (s3 = true, this.resetPreviousNodeTrailingComments(l2), o3 = this.eat(55), this.parsePropertyName(r3)), "get" !== e4 && "set" !== e4 || (i3 = true, this.resetPreviousNodeTrailingComments(l2), r3.kind = e4, this.match(55) && (o3 = true, this.raise(v.AccessorIsGenerator, this.state.curPosition(), { kind: e4 }), this.next()), this.parsePropertyName(r3));
      }
      return this.parseObjPropValue(r3, n3, o3, s3, false, i3, e3);
    }
    getGetterSetterExpectedParamCount(e3) {
      return "get" === e3.kind ? 0 : 1;
    }
    getObjectOrClassMethodParams(e3) {
      return e3.params;
    }
    checkGetterSetterParams(e3) {
      var t3;
      const r3 = this.getGetterSetterExpectedParamCount(e3), n3 = this.getObjectOrClassMethodParams(e3);
      n3.length !== r3 && this.raise("get" === e3.kind ? v.BadGetterArity : v.BadSetterArity, e3), "set" === e3.kind && "RestElement" === (null == (t3 = n3[n3.length - 1]) ? void 0 : t3.type) && this.raise(v.BadSetterRestParameter, e3);
    }
    parseObjectMethod(e3, t3, r3, n3, s3) {
      if (s3) {
        const r4 = this.parseMethod(e3, t3, false, false, false, "ObjectMethod");
        return this.checkGetterSetterParams(r4), r4;
      }
      if (r3 || t3 || this.match(10)) return n3 && this.unexpected(), e3.kind = "method", e3.method = true, this.parseMethod(e3, t3, r3, false, false, "ObjectMethod");
    }
    parseObjectProperty(e3, t3, r3, n3) {
      if (e3.shorthand = false, this.eat(14)) return e3.value = r3 ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n3), this.finishNode(e3, "ObjectProperty");
      if (!e3.computed && "Identifier" === e3.key.type) {
        if (this.checkReservedWord(e3.key.name, e3.key.loc.start, true, false), r3) e3.value = this.parseMaybeDefault(t3, it(e3.key));
        else if (this.match(29)) {
          const r4 = this.state.startLoc;
          null != n3 ? null === n3.shorthandAssignLoc && (n3.shorthandAssignLoc = r4) : this.raise(v.InvalidCoverInitializedName, r4), e3.value = this.parseMaybeDefault(t3, it(e3.key));
        } else e3.value = it(e3.key);
        return e3.shorthand = true, this.finishNode(e3, "ObjectProperty");
      }
    }
    parseObjPropValue(e3, t3, r3, n3, s3, i3, o3) {
      const a3 = this.parseObjectMethod(e3, r3, n3, s3, i3) || this.parseObjectProperty(e3, t3, s3, o3);
      return a3 || this.unexpected(), a3;
    }
    parsePropertyName(e3, t3) {
      if (this.eat(0)) e3.computed = true, e3.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        const { type: r3, value: n3 } = this.state;
        let s3;
        if (G(r3)) s3 = this.parseIdentifier(true);
        else switch (r3) {
          case 134:
            s3 = this.parseNumericLiteral(n3);
            break;
          case 133:
            s3 = this.parseStringLiteral(n3);
            break;
          case 135:
            s3 = this.parseBigIntLiteral(n3);
            break;
          case 136:
            s3 = this.parseDecimalLiteral(n3);
            break;
          case 138: {
            const e4 = this.state.startLoc;
            null != t3 ? null === t3.privateKeyLoc && (t3.privateKeyLoc = e4) : this.raise(v.UnexpectedPrivateField, e4), s3 = this.parsePrivateName();
            break;
          }
          default:
            this.unexpected();
        }
        e3.key = s3, 138 !== r3 && (e3.computed = false);
      }
      return e3.key;
    }
    initFunction(e3, t3) {
      e3.id = null, e3.generator = false, e3.async = t3;
    }
    parseMethod(e3, t3, r3, n3, s3, i3) {
      let o3 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
      this.initFunction(e3, r3), e3.generator = t3, this.scope.enter(18 | (o3 ? 64 : 0) | (s3 ? 32 : 0)), this.prodParam.enter(et(r3, e3.generator)), this.parseFunctionParams(e3, n3);
      const a3 = this.parseFunctionBodyAndFinish(e3, i3, true);
      return this.prodParam.exit(), this.scope.exit(), a3;
    }
    parseArrayLike(e3, t3, r3, n3) {
      r3 && this.expectPlugin("recordAndTuple");
      const s3 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const i3 = this.startNode();
      return this.next(), i3.elements = this.parseExprList(e3, !r3, n3, i3), this.state.inFSharpPipelineDirectBody = s3, this.finishNode(i3, r3 ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(e3, t3, r3, n3) {
      this.scope.enter(6);
      let s3 = et(r3, false);
      !this.match(5) && this.prodParam.hasIn && (s3 |= 8), this.prodParam.enter(s3), this.initFunction(e3, r3);
      const i3 = this.state.maybeInArrowParameters;
      return t3 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(e3, t3, n3)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(e3, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = i3, this.finishNode(e3, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(e3, t3, r3) {
      this.toAssignableList(t3, r3, false), e3.params = t3;
    }
    parseFunctionBodyAndFinish(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      return this.parseFunctionBody(e3, false, r3), this.finishNode(e3, t3);
    }
    parseFunctionBody(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      const n3 = t3 && !this.match(5);
      if (this.expressionScope.enter(Qe()), n3) e3.body = this.parseMaybeAssign(), this.checkParams(e3, false, t3, false);
      else {
        const n4 = this.state.strict, s3 = this.state.labels;
        this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), e3.body = this.parseBlock(true, false, (s4) => {
          const i3 = !this.isSimpleParamList(e3.params);
          s4 && i3 && this.raise(v.IllegalLanguageModeDirective, "method" !== e3.kind && "constructor" !== e3.kind || !e3.key ? e3 : e3.key.loc.end);
          const o3 = !n4 && this.state.strict;
          this.checkParams(e3, !(this.state.strict || t3 || r3 || i3), t3, o3), this.state.strict && e3.id && this.checkIdentifier(e3.id, 65, o3);
        }), this.prodParam.exit(), this.state.labels = s3;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(e3) {
      return "Identifier" === e3.type;
    }
    isSimpleParamList(e3) {
      for (let t3 = 0, r3 = e3.length; t3 < r3; t3++) if (!this.isSimpleParameter(e3[t3])) return false;
      return true;
    }
    checkParams(e3, t3, r3) {
      let n3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      const s3 = !t3 && /* @__PURE__ */ new Set(), i3 = { type: "FormalParameters" };
      for (const t4 of e3.params) this.checkLVal(t4, { in: i3, binding: 5, checkClashes: s3, strictModeChanged: n3 });
    }
    parseExprList(e3, t3, r3, n3) {
      const s3 = [];
      let i3 = true;
      for (; !this.eat(e3); ) {
        if (i3) i3 = false;
        else if (this.expect(12), this.match(e3)) {
          n3 && this.addTrailingCommaExtraToNode(n3), this.next();
          break;
        }
        s3.push(this.parseExprListItem(t3, r3));
      }
      return s3;
    }
    parseExprListItem(e3, t3, r3) {
      let n3;
      if (this.match(12)) e3 || this.raise(v.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), n3 = null;
      else if (this.match(21)) {
        const e4 = this.state.startLoc;
        n3 = this.parseParenItem(this.parseSpread(t3), e4);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), r3 || this.raise(v.UnexpectedArgumentPlaceholder, this.state.startLoc);
        const e4 = this.startNode();
        this.next(), n3 = this.finishNode(e4, "ArgumentPlaceholder");
      } else n3 = this.parseMaybeAssignAllowIn(t3, this.parseParenItem);
      return n3;
    }
    parseIdentifier(e3) {
      const t3 = this.startNode(), r3 = this.parseIdentifierName(e3);
      return this.createIdentifier(t3, r3);
    }
    createIdentifier(e3, t3) {
      return e3.name = t3, e3.loc.identifierName = t3, this.finishNode(e3, "Identifier");
    }
    parseIdentifierName(e3) {
      let t3;
      const { startLoc: r3, type: n3 } = this.state;
      G(n3) ? t3 = this.state.value : this.unexpected();
      const s3 = n3 <= 92;
      return e3 ? s3 && this.replaceToken(132) : this.checkReservedWord(t3, r3, s3, false), this.next(), t3;
    }
    checkReservedWord(e3, t3, r3, n3) {
      if (!(e3.length > 10) && function(e4) {
        return ye.has(e4);
      }(e3)) {
        if (r3 && function(e4) {
          return ce.has(e4);
        }(e3)) this.raise(v.UnexpectedKeyword, t3, { keyword: e3 });
        else if ((this.state.strict ? n3 ? me : fe : de)(e3, this.inModule)) this.raise(v.UnexpectedReservedWord, t3, { reservedWord: e3 });
        else if ("yield" === e3) {
          if (this.prodParam.hasYield) return void this.raise(v.YieldBindingIdentifier, t3);
        } else if ("await" === e3) {
          if (this.prodParam.hasAwait) return void this.raise(v.AwaitBindingIdentifier, t3);
          if (this.scope.inStaticBlock) return void this.raise(v.AwaitBindingIdentifierInStaticBlock, t3);
          this.expressionScope.recordAsyncArrowParametersError(t3);
        } else if ("arguments" === e3 && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(v.ArgumentsInClass, t3);
      }
    }
    isAwaitAllowed() {
      return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
    }
    parseAwait(e3) {
      const t3 = this.startNodeAt(e3);
      return this.expressionScope.recordParameterInitializerError(v.AwaitExpressionFormalParameter, t3), this.eat(55) && this.raise(v.ObsoleteAwaitStar, t3), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (t3.argument = this.parseMaybeUnary(null, true)), this.finishNode(t3, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak()) return true;
      const { type: e3 } = this.state;
      return 53 === e3 || 10 === e3 || 0 === e3 || Q(e3) || 102 === e3 && !this.state.containsEsc || 137 === e3 || 56 === e3 || this.hasPlugin("v8intrinsic") && 54 === e3;
    }
    parseYield() {
      const e3 = this.startNode();
      this.expressionScope.recordParameterInitializerError(v.YieldInParameter, e3), this.next();
      let t3 = false, r3 = null;
      if (!this.hasPrecedingLineBreak()) switch (t3 = this.eat(55), this.state.type) {
        case 13:
        case 139:
        case 8:
        case 11:
        case 3:
        case 9:
        case 14:
        case 12:
          if (!t3) break;
        default:
          r3 = this.parseMaybeAssign();
      }
      return e3.delegate = t3, e3.argument = r3, this.finishNode(e3, "YieldExpression");
    }
    parseImportCall(e3) {
      return this.next(), e3.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (e3.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e3.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(e3, "ImportExpression");
    }
    checkPipelineAtInfixOperator(e3, t3) {
      this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && "SequenceExpression" === e3.type && this.raise(v.PipelineHeadSequenceExpression, t3);
    }
    parseSmartPipelineBodyInStyle(e3, t3) {
      if (this.isSimpleReference(e3)) {
        const r3 = this.startNodeAt(t3);
        return r3.callee = e3, this.finishNode(r3, "PipelineBareFunction");
      }
      {
        const r3 = this.startNodeAt(t3);
        return this.checkSmartPipeTopicBodyEarlyErrors(t3), r3.expression = e3, this.finishNode(r3, "PipelineTopicExpression");
      }
    }
    isSimpleReference(e3) {
      switch (e3.type) {
        case "MemberExpression":
          return !e3.computed && this.isSimpleReference(e3.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(e3) {
      if (this.match(19)) throw this.raise(v.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(v.PipelineTopicUnused, e3);
    }
    withTopicBindingContext(e3) {
      const t3 = this.state.topicContext;
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
      try {
        return e3();
      } finally {
        this.state.topicContext = t3;
      }
    }
    withSmartMixTopicForbiddingContext(e3) {
      if (!this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) return e3();
      {
        const t3 = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
        try {
          return e3();
        } finally {
          this.state.topicContext = t3;
        }
      }
    }
    withSoloAwaitPermittingContext(e3) {
      const t3 = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return e3();
      } finally {
        this.state.soloAwait = t3;
      }
    }
    allowInAnd(e3) {
      const t3 = this.prodParam.currentFlags();
      if (8 & ~t3) {
        this.prodParam.enter(8 | t3);
        try {
          return e3();
        } finally {
          this.prodParam.exit();
        }
      }
      return e3();
    }
    disallowInAnd(e3) {
      const t3 = this.prodParam.currentFlags();
      if (8 & t3) {
        this.prodParam.enter(-9 & t3);
        try {
          return e3();
        } finally {
          this.prodParam.exit();
        }
      }
      return e3();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(e3) {
      const t3 = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const r3 = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const n3 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t3, e3);
      return this.state.inFSharpPipelineDirectBody = r3, n3;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const e3 = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      const t3 = this.startNodeAt(this.state.endLoc);
      this.next();
      const r3 = this.initializeScopes(true);
      this.enterInitialScopes();
      try {
        e3.body = this.parseProgram(t3, 8, "module");
      } finally {
        r3();
      }
      return this.finishNode(e3, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(e3) {
    }
  }
  const Rt = { kind: 1 }, Ft = { kind: 2 }, Ut = /[\uD800-\uDFFF]/u, $t = /in(?:stanceof)?/y;
  class Vt extends Bt {
    parseTopLevel(e3, t3) {
      return e3.program = this.parseProgram(t3), e3.comments = this.comments, this.options.tokens && (e3.tokens = function(e4, t4) {
        for (let r3 = 0; r3 < e4.length; r3++) {
          const n3 = e4[r3], { type: s3 } = n3;
          if ("number" == typeof s3) {
            if (138 === s3) {
              const { loc: t5, start: s4, value: i3, end: a3 } = n3, l2 = s4 + 1, c2 = o2(t5.start, 1);
              e4.splice(r3, 1, new Ge({ type: Z(27), value: "#", start: s4, end: l2, startLoc: t5.start, endLoc: c2 }), new Ge({ type: Z(132), value: i3, start: l2, end: a3, startLoc: c2, endLoc: t5.end })), r3++;
              continue;
            }
            if (Q(s3)) {
              const { loc: i3, start: a3, value: l2, end: c2 } = n3, u2 = a3 + 1, p2 = o2(i3.start, 1);
              let d2, f2, h2, m2, y2;
              d2 = 96 === t4.charCodeAt(a3) ? new Ge({ type: Z(22), value: "`", start: a3, end: u2, startLoc: i3.start, endLoc: p2 }) : new Ge({ type: Z(8), value: "}", start: a3, end: u2, startLoc: i3.start, endLoc: p2 }), 24 === s3 ? (h2 = c2 - 1, m2 = o2(i3.end, -1), f2 = null === l2 ? null : l2.slice(1, -1), y2 = new Ge({ type: Z(22), value: "`", start: h2, end: c2, startLoc: m2, endLoc: i3.end })) : (h2 = c2 - 2, m2 = o2(i3.end, -2), f2 = null === l2 ? null : l2.slice(1, -2), y2 = new Ge({ type: Z(23), value: "${", start: h2, end: c2, startLoc: m2, endLoc: i3.end })), e4.splice(r3, 1, d2, new Ge({ type: Z(20), value: f2, start: u2, end: h2, startLoc: p2, endLoc: m2 }), y2), r3 += 2;
              continue;
            }
            n3.type = Z(s3);
          }
        }
        return e4;
      }(this.tokens, this.input)), this.finishNode(e3, "File");
    }
    parseProgram(e3) {
      let t3, r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 139, n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.options.sourceType;
      if (e3.sourceType = n3, e3.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e3, true, true, r3), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (const [e4, t4] of Array.from(this.scope.undefinedExports)) this.raise(v.ModuleExportUndefined, t4, { localName: e4 });
      return t3 = 139 === r3 ? this.finishNode(e3, "Program") : this.finishNodeAt(e3, "Program", o2(this.state.startLoc, -1)), t3;
    }
    stmtToDirective(e3) {
      const t3 = e3;
      t3.type = "Directive", t3.value = t3.expression, delete t3.expression;
      const r3 = t3.value, n3 = r3.value, s3 = this.input.slice(r3.start, r3.end), i3 = r3.value = s3.slice(1, -1);
      return this.addExtra(r3, "raw", s3), this.addExtra(r3, "rawValue", i3), this.addExtra(r3, "expressionValue", n3), r3.type = "DirectiveLiteral", t3;
    }
    parseInterpreterDirective() {
      if (!this.match(28)) return null;
      const e3 = this.startNode();
      return e3.value = this.state.value, this.next(), this.finishNode(e3, "InterpreterDirective");
    }
    isLet() {
      return !!this.isContextual(100) && this.hasFollowingBindingAtom();
    }
    chStartsBindingIdentifier(e3, t3) {
      if (ae(e3)) {
        if ($t.lastIndex = t3, $t.test(this.input)) {
          const e4 = this.codePointAtPos($t.lastIndex);
          if (!le(e4) && 92 !== e4) return false;
        }
        return true;
      }
      return 92 === e3;
    }
    chStartsBindingPattern(e3) {
      return 91 === e3 || 123 === e3;
    }
    hasFollowingBindingAtom() {
      const e3 = this.nextTokenStart(), t3 = this.codePointAtPos(e3);
      return this.chStartsBindingPattern(t3) || this.chStartsBindingIdentifier(t3, e3);
    }
    hasInLineFollowingBindingIdentifier() {
      const e3 = this.nextTokenInLineStart(), t3 = this.codePointAtPos(e3);
      return this.chStartsBindingIdentifier(t3, e3);
    }
    startsUsingForOf() {
      const { type: e3, containsEsc: t3 } = this.lookahead();
      return !(102 === e3 && !t3) && (W(e3) && !this.hasFollowingLineBreak() ? (this.expectPlugin("explicitResourceManagement"), true) : void 0);
    }
    startsAwaitUsing() {
      let e3 = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e3, "using")) {
        e3 = this.nextTokenInLineStartSince(e3 + 5);
        const t3 = this.codePointAtPos(e3);
        if (this.chStartsBindingIdentifier(t3, e3)) return this.expectPlugin("explicitResourceManagement"), true;
      }
      return false;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t3 = 0;
      return this.options.annexB && !this.state.strict && (t3 |= 4, e3 && (t3 |= 8)), this.parseStatementLike(t3);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(e3) {
      let t3 = null;
      return this.match(26) && (t3 = this.parseDecorators(true)), this.parseStatementContent(e3, t3);
    }
    parseStatementContent(e3, t3) {
      const r3 = this.state.type, n3 = this.startNode(), s3 = !!(2 & e3), i3 = !!(4 & e3), o3 = 1 & e3;
      switch (r3) {
        case 60:
          return this.parseBreakContinueStatement(n3, true);
        case 63:
          return this.parseBreakContinueStatement(n3, false);
        case 64:
          return this.parseDebuggerStatement(n3);
        case 90:
          return this.parseDoWhileStatement(n3);
        case 91:
          return this.parseForStatement(n3);
        case 68:
          if (46 === this.lookaheadCharCode()) break;
          return i3 || this.raise(this.state.strict ? v.StrictFunction : this.options.annexB ? v.SloppyFunctionAnnexB : v.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(n3, false, !s3 && i3);
        case 80:
          return s3 || this.unexpected(), this.parseClass(this.maybeTakeDecorators(t3, n3), true);
        case 69:
          return this.parseIfStatement(n3);
        case 70:
          return this.parseReturnStatement(n3);
        case 71:
          return this.parseSwitchStatement(n3);
        case 72:
          return this.parseThrowStatement(n3);
        case 73:
          return this.parseTryStatement(n3);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing()) return this.isAwaitAllowed() ? s3 || this.raise(v.UnexpectedLexicalDeclaration, n3) : this.raise(v.AwaitUsingNotInAsyncContext, n3), this.next(), this.parseVarStatement(n3, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(v.UnexpectedUsingDeclaration, this.state.startLoc) : s3 || this.raise(v.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(n3, "using");
        case 100: {
          if (this.state.containsEsc) break;
          const e4 = this.nextTokenStart(), t4 = this.codePointAtPos(e4);
          if (91 !== t4) {
            if (!s3 && this.hasFollowingLineBreak()) break;
            if (!this.chStartsBindingIdentifier(t4, e4) && 123 !== t4) break;
          }
        }
        case 75:
          s3 || this.raise(v.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          const e4 = this.state.value;
          return this.parseVarStatement(n3, e4);
        }
        case 92:
          return this.parseWhileStatement(n3);
        case 76:
          return this.parseWithStatement(n3);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(n3);
        case 83: {
          const e4 = this.lookaheadCharCode();
          if (40 === e4 || 46 === e4) break;
        }
        case 82: {
          let e4;
          return this.options.allowImportExportEverywhere || o3 || this.raise(v.UnexpectedImportExport, this.state.startLoc), this.next(), 83 === r3 ? (e4 = this.parseImport(n3), "ImportDeclaration" !== e4.type || e4.importKind && "value" !== e4.importKind || (this.sawUnambiguousESM = true)) : (e4 = this.parseExport(n3, t3), ("ExportNamedDeclaration" !== e4.type || e4.exportKind && "value" !== e4.exportKind) && ("ExportAllDeclaration" !== e4.type || e4.exportKind && "value" !== e4.exportKind) && "ExportDefaultDeclaration" !== e4.type || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(e4), e4;
        }
        default:
          if (this.isAsyncFunction()) return s3 || this.raise(v.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(n3, true, !s3 && i3);
      }
      const a3 = this.state.value, l2 = this.parseExpression();
      return W(r3) && "Identifier" === l2.type && this.eat(14) ? this.parseLabeledStatement(n3, a3, l2, e3) : this.parseExpressionStatement(n3, l2, t3);
    }
    assertModuleNodeAllowed(e3) {
      this.options.allowImportExportEverywhere || this.inModule || this.raise(v.ImportOutsideModule, e3);
    }
    decoratorsEnabledBeforeExport() {
      return !!this.hasPlugin("decorators-legacy") || this.hasPlugin("decorators") && false !== this.getPluginOption("decorators", "decoratorsBeforeExport");
    }
    maybeTakeDecorators(e3, t3, r3) {
      return e3 && (t3.decorators && t3.decorators.length > 0 ? ("boolean" != typeof this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(v.DecoratorsBeforeAfterExport, t3.decorators[0]), t3.decorators.unshift(...e3)) : t3.decorators = e3, this.resetStartLocationFromNode(t3, e3[0]), r3 && this.resetStartLocationFromNode(r3, t3)), t3;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(e3) {
      const t3 = [];
      do {
        t3.push(this.parseDecorator());
      } while (this.match(26));
      if (this.match(82)) e3 || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(v.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator()) throw this.raise(v.UnexpectedLeadingDecorator, this.state.startLoc);
      return t3;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      const e3 = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        const t3 = this.state.startLoc;
        let r3;
        if (this.match(10)) {
          const t4 = this.state.startLoc;
          this.next(), r3 = this.parseExpression(), this.expect(11), r3 = this.wrapParenthesis(t4, r3);
          const n3 = this.state.startLoc;
          e3.expression = this.parseMaybeDecoratorArguments(r3), false === this.getPluginOption("decorators", "allowCallParenthesized") && e3.expression !== r3 && this.raise(v.DecoratorArgumentsOutsideParentheses, n3);
        } else {
          for (r3 = this.parseIdentifier(false); this.eat(16); ) {
            const e4 = this.startNodeAt(t3);
            e4.object = r3, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), e4.property = this.parsePrivateName()) : e4.property = this.parseIdentifier(true), e4.computed = false, r3 = this.finishNode(e4, "MemberExpression");
          }
          e3.expression = this.parseMaybeDecoratorArguments(r3);
        }
      } else e3.expression = this.parseExprSubscripts();
      return this.finishNode(e3, "Decorator");
    }
    parseMaybeDecoratorArguments(e3) {
      if (this.eat(10)) {
        const t3 = this.startNodeAtNode(e3);
        return t3.callee = e3, t3.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(t3.arguments), this.finishNode(t3, "CallExpression");
      }
      return e3;
    }
    parseBreakContinueStatement(e3, t3) {
      return this.next(), this.isLineTerminator() ? e3.label = null : (e3.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e3, t3), this.finishNode(e3, t3 ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(e3, t3) {
      let r3;
      for (r3 = 0; r3 < this.state.labels.length; ++r3) {
        const n3 = this.state.labels[r3];
        if (null == e3.label || n3.name === e3.label.name) {
          if (null != n3.kind && (t3 || 1 === n3.kind)) break;
          if (e3.label && t3) break;
        }
      }
      if (r3 === this.state.labels.length) {
        const r4 = t3 ? "BreakStatement" : "ContinueStatement";
        this.raise(v.IllegalBreakContinue, e3, { type: r4 });
      }
    }
    parseDebuggerStatement(e3) {
      return this.next(), this.semicolon(), this.finishNode(e3, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      const e3 = this.parseExpression();
      return this.expect(11), e3;
    }
    parseDoWhileStatement(e3) {
      return this.next(), this.state.labels.push(Rt), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), e3.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e3, "DoWhileStatement");
    }
    parseForStatement(e3) {
      this.next(), this.state.labels.push(Rt);
      let t3 = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (t3 = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13)) return null !== t3 && this.unexpected(t3), this.parseFor(e3, null);
      const r3 = this.isContextual(100);
      {
        const n4 = this.isContextual(96) && this.startsAwaitUsing(), s4 = n4 || this.isContextual(107) && this.startsUsingForOf(), i4 = r3 && this.hasFollowingBindingAtom() || s4;
        if (this.match(74) || this.match(75) || i4) {
          const r4 = this.startNode();
          let i5;
          n4 ? (i5 = "await using", this.isAwaitAllowed() || this.raise(v.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : i5 = this.state.value, this.next(), this.parseVar(r4, true, i5);
          const o4 = this.finishNode(r4, "VariableDeclaration"), a3 = this.match(58);
          return a3 && s4 && this.raise(v.ForInUsing, o4), (a3 || this.isContextual(102)) && 1 === o4.declarations.length ? this.parseForIn(e3, o4, t3) : (null !== t3 && this.unexpected(t3), this.parseFor(e3, o4));
        }
      }
      const n3 = this.isContextual(95), s3 = new rt(), i3 = this.parseExpression(true, s3), o3 = this.isContextual(102);
      if (o3 && (r3 && this.raise(v.ForOfLet, i3), null === t3 && n3 && "Identifier" === i3.type && this.raise(v.ForOfAsync, i3)), o3 || this.match(58)) {
        this.checkDestructuringPrivate(s3), this.toAssignable(i3, true);
        const r4 = o3 ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(i3, { in: { type: r4 } }), this.parseForIn(e3, i3, t3);
      }
      return this.checkExpressionErrors(s3, true), null !== t3 && this.unexpected(t3), this.parseFor(e3, i3);
    }
    parseFunctionStatement(e3, t3, r3) {
      return this.next(), this.parseFunction(e3, 1 | (r3 ? 2 : 0) | (t3 ? 8 : 0));
    }
    parseIfStatement(e3) {
      return this.next(), e3.test = this.parseHeaderExpression(), e3.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e3.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e3, "IfStatement");
    }
    parseReturnStatement(e3) {
      return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(v.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? e3.argument = null : (e3.argument = this.parseExpression(), this.semicolon()), this.finishNode(e3, "ReturnStatement");
    }
    parseSwitchStatement(e3) {
      this.next(), e3.discriminant = this.parseHeaderExpression();
      const t3 = e3.cases = [];
      let r3;
      this.expect(5), this.state.labels.push(Ft), this.scope.enter(0);
      for (let e4; !this.match(8); ) if (this.match(61) || this.match(65)) {
        const n3 = this.match(61);
        r3 && this.finishNode(r3, "SwitchCase"), t3.push(r3 = this.startNode()), r3.consequent = [], this.next(), n3 ? r3.test = this.parseExpression() : (e4 && this.raise(v.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), e4 = true, r3.test = null), this.expect(14);
      } else r3 ? r3.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), r3 && this.finishNode(r3, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e3, "SwitchStatement");
    }
    parseThrowStatement(e3) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(v.NewlineAfterThrow, this.state.lastTokEndLoc), e3.argument = this.parseExpression(), this.semicolon(), this.finishNode(e3, "ThrowStatement");
    }
    parseCatchClauseParam() {
      const e3 = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && "Identifier" === e3.type ? 8 : 0), this.checkLVal(e3, { in: { type: "CatchClause" }, binding: 9 }), e3;
    }
    parseTryStatement(e3) {
      if (this.next(), e3.block = this.parseBlock(), e3.handler = null, this.match(62)) {
        const t3 = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), t3.param = this.parseCatchClauseParam(), this.expect(11)) : (t3.param = null, this.scope.enter(0)), t3.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), e3.handler = this.finishNode(t3, "CatchClause");
      }
      return e3.finalizer = this.eat(67) ? this.parseBlock() : null, e3.handler || e3.finalizer || this.raise(v.NoCatchOrFinally, e3), this.finishNode(e3, "TryStatement");
    }
    parseVarStatement(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      return this.next(), this.parseVar(e3, false, t3, r3), this.semicolon(), this.finishNode(e3, "VariableDeclaration");
    }
    parseWhileStatement(e3) {
      return this.next(), e3.test = this.parseHeaderExpression(), this.state.labels.push(Rt), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(e3, "WhileStatement");
    }
    parseWithStatement(e3) {
      return this.state.strict && this.raise(v.StrictWith, this.state.startLoc), this.next(), e3.object = this.parseHeaderExpression(), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e3, "WithStatement");
    }
    parseEmptyStatement(e3) {
      return this.next(), this.finishNode(e3, "EmptyStatement");
    }
    parseLabeledStatement(e3, t3, r3, n3) {
      for (const e4 of this.state.labels) e4.name === t3 && this.raise(v.LabelRedeclaration, r3, { labelName: t3 });
      const s3 = (i3 = this.state.type) >= 90 && i3 <= 92 ? 1 : this.match(71) ? 2 : null;
      var i3;
      for (let t4 = this.state.labels.length - 1; t4 >= 0; t4--) {
        const r4 = this.state.labels[t4];
        if (r4.statementStart !== e3.start) break;
        r4.statementStart = this.state.start, r4.kind = s3;
      }
      return this.state.labels.push({ name: t3, kind: s3, statementStart: this.state.start }), e3.body = 8 & n3 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), e3.label = r3, this.finishNode(e3, "LabeledStatement");
    }
    parseExpressionStatement(e3, t3, r3) {
      return e3.expression = t3, this.semicolon(), this.finishNode(e3, "ExpressionStatement");
    }
    parseBlock() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], r3 = arguments.length > 2 ? arguments[2] : void 0;
      const n3 = this.startNode();
      return e3 && this.state.strictErrors.clear(), this.expect(5), t3 && this.scope.enter(0), this.parseBlockBody(n3, e3, false, 8, r3), t3 && this.scope.exit(), this.finishNode(n3, "BlockStatement");
    }
    isValidDirective(e3) {
      return "ExpressionStatement" === e3.type && "StringLiteral" === e3.expression.type && !e3.expression.extra.parenthesized;
    }
    parseBlockBody(e3, t3, r3, n3, s3) {
      const i3 = e3.body = [], o3 = e3.directives = [];
      this.parseBlockOrModuleBlockBody(i3, t3 ? o3 : void 0, r3, n3, s3);
    }
    parseBlockOrModuleBlockBody(e3, t3, r3, n3, s3) {
      const i3 = this.state.strict;
      let o3 = false, a3 = false;
      for (; !this.match(n3); ) {
        const n4 = r3 ? this.parseModuleItem() : this.parseStatementListItem();
        if (t3 && !a3) {
          if (this.isValidDirective(n4)) {
            const e4 = this.stmtToDirective(n4);
            t3.push(e4), o3 || "use strict" !== e4.value.value || (o3 = true, this.setStrict(true));
            continue;
          }
          a3 = true, this.state.strictErrors.clear();
        }
        e3.push(n4);
      }
      null == s3 || s3.call(this, o3), i3 || this.setStrict(false), this.next();
    }
    parseFor(e3, t3) {
      return e3.init = t3, this.semicolon(false), e3.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), e3.update = this.match(11) ? null : this.parseExpression(), this.expect(11), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e3, "ForStatement");
    }
    parseForIn(e3, t3, r3) {
      const n3 = this.match(58);
      return this.next(), n3 ? null !== r3 && this.unexpected(r3) : e3.await = null !== r3, "VariableDeclaration" !== t3.type || null == t3.declarations[0].init || n3 && this.options.annexB && !this.state.strict && "var" === t3.kind && "Identifier" === t3.declarations[0].id.type || this.raise(v.ForInOfLoopInitializer, t3, { type: n3 ? "ForInStatement" : "ForOfStatement" }), "AssignmentPattern" === t3.type && this.raise(v.InvalidLhs, t3, { ancestor: { type: "ForStatement" } }), e3.left = t3, e3.right = n3 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e3, n3 ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(e3, t3, r3) {
      let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
      const s3 = e3.declarations = [];
      for (e3.kind = r3; ; ) {
        const e4 = this.startNode();
        if (this.parseVarId(e4, r3), e4.init = this.eat(29) ? t3 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, null !== e4.init || n3 || ("Identifier" === e4.id.type || t3 && (this.match(58) || this.isContextual(102)) ? "const" !== r3 || this.match(58) || this.isContextual(102) || this.raise(v.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "const" }) : this.raise(v.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" })), s3.push(this.finishNode(e4, "VariableDeclarator")), !this.eat(12)) break;
      }
      return e3;
    }
    parseVarId(e3, t3) {
      const r3 = this.parseBindingAtom();
      this.checkLVal(r3, { in: { type: "VariableDeclarator" }, binding: "var" === t3 ? 5 : 8201 }), e3.id = r3;
    }
    parseAsyncFunctionExpression(e3) {
      return this.parseFunction(e3, 8);
    }
    parseFunction(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      const r3 = 2 & t3, n3 = !!(1 & t3), s3 = n3 && !(4 & t3), i3 = !!(8 & t3);
      this.initFunction(e3, i3), this.match(55) && (r3 && this.raise(v.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e3.generator = true), n3 && (e3.id = this.parseFunctionId(s3));
      const o3 = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(et(i3, e3.generator)), n3 || (e3.id = this.parseFunctionId()), this.parseFunctionParams(e3, false), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e3, n3 ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), n3 && !r3 && this.registerFunctionStatementId(e3), this.state.maybeInArrowParameters = o3, e3;
    }
    parseFunctionId(e3) {
      return e3 || W(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(e3, t3) {
      this.expect(10), this.expressionScope.enter(new Xe(3)), e3.params = this.parseBindingList(11, 41, 2 | (t3 ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(e3) {
      e3.id && this.scope.declareName(e3.id.name, !this.options.annexB || this.state.strict || e3.generator || e3.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, e3.id.loc.start);
    }
    parseClass(e3, t3, r3) {
      this.next();
      const n3 = this.state.strict;
      return this.state.strict = true, this.parseClassId(e3, t3, r3), this.parseClassSuper(e3), e3.body = this.parseClassBody(!!e3.superClass, n3), this.finishNode(e3, t3 ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(e3) {
      return !(e3.computed || e3.static || "constructor" !== e3.key.name && "constructor" !== e3.key.value);
    }
    parseClassBody(e3, t3) {
      this.classScope.enter();
      const r3 = { hadConstructor: false, hadSuperClass: e3 };
      let n3 = [];
      const s3 = this.startNode();
      if (s3.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (n3.length > 0) throw this.raise(v.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            n3.push(this.parseDecorator());
            continue;
          }
          const e4 = this.startNode();
          n3.length && (e4.decorators = n3, this.resetStartLocationFromNode(e4, n3[0]), n3 = []), this.parseClassMember(s3, e4, r3), "constructor" === e4.kind && e4.decorators && e4.decorators.length > 0 && this.raise(v.DecoratorConstructor, e4);
        }
      }), this.state.strict = t3, this.next(), n3.length) throw this.raise(v.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(s3, "ClassBody");
    }
    parseClassMemberFromModifier(e3, t3) {
      const r3 = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        const n3 = t3;
        return n3.kind = "method", n3.computed = false, n3.key = r3, n3.static = false, this.pushClassMethod(e3, n3, false, false, false, false), true;
      }
      if (this.isClassProperty()) {
        const n3 = t3;
        return n3.computed = false, n3.key = r3, n3.static = false, e3.body.push(this.parseClassProperty(n3)), true;
      }
      return this.resetPreviousNodeTrailingComments(r3), false;
    }
    parseClassMember(e3, t3, r3) {
      const n3 = this.isContextual(106);
      if (n3) {
        if (this.parseClassMemberFromModifier(e3, t3)) return;
        if (this.eat(5)) return void this.parseClassStaticBlock(e3, t3);
      }
      this.parseClassMemberWithIsStatic(e3, t3, r3, n3);
    }
    parseClassMemberWithIsStatic(e3, t3, r3, n3) {
      const s3 = t3, i3 = t3, o3 = t3, a3 = t3, l2 = t3, c2 = s3, u2 = s3;
      if (t3.static = n3, this.parsePropertyNamePrefixOperator(t3), this.eat(55)) {
        c2.kind = "method";
        const t4 = this.match(138);
        return this.parseClassElementName(c2), t4 ? void this.pushClassPrivateMethod(e3, i3, true, false) : (this.isNonstaticConstructor(s3) && this.raise(v.ConstructorIsGenerator, s3.key), void this.pushClassMethod(e3, s3, true, false, false, false));
      }
      const p2 = W(this.state.type) && !this.state.containsEsc, d2 = this.match(138), f2 = this.parseClassElementName(t3), h2 = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(u2), this.isClassMethod()) {
        if (c2.kind = "method", d2) return void this.pushClassPrivateMethod(e3, i3, false, false);
        const n4 = this.isNonstaticConstructor(s3);
        let o4 = false;
        n4 && (s3.kind = "constructor", r3.hadConstructor && !this.hasPlugin("typescript") && this.raise(v.DuplicateConstructor, f2), n4 && this.hasPlugin("typescript") && t3.override && this.raise(v.OverrideOnConstructor, f2), r3.hadConstructor = true, o4 = r3.hadSuperClass), this.pushClassMethod(e3, s3, false, false, n4, o4);
      } else if (this.isClassProperty()) d2 ? this.pushClassPrivateProperty(e3, a3) : this.pushClassProperty(e3, o3);
      else if (p2 && "async" === f2.name && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(f2);
        const t4 = this.eat(55);
        u2.optional && this.unexpected(h2), c2.kind = "method";
        const r4 = this.match(138);
        this.parseClassElementName(c2), this.parsePostMemberNameModifiers(u2), r4 ? this.pushClassPrivateMethod(e3, i3, t4, true) : (this.isNonstaticConstructor(s3) && this.raise(v.ConstructorIsAsync, s3.key), this.pushClassMethod(e3, s3, t4, true, false, false));
      } else if (!p2 || "get" !== f2.name && "set" !== f2.name || this.match(55) && this.isLineTerminator()) if (p2 && "accessor" === f2.name && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(f2);
        const t4 = this.match(138);
        this.parseClassElementName(o3), this.pushClassAccessorProperty(e3, l2, t4);
      } else this.isLineTerminator() ? d2 ? this.pushClassPrivateProperty(e3, a3) : this.pushClassProperty(e3, o3) : this.unexpected();
      else {
        this.resetPreviousNodeTrailingComments(f2), c2.kind = f2.name;
        const t4 = this.match(138);
        this.parseClassElementName(s3), t4 ? this.pushClassPrivateMethod(e3, i3, false, false) : (this.isNonstaticConstructor(s3) && this.raise(v.ConstructorIsAccessor, s3.key), this.pushClassMethod(e3, s3, false, false, false, false)), this.checkGetterSetterParams(s3);
      }
    }
    parseClassElementName(e3) {
      const { type: t3, value: r3 } = this.state;
      if (132 !== t3 && 133 !== t3 || !e3.static || "prototype" !== r3 || this.raise(v.StaticPrototype, this.state.startLoc), 138 === t3) {
        "constructor" === r3 && this.raise(v.ConstructorClassPrivateField, this.state.startLoc);
        const t4 = this.parsePrivateName();
        return e3.key = t4, t4;
      }
      return this.parsePropertyName(e3);
    }
    parseClassStaticBlock(e3, t3) {
      var r3;
      this.scope.enter(208);
      const n3 = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      const s3 = t3.body = [];
      this.parseBlockOrModuleBlockBody(s3, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = n3, e3.body.push(this.finishNode(t3, "StaticBlock")), null != (r3 = t3.decorators) && r3.length && this.raise(v.DecoratorStaticBlock, t3);
    }
    pushClassProperty(e3, t3) {
      t3.computed || "constructor" !== t3.key.name && "constructor" !== t3.key.value || this.raise(v.ConstructorClassField, t3.key), e3.body.push(this.parseClassProperty(t3));
    }
    pushClassPrivateProperty(e3, t3) {
      const r3 = this.parseClassPrivateProperty(t3);
      e3.body.push(r3), this.classScope.declarePrivateName(this.getPrivateNameSV(r3.key), 0, r3.key.loc.start);
    }
    pushClassAccessorProperty(e3, t3, r3) {
      if (!r3 && !t3.computed) {
        const e4 = t3.key;
        "constructor" !== e4.name && "constructor" !== e4.value || this.raise(v.ConstructorClassField, e4);
      }
      const n3 = this.parseClassAccessorProperty(t3);
      e3.body.push(n3), r3 && this.classScope.declarePrivateName(this.getPrivateNameSV(n3.key), 0, n3.key.loc.start);
    }
    pushClassMethod(e3, t3, r3, n3, s3, i3) {
      e3.body.push(this.parseMethod(t3, r3, n3, s3, i3, "ClassMethod", true));
    }
    pushClassPrivateMethod(e3, t3, r3, n3) {
      const s3 = this.parseMethod(t3, r3, n3, false, false, "ClassPrivateMethod", true);
      e3.body.push(s3);
      const i3 = "get" === s3.kind ? s3.static ? 6 : 2 : "set" === s3.kind ? s3.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(s3, i3);
    }
    declareClassPrivateMethodInScope(e3, t3) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e3.key), t3, e3.key.loc.start);
    }
    parsePostMemberNameModifiers(e3) {
    }
    parseClassPrivateProperty(e3) {
      return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassPrivateProperty");
    }
    parseClassProperty(e3) {
      return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassProperty");
    }
    parseClassAccessorProperty(e3) {
      return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassAccessorProperty");
    }
    parseInitializer(e3) {
      this.scope.enter(80), this.expressionScope.enter(Qe()), this.prodParam.enter(0), e3.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(e3, t3, r3) {
      let n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8331;
      if (W(this.state.type)) e3.id = this.parseIdentifier(), t3 && this.declareNameFromIdentifier(e3.id, n3);
      else {
        if (!r3 && t3) throw this.raise(v.MissingClassName, this.state.startLoc);
        e3.id = null;
      }
    }
    parseClassSuper(e3) {
      e3.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(e3, t3) {
      const r3 = this.parseMaybeImportPhase(e3, true), n3 = this.maybeParseExportDefaultSpecifier(e3, r3), s3 = !n3 || this.eat(12), i3 = s3 && this.eatExportStar(e3), o3 = i3 && this.maybeParseExportNamespaceSpecifier(e3), a3 = s3 && (!o3 || this.eat(12)), l2 = n3 || i3;
      if (i3 && !o3) {
        if (n3 && this.unexpected(), t3) throw this.raise(v.UnsupportedDecoratorExport, e3);
        return this.parseExportFrom(e3, true), this.finishNode(e3, "ExportAllDeclaration");
      }
      const c2 = this.maybeParseExportNamedSpecifiers(e3);
      let u2;
      if (n3 && s3 && !i3 && !c2 && this.unexpected(null, 5), o3 && a3 && this.unexpected(null, 98), l2 || c2) {
        if (u2 = false, t3) throw this.raise(v.UnsupportedDecoratorExport, e3);
        this.parseExportFrom(e3, l2);
      } else u2 = this.maybeParseExportDeclaration(e3);
      if (l2 || c2 || u2) {
        var p2;
        const r4 = e3;
        if (this.checkExport(r4, true, false, !!r4.source), "ClassDeclaration" === (null == (p2 = r4.declaration) ? void 0 : p2.type)) this.maybeTakeDecorators(t3, r4.declaration, r4);
        else if (t3) throw this.raise(v.UnsupportedDecoratorExport, e3);
        return this.finishNode(r4, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        const r4 = e3, n4 = this.parseExportDefaultExpression();
        if (r4.declaration = n4, "ClassDeclaration" === n4.type) this.maybeTakeDecorators(t3, n4, r4);
        else if (t3) throw this.raise(v.UnsupportedDecoratorExport, e3);
        return this.checkExport(r4, true, true), this.finishNode(r4, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(e3) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(e3, t3) {
      if (t3 || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", null == t3 ? void 0 : t3.loc.start);
        const r3 = t3 || this.parseIdentifier(true), n3 = this.startNodeAtNode(r3);
        return n3.exported = r3, e3.specifiers = [this.finishNode(n3, "ExportDefaultSpecifier")], true;
      }
      return false;
    }
    maybeParseExportNamespaceSpecifier(e3) {
      if (this.isContextual(93)) {
        e3.specifiers || (e3.specifiers = []);
        const t3 = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), t3.exported = this.parseModuleExportName(), e3.specifiers.push(this.finishNode(t3, "ExportNamespaceSpecifier")), true;
      }
      return false;
    }
    maybeParseExportNamedSpecifiers(e3) {
      if (this.match(5)) {
        e3.specifiers || (e3.specifiers = []);
        const t3 = "type" === e3.exportKind;
        return e3.specifiers.push(...this.parseExportSpecifiers(t3)), e3.source = null, e3.declaration = null, this.hasPlugin("importAssertions") && (e3.assertions = []), true;
      }
      return false;
    }
    maybeParseExportDeclaration(e3) {
      return !!this.shouldParseExportDeclaration() && (e3.specifiers = [], e3.source = null, this.hasPlugin("importAssertions") && (e3.assertions = []), e3.declaration = this.parseExportDeclaration(e3), true);
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return false;
      const e3 = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e3, "function");
    }
    parseExportDefaultExpression() {
      const e3 = this.startNode();
      if (this.match(68)) return this.next(), this.parseFunction(e3, 5);
      if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(e3, 13);
      if (this.match(80)) return this.parseClass(e3, true, true);
      if (this.match(26)) return this.hasPlugin("decorators") && true === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(v.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
      if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(v.UnsupportedDefaultExport, this.state.startLoc);
      const t3 = this.parseMaybeAssignAllowIn();
      return this.semicolon(), t3;
    }
    parseExportDeclaration(e3) {
      return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      const { type: e3 } = this.state;
      if (W(e3)) {
        if (95 === e3 && !this.state.containsEsc || 100 === e3) return false;
        if ((130 === e3 || 129 === e3) && !this.state.containsEsc) {
          const { type: e4 } = this.lookahead();
          if (W(e4) && 98 !== e4 || 5 === e4) return this.expectOnePlugin(["flow", "typescript"]), false;
        }
      } else if (!this.match(65)) return false;
      const t3 = this.nextTokenStart(), r3 = this.isUnparsedContextual(t3, "from");
      if (44 === this.input.charCodeAt(t3) || W(this.state.type) && r3) return true;
      if (this.match(65) && r3) {
        const e4 = this.input.charCodeAt(this.nextTokenStartSince(t3 + 4));
        return 34 === e4 || 39 === e4;
      }
      return false;
    }
    parseExportFrom(e3, t3) {
      this.eatContextual(98) ? (e3.source = this.parseImportSource(), this.checkExport(e3), this.maybeParseImportAttributes(e3), this.checkJSONModuleImport(e3)) : t3 && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      const { type: e3 } = this.state;
      return 26 === e3 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (true === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(v.DecoratorBeforeExport, this.state.startLoc), true) : 74 === e3 || 75 === e3 || 68 === e3 || 80 === e3 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(e3, t3, r3, n3) {
      var s3;
      if (t3) {
        if (r3) {
          if (this.checkDuplicateExports(e3, "default"), this.hasPlugin("exportDefaultFrom")) {
            var i3;
            const t4 = e3.declaration;
            "Identifier" !== t4.type || "from" !== t4.name || t4.end - t4.start != 4 || null != (i3 = t4.extra) && i3.parenthesized || this.raise(v.ExportDefaultFromAsIdentifier, t4);
          }
        } else if (null != (s3 = e3.specifiers) && s3.length) for (const t4 of e3.specifiers) {
          const { exported: e4 } = t4, r4 = "Identifier" === e4.type ? e4.name : e4.value;
          if (this.checkDuplicateExports(t4, r4), !n3 && t4.local) {
            const { local: e5 } = t4;
            "Identifier" !== e5.type ? this.raise(v.ExportBindingIsString, t4, { localName: e5.value, exportName: r4 }) : (this.checkReservedWord(e5.name, e5.loc.start, true, false), this.scope.checkLocalExport(e5));
          }
        }
        else if (e3.declaration) {
          if ("FunctionDeclaration" === e3.declaration.type || "ClassDeclaration" === e3.declaration.type) {
            const t4 = e3.declaration.id;
            if (!t4) throw new Error("Assertion failure");
            this.checkDuplicateExports(e3, t4.name);
          } else if ("VariableDeclaration" === e3.declaration.type) for (const t4 of e3.declaration.declarations) this.checkDeclaration(t4.id);
        }
      }
    }
    checkDeclaration(e3) {
      if ("Identifier" === e3.type) this.checkDuplicateExports(e3, e3.name);
      else if ("ObjectPattern" === e3.type) for (const t3 of e3.properties) this.checkDeclaration(t3);
      else if ("ArrayPattern" === e3.type) for (const t3 of e3.elements) t3 && this.checkDeclaration(t3);
      else "ObjectProperty" === e3.type ? this.checkDeclaration(e3.value) : "RestElement" === e3.type ? this.checkDeclaration(e3.argument) : "AssignmentPattern" === e3.type && this.checkDeclaration(e3.left);
    }
    checkDuplicateExports(e3, t3) {
      this.exportedIdentifiers.has(t3) && ("default" === t3 ? this.raise(v.DuplicateDefaultExport, e3) : this.raise(v.DuplicateExport, e3, { exportName: t3 })), this.exportedIdentifiers.add(t3);
    }
    parseExportSpecifiers(e3) {
      const t3 = [];
      let r3 = true;
      for (this.expect(5); !this.eat(8); ) {
        if (r3) r3 = false;
        else if (this.expect(12), this.eat(8)) break;
        const n3 = this.isContextual(130), s3 = this.match(133), i3 = this.startNode();
        i3.local = this.parseModuleExportName(), t3.push(this.parseExportSpecifier(i3, s3, e3, n3));
      }
      return t3;
    }
    parseExportSpecifier(e3, t3, r3, n3) {
      return this.eatContextual(93) ? e3.exported = this.parseModuleExportName() : t3 ? e3.exported = function(e4) {
        const { type: t4, start: r4, end: n4, loc: s3, range: i3, extra: o3 } = e4;
        if ("Placeholder" === t4) return function(e5) {
          return it(e5);
        }(e4);
        const a3 = Object.create(st);
        return a3.type = t4, a3.start = r4, a3.end = n4, a3.loc = s3, a3.range = i3, void 0 !== e4.raw ? a3.raw = e4.raw : a3.extra = o3, a3.value = e4.value, a3;
      }(e3.local) : e3.exported || (e3.exported = it(e3.local)), this.finishNode(e3, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        const e3 = this.parseStringLiteral(this.state.value), t3 = e3.value.match(Ut);
        return t3 && this.raise(v.ModuleExportNameHasLoneSurrogate, e3, { surrogateCharCode: t3[0].charCodeAt(0) }), e3;
      }
      return this.parseIdentifier(true);
    }
    isJSONModuleImport(e3) {
      return null != e3.assertions && e3.assertions.some((e4) => {
        let { key: t3, value: r3 } = e4;
        return "json" === r3.value && ("Identifier" === t3.type ? "type" === t3.name : "type" === t3.value);
      });
    }
    checkImportReflection(e3) {
      const { specifiers: t3 } = e3, r3 = 1 === t3.length ? t3[0].type : null;
      if ("source" === e3.phase) "ImportDefaultSpecifier" !== r3 && this.raise(v.SourcePhaseImportRequiresDefault, t3[0].loc.start);
      else if ("defer" === e3.phase) "ImportNamespaceSpecifier" !== r3 && this.raise(v.DeferImportRequiresNamespace, t3[0].loc.start);
      else if (e3.module) {
        var n3;
        "ImportDefaultSpecifier" !== r3 && this.raise(v.ImportReflectionNotBinding, t3[0].loc.start), (null == (n3 = e3.assertions) ? void 0 : n3.length) > 0 && this.raise(v.ImportReflectionHasAssertion, t3[0].loc.start);
      }
    }
    checkJSONModuleImport(e3) {
      if (this.isJSONModuleImport(e3) && "ExportAllDeclaration" !== e3.type) {
        const { specifiers: t3 } = e3;
        if (null != t3) {
          const e4 = t3.find((e5) => {
            let t4;
            if ("ExportSpecifier" === e5.type ? t4 = e5.local : "ImportSpecifier" === e5.type && (t4 = e5.imported), void 0 !== t4) return "Identifier" === t4.type ? "default" !== t4.name : "default" !== t4.value;
          });
          void 0 !== e4 && this.raise(v.ImportJSONBindingNotDefault, e4.loc.start);
        }
      }
    }
    isPotentialImportPhase(e3) {
      return !e3 && (this.isContextual(105) || this.isContextual(97) || this.isContextual(127));
    }
    applyImportPhase(e3, t3, r3, n3) {
      t3 || ("module" === r3 ? (this.expectPlugin("importReflection", n3), e3.module = true) : this.hasPlugin("importReflection") && (e3.module = false), "source" === r3 ? (this.expectPlugin("sourcePhaseImports", n3), e3.phase = "source") : "defer" === r3 ? (this.expectPlugin("deferredImportEvaluation", n3), e3.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e3.phase = null));
    }
    parseMaybeImportPhase(e3, t3) {
      if (!this.isPotentialImportPhase(t3)) return this.applyImportPhase(e3, t3, null), null;
      const r3 = this.parseIdentifier(true), { type: n3 } = this.state;
      return (G(n3) ? 98 !== n3 || 102 === this.lookaheadCharCode() : 12 !== n3) ? (this.resetPreviousIdentifierLeadingComments(r3), this.applyImportPhase(e3, t3, r3.name, r3.loc.start), null) : (this.applyImportPhase(e3, t3, null), r3);
    }
    isPrecedingIdImportPhase(e3) {
      const { type: t3 } = this.state;
      return W(t3) ? 98 !== t3 || 102 === this.lookaheadCharCode() : 12 !== t3;
    }
    parseImport(e3) {
      return this.match(133) ? this.parseImportSourceAndAttributes(e3) : this.parseImportSpecifiersAndAfter(e3, this.parseMaybeImportPhase(e3, false));
    }
    parseImportSpecifiersAndAfter(e3, t3) {
      e3.specifiers = [];
      const r3 = !this.maybeParseDefaultImportSpecifier(e3, t3) || this.eat(12), n3 = r3 && this.maybeParseStarImportSpecifier(e3);
      return r3 && !n3 && this.parseNamedImportSpecifiers(e3), this.expectContextual(98), this.parseImportSourceAndAttributes(e3);
    }
    parseImportSourceAndAttributes(e3) {
      return null != e3.specifiers || (e3.specifiers = []), e3.source = this.parseImportSource(), this.maybeParseImportAttributes(e3), this.checkImportReflection(e3), this.checkJSONModuleImport(e3), this.semicolon(), this.finishNode(e3, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(e3, t3, r3) {
      t3.local = this.parseIdentifier(), e3.specifiers.push(this.finishImportSpecifier(t3, r3));
    }
    finishImportSpecifier(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8201;
      return this.checkLVal(e3.local, { in: { type: t3 }, binding: r3 }), this.finishNode(e3, t3);
    }
    parseImportAttributes() {
      this.expect(5);
      const e3 = [], t3 = /* @__PURE__ */ new Set();
      do {
        if (this.match(8)) break;
        const r3 = this.startNode(), n3 = this.state.value;
        if (t3.has(n3) && this.raise(v.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: n3 }), t3.add(n3), this.match(133) ? r3.key = this.parseStringLiteral(n3) : r3.key = this.parseIdentifier(true), this.expect(14), !this.match(133)) throw this.raise(v.ModuleAttributeInvalidValue, this.state.startLoc);
        r3.value = this.parseStringLiteral(this.state.value), e3.push(this.finishNode(r3, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), e3;
    }
    parseModuleAttributes() {
      const e3 = [], t3 = /* @__PURE__ */ new Set();
      do {
        const r3 = this.startNode();
        if (r3.key = this.parseIdentifier(true), "type" !== r3.key.name && this.raise(v.ModuleAttributeDifferentFromType, r3.key), t3.has(r3.key.name) && this.raise(v.ModuleAttributesWithDuplicateKeys, r3.key, { key: r3.key.name }), t3.add(r3.key.name), this.expect(14), !this.match(133)) throw this.raise(v.ModuleAttributeInvalidValue, this.state.startLoc);
        r3.value = this.parseStringLiteral(this.state.value), e3.push(this.finishNode(r3, "ImportAttribute"));
      } while (this.eat(12));
      return e3;
    }
    maybeParseImportAttributes(e3) {
      let t3, r3 = false;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && 40 === this.lookaheadCharCode()) return;
        this.next(), this.hasPlugin("moduleAttributes") ? t3 = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), t3 = this.parseImportAttributes()), r3 = true;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) this.hasPlugin("importAttributes") ? (true !== this.getPluginOption("importAttributes", "deprecatedAssertSyntax") && this.raise(v.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(e3, "deprecatedAssertSyntax", true)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), t3 = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) t3 = [];
      else {
        if (!this.hasPlugin("moduleAttributes")) return;
        t3 = [];
      }
      !r3 && this.hasPlugin("importAssertions") ? e3.assertions = t3 : e3.attributes = t3;
    }
    maybeParseDefaultImportSpecifier(e3, t3) {
      if (t3) {
        const r3 = this.startNodeAtNode(t3);
        return r3.local = t3, e3.specifiers.push(this.finishImportSpecifier(r3, "ImportDefaultSpecifier")), true;
      }
      return !!G(this.state.type) && (this.parseImportSpecifierLocal(e3, this.startNode(), "ImportDefaultSpecifier"), true);
    }
    maybeParseStarImportSpecifier(e3) {
      if (this.match(55)) {
        const t3 = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e3, t3, "ImportNamespaceSpecifier"), true;
      }
      return false;
    }
    parseNamedImportSpecifiers(e3) {
      let t3 = true;
      for (this.expect(5); !this.eat(8); ) {
        if (t3) t3 = false;
        else {
          if (this.eat(14)) throw this.raise(v.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        const r3 = this.startNode(), n3 = this.match(133), s3 = this.isContextual(130);
        r3.imported = this.parseModuleExportName();
        const i3 = this.parseImportSpecifier(r3, n3, "type" === e3.importKind || "typeof" === e3.importKind, s3, void 0);
        e3.specifiers.push(i3);
      }
    }
    parseImportSpecifier(e3, t3, r3, n3, s3) {
      if (this.eatContextual(93)) e3.local = this.parseIdentifier();
      else {
        const { imported: r4 } = e3;
        if (t3) throw this.raise(v.ImportBindingIsString, e3, { importName: r4.value });
        this.checkReservedWord(r4.name, e3.loc.start, true, true), e3.local || (e3.local = it(r4));
      }
      return this.finishImportSpecifier(e3, "ImportSpecifier", s3);
    }
    isThisParam(e3) {
      return "Identifier" === e3.type && "this" === e3.name;
    }
  }
  class qt extends Vt {
    constructor(e3, t3) {
      super(e3 = function(e4) {
        if (null == e4) return Object.assign({}, Mt);
        if (null != e4.annexB && false !== e4.annexB) throw new Error("The `annexB` option can only be set to `false`.");
        const t4 = {};
        for (const n3 of Object.keys(Mt)) {
          var r3;
          t4[n3] = null != (r3 = e4[n3]) ? r3 : Mt[n3];
        }
        return t4;
      }(e3), t3), this.options = e3, this.initializeScopes(), this.plugins = function(e4) {
        const t4 = /* @__PURE__ */ new Map();
        for (const r3 of e4) {
          const [e5, n3] = Array.isArray(r3) ? r3 : [r3, {}];
          t4.has(e5) || t4.set(e5, n3 || {});
        }
        return t4;
      }(this.options.plugins), this.filename = e3.sourceFilename;
    }
    getScopeHandler() {
      return be;
    }
    parse() {
      this.enterInitialScopes();
      const e3 = this.startNode(), t3 = this.startNode();
      return this.nextToken(), e3.errors = null, this.parseTopLevel(e3, t3), e3.errors = this.state.errors, e3.comments.length = this.state.commentsLen, e3;
    }
  }
  const Wt = function(e3) {
    const t3 = {};
    for (const r3 of Object.keys(e3)) t3[r3] = Z(e3[r3]);
    return t3;
  }(q);
  function Gt(e3, t3) {
    let r3 = qt;
    return null != e3 && e3.plugins && (function(e4) {
      if (It(e4, "decorators")) {
        if (It(e4, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        const t4 = _t(e4, "decorators", "decoratorsBeforeExport");
        if (null != t4 && "boolean" != typeof t4) throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        const r4 = _t(e4, "decorators", "allowCallParenthesized");
        if (null != r4 && "boolean" != typeof r4) throw new Error("'allowCallParenthesized' must be a boolean.");
      }
      if (It(e4, "flow") && It(e4, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
      if (It(e4, "placeholders") && It(e4, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      if (It(e4, "pipelineOperator")) {
        const t4 = _t(e4, "pipelineOperator", "proposal");
        if (!kt.includes(t4)) {
          const e5 = kt.map((e6) => `"${e6}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e5}.`);
        }
        const r4 = It(e4, ["recordAndTuple", { syntaxType: "hash" }]);
        if ("hack" === t4) {
          if (It(e4, "placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          if (It(e4, "v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          const t5 = _t(e4, "pipelineOperator", "topicToken");
          if (!Nt.includes(t5)) {
            const e5 = Nt.map((e6) => `"${e6}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e5}.`);
          }
          if ("#" === t5 && r4) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        } else if ("smart" === t4 && r4) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      }
      if (It(e4, "moduleAttributes")) {
        if (It(e4, "importAssertions") || It(e4, "importAttributes")) throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
        if ("may-2020" !== _t(e4, "moduleAttributes", "version")) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
      }
      if (It(e4, "importAssertions") && It(e4, "importAttributes")) throw new Error("Cannot combine importAssertions and importAttributes plugins.");
      if (It(e4, "recordAndTuple") && null != _t(e4, "recordAndTuple", "syntaxType") && !Dt.includes(_t(e4, "recordAndTuple", "syntaxType"))) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + Dt.map((e5) => `'${e5}'`).join(", "));
      if (It(e4, "asyncDoExpressions") && !It(e4, "doExpressions")) {
        const e5 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        throw e5.missingPlugins = "doExpressions", e5;
      }
      if (It(e4, "optionalChainingAssign") && "2023-07" !== _t(e4, "optionalChainingAssign", "version")) throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
    }(e3.plugins), r3 = function(e4) {
      const t4 = Lt.filter((t5) => It(e4, t5)), r4 = t4.join("/");
      let n3 = Ht[r4];
      if (!n3) {
        n3 = qt;
        for (const e5 of t4) n3 = jt[e5](n3);
        Ht[r4] = n3;
      }
      return n3;
    }(e3.plugins)), new r3(e3, t3);
  }
  const Ht = {};
  t2.parse = function(e3, t3) {
    var r3;
    if ("unambiguous" !== (null == (r3 = t3) ? void 0 : r3.sourceType)) return Gt(t3, e3).parse();
    t3 = Object.assign({}, t3);
    try {
      t3.sourceType = "module";
      const r4 = Gt(t3, e3), n3 = r4.parse();
      if (r4.sawUnambiguousESM) return n3;
      if (r4.ambiguousScriptDifferentAst) try {
        return t3.sourceType = "script", Gt(t3, e3).parse();
      } catch (e4) {
      }
      else n3.program.sourceType = "script";
      return n3;
    } catch (r4) {
      try {
        return t3.sourceType = "script", Gt(t3, e3).parse();
      } catch (e4) {
      }
      throw r4;
    }
  }, t2.parseExpression = function(e3, t3) {
    const r3 = Gt(t3, e3);
    return r3.options.strictMode && (r3.state.strict = true), r3.getExpression();
  }, t2.tokTypes = Wt;
}, (e2, t2, r2) => {
  var n2;
  r2(12);
  var s2 = SyntaxError, i2 = Function, o2 = TypeError, a2 = function(e3) {
    try {
      return i2('"use strict"; return (' + e3 + ").constructor;")();
    } catch (e4) {
    }
  }, l = Object.getOwnPropertyDescriptor;
  if (l) try {
    l({}, "");
  } catch (e3) {
    l = null;
  }
  var c = function() {
    throw new o2();
  }, u = l ? function() {
    try {
      return c;
    } catch (e3) {
      try {
        return l(arguments, "callee").get;
      } catch (e4) {
        return c;
      }
    }
  }() : c, p = r2(230)(), d = r2(231)(), f = Object.getPrototypeOf || (d ? function(e3) {
    return e3.__proto__;
  } : null), h = {}, m = "undefined" != typeof Uint8Array && f ? f(Uint8Array) : n2, y = { "%AggregateError%": "undefined" == typeof AggregateError ? n2 : AggregateError, "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? n2 : ArrayBuffer, "%ArrayIteratorPrototype%": p && f ? f([][Symbol.iterator]()) : n2, "%AsyncFromSyncIteratorPrototype%": n2, "%AsyncFunction%": h, "%AsyncGenerator%": h, "%AsyncGeneratorFunction%": h, "%AsyncIteratorPrototype%": h, "%Atomics%": "undefined" == typeof Atomics ? n2 : Atomics, "%BigInt%": "undefined" == typeof BigInt ? n2 : BigInt, "%BigInt64Array%": "undefined" == typeof BigInt64Array ? n2 : BigInt64Array, "%BigUint64Array%": "undefined" == typeof BigUint64Array ? n2 : BigUint64Array, "%Boolean%": Boolean, "%DataView%": "undefined" == typeof DataView ? n2 : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": "undefined" == typeof Float32Array ? n2 : Float32Array, "%Float64Array%": "undefined" == typeof Float64Array ? n2 : Float64Array, "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? n2 : FinalizationRegistry, "%Function%": i2, "%GeneratorFunction%": h, "%Int8Array%": "undefined" == typeof Int8Array ? n2 : Int8Array, "%Int16Array%": "undefined" == typeof Int16Array ? n2 : Int16Array, "%Int32Array%": "undefined" == typeof Int32Array ? n2 : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": p && f ? f(f([][Symbol.iterator]())) : n2, "%JSON%": "object" == typeof JSON ? JSON : n2, "%Map%": "undefined" == typeof Map ? n2 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && p && f ? f((/* @__PURE__ */ new Map())[Symbol.iterator]()) : n2, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? n2 : Promise, "%Proxy%": "undefined" == typeof Proxy ? n2 : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": "undefined" == typeof Reflect ? n2 : Reflect, "%RegExp%": RegExp, "%Set%": "undefined" == typeof Set ? n2 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && p && f ? f((/* @__PURE__ */ new Set())[Symbol.iterator]()) : n2, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? n2 : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": p && f ? f(""[Symbol.iterator]()) : n2, "%Symbol%": p ? Symbol : n2, "%SyntaxError%": s2, "%ThrowTypeError%": u, "%TypedArray%": m, "%TypeError%": o2, "%Uint8Array%": "undefined" == typeof Uint8Array ? n2 : Uint8Array, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? n2 : Uint8ClampedArray, "%Uint16Array%": "undefined" == typeof Uint16Array ? n2 : Uint16Array, "%Uint32Array%": "undefined" == typeof Uint32Array ? n2 : Uint32Array, "%URIError%": URIError, "%WeakMap%": "undefined" == typeof WeakMap ? n2 : WeakMap, "%WeakRef%": "undefined" == typeof WeakRef ? n2 : WeakRef, "%WeakSet%": "undefined" == typeof WeakSet ? n2 : WeakSet };
  if (f) try {
    null.error;
  } catch (e3) {
    var g = f(f(e3));
    y["%Error.prototype%"] = g;
  }
  var b = function e3(t3) {
    var r3;
    if ("%AsyncFunction%" === t3) r3 = a2("async function () {}");
    else if ("%GeneratorFunction%" === t3) r3 = a2("function* () {}");
    else if ("%AsyncGeneratorFunction%" === t3) r3 = a2("async function* () {}");
    else if ("%AsyncGenerator%" === t3) {
      var n3 = e3("%AsyncGeneratorFunction%");
      n3 && (r3 = n3.prototype);
    } else if ("%AsyncIteratorPrototype%" === t3) {
      var s3 = e3("%AsyncGenerator%");
      s3 && f && (r3 = f(s3.prototype));
    }
    return y[t3] = r3, r3;
  }, v = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, E = r2(71), S = r2(233), x = E.call(Function.call, Array.prototype.concat), T = E.call(Function.apply, Array.prototype.splice), w = E.call(Function.call, String.prototype.replace), P = E.call(Function.call, String.prototype.slice), A = E.call(Function.call, RegExp.prototype.exec), C = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, O = /\\(\\)?/g, I = function(e3, t3) {
    var r3, n3 = e3;
    if (S(v, n3) && (n3 = "%" + (r3 = v[n3])[0] + "%"), S(y, n3)) {
      var i3 = y[n3];
      if (i3 === h && (i3 = b(n3)), void 0 === i3 && !t3) throw new o2("intrinsic " + e3 + " exists, but is not available. Please file an issue!");
      return { alias: r3, name: n3, value: i3 };
    }
    throw new s2("intrinsic " + e3 + " does not exist!");
  };
  e2.exports = function(e3, t3) {
    if ("string" != typeof e3 || 0 === e3.length) throw new o2("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && "boolean" != typeof t3) throw new o2('"allowMissing" argument must be a boolean');
    if (null === A(/^%?[^%]*%?$/, e3)) throw new s2("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var r3 = function(e4) {
      var t4 = P(e4, 0, 1), r4 = P(e4, -1);
      if ("%" === t4 && "%" !== r4) throw new s2("invalid intrinsic syntax, expected closing `%`");
      if ("%" === r4 && "%" !== t4) throw new s2("invalid intrinsic syntax, expected opening `%`");
      var n4 = [];
      return w(e4, C, function(e5, t5, r5, s3) {
        n4[n4.length] = r5 ? w(s3, O, "$1") : t5 || e5;
      }), n4;
    }(e3), n3 = r3.length > 0 ? r3[0] : "", i3 = I("%" + n3 + "%", t3), a3 = i3.name, c2 = i3.value, u2 = false, p2 = i3.alias;
    p2 && (n3 = p2[0], T(r3, x([0, 1], p2)));
    for (var d2 = 1, f2 = true; d2 < r3.length; d2 += 1) {
      var h2 = r3[d2], m2 = P(h2, 0, 1), g2 = P(h2, -1);
      if (('"' === m2 || "'" === m2 || "`" === m2 || '"' === g2 || "'" === g2 || "`" === g2) && m2 !== g2) throw new s2("property names with quotes must have matching quotes");
      if ("constructor" !== h2 && f2 || (u2 = true), S(y, a3 = "%" + (n3 += "." + h2) + "%")) c2 = y[a3];
      else if (null != c2) {
        if (!(h2 in c2)) {
          if (!t3) throw new o2("base intrinsic for " + e3 + " exists, but the property is not available.");
          return;
        }
        if (l && d2 + 1 >= r3.length) {
          var b2 = l(c2, h2);
          c2 = (f2 = !!b2) && "get" in b2 && !("originalValue" in b2.get) ? b2.get : c2[h2];
        } else f2 = S(c2, h2), c2 = c2[h2];
        f2 && !u2 && (y[a3] = c2);
      }
    }
    return c2;
  };
}, (e2, t2, r2) => {
  const n2 = r2(34), s2 = r2(47), i2 = r2(3), o2 = r2(128), a2 = r2(30), l = r2(253), c = r2(254), u = r2(255), p = r2(256), d = r2(257), f = r2(258), h = r2(259), m = r2(260), y = r2(7), g = r2(261), b = r2(262), v = r2(76), E = r2(263), S = r2(264), x = r2(49), T = r2(77), w = r2(129), P = r2(130), A = r2(78), C = r2(79), O = r2(131), I = r2(265), _ = r2(50), k = r2(8), N = r2(51), D = r2(268), j = r2(269), L = r2(270), M = r2(271), B = r2(272), R = r2(80), F = r2(273), U = r2(274), $ = r2(275), V = r2(276), q = r2(277);
  e2.exports = { parse: a2, valid: l, clean: c, inc: u, diff: p, major: d, minor: f, patch: h, prerelease: m, compare: y, rcompare: g, compareLoose: b, compareBuild: v, sort: E, rsort: S, gt: x, lt: T, eq: w, neq: P, gte: A, lte: C, cmp: O, coerce: I, Comparator: _, Range: k, satisfies: N, toComparators: D, maxSatisfying: j, minSatisfying: L, minVersion: M, validRange: B, outside: R, gtr: F, ltr: U, intersects: $, simplifyRange: V, subset: q, SemVer: i2, re: n2.re, src: n2.src, tokens: n2.t, SEMVER_SPEC_VERSION: s2.SEMVER_SPEC_VERSION, RELEASE_TYPES: s2.RELEASE_TYPES, compareIdentifiers: o2.compareIdentifiers, rcompareIdentifiers: o2.rcompareIdentifiers };
}, (e2, t2, r2) => {
  let n2, s2, i2, o2, { isClean: a2, my: l } = r2(145), c = r2(52), u = r2(56), p = r2(53);
  function d(e3) {
    return e3.map((e4) => (e4.nodes && (e4.nodes = d(e4.nodes)), delete e4.source, e4));
  }
  function f(e3) {
    if (e3[a2] = false, e3.proxyOf.nodes) for (let t3 of e3.proxyOf.nodes) f(t3);
  }
  class h extends p {
    append() {
      for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
      for (let e4 of t3) {
        let t4 = this.normalize(e4, this.last);
        for (let e5 of t4) this.proxyOf.nodes.push(e5);
      }
      return this.markDirty(), this;
    }
    cleanRaws(e3) {
      if (super.cleanRaws(e3), this.nodes) for (let t3 of this.nodes) t3.cleanRaws(e3);
    }
    each(e3) {
      if (!this.proxyOf.nodes) return;
      let t3, r3, n3 = this.getIterator();
      for (; this.indexes[n3] < this.proxyOf.nodes.length && (t3 = this.indexes[n3], r3 = e3(this.proxyOf.nodes[t3], t3), false !== r3); ) this.indexes[n3] += 1;
      return delete this.indexes[n3], r3;
    }
    every(e3) {
      return this.nodes.every(e3);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let e3 = this.lastEach;
      return this.indexes[e3] = 0, e3;
    }
    getProxyProcessor() {
      return { get: (e3, t3) => "proxyOf" === t3 ? e3 : e3[t3] ? "each" === t3 || "string" == typeof t3 && t3.startsWith("walk") ? function() {
        for (var r3 = arguments.length, n3 = new Array(r3), s3 = 0; s3 < r3; s3++) n3[s3] = arguments[s3];
        return e3[t3](...n3.map((e4) => "function" == typeof e4 ? (t4, r4) => e4(t4.toProxy(), r4) : e4));
      } : "every" === t3 || "some" === t3 ? (r3) => e3[t3](function(e4) {
        for (var t4 = arguments.length, n3 = new Array(t4 > 1 ? t4 - 1 : 0), s3 = 1; s3 < t4; s3++) n3[s3 - 1] = arguments[s3];
        return r3(e4.toProxy(), ...n3);
      }) : "root" === t3 ? () => e3.root().toProxy() : "nodes" === t3 ? e3.nodes.map((e4) => e4.toProxy()) : "first" === t3 || "last" === t3 ? e3[t3].toProxy() : e3[t3] : e3[t3], set: (e3, t3, r3) => (e3[t3] === r3 || (e3[t3] = r3, "name" !== t3 && "params" !== t3 && "selector" !== t3 || e3.markDirty()), true) };
    }
    index(e3) {
      return "number" == typeof e3 ? e3 : (e3.proxyOf && (e3 = e3.proxyOf), this.proxyOf.nodes.indexOf(e3));
    }
    insertAfter(e3, t3) {
      let r3, n3 = this.index(e3), s3 = this.normalize(t3, this.proxyOf.nodes[n3]).reverse();
      n3 = this.index(e3);
      for (let e4 of s3) this.proxyOf.nodes.splice(n3 + 1, 0, e4);
      for (let e4 in this.indexes) r3 = this.indexes[e4], n3 < r3 && (this.indexes[e4] = r3 + s3.length);
      return this.markDirty(), this;
    }
    insertBefore(e3, t3) {
      let r3, n3 = this.index(e3), s3 = 0 === n3 && "prepend", i3 = this.normalize(t3, this.proxyOf.nodes[n3], s3).reverse();
      n3 = this.index(e3);
      for (let e4 of i3) this.proxyOf.nodes.splice(n3, 0, e4);
      for (let e4 in this.indexes) r3 = this.indexes[e4], n3 <= r3 && (this.indexes[e4] = r3 + i3.length);
      return this.markDirty(), this;
    }
    normalize(e3, t3) {
      if ("string" == typeof e3) e3 = d(n2(e3).nodes);
      else if (Array.isArray(e3)) {
        e3 = e3.slice(0);
        for (let t4 of e3) t4.parent && t4.parent.removeChild(t4, "ignore");
      } else if ("root" === e3.type && "document" !== this.type) {
        e3 = e3.nodes.slice(0);
        for (let t4 of e3) t4.parent && t4.parent.removeChild(t4, "ignore");
      } else if (e3.type) e3 = [e3];
      else if (e3.prop) {
        if (void 0 === e3.value) throw new Error("Value field is missed in node creation");
        "string" != typeof e3.value && (e3.value = String(e3.value)), e3 = [new c(e3)];
      } else if (e3.selector) e3 = [new s2(e3)];
      else if (e3.name) e3 = [new i2(e3)];
      else {
        if (!e3.text) throw new Error("Unknown node type in node creation");
        e3 = [new u(e3)];
      }
      return e3.map((e4) => (e4[l] || h.rebuild(e4), (e4 = e4.proxyOf).parent && e4.parent.removeChild(e4), e4[a2] && f(e4), void 0 === e4.raws.before && t3 && void 0 !== t3.raws.before && (e4.raws.before = t3.raws.before.replace(/\S/g, "")), e4.parent = this.proxyOf, e4));
    }
    prepend() {
      for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
      t3 = t3.reverse();
      for (let e4 of t3) {
        let t4 = this.normalize(e4, this.first, "prepend").reverse();
        for (let e5 of t4) this.proxyOf.nodes.unshift(e5);
        for (let e5 in this.indexes) this.indexes[e5] = this.indexes[e5] + t4.length;
      }
      return this.markDirty(), this;
    }
    push(e3) {
      return e3.parent = this, this.proxyOf.nodes.push(e3), this;
    }
    removeAll() {
      for (let e3 of this.proxyOf.nodes) e3.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(e3) {
      let t3;
      e3 = this.index(e3), this.proxyOf.nodes[e3].parent = void 0, this.proxyOf.nodes.splice(e3, 1);
      for (let r3 in this.indexes) t3 = this.indexes[r3], t3 >= e3 && (this.indexes[r3] = t3 - 1);
      return this.markDirty(), this;
    }
    replaceValues(e3, t3, r3) {
      return r3 || (r3 = t3, t3 = {}), this.walkDecls((n3) => {
        t3.props && !t3.props.includes(n3.prop) || t3.fast && !n3.value.includes(t3.fast) || (n3.value = n3.value.replace(e3, r3));
      }), this.markDirty(), this;
    }
    some(e3) {
      return this.nodes.some(e3);
    }
    walk(e3) {
      return this.each((t3, r3) => {
        let n3;
        try {
          n3 = e3(t3, r3);
        } catch (e4) {
          throw t3.addToError(e4);
        }
        return false !== n3 && t3.walk && (n3 = t3.walk(e3)), n3;
      });
    }
    walkAtRules(e3, t3) {
      return t3 ? e3 instanceof RegExp ? this.walk((r3, n3) => {
        if ("atrule" === r3.type && e3.test(r3.name)) return t3(r3, n3);
      }) : this.walk((r3, n3) => {
        if ("atrule" === r3.type && r3.name === e3) return t3(r3, n3);
      }) : (t3 = e3, this.walk((e4, r3) => {
        if ("atrule" === e4.type) return t3(e4, r3);
      }));
    }
    walkComments(e3) {
      return this.walk((t3, r3) => {
        if ("comment" === t3.type) return e3(t3, r3);
      });
    }
    walkDecls(e3, t3) {
      return t3 ? e3 instanceof RegExp ? this.walk((r3, n3) => {
        if ("decl" === r3.type && e3.test(r3.prop)) return t3(r3, n3);
      }) : this.walk((r3, n3) => {
        if ("decl" === r3.type && r3.prop === e3) return t3(r3, n3);
      }) : (t3 = e3, this.walk((e4, r3) => {
        if ("decl" === e4.type) return t3(e4, r3);
      }));
    }
    walkRules(e3, t3) {
      return t3 ? e3 instanceof RegExp ? this.walk((r3, n3) => {
        if ("rule" === r3.type && e3.test(r3.selector)) return t3(r3, n3);
      }) : this.walk((r3, n3) => {
        if ("rule" === r3.type && r3.selector === e3) return t3(r3, n3);
      }) : (t3 = e3, this.walk((e4, r3) => {
        if ("rule" === e4.type) return t3(e4, r3);
      }));
    }
    get first() {
      if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
  }
  h.registerParse = (e3) => {
    n2 = e3;
  }, h.registerRule = (e3) => {
    s2 = e3;
  }, h.registerAtRule = (e3) => {
    i2 = e3;
  }, h.registerRoot = (e3) => {
    o2 = e3;
  }, e2.exports = h, h.default = h, h.rebuild = (e3) => {
    "atrule" === e3.type ? Object.setPrototypeOf(e3, i2.prototype) : "rule" === e3.type ? Object.setPrototypeOf(e3, s2.prototype) : "decl" === e3.type ? Object.setPrototypeOf(e3, c.prototype) : "comment" === e3.type ? Object.setPrototypeOf(e3, u.prototype) : "root" === e3.type && Object.setPrototypeOf(e3, o2.prototype), e3[l] = true, e3.nodes && e3.nodes.forEach((e4) => {
      h.rebuild(e4);
    });
  };
}, (e2, t2, r2) => {
  var n2 = r2(17);
  function s2(e3) {
    return s2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
      return typeof e4;
    } : function(e4) {
      return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
    }, s2(e3);
  }
  function i2(e3, t3) {
    for (var r3 = 0; r3 < t3.length; r3++) {
      var n3 = t3[r3];
      n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, (void 0, i3 = function(e4, t4) {
        if ("object" !== s2(e4) || null === e4) return e4;
        var r4 = e4[Symbol.toPrimitive];
        if (void 0 !== r4) {
          var n4 = r4.call(e4, "string");
          if ("object" !== s2(n4)) return n4;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return String(e4);
      }(n3.key), "symbol" === s2(i3) ? i3 : String(i3)), n3);
    }
    var i3;
  }
  function o2(e3, t3, r3) {
    return t3 && i2(e3.prototype, t3), r3 && i2(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
  }
  var a2, l, c = r2(227).codes, u = c.ERR_AMBIGUOUS_ARGUMENT, p = c.ERR_INVALID_ARG_TYPE, d = c.ERR_INVALID_ARG_VALUE, f = c.ERR_INVALID_RETURN_VALUE, h = c.ERR_MISSING_ARGS, m = r2(241), y = r2(32).inspect, g = r2(32).types, b = g.isPromise, v = g.isRegExp, E = r2(242)(), S = r2(74)(), x = r2(38)("RegExp.prototype.test");
  function T() {
    var e3 = r2(245);
    a2 = e3.isDeepEqual, l = e3.isDeepStrictEqual;
  }
  /* @__PURE__ */ new Map();
  var w = false, P = e2.exports = I, A = {};
  function C(e3) {
    if (e3.message instanceof Error) throw e3.message;
    throw new m(e3);
  }
  function O(e3, t3, r3, n3) {
    if (!r3) {
      var s3 = false;
      if (0 === t3) s3 = true, n3 = "No value argument passed to `assert.ok()`";
      else if (n3 instanceof Error) throw n3;
      var i3 = new m({ actual: r3, expected: true, message: n3, operator: "==", stackStartFn: e3 });
      throw i3.generatedMessage = s3, i3;
    }
  }
  function I() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    O.apply(void 0, [I, t3.length].concat(t3));
  }
  P.fail = function e3(t3, r3, s3, i3, o3) {
    var a3, l2 = arguments.length;
    if (0 === l2 ? a3 = "Failed" : 1 === l2 ? (s3 = t3, t3 = void 0) : (false === w && (w = true, (n2.emitWarning ? n2.emitWarning : void 0)("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094")), 2 === l2 && (i3 = "!=")), s3 instanceof Error) throw s3;
    var c2 = { actual: t3, expected: r3, operator: void 0 === i3 ? "fail" : i3, stackStartFn: o3 || e3 };
    void 0 !== s3 && (c2.message = s3);
    var u2 = new m(c2);
    throw a3 && (u2.message = a3, u2.generatedMessage = true), u2;
  }, P.AssertionError = m, P.ok = I, P.equal = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    t3 != r3 && C({ actual: t3, expected: r3, message: n3, operator: "==", stackStartFn: e3 });
  }, P.notEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    t3 == r3 && C({ actual: t3, expected: r3, message: n3, operator: "!=", stackStartFn: e3 });
  }, P.deepEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    void 0 === a2 && T(), a2(t3, r3) || C({ actual: t3, expected: r3, message: n3, operator: "deepEqual", stackStartFn: e3 });
  }, P.notDeepEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    void 0 === a2 && T(), a2(t3, r3) && C({ actual: t3, expected: r3, message: n3, operator: "notDeepEqual", stackStartFn: e3 });
  }, P.deepStrictEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    void 0 === a2 && T(), l(t3, r3) || C({ actual: t3, expected: r3, message: n3, operator: "deepStrictEqual", stackStartFn: e3 });
  }, P.notDeepStrictEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    void 0 === a2 && T(), l(t3, r3) && C({ actual: t3, expected: r3, message: n3, operator: "notDeepStrictEqual", stackStartFn: e3 });
  }, P.strictEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    S(t3, r3) || C({ actual: t3, expected: r3, message: n3, operator: "strictEqual", stackStartFn: e3 });
  }, P.notStrictEqual = function e3(t3, r3, n3) {
    if (arguments.length < 2) throw new h("actual", "expected");
    S(t3, r3) && C({ actual: t3, expected: r3, message: n3, operator: "notStrictEqual", stackStartFn: e3 });
  };
  var _ = o2(function e3(t3, r3, n3) {
    var s3 = this;
    !function(e4, t4) {
      if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
    }(this, e3), r3.forEach(function(e4) {
      e4 in t3 && (void 0 !== n3 && "string" == typeof n3[e4] && v(t3[e4]) && x(t3[e4], n3[e4]) ? s3[e4] = n3[e4] : s3[e4] = t3[e4]);
    });
  });
  function k(e3, t3, r3, n3) {
    if ("function" != typeof t3) {
      if (v(t3)) return x(t3, e3);
      if (2 === arguments.length) throw new p("expected", ["Function", "RegExp"], t3);
      if ("object" !== s2(e3) || null === e3) {
        var i3 = new m({ actual: e3, expected: t3, message: r3, operator: "deepStrictEqual", stackStartFn: n3 });
        throw i3.operator = n3.name, i3;
      }
      var o3 = Object.keys(t3);
      if (t3 instanceof Error) o3.push("name", "message");
      else if (0 === o3.length) throw new d("error", t3, "may not be an empty object");
      return void 0 === a2 && T(), o3.forEach(function(s3) {
        "string" == typeof e3[s3] && v(t3[s3]) && x(t3[s3], e3[s3]) || function(e4, t4, r4, n4, s4, i4) {
          if (!(r4 in e4) || !l(e4[r4], t4[r4])) {
            if (!n4) {
              var o4 = new _(e4, s4), a3 = new _(t4, s4, e4), c2 = new m({ actual: o4, expected: a3, operator: "deepStrictEqual", stackStartFn: i4 });
              throw c2.actual = e4, c2.expected = t4, c2.operator = i4.name, c2;
            }
            C({ actual: e4, expected: t4, message: n4, operator: i4.name, stackStartFn: i4 });
          }
        }(e3, t3, s3, r3, o3, n3);
      }), true;
    }
    return void 0 !== t3.prototype && e3 instanceof t3 || !Error.isPrototypeOf(t3) && true === t3.call({}, e3);
  }
  function N(e3) {
    if ("function" != typeof e3) throw new p("fn", "Function", e3);
    try {
      e3();
    } catch (e4) {
      return e4;
    }
    return A;
  }
  function D(e3) {
    return b(e3) || null !== e3 && "object" === s2(e3) && "function" == typeof e3.then && "function" == typeof e3.catch;
  }
  function j(e3) {
    return Promise.resolve().then(function() {
      var t3;
      if ("function" == typeof e3) {
        if (!D(t3 = e3())) throw new f("instance of Promise", "promiseFn", t3);
      } else {
        if (!D(e3)) throw new p("promiseFn", ["Function", "Promise"], e3);
        t3 = e3;
      }
      return Promise.resolve().then(function() {
        return t3;
      }).then(function() {
        return A;
      }).catch(function(e4) {
        return e4;
      });
    });
  }
  function L(e3, t3, r3, n3) {
    if ("string" == typeof r3) {
      if (4 === arguments.length) throw new p("error", ["Object", "Error", "Function", "RegExp"], r3);
      if ("object" === s2(t3) && null !== t3) {
        if (t3.message === r3) throw new u("error/message", 'The error message "'.concat(t3.message, '" is identical to the message.'));
      } else if (t3 === r3) throw new u("error/message", 'The error "'.concat(t3, '" is identical to the message.'));
      n3 = r3, r3 = void 0;
    } else if (null != r3 && "object" !== s2(r3) && "function" != typeof r3) throw new p("error", ["Object", "Error", "Function", "RegExp"], r3);
    if (t3 === A) {
      var i3 = "";
      r3 && r3.name && (i3 += " (".concat(r3.name, ")")), i3 += n3 ? ": ".concat(n3) : ".";
      var o3 = "rejects" === e3.name ? "rejection" : "exception";
      C({ actual: void 0, expected: r3, operator: e3.name, message: "Missing expected ".concat(o3).concat(i3), stackStartFn: e3 });
    }
    if (r3 && !k(t3, r3, n3, e3)) throw t3;
  }
  function M(e3, t3, r3, n3) {
    if (t3 !== A) {
      if ("string" == typeof r3 && (n3 = r3, r3 = void 0), !r3 || k(t3, r3)) {
        var s3 = n3 ? ": ".concat(n3) : ".", i3 = "doesNotReject" === e3.name ? "rejection" : "exception";
        C({ actual: t3, expected: r3, operator: e3.name, message: "Got unwanted ".concat(i3).concat(s3, "\n") + 'Actual message: "'.concat(t3 && t3.message, '"'), stackStartFn: e3 });
      }
      throw t3;
    }
  }
  function B(e3, t3, r3, n3, i3) {
    if (!v(t3)) throw new p("regexp", "RegExp", t3);
    var o3 = "match" === i3;
    if ("string" != typeof e3 || x(t3, e3) !== o3) {
      if (r3 instanceof Error) throw r3;
      var a3 = !r3;
      r3 = r3 || ("string" != typeof e3 ? 'The "string" argument must be of type string. Received type ' + "".concat(s2(e3), " (").concat(y(e3), ")") : (o3 ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(y(t3), ". Input:\n\n").concat(y(e3), "\n"));
      var l2 = new m({ actual: e3, expected: t3, message: r3, operator: i3, stackStartFn: n3 });
      throw l2.generatedMessage = a3, l2;
    }
  }
  function R() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    O.apply(void 0, [R, t3.length].concat(t3));
  }
  P.throws = function e3(t3) {
    for (var r3 = arguments.length, n3 = new Array(r3 > 1 ? r3 - 1 : 0), s3 = 1; s3 < r3; s3++) n3[s3 - 1] = arguments[s3];
    L.apply(void 0, [e3, N(t3)].concat(n3));
  }, P.rejects = function e3(t3) {
    for (var r3 = arguments.length, n3 = new Array(r3 > 1 ? r3 - 1 : 0), s3 = 1; s3 < r3; s3++) n3[s3 - 1] = arguments[s3];
    return j(t3).then(function(t4) {
      return L.apply(void 0, [e3, t4].concat(n3));
    });
  }, P.doesNotThrow = function e3(t3) {
    for (var r3 = arguments.length, n3 = new Array(r3 > 1 ? r3 - 1 : 0), s3 = 1; s3 < r3; s3++) n3[s3 - 1] = arguments[s3];
    M.apply(void 0, [e3, N(t3)].concat(n3));
  }, P.doesNotReject = function e3(t3) {
    for (var r3 = arguments.length, n3 = new Array(r3 > 1 ? r3 - 1 : 0), s3 = 1; s3 < r3; s3++) n3[s3 - 1] = arguments[s3];
    return j(t3).then(function(t4) {
      return M.apply(void 0, [e3, t4].concat(n3));
    });
  }, P.ifError = function e3(t3) {
    if (null != t3) {
      var r3 = "ifError got unwanted exception: ";
      "object" === s2(t3) && "string" == typeof t3.message ? 0 === t3.message.length && t3.constructor ? r3 += t3.constructor.name : r3 += t3.message : r3 += y(t3);
      var n3 = new m({ actual: t3, expected: null, operator: "ifError", message: r3, stackStartFn: e3 }), i3 = t3.stack;
      if ("string" == typeof i3) {
        var o3 = i3.split("\n");
        o3.shift();
        for (var a3 = n3.stack.split("\n"), l2 = 0; l2 < o3.length; l2++) {
          var c2 = a3.indexOf(o3[l2]);
          if (-1 !== c2) {
            a3 = a3.slice(0, c2);
            break;
          }
        }
        n3.stack = "".concat(a3.join("\n"), "\n").concat(o3.join("\n"));
      }
      throw n3;
    }
  }, P.match = function e3(t3, r3, n3) {
    B(t3, r3, n3, e3, "match");
  }, P.doesNotMatch = function e3(t3, r3, n3) {
    B(t3, r3, n3, e3, "doesNotMatch");
  }, P.strict = E(R, P, { equal: P.strictEqual, deepEqual: P.deepStrictEqual, notEqual: P.notStrictEqual, notDeepEqual: P.notDeepStrictEqual }), P.strict.strict = P.strict;
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.UPDATE_OPERATORS = t2.UNARY_OPERATORS = t2.STRING_UNARY_OPERATORS = t2.STATEMENT_OR_BLOCK_KEYS = t2.NUMBER_UNARY_OPERATORS = t2.NUMBER_BINARY_OPERATORS = t2.NOT_LOCAL_BINDING = t2.LOGICAL_OPERATORS = t2.INHERIT_KEYS = t2.FOR_INIT_KEYS = t2.FLATTENABLE_KEYS = t2.EQUALITY_BINARY_OPERATORS = t2.COMPARISON_BINARY_OPERATORS = t2.COMMENT_KEYS = t2.BOOLEAN_UNARY_OPERATORS = t2.BOOLEAN_NUMBER_BINARY_OPERATORS = t2.BOOLEAN_BINARY_OPERATORS = t2.BLOCK_SCOPED_SYMBOL = t2.BINARY_OPERATORS = t2.ASSIGNMENT_OPERATORS = void 0, t2.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], t2.FLATTENABLE_KEYS = ["body", "expressions"], t2.FOR_INIT_KEYS = ["left", "init"], t2.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  const r2 = t2.LOGICAL_OPERATORS = ["||", "&&", "??"], n2 = (t2.UPDATE_OPERATORS = ["++", "--"], t2.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="]), s2 = t2.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], i2 = t2.COMPARISON_BINARY_OPERATORS = [...s2, "in", "instanceof"], o2 = t2.BOOLEAN_BINARY_OPERATORS = [...i2, ...n2], a2 = t2.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], l = (t2.BINARY_OPERATORS = ["+", ...a2, ...o2, "|>"], t2.ASSIGNMENT_OPERATORS = ["=", "+=", ...a2.map((e3) => e3 + "="), ...r2.map((e3) => e3 + "=")], t2.BOOLEAN_UNARY_OPERATORS = ["delete", "!"]), c = t2.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], u = t2.STRING_UNARY_OPERATORS = ["typeof"];
  t2.UNARY_OPERATORS = ["void", "throw", ...l, ...c, ...u], t2.INHERIT_KEYS = { optional: ["typeAnnotation", "typeParameters", "returnType"], force: ["start", "loc", "end"] }, t2.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), t2.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return l(e3, !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2], /* @__PURE__ */ new Map());
  };
  var n2 = r2(9), s2 = r2(2);
  const i2 = Function.call.bind(Object.prototype.hasOwnProperty);
  function o2(e3, t3, r3, n3) {
    return e3 && "string" == typeof e3.type ? l(e3, t3, r3, n3) : e3;
  }
  function a2(e3, t3, r3, n3) {
    return Array.isArray(e3) ? e3.map((e4) => o2(e4, t3, r3, n3)) : o2(e3, t3, r3, n3);
  }
  function l(e3) {
    let t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], o3 = arguments.length > 3 ? arguments[3] : void 0;
    if (!e3) return e3;
    const { type: l2 } = e3, u = { type: e3.type };
    if ((0, s2.isIdentifier)(e3)) u.name = e3.name, i2(e3, "optional") && "boolean" == typeof e3.optional && (u.optional = e3.optional), i2(e3, "typeAnnotation") && (u.typeAnnotation = t3 ? a2(e3.typeAnnotation, true, r3, o3) : e3.typeAnnotation);
    else {
      if (!i2(n2.NODE_FIELDS, l2)) throw new Error(`Unknown node type: "${l2}"`);
      for (const p of Object.keys(n2.NODE_FIELDS[l2])) i2(e3, p) && (u[p] = t3 ? (0, s2.isFile)(e3) && "comments" === p ? c(e3.comments, t3, r3, o3) : a2(e3[p], true, r3, o3) : e3[p]);
    }
    return i2(e3, "loc") && (u.loc = r3 ? null : e3.loc), i2(e3, "leadingComments") && (u.leadingComments = c(e3.leadingComments, t3, r3, o3)), i2(e3, "innerComments") && (u.innerComments = c(e3.innerComments, t3, r3, o3)), i2(e3, "trailingComments") && (u.trailingComments = c(e3.trailingComments, t3, r3, o3)), i2(e3, "extra") && (u.extra = Object.assign({}, e3.extra)), u;
  }
  function c(e3, t3, r3, n3) {
    return e3 && t3 ? e3.map((e4) => {
      const t4 = n3.get(e4);
      if (t4) return t4;
      const { type: s3, value: i3, loc: o3 } = e4, a3 = { type: s3, value: i3, loc: o3 };
      return r3 && (a3.loc = null), n3.set(e4, a3), a3;
    }) : e3;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = t2.SHOULD_STOP = t2.SHOULD_SKIP = t2.REMOVED = void 0;
  var n2 = r2(162), s2 = r2(61), i2 = r2(14), o2 = r2(183), a2 = r2(0), l = a2, c = r2(35), u = r2(101), p = r2(423), d = r2(424), f = r2(427), h = r2(430), m = r2(431), y = r2(436), g = r2(437), b = r2(438), v = r2(440), E = r2(442), S = r2(443), x = r2(163);
  const { validate: T } = a2, w = s2("babel"), P = t2.REMOVED = 1, A = t2.SHOULD_STOP = 2, C = t2.SHOULD_SKIP = 4;
  class O {
    constructor(e3, t3) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = t3, this.hub = e3, this.data = null, this.context = null, this.scope = null;
    }
    static get(e3) {
      let { hub: t3, parentPath: r3, parent: n3, container: s3, listKey: i3, key: o3 } = e3;
      if (!t3 && r3 && (t3 = r3.hub), !n3) throw new Error("To get a node path the parent needs to exist");
      const a3 = s3[o3], l2 = c.getOrCreateCachedPaths(t3, n3);
      let u2 = l2.get(a3);
      return u2 || (u2 = new O(t3, n3), a3 && l2.set(a3, u2)), u2.setup(r3, s3, i3, o3), u2;
    }
    getScope(e3) {
      return this.isScope() ? new o2.default(this) : e3;
    }
    setData(e3, t3) {
      return null == this.data && (this.data = /* @__PURE__ */ Object.create(null)), this.data[e3] = t3;
    }
    getData(e3, t3) {
      null == this.data && (this.data = /* @__PURE__ */ Object.create(null));
      let r3 = this.data[e3];
      return void 0 === r3 && void 0 !== t3 && (r3 = this.data[e3] = t3), r3;
    }
    hasNode() {
      return null != this.node;
    }
    buildCodeFrameError(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : SyntaxError;
      return this.hub.buildError(this.node, e3, t3);
    }
    traverse(e3, t3) {
      (0, i2.default)(this.node, e3, this.scope, t3, this);
    }
    set(e3, t3) {
      T(this.node, e3, t3), this.node[e3] = t3;
    }
    getPathLocation() {
      const e3 = [];
      let t3 = this;
      do {
        let r3 = t3.key;
        t3.inList && (r3 = `${t3.listKey}[${r3}]`), e3.unshift(r3);
      } while (t3 = t3.parentPath);
      return e3.join(".");
    }
    debug(e3) {
      w.enabled && w(`${this.getPathLocation()} ${this.type}: ${e3}`);
    }
    toString() {
      return (0, u.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(e3) {
      e3 || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
    get shouldSkip() {
      return !!(this._traverseFlags & C);
    }
    set shouldSkip(e3) {
      e3 ? this._traverseFlags |= C : this._traverseFlags &= ~C;
    }
    get shouldStop() {
      return !!(this._traverseFlags & A);
    }
    set shouldStop(e3) {
      e3 ? this._traverseFlags |= A : this._traverseFlags &= ~A;
    }
    get removed() {
      return !!(this._traverseFlags & P);
    }
    set removed(e3) {
      e3 ? this._traverseFlags |= P : this._traverseFlags &= ~P;
    }
  }
  Object.assign(O.prototype, p, d, f, h, m, y, g, b, v, E, S), O.prototype._guessExecutionStatusRelativeToDifferentFunctions = y._guessExecutionStatusRelativeTo;
  for (const e3 of l.TYPES) {
    const t3 = `is${e3}`, r3 = l[t3];
    O.prototype[t3] = function(e4) {
      return r3(this.node, e4);
    }, O.prototype[`assert${e3}`] = function(t4) {
      if (!r3(this.node, t4)) throw new TypeError(`Expected node path of type ${e3}`);
    };
  }
  Object.assign(O.prototype, x);
  for (const e3 of Object.keys(n2)) "_" !== e3[0] && (l.TYPES.includes(e3) || l.TYPES.push(e3));
  t2.default = O;
}, (e2, t2, r2) => {
  var n2 = r2(19), s2 = r2(63), i2 = n2({}.hasOwnProperty);
  e2.exports = Object.hasOwn || function(e3, t3) {
    return i2(s2(e3), t3);
  };
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (e3 instanceof n2) return e3;
    try {
      return new n2(e3, t3);
    } catch (e4) {
      if (!r3) return null;
      throw e4;
    }
  };
}, (e2, t2, r2) => {
  r2(12);
  const n2 = r2(417), s2 = r2(418), i2 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
  t2.a = l, t2.b = 50;
  const o2 = 2147483647;
  function a2(e3) {
    if (e3 > o2) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
    const t3 = new Uint8Array(e3);
    return Object.setPrototypeOf(t3, l.prototype), t3;
  }
  function l(e3, t3, r3) {
    if ("number" == typeof e3) {
      if ("string" == typeof t3) throw new TypeError('The "string" argument must be of type string. Received type number');
      return p(e3);
    }
    return c(e3, t3, r3);
  }
  function c(e3, t3, r3) {
    if ("string" == typeof e3) return function(e4, t4) {
      if ("string" == typeof t4 && "" !== t4 || (t4 = "utf8"), !l.isEncoding(t4)) throw new TypeError("Unknown encoding: " + t4);
      const r4 = 0 | m(e4, t4);
      let n4 = a2(r4);
      const s4 = n4.write(e4, t4);
      return s4 !== r4 && (n4 = n4.slice(0, s4)), n4;
    }(e3, t3);
    if (ArrayBuffer.isView(e3)) return function(e4) {
      if (X(e4, Uint8Array)) {
        const t4 = new Uint8Array(e4);
        return f(t4.buffer, t4.byteOffset, t4.byteLength);
      }
      return d(e4);
    }(e3);
    if (null == e3) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
    if (X(e3, ArrayBuffer) || e3 && X(e3.buffer, ArrayBuffer)) return f(e3, t3, r3);
    if ("undefined" != typeof SharedArrayBuffer && (X(e3, SharedArrayBuffer) || e3 && X(e3.buffer, SharedArrayBuffer))) return f(e3, t3, r3);
    if ("number" == typeof e3) throw new TypeError('The "value" argument must not be of type number. Received type number');
    const n3 = e3.valueOf && e3.valueOf();
    if (null != n3 && n3 !== e3) return l.from(n3, t3, r3);
    const s3 = function(e4) {
      if (l.isBuffer(e4)) {
        const t4 = 0 | h(e4.length), r4 = a2(t4);
        return 0 === r4.length || e4.copy(r4, 0, 0, t4), r4;
      }
      return void 0 !== e4.length ? "number" != typeof e4.length || J(e4.length) ? a2(0) : d(e4) : "Buffer" === e4.type && Array.isArray(e4.data) ? d(e4.data) : void 0;
    }(e3);
    if (s3) return s3;
    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e3[Symbol.toPrimitive]) return l.from(e3[Symbol.toPrimitive]("string"), t3, r3);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
  }
  function u(e3) {
    if ("number" != typeof e3) throw new TypeError('"size" argument must be of type number');
    if (e3 < 0) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
  }
  function p(e3) {
    return u(e3), a2(e3 < 0 ? 0 : 0 | h(e3));
  }
  function d(e3) {
    const t3 = e3.length < 0 ? 0 : 0 | h(e3.length), r3 = a2(t3);
    for (let n3 = 0; n3 < t3; n3 += 1) r3[n3] = 255 & e3[n3];
    return r3;
  }
  function f(e3, t3, r3) {
    if (t3 < 0 || e3.byteLength < t3) throw new RangeError('"offset" is outside of buffer bounds');
    if (e3.byteLength < t3 + (r3 || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let n3;
    return n3 = void 0 === t3 && void 0 === r3 ? new Uint8Array(e3) : void 0 === r3 ? new Uint8Array(e3, t3) : new Uint8Array(e3, t3, r3), Object.setPrototypeOf(n3, l.prototype), n3;
  }
  function h(e3) {
    if (e3 >= o2) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o2.toString(16) + " bytes");
    return 0 | e3;
  }
  function m(e3, t3) {
    if (l.isBuffer(e3)) return e3.length;
    if (ArrayBuffer.isView(e3) || X(e3, ArrayBuffer)) return e3.byteLength;
    if ("string" != typeof e3) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e3);
    const r3 = e3.length, n3 = arguments.length > 2 && true === arguments[2];
    if (!n3 && 0 === r3) return 0;
    let s3 = false;
    for (; ; ) switch (t3) {
      case "ascii":
      case "latin1":
      case "binary":
        return r3;
      case "utf8":
      case "utf-8":
        return H(e3).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * r3;
      case "hex":
        return r3 >>> 1;
      case "base64":
        return z(e3).length;
      default:
        if (s3) return n3 ? -1 : H(e3).length;
        t3 = ("" + t3).toLowerCase(), s3 = true;
    }
  }
  function y(e3, t3, r3) {
    let n3 = false;
    if ((void 0 === t3 || t3 < 0) && (t3 = 0), t3 > this.length) return "";
    if ((void 0 === r3 || r3 > this.length) && (r3 = this.length), r3 <= 0) return "";
    if ((r3 >>>= 0) <= (t3 >>>= 0)) return "";
    for (e3 || (e3 = "utf8"); ; ) switch (e3) {
      case "hex":
        return _(this, t3, r3);
      case "utf8":
      case "utf-8":
        return A(this, t3, r3);
      case "ascii":
        return O(this, t3, r3);
      case "latin1":
      case "binary":
        return I(this, t3, r3);
      case "base64":
        return P(this, t3, r3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return k(this, t3, r3);
      default:
        if (n3) throw new TypeError("Unknown encoding: " + e3);
        e3 = (e3 + "").toLowerCase(), n3 = true;
    }
  }
  function g(e3, t3, r3) {
    const n3 = e3[t3];
    e3[t3] = e3[r3], e3[r3] = n3;
  }
  function b(e3, t3, r3, n3, s3) {
    if (0 === e3.length) return -1;
    if ("string" == typeof r3 ? (n3 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), J(r3 = +r3) && (r3 = s3 ? 0 : e3.length - 1), r3 < 0 && (r3 = e3.length + r3), r3 >= e3.length) {
      if (s3) return -1;
      r3 = e3.length - 1;
    } else if (r3 < 0) {
      if (!s3) return -1;
      r3 = 0;
    }
    if ("string" == typeof t3 && (t3 = l.from(t3, n3)), l.isBuffer(t3)) return 0 === t3.length ? -1 : v(e3, t3, r3, n3, s3);
    if ("number" == typeof t3) return t3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? s3 ? Uint8Array.prototype.indexOf.call(e3, t3, r3) : Uint8Array.prototype.lastIndexOf.call(e3, t3, r3) : v(e3, [t3], r3, n3, s3);
    throw new TypeError("val must be string, number or Buffer");
  }
  function v(e3, t3, r3, n3, s3) {
    let i3, o3 = 1, a3 = e3.length, l2 = t3.length;
    if (void 0 !== n3 && ("ucs2" === (n3 = String(n3).toLowerCase()) || "ucs-2" === n3 || "utf16le" === n3 || "utf-16le" === n3)) {
      if (e3.length < 2 || t3.length < 2) return -1;
      o3 = 2, a3 /= 2, l2 /= 2, r3 /= 2;
    }
    function c2(e4, t4) {
      return 1 === o3 ? e4[t4] : e4.readUInt16BE(t4 * o3);
    }
    if (s3) {
      let n4 = -1;
      for (i3 = r3; i3 < a3; i3++) if (c2(e3, i3) === c2(t3, -1 === n4 ? 0 : i3 - n4)) {
        if (-1 === n4 && (n4 = i3), i3 - n4 + 1 === l2) return n4 * o3;
      } else -1 !== n4 && (i3 -= i3 - n4), n4 = -1;
    } else for (r3 + l2 > a3 && (r3 = a3 - l2), i3 = r3; i3 >= 0; i3--) {
      let r4 = true;
      for (let n4 = 0; n4 < l2; n4++) if (c2(e3, i3 + n4) !== c2(t3, n4)) {
        r4 = false;
        break;
      }
      if (r4) return i3;
    }
    return -1;
  }
  function E(e3, t3, r3, n3) {
    r3 = Number(r3) || 0;
    const s3 = e3.length - r3;
    n3 ? (n3 = Number(n3)) > s3 && (n3 = s3) : n3 = s3;
    const i3 = t3.length;
    let o3;
    for (n3 > i3 / 2 && (n3 = i3 / 2), o3 = 0; o3 < n3; ++o3) {
      const n4 = parseInt(t3.substr(2 * o3, 2), 16);
      if (J(n4)) return o3;
      e3[r3 + o3] = n4;
    }
    return o3;
  }
  function S(e3, t3, r3, n3) {
    return K(H(t3, e3.length - r3), e3, r3, n3);
  }
  function x(e3, t3, r3, n3) {
    return K(function(e4) {
      const t4 = [];
      for (let r4 = 0; r4 < e4.length; ++r4) t4.push(255 & e4.charCodeAt(r4));
      return t4;
    }(t3), e3, r3, n3);
  }
  function T(e3, t3, r3, n3) {
    return K(z(t3), e3, r3, n3);
  }
  function w(e3, t3, r3, n3) {
    return K(function(e4, t4) {
      let r4, n4, s3;
      const i3 = [];
      for (let o3 = 0; o3 < e4.length && !((t4 -= 2) < 0); ++o3) r4 = e4.charCodeAt(o3), n4 = r4 >> 8, s3 = r4 % 256, i3.push(s3), i3.push(n4);
      return i3;
    }(t3, e3.length - r3), e3, r3, n3);
  }
  function P(e3, t3, r3) {
    return 0 === t3 && r3 === e3.length ? n2.fromByteArray(e3) : n2.fromByteArray(e3.slice(t3, r3));
  }
  function A(e3, t3, r3) {
    r3 = Math.min(e3.length, r3);
    const n3 = [];
    let s3 = t3;
    for (; s3 < r3; ) {
      const t4 = e3[s3];
      let i3 = null, o3 = t4 > 239 ? 4 : t4 > 223 ? 3 : t4 > 191 ? 2 : 1;
      if (s3 + o3 <= r3) {
        let r4, n4, a3, l2;
        switch (o3) {
          case 1:
            t4 < 128 && (i3 = t4);
            break;
          case 2:
            r4 = e3[s3 + 1], 128 == (192 & r4) && (l2 = (31 & t4) << 6 | 63 & r4, l2 > 127 && (i3 = l2));
            break;
          case 3:
            r4 = e3[s3 + 1], n4 = e3[s3 + 2], 128 == (192 & r4) && 128 == (192 & n4) && (l2 = (15 & t4) << 12 | (63 & r4) << 6 | 63 & n4, l2 > 2047 && (l2 < 55296 || l2 > 57343) && (i3 = l2));
            break;
          case 4:
            r4 = e3[s3 + 1], n4 = e3[s3 + 2], a3 = e3[s3 + 3], 128 == (192 & r4) && 128 == (192 & n4) && 128 == (192 & a3) && (l2 = (15 & t4) << 18 | (63 & r4) << 12 | (63 & n4) << 6 | 63 & a3, l2 > 65535 && l2 < 1114112 && (i3 = l2));
        }
      }
      null === i3 ? (i3 = 65533, o3 = 1) : i3 > 65535 && (i3 -= 65536, n3.push(i3 >>> 10 & 1023 | 55296), i3 = 56320 | 1023 & i3), n3.push(i3), s3 += o3;
    }
    return function(e4) {
      const t4 = e4.length;
      if (t4 <= C) return String.fromCharCode.apply(String, e4);
      let r4 = "", n4 = 0;
      for (; n4 < t4; ) r4 += String.fromCharCode.apply(String, e4.slice(n4, n4 += C));
      return r4;
    }(n3);
  }
  l.TYPED_ARRAY_SUPPORT = function() {
    try {
      const e3 = new Uint8Array(1), t3 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(t3, Uint8Array.prototype), Object.setPrototypeOf(e3, t3), 42 === e3.foo();
    } catch (e3) {
      return false;
    }
  }(), !l.TYPED_ARRAY_SUPPORT && "undefined" != typeof console && console.error, Object.defineProperty(l.prototype, "parent", { enumerable: true, get: function() {
    if (l.isBuffer(this)) return this.buffer;
  } }), Object.defineProperty(l.prototype, "offset", { enumerable: true, get: function() {
    if (l.isBuffer(this)) return this.byteOffset;
  } }), l.poolSize = 8192, l.from = function(e3, t3, r3) {
    return c(e3, t3, r3);
  }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array), l.alloc = function(e3, t3, r3) {
    return function(e4, t4, r4) {
      return u(e4), e4 <= 0 ? a2(e4) : void 0 !== t4 ? "string" == typeof r4 ? a2(e4).fill(t4, r4) : a2(e4).fill(t4) : a2(e4);
    }(e3, t3, r3);
  }, l.allocUnsafe = function(e3) {
    return p(e3);
  }, l.allocUnsafeSlow = function(e3) {
    return p(e3);
  }, l.isBuffer = function(e3) {
    return null != e3 && true === e3._isBuffer && e3 !== l.prototype;
  }, l.compare = function(e3, t3) {
    if (X(e3, Uint8Array) && (e3 = l.from(e3, e3.offset, e3.byteLength)), X(t3, Uint8Array) && (t3 = l.from(t3, t3.offset, t3.byteLength)), !l.isBuffer(e3) || !l.isBuffer(t3)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (e3 === t3) return 0;
    let r3 = e3.length, n3 = t3.length;
    for (let s3 = 0, i3 = Math.min(r3, n3); s3 < i3; ++s3) if (e3[s3] !== t3[s3]) {
      r3 = e3[s3], n3 = t3[s3];
      break;
    }
    return r3 < n3 ? -1 : n3 < r3 ? 1 : 0;
  }, l.isEncoding = function(e3) {
    switch (String(e3).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, l.concat = function(e3, t3) {
    if (!Array.isArray(e3)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (0 === e3.length) return l.alloc(0);
    let r3;
    if (void 0 === t3) for (t3 = 0, r3 = 0; r3 < e3.length; ++r3) t3 += e3[r3].length;
    const n3 = l.allocUnsafe(t3);
    let s3 = 0;
    for (r3 = 0; r3 < e3.length; ++r3) {
      let t4 = e3[r3];
      if (X(t4, Uint8Array)) s3 + t4.length > n3.length ? (l.isBuffer(t4) || (t4 = l.from(t4)), t4.copy(n3, s3)) : Uint8Array.prototype.set.call(n3, t4, s3);
      else {
        if (!l.isBuffer(t4)) throw new TypeError('"list" argument must be an Array of Buffers');
        t4.copy(n3, s3);
      }
      s3 += t4.length;
    }
    return n3;
  }, l.byteLength = m, l.prototype._isBuffer = true, l.prototype.swap16 = function() {
    const e3 = this.length;
    if (e3 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t3 = 0; t3 < e3; t3 += 2) g(this, t3, t3 + 1);
    return this;
  }, l.prototype.swap32 = function() {
    const e3 = this.length;
    if (e3 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t3 = 0; t3 < e3; t3 += 4) g(this, t3, t3 + 3), g(this, t3 + 1, t3 + 2);
    return this;
  }, l.prototype.swap64 = function() {
    const e3 = this.length;
    if (e3 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t3 = 0; t3 < e3; t3 += 8) g(this, t3, t3 + 7), g(this, t3 + 1, t3 + 6), g(this, t3 + 2, t3 + 5), g(this, t3 + 3, t3 + 4);
    return this;
  }, l.prototype.toString = function() {
    const e3 = this.length;
    return 0 === e3 ? "" : 0 === arguments.length ? A(this, 0, e3) : y.apply(this, arguments);
  }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(e3) {
    if (!l.isBuffer(e3)) throw new TypeError("Argument must be a Buffer");
    return this === e3 || 0 === l.compare(this, e3);
  }, l.prototype.inspect = function() {
    let e3 = "";
    const r3 = t2.b;
    return e3 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (e3 += " ... "), "<Buffer " + e3 + ">";
  }, i2 && (l.prototype[i2] = l.prototype.inspect), l.prototype.compare = function(e3, t3, r3, n3, s3) {
    if (X(e3, Uint8Array) && (e3 = l.from(e3, e3.offset, e3.byteLength)), !l.isBuffer(e3)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
    if (void 0 === t3 && (t3 = 0), void 0 === r3 && (r3 = e3 ? e3.length : 0), void 0 === n3 && (n3 = 0), void 0 === s3 && (s3 = this.length), t3 < 0 || r3 > e3.length || n3 < 0 || s3 > this.length) throw new RangeError("out of range index");
    if (n3 >= s3 && t3 >= r3) return 0;
    if (n3 >= s3) return -1;
    if (t3 >= r3) return 1;
    if (this === e3) return 0;
    let i3 = (s3 >>>= 0) - (n3 >>>= 0), o3 = (r3 >>>= 0) - (t3 >>>= 0);
    const a3 = Math.min(i3, o3), c2 = this.slice(n3, s3), u2 = e3.slice(t3, r3);
    for (let e4 = 0; e4 < a3; ++e4) if (c2[e4] !== u2[e4]) {
      i3 = c2[e4], o3 = u2[e4];
      break;
    }
    return i3 < o3 ? -1 : o3 < i3 ? 1 : 0;
  }, l.prototype.includes = function(e3, t3, r3) {
    return -1 !== this.indexOf(e3, t3, r3);
  }, l.prototype.indexOf = function(e3, t3, r3) {
    return b(this, e3, t3, r3, true);
  }, l.prototype.lastIndexOf = function(e3, t3, r3) {
    return b(this, e3, t3, r3, false);
  }, l.prototype.write = function(e3, t3, r3, n3) {
    if (void 0 === t3) n3 = "utf8", r3 = this.length, t3 = 0;
    else if (void 0 === r3 && "string" == typeof t3) n3 = t3, r3 = this.length, t3 = 0;
    else {
      if (!isFinite(t3)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      t3 >>>= 0, isFinite(r3) ? (r3 >>>= 0, void 0 === n3 && (n3 = "utf8")) : (n3 = r3, r3 = void 0);
    }
    const s3 = this.length - t3;
    if ((void 0 === r3 || r3 > s3) && (r3 = s3), e3.length > 0 && (r3 < 0 || t3 < 0) || t3 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    n3 || (n3 = "utf8");
    let i3 = false;
    for (; ; ) switch (n3) {
      case "hex":
        return E(this, e3, t3, r3);
      case "utf8":
      case "utf-8":
        return S(this, e3, t3, r3);
      case "ascii":
      case "latin1":
      case "binary":
        return x(this, e3, t3, r3);
      case "base64":
        return T(this, e3, t3, r3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return w(this, e3, t3, r3);
      default:
        if (i3) throw new TypeError("Unknown encoding: " + n3);
        n3 = ("" + n3).toLowerCase(), i3 = true;
    }
  }, l.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const C = 4096;
  function O(e3, t3, r3) {
    let n3 = "";
    r3 = Math.min(e3.length, r3);
    for (let s3 = t3; s3 < r3; ++s3) n3 += String.fromCharCode(127 & e3[s3]);
    return n3;
  }
  function I(e3, t3, r3) {
    let n3 = "";
    r3 = Math.min(e3.length, r3);
    for (let s3 = t3; s3 < r3; ++s3) n3 += String.fromCharCode(e3[s3]);
    return n3;
  }
  function _(e3, t3, r3) {
    const n3 = e3.length;
    (!t3 || t3 < 0) && (t3 = 0), (!r3 || r3 < 0 || r3 > n3) && (r3 = n3);
    let s3 = "";
    for (let n4 = t3; n4 < r3; ++n4) s3 += Y[e3[n4]];
    return s3;
  }
  function k(e3, t3, r3) {
    const n3 = e3.slice(t3, r3);
    let s3 = "";
    for (let e4 = 0; e4 < n3.length - 1; e4 += 2) s3 += String.fromCharCode(n3[e4] + 256 * n3[e4 + 1]);
    return s3;
  }
  function N(e3, t3, r3) {
    if (e3 % 1 != 0 || e3 < 0) throw new RangeError("offset is not uint");
    if (e3 + t3 > r3) throw new RangeError("Trying to access beyond buffer length");
  }
  function D(e3, t3, r3, n3, s3, i3) {
    if (!l.isBuffer(e3)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t3 > s3 || t3 < i3) throw new RangeError('"value" argument is out of bounds');
    if (r3 + n3 > e3.length) throw new RangeError("Index out of range");
  }
  function j(e3, t3, r3, n3, s3) {
    V(t3, n3, s3, e3, r3, 7);
    let i3 = Number(t3 & BigInt(4294967295));
    e3[r3++] = i3, i3 >>= 8, e3[r3++] = i3, i3 >>= 8, e3[r3++] = i3, i3 >>= 8, e3[r3++] = i3;
    let o3 = Number(t3 >> BigInt(32) & BigInt(4294967295));
    return e3[r3++] = o3, o3 >>= 8, e3[r3++] = o3, o3 >>= 8, e3[r3++] = o3, o3 >>= 8, e3[r3++] = o3, r3;
  }
  function L(e3, t3, r3, n3, s3) {
    V(t3, n3, s3, e3, r3, 7);
    let i3 = Number(t3 & BigInt(4294967295));
    e3[r3 + 7] = i3, i3 >>= 8, e3[r3 + 6] = i3, i3 >>= 8, e3[r3 + 5] = i3, i3 >>= 8, e3[r3 + 4] = i3;
    let o3 = Number(t3 >> BigInt(32) & BigInt(4294967295));
    return e3[r3 + 3] = o3, o3 >>= 8, e3[r3 + 2] = o3, o3 >>= 8, e3[r3 + 1] = o3, o3 >>= 8, e3[r3] = o3, r3 + 8;
  }
  function M(e3, t3, r3, n3, s3, i3) {
    if (r3 + n3 > e3.length) throw new RangeError("Index out of range");
    if (r3 < 0) throw new RangeError("Index out of range");
  }
  function B(e3, t3, r3, n3, i3) {
    return t3 = +t3, r3 >>>= 0, i3 || M(e3, 0, r3, 4), s2.write(e3, t3, r3, n3, 23, 4), r3 + 4;
  }
  function R(e3, t3, r3, n3, i3) {
    return t3 = +t3, r3 >>>= 0, i3 || M(e3, 0, r3, 8), s2.write(e3, t3, r3, n3, 52, 8), r3 + 8;
  }
  l.prototype.slice = function(e3, t3) {
    const r3 = this.length;
    (e3 = ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), (t3 = void 0 === t3 ? r3 : ~~t3) < 0 ? (t3 += r3) < 0 && (t3 = 0) : t3 > r3 && (t3 = r3), t3 < e3 && (t3 = e3);
    const n3 = this.subarray(e3, t3);
    return Object.setPrototypeOf(n3, l.prototype), n3;
  }, l.prototype.readUintLE = l.prototype.readUIntLE = function(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || N(e3, t3, this.length);
    let n3 = this[e3], s3 = 1, i3 = 0;
    for (; ++i3 < t3 && (s3 *= 256); ) n3 += this[e3 + i3] * s3;
    return n3;
  }, l.prototype.readUintBE = l.prototype.readUIntBE = function(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || N(e3, t3, this.length);
    let n3 = this[e3 + --t3], s3 = 1;
    for (; t3 > 0 && (s3 *= 256); ) n3 += this[e3 + --t3] * s3;
    return n3;
  }, l.prototype.readUint8 = l.prototype.readUInt8 = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 1, this.length), this[e3];
  }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
  }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
  }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
  }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
  }, l.prototype.readBigUInt64LE = Q(function(e3) {
    q(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || W(e3, this.length - 8);
    const n3 = t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24, s3 = this[++e3] + 256 * this[++e3] + 65536 * this[++e3] + r3 * 2 ** 24;
    return BigInt(n3) + (BigInt(s3) << BigInt(32));
  }), l.prototype.readBigUInt64BE = Q(function(e3) {
    q(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || W(e3, this.length - 8);
    const n3 = t3 * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + this[++e3], s3 = this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3;
    return (BigInt(n3) << BigInt(32)) + BigInt(s3);
  }), l.prototype.readIntLE = function(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || N(e3, t3, this.length);
    let n3 = this[e3], s3 = 1, i3 = 0;
    for (; ++i3 < t3 && (s3 *= 256); ) n3 += this[e3 + i3] * s3;
    return s3 *= 128, n3 >= s3 && (n3 -= Math.pow(2, 8 * t3)), n3;
  }, l.prototype.readIntBE = function(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || N(e3, t3, this.length);
    let n3 = t3, s3 = 1, i3 = this[e3 + --n3];
    for (; n3 > 0 && (s3 *= 256); ) i3 += this[e3 + --n3] * s3;
    return s3 *= 128, i3 >= s3 && (i3 -= Math.pow(2, 8 * t3)), i3;
  }, l.prototype.readInt8 = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
  }, l.prototype.readInt16LE = function(e3, t3) {
    e3 >>>= 0, t3 || N(e3, 2, this.length);
    const r3 = this[e3] | this[e3 + 1] << 8;
    return 32768 & r3 ? 4294901760 | r3 : r3;
  }, l.prototype.readInt16BE = function(e3, t3) {
    e3 >>>= 0, t3 || N(e3, 2, this.length);
    const r3 = this[e3 + 1] | this[e3] << 8;
    return 32768 & r3 ? 4294901760 | r3 : r3;
  }, l.prototype.readInt32LE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
  }, l.prototype.readInt32BE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
  }, l.prototype.readBigInt64LE = Q(function(e3) {
    q(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || W(e3, this.length - 8);
    const n3 = this[e3 + 4] + 256 * this[e3 + 5] + 65536 * this[e3 + 6] + (r3 << 24);
    return (BigInt(n3) << BigInt(32)) + BigInt(t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24);
  }), l.prototype.readBigInt64BE = Q(function(e3) {
    q(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || W(e3, this.length - 8);
    const n3 = (t3 << 24) + 65536 * this[++e3] + 256 * this[++e3] + this[++e3];
    return (BigInt(n3) << BigInt(32)) + BigInt(this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3);
  }), l.prototype.readFloatLE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 4, this.length), s2.read(this, e3, true, 23, 4);
  }, l.prototype.readFloatBE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 4, this.length), s2.read(this, e3, false, 23, 4);
  }, l.prototype.readDoubleLE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 8, this.length), s2.read(this, e3, true, 52, 8);
  }, l.prototype.readDoubleBE = function(e3, t3) {
    return e3 >>>= 0, t3 || N(e3, 8, this.length), s2.read(this, e3, false, 52, 8);
  }, l.prototype.writeUintLE = l.prototype.writeUIntLE = function(e3, t3, r3, n3) {
    e3 = +e3, t3 >>>= 0, r3 >>>= 0, n3 || D(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
    let s3 = 1, i3 = 0;
    for (this[t3] = 255 & e3; ++i3 < r3 && (s3 *= 256); ) this[t3 + i3] = e3 / s3 & 255;
    return t3 + r3;
  }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(e3, t3, r3, n3) {
    e3 = +e3, t3 >>>= 0, r3 >>>= 0, n3 || D(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
    let s3 = r3 - 1, i3 = 1;
    for (this[t3 + s3] = 255 & e3; --s3 >= 0 && (i3 *= 256); ) this[t3 + s3] = e3 / i3 & 255;
    return t3 + r3;
  }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 1, 255, 0), this[t3] = 255 & e3, t3 + 1;
  }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 2, 65535, 0), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
  }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 2, 65535, 0), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
  }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 4, 4294967295, 0), this[t3 + 3] = e3 >>> 24, this[t3 + 2] = e3 >>> 16, this[t3 + 1] = e3 >>> 8, this[t3] = 255 & e3, t3 + 4;
  }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 4, 4294967295, 0), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
  }, l.prototype.writeBigUInt64LE = Q(function(e3) {
    return j(this, e3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l.prototype.writeBigUInt64BE = Q(function(e3) {
    return L(this, e3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l.prototype.writeIntLE = function(e3, t3, r3, n3) {
    if (e3 = +e3, t3 >>>= 0, !n3) {
      const n4 = Math.pow(2, 8 * r3 - 1);
      D(this, e3, t3, r3, n4 - 1, -n4);
    }
    let s3 = 0, i3 = 1, o3 = 0;
    for (this[t3] = 255 & e3; ++s3 < r3 && (i3 *= 256); ) e3 < 0 && 0 === o3 && 0 !== this[t3 + s3 - 1] && (o3 = 1), this[t3 + s3] = (e3 / i3 >> 0) - o3 & 255;
    return t3 + r3;
  }, l.prototype.writeIntBE = function(e3, t3, r3, n3) {
    if (e3 = +e3, t3 >>>= 0, !n3) {
      const n4 = Math.pow(2, 8 * r3 - 1);
      D(this, e3, t3, r3, n4 - 1, -n4);
    }
    let s3 = r3 - 1, i3 = 1, o3 = 0;
    for (this[t3 + s3] = 255 & e3; --s3 >= 0 && (i3 *= 256); ) e3 < 0 && 0 === o3 && 0 !== this[t3 + s3 + 1] && (o3 = 1), this[t3 + s3] = (e3 / i3 >> 0) - o3 & 255;
    return t3 + r3;
  }, l.prototype.writeInt8 = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 1, 127, -128), e3 < 0 && (e3 = 255 + e3 + 1), this[t3] = 255 & e3, t3 + 1;
  }, l.prototype.writeInt16LE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 2, 32767, -32768), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
  }, l.prototype.writeInt16BE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 2, 32767, -32768), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
  }, l.prototype.writeInt32LE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 4, 2147483647, -2147483648), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, this[t3 + 2] = e3 >>> 16, this[t3 + 3] = e3 >>> 24, t3 + 4;
  }, l.prototype.writeInt32BE = function(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || D(this, e3, t3, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
  }, l.prototype.writeBigInt64LE = Q(function(e3) {
    return j(this, e3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), l.prototype.writeBigInt64BE = Q(function(e3) {
    return L(this, e3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), l.prototype.writeFloatLE = function(e3, t3, r3) {
    return B(this, e3, t3, true, r3);
  }, l.prototype.writeFloatBE = function(e3, t3, r3) {
    return B(this, e3, t3, false, r3);
  }, l.prototype.writeDoubleLE = function(e3, t3, r3) {
    return R(this, e3, t3, true, r3);
  }, l.prototype.writeDoubleBE = function(e3, t3, r3) {
    return R(this, e3, t3, false, r3);
  }, l.prototype.copy = function(e3, t3, r3, n3) {
    if (!l.isBuffer(e3)) throw new TypeError("argument should be a Buffer");
    if (r3 || (r3 = 0), n3 || 0 === n3 || (n3 = this.length), t3 >= e3.length && (t3 = e3.length), t3 || (t3 = 0), n3 > 0 && n3 < r3 && (n3 = r3), n3 === r3) return 0;
    if (0 === e3.length || 0 === this.length) return 0;
    if (t3 < 0) throw new RangeError("targetStart out of bounds");
    if (r3 < 0 || r3 >= this.length) throw new RangeError("Index out of range");
    if (n3 < 0) throw new RangeError("sourceEnd out of bounds");
    n3 > this.length && (n3 = this.length), e3.length - t3 < n3 - r3 && (n3 = e3.length - t3 + r3);
    const s3 = n3 - r3;
    return this === e3 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t3, r3, n3) : Uint8Array.prototype.set.call(e3, this.subarray(r3, n3), t3), s3;
  }, l.prototype.fill = function(e3, t3, r3, n3) {
    if ("string" == typeof e3) {
      if ("string" == typeof t3 ? (n3 = t3, t3 = 0, r3 = this.length) : "string" == typeof r3 && (n3 = r3, r3 = this.length), void 0 !== n3 && "string" != typeof n3) throw new TypeError("encoding must be a string");
      if ("string" == typeof n3 && !l.isEncoding(n3)) throw new TypeError("Unknown encoding: " + n3);
      if (1 === e3.length) {
        const t4 = e3.charCodeAt(0);
        ("utf8" === n3 && t4 < 128 || "latin1" === n3) && (e3 = t4);
      }
    } else "number" == typeof e3 ? e3 &= 255 : "boolean" == typeof e3 && (e3 = Number(e3));
    if (t3 < 0 || this.length < t3 || this.length < r3) throw new RangeError("Out of range index");
    if (r3 <= t3) return this;
    let s3;
    if (t3 >>>= 0, r3 = void 0 === r3 ? this.length : r3 >>> 0, e3 || (e3 = 0), "number" == typeof e3) for (s3 = t3; s3 < r3; ++s3) this[s3] = e3;
    else {
      const i3 = l.isBuffer(e3) ? e3 : l.from(e3, n3), o3 = i3.length;
      if (0 === o3) throw new TypeError('The value "' + e3 + '" is invalid for argument "value"');
      for (s3 = 0; s3 < r3 - t3; ++s3) this[s3 + t3] = i3[s3 % o3];
    }
    return this;
  };
  const F = {};
  function U(e3, t3, r3) {
    F[e3] = class extends r3 {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: t3.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e3}]`, this.stack, delete this.name;
      }
      get code() {
        return e3;
      }
      set code(e4) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e4, writable: true });
      }
      toString() {
        return `${this.name} [${e3}]: ${this.message}`;
      }
    };
  }
  function $(e3) {
    let t3 = "", r3 = e3.length;
    const n3 = "-" === e3[0] ? 1 : 0;
    for (; r3 >= n3 + 4; r3 -= 3) t3 = `_${e3.slice(r3 - 3, r3)}${t3}`;
    return `${e3.slice(0, r3)}${t3}`;
  }
  function V(e3, t3, r3, n3, s3, i3) {
    if (e3 > r3 || e3 < t3) {
      const n4 = "bigint" == typeof t3 ? "n" : "";
      let s4;
      throw s4 = i3 > 3 ? 0 === t3 || t3 === BigInt(0) ? `>= 0${n4} and < 2${n4} ** ${8 * (i3 + 1)}${n4}` : `>= -(2${n4} ** ${8 * (i3 + 1) - 1}${n4}) and < 2 ** ${8 * (i3 + 1) - 1}${n4}` : `>= ${t3}${n4} and <= ${r3}${n4}`, new F.ERR_OUT_OF_RANGE("value", s4, e3);
    }
    !function(e4, t4, r4) {
      q(t4, "offset"), void 0 !== e4[t4] && void 0 !== e4[t4 + r4] || W(t4, e4.length - (r4 + 1));
    }(n3, s3, i3);
  }
  function q(e3, t3) {
    if ("number" != typeof e3) throw new F.ERR_INVALID_ARG_TYPE(t3, "number", e3);
  }
  function W(e3, t3, r3) {
    if (Math.floor(e3) !== e3) throw q(e3, r3), new F.ERR_OUT_OF_RANGE(r3 || "offset", "an integer", e3);
    if (t3 < 0) throw new F.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new F.ERR_OUT_OF_RANGE(r3 || "offset", `>= ${r3 ? 1 : 0} and <= ${t3}`, e3);
  }
  U("ERR_BUFFER_OUT_OF_BOUNDS", function(e3) {
    return e3 ? `${e3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), U("ERR_INVALID_ARG_TYPE", function(e3, t3) {
    return `The "${e3}" argument must be of type number. Received type ${typeof t3}`;
  }, TypeError), U("ERR_OUT_OF_RANGE", function(e3, t3, r3) {
    let n3 = `The value of "${e3}" is out of range.`, s3 = r3;
    return Number.isInteger(r3) && Math.abs(r3) > 2 ** 32 ? s3 = $(String(r3)) : "bigint" == typeof r3 && (s3 = String(r3), (r3 > BigInt(2) ** BigInt(32) || r3 < -(BigInt(2) ** BigInt(32))) && (s3 = $(s3)), s3 += "n"), n3 += ` It must be ${t3}. Received ${s3}`, n3;
  }, RangeError);
  const G = /[^+/0-9A-Za-z-_]/g;
  function H(e3, t3) {
    let r3;
    t3 = t3 || 1 / 0;
    const n3 = e3.length;
    let s3 = null;
    const i3 = [];
    for (let o3 = 0; o3 < n3; ++o3) {
      if (r3 = e3.charCodeAt(o3), r3 > 55295 && r3 < 57344) {
        if (!s3) {
          if (r3 > 56319) {
            (t3 -= 3) > -1 && i3.push(239, 191, 189);
            continue;
          }
          if (o3 + 1 === n3) {
            (t3 -= 3) > -1 && i3.push(239, 191, 189);
            continue;
          }
          s3 = r3;
          continue;
        }
        if (r3 < 56320) {
          (t3 -= 3) > -1 && i3.push(239, 191, 189), s3 = r3;
          continue;
        }
        r3 = 65536 + (s3 - 55296 << 10 | r3 - 56320);
      } else s3 && (t3 -= 3) > -1 && i3.push(239, 191, 189);
      if (s3 = null, r3 < 128) {
        if ((t3 -= 1) < 0) break;
        i3.push(r3);
      } else if (r3 < 2048) {
        if ((t3 -= 2) < 0) break;
        i3.push(r3 >> 6 | 192, 63 & r3 | 128);
      } else if (r3 < 65536) {
        if ((t3 -= 3) < 0) break;
        i3.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
      } else {
        if (!(r3 < 1114112)) throw new Error("Invalid code point");
        if ((t3 -= 4) < 0) break;
        i3.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
      }
    }
    return i3;
  }
  function z(e3) {
    return n2.toByteArray(function(e4) {
      if ((e4 = (e4 = e4.split("=")[0]).trim().replace(G, "")).length < 2) return "";
      for (; e4.length % 4 != 0; ) e4 += "=";
      return e4;
    }(e3));
  }
  function K(e3, t3, r3, n3) {
    let s3;
    for (s3 = 0; s3 < n3 && !(s3 + r3 >= t3.length || s3 >= e3.length); ++s3) t3[s3 + r3] = e3[s3];
    return s3;
  }
  function X(e3, t3) {
    return e3 instanceof t3 || null != e3 && null != e3.constructor && null != e3.constructor.name && e3.constructor.name === t3.name;
  }
  function J(e3) {
    return e3 != e3;
  }
  const Y = function() {
    const e3 = "0123456789abcdef", t3 = new Array(256);
    for (let r3 = 0; r3 < 16; ++r3) {
      const n3 = 16 * r3;
      for (let s3 = 0; s3 < 16; ++s3) t3[n3 + s3] = e3[r3] + e3[s3];
    }
    return t3;
  }();
  function Q(e3) {
    return "undefined" == typeof BigInt ? Z : e3;
  }
  function Z() {
    throw new Error("BigInt not supported");
  }
}, (e2, t2, r2) => {
  var n2 = r2(17), s2 = Object.getOwnPropertyDescriptors || function(e3) {
    for (var t3 = Object.keys(e3), r3 = {}, n3 = 0; n3 < t3.length; n3++) r3[t3[n3]] = Object.getOwnPropertyDescriptor(e3, t3[n3]);
    return r3;
  }, i2 = /%[sdj%]/g;
  t2.format = function(e3) {
    if (!b(e3)) {
      for (var t3 = [], r3 = 0; r3 < arguments.length; r3++) t3.push(l(arguments[r3]));
      return t3.join(" ");
    }
    r3 = 1;
    for (var n3 = arguments, s3 = n3.length, o3 = String(e3).replace(i2, function(e4) {
      if ("%%" === e4) return "%";
      if (r3 >= s3) return e4;
      switch (e4) {
        case "%s":
          return String(n3[r3++]);
        case "%d":
          return Number(n3[r3++]);
        case "%j":
          try {
            return JSON.stringify(n3[r3++]);
          } catch (e5) {
            return "[Circular]";
          }
        default:
          return e4;
      }
    }), a3 = n3[r3]; r3 < s3; a3 = n3[++r3]) y(a3) || !S(a3) ? o3 += " " + a3 : o3 += " " + l(a3);
    return o3;
  }, t2.deprecate = function(e3, r3) {
    if (void 0 !== n2 && true === n2.noDeprecation) return e3;
    if (void 0 === n2) return function() {
      return t2.deprecate(e3, r3).apply(this, arguments);
    };
    var s3 = false;
    return function() {
      if (!s3) {
        if (n2.throwDeprecation) throw new Error(r3);
        n2.traceDeprecation, s3 = true;
      }
      return e3.apply(this, arguments);
    };
  };
  var o2 = {}, a2 = /^$/;
  function l(e3, r3) {
    var n3 = { seen: [], stylize: u };
    return arguments.length >= 3 && (n3.depth = arguments[2]), arguments.length >= 4 && (n3.colors = arguments[3]), m(r3) ? n3.showHidden = r3 : r3 && t2._extend(n3, r3), v(n3.showHidden) && (n3.showHidden = false), v(n3.depth) && (n3.depth = 2), v(n3.colors) && (n3.colors = false), v(n3.customInspect) && (n3.customInspect = true), n3.colors && (n3.stylize = c), p(n3, e3, n3.depth);
  }
  function c(e3, t3) {
    var r3 = l.styles[t3];
    return r3 ? "\x1B[" + l.colors[r3][0] + "m" + e3 + "\x1B[" + l.colors[r3][1] + "m" : e3;
  }
  function u(e3, t3) {
    return e3;
  }
  function p(e3, r3, n3) {
    if (e3.customInspect && r3 && w(r3.inspect) && r3.inspect !== t2.inspect && (!r3.constructor || r3.constructor.prototype !== r3)) {
      var s3 = r3.inspect(n3, e3);
      return b(s3) || (s3 = p(e3, s3, n3)), s3;
    }
    var i3 = function(e4, t3) {
      if (v(t3)) return e4.stylize("undefined", "undefined");
      if (b(t3)) {
        var r4 = "'" + JSON.stringify(t3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e4.stylize(r4, "string");
      }
      return g(t3) ? e4.stylize("" + t3, "number") : m(t3) ? e4.stylize("" + t3, "boolean") : y(t3) ? e4.stylize("null", "null") : void 0;
    }(e3, r3);
    if (i3) return i3;
    var o3 = Object.keys(r3), a3 = function(e4) {
      var t3 = {};
      return e4.forEach(function(e5, r4) {
        t3[e5] = true;
      }), t3;
    }(o3);
    if (e3.showHidden && (o3 = Object.getOwnPropertyNames(r3)), T(r3) && (o3.indexOf("message") >= 0 || o3.indexOf("description") >= 0)) return d(r3);
    if (0 === o3.length) {
      if (w(r3)) {
        var l2 = r3.name ? ": " + r3.name : "";
        return e3.stylize("[Function" + l2 + "]", "special");
      }
      if (E(r3)) return e3.stylize(RegExp.prototype.toString.call(r3), "regexp");
      if (x(r3)) return e3.stylize(Date.prototype.toString.call(r3), "date");
      if (T(r3)) return d(r3);
    }
    var c2, u2 = "", S2 = false, P2 = ["{", "}"];
    return h(r3) && (S2 = true, P2 = ["[", "]"]), w(r3) && (u2 = " [Function" + (r3.name ? ": " + r3.name : "") + "]"), E(r3) && (u2 = " " + RegExp.prototype.toString.call(r3)), x(r3) && (u2 = " " + Date.prototype.toUTCString.call(r3)), T(r3) && (u2 = " " + d(r3)), 0 !== o3.length || S2 && 0 != r3.length ? n3 < 0 ? E(r3) ? e3.stylize(RegExp.prototype.toString.call(r3), "regexp") : e3.stylize("[Object]", "special") : (e3.seen.push(r3), c2 = S2 ? function(e4, t3, r4, n4, s4) {
      for (var i4 = [], o4 = 0, a4 = t3.length; o4 < a4; ++o4) A(t3, String(o4)) ? i4.push(f(e4, t3, r4, n4, String(o4), true)) : i4.push("");
      return s4.forEach(function(s5) {
        s5.match(/^\d+$/) || i4.push(f(e4, t3, r4, n4, s5, true));
      }), i4;
    }(e3, r3, n3, a3, o3) : o3.map(function(t3) {
      return f(e3, r3, n3, a3, t3, S2);
    }), e3.seen.pop(), function(e4, t3, r4) {
      return e4.reduce(function(e5, t4) {
        return t4.indexOf("\n"), e5 + t4.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0) > 60 ? r4[0] + ("" === t3 ? "" : t3 + "\n ") + " " + e4.join(",\n  ") + " " + r4[1] : r4[0] + t3 + " " + e4.join(", ") + " " + r4[1];
    }(c2, u2, P2)) : P2[0] + u2 + P2[1];
  }
  function d(e3) {
    return "[" + Error.prototype.toString.call(e3) + "]";
  }
  function f(e3, t3, r3, n3, s3, i3) {
    var o3, a3, l2;
    if ((l2 = Object.getOwnPropertyDescriptor(t3, s3) || { value: t3[s3] }).get ? a3 = l2.set ? e3.stylize("[Getter/Setter]", "special") : e3.stylize("[Getter]", "special") : l2.set && (a3 = e3.stylize("[Setter]", "special")), A(n3, s3) || (o3 = "[" + s3 + "]"), a3 || (e3.seen.indexOf(l2.value) < 0 ? (a3 = y(r3) ? p(e3, l2.value, null) : p(e3, l2.value, r3 - 1)).indexOf("\n") > -1 && (a3 = i3 ? a3.split("\n").map(function(e4) {
      return "  " + e4;
    }).join("\n").slice(2) : "\n" + a3.split("\n").map(function(e4) {
      return "   " + e4;
    }).join("\n")) : a3 = e3.stylize("[Circular]", "special")), v(o3)) {
      if (i3 && s3.match(/^\d+$/)) return a3;
      (o3 = JSON.stringify("" + s3)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o3 = o3.slice(1, -1), o3 = e3.stylize(o3, "name")) : (o3 = o3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o3 = e3.stylize(o3, "string"));
    }
    return o3 + ": " + a3;
  }
  function h(e3) {
    return Array.isArray(e3);
  }
  function m(e3) {
    return "boolean" == typeof e3;
  }
  function y(e3) {
    return null === e3;
  }
  function g(e3) {
    return "number" == typeof e3;
  }
  function b(e3) {
    return "string" == typeof e3;
  }
  function v(e3) {
    return void 0 === e3;
  }
  function E(e3) {
    return S(e3) && "[object RegExp]" === P(e3);
  }
  function S(e3) {
    return "object" == typeof e3 && null !== e3;
  }
  function x(e3) {
    return S(e3) && "[object Date]" === P(e3);
  }
  function T(e3) {
    return S(e3) && ("[object Error]" === P(e3) || e3 instanceof Error);
  }
  function w(e3) {
    return "function" == typeof e3;
  }
  function P(e3) {
    return Object.prototype.toString.call(e3);
  }
  function A(e3, t3) {
    return Object.prototype.hasOwnProperty.call(e3, t3);
  }
  t2.debuglog = function(e3) {
    return e3 = e3.toUpperCase(), o2[e3] || (a2.test(e3) ? (n2.pid, o2[e3] = function() {
      t2.format.apply(t2, arguments);
    }) : o2[e3] = function() {
    }), o2[e3];
  }, t2.inspect = l, l.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, l.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, t2.types = r2(228), t2.isArray = h, t2.isBoolean = m, t2.isNull = y, t2.isNullOrUndefined = function(e3) {
    return null == e3;
  }, t2.isNumber = g, t2.isString = b, t2.isSymbol = function(e3) {
    return "symbol" == typeof e3;
  }, t2.isUndefined = v, t2.isRegExp = E, t2.types.isRegExp = E, t2.isObject = S, t2.isDate = x, t2.types.isDate = x, t2.isError = T, t2.types.isNativeError = T, t2.isFunction = w, t2.isPrimitive = function(e3) {
    return null === e3 || "boolean" == typeof e3 || "number" == typeof e3 || "string" == typeof e3 || "symbol" == typeof e3 || void 0 === e3;
  }, t2.isBuffer = r2(240), t2.log = function() {
  }, t2.inherits = r2(158), t2._extend = function(e3, t3) {
    if (!t3 || !S(t3)) return e3;
    for (var r3 = Object.keys(t3), n3 = r3.length; n3--; ) e3[r3[n3]] = t3[r3[n3]];
    return e3;
  };
  var C = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
  function O(e3, t3) {
    if (!e3) {
      var r3 = new Error("Promise was rejected with a falsy value");
      r3.reason = e3, e3 = r3;
    }
    return t3(e3);
  }
  t2.promisify = function(e3) {
    if ("function" != typeof e3) throw new TypeError('The "original" argument must be of type Function');
    if (C && e3[C]) {
      var t3;
      if ("function" != typeof (t3 = e3[C])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(t3, C, { value: t3, enumerable: false, writable: false, configurable: true }), t3;
    }
    function t3() {
      for (var t4, r3, n3 = new Promise(function(e4, n4) {
        t4 = e4, r3 = n4;
      }), s3 = [], i3 = 0; i3 < arguments.length; i3++) s3.push(arguments[i3]);
      s3.push(function(e4, n4) {
        e4 ? r3(e4) : t4(n4);
      });
      try {
        e3.apply(this, s3);
      } catch (e4) {
        r3(e4);
      }
      return n3;
    }
    return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), C && Object.defineProperty(t3, C, { value: t3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t3, s2(e3));
  }, t2.promisify.custom = C, t2.callbackify = function(e3) {
    if ("function" != typeof e3) throw new TypeError('The "original" argument must be of type Function');
    function t3() {
      for (var t4 = [], r3 = 0; r3 < arguments.length; r3++) t4.push(arguments[r3]);
      var s3 = t4.pop();
      if ("function" != typeof s3) throw new TypeError("The last argument must be of type Function");
      var i3 = this, o3 = function() {
        return s3.apply(i3, arguments);
      };
      e3.apply(this, t4).then(function(e4) {
        n2.nextTick(o3.bind(null, null, e4));
      }, function(e4) {
        n2.nextTick(O.bind(null, e4, o3));
      });
    }
    return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), Object.defineProperties(t3, s2(e3)), t3;
  };
}, (e2, t2) => {
  function r2(e3) {
    const { context: t3, node: r3 } = e3;
    if (r3.computed && t3.maybeQueue(e3.get("key")), r3.decorators) for (const r4 of e3.get("decorators")) t3.maybeQueue(r4);
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.requeueComputedKeyAndDecorators = r2, t2.skipAllButComputedKey = function(e3) {
    e3.skip(), e3.node.computed && e3.context.maybeQueue(e3.get("key"));
  };
  var n2 = { FunctionParent(e3) {
    e3.isArrowFunctionExpression() || (e3.skip(), e3.isMethod() && r2(e3));
  }, Property(e3) {
    e3.isObjectProperty() || (e3.skip(), r2(e3));
  } };
  t2.default = n2;
}, (e2, t2, r2) => {
  const { MAX_SAFE_COMPONENT_LENGTH: n2, MAX_SAFE_BUILD_LENGTH: s2, MAX_LENGTH: i2 } = r2(47), o2 = r2(48), a2 = (t2 = e2.exports = {}).re = [], l = t2.safeRe = [], c = t2.src = [], u = t2.t = {};
  let p = 0;
  const d = "[a-zA-Z0-9-]", f = [["\\s", 1], ["\\d", i2], [d, s2]], h = (e3, t3, r3) => {
    const n3 = ((e4) => {
      for (const [t4, r4] of f) e4 = e4.split(`${t4}*`).join(`${t4}{0,${r4}}`).split(`${t4}+`).join(`${t4}{1,${r4}}`);
      return e4;
    })(t3), s3 = p++;
    o2(e3, s3, t3), u[e3] = s3, c[s3] = t3, a2[s3] = new RegExp(t3, r3 ? "g" : void 0), l[s3] = new RegExp(n3, r3 ? "g" : void 0);
  };
  h("NUMERICIDENTIFIER", "0|[1-9]\\d*"), h("NUMERICIDENTIFIERLOOSE", "\\d+"), h("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${d}*`), h("MAINVERSION", `(${c[u.NUMERICIDENTIFIER]})\\.(${c[u.NUMERICIDENTIFIER]})\\.(${c[u.NUMERICIDENTIFIER]})`), h("MAINVERSIONLOOSE", `(${c[u.NUMERICIDENTIFIERLOOSE]})\\.(${c[u.NUMERICIDENTIFIERLOOSE]})\\.(${c[u.NUMERICIDENTIFIERLOOSE]})`), h("PRERELEASEIDENTIFIER", `(?:${c[u.NUMERICIDENTIFIER]}|${c[u.NONNUMERICIDENTIFIER]})`), h("PRERELEASEIDENTIFIERLOOSE", `(?:${c[u.NUMERICIDENTIFIERLOOSE]}|${c[u.NONNUMERICIDENTIFIER]})`), h("PRERELEASE", `(?:-(${c[u.PRERELEASEIDENTIFIER]}(?:\\.${c[u.PRERELEASEIDENTIFIER]})*))`), h("PRERELEASELOOSE", `(?:-?(${c[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[u.PRERELEASEIDENTIFIERLOOSE]})*))`), h("BUILDIDENTIFIER", `${d}+`), h("BUILD", `(?:\\+(${c[u.BUILDIDENTIFIER]}(?:\\.${c[u.BUILDIDENTIFIER]})*))`), h("FULLPLAIN", `v?${c[u.MAINVERSION]}${c[u.PRERELEASE]}?${c[u.BUILD]}?`), h("FULL", `^${c[u.FULLPLAIN]}$`), h("LOOSEPLAIN", `[v=\\s]*${c[u.MAINVERSIONLOOSE]}${c[u.PRERELEASELOOSE]}?${c[u.BUILD]}?`), h("LOOSE", `^${c[u.LOOSEPLAIN]}$`), h("GTLT", "((?:<|>)?=?)"), h("XRANGEIDENTIFIERLOOSE", `${c[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), h("XRANGEIDENTIFIER", `${c[u.NUMERICIDENTIFIER]}|x|X|\\*`), h("XRANGEPLAIN", `[v=\\s]*(${c[u.XRANGEIDENTIFIER]})(?:\\.(${c[u.XRANGEIDENTIFIER]})(?:\\.(${c[u.XRANGEIDENTIFIER]})(?:${c[u.PRERELEASE]})?${c[u.BUILD]}?)?)?`), h("XRANGEPLAINLOOSE", `[v=\\s]*(${c[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[u.XRANGEIDENTIFIERLOOSE]})(?:${c[u.PRERELEASELOOSE]})?${c[u.BUILD]}?)?)?`), h("XRANGE", `^${c[u.GTLT]}\\s*${c[u.XRANGEPLAIN]}$`), h("XRANGELOOSE", `^${c[u.GTLT]}\\s*${c[u.XRANGEPLAINLOOSE]}$`), h("COERCE", `(^|[^\\d])(\\d{1,${n2}})(?:\\.(\\d{1,${n2}}))?(?:\\.(\\d{1,${n2}}))?(?:$|[^\\d])`), h("COERCERTL", c[u.COERCE], true), h("LONETILDE", "(?:~>?)"), h("TILDETRIM", `(\\s*)${c[u.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", h("TILDE", `^${c[u.LONETILDE]}${c[u.XRANGEPLAIN]}$`), h("TILDELOOSE", `^${c[u.LONETILDE]}${c[u.XRANGEPLAINLOOSE]}$`), h("LONECARET", "(?:\\^)"), h("CARETTRIM", `(\\s*)${c[u.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", h("CARET", `^${c[u.LONECARET]}${c[u.XRANGEPLAIN]}$`), h("CARETLOOSE", `^${c[u.LONECARET]}${c[u.XRANGEPLAINLOOSE]}$`), h("COMPARATORLOOSE", `^${c[u.GTLT]}\\s*(${c[u.LOOSEPLAIN]})$|^$`), h("COMPARATOR", `^${c[u.GTLT]}\\s*(${c[u.FULLPLAIN]})$|^$`), h("COMPARATORTRIM", `(\\s*)${c[u.GTLT]}\\s*(${c[u.LOOSEPLAIN]}|${c[u.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", h("HYPHENRANGE", `^\\s*(${c[u.XRANGEPLAIN]})\\s+-\\s+(${c[u.XRANGEPLAIN]})\\s*$`), h("HYPHENRANGELOOSE", `^\\s*(${c[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[u.XRANGEPLAINLOOSE]})\\s*$`), h("STAR", "(<|>)?=?\\s*\\*"), h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.clear = function() {
    s2(), i2();
  }, t2.clearPath = s2, t2.clearScope = i2, t2.getCachedPaths = function(e3, t3) {
    var n3;
    return null == (n3 = r2.get(o2)) ? void 0 : n3.get(t3);
  }, t2.getOrCreateCachedPaths = function(e3, t3) {
    let n3 = r2.get(o2);
    n3 || r2.set(o2, n3 = /* @__PURE__ */ new WeakMap());
    let s3 = n3.get(t3);
    return s3 || n3.set(t3, s3 = /* @__PURE__ */ new Map()), s3;
  }, t2.scope = t2.path = void 0;
  let r2 = t2.path = /* @__PURE__ */ new WeakMap(), n2 = t2.scope = /* @__PURE__ */ new WeakMap();
  function s2() {
    t2.path = r2 = /* @__PURE__ */ new WeakMap();
  }
  function i2() {
    t2.scope = n2 = /* @__PURE__ */ new WeakMap();
  }
  const o2 = Object.freeze({});
}, (e2, t2, r2) => {
  var n2 = r2(17);
  Object.defineProperty(t2, "__esModule", { value: true }), t2.codeFrameColumns = u, t2.default = function(e3, t3, r3) {
    let s3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
    if (!l) {
      l = true;
      const e4 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      n2.emitWarning ? n2.emitWarning(e4, "DeprecationWarning") : new Error(e4).name = "DeprecationWarning";
    }
    return u(e3, { start: { column: r3 = Math.max(r3, 0), line: t3 } }, s3);
  };
  var s2 = r2(428), i2 = function(e3, t3) {
    if (null === e3 || "object" != typeof e3 && "function" != typeof e3) return { default: e3 };
    var r3 = o2(true);
    if (r3 && r3.has(e3)) return r3.get(e3);
    var n3 = { __proto__: null }, s3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var i3 in e3) if ("default" !== i3 && Object.prototype.hasOwnProperty.call(e3, i3)) {
      var a3 = s3 ? Object.getOwnPropertyDescriptor(e3, i3) : null;
      a3 && (a3.get || a3.set) ? Object.defineProperty(n3, i3, a3) : n3[i3] = e3[i3];
    }
    return n3.default = e3, r3 && r3.set(e3, n3), n3;
  }(r2(224));
  function o2(e3) {
    if ("function" != typeof WeakMap) return null;
    var t3 = /* @__PURE__ */ new WeakMap(), r3 = /* @__PURE__ */ new WeakMap();
    return (o2 = function(e4) {
      return e4 ? r3 : t3;
    })(e3);
  }
  let a2, l = false;
  const c = /\r\n|[\n\r\u2028\u2029]/;
  function u(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    const n3 = (r3.highlightCode || r3.forceColor) && (0, s2.shouldHighlight)(r3), o3 = r3.forceColor ? (null != a2 || (a2 = new i2.default.constructor({ enabled: true, level: 1 })), a2) : i2.default, l2 = function(e4) {
      return { gutter: e4.grey, marker: e4.red.bold, message: e4.red.bold };
    }(o3), u2 = (e4, t4) => n3 ? e4(t4) : t4, p = e3.split(c), { start: d, end: f, markerLines: h } = function(e4, t4, r4) {
      const n4 = Object.assign({ column: 0, line: -1 }, e4.start), s3 = Object.assign({}, n4, e4.end), { linesAbove: i3 = 2, linesBelow: o4 = 3 } = r4 || {}, a3 = n4.line, l3 = n4.column, c2 = s3.line, u3 = s3.column;
      let p2 = Math.max(a3 - (i3 + 1), 0), d2 = Math.min(t4.length, c2 + o4);
      -1 === a3 && (p2 = 0), -1 === c2 && (d2 = t4.length);
      const f2 = c2 - a3, h2 = {};
      if (f2) for (let e5 = 0; e5 <= f2; e5++) {
        const r5 = e5 + a3;
        if (l3) if (0 === e5) {
          const e6 = t4[r5 - 1].length;
          h2[r5] = [l3, e6 - l3 + 1];
        } else if (e5 === f2) h2[r5] = [0, u3];
        else {
          const n5 = t4[r5 - e5].length;
          h2[r5] = [0, n5];
        }
        else h2[r5] = true;
      }
      else h2[a3] = l3 === u3 ? !l3 || [l3, 0] : [l3, u3 - l3];
      return { start: p2, end: d2, markerLines: h2 };
    }(t3, p, r3), m = t3.start && "number" == typeof t3.start.column, y = String(f).length;
    let g = (n3 ? (0, s2.default)(e3, r3) : e3).split(c, f).slice(d, f).map((e4, t4) => {
      const n4 = d + 1 + t4, s3 = ` ${` ${n4}`.slice(-y)} |`, i3 = h[n4], o4 = !h[n4 + 1];
      if (i3) {
        let t5 = "";
        if (Array.isArray(i3)) {
          const n5 = e4.slice(0, Math.max(i3[0] - 1, 0)).replace(/[^\t]/g, " "), a3 = i3[1] || 1;
          t5 = ["\n ", u2(l2.gutter, s3.replace(/\d/g, " ")), " ", n5, u2(l2.marker, "^").repeat(a3)].join(""), o4 && r3.message && (t5 += " " + u2(l2.message, r3.message));
        }
        return [u2(l2.marker, ">"), u2(l2.gutter, s3), e4.length > 0 ? ` ${e4}` : "", t5].join("");
      }
      return ` ${u2(l2.gutter, s3)}${e4.length > 0 ? ` ${e4}` : ""}`;
    }).join("\n");
    return r3.message && !m && (g = `${" ".repeat(y + 1)}${r3.message}
${g}`), n3 ? o3.reset(g) : g;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.statements = t2.statement = t2.smart = t2.program = t2.expression = t2.default = void 0;
  var n2 = r2(432), s2 = r2(433);
  const i2 = (0, s2.default)(n2.smart);
  t2.smart = i2;
  const o2 = (0, s2.default)(n2.statement);
  t2.statement = o2;
  const a2 = (0, s2.default)(n2.statements);
  t2.statements = a2;
  const l = (0, s2.default)(n2.expression);
  t2.expression = l;
  const c = (0, s2.default)(n2.program);
  t2.program = c;
  var u = Object.assign(i2.bind(void 0), { smart: i2, statement: o2, statements: a2, expression: l, program: c, ast: i2.ast });
  t2.default = u;
}, (e2, t2, r2) => {
  var n2 = r2(22), s2 = r2(41), i2 = s2(n2("String.prototype.indexOf"));
  e2.exports = function(e3, t3) {
    var r3 = n2(e3, !!t3);
    return "function" == typeof r3 && i2(e3, ".prototype.") > -1 ? s2(r3) : r3;
  };
}, (e2, t2) => {
  var r2;
  Object.defineProperty(t2, "__esModule", { value: true }), t2.beginHiddenCallStack = function(e3) {
    return s2 ? Object.defineProperty(function() {
      return c(), e3(...arguments);
    }, "name", { value: o2 }) : e3;
  }, t2.endHiddenCallStack = function(e3) {
    return s2 ? Object.defineProperty(function() {
      return e3(...arguments);
    }, "name", { value: i2 }) : e3;
  }, t2.expectedError = function(e3) {
    if (s2) return a2.add(e3), e3;
  }, t2.injectVirtualStackFrame = function(e3, t3) {
    if (!s2) return;
    let r3 = l.get(e3);
    return r3 || l.set(e3, r3 = []), r3.push(/* @__PURE__ */ function(e4) {
      return /* @__PURE__ */ Object.create({ isNative: () => false, isConstructor: () => false, isToplevel: () => true, getFileName: () => e4, getLineNumber: () => {
      }, getColumnNumber: () => {
      }, getFunctionName: () => {
      }, getMethodName: () => {
      }, getTypeName: () => {
      }, toString: () => e4 });
    }(t3)), e3;
  };
  const n2 = Function.call.bind(Error.prototype.toString), s2 = !!Error.captureStackTrace && true === (null == (r2 = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) ? void 0 : r2.writable), i2 = "startHiding - secret - don't use this - v1", o2 = "stopHiding - secret - don't use this - v1", a2 = /* @__PURE__ */ new WeakSet(), l = /* @__PURE__ */ new WeakMap();
  function c() {
    c = () => {
    };
    const { prepareStackTrace: e3 = u } = Error;
    Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, 50)), Error.prepareStackTrace = function(t3, r3) {
      let n3 = [], s3 = a2.has(t3) ? "hiding" : "unknown";
      for (let e4 = 0; e4 < r3.length; e4++) {
        const a3 = r3[e4].getFunctionName();
        if (a3 === i2) s3 = "hiding";
        else if (a3 === o2) {
          if ("hiding" === s3) s3 = "showing", l.has(t3) && n3.unshift(...l.get(t3));
          else if ("unknown" === s3) {
            n3 = r3;
            break;
          }
        } else "hiding" !== s3 && n3.push(r3[e4]);
      }
      return e3(t3, n3);
    };
  }
  function u(e3, t3) {
    return 0 === t3.length ? n2(e3) : `${n2(e3)}
    at ${t3.join("\n    at ")}`;
  }
}, (e2, t2, r2) => {
  let n2, s2, i2 = r2(24);
  class o2 extends i2 {
    constructor(e3) {
      super(e3), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(e3, t3, r3) {
      let n3 = super.normalize(e3);
      if (t3) {
        if ("prepend" === r3) this.nodes.length > 1 ? t3.raws.before = this.nodes[1].raws.before : delete t3.raws.before;
        else if (this.first !== t3) for (let e4 of n3) e4.raws.before = t3.raws.before;
      }
      return n3;
    }
    removeChild(e3, t3) {
      let r3 = this.index(e3);
      return !t3 && 0 === r3 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r3].raws.before), super.removeChild(e3);
    }
    toResult() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return new n2(new s2(), this, e3).stringify();
    }
  }
  o2.registerLazyResult = (e3) => {
    n2 = e3;
  }, o2.registerProcessor = (e3) => {
    s2 = e3;
  }, e2.exports = o2, o2.default = o2, i2.registerRoot(o2);
}, (e2, t2, r2) => {
  var n2 = r2(71), s2 = r2(22), i2 = r2(234), o2 = s2("%TypeError%"), a2 = s2("%Function.prototype.apply%"), l = s2("%Function.prototype.call%"), c = s2("%Reflect.apply%", true) || n2.call(l, a2), u = s2("%Object.defineProperty%", true), p = s2("%Math.max%");
  if (u) try {
    u({}, "a", { value: 1 });
  } catch (e3) {
    u = null;
  }
  e2.exports = function(e3) {
    if ("function" != typeof e3) throw new o2("a function is required");
    var t3 = c(n2, l, arguments);
    return i2(t3, 1 + p(0, e3.length - (arguments.length - 1)), true);
  };
  var d = function() {
    return c(n2, a2, arguments);
  };
  u ? u(e2.exports, "apply", { value: d }) : e2.exports.apply = d;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    return !!t3 && ((0, s2.default)(t3.type, e3) ? void 0 === r3 || (0, n2.default)(t3, r3) : !r3 && "Placeholder" === t3.type && e3 in o2.FLIPPED_ALIAS_KEYS && (0, i2.default)(t3.expectedNode, e3));
  };
  var n2 = r2(96), s2 = r2(98), i2 = r2(168), o2 = r2(9);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return "string" == typeof e3 && ((!(!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) || !(0, n2.isKeyword)(e3) && !(0, n2.isStrictReservedWord)(e3, true)) && (0, n2.isIdentifierName)(e3));
  };
  var n2 = r2(59);
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(15), i2 = r2(102), o2 = r2(204), a2 = r2(11), l = n2.RegExp, c = l.prototype;
  s2 && a2(function() {
    var e3 = true;
    try {
      l(".", "d");
    } catch (t4) {
      e3 = false;
    }
    var t3 = {}, r3 = "", n3 = e3 ? "dgimsy" : "gimsy", s3 = function(e4, n4) {
      Object.defineProperty(t3, e4, { get: function() {
        return r3 += n4, true;
      } });
    }, i3 = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
    for (var o3 in e3 && (i3.hasIndices = "d"), i3) s3(o3, i3[o3]);
    return Object.getOwnPropertyDescriptor(c, "flags").get.call(t3) !== n3 || r3 !== n3;
  }) && i2(c, "flags", { configurable: true, get: o2 });
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(116), i2 = r2(29), o2 = r2(67), a2 = r2(113), l = r2(112), c = n2.Symbol, u = s2("wks"), p = l ? c.for || c : c && c.withoutSetter || o2;
  e2.exports = function(e3) {
    return i2(u, e3) || (u[e3] = a2 && i2(c, e3) ? c[e3] : p("Symbol." + e3)), u[e3];
  };
}, (e2, t2, r2) => {
  var n2 = r2(123), s2 = "function" == typeof Symbol && "symbol" == typeof Symbol("foo"), i2 = Object.prototype.toString, o2 = Array.prototype.concat, a2 = r2(121), l = r2(72)(), c = function(e3, t3, r3, n3) {
    if (t3 in e3) {
      if (true === n3) {
        if (e3[t3] === r3) return;
      } else if ("function" != typeof (s3 = n3) || "[object Function]" !== i2.call(s3) || !n3()) return;
    }
    var s3;
    l ? a2(e3, t3, r3, true) : a2(e3, t3, r3);
  }, u = function(e3, t3) {
    var r3 = arguments.length > 2 ? arguments[2] : {}, i3 = n2(t3);
    s2 && (i3 = o2.call(i3, Object.getOwnPropertySymbols(t3)));
    for (var a3 = 0; a3 < i3.length; a3 += 1) c(e3, i3[a3], t3[i3[a3]], r3[i3[a3]]);
  };
  u.supportsDescriptors = !!l, e2.exports = u;
}, (e2) => {
  const t2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  e2.exports = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: t2, RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"], SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
}, (e2, t2, r2) => {
  var n2 = r2(17);
  const s2 = ("object" == typeof n2 && n2.env, () => {
  });
  e2.exports = s2;
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => n2(e3, t3, r3) > 0;
}, (e2, t2, r2) => {
  const n2 = Symbol("SemVer ANY");
  class s2 {
    static get ANY() {
      return n2;
    }
    constructor(e3, t3) {
      if (t3 = i2(t3), e3 instanceof s2) {
        if (e3.loose === !!t3.loose) return e3;
        e3 = e3.value;
      }
      e3 = e3.trim().split(/\s+/).join(" "), c("comparator", e3, t3), this.options = t3, this.loose = !!t3.loose, this.parse(e3), this.semver === n2 ? this.value = "" : this.value = this.operator + this.semver.version, c("comp", this);
    }
    parse(e3) {
      const t3 = this.options.loose ? o2[a2.COMPARATORLOOSE] : o2[a2.COMPARATOR], r3 = e3.match(t3);
      if (!r3) throw new TypeError(`Invalid comparator: ${e3}`);
      this.operator = void 0 !== r3[1] ? r3[1] : "", "=" === this.operator && (this.operator = ""), r3[2] ? this.semver = new u(r3[2], this.options.loose) : this.semver = n2;
    }
    toString() {
      return this.value;
    }
    test(e3) {
      if (c("Comparator.test", e3, this.options.loose), this.semver === n2 || e3 === n2) return true;
      if ("string" == typeof e3) try {
        e3 = new u(e3, this.options);
      } catch (e4) {
        return false;
      }
      return l(e3, this.operator, this.semver, this.options);
    }
    intersects(e3, t3) {
      if (!(e3 instanceof s2)) throw new TypeError("a Comparator is required");
      return "" === this.operator ? "" === this.value || new p(e3.value, t3).test(this.value) : "" === e3.operator ? "" === e3.value || new p(this.value, t3).test(e3.semver) : !((t3 = i2(t3)).includePrerelease && ("<0.0.0-0" === this.value || "<0.0.0-0" === e3.value) || !t3.includePrerelease && (this.value.startsWith("<0.0.0") || e3.value.startsWith("<0.0.0")) || (!this.operator.startsWith(">") || !e3.operator.startsWith(">")) && (!this.operator.startsWith("<") || !e3.operator.startsWith("<")) && (this.semver.version !== e3.semver.version || !this.operator.includes("=") || !e3.operator.includes("=")) && !(l(this.semver, "<", e3.semver, t3) && this.operator.startsWith(">") && e3.operator.startsWith("<")) && !(l(this.semver, ">", e3.semver, t3) && this.operator.startsWith("<") && e3.operator.startsWith(">")));
    }
  }
  e2.exports = s2;
  const i2 = r2(75), { safeRe: o2, t: a2 } = r2(34), l = r2(131), c = r2(48), u = r2(3), p = r2(8);
}, (e2, t2, r2) => {
  const n2 = r2(8);
  e2.exports = (e3, t3, r3) => {
    try {
      t3 = new n2(t3, r3);
    } catch (e4) {
      return false;
    }
    return t3.test(e3);
  };
}, (e2, t2, r2) => {
  let n2 = r2(53);
  class s2 extends n2 {
    constructor(e3) {
      e3 && void 0 !== e3.value && "string" != typeof e3.value && (e3 = { ...e3, value: String(e3.value) }), super(e3), this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || "$" === this.prop[0];
    }
  }
  e2.exports = s2, s2.default = s2;
}, (e2, t2, r2) => {
  let { isClean: n2, my: s2 } = r2(145), i2 = r2(87), o2 = r2(146), a2 = r2(54);
  function l(e3, t3) {
    let r3 = new e3.constructor();
    for (let n3 in e3) {
      if (!Object.prototype.hasOwnProperty.call(e3, n3)) continue;
      if ("proxyCache" === n3) continue;
      let s3 = e3[n3], i3 = typeof s3;
      "parent" === n3 && "object" === i3 ? t3 && (r3[n3] = t3) : "source" === n3 ? r3[n3] = s3 : Array.isArray(s3) ? r3[n3] = s3.map((e4) => l(e4, r3)) : ("object" === i3 && null !== s3 && (s3 = l(s3)), r3[n3] = s3);
    }
    return r3;
  }
  class c {
    constructor() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.raws = {}, this[n2] = false, this[s2] = true;
      for (let t3 in e3) if ("nodes" === t3) {
        this.nodes = [];
        for (let r3 of e3[t3]) "function" == typeof r3.clone ? this.append(r3.clone()) : this.append(r3);
      } else this[t3] = e3[t3];
    }
    addToError(e3) {
      if (e3.postcssNode = this, e3.stack && this.source && /\n\s{4}at /.test(e3.stack)) {
        let t3 = this.source;
        e3.stack = e3.stack.replace(/\n\s{4}at /, `$&${t3.input.from}:${t3.start.line}:${t3.start.column}$&`);
      }
      return e3;
    }
    after(e3) {
      return this.parent.insertAfter(this, e3), this;
    }
    assign() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      for (let t3 in e3) this[t3] = e3[t3];
      return this;
    }
    before(e3) {
      return this.parent.insertBefore(this, e3), this;
    }
    cleanRaws(e3) {
      delete this.raws.before, delete this.raws.after, e3 || delete this.raws.between;
    }
    clone() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = l(this);
      for (let r3 in e3) t3[r3] = e3[r3];
      return t3;
    }
    cloneAfter() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = this.clone(e3);
      return this.parent.insertAfter(this, t3), t3;
    }
    cloneBefore() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = this.clone(e3);
      return this.parent.insertBefore(this, t3), t3;
    }
    error(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      if (this.source) {
        let { end: r3, start: n3 } = this.rangeBy(t3);
        return this.source.input.error(e3, { column: n3.column, line: n3.line }, { column: r3.column, line: r3.line }, t3);
      }
      return new i2(e3);
    }
    getProxyProcessor() {
      return { get: (e3, t3) => "proxyOf" === t3 ? e3 : "root" === t3 ? () => e3.root().toProxy() : e3[t3], set: (e3, t3, r3) => (e3[t3] === r3 || (e3[t3] = r3, "prop" !== t3 && "value" !== t3 && "name" !== t3 && "params" !== t3 && "important" !== t3 && "text" !== t3 || e3.markDirty()), true) };
    }
    markDirty() {
      if (this[n2]) {
        this[n2] = false;
        let e3 = this;
        for (; e3 = e3.parent; ) e3[n2] = false;
      }
    }
    next() {
      if (!this.parent) return;
      let e3 = this.parent.index(this);
      return this.parent.nodes[e3 + 1];
    }
    positionBy(e3, t3) {
      let r3 = this.source.start;
      if (e3.index) r3 = this.positionInside(e3.index, t3);
      else if (e3.word) {
        let n3 = (t3 = this.toString()).indexOf(e3.word);
        -1 !== n3 && (r3 = this.positionInside(n3, t3));
      }
      return r3;
    }
    positionInside(e3, t3) {
      let r3 = t3 || this.toString(), n3 = this.source.start.column, s3 = this.source.start.line;
      for (let t4 = 0; t4 < e3; t4++) "\n" === r3[t4] ? (n3 = 1, s3 += 1) : n3 += 1;
      return { column: n3, line: s3 };
    }
    prev() {
      if (!this.parent) return;
      let e3 = this.parent.index(this);
      return this.parent.nodes[e3 - 1];
    }
    rangeBy(e3) {
      let t3 = { column: this.source.start.column, line: this.source.start.line }, r3 = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: t3.column + 1, line: t3.line };
      if (e3.word) {
        let n3 = this.toString(), s3 = n3.indexOf(e3.word);
        -1 !== s3 && (t3 = this.positionInside(s3, n3), r3 = this.positionInside(s3 + e3.word.length, n3));
      } else e3.start ? t3 = { column: e3.start.column, line: e3.start.line } : e3.index && (t3 = this.positionInside(e3.index)), e3.end ? r3 = { column: e3.end.column, line: e3.end.line } : e3.endIndex ? r3 = this.positionInside(e3.endIndex) : e3.index && (r3 = this.positionInside(e3.index + 1));
      return (r3.line < t3.line || r3.line === t3.line && r3.column <= t3.column) && (r3 = { column: t3.column + 1, line: t3.line }), { end: r3, start: t3 };
    }
    raw(e3, t3) {
      return new o2().raw(this, e3, t3);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith() {
      if (this.parent) {
        let n3 = this, s3 = false;
        for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
        for (let e4 of t3) e4 === this ? s3 = true : s3 ? (this.parent.insertAfter(n3, e4), n3 = e4) : this.parent.insertBefore(n3, e4);
        s3 || this.remove();
      }
      return this;
    }
    root() {
      let e3 = this;
      for (; e3.parent && "document" !== e3.parent.type; ) e3 = e3.parent;
      return e3;
    }
    toJSON(e3, t3) {
      let r3 = {}, n3 = null == t3;
      t3 = t3 || /* @__PURE__ */ new Map();
      let s3 = 0;
      for (let e4 in this) {
        if (!Object.prototype.hasOwnProperty.call(this, e4)) continue;
        if ("parent" === e4 || "proxyCache" === e4) continue;
        let n4 = this[e4];
        if (Array.isArray(n4)) r3[e4] = n4.map((e5) => "object" == typeof e5 && e5.toJSON ? e5.toJSON(null, t3) : e5);
        else if ("object" == typeof n4 && n4.toJSON) r3[e4] = n4.toJSON(null, t3);
        else if ("source" === e4) {
          let i3 = t3.get(n4.input);
          null == i3 && (i3 = s3, t3.set(n4.input, s3), s3++), r3[e4] = { end: n4.end, inputId: i3, start: n4.start };
        } else r3[e4] = n4;
      }
      return n3 && (r3.inputs = [...t3.keys()].map((e4) => e4.toJSON())), r3;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a2;
      e3.stringify && (e3 = e3.stringify);
      let t3 = "";
      return e3(this, (e4) => {
        t3 += e4;
      }), t3;
    }
    warn(e3, t3, r3) {
      let n3 = { node: this };
      for (let e4 in r3) n3[e4] = r3[e4];
      return e3.warn(t3, n3);
    }
    get proxyOf() {
      return this;
    }
  }
  e2.exports = c, c.default = c;
}, (e2, t2, r2) => {
  let n2 = r2(146);
  function s2(e3, t3) {
    new n2(t3).stringify(e3);
  }
  e2.exports = s2, s2.default = s2;
}, (e2, t2, r2) => {
  let { SourceMapConsumer: n2, SourceMapGenerator: s2 } = r2(149), { fileURLToPath: i2, pathToFileURL: o2 } = r2(318), { isAbsolute: a2, resolve: l } = r2(150), { nanoid: c } = r2(319), u = r2(317), p = r2(87), d = r2(151), f = Symbol("fromOffsetCache"), h = Boolean(n2 && s2), m = Boolean(l && a2);
  class y {
    constructor(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      if (null == e3 || "object" == typeof e3 && !e3.toString) throw new Error(`PostCSS received ${e3} instead of CSS string`);
      if (this.css = e3.toString(), "\uFEFF" === this.css[0] || "" === this.css[0] ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, t3.from && (!m || /^\w+:\/\//.test(t3.from) || a2(t3.from) ? this.file = t3.from : this.file = l(t3.from)), m && h) {
        let e4 = new d(this.css, t3);
        if (e4.text) {
          this.map = e4;
          let t4 = e4.consumer().file;
          !this.file && t4 && (this.file = this.mapResolve(t4));
        }
      }
      this.file || (this.id = "<input css " + c(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(e3, t3, r3) {
      let n3, s3, i3, a3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
      if (t3 && "object" == typeof t3) {
        let e4 = t3, n4 = r3;
        if ("number" == typeof e4.offset) {
          let n5 = this.fromOffset(e4.offset);
          t3 = n5.line, r3 = n5.col;
        } else t3 = e4.line, r3 = e4.column;
        if ("number" == typeof n4.offset) {
          let e5 = this.fromOffset(n4.offset);
          s3 = e5.line, i3 = e5.col;
        } else s3 = n4.line, i3 = n4.column;
      } else if (!r3) {
        let e4 = this.fromOffset(t3);
        t3 = e4.line, r3 = e4.col;
      }
      let l2 = this.origin(t3, r3, s3, i3);
      return n3 = l2 ? new p(e3, void 0 === l2.endLine ? l2.line : { column: l2.column, line: l2.line }, void 0 === l2.endLine ? l2.column : { column: l2.endColumn, line: l2.endLine }, l2.source, l2.file, a3.plugin) : new p(e3, void 0 === s3 ? t3 : { column: r3, line: t3 }, void 0 === s3 ? r3 : { column: i3, line: s3 }, this.css, this.file, a3.plugin), n3.input = { column: r3, endColumn: i3, endLine: s3, line: t3, source: this.css }, this.file && (o2 && (n3.input.url = o2(this.file).toString()), n3.input.file = this.file), n3;
    }
    fromOffset(e3) {
      let t3, r3;
      if (this[f]) r3 = this[f];
      else {
        let e4 = this.css.split("\n");
        r3 = new Array(e4.length);
        let t4 = 0;
        for (let n4 = 0, s3 = e4.length; n4 < s3; n4++) r3[n4] = t4, t4 += e4[n4].length + 1;
        this[f] = r3;
      }
      t3 = r3[r3.length - 1];
      let n3 = 0;
      if (e3 >= t3) n3 = r3.length - 1;
      else {
        let t4, s3 = r3.length - 2;
        for (; n3 < s3; ) if (t4 = n3 + (s3 - n3 >> 1), e3 < r3[t4]) s3 = t4 - 1;
        else {
          if (!(e3 >= r3[t4 + 1])) {
            n3 = t4;
            break;
          }
          n3 = t4 + 1;
        }
      }
      return { col: e3 - r3[n3] + 1, line: n3 + 1 };
    }
    mapResolve(e3) {
      return /^\w+:\/\//.test(e3) ? e3 : l(this.map.consumer().sourceRoot || this.map.root || ".", e3);
    }
    origin(e3, t3, r3, n3) {
      if (!this.map) return false;
      let s3, l2, c2 = this.map.consumer(), u2 = c2.originalPositionFor({ column: t3, line: e3 });
      if (!u2.source) return false;
      "number" == typeof r3 && (s3 = c2.originalPositionFor({ column: n3, line: r3 })), l2 = a2(u2.source) ? o2(u2.source) : new URL(u2.source, this.map.consumer().sourceRoot || o2(this.map.mapFile));
      let p2 = { column: u2.column, endColumn: s3 && s3.column, endLine: s3 && s3.line, line: u2.line, url: l2.toString() };
      if ("file:" === l2.protocol) {
        if (!i2) throw new Error("file: protocol is not available in this PostCSS build");
        p2.file = i2(l2);
      }
      let d2 = c2.sourceContentFor(u2.source);
      return d2 && (p2.source = d2), p2;
    }
    toJSON() {
      let e3 = {};
      for (let t3 of ["hasBOM", "css", "file", "id"]) null != this[t3] && (e3[t3] = this[t3]);
      return this.map && (e3.map = { ...this.map }, e3.map.consumerCache && (e3.map.consumerCache = void 0)), e3;
    }
    get from() {
      return this.file || this.id;
    }
  }
  e2.exports = y, y.default = y, u && u.registerInput && u.registerInput(y);
}, (e2, t2, r2) => {
  let n2 = r2(53);
  class s2 extends n2 {
    constructor(e3) {
      super(e3), this.type = "comment";
    }
  }
  e2.exports = s2, s2.default = s2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.explode = d, t2.isExplodedVisitor = p, t2.merge = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], r3 = arguments.length > 2 ? arguments[2] : void 0;
    const n3 = {};
    for (let s3 = 0; s3 < e3.length; s3++) {
      const i3 = d(e3[s3]), o3 = t3[s3];
      let a3 = i3;
      (o3 || r3) && (a3 = m(a3, o3, r3)), v(n3, a3);
      for (const e4 of Object.keys(i3)) {
        if (b(e4)) continue;
        let t4 = i3[e4];
        (o3 || r3) && (t4 = m(t4, o3, r3)), v(n3[e4] || (n3[e4] = {}), t4);
      }
    }
    return n3;
  }, t2.verify = f;
  var n2 = r2(162), s2 = r2(163), i2 = r2(0);
  const { DEPRECATED_KEYS: o2, DEPRECATED_ALIASES: a2, FLIPPED_ALIAS_KEYS: l, TYPES: c, __internal__deprecationWarning: u } = i2;
  function p(e3) {
    return null == e3 ? void 0 : e3._exploded;
  }
  function d(e3) {
    if (p(e3)) return e3;
    e3._exploded = true;
    for (const t3 of Object.keys(e3)) {
      if (b(t3)) continue;
      const r3 = t3.split("|");
      if (1 === r3.length) continue;
      const n3 = e3[t3];
      delete e3[t3];
      for (const t4 of r3) e3[t4] = n3;
    }
    f(e3), delete e3.__esModule, function(e4) {
      for (const t3 of Object.keys(e4)) {
        if (b(t3)) continue;
        const r3 = e4[t3];
        "function" == typeof r3 && (e4[t3] = { enter: r3 });
      }
    }(e3), y(e3);
    for (const t3 of Object.keys(e3)) {
      if (b(t3)) continue;
      if (!(t3 in n2)) continue;
      const r3 = e3[t3];
      for (const e4 of Object.keys(r3)) r3[e4] = g(t3, r3[e4]);
      delete e3[t3];
      const s3 = n2[t3];
      if (null !== s3) for (const t4 of s3) e3[t4] ? v(e3[t4], r3) : e3[t4] = r3;
      else v(e3, r3);
    }
    for (const t3 of Object.keys(e3)) {
      if (b(t3)) continue;
      let r3 = l[t3];
      if (t3 in o2) {
        const e4 = o2[t3];
        u(t3, e4, "Visitor "), r3 = [e4];
      } else if (t3 in a2) {
        const e4 = a2[t3];
        u(t3, e4, "Visitor "), r3 = l[e4];
      }
      if (!r3) continue;
      const n3 = e3[t3];
      delete e3[t3];
      for (const t4 of r3) {
        const r4 = e3[t4];
        r4 ? v(r4, n3) : e3[t4] = Object.assign({}, n3);
      }
    }
    for (const t3 of Object.keys(e3)) b(t3) || y(e3[t3]);
    return e3;
  }
  function f(e3) {
    if (!e3._verified) {
      if ("function" == typeof e3) throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
      for (const t3 of Object.keys(e3)) {
        if ("enter" !== t3 && "exit" !== t3 || h(t3, e3[t3]), b(t3)) continue;
        if (c.indexOf(t3) < 0) throw new Error(`You gave us a visitor for the node type ${t3} but it's not a valid type`);
        const r3 = e3[t3];
        if ("object" == typeof r3) for (const e4 of Object.keys(r3)) {
          if ("enter" !== e4 && "exit" !== e4) throw new Error(`You passed \`traverse()\` a visitor object with the property ${t3} that has the invalid property ${e4}`);
          h(`${t3}.${e4}`, r3[e4]);
        }
      }
      e3._verified = true;
    }
  }
  function h(e3, t3) {
    const r3 = [].concat(t3);
    for (const t4 of r3) if ("function" != typeof t4) throw new TypeError(`Non-function found defined in ${e3} with type ${typeof t4}`);
  }
  function m(e3, t3, r3) {
    const n3 = {};
    for (const s3 of ["enter", "exit"]) {
      let i3 = e3[s3];
      Array.isArray(i3) && (i3 = i3.map(function(e4) {
        let n4 = e4;
        return t3 && (n4 = function(r4) {
          e4.call(t3, r4, t3);
        }), r3 && (n4 = r3(null == t3 ? void 0 : t3.key, s3, n4)), n4 !== e4 && (n4.toString = () => e4.toString()), n4;
      }), n3[s3] = i3);
    }
    return n3;
  }
  function y(e3) {
    e3.enter && !Array.isArray(e3.enter) && (e3.enter = [e3.enter]), e3.exit && !Array.isArray(e3.exit) && (e3.exit = [e3.exit]);
  }
  function g(e3, t3) {
    const r3 = s2[`is${e3}`], n3 = function(e4) {
      if (r3.call(e4)) return t3.apply(this, arguments);
    };
    return n3.toString = () => t3.toString(), n3;
  }
  function b(e3) {
    return "_" === e3[0] || "enter" === e3 || "exit" === e3 || "shouldSkip" === e3 || "denylist" === e3 || "noScope" === e3 || "skipKeys" === e3 || "blacklist" === e3;
  }
  function v(e3, t3) {
    for (const r3 of ["enter", "exit"]) t3[r3] && (e3[r3] = [].concat(e3[r3] || [], t3[r3]));
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if (r2.has(e3)) return;
    r2.add(e3);
    const { internal: n2, trace: s2 } = function(e4, t4) {
      const { stackTraceLimit: r3, prepareStackTrace: n3 } = Error;
      let s3;
      if (Error.stackTraceLimit = 4, Error.prepareStackTrace = function(e5, t5) {
        s3 = t5;
      }, new Error().stack, Error.stackTraceLimit = r3, Error.prepareStackTrace = n3, !s3) return { internal: false, trace: "" };
      const i2 = s3.slice(2, 4);
      return { internal: /[\\/]@babel[\\/]/.test(i2[1].getFileName()), trace: i2.map((e5) => `    at ${e5}`).join("\n") };
    }();
  };
  const r2 = /* @__PURE__ */ new Set();
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "isIdentifierChar", { enumerable: true, get: function() {
    return n2.isIdentifierChar;
  } }), Object.defineProperty(t2, "isIdentifierName", { enumerable: true, get: function() {
    return n2.isIdentifierName;
  } }), Object.defineProperty(t2, "isIdentifierStart", { enumerable: true, get: function() {
    return n2.isIdentifierStart;
  } }), Object.defineProperty(t2, "isKeyword", { enumerable: true, get: function() {
    return s2.isKeyword;
  } }), Object.defineProperty(t2, "isReservedWord", { enumerable: true, get: function() {
    return s2.isReservedWord;
  } }), Object.defineProperty(t2, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
    return s2.isStrictBindOnlyReservedWord;
  } }), Object.defineProperty(t2, "isStrictBindReservedWord", { enumerable: true, get: function() {
    return s2.isStrictBindReservedWord;
  } }), Object.defineProperty(t2, "isStrictReservedWord", { enumerable: true, get: function() {
    return s2.isStrictReservedWord;
  } });
  var n2 = r2(353), s2 = r2(354);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = s2;
  var n2 = r2(2);
  function s2(e3, t3, r3, i2) {
    const o2 = [].concat(e3), a2 = /* @__PURE__ */ Object.create(null);
    for (; o2.length; ) {
      const e4 = o2.shift();
      if (!e4) continue;
      if (i2 && ((0, n2.isAssignmentExpression)(e4) || (0, n2.isUnaryExpression)(e4))) continue;
      const l = s2.keys[e4.type];
      if ((0, n2.isIdentifier)(e4)) t3 ? (a2[e4.name] = a2[e4.name] || []).push(e4) : a2[e4.name] = e4;
      else if (!(0, n2.isExportDeclaration)(e4) || (0, n2.isExportAllDeclaration)(e4)) {
        if (r3) {
          if ((0, n2.isFunctionDeclaration)(e4)) {
            o2.push(e4.id);
            continue;
          }
          if ((0, n2.isFunctionExpression)(e4)) continue;
        }
        if (l) for (let t4 = 0; t4 < l.length; t4++) {
          const r4 = e4[l[t4]];
          r4 && (Array.isArray(r4) ? o2.push(...r4) : o2.push(r4));
        }
      } else (0, n2.isDeclaration)(e4.declaration) && o2.push(e4.declaration);
    }
    return a2;
  }
  s2.keys = { DeclareClass: ["id"], DeclareFunction: ["id"], DeclareModule: ["id"], DeclareVariable: ["id"], DeclareInterface: ["id"], DeclareTypeAlias: ["id"], DeclareOpaqueType: ["id"], InterfaceDeclaration: ["id"], TypeAlias: ["id"], OpaqueType: ["id"], CatchClause: ["param"], LabeledStatement: ["label"], UnaryExpression: ["argument"], AssignmentExpression: ["left"], ImportSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportDefaultSpecifier: ["local"], ImportDeclaration: ["specifiers"], ExportSpecifier: ["exported"], ExportNamespaceSpecifier: ["exported"], ExportDefaultSpecifier: ["exported"], FunctionDeclaration: ["id", "params"], FunctionExpression: ["id", "params"], ArrowFunctionExpression: ["params"], ObjectMethod: ["params"], ClassMethod: ["params"], ClassPrivateMethod: ["params"], ForInStatement: ["left"], ForOfStatement: ["left"], ClassDeclaration: ["id"], ClassExpression: ["id"], RestElement: ["argument"], UpdateExpression: ["argument"], ObjectProperty: ["value"], AssignmentPattern: ["left"], ArrayPattern: ["elements"], ObjectPattern: ["properties"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id"] };
}, (e2) => {
  e2.exports = function() {
    return function() {
    };
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    if (!e3.isExportDeclaration() || e3.isExportAllDeclaration()) throw new Error("Only default and named export declarations can be split.");
    if (e3.isExportDefaultDeclaration()) {
      const t4 = e3.get("declaration"), r4 = t4.isFunctionDeclaration() || t4.isClassDeclaration(), n4 = t4.isFunctionExpression() || t4.isClassExpression(), u2 = t4.isScope() ? t4.scope.parent : t4.scope;
      let p = t4.node.id, d = false;
      p ? n4 && u2.hasBinding(p.name) && (d = true, p = u2.generateUidIdentifier(p.name)) : (d = true, p = u2.generateUidIdentifier("default"), (r4 || n4) && (t4.node.id = s2(p)));
      const f = r4 ? t4.node : l("var", [c(s2(p), t4.node)]), h = i2(null, [o2(s2(p), a2("default"))]);
      return e3.insertAfter(h), e3.replaceWith(f), d && u2.registerDeclaration(e3), e3;
    }
    if (e3.get("specifiers").length > 0) throw new Error("It doesn't make sense to split exported specifiers.");
    const t3 = e3.get("declaration"), r3 = t3.getOuterBindingIdentifiers(), n3 = Object.keys(r3).map((e4) => o2(a2(e4), a2(e4))), u = i2(null, n3);
    return e3.insertAfter(u), e3.replaceWith(t3.node), e3;
  };
  var n2 = r2(0);
  const { cloneNode: s2, exportNamedDeclaration: i2, exportSpecifier: o2, identifier: a2, variableDeclaration: l, variableDeclarator: c } = n2;
}, (e2, t2, r2) => {
  var n2 = r2(187), s2 = Object;
  e2.exports = function(e3) {
    return s2(n2(e3));
  };
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(106), i2 = "__core-js_shared__", o2 = n2[i2] || s2(i2, {});
  e2.exports = o2;
}, (e2, t2, r2) => {
  var n2 = r2(20), s2 = String, i2 = TypeError;
  e2.exports = function(e3) {
    if (n2(e3)) return e3;
    throw new i2(s2(e3) + " is not an object");
  };
}, (e2, t2, r2) => {
  var n2 = r2(104), s2 = Function.prototype.call;
  e2.exports = n2 ? s2.bind(s2) : function() {
    return s2.apply(s2, arguments);
  };
}, (e2, t2, r2) => {
  var n2 = r2(19), s2 = 0, i2 = Math.random(), o2 = n2(1 .toString);
  e2.exports = function(e3) {
    return "Symbol(" + (void 0 === e3 ? "" : e3) + ")_" + o2(++s2 + i2, 36);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "buildDynamicImport", { enumerable: true, get: function() {
    return u.buildDynamicImport;
  } }), t2.buildNamespaceInitStatements = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : c.wrapReference;
    var i3;
    const o3 = [], a3 = b(t3.name);
    for (const e4 of t3.importsNamespace) e4 !== t3.name && o3.push(s2.template.statement`var NAME = SOURCE;`({ NAME: e4, SOURCE: h(a3) }));
    const l2 = null != (i3 = n3(a3, t3.wrap)) ? i3 : a3;
    r3 && o3.push(...A(e3, t3, true, n3));
    for (const r4 of t3.reexportNamespace) o3.push((s2.types.isIdentifier(l2) ? s2.template.statement`EXPORTS.NAME = NAMESPACE;` : s2.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({ EXPORTS: e3.exportName, NAME: r4, NAMESPACE: h(l2) }));
    if (t3.reexportAll) {
      const n4 = function(e4, t4, r4) {
        return (r4 ? s2.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : s2.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({ NAMESPACE: t4, EXPORTS: e4.exportName, VERIFY_NAME_LIST: e4.exportNameListName ? s2.template`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({ EXPORTS_LIST: e4.exportNameListName }) : null });
      }(e3, h(l2), r3);
      n4.loc = t3.reexportAll.loc, o3.push(n4);
    }
    return o3;
  }, t2.ensureStatementsHoisted = function(e3) {
    e3.forEach((e4) => {
      e4._blockHoist = 3;
    });
  }, Object.defineProperty(t2, "getModuleName", { enumerable: true, get: function() {
    return p.default;
  } }), Object.defineProperty(t2, "hasExports", { enumerable: true, get: function() {
    return l.hasExports;
  } }), Object.defineProperty(t2, "isModule", { enumerable: true, get: function() {
    return i2.isModule;
  } }), Object.defineProperty(t2, "isSideEffectImport", { enumerable: true, get: function() {
    return l.isSideEffectImport;
  } }), t2.rewriteModuleStatementsAndPrepareHeader = function(e3, t3) {
    let { exportName: r3, strict: u2, allowTopLevelThis: p2, strictMode: d2, noInterop: f2, importInterop: h2 = f2 ? "none" : "babel", lazy: g2, getWrapperPayload: v2 = c.toGetWrapperPayload(null != g2 && g2), wrapReference: E2 = c.wrapReference, esNamespaceOnly: S2, filename: P2, constantReexports: C2 = arguments[1].loose, enumerableModuleMeta: I = arguments[1].loose, noIncompleteNsImportDetection: _ } = t3;
    (0, l.validateImportInteropOption)(h2), n2((0, i2.isModule)(e3), "Cannot process module statements in a script"), e3.node.sourceType = "script";
    const k = (0, l.default)(e3, r3, { importInterop: h2, initializeReexports: C2, getWrapperPayload: v2, esNamespaceOnly: S2, filename: P2 });
    if (p2 || (0, o2.default)(e3), (0, a2.default)(e3, k, E2), false !== d2) {
      const t4 = e3.node.directives.some((e4) => "use strict" === e4.value.value);
      t4 || e3.unshiftContainer("directives", m(y("use strict")));
    }
    const N = [];
    (0, l.hasExports)(k) && !u2 && N.push(function(e4) {
      return (arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? s2.template.statement`
        EXPORTS.__esModule = true;
      ` : s2.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({ EXPORTS: e4.exportName });
    }(k, I));
    const D = function(e4, t4) {
      const r4 = /* @__PURE__ */ Object.create(null);
      for (const e5 of t4.local.values()) for (const t5 of e5.names) r4[t5] = true;
      let n3 = false;
      for (const e5 of t4.source.values()) {
        for (const t5 of e5.reexports.keys()) r4[t5] = true;
        for (const t5 of e5.reexportNamespace) r4[t5] = true;
        n3 = n3 || !!e5.reexportAll;
      }
      if (!n3 || 0 === Object.keys(r4).length) return null;
      const s3 = e4.scope.generateUidIdentifier("exportNames");
      return delete r4.default, { name: s3.name, statement: T("var", [w(s3, x(r4))]) };
    }(e3, k);
    return D && (k.exportNameListName = D.name, N.push(D.statement)), N.push(...function(e4, t4, r4) {
      let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], s3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
      const i3 = [];
      for (const [e5, r5] of t4.local) if ("import" === r5.kind) ;
      else if ("hoisted" === r5.kind) i3.push([r5.names[0], O(t4, r5.names, b(e5))]);
      else if (!s3) for (const e6 of r5.names) i3.push([e6, null]);
      for (const e5 of t4.source.values()) {
        if (!n3) {
          const n4 = A(t4, e5, false, r4), s4 = [...e5.reexports.keys()];
          for (let e6 = 0; e6 < n4.length; e6++) i3.push([s4[e6], n4[e6]]);
        }
        if (!s3) for (const t5 of e5.reexportNamespace) i3.push([t5, null]);
      }
      i3.sort((e5, t5) => {
        let [r5] = e5, [n4] = t5;
        return r5 < n4 ? -1 : n4 < r5 ? 1 : 0;
      });
      const o3 = [];
      if (s3) for (const [, e5] of i3) o3.push(e5);
      else {
        const r5 = 100;
        for (let n4 = 0; n4 < i3.length; n4 += r5) {
          let s4 = [];
          for (let a3 = 0; a3 < r5 && n4 + a3 < i3.length; a3++) {
            const [r6, l2] = i3[n4 + a3];
            null !== l2 ? (s4.length > 0 && (o3.push(O(t4, s4, e4.scope.buildUndefinedNode())), s4 = []), o3.push(l2)) : s4.push(r6);
          }
          s4.length > 0 && o3.push(O(t4, s4, e4.scope.buildUndefinedNode()));
        }
      }
      return o3;
    }(e3, k, E2, C2, _)), { meta: k, headers: N };
  }, Object.defineProperty(t2, "rewriteThis", { enumerable: true, get: function() {
    return o2.default;
  } }), t2.wrapInterop = function(e3, t3, r3) {
    if ("none" === r3) return null;
    if ("node-namespace" === r3) return f(e3.hub.addHelper("interopRequireWildcard"), [t3, d(true)]);
    if ("node-default" === r3) return null;
    let n3;
    if ("default" === r3) n3 = "interopRequireDefault";
    else {
      if ("namespace" !== r3) throw new Error(`Unknown interop: ${r3}`);
      n3 = "interopRequireWildcard";
    }
    return f(e3.hub.addHelper(n3), [t3]);
  };
  var n2 = r2(25), s2 = r2(1), i2 = r2(93), o2 = r2(449), a2 = r2(450), l = r2(252), c = r2(451), u = r2(330), p = r2(452);
  const { booleanLiteral: d, callExpression: f, cloneNode: h, directive: m, directiveLiteral: y, expressionStatement: g, identifier: b, isIdentifier: v, memberExpression: E, stringLiteral: S, valueToNode: x, variableDeclaration: T, variableDeclarator: w } = s2.types;
  t2.getDynamicImportSource = r2(330).getDynamicImportSource;
  const P = { constant: s2.template.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`, constantComputed: s2.template.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`, spec: s2.template.statement`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() {
        return NAMESPACE_IMPORT;
      },
    });
    ` };
  function A(e3, t3, r3, n3) {
    var s3;
    let i3 = b(t3.name);
    i3 = null != (s3 = n3(i3, t3.wrap)) ? s3 : i3;
    const { stringSpecifiers: o3 } = e3;
    return Array.from(t3.reexports, (n4) => {
      let [s4, a3] = n4, l2 = h(i3);
      "default" === a3 && "node-default" === t3.interop || (l2 = o3.has(a3) ? E(l2, S(a3), true) : E(l2, b(a3)));
      const c2 = { EXPORTS: e3.exportName, EXPORT_NAME: s4, NAMESPACE_IMPORT: l2 };
      return r3 || v(l2) ? o3.has(s4) ? P.constantComputed(c2) : P.constant(c2) : P.spec(c2);
    });
  }
  const C = { computed: s2.template.expression`EXPORTS["NAME"] = VALUE`, default: s2.template.expression`EXPORTS.NAME = VALUE`, define: s2.template.expression`Object.defineProperty(EXPORTS, "NAME", { enumerable:true, value: void 0, writable: true })["NAME"] = VALUE` };
  function O(e3, t3, r3) {
    const { stringSpecifiers: n3, exportName: s3 } = e3;
    return g(t3.reduce((e4, t4) => {
      const r4 = { EXPORTS: s3, NAME: t4, VALUE: e4 };
      return "__proto__" === t4 ? C.define(r4) : n3.has(t4) ? C.computed(r4) : C.default(r4);
    }, r3));
  }
}, (e2, t2, r2) => {
  var n2 = r2(70);
  e2.exports = function() {
    return n2() && !!Symbol.toStringTag;
  };
}, (e2) => {
  e2.exports = function() {
    if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return false;
    if ("symbol" == typeof Symbol.iterator) return true;
    var e3 = {}, t2 = Symbol("test"), r2 = Object(t2);
    if ("string" == typeof t2) return false;
    if ("[object Symbol]" !== Object.prototype.toString.call(t2)) return false;
    if ("[object Symbol]" !== Object.prototype.toString.call(r2)) return false;
    for (t2 in e3[t2] = 42, e3) return false;
    if ("function" == typeof Object.keys && 0 !== Object.keys(e3).length) return false;
    if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e3).length) return false;
    var n2 = Object.getOwnPropertySymbols(e3);
    if (1 !== n2.length || n2[0] !== t2) return false;
    if (!Object.prototype.propertyIsEnumerable.call(e3, t2)) return false;
    if ("function" == typeof Object.getOwnPropertyDescriptor) {
      var s2 = Object.getOwnPropertyDescriptor(e3, t2);
      if (42 !== s2.value || true !== s2.enumerable) return false;
    }
    return true;
  };
}, (e2, t2, r2) => {
  var n2 = r2(232);
  e2.exports = Function.prototype.bind || n2;
}, (e2, t2, r2) => {
  var n2 = r2(22)("%Object.defineProperty%", true), s2 = function() {
    if (n2) try {
      return n2({}, "a", { value: 1 }), true;
    } catch (e3) {
      return false;
    }
    return false;
  };
  s2.hasArrayLengthDefineBug = function() {
    if (!s2()) return null;
    try {
      return 1 !== n2([], "length", { value: 1 }).length;
    } catch (e3) {
      return true;
    }
  }, e2.exports = s2;
}, (e2, t2, r2) => {
  var n2 = r2(22)("%Object.getOwnPropertyDescriptor%", true);
  if (n2) try {
    n2([], "length");
  } catch (e3) {
    n2 = null;
  }
  e2.exports = n2;
}, (e2, t2, r2) => {
  var n2 = r2(125);
  e2.exports = function() {
    return "function" == typeof Object.is ? Object.is : n2;
  };
}, (e2) => {
  const t2 = Object.freeze({ loose: true }), r2 = Object.freeze({});
  e2.exports = (e3) => e3 ? "object" != typeof e3 ? t2 : e3 : r2;
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = (e3, t3, r3) => {
    const s2 = new n2(e3, r3), i2 = new n2(t3, r3);
    return s2.compare(i2) || s2.compareBuild(i2);
  };
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => n2(e3, t3, r3) < 0;
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => n2(e3, t3, r3) >= 0;
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => n2(e3, t3, r3) <= 0;
}, (e2, t2, r2) => {
  const n2 = r2(3), s2 = r2(50), { ANY: i2 } = s2, o2 = r2(8), a2 = r2(51), l = r2(49), c = r2(77), u = r2(79), p = r2(78);
  e2.exports = (e3, t3, r3, d) => {
    let f, h, m, y, g;
    switch (e3 = new n2(e3, d), t3 = new o2(t3, d), r3) {
      case ">":
        f = l, h = u, m = c, y = ">", g = ">=";
        break;
      case "<":
        f = c, h = p, m = l, y = "<", g = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (a2(e3, t3, d)) return false;
    for (let r4 = 0; r4 < t3.set.length; ++r4) {
      const n3 = t3.set[r4];
      let o3 = null, a3 = null;
      if (n3.forEach((e4) => {
        e4.semver === i2 && (e4 = new s2(">=0.0.0")), o3 = o3 || e4, a3 = a3 || e4, f(e4.semver, o3.semver, d) ? o3 = e4 : m(e4.semver, a3.semver, d) && (a3 = e4);
      }), o3.operator === y || o3.operator === g) return false;
      if ((!a3.operator || a3.operator === y) && h(e3, a3.semver)) return false;
      if (a3.operator === g && m(e3, a3.semver)) return false;
    }
    return true;
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ROOT_CONFIG_FILENAMES = void 0, t2.findConfigUpwards = function(e3) {
    return null;
  }, t2.findPackageData = function* (e3) {
    return { filepath: e3, directories: [], pkg: null, isPackage: false };
  }, t2.findRelativeConfig = function* (e3, t3, r2) {
    return { config: null, ignore: null };
  }, t2.findRootConfig = function* (e3, t3, r2) {
    return null;
  }, t2.loadConfig = function* (e3, t3, r2, n2) {
    throw new Error(`Cannot load ${e3} relative to ${t3} in a browser`);
  }, t2.loadPlugin = function(e3, t3) {
    throw new Error(`Cannot load plugin ${e3} relative to ${t3} in a browser`);
  }, t2.loadPreset = function(e3, t3) {
    throw new Error(`Cannot load preset ${e3} relative to ${t3} in a browser`);
  }, t2.resolvePlugin = function(e3, t3) {
    return null;
  }, t2.resolvePreset = function(e3, t3) {
    return null;
  }, t2.resolveShowConfigPath = function* (e3) {
    return null;
  }, t2.ROOT_CONFIG_FILENAMES = [];
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.createConfigItem = function(e3, t3, r3) {
    if (void 0 !== r3) (0, a2.beginHiddenCallStack)(d.errback)(e3, t3, r3);
    else {
      if ("function" != typeof t3) return f(e3, t3);
      (0, a2.beginHiddenCallStack)(d.errback)(e3, void 0, r3);
    }
  }, t2.createConfigItemAsync = function() {
    return (0, a2.beginHiddenCallStack)(d.async)(...arguments);
  }, t2.createConfigItemSync = f, Object.defineProperty(t2, "default", { enumerable: true, get: function() {
    return s2.default;
  } }), t2.loadOptions = function(e3, t3) {
    if (void 0 !== t3) (0, a2.beginHiddenCallStack)(u.errback)(e3, t3);
    else {
      if ("function" != typeof e3) return p(e3);
      (0, a2.beginHiddenCallStack)(u.errback)(void 0, e3);
    }
  }, t2.loadOptionsAsync = function() {
    return (0, a2.beginHiddenCallStack)(u.async)(...arguments);
  }, t2.loadOptionsSync = p, t2.loadPartialConfig = function(e3, t3) {
    if (void 0 !== t3) (0, a2.beginHiddenCallStack)(l.errback)(e3, t3);
    else {
      if ("function" != typeof e3) return c(e3);
      (0, a2.beginHiddenCallStack)(l.errback)(void 0, e3);
    }
  }, t2.loadPartialConfigAsync = function() {
    return (0, a2.beginHiddenCallStack)(l.async)(...arguments);
  }, t2.loadPartialConfigSync = c;
  var s2 = r2(454), i2 = r2(294), o2 = r2(83), a2 = r2(39);
  const l = n2()(i2.loadPartialConfig);
  function c() {
    return (0, a2.beginHiddenCallStack)(l.sync)(...arguments);
  }
  const u = n2()(function* (e3) {
    var t3;
    const r3 = yield* (0, s2.default)(e3);
    return null != (t3 = null == r3 ? void 0 : r3.options) ? t3 : null;
  });
  function p() {
    return (0, a2.beginHiddenCallStack)(u.sync)(...arguments);
  }
  const d = n2()(o2.createConfigItem);
  function f() {
    return (0, a2.beginHiddenCallStack)(d.sync)(...arguments);
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(10);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.createConfigItem = function(e3) {
    let { dirname: t3 = ".", type: r3 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return function* () {
      return i2(yield* (0, s2.createDescriptor)(e3, n2().resolve(t3), { type: r3, alias: "programmatic item" }));
    }();
  }, t2.createItemFromDescriptor = i2, t2.getItemDescriptor = function(e3) {
    if (null != e3 && e3[o2]) return e3._descriptor;
  };
  var s2 = r2(279);
  function i2(e3) {
    return new a2(e3);
  }
  const o2 = Symbol.for("@babel/core@7 - ConfigItem");
  class a2 {
    constructor(e3) {
      this._descriptor = void 0, this[o2] = true, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.file = void 0, this._descriptor = e3, Object.defineProperty(this, "_descriptor", { enumerable: false }), Object.defineProperty(this, o2, { enumerable: false }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name = this._descriptor.name, this.file = this._descriptor.file ? { request: this._descriptor.file.request, resolved: this._descriptor.file.resolved } : void 0, Object.freeze(this);
    }
  }
  Object.freeze(a2.prototype);
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.assertSimpleType = h, t2.makeStrongCache = c, t2.makeStrongCacheSync = function(e3) {
    return o2(c(e3));
  }, t2.makeWeakCache = l, t2.makeWeakCacheSync = function(e3) {
    return o2(l(e3));
  };
  var s2 = r2(133), i2 = r2(134);
  const o2 = (e3) => n2()(e3).sync;
  function* a2() {
    return true;
  }
  function l(e3) {
    return u(WeakMap, e3);
  }
  function c(e3) {
    return u(Map, e3);
  }
  function u(e3, t3) {
    const r3 = new e3(), n3 = new e3(), o3 = new e3();
    return function* (e4, a3) {
      const l2 = yield* (0, s2.isAsync)(), c2 = l2 ? n3 : r3, u2 = yield* function* (e5, t4, r4, n4, i3) {
        const o4 = yield* p(t4, n4, i3);
        if (o4.valid) return o4;
        if (e5) {
          const e6 = yield* p(r4, n4, i3);
          if (e6.valid) return { valid: true, value: yield* (0, s2.waitFor)(e6.value.promise) };
        }
        return { valid: false, value: null };
      }(l2, c2, o3, e4, a3);
      if (u2.valid) return u2.value;
      const h2 = new f(a3), y = t3(e4, h2);
      let g, b;
      return b = (0, i2.isIterableIterator)(y) ? yield* (0, s2.onFirstPause)(y, () => {
        g = function(e5, t4, r4) {
          const n4 = new m();
          return d(t4, e5, r4, n4), n4;
        }(h2, o3, e4);
      }) : y, d(c2, h2, e4, b), g && (o3.delete(e4), g.release(b)), b;
    };
  }
  function* p(e3, t3, r3) {
    const n3 = e3.get(t3);
    if (n3) {
      for (const { value: e4, valid: t4 } of n3) if (yield* t4(r3)) return { valid: true, value: e4 };
    }
    return { valid: false, value: null };
  }
  function d(e3, t3, r3, n3) {
    t3.configured() || t3.forever();
    let s3 = e3.get(r3);
    switch (t3.deactivate(), t3.mode()) {
      case "forever":
        s3 = [{ value: n3, valid: a2 }], e3.set(r3, s3);
        break;
      case "invalidate":
        s3 = [{ value: n3, valid: t3.validator() }], e3.set(r3, s3);
        break;
      case "valid":
        s3 ? s3.push({ value: n3, valid: t3.validator() }) : (s3 = [{ value: n3, valid: t3.validator() }], e3.set(r3, s3));
    }
  }
  class f {
    constructor(e3) {
      this._active = true, this._never = false, this._forever = false, this._invalidate = false, this._configured = false, this._pairs = [], this._data = void 0, this._data = e3;
    }
    simple() {
      return function(e3) {
        function t3(t4) {
          if ("boolean" != typeof t4) return e3.using(() => h(t4()));
          t4 ? e3.forever() : e3.never();
        }
        return t3.forever = () => e3.forever(), t3.never = () => e3.never(), t3.using = (t4) => e3.using(() => h(t4())), t3.invalidate = (t4) => e3.invalidate(() => h(t4())), t3;
      }(this);
    }
    mode() {
      return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
    }
    forever() {
      if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never) throw new Error("Caching has already been configured with .never()");
      this._forever = true, this._configured = true;
    }
    never() {
      if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
      if (this._forever) throw new Error("Caching has already been configured with .forever()");
      this._never = true, this._configured = true;
    }
    using(e3) {
      if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never || this._forever) throw new Error("Caching has already been configured with .never or .forever()");
      this._configured = true;
      const t3 = e3(this._data), r3 = (0, s2.maybeAsync)(e3, "You appear to be using an async cache handler, but Babel has been called synchronously");
      return (0, s2.isThenable)(t3) ? t3.then((e4) => (this._pairs.push([e4, r3]), e4)) : (this._pairs.push([t3, r3]), t3);
    }
    invalidate(e3) {
      return this._invalidate = true, this.using(e3);
    }
    validator() {
      const e3 = this._pairs;
      return function* (t3) {
        for (const [r3, n3] of e3) if (r3 !== (yield* n3(t3))) return false;
        return true;
      };
    }
    deactivate() {
      this._active = false;
    }
    configured() {
      return this._configured;
    }
  }
  function h(e3) {
    if ((0, s2.isThenable)(e3)) throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");
    if (null != e3 && "string" != typeof e3 && "boolean" != typeof e3 && "number" != typeof e3) throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
    return e3;
  }
  class m {
    constructor() {
      this.released = false, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((e3) => {
        this._resolve = e3;
      });
    }
    release(e3) {
      this.released = true, this._resolve(e3);
    }
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.assumptionsNames = void 0, t2.checkNoUnwrappedItemOptionPairs = function(e3, t3, r3, n3) {
    if (0 === t3) return;
    const s3 = e3[t3 - 1], i3 = e3[t3];
    s3.file && void 0 === s3.options && "object" == typeof i3.value && (n3.message += `
- Maybe you meant to use
"${r3}s": [
  ["${s3.file.request}", ${JSON.stringify(i3.value, void 0, 2)}]
]
To be a valid ${r3}, its name and options should be wrapped in a pair of brackets`);
  }, t2.validate = function(e3, t3, r3) {
    try {
      return p({ type: "root", source: e3 }, t3);
    } catch (e4) {
      const t4 = new i2.default(e4.message, r3);
      throw e4.code && (t4.code = e4.code), t4;
    }
  };
  var n2 = r2(470), s2 = r2(293), i2 = r2(140);
  const o2 = { cwd: s2.assertString, root: s2.assertString, rootMode: s2.assertRootMode, configFile: s2.assertConfigFileSearch, caller: s2.assertCallerMetadata, filename: s2.assertString, filenameRelative: s2.assertString, code: s2.assertBoolean, ast: s2.assertBoolean, cloneInputAst: s2.assertBoolean, envName: s2.assertString }, a2 = { babelrc: s2.assertBoolean, babelrcRoots: s2.assertBabelrcSearch }, l = { extends: s2.assertString, ignore: s2.assertIgnoreList, only: s2.assertIgnoreList, targets: s2.assertTargets, browserslistConfigFile: s2.assertConfigFileSearch, browserslistEnv: s2.assertString }, c = { inputSourceMap: s2.assertInputSourceMap, presets: s2.assertPluginList, plugins: s2.assertPluginList, passPerPreset: s2.assertBoolean, assumptions: s2.assertAssumptions, env: function(e3, t3) {
    if ("env" === e3.parent.type) throw new Error(`${(0, s2.msg)(e3)} is not allowed inside of another .env block`);
    const r3 = e3.parent, n3 = (0, s2.assertObject)(e3, t3);
    if (n3) for (const t4 of Object.keys(n3)) {
      const i3 = (0, s2.assertObject)((0, s2.access)(e3, t4), n3[t4]);
      i3 && p({ type: "env", name: t4, parent: r3 }, i3);
    }
    return n3;
  }, overrides: function(e3, t3) {
    if ("env" === e3.parent.type) throw new Error(`${(0, s2.msg)(e3)} is not allowed inside an .env block`);
    if ("overrides" === e3.parent.type) throw new Error(`${(0, s2.msg)(e3)} is not allowed inside an .overrides block`);
    const r3 = e3.parent, n3 = (0, s2.assertArray)(e3, t3);
    if (n3) for (const [t4, i3] of n3.entries()) {
      const n4 = (0, s2.access)(e3, t4), o3 = (0, s2.assertObject)(n4, i3);
      if (!o3) throw new Error(`${(0, s2.msg)(n4)} must be an object`);
      p({ type: "overrides", index: t4, parent: r3 }, o3);
    }
    return n3;
  }, test: s2.assertConfigApplicableTest, include: s2.assertConfigApplicableTest, exclude: s2.assertConfigApplicableTest, retainLines: s2.assertBoolean, comments: s2.assertBoolean, shouldPrintComment: s2.assertFunction, compact: s2.assertCompact, minified: s2.assertBoolean, auxiliaryCommentBefore: s2.assertString, auxiliaryCommentAfter: s2.assertString, sourceType: s2.assertSourceType, wrapPluginVisitorMethod: s2.assertFunction, highlightCode: s2.assertBoolean, sourceMaps: s2.assertSourceMaps, sourceMap: s2.assertSourceMaps, sourceFileName: s2.assertString, sourceRoot: s2.assertString, parserOpts: s2.assertObject, generatorOpts: s2.assertObject };
  function u(e3) {
    return "root" === e3.type ? e3.source : u(e3.parent);
  }
  function p(e3, t3) {
    const r3 = u(e3);
    return function(e4) {
      if (f(e4, "sourceMap") && f(e4, "sourceMaps")) throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
    }(t3), Object.keys(t3).forEach((n3) => {
      const i3 = { type: "option", name: n3, parent: e3 };
      if ("preset" === r3 && l[n3]) throw new Error(`${(0, s2.msg)(i3)} is not allowed in preset options`);
      if ("arguments" !== r3 && o2[n3]) throw new Error(`${(0, s2.msg)(i3)} is only allowed in root programmatic options`);
      if ("arguments" !== r3 && "configfile" !== r3 && a2[n3]) {
        if ("babelrcfile" === r3 || "extendsfile" === r3) throw new Error(`${(0, s2.msg)(i3)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`);
        throw new Error(`${(0, s2.msg)(i3)} is only allowed in root programmatic options, or babel.config.js/config file options`);
      }
      (c[n3] || l[n3] || a2[n3] || o2[n3] || d)(i3, t3[n3]);
    }), t3;
  }
  function d(e3) {
    const t3 = e3.name;
    if (n2.default[t3]) {
      const { message: r3, version: i3 = 5 } = n2.default[t3];
      throw new Error(`Using removed Babel ${i3} option: ${(0, s2.msg)(e3)} - ${r3}`);
    }
    {
      const t4 = new Error(`Unknown option: ${(0, s2.msg)(e3)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
      throw t4.code = "BABEL_UNKNOWN_OPTION", t4;
    }
  }
  function f(e3, t3) {
    return Object.prototype.hasOwnProperty.call(e3, t3);
  }
  Object.assign(c, { getModuleId: s2.assertFunction, moduleRoot: s2.assertString, moduleIds: s2.assertBoolean, moduleId: s2.assertString }), t2.assumptionsNames = /* @__PURE__ */ new Set(["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"]);
}, (e2) => {
  var t2 = String.prototype.replace, r2 = /%20/g, n2 = "RFC3986";
  e2.exports = { default: n2, formatters: { RFC1738: function(e3) {
    return t2.call(e3, r2, "+");
  }, RFC3986: function(e3) {
    return String(e3);
  } }, RFC1738: "RFC1738", RFC3986: n2 };
}, (e2, t2, r2) => {
  let n2 = r2(316), s2 = r2(317);
  class i2 extends Error {
    constructor(e3, t3, r3, n3, s3, o2) {
      super(e3), this.name = "CssSyntaxError", this.reason = e3, s3 && (this.file = s3), n3 && (this.source = n3), o2 && (this.plugin = o2), void 0 !== t3 && void 0 !== r3 && ("number" == typeof t3 ? (this.line = t3, this.column = r3) : (this.line = t3.line, this.column = t3.column, this.endLine = r3.line, this.endColumn = r3.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, i2);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", void 0 !== this.line && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(e3) {
      if (!this.source) return "";
      let t3 = this.source;
      null == e3 && (e3 = n2.isColorSupported), s2 && e3 && (t3 = s2(t3));
      let r3, i3, o2 = t3.split(/\r?\n/), a2 = Math.max(this.line - 3, 0), l = Math.min(this.line + 2, o2.length), c = String(l).length;
      if (e3) {
        let { bold: e4, gray: t4, red: s3 } = n2.createColors(true);
        r3 = (t5) => e4(s3(t5)), i3 = (e5) => t4(e5);
      } else r3 = i3 = (e4) => e4;
      return o2.slice(a2, l).map((e4, t4) => {
        let n3 = a2 + 1 + t4, s3 = " " + (" " + n3).slice(-c) + " | ";
        if (n3 === this.line) {
          let t5 = i3(s3.replace(/\d/g, " ")) + e4.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return r3(">") + i3(s3) + e4 + "\n " + t5 + r3("^");
        }
        return " " + i3(s3) + e4;
      }).join("\n");
    }
    toString() {
      let e3 = this.showSourceCode();
      return e3 && (e3 = "\n\n" + e3 + "\n"), this.name + ": " + this.message + e3;
    }
  }
  e2.exports = i2, i2.default = i2;
}, (e2, t2, r2) => {
  let n2, s2, i2 = r2(24);
  class o2 extends i2 {
    constructor(e3) {
      super({ type: "document", ...e3 }), this.nodes || (this.nodes = []);
    }
    toResult() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return new n2(new s2(), this, e3).stringify();
    }
  }
  o2.registerLazyResult = (e3) => {
    n2 = e3;
  }, o2.registerProcessor = (e3) => {
    s2 = e3;
  }, e2.exports = o2, o2.default = o2;
}, (e2, t2, r2) => {
  let n2 = r2(153);
  class s2 {
    constructor(e3, t3, r3) {
      this.processor = e3, this.messages = [], this.root = t3, this.opts = r3, this.css = void 0, this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      t3.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t3.plugin = this.lastPlugin.postcssPlugin);
      let r3 = new n2(e3, t3);
      return this.messages.push(r3), r3;
    }
    warnings() {
      return this.messages.filter((e3) => "warning" === e3.type);
    }
    get content() {
      return this.css;
    }
  }
  e2.exports = s2, s2.default = s2;
}, (e2, t2, r2) => {
  let n2 = r2(24), s2 = r2(320), i2 = r2(55);
  function o2(e3, t3) {
    let r3 = new i2(e3, t3), n3 = new s2(r3);
    try {
      n3.parse();
    } catch (e4) {
      throw e4;
    }
    return n3.root;
  }
  e2.exports = o2, o2.default = o2, n2.registerParse(o2);
}, (e2, t2, r2) => {
  let n2 = r2(24);
  class s2 extends n2 {
    constructor(e3) {
      super(e3), this.type = "atrule";
    }
    append() {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...arguments);
    }
    prepend() {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...arguments);
    }
  }
  e2.exports = s2, s2.default = s2, n2.registerAtRule(s2);
}, (e2, t2, r2) => {
  let n2 = r2(24), s2 = r2(154);
  class i2 extends n2 {
    constructor(e3) {
      super(e3), this.type = "rule", this.nodes || (this.nodes = []);
    }
    get selectors() {
      return s2.comma(this.selector);
    }
    set selectors(e3) {
      let t3 = this.selector ? this.selector.match(/,\s*/) : null, r3 = t3 ? t3[0] : "," + this.raw("between", "beforeOpen");
      this.selector = e3.join(r3);
    }
  }
  e2.exports = i2, i2.default = i2, n2.registerRule(i2);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "ImportInjector", { enumerable: true, get: function() {
    return n2.default;
  } }), t2.addDefault = function(e3, t3, r3) {
    return new n2.default(e3).addDefault(t3, r3);
  }, t2.addNamed = function(e3, t3, r3, s3) {
    return new n2.default(e3).addNamed(t3, r3, s3);
  }, t2.addNamespace = function(e3, t3, r3) {
    return new n2.default(e3).addNamespace(t3, r3);
  }, t2.addSideEffect = function(e3, t3, r3) {
    return new n2.default(e3).addSideEffect(t3, r3);
  }, Object.defineProperty(t2, "isModule", { enumerable: true, get: function() {
    return s2.default;
  } });
  var n2 = r2(447), s2 = r2(250);
}, function(e2, t2) {
  !function(e3) {
    class t3 {
      constructor() {
        this.should_skip = false, this.should_remove = false, this.replacement = null, this.context = { skip: () => this.should_skip = true, remove: () => this.should_remove = true, replace: (e4) => this.replacement = e4 };
      }
      replace(e4, t4, r3, n3) {
        e4 && (null !== r3 ? e4[t4][r3] = n3 : e4[t4] = n3);
      }
      remove(e4, t4, r3) {
        e4 && (null !== r3 ? e4[t4].splice(r3, 1) : delete e4[t4]);
      }
    }
    class r2 extends t3 {
      constructor(e4, t4) {
        super(), this.enter = e4, this.leave = t4;
      }
      visit(e4, t4, r3, n3) {
        if (e4) {
          if (this.enter) {
            const s2 = this.should_skip, i2 = this.should_remove, o2 = this.replacement;
            this.should_skip = false, this.should_remove = false, this.replacement = null, this.enter.call(this.context, e4, t4, r3, n3), this.replacement && (e4 = this.replacement, this.replace(t4, r3, n3, e4)), this.should_remove && this.remove(t4, r3, n3);
            const a2 = this.should_skip, l = this.should_remove;
            if (this.should_skip = s2, this.should_remove = i2, this.replacement = o2, a2) return e4;
            if (l) return null;
          }
          for (const t5 in e4) {
            const r4 = e4[t5];
            if ("object" == typeof r4) if (Array.isArray(r4)) for (let n4 = 0; n4 < r4.length; n4 += 1) null !== r4[n4] && "string" == typeof r4[n4].type && (this.visit(r4[n4], e4, t5, n4) || n4--);
            else null !== r4 && "string" == typeof r4.type && this.visit(r4, e4, t5, null);
          }
          if (this.leave) {
            const s2 = this.replacement, i2 = this.should_remove;
            this.replacement = null, this.should_remove = false, this.leave.call(this.context, e4, t4, r3, n3), this.replacement && (e4 = this.replacement, this.replace(t4, r3, n3, e4)), this.should_remove && this.remove(t4, r3, n3);
            const o2 = this.should_remove;
            if (this.replacement = s2, this.should_remove = i2, o2) return null;
          }
        }
        return e4;
      }
    }
    class n2 extends t3 {
      constructor(e4, t4) {
        super(), this.enter = e4, this.leave = t4;
      }
      async visit(e4, t4, r3, n3) {
        if (e4) {
          if (this.enter) {
            const s2 = this.should_skip, i2 = this.should_remove, o2 = this.replacement;
            this.should_skip = false, this.should_remove = false, this.replacement = null, await this.enter.call(this.context, e4, t4, r3, n3), this.replacement && (e4 = this.replacement, this.replace(t4, r3, n3, e4)), this.should_remove && this.remove(t4, r3, n3);
            const a2 = this.should_skip, l = this.should_remove;
            if (this.should_skip = s2, this.should_remove = i2, this.replacement = o2, a2) return e4;
            if (l) return null;
          }
          for (const t5 in e4) {
            const r4 = e4[t5];
            if ("object" == typeof r4) if (Array.isArray(r4)) for (let n4 = 0; n4 < r4.length; n4 += 1) null !== r4[n4] && "string" == typeof r4[n4].type && (await this.visit(r4[n4], e4, t5, n4) || n4--);
            else null !== r4 && "string" == typeof r4.type && await this.visit(r4, e4, t5, null);
          }
          if (this.leave) {
            const s2 = this.replacement, i2 = this.should_remove;
            this.replacement = null, this.should_remove = false, await this.leave.call(this.context, e4, t4, r3, n3), this.replacement && (e4 = this.replacement, this.replace(t4, r3, n3, e4)), this.should_remove && this.remove(t4, r3, n3);
            const o2 = this.should_remove;
            if (this.replacement = s2, this.should_remove = i2, o2) return null;
          }
        }
        return e4;
      }
    }
    e3.asyncWalk = async function(e4, t4) {
      let { enter: r3, leave: s2 } = t4;
      const i2 = new n2(r3, s2);
      return await i2.visit(e4, null);
    }, e3.walk = function(e4, t4) {
      let { enter: n3, leave: s2 } = t4;
      return new r2(n3, s2).visit(e4, null);
    }, Object.defineProperty(e3, "__esModule", { value: true });
  }(t2);
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(161);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2() {
    const e3 = r2(14);
    return s2 = function() {
      return e3;
    }, e3;
  }
  function i2() {
    const e3 = r2(36);
    return i2 = function() {
      return e3;
    }, e3;
  }
  function o2() {
    const e3 = r2(0);
    return o2 = function() {
      return e3;
    }, e3;
  }
  function a2() {
    const e3 = r2(68);
    return a2 = function() {
      return e3;
    }, e3;
  }
  function l() {
    const e3 = r2(23);
    return l = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  const { cloneNode: c, interpreterDirective: u } = o2(), p = { enter(e3, t3) {
    const r3 = e3.node.loc;
    r3 && (t3.loc = r3, e3.stop());
  } };
  class d {
    constructor(e3, t3) {
      let { code: r3, ast: n3, inputMap: i3 } = t3;
      this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope = void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = { file: this, getCode: () => this.code, getScope: () => this.scope, addHelper: this.addHelper.bind(this), buildError: this.buildCodeFrameError.bind(this) }, this.opts = e3, this.code = r3, this.ast = n3, this.inputMap = i3, this.path = s2().NodePath.get({ hub: this.hub, parentPath: null, parent: this.ast, container: this.ast, key: "program" }).setContext(), this.scope = this.path.scope;
    }
    get shebang() {
      const { interpreter: e3 } = this.path.node;
      return e3 ? e3.value : "";
    }
    set shebang(e3) {
      e3 ? this.path.get("interpreter").replaceWith(u(e3)) : this.path.get("interpreter").remove();
    }
    set(e3, t3) {
      if ("helpersNamespace" === e3) throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
      this._map.set(e3, t3);
    }
    get(e3) {
      return this._map.get(e3);
    }
    has(e3) {
      return this._map.has(e3);
    }
    getModuleName() {
      return (0, a2().getModuleName)(this.opts, this.opts);
    }
    addImport() {
      throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
    }
    availableHelper(e3, t3) {
      let r3;
      try {
        r3 = n2().minVersion(e3);
      } catch (e4) {
        if ("BABEL_HELPER_UNKNOWN" !== e4.code) throw e4;
        return false;
      }
      return "string" != typeof t3 || (l().valid(t3) && (t3 = `^${t3}`), !l().intersects(`<${r3}`, t3) && !l().intersects(">=8.0.0", t3));
    }
    addHelper(e3) {
      const t3 = this.declarations[e3];
      if (t3) return c(t3);
      const r3 = this.get("helperGenerator");
      if (r3) {
        const t4 = r3(e3);
        if (t4) return t4;
      }
      n2().ensure(e3, d);
      const s3 = this.declarations[e3] = this.scope.generateUidIdentifier(e3), i3 = {};
      for (const t4 of n2().getDependencies(e3)) i3[t4] = this.addHelper(t4);
      const { nodes: o3, globals: a3 } = n2().get(e3, (e4) => i3[e4], s3, Object.keys(this.scope.getAllBindings()));
      return a3.forEach((e4) => {
        this.path.scope.hasBinding(e4, true) && this.path.scope.rename(e4);
      }), o3.forEach((e4) => {
        e4._compact = true;
      }), this.path.unshiftContainer("body", o3), this.path.get("body").forEach((e4) => {
        -1 !== o3.indexOf(e4.node) && e4.isVariableDeclaration() && this.scope.registerDeclaration(e4);
      }), s3;
    }
    addTemplateObject() {
      throw new Error("This function has been moved into the template literal transform itself.");
    }
    buildCodeFrameError(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : SyntaxError, n3 = e3 && (e3.loc || e3._loc);
      if (!n3 && e3) {
        const r4 = { loc: null };
        (0, s2().default)(e3, p, this.scope, r4), n3 = r4.loc;
        let i3 = "This is an error on an internal node. Probably an internal error.";
        n3 && (i3 += " Location has been estimated."), t3 += ` (${i3})`;
      }
      if (n3) {
        const { highlightCode: e4 = true } = this.opts;
        t3 += "\n" + (0, i2().codeFrameColumns)(this.code, { start: { line: n3.start.line, column: n3.start.column + 1 }, end: n3.end && n3.start.line === n3.end.line ? { line: n3.end.line, column: n3.end.column + 1 } : void 0 }, { highlightCode: e4 });
      }
      return new r3(t3);
    }
  }
  t2.default = d;
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const r2 = Object.keys(t3);
    for (const n2 of r2) if (e3[n2] !== t3[n2]) return false;
    return true;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    if (!e3) return;
    const o2 = n2.NODE_FIELDS[e3.type];
    if (!o2) return;
    s2(e3, t3, r3, o2[t3]), i2(e3, t3, r3);
  }, t2.validateChild = i2, t2.validateField = s2;
  var n2 = r2(9);
  function s2(e3, t3, r3, n3) {
    null != n3 && n3.validate && (n3.optional && null == r3 || n3.validate(e3, t3, r3));
  }
  function i2(e3, t3, r3) {
    if (null == r3) return;
    const s3 = n2.NODE_PARENT_VALIDATIONS[r3.type];
    s3 && s3(e3, t3, r3);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if (e3 === t3) return true;
    if (null == e3) return false;
    if (n2.ALIAS_KEYS[t3]) return false;
    const r3 = n2.FLIPPED_ALIAS_KEYS[t3];
    if (r3) {
      if (r3[0] === e3) return true;
      for (const t4 of r3) if (e3 === t4) return true;
    }
    return false;
  };
  var n2 = r2(9);
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r2) {
    t3 && r2 && (t3[e3] = Array.from(new Set([].concat(t3[e3], r2[e3]).filter(Boolean))));
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.traverseNode = function(e3, t3, r3, s3, o2, a2, l) {
    const c = i2[e3.type];
    if (!c) return false;
    const u = new n2.default(r3, t3, s3, o2);
    if (l) return (null == a2 || !a2[o2.parentKey]) && u.visitQueue([o2]);
    for (const t4 of c) if ((null == a2 || !a2[t4]) && u.visit(e3, t4)) return true;
    return false;
  };
  var n2 = r2(400), s2 = r2(0);
  const { VISITOR_KEYS: i2 } = s2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = arguments.length > 2 ? arguments[2] : void 0;
    const o2 = i2(r3, t3), a2 = t3.sourceMaps ? new n2.default(t3, r3) : null;
    return new s2.default(o2, a2).generate(e3);
  };
  var n2 = r2(405), s2 = r2(408);
  function i2(e3, t3) {
    var r3;
    const n3 = { auxiliaryCommentBefore: t3.auxiliaryCommentBefore, auxiliaryCommentAfter: t3.auxiliaryCommentAfter, shouldPrintComment: t3.shouldPrintComment, retainLines: t3.retainLines, retainFunctionParens: t3.retainFunctionParens, comments: null == t3.comments || t3.comments, compact: t3.compact, minified: t3.minified, concise: t3.concise, indent: { adjustMultilineComment: true, style: "  " }, jsescOption: Object.assign({ quotes: "double", wrap: true, minimal: false }, t3.jsescOption), recordAndTupleSyntaxType: null != (r3 = t3.recordAndTupleSyntaxType) ? r3 : "hash", topicToken: t3.topicToken, importAttributesKeyword: t3.importAttributesKeyword };
    n3.decoratorsBeforeExport = t3.decoratorsBeforeExport, n3.jsescOption.json = t3.jsonCompatibleStrings, n3.minified ? (n3.compact = true, n3.shouldPrintComment = n3.shouldPrintComment || (() => n3.comments)) : n3.shouldPrintComment = n3.shouldPrintComment || ((e4) => n3.comments || e4.includes("@license") || e4.includes("@preserve")), "auto" === n3.compact && (n3.compact = "string" == typeof e3 && e3.length > 5e5, n3.compact), n3.compact && (n3.indent.adjustMultilineComment = false);
    const { auxiliaryCommentBefore: s3, auxiliaryCommentAfter: i3, shouldPrintComment: o2 } = n3;
    return s3 && !o2(s3) && (n3.auxiliaryCommentBefore = void 0), i3 && !o2(i3) && (n3.auxiliaryCommentAfter = void 0), n3;
  }
  t2.CodeGenerator = class {
    constructor(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = arguments.length > 2 ? arguments[2] : void 0;
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = e3, this._format = i2(r3, t3), this._map = t3.sourceMaps ? new n2.default(t3, r3) : null;
    }
    generate() {
      return new s2.default(this._format, this._map).generate(this._ast);
    }
  };
}, (e2, t2, r2) => {
  var n2 = r2(103), s2 = r2(109);
  e2.exports = function(e3, t3, r3) {
    return r3.get && n2(r3.get, t3, { getter: true }), r3.set && n2(r3.set, t3, { setter: true }), s2.f(e3, t3, r3);
  };
}, (e2, t2, r2) => {
  var n2 = r2(19), s2 = r2(11), i2 = r2(6), o2 = r2(29), a2 = r2(15), l = r2(188).CONFIGURABLE, c = r2(189), u = r2(107), p = u.enforce, d = u.get, f = String, h = Object.defineProperty, m = n2("".slice), y = n2("".replace), g = n2([].join), b = a2 && !s2(function() {
    return 8 !== h(function() {
    }, "length", { value: 8 }).length;
  }), v = String(String).split("String"), E = e2.exports = function(e3, t3, r3) {
    "Symbol(" === m(f(t3), 0, 7) && (t3 = "[" + y(f(t3), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), r3 && r3.getter && (t3 = "get " + t3), r3 && r3.setter && (t3 = "set " + t3), (!o2(e3, "name") || l && e3.name !== t3) && (a2 ? h(e3, "name", { value: t3, configurable: true }) : e3.name = t3), b && r3 && o2(r3, "arity") && e3.length !== r3.arity && h(e3, "length", { value: r3.arity });
    try {
      r3 && o2(r3, "constructor") && r3.constructor ? a2 && h(e3, "prototype", { writable: false }) : e3.prototype && (e3.prototype = void 0);
    } catch (e4) {
    }
    var n3 = p(e3);
    return o2(n3, "source") || (n3.source = g(v, "string" == typeof t3 ? t3 : "")), e3;
  };
  Function.prototype.toString = E(function() {
    return i2(this) && d(this).source || c(this);
  }, "toString");
}, (e2, t2, r2) => {
  var n2 = r2(11);
  e2.exports = !n2(function() {
    var e3 = (function() {
    }).bind();
    return "function" != typeof e3 || e3.hasOwnProperty("prototype");
  });
}, (e2) => {
  e2.exports = function(e3) {
    return null == e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = Object.defineProperty;
  e2.exports = function(e3, t3) {
    try {
      s2(n2, e3, { value: t3, configurable: true, writable: true });
    } catch (r3) {
      n2[e3] = t3;
    }
    return t3;
  };
}, (e2, t2, r2) => {
  var n2, s2, i2, o2 = r2(190), a2 = r2(5), l = r2(20), c = r2(108), u = r2(29), p = r2(64), d = r2(117), f = r2(203), h = "Object already initialized", m = a2.TypeError, y = a2.WeakMap;
  if (o2 || p.state) {
    var g = p.state || (p.state = new y());
    g.get = g.get, g.has = g.has, g.set = g.set, n2 = function(e3, t3) {
      if (g.has(e3)) throw new m(h);
      return t3.facade = e3, g.set(e3, t3), t3;
    }, s2 = function(e3) {
      return g.get(e3) || {};
    }, i2 = function(e3) {
      return g.has(e3);
    };
  } else {
    var b = d("state");
    f[b] = true, n2 = function(e3, t3) {
      if (u(e3, b)) throw new m(h);
      return t3.facade = e3, c(e3, b, t3), t3;
    }, s2 = function(e3) {
      return u(e3, b) ? e3[b] : {};
    }, i2 = function(e3) {
      return u(e3, b);
    };
  }
  e2.exports = { set: n2, get: s2, has: i2, enforce: function(e3) {
    return i2(e3) ? s2(e3) : n2(e3, {});
  }, getterFor: function(e3) {
    return function(t3) {
      var r3;
      if (!l(t3) || (r3 = s2(t3)).type !== e3) throw new m("Incompatible receiver, " + e3 + " required");
      return r3;
    };
  } };
}, (e2, t2, r2) => {
  var n2 = r2(15), s2 = r2(109), i2 = r2(202);
  e2.exports = n2 ? function(e3, t3, r3) {
    return s2.f(e3, t3, i2(1, r3));
  } : function(e3, t3, r3) {
    return e3[t3] = r3, e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(15), s2 = r2(191), i2 = r2(193), o2 = r2(65), a2 = r2(194), l = TypeError, c = Object.defineProperty, u = Object.getOwnPropertyDescriptor, p = "enumerable", d = "configurable", f = "writable";
  t2.f = n2 ? i2 ? function(e3, t3, r3) {
    if (o2(e3), t3 = a2(t3), o2(r3), "function" == typeof e3 && "prototype" === t3 && "value" in r3 && f in r3 && !r3[f]) {
      var n3 = u(e3, t3);
      n3 && n3[f] && (e3[t3] = r3.value, r3 = { configurable: d in r3 ? r3[d] : n3[d], enumerable: p in r3 ? r3[p] : n3[p], writable: false });
    }
    return c(e3, t3, r3);
  } : c : function(e3, t3, r3) {
    if (o2(e3), t3 = a2(t3), o2(r3), s2) try {
      return c(e3, t3, r3);
    } catch (e4) {
    }
    if ("get" in r3 || "set" in r3) throw new l("Accessors not supported");
    return "value" in r3 && (e3[t3] = r3.value), e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(196), s2 = r2(6), i2 = r2(111), o2 = r2(112), a2 = Object;
  e2.exports = o2 ? function(e3) {
    return "symbol" == typeof e3;
  } : function(e3) {
    var t3 = n2("Symbol");
    return s2(t3) && i2(t3.prototype, a2(e3));
  };
}, (e2, t2, r2) => {
  var n2 = r2(19);
  e2.exports = n2({}.isPrototypeOf);
}, (e2, t2, r2) => {
  var n2 = r2(113);
  e2.exports = n2 && !Symbol.sham && "symbol" == typeof Symbol.iterator;
}, (e2, t2, r2) => {
  var n2 = r2(197), s2 = r2(11), i2 = r2(5).String;
  e2.exports = !!Object.getOwnPropertySymbols && !s2(function() {
    var e3 = Symbol("symbol detection");
    return !i2(e3) || !(Object(e3) instanceof Symbol) || !Symbol.sham && n2 && n2 < 41;
  });
}, (e2, t2, r2) => {
  var n2 = r2(6), s2 = r2(115), i2 = TypeError;
  e2.exports = function(e3) {
    if (n2(e3)) return e3;
    throw new i2(s2(e3) + " is not a function");
  };
}, (e2) => {
  var t2 = String;
  e2.exports = function(e3) {
    try {
      return t2(e3);
    } catch (e4) {
      return "Object";
    }
  };
}, (e2, t2, r2) => {
  var n2 = r2(201), s2 = r2(64);
  (e2.exports = function(e3, t3) {
    return s2[e3] || (s2[e3] = void 0 !== t3 ? t3 : {});
  })("versions", []).push({ version: "3.35.1", mode: n2 ? "pure" : "global", copyright: " 2014-2024 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.35.1/LICENSE", source: "https://github.com/zloirock/core-js" });
}, (e2, t2, r2) => {
  var n2 = r2(116), s2 = r2(67), i2 = n2("keys");
  e2.exports = function(e3) {
    return i2[e3] || (i2[e3] = s2(e3));
  };
}, (e2, t2, r2) => {
  var n2 = r2(220);
  e2.exports = function(e3) {
    var t3 = +e3;
    return t3 != t3 || 0 === t3 ? 0 : n2(t3);
  };
}, (e2, t2, r2) => {
  r2(44), Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    let t3, { node: r3, parent: n3, scope: s3, id: w } = e3, P = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], A = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (r3.id) return;
    if (!m(n3) && !h(n3, { kind: "method" }) || n3.computed && !d(n3.key)) {
      if (v(n3)) {
        if (w = n3.id, p(w) && !P) {
          const e4 = s3.parent.getBinding(w.name);
          if (e4 && e4.constant && s3.getBinding(w.name) === e4) return r3.id = o2(w), void (r3.id[i2] = true);
        }
      } else if (l(n3, { operator: "=" })) w = n3.left;
      else if (!w) return;
    } else w = n3.key;
    if (w && d(w) ? t3 = function(e4) {
      return f(e4) ? "null" : y(e4) ? `_${e4.pattern}_${e4.flags}` : b(e4) ? e4.quasis.map((e5) => e5.value.raw).join("") : void 0 !== e4.value ? e4.value + "" : "";
    }(w) : w && p(w) && (t3 = w.name), void 0 === t3) return;
    if (!A && u(r3) && /[\uD800-\uDFFF]/.test(t3)) return;
    t3 = E(t3);
    const C = a2(t3);
    return C[i2] = true, function(e4, t4, r4, n4) {
      if (e4.selfReference) {
        if (!n4.hasBinding(r4.name) || n4.hasGlobal(r4.name)) {
          if (!u(t4)) return;
          let e5 = S;
          t4.generator && (e5 = x);
          const s4 = e5({ FUNCTION: t4, FUNCTION_ID: r4, FUNCTION_KEY: n4.generateUidIdentifier(r4.name) }).expression, i3 = s4.callee.body.body[0].params;
          for (let e6 = 0, r5 = function(e7) {
            const t5 = e7.params.findIndex((e8) => c(e8) || g(e8));
            return -1 === t5 ? e7.params.length : t5;
          }(t4); e6 < r5; e6++) i3.push(n4.generateUidIdentifier("x"));
          return s4;
        }
        n4.rename(r4.name);
      }
      t4.id = r4, n4.getProgramParent().references[r4.name] = true;
    }(function(e4, t4, r4) {
      const n4 = { selfAssignment: false, selfReference: false, outerDeclar: r4.getBindingIdentifier(t4), name: t4 }, s4 = r4.getOwnBinding(t4);
      return s4 ? "param" === s4.kind && (n4.selfReference = true) : (n4.outerDeclar || r4.hasGlobal(t4)) && r4.traverse(e4, T, n4), n4;
    }(r3, t3, s3), r3, C, s3) || r3;
  };
  var n2 = r2(37), s2 = r2(0);
  const { NOT_LOCAL_BINDING: i2, cloneNode: o2, identifier: a2, isAssignmentExpression: l, isAssignmentPattern: c, isFunction: u, isIdentifier: p, isLiteral: d, isNullLiteral: f, isObjectMethod: h, isObjectProperty: m, isRegExpLiteral: y, isRestElement: g, isTemplateLiteral: b, isVariableDeclarator: v, toBindingIdentifierName: E } = s2, S = n2.default.statement("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), x = n2.default.statement("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), T = { "ReferencedIdentifier|BindingIdentifier"(e3, t3) {
    e3.node.name === t3.name && e3.scope.getBindingIdentifier(t3.name) === t3.outerDeclar && (t3.selfReference = true, e3.stop());
  } };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.merge = function(e3, t3) {
    const { placeholderWhitelist: r3 = e3.placeholderWhitelist, placeholderPattern: n2 = e3.placeholderPattern, preserveComments: s2 = e3.preserveComments, syntacticPlaceholders: i2 = e3.syntacticPlaceholders } = t3;
    return { parser: Object.assign({}, e3.parser, t3.parser), placeholderWhitelist: r3, placeholderPattern: n2, preserveComments: s2, syntacticPlaceholders: i2 };
  }, t2.normalizeReplacements = function(e3) {
    if (Array.isArray(e3)) return e3.reduce((e4, t3, r3) => (e4["$" + r3] = t3, e4), {});
    if ("object" == typeof e3 || null == e3) return e3 || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }, t2.validate = function(e3) {
    if (null != e3 && "object" != typeof e3) throw new Error("Unknown template options.");
    const t3 = e3 || {}, { placeholderWhitelist: n2, placeholderPattern: s2, preserveComments: i2, syntacticPlaceholders: o2 } = t3, a2 = function(e4, t4) {
      if (null == e4) return {};
      var r3, n3, s3 = {}, i3 = Object.keys(e4);
      for (n3 = 0; n3 < i3.length; n3++) r3 = i3[n3], t4.indexOf(r3) >= 0 || (s3[r3] = e4[r3]);
      return s3;
    }(t3, r2);
    if (null != n2 && !(n2 instanceof Set)) throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (null != s2 && !(s2 instanceof RegExp) && false !== s2) throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (null != i2 && "boolean" != typeof i2) throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (null != o2 && "boolean" != typeof o2) throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (true === o2 && (null != n2 || null != s2)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return { parser: a2, placeholderWhitelist: n2 || void 0, placeholderPattern: null == s2 ? void 0 : s2, preserveComments: null == i2 ? void 0 : i2, syntacticPlaceholders: null == o2 ? void 0 : o2 };
  };
  const r2 = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
}, (e2, t2, r2) => {
  var n2 = r2(72)(), s2 = r2(22), i2 = n2 && s2("%Object.defineProperty%", true);
  if (i2) try {
    i2({}, "a", { value: 1 });
  } catch (e3) {
    i2 = false;
  }
  var o2 = s2("%SyntaxError%"), a2 = s2("%TypeError%"), l = r2(73);
  e2.exports = function(e3, t3, r3) {
    if (!e3 || "object" != typeof e3 && "function" != typeof e3) throw new a2("`obj` must be an object or a function`");
    if ("string" != typeof t3 && "symbol" != typeof t3) throw new a2("`property` must be a string or a symbol`");
    if (arguments.length > 3 && "boolean" != typeof arguments[3] && null !== arguments[3]) throw new a2("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && "boolean" != typeof arguments[4] && null !== arguments[4]) throw new a2("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && "boolean" != typeof arguments[5] && null !== arguments[5]) throw new a2("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && "boolean" != typeof arguments[6]) throw new a2("`loose`, if provided, must be a boolean");
    var n3 = arguments.length > 3 ? arguments[3] : null, s3 = arguments.length > 4 ? arguments[4] : null, c = arguments.length > 5 ? arguments[5] : null, u = arguments.length > 6 && arguments[6], p = !!l && l(e3, t3);
    if (i2) i2(e3, t3, { configurable: null === c && p ? p.configurable : !c, enumerable: null === n3 && p ? p.enumerable : !n3, value: r3, writable: null === s3 && p ? p.writable : !s3 });
    else {
      if (!u && (n3 || s3 || c)) throw new o2("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      e3[t3] = r3;
    }
  };
}, (e2, t2, r2) => {
  var n2 = r2(236), s2 = r2(238), i2 = r2(41), o2 = r2(38), a2 = r2(73), l = o2("Object.prototype.toString"), c = r2(69)(), u = "undefined" == typeof globalThis ? r2.g : globalThis, p = s2(), d = o2("String.prototype.slice"), f = Object.getPrototypeOf, h = o2("Array.prototype.indexOf", true) || function(e3, t3) {
    for (var r3 = 0; r3 < e3.length; r3 += 1) if (e3[r3] === t3) return r3;
    return -1;
  }, m = { __proto__: null };
  n2(p, c && a2 && f ? function(e3) {
    var t3 = new u[e3]();
    if (Symbol.toStringTag in t3) {
      var r3 = f(t3), n3 = a2(r3, Symbol.toStringTag);
      if (!n3) {
        var s3 = f(r3);
        n3 = a2(s3, Symbol.toStringTag);
      }
      m["$" + e3] = i2(n3.get);
    }
  } : function(e3) {
    var t3 = new u[e3](), r3 = t3.slice || t3.set;
    r3 && (m["$" + e3] = i2(r3));
  }), e2.exports = function(e3) {
    if (!e3 || "object" != typeof e3) return false;
    if (!c) {
      var t3 = d(l(e3), 8, -1);
      return h(p, t3) > -1 ? t3 : "Object" === t3 && function(e4) {
        var t4 = false;
        return n2(m, function(r3, n3) {
          if (!t4) try {
            r3(e4), t4 = d(n3, 1);
          } catch (e5) {
          }
        }), t4;
      }(e3);
    }
    return a2 ? function(e4) {
      var t4 = false;
      return n2(m, function(r3, n3) {
        if (!t4) try {
          "$" + r3(e4) === n3 && (t4 = d(n3, 1));
        } catch (e5) {
        }
      }), t4;
    }(e3) : null;
  };
}, (e2, t2, r2) => {
  var n2 = Array.prototype.slice, s2 = r2(124), i2 = Object.keys, o2 = i2 ? function(e3) {
    return i2(e3);
  } : r2(244), a2 = Object.keys;
  o2.shim = function() {
    if (Object.keys) {
      var e3 = function() {
        var e4 = Object.keys(arguments);
        return e4 && e4.length === arguments.length;
      }(1, 2);
      e3 || (Object.keys = function(e4) {
        return s2(e4) ? a2(n2.call(e4)) : a2(e4);
      });
    } else Object.keys = o2;
    return Object.keys || o2;
  }, e2.exports = o2;
}, (e2) => {
  var t2 = Object.prototype.toString;
  e2.exports = function(e3) {
    var r2 = t2.call(e3), n2 = "[object Arguments]" === r2;
    return n2 || (n2 = "[object Array]" !== r2 && null !== e3 && "object" == typeof e3 && "number" == typeof e3.length && e3.length >= 0 && "[object Function]" === t2.call(e3.callee)), n2;
  };
}, (e2) => {
  var t2 = function(e3) {
    return e3 != e3;
  };
  e2.exports = function(e3, r2) {
    return 0 === e3 && 0 === r2 ? 1 / e3 == 1 / r2 : e3 === r2 || !(!t2(e3) || !t2(r2));
  };
}, (e2) => {
  e2.exports = function(e3) {
    return e3 != e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(126);
  e2.exports = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : n2;
  };
}, (e2) => {
  const t2 = /^[0-9]+$/, r2 = (e3, r3) => {
    const n2 = t2.test(e3), s2 = t2.test(r3);
    return n2 && s2 && (e3 = +e3, r3 = +r3), e3 === r3 ? 0 : n2 && !s2 ? -1 : s2 && !n2 ? 1 : e3 < r3 ? -1 : 1;
  };
  e2.exports = { compareIdentifiers: r2, rcompareIdentifiers: (e3, t3) => r2(t3, e3) };
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => 0 === n2(e3, t3, r3);
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => 0 !== n2(e3, t3, r3);
}, (e2, t2, r2) => {
  const n2 = r2(129), s2 = r2(130), i2 = r2(49), o2 = r2(78), a2 = r2(77), l = r2(79);
  e2.exports = (e3, t3, r3, c) => {
    switch (t3) {
      case "===":
        return "object" == typeof e3 && (e3 = e3.version), "object" == typeof r3 && (r3 = r3.version), e3 === r3;
      case "!==":
        return "object" == typeof e3 && (e3 = e3.version), "object" == typeof r3 && (r3 = r3.version), e3 !== r3;
      case "":
      case "=":
      case "==":
        return n2(e3, r3, c);
      case "!=":
        return s2(e3, r3, c);
      case ">":
        return i2(e3, r3, c);
      case ">=":
        return o2(e3, r3, c);
      case "<":
        return a2(e3, r3, c);
      case "<=":
        return l(e3, r3, c);
      default:
        throw new TypeError(`Invalid operator: ${t3}`);
    }
  };
}, (e2, t2, r2) => {
  const n2 = r2(266), s2 = Symbol("max"), i2 = Symbol("length"), o2 = Symbol("lengthCalculator"), a2 = Symbol("allowStale"), l = Symbol("maxAge"), c = Symbol("dispose"), u = Symbol("noDisposeOnSet"), p = Symbol("lruList"), d = Symbol("cache"), f = Symbol("updateAgeOnGet"), h = () => 1, m = (e3, t3, r3) => {
    const n3 = e3[d].get(t3);
    if (n3) {
      const t4 = n3.value;
      if (y(e3, t4)) {
        if (b(e3, n3), !e3[a2]) return;
      } else r3 && (e3[f] && (n3.value.now = Date.now()), e3[p].unshiftNode(n3));
      return t4.value;
    }
  }, y = (e3, t3) => {
    if (!t3 || !t3.maxAge && !e3[l]) return false;
    const r3 = Date.now() - t3.now;
    return t3.maxAge ? r3 > t3.maxAge : e3[l] && r3 > e3[l];
  }, g = (e3) => {
    if (e3[i2] > e3[s2]) for (let t3 = e3[p].tail; e3[i2] > e3[s2] && null !== t3; ) {
      const r3 = t3.prev;
      b(e3, t3), t3 = r3;
    }
  }, b = (e3, t3) => {
    if (t3) {
      const r3 = t3.value;
      e3[c] && e3[c](r3.key, r3.value), e3[i2] -= r3.length, e3[d].delete(r3.key), e3[p].removeNode(t3);
    }
  };
  class v {
    constructor(e3, t3, r3, n3, s3) {
      this.key = e3, this.value = t3, this.length = r3, this.now = n3, this.maxAge = s3 || 0;
    }
  }
  const E = (e3, t3, r3, n3) => {
    let s3 = r3.value;
    y(e3, s3) && (b(e3, r3), e3[a2] || (s3 = void 0)), s3 && t3.call(n3, s3.value, s3.key, e3);
  };
  e2.exports = class {
    constructor(e3) {
      if ("number" == typeof e3 && (e3 = { max: e3 }), e3 || (e3 = {}), e3.max && ("number" != typeof e3.max || e3.max < 0)) throw new TypeError("max must be a non-negative number");
      this[s2] = e3.max || 1 / 0;
      const t3 = e3.length || h;
      if (this[o2] = "function" != typeof t3 ? h : t3, this[a2] = e3.stale || false, e3.maxAge && "number" != typeof e3.maxAge) throw new TypeError("maxAge must be a number");
      this[l] = e3.maxAge || 0, this[c] = e3.dispose, this[u] = e3.noDisposeOnSet || false, this[f] = e3.updateAgeOnGet || false, this.reset();
    }
    set max(e3) {
      if ("number" != typeof e3 || e3 < 0) throw new TypeError("max must be a non-negative number");
      this[s2] = e3 || 1 / 0, g(this);
    }
    get max() {
      return this[s2];
    }
    set allowStale(e3) {
      this[a2] = !!e3;
    }
    get allowStale() {
      return this[a2];
    }
    set maxAge(e3) {
      if ("number" != typeof e3) throw new TypeError("maxAge must be a non-negative number");
      this[l] = e3, g(this);
    }
    get maxAge() {
      return this[l];
    }
    set lengthCalculator(e3) {
      "function" != typeof e3 && (e3 = h), e3 !== this[o2] && (this[o2] = e3, this[i2] = 0, this[p].forEach((e4) => {
        e4.length = this[o2](e4.value, e4.key), this[i2] += e4.length;
      })), g(this);
    }
    get lengthCalculator() {
      return this[o2];
    }
    get length() {
      return this[i2];
    }
    get itemCount() {
      return this[p].length;
    }
    rforEach(e3, t3) {
      t3 = t3 || this;
      for (let r3 = this[p].tail; null !== r3; ) {
        const n3 = r3.prev;
        E(this, e3, r3, t3), r3 = n3;
      }
    }
    forEach(e3, t3) {
      t3 = t3 || this;
      for (let r3 = this[p].head; null !== r3; ) {
        const n3 = r3.next;
        E(this, e3, r3, t3), r3 = n3;
      }
    }
    keys() {
      return this[p].toArray().map((e3) => e3.key);
    }
    values() {
      return this[p].toArray().map((e3) => e3.value);
    }
    reset() {
      this[c] && this[p] && this[p].length && this[p].forEach((e3) => this[c](e3.key, e3.value)), this[d] = /* @__PURE__ */ new Map(), this[p] = new n2(), this[i2] = 0;
    }
    dump() {
      return this[p].map((e3) => !y(this, e3) && { k: e3.key, v: e3.value, e: e3.now + (e3.maxAge || 0) }).toArray().filter((e3) => e3);
    }
    dumpLru() {
      return this[p];
    }
    set(e3, t3, r3) {
      if ((r3 = r3 || this[l]) && "number" != typeof r3) throw new TypeError("maxAge must be a number");
      const n3 = r3 ? Date.now() : 0, a3 = this[o2](t3, e3);
      if (this[d].has(e3)) {
        if (a3 > this[s2]) return b(this, this[d].get(e3)), false;
        const o3 = this[d].get(e3).value;
        return this[c] && (this[u] || this[c](e3, o3.value)), o3.now = n3, o3.maxAge = r3, o3.value = t3, this[i2] += a3 - o3.length, o3.length = a3, this.get(e3), g(this), true;
      }
      const f2 = new v(e3, t3, a3, n3, r3);
      return f2.length > this[s2] ? (this[c] && this[c](e3, t3), false) : (this[i2] += f2.length, this[p].unshift(f2), this[d].set(e3, this[p].head), g(this), true);
    }
    has(e3) {
      if (!this[d].has(e3)) return false;
      const t3 = this[d].get(e3).value;
      return !y(this, t3);
    }
    get(e3) {
      return m(this, e3, true);
    }
    peek(e3) {
      return m(this, e3, false);
    }
    pop() {
      const e3 = this[p].tail;
      return e3 ? (b(this, e3), e3.value) : null;
    }
    del(e3) {
      b(this, this[d].get(e3));
    }
    load(e3) {
      this.reset();
      const t3 = Date.now();
      for (let r3 = e3.length - 1; r3 >= 0; r3--) {
        const n3 = e3[r3], s3 = n3.e || 0;
        if (0 === s3) this.set(n3.k, n3.v);
        else {
          const e4 = s3 - t3;
          e4 > 0 && this.set(n3.k, n3.v, e4);
        }
      }
    }
    prune() {
      this[d].forEach((e3, t3) => m(this, t3, false));
    }
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2(e3, t3, r3, n3, s3, i3, o3) {
    try {
      var a3 = e3[i3](o3), l2 = a3.value;
    } catch (e4) {
      return void r3(e4);
    }
    a3.done ? t3(l2) : Promise.resolve(l2).then(n3, s3);
  }
  function i2(e3) {
    return function() {
      var t3 = this, r3 = arguments;
      return new Promise(function(n3, i3) {
        var o3 = e3.apply(t3, r3);
        function a3(e4) {
          s2(o3, n3, i3, a3, l2, "next", e4);
        }
        function l2(e4) {
          s2(o3, n3, i3, a3, l2, "throw", e4);
        }
        a3(void 0);
      });
    };
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.forwardAsync = function(e3, t3) {
    const r3 = n2()(e3);
    return a2((e4) => {
      const n3 = r3[e4];
      return t3(n3);
    });
  }, t2.isAsync = void 0, t2.isThenable = u, t2.maybeAsync = function(e3, t3) {
    return n2()({ sync() {
      for (var r3 = arguments.length, n3 = new Array(r3), s3 = 0; s3 < r3; s3++) n3[s3] = arguments[s3];
      const i3 = e3.apply(this, n3);
      if (u(i3)) throw new Error(t3);
      return i3;
    }, async() {
      for (var t4 = arguments.length, r3 = new Array(t4), n3 = 0; n3 < t4; n3++) r3[n3] = arguments[n3];
      return Promise.resolve(e3.apply(this, r3));
    } });
  }, t2.waitFor = t2.onFirstPause = void 0;
  const o2 = n2()(function* (e3) {
    return yield* e3;
  });
  t2.isAsync = n2()({ sync: () => false, errback: (e3) => e3(null, true) });
  const a2 = n2()({ sync: (e3) => e3("sync"), async: (l = i2(function* (e3) {
    return e3("async");
  }), function(e3) {
    return l.apply(this, arguments);
  }) });
  var l, c;
  function u(e3) {
    return !(!e3 || "object" != typeof e3 && "function" != typeof e3 || !e3.then || "function" != typeof e3.then);
  }
  t2.onFirstPause = n2()({ name: "onFirstPause", arity: 2, sync: function(e3) {
    return o2.sync(e3);
  }, errback: function(e3, t3, r3) {
    let n3 = false;
    o2.errback(e3, (e4, t4) => {
      n3 = true, r3(e4, t4);
    }), n3 || t3();
  } }), t2.waitFor = n2()({ sync: (e3) => e3, async: (c = i2(function* (e3) {
    return e3;
  }), function(e3) {
    return c.apply(this, arguments);
  }) });
}, (e2, t2) => {
  function r2(e3, t3) {
    for (const r3 of Object.keys(t3)) {
      const n2 = t3[r3];
      void 0 !== n2 && (e3[r3] = n2);
    }
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isIterableIterator = function(e3) {
    return !!e3 && "function" == typeof e3.next && "function" == typeof e3[Symbol.iterator];
  }, t2.mergeOptions = function(e3, t3) {
    for (const n2 of Object.keys(t3)) if ("parserOpts" !== n2 && "generatorOpts" !== n2 && "assumptions" !== n2 || !t3[n2]) {
      const r3 = t3[n2];
      void 0 !== r3 && (e3[n2] = r3);
    } else {
      const s2 = t3[n2];
      r2(e3[n2] || (e3[n2] = {}), s2);
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(136);
  t2.default = class {
    constructor(e3, t3, r3) {
      let s2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : (0, n2.finalize)([]);
      this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride = void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = e3.name || r3, this.manipulateOptions = e3.manipulateOptions, this.post = e3.post, this.pre = e3.pre, this.visitor = e3.visitor || {}, this.parserOverride = e3.parserOverride, this.generatorOverride = e3.generatorOverride, this.options = t3, this.externalDependencies = s2;
    }
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.finalize = function(e3) {
    return Object.freeze(e3);
  }, t2.flattenToSet = function(e3) {
    const t3 = /* @__PURE__ */ new Set(), r2 = [e3];
    for (; r2.length > 0; ) for (const e4 of r2.pop()) Array.isArray(e4) ? r2.push(e4) : t3.add(e4);
    return t3;
  };
}, (e2) => {
  function t2(e3) {
    this.name = "BrowserslistError", this.message = e3, this.browserslist = true, Error.captureStackTrace && Error.captureStackTrace(this, t2);
  }
  t2.prototype = Error.prototype, e2.exports = t2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.getHighestUnreleased = function(e3, t3, r3) {
    return c(e3, t3, r3) === e3 ? t3 : e3;
  }, t2.getLowestImplementedVersion = function(e3, t3) {
    const r3 = e3[t3];
    return r3 || "android" !== t3 ? r3 : e3.chrome;
  }, t2.getLowestUnreleased = c, t2.isUnreleasedVersion = function(e3, t3) {
    const r3 = i2.unreleasedLabels[t3];
    return !!r3 && r3 === e3.toString().toLowerCase();
  }, t2.semverMin = l, t2.semverify = function(e3) {
    if ("string" == typeof e3 && n2.valid(e3)) return e3;
    a2.invariant("number" == typeof e3 || "string" == typeof e3 && o2.test(e3), `'${e3}' is not a valid version`), e3 = e3.toString();
    let t3 = 0, r3 = 0;
    for (; (t3 = e3.indexOf(".", t3 + 1)) > 0; ) r3++;
    return e3 + ".0".repeat(2 - r3);
  };
  var n2 = r2(23), s2 = r2(289), i2 = r2(139);
  const o2 = /^(\d+|\d+.\d+)$/, a2 = new s2.OptionValidator("@babel/helper-compilation-targets");
  function l(e3, t3) {
    return e3 && n2.lt(e3, t3) ? e3 : t3;
  }
  function c(e3, t3, r3) {
    const n3 = i2.unreleasedLabels[r3];
    return e3 === n3 ? t3 : t3 === n3 ? e3 : l(e3, t3);
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.unreleasedLabels = t2.browserNameMap = void 0, t2.unreleasedLabels = { safari: "tp" }, t2.browserNameMap = { and_chr: "chrome", and_ff: "firefox", android: "android", chrome: "chrome", edge: "edge", firefox: "firefox", ie: "ie", ie_mob: "ie", ios_saf: "ios", node: "node", deno: "deno", op_mob: "opera_mobile", opera: "opera", safari: "safari", samsung: "samsung" };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(39);
  class s2 extends Error {
    constructor(e3, t3) {
      super(e3), (0, n2.expectedError)(this), t3 && (0, n2.injectVirtualStackFrame)(this, t3);
    }
  }
  t2.default = s2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(33), s2 = r2(299), i2 = r2(300), o2 = r2(1);
  const { assignmentExpression: a2, booleanLiteral: l, callExpression: c, cloneNode: u, identifier: p, memberExpression: d, sequenceExpression: f, stringLiteral: h, thisExpression: m } = o2.types;
  {
    const e3 = r2(33);
    t2.environmentVisitor = e3.default, t2.skipAllButComputedKey = e3.skipAllButComputedKey;
  }
  function y(e3, t3, r3, n3) {
    e3 = u(e3);
    const s3 = t3 || n3 ? e3 : d(e3, p("prototype"));
    return c(r3.addHelper("getPrototypeOf"), [s3]);
  }
  const g = o2.traverse.visitors.merge([n2.default, { Super(e3, t3) {
    const { node: r3, parentPath: n3 } = e3;
    n3.isMemberExpression({ object: r3 }) && t3.handle(n3);
  } }]), b = o2.traverse.visitors.merge([n2.default, { Scopable(e3, t3) {
    let { refName: r3 } = t3;
    const n3 = e3.scope.getOwnBinding(r3);
    n3 && n3.identifier.name === r3 && e3.scope.rename(r3);
  } }]), v = { memoise(e3, t3) {
    const { scope: r3, node: n3 } = e3, { computed: s3, property: i3 } = n3;
    if (!s3) return;
    const o3 = r3.maybeGenerateMemoised(i3);
    o3 && this.memoiser.set(i3, o3, t3);
  }, prop(e3) {
    const { computed: t3, property: r3 } = e3.node;
    return this.memoiser.has(r3) ? u(this.memoiser.get(r3)) : t3 ? u(r3) : h(r3.name);
  }, get(e3) {
    return this._get(e3, this._getThisRefs());
  }, _get(e3, t3) {
    const r3 = y(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return c(this.file.addHelper("get"), [t3.memo ? f([t3.memo, r3]) : r3, this.prop(e3), t3.this]);
  }, _getThisRefs() {
    if (!this.isDerivedConstructor) return { this: m() };
    const e3 = this.scope.generateDeclaredUidIdentifier("thisSuper");
    return { memo: a2("=", e3, m()), this: u(e3) };
  }, set(e3, t3) {
    const r3 = this._getThisRefs(), n3 = y(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return c(this.file.addHelper("set"), [r3.memo ? f([r3.memo, n3]) : n3, this.prop(e3), t3, r3.this, l(e3.isInStrictMode())]);
  }, destructureSet(e3) {
    throw e3.buildCodeFrameError("Destructuring to a super field is not supported yet.");
  }, call(e3, t3) {
    const r3 = this._getThisRefs();
    return (0, i2.default)(this._get(e3, r3), u(r3.this), t3, false);
  }, optionalCall(e3, t3) {
    const r3 = this._getThisRefs();
    return (0, i2.default)(this._get(e3, r3), u(r3.this), t3, true);
  }, delete(e3) {
    return e3.node.computed ? f([c(this.file.addHelper("toPropertyKey"), [u(e3.node.property)]), o2.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : o2.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
  } }, E = Object.assign({}, v, { prop(e3) {
    const { property: t3 } = e3.node;
    return this.memoiser.has(t3) ? u(this.memoiser.get(t3)) : u(t3);
  }, get(e3) {
    const { isStatic: t3, getSuperRef: r3 } = this, { computed: n3 } = e3.node, s3 = this.prop(e3);
    let i3;
    var o3, a3;
    return i3 = t3 ? null != (o3 = r3()) ? o3 : d(p("Function"), p("prototype")) : d(null != (a3 = r3()) ? a3 : p("Object"), p("prototype")), d(i3, s3, n3);
  }, set(e3, t3) {
    const { computed: r3 } = e3.node, n3 = this.prop(e3);
    return a2("=", d(m(), n3, r3), t3);
  }, destructureSet(e3) {
    const { computed: t3 } = e3.node, r3 = this.prop(e3);
    return d(m(), r3, t3);
  }, call(e3, t3) {
    return (0, i2.default)(this.get(e3), m(), t3, false);
  }, optionalCall(e3, t3) {
    return (0, i2.default)(this.get(e3), m(), t3, true);
  } });
  t2.default = class {
    constructor(e3) {
      var t3;
      const r3 = e3.methodPath;
      this.methodPath = r3, this.isDerivedConstructor = r3.isClassMethod({ kind: "constructor" }) && !!e3.superRef, this.isStatic = r3.isObjectMethod() || r3.node.static || (null == r3.isStaticBlock ? void 0 : r3.isStaticBlock()), this.isPrivateMethod = r3.isPrivate() && r3.isMethod(), this.file = e3.file, this.constantSuper = null != (t3 = e3.constantSuper) ? t3 : e3.isLoose, this.opts = e3;
    }
    getObjectRef() {
      return u(this.opts.objectRef || this.opts.getObjectRef());
    }
    getSuperRef() {
      return this.opts.superRef ? u(this.opts.superRef) : this.opts.getSuperRef ? u(this.opts.getSuperRef()) : void 0;
    }
    replace() {
      this.opts.refToPreserve && this.methodPath.traverse(b, { refName: this.opts.refToPreserve.name });
      const e3 = this.constantSuper ? E : v;
      (0, s2.default)(this.methodPath, g, Object.assign({ file: this.file, scope: this.methodPath.scope, isDerivedConstructor: this.isDerivedConstructor, isStatic: this.isStatic, isPrivateMethod: this.isPrivateMethod, getObjectRef: this.getObjectRef.bind(this), getSuperRef: this.getSuperRef.bind(this), boundGet: e3.get }, e3));
    }
  };
}, (e2, t2, r2) => {
  e2.exports = r2(503);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true });
  var n2 = r2(309), s2 = r2(142);
  const i2 = Symbol(""), o2 = Symbol(""), a2 = Symbol(""), l = Symbol(""), c = Symbol(""), u = Symbol(""), p = Symbol(""), d = Symbol(""), f = Symbol(""), h = Symbol("");
  n2.registerRuntimeHelpers({ [i2]: "vModelRadio", [o2]: "vModelCheckbox", [a2]: "vModelText", [l]: "vModelSelect", [c]: "vModelDynamic", [u]: "withModifiers", [p]: "withKeys", [d]: "vShow", [f]: "Transition", [h]: "TransitionGroup" });
  const m = { parseMode: "html", isVoidTag: s2.isVoidTag, isNativeTag: (e3) => s2.isHTMLTag(e3) || s2.isSVGTag(e3) || s2.isMathMLTag(e3), isPreTag: (e3) => "pre" === e3, decodeEntities: void 0, isBuiltInComponent: (e3) => "Transition" === e3 || "transition" === e3 ? f : "TransitionGroup" === e3 || "transition-group" === e3 ? h : void 0, getNamespace(e3, t3, r3) {
    let n3 = t3 ? t3.ns : r3;
    if (t3 && 2 === n3) if ("annotation-xml" === t3.tag) {
      if ("svg" === e3) return 1;
      t3.props.some((e4) => 6 === e4.type && "encoding" === e4.name && null != e4.value && ("text/html" === e4.value.content || "application/xhtml+xml" === e4.value.content)) && (n3 = 0);
    } else /^m(?:[ions]|text)$/.test(t3.tag) && "mglyph" !== e3 && "malignmark" !== e3 && (n3 = 0);
    else t3 && 1 === n3 && ("foreignObject" !== t3.tag && "desc" !== t3.tag && "title" !== t3.tag || (n3 = 0));
    if (0 === n3) {
      if ("svg" === e3) return 1;
      if ("math" === e3) return 2;
    }
    return n3;
  } }, y = (e3) => {
    1 === e3.type && e3.props.forEach((t3, r3) => {
      6 === t3.type && "style" === t3.name && t3.value && (e3.props[r3] = { type: 7, name: "bind", arg: n2.createSimpleExpression("style", true, t3.loc), exp: g(t3.value.content, t3.loc), modifiers: [], loc: t3.loc });
    });
  }, g = (e3, t3) => {
    const r3 = s2.parseStringStyle(e3);
    return n2.createSimpleExpression(JSON.stringify(r3), false, t3, 3);
  };
  function b(e3, t3) {
    return n2.createCompilerError(e3, t3, v);
  }
  const v = { 53: "v-html is missing expression.", 54: "v-html will override element children.", 55: "v-text is missing expression.", 56: "v-text will override element children.", 57: "v-model can only be used on <input>, <textarea> and <select> elements.", 58: "v-model argument is not supported on plain elements.", 59: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.", 60: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.", 61: "v-show is missing expression.", 62: "<Transition> expects exactly one child element or component.", 63: "Tags with side effect (<script> and <style>) are ignored in client component templates." }, E = s2.makeMap("passive,once,capture"), S = s2.makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"), x = s2.makeMap("left,right"), T = s2.makeMap("onkeyup,onkeydown,onkeypress", true), w = (e3, t3) => n2.isStaticExp(e3) && "onclick" === e3.content.toLowerCase() ? n2.createSimpleExpression(t3, true) : 4 !== e3.type ? n2.createCompoundExpression(["(", e3, `) === "onClick" ? "${t3}" : (`, e3, ")"]) : e3, P = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g, A = (e3, t3, r3) => {
    if (t3.scopes.vSlot > 0) return;
    let s3 = 0, i3 = 0;
    const o3 = [], a3 = (r4) => {
      if (s3 >= 20 || i3 >= 5) {
        const s4 = n2.createCallExpression(t3.helper(n2.CREATE_STATIC), [JSON.stringify(o3.map((e4) => D(e4, t3)).join("")).replace(P, '" + $1 + "'), String(o3.length)]);
        if (_(o3[0], s4, t3), o3.length > 1) {
          for (let e4 = 1; e4 < o3.length; e4++) _(o3[e4], null, t3);
          const n3 = o3.length - 1;
          return e3.splice(r4 - o3.length + 1, n3), n3;
        }
      }
      return 0;
    };
    let l2 = 0;
    for (; l2 < e3.length; l2++) {
      const t4 = e3[l2];
      if (C(t4)) {
        const e4 = t4, r4 = N(e4);
        if (r4) {
          s3 += r4[0], i3 += r4[1], o3.push(e4);
          continue;
        }
      }
      l2 -= a3(l2), s3 = 0, i3 = 0, o3.length = 0;
    }
    a3(l2);
  }, C = (e3) => (1 === e3.type && 0 === e3.tagType || 12 == e3.type) && e3.codegenNode && 4 === e3.codegenNode.type && e3.codegenNode.hoisted, O = /^(data|aria)-/, I = (e3, t3) => (0 === t3 ? s2.isKnownHtmlAttr(e3) : 1 === t3 && s2.isKnownSvgAttr(e3)) || O.test(e3), _ = (e3, t3, r3) => {
    const n3 = e3.codegenNode.hoisted;
    r3.hoists[r3.hoists.indexOf(n3)] = t3;
  }, k = s2.makeMap("caption,thead,tr,th,tbody,td,tfoot,colgroup,col");
  function N(e3) {
    if (1 === e3.type && k(e3.tag)) return false;
    if (12 === e3.type) return [1, 0];
    let t3 = 1, r3 = e3.props.length > 0 ? 1 : 0, n3 = false;
    const s3 = () => (n3 = true, false);
    return !!function e4(i3) {
      for (let e5 = 0; e5 < i3.props.length; e5++) {
        const t4 = i3.props[e5];
        if (6 === t4.type && !I(t4.name, i3.ns)) return s3();
        if (7 === t4.type && "bind" === t4.name) {
          if (t4.arg && (8 === t4.arg.type || t4.arg.isStatic && !I(t4.arg.content, i3.ns))) return s3();
          if (t4.exp && (8 === t4.exp.type || t4.exp.constType < 3)) return s3();
        }
      }
      for (let s4 = 0; s4 < i3.children.length; s4++) {
        t3++;
        const o3 = i3.children[s4];
        if (1 === o3.type && (o3.props.length > 0 && r3++, e4(o3), n3)) return false;
      }
      return true;
    }(e3) && [t3, r3];
  }
  function D(e3, t3) {
    if (s2.isString(e3)) return e3;
    if (s2.isSymbol(e3)) return "";
    switch (e3.type) {
      case 1:
        return function(e4, t4) {
          let r3 = `<${e4.tag}`, n3 = "";
          for (let t5 = 0; t5 < e4.props.length; t5++) {
            const i3 = e4.props[t5];
            if (6 === i3.type) r3 += ` ${i3.name}`, i3.value && (r3 += `="${s2.escapeHtml(i3.value.content)}"`);
            else if (7 === i3.type) if ("bind" === i3.name) {
              const e5 = i3.exp;
              if ("_" === e5.content[0]) {
                r3 += ` ${i3.arg.content}="__VUE_EXP_START__${e5.content}__VUE_EXP_END__"`;
                continue;
              }
              if (s2.isBooleanAttr(i3.arg.content) && "false" === e5.content) continue;
              let t6 = j(e5);
              if (null != t6) {
                const e6 = i3.arg && i3.arg.content;
                "class" === e6 ? t6 = s2.normalizeClass(t6) : "style" === e6 && (t6 = s2.stringifyStyle(s2.normalizeStyle(t6))), r3 += ` ${i3.arg.content}="${s2.escapeHtml(t6)}"`;
              }
            } else "html" === i3.name ? n3 = j(i3.exp) : "text" === i3.name && (n3 = s2.escapeHtml(s2.toDisplayString(j(i3.exp))));
          }
          if (t4.scopeId && (r3 += ` ${t4.scopeId}`), r3 += ">", n3) r3 += n3;
          else for (let n4 = 0; n4 < e4.children.length; n4++) r3 += D(e4.children[n4], t4);
          return s2.isVoidTag(e4.tag) || (r3 += `</${e4.tag}>`), r3;
        }(e3, t3);
      case 2:
        return s2.escapeHtml(e3.content);
      case 3:
        return `<!--${s2.escapeHtml(e3.content)}-->`;
      case 5:
        return s2.escapeHtml(s2.toDisplayString(j(e3.content)));
      case 8:
        return s2.escapeHtml(j(e3));
      case 12:
        return D(e3.content, t3);
      default:
        return "";
    }
  }
  function j(e3) {
    if (4 === e3.type) return new Function(`return (${e3.content})`)();
    {
      let t3 = "";
      return e3.children.forEach((e4) => {
        s2.isString(e4) || s2.isSymbol(e4) || (2 === e4.type ? t3 += e4.content : 5 === e4.type ? t3 += s2.toDisplayString(j(e4.content)) : t3 += j(e4));
      }), t3;
    }
  }
  const L = (e3, t3) => {
    1 !== e3.type || 0 !== e3.tagType || "script" !== e3.tag && "style" !== e3.tag || t3.removeNode();
  }, M = [y], B = { cloak: n2.noopDirectiveTransform, html: (e3, t3, r3) => {
    const { exp: s3, loc: i3 } = e3;
    return s3 || r3.onError(b(53, i3)), t3.children.length && (r3.onError(b(54, i3)), t3.children.length = 0), { props: [n2.createObjectProperty(n2.createSimpleExpression("innerHTML", true, i3), s3 || n2.createSimpleExpression("", true))] };
  }, text: (e3, t3, r3) => {
    const { exp: s3, loc: i3 } = e3;
    return s3 || r3.onError(b(55, i3)), t3.children.length && (r3.onError(b(56, i3)), t3.children.length = 0), { props: [n2.createObjectProperty(n2.createSimpleExpression("textContent", true), s3 ? n2.getConstantType(s3, r3) > 0 ? s3 : n2.createCallExpression(r3.helperString(n2.TO_DISPLAY_STRING), [s3], i3) : n2.createSimpleExpression("", true))] };
  }, model: (e3, t3, r3) => {
    const s3 = n2.transformModel(e3, t3, r3);
    if (!s3.props.length || 1 === t3.tagType) return s3;
    e3.arg && r3.onError(b(58, e3.arg.loc));
    const { tag: u2 } = t3, p2 = r3.isCustomElement(u2);
    if ("input" === u2 || "textarea" === u2 || "select" === u2 || p2) {
      let d2 = a2, f2 = false;
      if ("input" === u2 || p2) {
        const s4 = n2.findProp(t3, "type");
        if (s4) {
          if (7 === s4.type) d2 = c;
          else if (s4.value) switch (s4.value.content) {
            case "radio":
              d2 = i2;
              break;
            case "checkbox":
              d2 = o2;
              break;
            case "file":
              f2 = true, r3.onError(b(59, e3.loc));
          }
        } else n2.hasDynamicKeyVBind(t3) && (d2 = c);
      } else "select" === u2 && (d2 = l);
      f2 || (s3.needRuntime = r3.helper(d2));
    } else r3.onError(b(57, e3.loc));
    return s3.props = s3.props.filter((e4) => !(4 === e4.key.type && "modelValue" === e4.key.content)), s3;
  }, on: (e3, t3, r3) => n2.transformOn(e3, t3, r3, (t4) => {
    const { modifiers: i3 } = e3;
    if (!i3.length) return t4;
    let { key: o3, value: a3 } = t4.props[0];
    const { keyModifiers: l2, nonKeyModifiers: c2, eventOptionModifiers: d2 } = ((e4, t5, r4, s3) => {
      const i4 = [], o4 = [], a4 = [];
      for (let l3 = 0; l3 < t5.length; l3++) {
        const c3 = t5[l3];
        "native" === c3 && n2.checkCompatEnabled("COMPILER_V_ON_NATIVE", r4, s3) || E(c3) ? a4.push(c3) : x(c3) ? n2.isStaticExp(e4) ? T(e4.content) ? i4.push(c3) : o4.push(c3) : (i4.push(c3), o4.push(c3)) : S(c3) ? o4.push(c3) : i4.push(c3);
      }
      return { keyModifiers: i4, nonKeyModifiers: o4, eventOptionModifiers: a4 };
    })(o3, i3, r3, e3.loc);
    if (c2.includes("right") && (o3 = w(o3, "onContextmenu")), c2.includes("middle") && (o3 = w(o3, "onMouseup")), c2.length && (a3 = n2.createCallExpression(r3.helper(u), [a3, JSON.stringify(c2)])), !l2.length || n2.isStaticExp(o3) && !T(o3.content) || (a3 = n2.createCallExpression(r3.helper(p), [a3, JSON.stringify(l2)])), d2.length) {
      const e4 = d2.map(s2.capitalize).join("");
      o3 = n2.isStaticExp(o3) ? n2.createSimpleExpression(`${o3.content}${e4}`, true) : n2.createCompoundExpression(["(", o3, `) + "${e4}"`]);
    }
    return { props: [n2.createObjectProperty(o3, a3)] };
  }), show: (e3, t3, r3) => {
    const { exp: n3, loc: s3 } = e3;
    return n3 || r3.onError(b(61, s3)), { props: [], needRuntime: r3.helper(d) };
  } };
  t2.DOMDirectiveTransforms = B, t2.DOMErrorCodes = { X_V_HTML_NO_EXPRESSION: 53, 53: "X_V_HTML_NO_EXPRESSION", X_V_HTML_WITH_CHILDREN: 54, 54: "X_V_HTML_WITH_CHILDREN", X_V_TEXT_NO_EXPRESSION: 55, 55: "X_V_TEXT_NO_EXPRESSION", X_V_TEXT_WITH_CHILDREN: 56, 56: "X_V_TEXT_WITH_CHILDREN", X_V_MODEL_ON_INVALID_ELEMENT: 57, 57: "X_V_MODEL_ON_INVALID_ELEMENT", X_V_MODEL_ARG_ON_ELEMENT: 58, 58: "X_V_MODEL_ARG_ON_ELEMENT", X_V_MODEL_ON_FILE_INPUT_ELEMENT: 59, 59: "X_V_MODEL_ON_FILE_INPUT_ELEMENT", X_V_MODEL_UNNECESSARY_VALUE: 60, 60: "X_V_MODEL_UNNECESSARY_VALUE", X_V_SHOW_NO_EXPRESSION: 61, 61: "X_V_SHOW_NO_EXPRESSION", X_TRANSITION_INVALID_CHILDREN: 62, 62: "X_TRANSITION_INVALID_CHILDREN", X_IGNORED_SIDE_EFFECT_TAG: 63, 63: "X_IGNORED_SIDE_EFFECT_TAG", __EXTEND_POINT__: 64, 64: "__EXTEND_POINT__" }, t2.DOMErrorMessages = v, t2.DOMNodeTransforms = M, t2.TRANSITION = f, t2.TRANSITION_GROUP = h, t2.V_MODEL_CHECKBOX = o2, t2.V_MODEL_DYNAMIC = c, t2.V_MODEL_RADIO = i2, t2.V_MODEL_SELECT = l, t2.V_MODEL_TEXT = a2, t2.V_ON_WITH_KEYS = p, t2.V_ON_WITH_MODIFIERS = u, t2.V_SHOW = d, t2.compile = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return n2.baseCompile(e3, s2.extend({}, m, t3, { nodeTransforms: [L, ...M, ...t3.nodeTransforms || []], directiveTransforms: s2.extend({}, B, t3.directiveTransforms || {}), transformHoist: A }));
  }, t2.createDOMCompilerError = b, t2.parse = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return n2.baseParse(e3, s2.extend({}, m, t3));
  }, t2.parserOptions = m, t2.transformStyle = y, Object.keys(n2).forEach(function(e3) {
    "default" === e3 || Object.prototype.hasOwnProperty.call(t2, e3) || (t2[e3] = n2[e3]);
  });
}, (e2, t2, r2) => {
  var n2 = r2(86), s2 = Object.prototype.hasOwnProperty, i2 = Array.isArray, o2 = function() {
    for (var e3 = [], t3 = 0; t3 < 256; ++t3) e3.push("%" + ((t3 < 16 ? "0" : "") + t3.toString(16)).toUpperCase());
    return e3;
  }(), a2 = function(e3, t3) {
    for (var r3 = t3 && t3.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, n3 = 0; n3 < e3.length; ++n3) void 0 !== e3[n3] && (r3[n3] = e3[n3]);
    return r3;
  };
  e2.exports = { arrayToObject: a2, assign: function(e3, t3) {
    return Object.keys(t3).reduce(function(e4, r3) {
      return e4[r3] = t3[r3], e4;
    }, e3);
  }, combine: function(e3, t3) {
    return [].concat(e3, t3);
  }, compact: function(e3) {
    for (var t3 = [{ obj: { o: e3 }, prop: "o" }], r3 = [], n3 = 0; n3 < t3.length; ++n3) for (var s3 = t3[n3], o3 = s3.obj[s3.prop], a3 = Object.keys(o3), l = 0; l < a3.length; ++l) {
      var c = a3[l], u = o3[c];
      "object" == typeof u && null !== u && -1 === r3.indexOf(u) && (t3.push({ obj: o3, prop: c }), r3.push(u));
    }
    return function(e4) {
      for (; e4.length > 1; ) {
        var t4 = e4.pop(), r4 = t4.obj[t4.prop];
        if (i2(r4)) {
          for (var n4 = [], s4 = 0; s4 < r4.length; ++s4) void 0 !== r4[s4] && n4.push(r4[s4]);
          t4.obj[t4.prop] = n4;
        }
      }
    }(t3), e3;
  }, decode: function(e3, t3, r3) {
    var n3 = e3.replace(/\+/g, " ");
    if ("iso-8859-1" === r3) return n3.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(n3);
    } catch (e4) {
      return n3;
    }
  }, encode: function(e3, t3, r3, s3, i3) {
    if (0 === e3.length) return e3;
    var a3 = e3;
    if ("symbol" == typeof e3 ? a3 = Symbol.prototype.toString.call(e3) : "string" != typeof e3 && (a3 = String(e3)), "iso-8859-1" === r3) return escape(a3).replace(/%u[0-9a-f]{4}/gi, function(e4) {
      return "%26%23" + parseInt(e4.slice(2), 16) + "%3B";
    });
    for (var l = "", c = 0; c < a3.length; ++c) {
      var u = a3.charCodeAt(c);
      45 === u || 46 === u || 95 === u || 126 === u || u >= 48 && u <= 57 || u >= 65 && u <= 90 || u >= 97 && u <= 122 || i3 === n2.RFC1738 && (40 === u || 41 === u) ? l += a3.charAt(c) : u < 128 ? l += o2[u] : u < 2048 ? l += o2[192 | u >> 6] + o2[128 | 63 & u] : u < 55296 || u >= 57344 ? l += o2[224 | u >> 12] + o2[128 | u >> 6 & 63] + o2[128 | 63 & u] : (c += 1, u = 65536 + ((1023 & u) << 10 | 1023 & a3.charCodeAt(c)), l += o2[240 | u >> 18] + o2[128 | u >> 12 & 63] + o2[128 | u >> 6 & 63] + o2[128 | 63 & u]);
    }
    return l;
  }, isBuffer: function(e3) {
    return !(!e3 || "object" != typeof e3 || !(e3.constructor && e3.constructor.isBuffer && e3.constructor.isBuffer(e3)));
  }, isRegExp: function(e3) {
    return "[object RegExp]" === Object.prototype.toString.call(e3);
  }, maybeMap: function(e3, t3) {
    if (i2(e3)) {
      for (var r3 = [], n3 = 0; n3 < e3.length; n3 += 1) r3.push(t3(e3[n3]));
      return r3;
    }
    return t3(e3);
  }, merge: function e3(t3, r3, n3) {
    if (!r3) return t3;
    if ("object" != typeof r3) {
      if (i2(t3)) t3.push(r3);
      else {
        if (!t3 || "object" != typeof t3) return [t3, r3];
        (n3 && (n3.plainObjects || n3.allowPrototypes) || !s2.call(Object.prototype, r3)) && (t3[r3] = true);
      }
      return t3;
    }
    if (!t3 || "object" != typeof t3) return [t3].concat(r3);
    var o3 = t3;
    return i2(t3) && !i2(r3) && (o3 = a2(t3, n3)), i2(t3) && i2(r3) ? (r3.forEach(function(r4, i3) {
      if (s2.call(t3, i3)) {
        var o4 = t3[i3];
        o4 && "object" == typeof o4 && r4 && "object" == typeof r4 ? t3[i3] = e3(o4, r4, n3) : t3.push(r4);
      } else t3[i3] = r4;
    }), t3) : Object.keys(r3).reduce(function(t4, i3) {
      var o4 = r3[i3];
      return s2.call(t4, i3) ? t4[i3] = e3(t4[i3], o4, n3) : t4[i3] = o4, t4;
    }, o3);
  } };
}, (e2) => {
  e2.exports.isClean = Symbol("isClean"), e2.exports.my = Symbol("my");
}, (e2) => {
  const t2 = { after: "\n", beforeClose: "\n", beforeComment: "\n", beforeDecl: "\n", beforeOpen: " ", beforeRule: "\n", colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: false };
  class r2 {
    constructor(e3) {
      this.builder = e3;
    }
    atrule(e3, t3) {
      let r3 = "@" + e3.name, n2 = e3.params ? this.rawValue(e3, "params") : "";
      if (void 0 !== e3.raws.afterName ? r3 += e3.raws.afterName : n2 && (r3 += " "), e3.nodes) this.block(e3, r3 + n2);
      else {
        let s2 = (e3.raws.between || "") + (t3 ? ";" : "");
        this.builder(r3 + n2 + s2, e3);
      }
    }
    beforeAfter(e3, t3) {
      let r3;
      r3 = "decl" === e3.type ? this.raw(e3, null, "beforeDecl") : "comment" === e3.type ? this.raw(e3, null, "beforeComment") : "before" === t3 ? this.raw(e3, null, "beforeRule") : this.raw(e3, null, "beforeClose");
      let n2 = e3.parent, s2 = 0;
      for (; n2 && "root" !== n2.type; ) s2 += 1, n2 = n2.parent;
      if (r3.includes("\n")) {
        let t4 = this.raw(e3, null, "indent");
        if (t4.length) for (let e4 = 0; e4 < s2; e4++) r3 += t4;
      }
      return r3;
    }
    block(e3, t3) {
      let r3, n2 = this.raw(e3, "between", "beforeOpen");
      this.builder(t3 + n2 + "{", e3, "start"), e3.nodes && e3.nodes.length ? (this.body(e3), r3 = this.raw(e3, "after")) : r3 = this.raw(e3, "after", "emptyBody"), r3 && this.builder(r3), this.builder("}", e3, "end");
    }
    body(e3) {
      let t3 = e3.nodes.length - 1;
      for (; t3 > 0 && "comment" === e3.nodes[t3].type; ) t3 -= 1;
      let r3 = this.raw(e3, "semicolon");
      for (let n2 = 0; n2 < e3.nodes.length; n2++) {
        let s2 = e3.nodes[n2], i2 = this.raw(s2, "before");
        i2 && this.builder(i2), this.stringify(s2, t3 !== n2 || r3);
      }
    }
    comment(e3) {
      let t3 = this.raw(e3, "left", "commentLeft"), r3 = this.raw(e3, "right", "commentRight");
      this.builder("/*" + t3 + e3.text + r3 + "*/", e3);
    }
    decl(e3, t3) {
      let r3 = this.raw(e3, "between", "colon"), n2 = e3.prop + r3 + this.rawValue(e3, "value");
      e3.important && (n2 += e3.raws.important || " !important"), t3 && (n2 += ";"), this.builder(n2, e3);
    }
    document(e3) {
      this.body(e3);
    }
    raw(e3, r3, n2) {
      let s2;
      if (n2 || (n2 = r3), r3 && (s2 = e3.raws[r3], void 0 !== s2)) return s2;
      let i2 = e3.parent;
      if ("before" === n2) {
        if (!i2 || "root" === i2.type && i2.first === e3) return "";
        if (i2 && "document" === i2.type) return "";
      }
      if (!i2) return t2[n2];
      let o2 = e3.root();
      if (o2.rawCache || (o2.rawCache = {}), void 0 !== o2.rawCache[n2]) return o2.rawCache[n2];
      if ("before" === n2 || "after" === n2) return this.beforeAfter(e3, n2);
      {
        let t3 = "raw" + ((a2 = n2)[0].toUpperCase() + a2.slice(1));
        this[t3] ? s2 = this[t3](o2, e3) : o2.walk((e4) => {
          if (s2 = e4.raws[r3], void 0 !== s2) return false;
        });
      }
      var a2;
      return void 0 === s2 && (s2 = t2[n2]), o2.rawCache[n2] = s2, s2;
    }
    rawBeforeClose(e3) {
      let t3;
      return e3.walk((e4) => {
        if (e4.nodes && e4.nodes.length > 0 && void 0 !== e4.raws.after) return t3 = e4.raws.after, t3.includes("\n") && (t3 = t3.replace(/[^\n]+$/, "")), false;
      }), t3 && (t3 = t3.replace(/\S/g, "")), t3;
    }
    rawBeforeComment(e3, t3) {
      let r3;
      return e3.walkComments((e4) => {
        if (void 0 !== e4.raws.before) return r3 = e4.raws.before, r3.includes("\n") && (r3 = r3.replace(/[^\n]+$/, "")), false;
      }), void 0 === r3 ? r3 = this.raw(t3, null, "beforeDecl") : r3 && (r3 = r3.replace(/\S/g, "")), r3;
    }
    rawBeforeDecl(e3, t3) {
      let r3;
      return e3.walkDecls((e4) => {
        if (void 0 !== e4.raws.before) return r3 = e4.raws.before, r3.includes("\n") && (r3 = r3.replace(/[^\n]+$/, "")), false;
      }), void 0 === r3 ? r3 = this.raw(t3, null, "beforeRule") : r3 && (r3 = r3.replace(/\S/g, "")), r3;
    }
    rawBeforeOpen(e3) {
      let t3;
      return e3.walk((e4) => {
        if ("decl" !== e4.type && (t3 = e4.raws.between, void 0 !== t3)) return false;
      }), t3;
    }
    rawBeforeRule(e3) {
      let t3;
      return e3.walk((r3) => {
        if (r3.nodes && (r3.parent !== e3 || e3.first !== r3) && void 0 !== r3.raws.before) return t3 = r3.raws.before, t3.includes("\n") && (t3 = t3.replace(/[^\n]+$/, "")), false;
      }), t3 && (t3 = t3.replace(/\S/g, "")), t3;
    }
    rawColon(e3) {
      let t3;
      return e3.walkDecls((e4) => {
        if (void 0 !== e4.raws.between) return t3 = e4.raws.between.replace(/[^\s:]/g, ""), false;
      }), t3;
    }
    rawEmptyBody(e3) {
      let t3;
      return e3.walk((e4) => {
        if (e4.nodes && 0 === e4.nodes.length && (t3 = e4.raws.after, void 0 !== t3)) return false;
      }), t3;
    }
    rawIndent(e3) {
      if (e3.raws.indent) return e3.raws.indent;
      let t3;
      return e3.walk((r3) => {
        let n2 = r3.parent;
        if (n2 && n2 !== e3 && n2.parent && n2.parent === e3 && void 0 !== r3.raws.before) {
          let e4 = r3.raws.before.split("\n");
          return t3 = e4[e4.length - 1], t3 = t3.replace(/\S/g, ""), false;
        }
      }), t3;
    }
    rawSemicolon(e3) {
      let t3;
      return e3.walk((e4) => {
        if (e4.nodes && e4.nodes.length && "decl" === e4.last.type && (t3 = e4.raws.semicolon, void 0 !== t3)) return false;
      }), t3;
    }
    rawValue(e3, t3) {
      let r3 = e3[t3], n2 = e3.raws[t3];
      return n2 && n2.value === r3 ? n2.raw : r3;
    }
    root(e3) {
      this.body(e3), e3.raws.after && this.builder(e3.raws.after);
    }
    rule(e3) {
      this.block(e3, this.rawValue(e3, "selector")), e3.raws.ownSemicolon && this.builder(e3.raws.ownSemicolon, e3, "end");
    }
    stringify(e3, t3) {
      if (!this[e3.type]) throw new Error("Unknown AST node type " + e3.type + ". Maybe you need to change PostCSS stringifier.");
      this[e3.type](e3, t3);
    }
  }
  e2.exports = r2, r2.default = r2;
}, (e2, t2, r2) => {
  let { isClean: n2, my: s2 } = r2(145), i2 = r2(148), o2 = r2(54), a2 = r2(24), l = r2(88), c = (r2(152), r2(89)), u = r2(90), p = r2(40);
  const d = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, f = { AtRule: true, AtRuleExit: true, Comment: true, CommentExit: true, Declaration: true, DeclarationExit: true, Document: true, DocumentExit: true, Once: true, OnceExit: true, postcssPlugin: true, prepare: true, Root: true, RootExit: true, Rule: true, RuleExit: true }, h = { Once: true, postcssPlugin: true, prepare: true }, m = 0;
  function y(e3) {
    return "object" == typeof e3 && "function" == typeof e3.then;
  }
  function g(e3) {
    let t3 = false, r3 = d[e3.type];
    return "decl" === e3.type ? t3 = e3.prop.toLowerCase() : "atrule" === e3.type && (t3 = e3.name.toLowerCase()), t3 && e3.append ? [r3, r3 + "-" + t3, m, r3 + "Exit", r3 + "Exit-" + t3] : t3 ? [r3, r3 + "-" + t3, r3 + "Exit", r3 + "Exit-" + t3] : e3.append ? [r3, m, r3 + "Exit"] : [r3, r3 + "Exit"];
  }
  function b(e3) {
    let t3;
    return t3 = "document" === e3.type ? ["Document", m, "DocumentExit"] : "root" === e3.type ? ["Root", m, "RootExit"] : g(e3), { eventIndex: 0, events: t3, iterator: 0, node: e3, visitorIndex: 0, visitors: [] };
  }
  function v(e3) {
    return e3[n2] = false, e3.nodes && e3.nodes.forEach((e4) => v(e4)), e3;
  }
  let E = {};
  class S {
    constructor(e3, t3, r3) {
      let n3;
      if (this.stringified = false, this.processed = false, "object" != typeof t3 || null === t3 || "root" !== t3.type && "document" !== t3.type) if (t3 instanceof S || t3 instanceof c) n3 = v(t3.root), t3.map && (void 0 === r3.map && (r3.map = {}), r3.map.inline || (r3.map.inline = false), r3.map.prev = t3.map);
      else {
        let e4 = u;
        r3.syntax && (e4 = r3.syntax.parse), r3.parser && (e4 = r3.parser), e4.parse && (e4 = e4.parse);
        try {
          n3 = e4(t3, r3);
        } catch (e5) {
          this.processed = true, this.error = e5;
        }
        n3 && !n3[s2] && a2.rebuild(n3);
      }
      else n3 = v(t3);
      this.result = new c(e3, n3, r3), this.helpers = { ...E, postcss: E, result: this.result }, this.plugins = this.processor.plugins.map((e4) => "object" == typeof e4 && e4.prepare ? { ...e4, ...e4.prepare(this.result) } : e4);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(e3) {
      return this.async().catch(e3);
    }
    finally(e3) {
      return this.async().then(e3, e3);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(e3, t3) {
      let r3 = this.result.lastPlugin;
      try {
        t3 && t3.addToError(e3), this.error = e3, "CssSyntaxError" !== e3.name || e3.plugin ? r3.postcssVersion : (e3.plugin = r3.postcssPlugin, e3.setMessage());
      } catch (e4) {
        console && console.error;
      }
      return e3;
    }
    prepareVisitors() {
      this.listeners = {};
      let e3 = (e4, t3, r3) => {
        this.listeners[t3] || (this.listeners[t3] = []), this.listeners[t3].push([e4, r3]);
      };
      for (let t3 of this.plugins) if ("object" == typeof t3) for (let r3 in t3) {
        if (!f[r3] && /^[A-Z]/.test(r3)) throw new Error(`Unknown event ${r3} in ${t3.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
        if (!h[r3]) if ("object" == typeof t3[r3]) for (let n3 in t3[r3]) e3(t3, "*" === n3 ? r3 : r3 + "-" + n3.toLowerCase(), t3[r3][n3]);
        else "function" == typeof t3[r3] && e3(t3, r3, t3[r3]);
      }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let e3 = 0; e3 < this.plugins.length; e3++) {
        let t3 = this.plugins[e3], r3 = this.runOnRoot(t3);
        if (y(r3)) try {
          await r3;
        } catch (e4) {
          throw this.handleError(e4);
        }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e3 = this.result.root;
        for (; !e3[n2]; ) {
          e3[n2] = true;
          let t3 = [b(e3)];
          for (; t3.length > 0; ) {
            let e4 = this.visitTick(t3);
            if (y(e4)) try {
              await e4;
            } catch (e5) {
              let r3 = t3[t3.length - 1].node;
              throw this.handleError(e5, r3);
            }
          }
        }
        if (this.listeners.OnceExit) for (let [t3, r3] of this.listeners.OnceExit) {
          this.result.lastPlugin = t3;
          try {
            if ("document" === e3.type) {
              let t4 = e3.nodes.map((e4) => r3(e4, this.helpers));
              await Promise.all(t4);
            } else await r3(e3, this.helpers);
          } catch (e4) {
            throw this.handleError(e4);
          }
        }
      }
      return this.processed = true, this.stringify();
    }
    runOnRoot(e3) {
      this.result.lastPlugin = e3;
      try {
        if ("object" == typeof e3 && e3.Once) {
          if ("document" === this.result.root.type) {
            let t3 = this.result.root.nodes.map((t4) => e3.Once(t4, this.helpers));
            return y(t3[0]) ? Promise.all(t3) : t3;
          }
          return e3.Once(this.result.root, this.helpers);
        }
        if ("function" == typeof e3) return e3(this.result.root, this.result);
      } catch (e4) {
        throw this.handleError(e4);
      }
    }
    stringify() {
      if (this.error) throw this.error;
      if (this.stringified) return this.result;
      this.stringified = true, this.sync();
      let e3 = this.result.opts, t3 = o2;
      e3.syntax && (t3 = e3.syntax.stringify), e3.stringifier && (t3 = e3.stringifier), t3.stringify && (t3 = t3.stringify);
      let r3 = new i2(t3, this.result.root, this.result.opts).generate();
      return this.result.css = r3[0], this.result.map = r3[1], this.result;
    }
    sync() {
      if (this.error) throw this.error;
      if (this.processed) return this.result;
      if (this.processed = true, this.processing) throw this.getAsyncError();
      for (let e3 of this.plugins) if (y(this.runOnRoot(e3))) throw this.getAsyncError();
      if (this.prepareVisitors(), this.hasListener) {
        let e3 = this.result.root;
        for (; !e3[n2]; ) e3[n2] = true, this.walkSync(e3);
        if (this.listeners.OnceExit) if ("document" === e3.type) for (let t3 of e3.nodes) this.visitSync(this.listeners.OnceExit, t3);
        else this.visitSync(this.listeners.OnceExit, e3);
      }
      return this.result;
    }
    then(e3, t3) {
      return this.async().then(e3, t3);
    }
    toString() {
      return this.css;
    }
    visitSync(e3, t3) {
      for (let [r3, n3] of e3) {
        let e4;
        this.result.lastPlugin = r3;
        try {
          e4 = n3(t3, this.helpers);
        } catch (e5) {
          throw this.handleError(e5, t3.proxyOf);
        }
        if ("root" !== t3.type && "document" !== t3.type && !t3.parent) return true;
        if (y(e4)) throw this.getAsyncError();
      }
    }
    visitTick(e3) {
      let t3 = e3[e3.length - 1], { node: r3, visitors: s3 } = t3;
      if ("root" !== r3.type && "document" !== r3.type && !r3.parent) return void e3.pop();
      if (s3.length > 0 && t3.visitorIndex < s3.length) {
        let [e4, n3] = s3[t3.visitorIndex];
        t3.visitorIndex += 1, t3.visitorIndex === s3.length && (t3.visitors = [], t3.visitorIndex = 0), this.result.lastPlugin = e4;
        try {
          return n3(r3.toProxy(), this.helpers);
        } catch (e5) {
          throw this.handleError(e5, r3);
        }
      }
      if (0 !== t3.iterator) {
        let s4, i4 = t3.iterator;
        for (; s4 = r3.nodes[r3.indexes[i4]]; ) if (r3.indexes[i4] += 1, !s4[n2]) return s4[n2] = true, void e3.push(b(s4));
        t3.iterator = 0, delete r3.indexes[i4];
      }
      let i3 = t3.events;
      for (; t3.eventIndex < i3.length; ) {
        let e4 = i3[t3.eventIndex];
        if (t3.eventIndex += 1, e4 === m) return void (r3.nodes && r3.nodes.length && (r3[n2] = true, t3.iterator = r3.getIterator()));
        if (this.listeners[e4]) return void (t3.visitors = this.listeners[e4]);
      }
      e3.pop();
    }
    walkSync(e3) {
      e3[n2] = true;
      let t3 = g(e3);
      for (let r3 of t3) if (r3 === m) e3.nodes && e3.each((e4) => {
        e4[n2] || this.walkSync(e4);
      });
      else {
        let t4 = this.listeners[r3];
        if (t4 && this.visitSync(t4, e3.toProxy())) return;
      }
    }
    warnings() {
      return this.sync().warnings();
    }
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
  }
  S.registerPostcss = (e3) => {
    E = e3;
  }, e2.exports = S, S.default = S, p.registerLazyResult(S), l.registerLazyResult(S);
}, (e2, t2, r2) => {
  var n2 = r2(31).a;
  let { SourceMapConsumer: s2, SourceMapGenerator: i2 } = r2(149), { dirname: o2, relative: a2, resolve: l, sep: c } = r2(150), { pathToFileURL: u } = r2(318), p = r2(55), d = Boolean(s2 && i2), f = Boolean(o2 && l && a2 && c);
  e2.exports = class {
    constructor(e3, t3, r3, n3) {
      this.stringify = e3, this.mapOpts = r3.map || {}, this.root = t3, this.opts = r3, this.css = n3, this.originalCSS = n3, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
    }
    addAnnotation() {
      let e3;
      e3 = this.isInline() ? "data:application/json;base64," + this.toBase64(this.map.toString()) : "string" == typeof this.mapOpts.annotation ? this.mapOpts.annotation : "function" == typeof this.mapOpts.annotation ? this.mapOpts.annotation(this.opts.to, this.root) : this.outputFile() + ".map";
      let t3 = "\n";
      this.css.includes("\r\n") && (t3 = "\r\n"), this.css += t3 + "/*# sourceMappingURL=" + e3 + " */";
    }
    applyPrevMaps() {
      for (let e3 of this.previous()) {
        let t3, r3 = this.toUrl(this.path(e3.file)), n3 = e3.root || o2(e3.file);
        false === this.mapOpts.sourcesContent ? (t3 = new s2(e3.text), t3.sourcesContent && (t3.sourcesContent = t3.sourcesContent.map(() => null))) : t3 = e3.consumer(), this.map.applySourceMap(t3, r3, this.toUrl(this.path(n3)));
      }
    }
    clearAnnotation() {
      if (false !== this.mapOpts.annotation) if (this.root) {
        let e3;
        for (let t3 = this.root.nodes.length - 1; t3 >= 0; t3--) e3 = this.root.nodes[t3], "comment" === e3.type && 0 === e3.text.indexOf("# sourceMappingURL=") && this.root.removeChild(t3);
      } else this.css && (this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), f && d && this.isMap()) return this.generateMap();
      {
        let e3 = "";
        return this.stringify(this.root, (t3) => {
          e3 += t3;
        }), [e3];
      }
    }
    generateMap() {
      if (this.root) this.generateString();
      else if (1 === this.previous().length) {
        let e3 = this.previous()[0].consumer();
        e3.file = this.outputFile(), this.map = i2.fromSourceMap(e3);
      } else this.map = new i2({ file: this.outputFile() }), this.map.addMapping({ generated: { column: 0, line: 1 }, original: { column: 0, line: 1 }, source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>" });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new i2({ file: this.outputFile() });
      let e3, t3, r3 = 1, n3 = 1, s3 = "<no source>", o3 = { generated: { column: 0, line: 0 }, original: { column: 0, line: 0 }, source: "" };
      this.stringify(this.root, (i3, a3, l2) => {
        if (this.css += i3, a3 && "end" !== l2 && (o3.generated.line = r3, o3.generated.column = n3 - 1, a3.source && a3.source.start ? (o3.source = this.sourcePath(a3), o3.original.line = a3.source.start.line, o3.original.column = a3.source.start.column - 1, this.map.addMapping(o3)) : (o3.source = s3, o3.original.line = 1, o3.original.column = 0, this.map.addMapping(o3))), e3 = i3.match(/\n/g), e3 ? (r3 += e3.length, t3 = i3.lastIndexOf("\n"), n3 = i3.length - t3) : n3 += i3.length, a3 && "start" !== l2) {
          let e4 = a3.parent || { raws: {} };
          ("decl" === a3.type || "atrule" === a3.type && !a3.nodes) && a3 === e4.last && !e4.raws.semicolon || (a3.source && a3.source.end ? (o3.source = this.sourcePath(a3), o3.original.line = a3.source.end.line, o3.original.column = a3.source.end.column - 1, o3.generated.line = r3, o3.generated.column = n3 - 2, this.map.addMapping(o3)) : (o3.source = s3, o3.original.line = 1, o3.original.column = 0, o3.generated.line = r3, o3.generated.column = n3 - 1, this.map.addMapping(o3)));
        }
      });
    }
    isAnnotation() {
      return !!this.isInline() || (void 0 !== this.mapOpts.annotation ? this.mapOpts.annotation : !this.previous().length || this.previous().some((e3) => e3.annotation));
    }
    isInline() {
      if (void 0 !== this.mapOpts.inline) return this.mapOpts.inline;
      let e3 = this.mapOpts.annotation;
      return (void 0 === e3 || true === e3) && (!this.previous().length || this.previous().some((e4) => e4.inline));
    }
    isMap() {
      return void 0 !== this.opts.map ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return void 0 !== this.mapOpts.sourcesContent ? this.mapOpts.sourcesContent : !this.previous().length || this.previous().some((e3) => e3.withContent());
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(e3) {
      if (this.mapOpts.absolute) return e3;
      if (60 === e3.charCodeAt(0)) return e3;
      if (/^\w+:\/\//.test(e3)) return e3;
      let t3 = this.memoizedPaths.get(e3);
      if (t3) return t3;
      let r3 = this.opts.to ? o2(this.opts.to) : ".";
      "string" == typeof this.mapOpts.annotation && (r3 = o2(l(r3, this.mapOpts.annotation)));
      let n3 = a2(r3, e3);
      return this.memoizedPaths.set(e3, n3), n3;
    }
    previous() {
      if (!this.previousMaps) if (this.previousMaps = [], this.root) this.root.walk((e3) => {
        if (e3.source && e3.source.input.map) {
          let t3 = e3.source.input.map;
          this.previousMaps.includes(t3) || this.previousMaps.push(t3);
        }
      });
      else {
        let e3 = new p(this.originalCSS, this.opts);
        e3.map && this.previousMaps.push(e3.map);
      }
      return this.previousMaps;
    }
    setSourcesContent() {
      let e3 = {};
      if (this.root) this.root.walk((t3) => {
        if (t3.source) {
          let r3 = t3.source.input.from;
          if (r3 && !e3[r3]) {
            e3[r3] = true;
            let n3 = this.usesFileUrls ? this.toFileUrl(r3) : this.toUrl(this.path(r3));
            this.map.setSourceContent(n3, t3.source.input.css);
          }
        }
      });
      else if (this.css) {
        let e4 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(e4, this.css);
      }
    }
    sourcePath(e3) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e3.source.input.from) : this.toUrl(this.path(e3.source.input.from));
    }
    toBase64(e3) {
      return n2 ? n2.from(e3).toString("base64") : window.btoa(unescape(encodeURIComponent(e3)));
    }
    toFileUrl(e3) {
      let t3 = this.memoizedFileURLs.get(e3);
      if (t3) return t3;
      if (u) {
        let t4 = u(e3).toString();
        return this.memoizedFileURLs.set(e3, t4), t4;
      }
      throw new Error("`map.absolute` option is not available in this PostCSS build");
    }
    toUrl(e3) {
      let t3 = this.memoizedURLs.get(e3);
      if (t3) return t3;
      "\\" === c && (e3 = e3.replace(/\\/g, "/"));
      let r3 = encodeURI(e3).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(e3, r3), r3;
    }
  };
}, () => {
}, () => {
}, (e2, t2, r2) => {
  var n2 = r2(31).a;
  let { SourceMapConsumer: s2, SourceMapGenerator: i2 } = r2(149), { existsSync: o2, readFileSync: a2 } = r2(512), { dirname: l, join: c } = r2(150);
  class u {
    constructor(e3, t3) {
      if (false === t3.map) return;
      this.loadAnnotation(e3), this.inline = this.startWith(this.annotation, "data:");
      let r3 = t3.map ? t3.map.prev : void 0, n3 = this.loadMap(t3.from, r3);
      !this.mapFile && t3.from && (this.mapFile = t3.from), this.mapFile && (this.root = l(this.mapFile)), n3 && (this.text = n3);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new s2(this.text)), this.consumerCache;
    }
    decodeInline(e3) {
      if (/^data:application\/json;charset=utf-?8,/.test(e3) || /^data:application\/json,/.test(e3)) return decodeURIComponent(e3.substr(RegExp.lastMatch.length));
      if (/^data:application\/json;charset=utf-?8;base64,/.test(e3) || /^data:application\/json;base64,/.test(e3)) return t3 = e3.substr(RegExp.lastMatch.length), n2 ? n2.from(t3, "base64").toString() : window.atob(t3);
      var t3;
      let r3 = e3.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + r3);
    }
    getAnnotationURL(e3) {
      return e3.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(e3) {
      return "object" == typeof e3 && ("string" == typeof e3.mappings || "string" == typeof e3._mappings || Array.isArray(e3.sections));
    }
    loadAnnotation(e3) {
      let t3 = e3.match(/\/\*\s*# sourceMappingURL=/gm);
      if (!t3) return;
      let r3 = e3.lastIndexOf(t3.pop()), n3 = e3.indexOf("*/", r3);
      r3 > -1 && n3 > -1 && (this.annotation = this.getAnnotationURL(e3.substring(r3, n3)));
    }
    loadFile(e3) {
      if (this.root = l(e3), o2(e3)) return this.mapFile = e3, a2(e3, "utf-8").toString().trim();
    }
    loadMap(e3, t3) {
      if (false === t3) return false;
      if (t3) {
        if ("string" == typeof t3) return t3;
        if ("function" != typeof t3) {
          if (t3 instanceof s2) return i2.fromSourceMap(t3).toString();
          if (t3 instanceof i2) return t3.toString();
          if (this.isMap(t3)) return JSON.stringify(t3);
          throw new Error("Unsupported previous source map format: " + t3.toString());
        }
        {
          let r3 = t3(e3);
          if (r3) {
            let e4 = this.loadFile(r3);
            if (!e4) throw new Error("Unable to load previous source map: " + r3.toString());
            return e4;
          }
        }
      } else {
        if (this.inline) return this.decodeInline(this.annotation);
        if (this.annotation) {
          let t4 = this.annotation;
          return e3 && (t4 = c(l(e3), t4)), this.loadFile(t4);
        }
      }
    }
    startWith(e3, t3) {
      return !!e3 && e3.substr(0, t3.length) === t3;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  }
  e2.exports = u, u.default = u;
}, (e2) => {
  let t2 = {};
  e2.exports = function(e3) {
    t2[e3] || (t2[e3] = true, "undefined" != typeof console && console.warn);
  };
}, (e2) => {
  class t2 {
    constructor(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      if (this.type = "warning", this.text = e3, t3.node && t3.node.source) {
        let e4 = t3.node.rangeBy(t3);
        this.line = e4.start.line, this.column = e4.start.column, this.endLine = e4.end.line, this.endColumn = e4.end.column;
      }
      for (let e4 in t3) this[e4] = t3[e4];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  }
  e2.exports = t2, t2.default = t2;
}, (e2) => {
  let t2 = { comma: (e3) => t2.split(e3, [","], true), space: (e3) => t2.split(e3, [" ", "\n", "	"]), split(e3, t3, r2) {
    let n2 = [], s2 = "", i2 = false, o2 = 0, a2 = false, l = "", c = false;
    for (let r3 of e3) c ? c = false : "\\" === r3 ? c = true : a2 ? r3 === l && (a2 = false) : '"' === r3 || "'" === r3 ? (a2 = true, l = r3) : "(" === r3 ? o2 += 1 : ")" === r3 ? o2 > 0 && (o2 -= 1) : 0 === o2 && t3.includes(r3) && (i2 = true), i2 ? ("" !== s2 && n2.push(s2.trim()), s2 = "", i2 = false) : s2 += r3;
    return (r2 || "" !== s2) && n2.push(s2.trim()), n2;
  } };
  e2.exports = t2, t2.default = t2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true });
  var n2 = r2(412);
  Object.keys(n2).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === n2[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return n2[e3];
    } }));
  });
  var s2 = r2(413);
  Object.keys(s2).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === s2[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return s2[e3];
    } }));
  });
  var i2 = r2(414);
  Object.keys(i2).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === i2[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return i2[e3];
    } }));
  });
  var o2 = r2(415);
  Object.keys(o2).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === o2[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return o2[e3];
    } }));
  });
  var a2 = r2(416);
  Object.keys(a2).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === a2[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return a2[e3];
    } }));
  });
  var l = r2(185);
  Object.keys(l).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === l[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return l[e3];
    } }));
  });
  var c = r2(186);
  Object.keys(c).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === c[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return c[e3];
    } }));
  });
  var u = r2(419);
  Object.keys(u).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === u[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return u[e3];
    } }));
  });
  var p = r2(420);
  Object.keys(p).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === p[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return p[e3];
    } }));
  });
  var d = r2(421);
  Object.keys(d).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === d[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return d[e3];
    } }));
  });
  var f = r2(422);
  Object.keys(f).forEach(function(e3) {
    "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === f[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
      return f[e3];
    } }));
  });
}, function(e2, t2, r2) {
  var n2 = this && this.__createBinding || (Object.create ? function(e3, t3, r3, n3) {
    void 0 === n3 && (n3 = r3);
    var s3 = Object.getOwnPropertyDescriptor(t3, r3);
    s3 && !("get" in s3 ? !t3.__esModule : s3.writable || s3.configurable) || (s3 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, n3, s3);
  } : function(e3, t3, r3, n3) {
    void 0 === n3 && (n3 = r3), e3[n3] = t3[r3];
  }), s2 = this && this.__setModuleDefault || (Object.create ? function(e3, t3) {
    Object.defineProperty(e3, "default", { enumerable: true, value: t3 });
  } : function(e3, t3) {
    e3.default = t3;
  }), i2 = this && this.__importStar || function(e3) {
    if (e3 && e3.__esModule) return e3;
    var t3 = {};
    if (null != e3) for (var r3 in e3) "default" !== r3 && Object.prototype.hasOwnProperty.call(e3, r3) && n2(t3, e3, r3);
    return s2(t3, e3), t3;
  }, o2 = this && this.__importDefault || function(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  };
  Object.defineProperty(t2, "__esModule", { value: true }), t2.decodeXML = t2.decodeHTMLStrict = t2.decodeHTMLAttribute = t2.decodeHTML = t2.determineBranch = t2.EntityDecoder = t2.DecodingMode = t2.BinTrieFlags = t2.fromCodePoint = t2.replaceCodePoint = t2.decodeCodePoint = t2.xmlDecodeTree = t2.htmlDecodeTree = void 0;
  var a2 = o2(r2(504));
  t2.htmlDecodeTree = a2.default;
  var l = o2(r2(505));
  t2.xmlDecodeTree = l.default;
  var c = i2(r2(160));
  t2.decodeCodePoint = c.default;
  var u, p, d, f, h = r2(160);
  function m(e3) {
    return e3 >= u.ZERO && e3 <= u.NINE;
  }
  Object.defineProperty(t2, "replaceCodePoint", { enumerable: true, get: function() {
    return h.replaceCodePoint;
  } }), Object.defineProperty(t2, "fromCodePoint", { enumerable: true, get: function() {
    return h.fromCodePoint;
  } }), function(e3) {
    e3[e3.NUM = 35] = "NUM", e3[e3.SEMI = 59] = "SEMI", e3[e3.EQUALS = 61] = "EQUALS", e3[e3.ZERO = 48] = "ZERO", e3[e3.NINE = 57] = "NINE", e3[e3.LOWER_A = 97] = "LOWER_A", e3[e3.LOWER_F = 102] = "LOWER_F", e3[e3.LOWER_X = 120] = "LOWER_X", e3[e3.LOWER_Z = 122] = "LOWER_Z", e3[e3.UPPER_A = 65] = "UPPER_A", e3[e3.UPPER_F = 70] = "UPPER_F", e3[e3.UPPER_Z = 90] = "UPPER_Z";
  }(u || (u = {})), function(e3) {
    e3[e3.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e3[e3.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e3[e3.JUMP_TABLE = 127] = "JUMP_TABLE";
  }(p = t2.BinTrieFlags || (t2.BinTrieFlags = {})), function(e3) {
    e3[e3.EntityStart = 0] = "EntityStart", e3[e3.NumericStart = 1] = "NumericStart", e3[e3.NumericDecimal = 2] = "NumericDecimal", e3[e3.NumericHex = 3] = "NumericHex", e3[e3.NamedEntity = 4] = "NamedEntity";
  }(d || (d = {})), function(e3) {
    e3[e3.Legacy = 0] = "Legacy", e3[e3.Strict = 1] = "Strict", e3[e3.Attribute = 2] = "Attribute";
  }(f = t2.DecodingMode || (t2.DecodingMode = {}));
  var y = function() {
    function e3(e4, t3, r3) {
      this.decodeTree = e4, this.emitCodePoint = t3, this.errors = r3, this.state = d.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = f.Strict;
    }
    return e3.prototype.startEntity = function(e4) {
      this.decodeMode = e4, this.state = d.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
    }, e3.prototype.write = function(e4, t3) {
      switch (this.state) {
        case d.EntityStart:
          return e4.charCodeAt(t3) === u.NUM ? (this.state = d.NumericStart, this.consumed += 1, this.stateNumericStart(e4, t3 + 1)) : (this.state = d.NamedEntity, this.stateNamedEntity(e4, t3));
        case d.NumericStart:
          return this.stateNumericStart(e4, t3);
        case d.NumericDecimal:
          return this.stateNumericDecimal(e4, t3);
        case d.NumericHex:
          return this.stateNumericHex(e4, t3);
        case d.NamedEntity:
          return this.stateNamedEntity(e4, t3);
      }
    }, e3.prototype.stateNumericStart = function(e4, t3) {
      return t3 >= e4.length ? -1 : (32 | e4.charCodeAt(t3)) === u.LOWER_X ? (this.state = d.NumericHex, this.consumed += 1, this.stateNumericHex(e4, t3 + 1)) : (this.state = d.NumericDecimal, this.stateNumericDecimal(e4, t3));
    }, e3.prototype.addToNumericResult = function(e4, t3, r3, n3) {
      if (t3 !== r3) {
        var s3 = r3 - t3;
        this.result = this.result * Math.pow(n3, s3) + parseInt(e4.substr(t3, s3), n3), this.consumed += s3;
      }
    }, e3.prototype.stateNumericHex = function(e4, t3) {
      for (var r3, n3 = t3; t3 < e4.length; ) {
        var s3 = e4.charCodeAt(t3);
        if (!(m(s3) || (r3 = s3, r3 >= u.UPPER_A && r3 <= u.UPPER_F || r3 >= u.LOWER_A && r3 <= u.LOWER_F))) return this.addToNumericResult(e4, n3, t3, 16), this.emitNumericEntity(s3, 3);
        t3 += 1;
      }
      return this.addToNumericResult(e4, n3, t3, 16), -1;
    }, e3.prototype.stateNumericDecimal = function(e4, t3) {
      for (var r3 = t3; t3 < e4.length; ) {
        var n3 = e4.charCodeAt(t3);
        if (!m(n3)) return this.addToNumericResult(e4, r3, t3, 10), this.emitNumericEntity(n3, 2);
        t3 += 1;
      }
      return this.addToNumericResult(e4, r3, t3, 10), -1;
    }, e3.prototype.emitNumericEntity = function(e4, t3) {
      var r3;
      if (this.consumed <= t3) return null === (r3 = this.errors) || void 0 === r3 || r3.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      if (e4 === u.SEMI) this.consumed += 1;
      else if (this.decodeMode === f.Strict) return 0;
      return this.emitCodePoint((0, c.replaceCodePoint)(this.result), this.consumed), this.errors && (e4 !== u.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
    }, e3.prototype.stateNamedEntity = function(e4, t3) {
      for (var r3 = this.decodeTree, n3 = r3[this.treeIndex], s3 = (n3 & p.VALUE_LENGTH) >> 14; t3 < e4.length; t3++, this.excess++) {
        var i3 = e4.charCodeAt(t3);
        if (this.treeIndex = b(r3, n3, this.treeIndex + Math.max(1, s3), i3), this.treeIndex < 0) return 0 === this.result || this.decodeMode === f.Attribute && (0 === s3 || ((o3 = i3) === u.EQUALS || function(e5) {
          return e5 >= u.UPPER_A && e5 <= u.UPPER_Z || e5 >= u.LOWER_A && e5 <= u.LOWER_Z || m(e5);
        }(o3))) ? 0 : this.emitNotTerminatedNamedEntity();
        if (0 != (s3 = ((n3 = r3[this.treeIndex]) & p.VALUE_LENGTH) >> 14)) {
          if (i3 === u.SEMI) return this.emitNamedEntityData(this.treeIndex, s3, this.consumed + this.excess);
          this.decodeMode !== f.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
        }
      }
      var o3;
      return -1;
    }, e3.prototype.emitNotTerminatedNamedEntity = function() {
      var e4, t3 = this.result, r3 = (this.decodeTree[t3] & p.VALUE_LENGTH) >> 14;
      return this.emitNamedEntityData(t3, r3, this.consumed), null === (e4 = this.errors) || void 0 === e4 || e4.missingSemicolonAfterCharacterReference(), this.consumed;
    }, e3.prototype.emitNamedEntityData = function(e4, t3, r3) {
      var n3 = this.decodeTree;
      return this.emitCodePoint(1 === t3 ? n3[e4] & ~p.VALUE_LENGTH : n3[e4 + 1], r3), 3 === t3 && this.emitCodePoint(n3[e4 + 2], r3), r3;
    }, e3.prototype.end = function() {
      var e4;
      switch (this.state) {
        case d.NamedEntity:
          return 0 === this.result || this.decodeMode === f.Attribute && this.result !== this.treeIndex ? 0 : this.emitNotTerminatedNamedEntity();
        case d.NumericDecimal:
          return this.emitNumericEntity(0, 2);
        case d.NumericHex:
          return this.emitNumericEntity(0, 3);
        case d.NumericStart:
          return null === (e4 = this.errors) || void 0 === e4 || e4.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
        case d.EntityStart:
          return 0;
      }
    }, e3;
  }();
  function g(e3) {
    var t3 = "", r3 = new y(e3, function(e4) {
      return t3 += (0, c.fromCodePoint)(e4);
    });
    return function(e4, n3) {
      for (var s3 = 0, i3 = 0; (i3 = e4.indexOf("&", i3)) >= 0; ) {
        t3 += e4.slice(s3, i3), r3.startEntity(n3);
        var o3 = r3.write(e4, i3 + 1);
        if (o3 < 0) {
          s3 = i3 + r3.end();
          break;
        }
        s3 = i3 + o3, i3 = 0 === o3 ? s3 + 1 : s3;
      }
      var a3 = t3 + e4.slice(s3);
      return t3 = "", a3;
    };
  }
  function b(e3, t3, r3, n3) {
    var s3 = (t3 & p.BRANCH_LENGTH) >> 7, i3 = t3 & p.JUMP_TABLE;
    if (0 === s3) return 0 !== i3 && n3 === i3 ? r3 : -1;
    if (i3) {
      var o3 = n3 - i3;
      return o3 < 0 || o3 >= s3 ? -1 : e3[r3 + o3] - 1;
    }
    for (var a3 = r3, l2 = a3 + s3 - 1; a3 <= l2; ) {
      var c2 = a3 + l2 >>> 1, u2 = e3[c2];
      if (u2 < n3) a3 = c2 + 1;
      else {
        if (!(u2 > n3)) return e3[c2 + s3];
        l2 = c2 - 1;
      }
    }
    return -1;
  }
  t2.EntityDecoder = y, t2.determineBranch = b;
  var v = g(a2.default), E = g(l.default);
  t2.decodeHTML = function(e3, t3) {
    return void 0 === t3 && (t3 = f.Legacy), v(e3, t3);
  }, t2.decodeHTMLAttribute = function(e3) {
    return v(e3, f.Attribute);
  }, t2.decodeHTMLStrict = function(e3) {
    return v(e3, f.Strict);
  }, t2.decodeXML = function(e3) {
    return E(e3, f.Strict);
  };
}, function(e2, t2, r2) {
  var n2;
  e2 = r2.nmd(e2), function(s2) {
    t2 && t2.nodeType, e2 && e2.nodeType;
    var i2 = "object" == typeof r2.g && r2.g;
    i2.global !== i2 && i2.window !== i2 && i2.self;
    var o2, a2 = 2147483647, l = 36, c = 26, u = 38, p = 700, d = /^xn--/, f = /[^\x20-\x7E]/, h = /[\x2E\u3002\uFF0E\uFF61]/g, m = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, y = l - 1, g = Math.floor, b = String.fromCharCode;
    function v(e3) {
      throw new RangeError(m[e3]);
    }
    function E(e3, t3) {
      for (var r3 = e3.length, n3 = []; r3--; ) n3[r3] = t3(e3[r3]);
      return n3;
    }
    function S(e3, t3) {
      var r3 = e3.split("@"), n3 = "";
      return r3.length > 1 && (n3 = r3[0] + "@", e3 = r3[1]), n3 + E((e3 = e3.replace(h, ".")).split("."), t3).join(".");
    }
    function x(e3) {
      for (var t3, r3, n3 = [], s3 = 0, i3 = e3.length; s3 < i3; ) (t3 = e3.charCodeAt(s3++)) >= 55296 && t3 <= 56319 && s3 < i3 ? 56320 == (64512 & (r3 = e3.charCodeAt(s3++))) ? n3.push(((1023 & t3) << 10) + (1023 & r3) + 65536) : (n3.push(t3), s3--) : n3.push(t3);
      return n3;
    }
    function T(e3) {
      return E(e3, function(e4) {
        var t3 = "";
        return e4 > 65535 && (t3 += b((e4 -= 65536) >>> 10 & 1023 | 55296), e4 = 56320 | 1023 & e4), t3 + b(e4);
      }).join("");
    }
    function w(e3, t3) {
      return e3 + 22 + 75 * (e3 < 26) - ((0 != t3) << 5);
    }
    function P(e3, t3, r3) {
      var n3 = 0;
      for (e3 = r3 ? g(e3 / p) : e3 >> 1, e3 += g(e3 / t3); e3 > y * c >> 1; n3 += l) e3 = g(e3 / y);
      return g(n3 + (y + 1) * e3 / (e3 + u));
    }
    function A(e3) {
      var t3, r3, n3, s3, i3, o3, u2, p2, d2, f2, h2, m2 = [], y2 = e3.length, b2 = 0, E2 = 128, S2 = 72;
      for ((r3 = e3.lastIndexOf("-")) < 0 && (r3 = 0), n3 = 0; n3 < r3; ++n3) e3.charCodeAt(n3) >= 128 && v("not-basic"), m2.push(e3.charCodeAt(n3));
      for (s3 = r3 > 0 ? r3 + 1 : 0; s3 < y2; ) {
        for (i3 = b2, o3 = 1, u2 = l; s3 >= y2 && v("invalid-input"), ((p2 = (h2 = e3.charCodeAt(s3++)) - 48 < 10 ? h2 - 22 : h2 - 65 < 26 ? h2 - 65 : h2 - 97 < 26 ? h2 - 97 : l) >= l || p2 > g((a2 - b2) / o3)) && v("overflow"), b2 += p2 * o3, !(p2 < (d2 = u2 <= S2 ? 1 : u2 >= S2 + c ? c : u2 - S2)); u2 += l) o3 > g(a2 / (f2 = l - d2)) && v("overflow"), o3 *= f2;
        S2 = P(b2 - i3, t3 = m2.length + 1, 0 == i3), g(b2 / t3) > a2 - E2 && v("overflow"), E2 += g(b2 / t3), b2 %= t3, m2.splice(b2++, 0, E2);
      }
      return T(m2);
    }
    function C(e3) {
      var t3, r3, n3, s3, i3, o3, u2, p2, d2, f2, h2, m2, y2, E2, S2, T2 = [];
      for (m2 = (e3 = x(e3)).length, t3 = 128, r3 = 0, i3 = 72, o3 = 0; o3 < m2; ++o3) (h2 = e3[o3]) < 128 && T2.push(b(h2));
      for (n3 = s3 = T2.length, s3 && T2.push("-"); n3 < m2; ) {
        for (u2 = a2, o3 = 0; o3 < m2; ++o3) (h2 = e3[o3]) >= t3 && h2 < u2 && (u2 = h2);
        for (u2 - t3 > g((a2 - r3) / (y2 = n3 + 1)) && v("overflow"), r3 += (u2 - t3) * y2, t3 = u2, o3 = 0; o3 < m2; ++o3) if ((h2 = e3[o3]) < t3 && ++r3 > a2 && v("overflow"), h2 == t3) {
          for (p2 = r3, d2 = l; !(p2 < (f2 = d2 <= i3 ? 1 : d2 >= i3 + c ? c : d2 - i3)); d2 += l) S2 = p2 - f2, E2 = l - f2, T2.push(b(w(f2 + S2 % E2, 0))), p2 = g(S2 / E2);
          T2.push(b(w(p2, 0))), i3 = P(r3, y2, n3 == s3), r3 = 0, ++n3;
        }
        ++r3, ++t3;
      }
      return T2.join("");
    }
    o2 = { version: "1.4.1", ucs2: { decode: x, encode: T }, decode: A, encode: C, toASCII: function(e3) {
      return S(e3, function(e4) {
        return f.test(e4) ? "xn--" + C(e4) : e4;
      });
    }, toUnicode: function(e3) {
      return S(e3, function(e4) {
        return d.test(e4) ? A(e4.slice(4).toLowerCase()) : e4;
      });
    } }, void 0 === (n2 = (function() {
      return o2;
    }).call(t2, r2, t2, e2)) || (e2.exports = n2);
  }();
}, (e2) => {
  "function" == typeof Object.create ? e2.exports = function(e3, t2) {
    t2 && (e3.super_ = t2, e3.prototype = Object.create(t2.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } }));
  } : e2.exports = function(e3, t2) {
    if (t2) {
      e3.super_ = t2;
      var r2 = function() {
      };
      r2.prototype = t2.prototype, e3.prototype = new r2(), e3.prototype.constructor = e3;
    }
  };
}, function(e2, t2, r2) {
  e2.exports = function(e3, t3) {
    const r3 = s2("", -1, -1, "", null), n2 = [];
    function s2(e4, t4, r4, n3, s3) {
      return { source: e4, line: t4, column: r4, name: n3, content: s3 };
    }
    function i2(e4, t4, r4, n3) {
      return { map: e4, sources: t4, source: r4, content: n3 };
    }
    function o2(e4, t4) {
      return i2(e4, t4, "", null);
    }
    function a2(t4, n3, i3, o3) {
      if (!t4.map) return s2(t4.source, n3, i3, o3, t4.content);
      const l2 = e3.traceSegment(t4.map, n3, i3);
      return null == l2 ? null : 1 === l2.length ? r3 : a2(t4.sources[l2[1]], l2[2], l2[3], 5 === l2.length ? t4.map.names[l2[4]] : o3);
    }
    function l(t4, r4) {
      const n3 = (i3 = t4, Array.isArray(i3) ? i3 : [i3]).map((t5) => new e3.TraceMap(t5, "")), s3 = n3.pop();
      var i3;
      for (let e4 = 0; e4 < n3.length; e4++) if (n3[e4].sources.length > 1) throw new Error(`Transformation map ${e4} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
      let a3 = c(s3, r4, "", 0);
      for (let e4 = n3.length - 1; e4 >= 0; e4--) a3 = o2(n3[e4], [a3]);
      return a3;
    }
    function c(t4, r4, s3, a3) {
      const { resolvedSources: l2, sourcesContent: u2 } = t4, p = a3 + 1;
      return o2(t4, l2.map((t5, o3) => {
        const a4 = { importer: s3, depth: p, source: t5 || "", content: void 0 }, l3 = r4(a4.source, a4), { source: d, content: f } = a4;
        return l3 ? c(new e3.TraceMap(l3, d), r4, d, p) : function(e4, t6) {
          return i2(null, n2, e4, t6);
        }(d, void 0 !== f ? f : u2 ? u2[o3] : null);
      }));
    }
    class u {
      constructor(e4, r4) {
        const n3 = r4.decodedMappings ? t3.toDecodedMap(e4) : t3.toEncodedMap(e4);
        this.version = n3.version, this.file = n3.file, this.mappings = n3.mappings, this.names = n3.names, this.sourceRoot = n3.sourceRoot, this.sources = n3.sources, r4.excludeContent || (this.sourcesContent = n3.sourcesContent);
      }
      toString() {
        return JSON.stringify(this);
      }
    }
    return function(n3, s3, i3) {
      const o3 = "object" == typeof i3 ? i3 : { excludeContent: !!i3, decodedMappings: false }, c2 = l(n3, s3);
      return new u(function(n4) {
        const s4 = new t3.GenMapping({ file: n4.map.file }), { sources: i4, map: o4 } = n4, l2 = o4.names, c3 = e3.decodedMappings(o4);
        for (let e4 = 0; e4 < c3.length; e4++) {
          const n5 = c3[e4];
          for (let o5 = 0; o5 < n5.length; o5++) {
            const c4 = n5[o5], u2 = c4[0];
            let p = r3;
            if (1 !== c4.length && (p = a2(i4[c4[1]], c4[2], c4[3], 5 === c4.length ? l2[c4[4]] : ""), null == p)) continue;
            const { column: d, line: f, name: h, content: m, source: y } = p;
            t3.maybeAddSegment(s4, e4, u2, y, f, d, h), y && null != m && t3.setSourceContent(s4, y, m);
          }
        }
        return s4;
      }(c2), o3);
    };
  }(r2(486), r2(487));
}, (e2, t2) => {
  var r2;
  Object.defineProperty(t2, "__esModule", { value: true }), t2.replaceCodePoint = t2.fromCodePoint = void 0;
  var n2 = /* @__PURE__ */ new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]);
  function s2(e3) {
    var t3;
    return e3 >= 55296 && e3 <= 57343 || e3 > 1114111 ? 65533 : null !== (t3 = n2.get(e3)) && void 0 !== t3 ? t3 : e3;
  }
  t2.fromCodePoint = null !== (r2 = String.fromCodePoint) && void 0 !== r2 ? r2 : function(e3) {
    var t3 = "";
    return e3 > 65535 && (e3 -= 65536, t3 += String.fromCharCode(e3 >>> 10 & 1023 | 55296), e3 = 56320 | 1023 & e3), t3 + String.fromCharCode(e3);
  }, t2.replaceCodePoint = s2, t2.default = function(e3) {
    return (0, t2.fromCodePoint)(s2(e3));
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.ensure = function(e3, t3) {
    d || (d = t3), m(e3);
  }, t2.get = y, t2.getDependencies = function(e3) {
    return m(e3).getDependencies();
  }, t2.list = void 0, t2.minVersion = function(e3) {
    return m(e3).minVersion;
  };
  var n2 = r2(14), s2 = r2(0), i2 = r2(445);
  const { assignmentExpression: o2, cloneNode: a2, expressionStatement: l, file: c, identifier: u } = s2;
  function p(e3) {
    const t3 = [];
    for (; e3.parentPath; e3 = e3.parentPath) t3.push(e3.key), e3.inList && t3.push(e3.listKey);
    return t3.reverse().join(".");
  }
  let d;
  function f(e3) {
    const t3 = /* @__PURE__ */ new Set(), r3 = /* @__PURE__ */ new Set(), s3 = /* @__PURE__ */ new Map();
    let o3, a3;
    const l2 = [], c2 = [], u2 = [], d2 = { ImportDeclaration(e4) {
      const t4 = e4.node.source.value;
      if (!i2.default[t4]) throw e4.buildCodeFrameError(`Unknown helper ${t4}`);
      if (1 !== e4.get("specifiers").length || !e4.get("specifiers.0").isImportDefaultSpecifier()) throw e4.buildCodeFrameError("Helpers can only import a default value");
      const r4 = e4.node.specifiers[0].local;
      s3.set(r4, t4), c2.push(p(e4));
    }, ExportDefaultDeclaration(e4) {
      const t4 = e4.get("declaration");
      if (!t4.isFunctionDeclaration() || !t4.node.id) throw t4.buildCodeFrameError("Helpers can only export named function declarations");
      o3 = t4.node.id.name, a3 = p(e4);
    }, ExportAllDeclaration(e4) {
      throw e4.buildCodeFrameError("Helpers can only export default");
    }, ExportNamedDeclaration(e4) {
      throw e4.buildCodeFrameError("Helpers can only export default");
    }, Statement(e4) {
      e4.isImportDeclaration() || e4.isExportDeclaration() || e4.skip();
    } }, f2 = { Program(e4) {
      const t4 = e4.scope.getAllBindings();
      Object.keys(t4).forEach((e5) => {
        e5 !== o3 && (s3.has(t4[e5].identifier) || r3.add(e5));
      });
    }, ReferencedIdentifier(e4) {
      const r4 = e4.node.name, n3 = e4.scope.getBinding(r4);
      n3 ? s3.has(n3.identifier) && u2.push(p(e4)) : t3.add(r4);
    }, AssignmentExpression(e4) {
      const t4 = e4.get("left");
      if (!(o3 in t4.getBindingIdentifiers())) return;
      if (!t4.isIdentifier()) throw t4.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
      const r4 = e4.scope.getBinding(o3);
      null != r4 && r4.scope.path.isProgram() && l2.push(p(e4));
    } };
    if ((0, n2.default)(e3.ast, d2, e3.scope), (0, n2.default)(e3.ast, f2, e3.scope), !a3) throw new Error("Helpers must have a default export.");
    return l2.reverse(), { globals: Array.from(t3), localBindingNames: Array.from(r3), dependencies: s3, exportBindingAssignments: l2, exportPath: a3, exportName: o3, importBindingsReferences: u2, importPaths: c2 };
  }
  const h = /* @__PURE__ */ Object.create(null);
  function m(e3) {
    if (!h[e3]) {
      const t3 = i2.default[e3];
      if (!t3) throw Object.assign(new ReferenceError(`Unknown helper ${e3}`), { code: "BABEL_HELPER_UNKNOWN", helper: e3 });
      const r3 = () => {
        if (!d) {
          const e4 = { ast: c(t3.ast()), path: null };
          return (0, n2.default)(e4.ast, { Program: (t4) => (e4.path = t4).stop() }), e4;
        }
        return new d({ filename: `babel-helper://${e3}` }, { ast: c(t3.ast()), code: "[internal Babel helper code]", inputMap: null });
      };
      let s3 = null;
      h[e3] = { minVersion: t3.minVersion, build(e4, t4, n3) {
        const i3 = r3();
        return s3 || (s3 = f(i3)), function(e5, t5, r4, n4, s4) {
          if (n4 && !r4) throw new Error("Unexpected local bindings for module-based helpers.");
          if (!r4) return;
          const { localBindingNames: i4, dependencies: c2, exportBindingAssignments: p2, exportPath: d2, exportName: f2, importBindingsReferences: h2, importPaths: m2 } = t5, y2 = {};
          c2.forEach((e6, t6) => {
            y2[t6.name] = "function" == typeof s4 && s4(e6) || t6;
          });
          const g = {}, b = new Set(n4 || []);
          "Identifier" === r4.type && b.add(r4.name), i4.forEach((e6) => {
            let t6 = e6;
            for (; b.has(t6); ) t6 = "_" + t6;
            t6 !== e6 && (g[e6] = t6);
          }), "Identifier" === r4.type && f2 !== r4.name && (g[f2] = r4.name);
          const { path: v } = e5, E = v.get(d2), S = m2.map((e6) => v.get(e6)), x = h2.map((e6) => v.get(e6)), T = E.get("declaration");
          if ("Identifier" === r4.type) E.replaceWith(T);
          else {
            if ("MemberExpression" !== r4.type) throw new Error("Unexpected helper format.");
            p2.forEach((e6) => {
              const t6 = v.get(e6);
              t6.replaceWith(o2("=", r4, t6.node));
            }), E.replaceWith(T), v.pushContainer("body", l(o2("=", r4, u(f2))));
          }
          Object.keys(g).forEach((e6) => {
            v.scope.rename(e6, g[e6]);
          });
          for (const e6 of S) e6.remove();
          for (const e6 of x) {
            const t6 = a2(y2[e6.node.name]);
            e6.replaceWith(t6);
          }
        }(i3, s3, t4, n3, e4), { nodes: i3.ast.program.body, globals: s3.globals };
      }, getDependencies: () => (s3 || (s3 = f(r3())), Array.from(s3.dependencies.values())) };
    }
    return h[e3];
  }
  function y(e3, t3, r3, n3) {
    return m(e3).build(t3, r3, n3);
  }
  t2.list = Object.keys(i2.default).map((e3) => e3.replace(/^_/, "")), t2.default = y;
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.Var = t2.User = t2.Statement = t2.SpreadProperty = t2.Scope = t2.RestProperty = t2.ReferencedMemberExpression = t2.ReferencedIdentifier = t2.Referenced = t2.Pure = t2.NumericLiteralTypeAnnotation = t2.Generated = t2.ForAwaitStatement = t2.Flow = t2.Expression = t2.ExistentialTypeParam = t2.BlockScoped = t2.BindingIdentifier = void 0, t2.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], t2.ReferencedMemberExpression = ["MemberExpression"], t2.BindingIdentifier = ["Identifier"], t2.Statement = ["Statement"], t2.Expression = ["Expression"], t2.Scope = ["Scopable", "Pattern"], t2.Referenced = null, t2.BlockScoped = null, t2.Var = ["VariableDeclaration"], t2.User = null, t2.Generated = null, t2.Pure = null, t2.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], t2.RestProperty = ["RestElement"], t2.SpreadProperty = ["RestElement"], t2.ExistentialTypeParam = ["ExistsTypeAnnotation"], t2.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"], t2.ForAwaitStatement = ["ForOfStatement"];
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isBindingIdentifier = function() {
    const { node: e3, parent: t3 } = this, r3 = this.parentPath.parent;
    return p(e3) && s2(e3, t3, r3);
  }, t2.isBlockScoped = function() {
    return i2(this.node);
  }, t2.isExpression = function() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : a2(this.node);
  }, t2.isFlow = function() {
    const { node: e3 } = this;
    return !(!l(e3) && (d(e3) ? "type" !== e3.importKind && "typeof" !== e3.importKind : o2(e3) ? "type" !== e3.exportKind : !f(e3) || "type" !== e3.importKind && "typeof" !== e3.importKind));
  }, t2.isForAwaitStatement = function() {
    return w(this.node, { await: true });
  }, t2.isGenerated = function() {
    return !this.isUser();
  }, t2.isPure = function(e3) {
    return this.scope.isPure(this.node, e3);
  }, t2.isReferenced = function() {
    return b(this.node, this.parent);
  }, t2.isReferencedIdentifier = function(e3) {
    const { node: t3, parent: r3 } = this;
    if (!p(t3, e3) && !m(r3, e3)) {
      if (!h(t3, e3)) return false;
      if (P(t3.name)) return false;
    }
    return b(t3, r3, this.parentPath.parent);
  }, t2.isReferencedMemberExpression = function() {
    const { node: e3, parent: t3 } = this;
    return y(e3) && b(e3, t3);
  }, t2.isRestProperty = function() {
    return g(this.node) && this.parentPath && this.parentPath.isObjectPattern();
  }, t2.isScope = function() {
    return v(this.node, this.parent);
  }, t2.isSpreadProperty = function() {
    return g(this.node) && this.parentPath && this.parentPath.isObjectExpression();
  }, t2.isStatement = function() {
    const { node: e3, parent: t3 } = this;
    if (E(e3)) {
      if (x(e3)) {
        if (u(t3, { left: e3 })) return false;
        if (c(t3, { init: e3 })) return false;
      }
      return true;
    }
    return false;
  }, t2.isUser = function() {
    return this.node && !!this.node.loc;
  }, t2.isVar = function() {
    return S(this.node);
  };
  var n2 = r2(0);
  const { isBinding: s2, isBlockScoped: i2, isExportDeclaration: o2, isExpression: a2, isFlow: l, isForStatement: c, isForXStatement: u, isIdentifier: p, isImportDeclaration: d, isImportSpecifier: f, isJSXIdentifier: h, isJSXMemberExpression: m, isMemberExpression: y, isRestElement: g, isReferenced: b, isScope: v, isStatement: E, isVar: S, isVariableDeclaration: x, react: T, isForOfStatement: w } = n2, { isCompatTag: P } = T;
  t2.isExistentialTypeParam = function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, t2.isNumericLiteralTypeAnnotation = function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const r3 = e3.split(".");
    return (e4) => (0, n2.default)(e4, r3, t3);
  };
  var n2 = r2(165);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    if (!(0, n2.isMemberExpression)(e3)) return false;
    const s2 = Array.isArray(t3) ? t3 : t3.split("."), i2 = [];
    let o2;
    for (o2 = e3; (0, n2.isMemberExpression)(o2); o2 = o2.object) i2.push(o2.property);
    if (i2.push(o2), i2.length < s2.length) return false;
    if (!r3 && i2.length > s2.length) return false;
    for (let e4 = 0, t4 = i2.length - 1; e4 < s2.length; e4++, t4--) {
      const r4 = i2[t4];
      let o3;
      if ((0, n2.isIdentifier)(r4)) o3 = r4.name;
      else if ((0, n2.isStringLiteral)(r4)) o3 = r4.value;
      else {
        if (!(0, n2.isThisExpression)(r4)) return false;
        o3 = "this";
      }
      if (s2[e4] !== o3) return false;
    }
    return true;
  };
  var n2 = r2(2);
}, (e2) => {
  let t2 = null;
  function r2(e3) {
    if (null !== t2 && (t2.property, 1)) {
      const e4 = t2;
      return t2 = r2.prototype = null, e4;
    }
    return t2 = r2.prototype = null == e3 ? /* @__PURE__ */ Object.create(null) : e3, new r2();
  }
  r2(), e2.exports = function(e3) {
    return r2(e3);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.patternLikeCommon = t2.functionTypeAnnotationCommon = t2.functionDeclarationCommon = t2.functionCommon = t2.classMethodOrPropertyCommon = t2.classMethodOrDeclareMethodCommon = void 0, r2(42), r2(43), r2(59);
  var n2 = r2(355), s2 = r2(26), i2 = r2(18);
  const o2 = (0, i2.defineAliasedType)("Standardized");
  o2("ArrayExpression", { fields: { elements: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeOrValueType)("null", "Expression", "SpreadElement"))), default: [] } }, visitor: ["elements"], aliases: ["Expression"] }), o2("AssignmentExpression", { fields: { operator: { validate: (0, i2.assertValueType)("string") }, left: { validate: (0, i2.assertNodeType)("LVal", "OptionalMemberExpression") }, right: { validate: (0, i2.assertNodeType)("Expression") } }, builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Expression"] }), o2("BinaryExpression", { builder: ["operator", "left", "right"], fields: { operator: { validate: (0, i2.assertOneOf)(...s2.BINARY_OPERATORS) }, left: { validate: function() {
    const e3 = (0, i2.assertNodeType)("Expression"), t3 = (0, i2.assertNodeType)("Expression", "PrivateName");
    return Object.assign(function(r3, n3, s3) {
      ("in" === r3.operator ? t3 : e3)(r3, n3, s3);
    }, { oneOfNodeTypes: ["Expression", "PrivateName"] });
  }() }, right: { validate: (0, i2.assertNodeType)("Expression") } }, visitor: ["left", "right"], aliases: ["Binary", "Expression"] }), o2("InterpreterDirective", { builder: ["value"], fields: { value: { validate: (0, i2.assertValueType)("string") } } }), o2("Directive", { visitor: ["value"], fields: { value: { validate: (0, i2.assertNodeType)("DirectiveLiteral") } } }), o2("DirectiveLiteral", { builder: ["value"], fields: { value: { validate: (0, i2.assertValueType)("string") } } }), o2("BlockStatement", { builder: ["body", "directives"], visitor: ["directives", "body"], fields: { directives: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block", "Statement"] }), o2("BreakStatement", { visitor: ["label"], fields: { label: { validate: (0, i2.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), o2("CallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments"], aliases: ["Expression"], fields: Object.assign({ callee: { validate: (0, i2.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier") }, arguments: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) } }, { optional: { validate: (0, i2.assertOneOf)(true, false), optional: true } }, { typeArguments: { validate: (0, i2.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, i2.assertNodeType)("TSTypeParameterInstantiation"), optional: true } }) }), o2("CatchClause", { visitor: ["param", "body"], fields: { param: { validate: (0, i2.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), optional: true }, body: { validate: (0, i2.assertNodeType)("BlockStatement") } }, aliases: ["Scopable", "BlockParent"] }), o2("ConditionalExpression", { visitor: ["test", "consequent", "alternate"], fields: { test: { validate: (0, i2.assertNodeType)("Expression") }, consequent: { validate: (0, i2.assertNodeType)("Expression") }, alternate: { validate: (0, i2.assertNodeType)("Expression") } }, aliases: ["Expression", "Conditional"] }), o2("ContinueStatement", { visitor: ["label"], fields: { label: { validate: (0, i2.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), o2("DebuggerStatement", { aliases: ["Statement"] }), o2("DoWhileStatement", { visitor: ["test", "body"], fields: { test: { validate: (0, i2.assertNodeType)("Expression") }, body: { validate: (0, i2.assertNodeType)("Statement") } }, aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"] }), o2("EmptyStatement", { aliases: ["Statement"] }), o2("ExpressionStatement", { visitor: ["expression"], fields: { expression: { validate: (0, i2.assertNodeType)("Expression") } }, aliases: ["Statement", "ExpressionWrapper"] }), o2("File", { builder: ["program", "comments", "tokens"], visitor: ["program"], fields: { program: { validate: (0, i2.assertNodeType)("Program") }, comments: { validate: Object.assign(() => {
  }, { each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] } }), optional: true }, tokens: { validate: (0, i2.assertEach)(Object.assign(() => {
  }, { type: "any" })), optional: true } } }), o2("ForInStatement", { visitor: ["left", "right", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: (0, i2.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, i2.assertNodeType)("Expression") }, body: { validate: (0, i2.assertNodeType)("Statement") } } }), o2("ForStatement", { visitor: ["init", "test", "update", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"], fields: { init: { validate: (0, i2.assertNodeType)("VariableDeclaration", "Expression"), optional: true }, test: { validate: (0, i2.assertNodeType)("Expression"), optional: true }, update: { validate: (0, i2.assertNodeType)("Expression"), optional: true }, body: { validate: (0, i2.assertNodeType)("Statement") } } });
  const a2 = () => ({ params: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Identifier", "Pattern", "RestElement"))) }, generator: { default: false }, async: { default: false } });
  t2.functionCommon = a2;
  const l = () => ({ returnType: { validate: (0, i2.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, i2.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true } });
  t2.functionTypeAnnotationCommon = l;
  const c = () => Object.assign({}, a2(), { declare: { validate: (0, i2.assertValueType)("boolean"), optional: true }, id: { validate: (0, i2.assertNodeType)("Identifier"), optional: true } });
  t2.functionDeclarationCommon = c, o2("FunctionDeclaration", { builder: ["id", "params", "body", "generator", "async"], visitor: ["id", "params", "body", "returnType", "typeParameters"], fields: Object.assign({}, c(), l(), { body: { validate: (0, i2.assertNodeType)("BlockStatement") }, predicate: { validate: (0, i2.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }), aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"], validate: () => {
  } }), o2("FunctionExpression", { inherits: "FunctionDeclaration", aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, a2(), l(), { id: { validate: (0, i2.assertNodeType)("Identifier"), optional: true }, body: { validate: (0, i2.assertNodeType)("BlockStatement") }, predicate: { validate: (0, i2.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) });
  const u = () => ({ typeAnnotation: { validate: (0, i2.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, optional: { validate: (0, i2.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true } });
  t2.patternLikeCommon = u, o2("Identifier", { builder: ["name"], visitor: ["typeAnnotation", "decorators"], aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"], fields: Object.assign({}, u(), { name: { validate: (0, i2.chain)((0, i2.assertValueType)("string"), Object.assign(function(e3, t3, r3) {
  }, { type: "string" })) } }), validate(e3, t3, r3) {
  } }), o2("IfStatement", { visitor: ["test", "consequent", "alternate"], aliases: ["Statement", "Conditional"], fields: { test: { validate: (0, i2.assertNodeType)("Expression") }, consequent: { validate: (0, i2.assertNodeType)("Statement") }, alternate: { optional: true, validate: (0, i2.assertNodeType)("Statement") } } }), o2("LabeledStatement", { visitor: ["label", "body"], aliases: ["Statement"], fields: { label: { validate: (0, i2.assertNodeType)("Identifier") }, body: { validate: (0, i2.assertNodeType)("Statement") } } }), o2("StringLiteral", { builder: ["value"], fields: { value: { validate: (0, i2.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), o2("NumericLiteral", { builder: ["value"], deprecatedAlias: "NumberLiteral", fields: { value: { validate: (0, i2.chain)((0, i2.assertValueType)("number"), Object.assign(function(e3, t3, r3) {
    (1 / r3 < 0 || !Number.isFinite(r3)) && new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r3}) instead.`);
  }, { type: "number" })) } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), o2("NullLiteral", { aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), o2("BooleanLiteral", { builder: ["value"], fields: { value: { validate: (0, i2.assertValueType)("boolean") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), o2("RegExpLiteral", { builder: ["pattern", "flags"], deprecatedAlias: "RegexLiteral", aliases: ["Expression", "Pureish", "Literal"], fields: { pattern: { validate: (0, i2.assertValueType)("string") }, flags: { validate: (0, i2.chain)((0, i2.assertValueType)("string"), Object.assign(function(e3, t3, r3) {
  }, { type: "string" })), default: "" } } }), o2("LogicalExpression", { builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Binary", "Expression"], fields: { operator: { validate: (0, i2.assertOneOf)(...s2.LOGICAL_OPERATORS) }, left: { validate: (0, i2.assertNodeType)("Expression") }, right: { validate: (0, i2.assertNodeType)("Expression") } } }), o2("MemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression", "LVal"], fields: Object.assign({ object: { validate: (0, i2.assertNodeType)("Expression", "Super") }, property: { validate: function() {
    const e3 = (0, i2.assertNodeType)("Identifier", "PrivateName"), t3 = (0, i2.assertNodeType)("Expression"), r3 = function(r4, n3, s3) {
      (r4.computed ? t3 : e3)(r4, n3, s3);
    };
    return r3.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r3;
  }() }, computed: { default: false } }, { optional: { validate: (0, i2.assertOneOf)(true, false), optional: true } }) }), o2("NewExpression", { inherits: "CallExpression" }), o2("Program", { visitor: ["directives", "body"], builder: ["body", "directives", "sourceType", "interpreter"], fields: { sourceFile: { validate: (0, i2.assertValueType)("string") }, sourceType: { validate: (0, i2.assertOneOf)("script", "module"), default: "script" }, interpreter: { validate: (0, i2.assertNodeType)("InterpreterDirective"), default: null, optional: true }, directives: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block"] }), o2("ObjectExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement"))) } } }), o2("ObjectMethod", { builder: ["kind", "key", "params", "body", "computed", "generator", "async"], fields: Object.assign({}, a2(), l(), { kind: Object.assign({ validate: (0, i2.assertOneOf)("method", "get", "set") }, { default: "method" }), computed: { default: false }, key: { validate: function() {
    const e3 = (0, i2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t3 = (0, i2.assertNodeType)("Expression"), r3 = function(r4, n3, s3) {
      (r4.computed ? t3 : e3)(r4, n3, s3);
    };
    return r3.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r3;
  }() }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true }, body: { validate: (0, i2.assertNodeType)("BlockStatement") } }), visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"] }), o2("ObjectProperty", { builder: ["key", "value", "computed", "shorthand", "decorators"], fields: { computed: { default: false }, key: { validate: function() {
    const e3 = (0, i2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), t3 = (0, i2.assertNodeType)("Expression");
    return Object.assign(function(r3, n3, s3) {
      (r3.computed ? t3 : e3)(r3, n3, s3);
    }, { oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"] });
  }() }, value: { validate: (0, i2.assertNodeType)("Expression", "PatternLike") }, shorthand: { validate: (0, i2.chain)((0, i2.assertValueType)("boolean"), Object.assign(function(e3, t3, r3) {
  }, { type: "boolean" }), function(e3, t3, r3) {
  }), default: false }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true } }, visitor: ["key", "value", "decorators"], aliases: ["UserWhitespacable", "Property", "ObjectMember"], validate: ((0, i2.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), (0, i2.assertNodeType)("Expression"), function(e3, t3, r3) {
  }) }), o2("RestElement", { visitor: ["argument", "typeAnnotation"], builder: ["argument"], aliases: ["LVal", "PatternLike"], deprecatedAlias: "RestProperty", fields: Object.assign({}, u(), { argument: { validate: (0, i2.assertNodeType)("LVal") } }), validate(e3, t3) {
  } }), o2("ReturnStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, i2.assertNodeType)("Expression"), optional: true } } }), o2("SequenceExpression", { visitor: ["expressions"], fields: { expressions: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Expression"))) } }, aliases: ["Expression"] }), o2("ParenthesizedExpression", { visitor: ["expression"], aliases: ["Expression", "ExpressionWrapper"], fields: { expression: { validate: (0, i2.assertNodeType)("Expression") } } }), o2("SwitchCase", { visitor: ["test", "consequent"], fields: { test: { validate: (0, i2.assertNodeType)("Expression"), optional: true }, consequent: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Statement"))) } } }), o2("SwitchStatement", { visitor: ["discriminant", "cases"], aliases: ["Statement", "BlockParent", "Scopable"], fields: { discriminant: { validate: (0, i2.assertNodeType)("Expression") }, cases: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("SwitchCase"))) } } }), o2("ThisExpression", { aliases: ["Expression"] }), o2("ThrowStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, i2.assertNodeType)("Expression") } } }), o2("TryStatement", { visitor: ["block", "handler", "finalizer"], aliases: ["Statement"], fields: { block: { validate: (0, i2.chain)((0, i2.assertNodeType)("BlockStatement"), Object.assign(function(e3) {
  }, { oneOfNodeTypes: ["BlockStatement"] })) }, handler: { optional: true, validate: (0, i2.assertNodeType)("CatchClause") }, finalizer: { optional: true, validate: (0, i2.assertNodeType)("BlockStatement") } } }), o2("UnaryExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: true }, argument: { validate: (0, i2.assertNodeType)("Expression") }, operator: { validate: (0, i2.assertOneOf)(...s2.UNARY_OPERATORS) } }, visitor: ["argument"], aliases: ["UnaryLike", "Expression"] }), o2("UpdateExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: false }, argument: { validate: (0, i2.assertNodeType)("Expression") }, operator: { validate: (0, i2.assertOneOf)(...s2.UPDATE_OPERATORS) } }, visitor: ["argument"], aliases: ["Expression"] }), o2("VariableDeclaration", { builder: ["kind", "declarations"], visitor: ["declarations"], aliases: ["Statement", "Declaration"], fields: { declare: { validate: (0, i2.assertValueType)("boolean"), optional: true }, kind: { validate: (0, i2.assertOneOf)("var", "let", "const", "using", "await using") }, declarations: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("VariableDeclarator"))) } }, validate(e3, t3, r3) {
  } }), o2("VariableDeclarator", { visitor: ["id", "init"], fields: { id: { validate: (0, i2.assertNodeType)("LVal") }, definite: { optional: true, validate: (0, i2.assertValueType)("boolean") }, init: { optional: true, validate: (0, i2.assertNodeType)("Expression") } } }), o2("WhileStatement", { visitor: ["test", "body"], aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"], fields: { test: { validate: (0, i2.assertNodeType)("Expression") }, body: { validate: (0, i2.assertNodeType)("Statement") } } }), o2("WithStatement", { visitor: ["object", "body"], aliases: ["Statement"], fields: { object: { validate: (0, i2.assertNodeType)("Expression") }, body: { validate: (0, i2.assertNodeType)("Statement") } } }), o2("AssignmentPattern", { visitor: ["left", "right", "decorators"], builder: ["left", "right"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, u(), { left: { validate: (0, i2.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") }, right: { validate: (0, i2.assertNodeType)("Expression") }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true } }) }), o2("ArrayPattern", { visitor: ["elements", "typeAnnotation"], builder: ["elements"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, u(), { elements: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeOrValueType)("null", "PatternLike", "LVal"))) } }) }), o2("ArrowFunctionExpression", { builder: ["params", "body", "async"], visitor: ["params", "body", "returnType", "typeParameters"], aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, a2(), l(), { expression: { validate: (0, i2.assertValueType)("boolean") }, body: { validate: (0, i2.assertNodeType)("BlockStatement", "Expression") }, predicate: { validate: (0, i2.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) }), o2("ClassBody", { visitor: ["body"], fields: { body: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock"))) } } }), o2("ClassExpression", { builder: ["id", "superClass", "body", "decorators"], visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"], aliases: ["Scopable", "Class", "Expression"], fields: { id: { validate: (0, i2.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, i2.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, i2.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, i2.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, i2.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, i2.assertNodeType)("InterfaceExtends"), optional: true } } }), o2("ClassDeclaration", { inherits: "ClassExpression", aliases: ["Scopable", "Class", "Statement", "Declaration"], fields: { id: { validate: (0, i2.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, i2.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, i2.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, i2.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, i2.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, i2.assertNodeType)("InterfaceExtends"), optional: true }, declare: { validate: (0, i2.assertValueType)("boolean"), optional: true }, abstract: { validate: (0, i2.assertValueType)("boolean"), optional: true } }, validate: ((0, i2.assertNodeType)("Identifier"), function(e3, t3, r3) {
  }) }), o2("ExportAllDeclaration", { builder: ["source"], visitor: ["source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { source: { validate: (0, i2.assertNodeType)("StringLiteral") }, exportKind: (0, i2.validateOptional)((0, i2.assertOneOf)("type", "value")), attributes: { optional: true, validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportAttribute"))) } } }), o2("ExportDefaultDeclaration", { visitor: ["declaration"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { validate: (0, i2.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression") }, exportKind: (0, i2.validateOptional)((0, i2.assertOneOf)("value")) } }), o2("ExportNamedDeclaration", { builder: ["declaration", "specifiers", "source"], visitor: ["declaration", "specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { optional: true, validate: (0, i2.chain)((0, i2.assertNodeType)("Declaration"), Object.assign(function(e3, t3, r3) {
  }, { oneOfNodeTypes: ["Declaration"] }), function(e3, t3, r3) {
  }) }, attributes: { optional: true, validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportAttribute"))) }, specifiers: { default: [], validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)(function() {
    const e3 = (0, i2.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
    return (0, i2.assertNodeType)("ExportSpecifier"), e3;
  }())) }, source: { validate: (0, i2.assertNodeType)("StringLiteral"), optional: true }, exportKind: (0, i2.validateOptional)((0, i2.assertOneOf)("type", "value")) } }), o2("ExportSpecifier", { visitor: ["local", "exported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, i2.assertNodeType)("Identifier") }, exported: { validate: (0, i2.assertNodeType)("Identifier", "StringLiteral") }, exportKind: { validate: (0, i2.assertOneOf)("type", "value"), optional: true } } }), o2("ForOfStatement", { visitor: ["left", "right", "body"], builder: ["left", "right", "body", "await"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: (0, i2.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, i2.assertNodeType)("Expression") }, body: { validate: (0, i2.assertNodeType)("Statement") }, await: { default: false } } }), o2("ImportDeclaration", { builder: ["specifiers", "source"], visitor: ["specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"], fields: { attributes: { optional: true, validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportAttribute"))) }, module: { optional: true, validate: (0, i2.assertValueType)("boolean") }, phase: { default: null, validate: (0, i2.assertOneOf)("source", "defer") }, specifiers: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"))) }, source: { validate: (0, i2.assertNodeType)("StringLiteral") }, importKind: { validate: (0, i2.assertOneOf)("type", "typeof", "value"), optional: true } } }), o2("ImportDefaultSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, i2.assertNodeType)("Identifier") } } }), o2("ImportNamespaceSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, i2.assertNodeType)("Identifier") } } }), o2("ImportSpecifier", { visitor: ["local", "imported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, i2.assertNodeType)("Identifier") }, imported: { validate: (0, i2.assertNodeType)("Identifier", "StringLiteral") }, importKind: { validate: (0, i2.assertOneOf)("type", "typeof", "value"), optional: true } } }), o2("ImportExpression", { visitor: ["source", "options"], aliases: ["Expression"], fields: { phase: { default: null, validate: (0, i2.assertOneOf)("source", "defer") }, source: { validate: (0, i2.assertNodeType)("Expression") }, options: { validate: (0, i2.assertNodeType)("Expression"), optional: true } } }), o2("MetaProperty", { visitor: ["meta", "property"], aliases: ["Expression"], fields: { meta: { validate: (0, i2.chain)((0, i2.assertNodeType)("Identifier"), Object.assign(function(e3, t3, r3) {
  }, { oneOfNodeTypes: ["Identifier"] })) }, property: { validate: (0, i2.assertNodeType)("Identifier") } } });
  const p = () => ({ abstract: { validate: (0, i2.assertValueType)("boolean"), optional: true }, accessibility: { validate: (0, i2.assertOneOf)("public", "private", "protected"), optional: true }, static: { default: false }, override: { default: false }, computed: { default: false }, optional: { validate: (0, i2.assertValueType)("boolean"), optional: true }, key: { validate: (0, i2.chain)(function() {
    const e3 = (0, i2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t3 = (0, i2.assertNodeType)("Expression");
    return function(r3, n3, s3) {
      (r3.computed ? t3 : e3)(r3, n3, s3);
    };
  }(), (0, i2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression")) } });
  t2.classMethodOrPropertyCommon = p;
  const d = () => Object.assign({}, a2(), p(), { params: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"))) }, kind: { validate: (0, i2.assertOneOf)("get", "set", "method", "constructor"), default: "method" }, access: { validate: (0, i2.chain)((0, i2.assertValueType)("string"), (0, i2.assertOneOf)("public", "private", "protected")), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true } });
  t2.classMethodOrDeclareMethodCommon = d, o2("ClassMethod", { aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"], builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], fields: Object.assign({}, d(), l(), { body: { validate: (0, i2.assertNodeType)("BlockStatement") } }) }), o2("ObjectPattern", { visitor: ["properties", "typeAnnotation", "decorators"], builder: ["properties"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, u(), { properties: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("RestElement", "ObjectProperty"))) } }) }), o2("SpreadElement", { visitor: ["argument"], aliases: ["UnaryLike"], deprecatedAlias: "SpreadProperty", fields: { argument: { validate: (0, i2.assertNodeType)("Expression") } } }), o2("Super", { aliases: ["Expression"] }), o2("TaggedTemplateExpression", { visitor: ["tag", "quasi", "typeParameters"], builder: ["tag", "quasi"], aliases: ["Expression"], fields: { tag: { validate: (0, i2.assertNodeType)("Expression") }, quasi: { validate: (0, i2.assertNodeType)("TemplateLiteral") }, typeParameters: { validate: (0, i2.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), o2("TemplateElement", { builder: ["value", "tail"], fields: { value: { validate: (0, i2.chain)((0, i2.assertShape)({ raw: { validate: (0, i2.assertValueType)("string") }, cooked: { validate: (0, i2.assertValueType)("string"), optional: true } }), function(e3) {
    const t3 = e3.value.raw;
    let r3 = false;
    const s3 = () => {
      throw new Error("Internal @babel/types error.");
    }, { str: i3, firstInvalidLoc: o3 } = (0, n2.readStringContents)("template", t3, 0, 0, 0, { unterminated() {
      r3 = true;
    }, strictNumericEscape: s3, invalidEscapeSequence: s3, numericSeparatorInEscapeSequence: s3, unexpectedNumericSeparator: s3, invalidDigit: s3, invalidCodePoint: s3 });
    if (!r3) throw new Error("Invalid raw");
    e3.value.cooked = o3 ? null : i3;
  }) }, tail: { default: false } } }), o2("TemplateLiteral", { visitor: ["quasis", "expressions"], aliases: ["Expression", "Literal"], fields: { quasis: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("TemplateElement"))) }, expressions: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Expression", "TSType")), function(e3, t3, r3) {
    if (e3.quasis.length !== r3.length + 1) throw new TypeError(`Number of ${e3.type} quasis should be exactly one more than the number of expressions.
Expected ${r3.length + 1} quasis but got ${e3.quasis.length}`);
  }) } } }), o2("YieldExpression", { builder: ["argument", "delegate"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { delegate: { validate: (0, i2.chain)((0, i2.assertValueType)("boolean"), Object.assign(function(e3, t3, r3) {
  }, { type: "boolean" })), default: false }, argument: { optional: true, validate: (0, i2.assertNodeType)("Expression") } } }), o2("AwaitExpression", { builder: ["argument"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { argument: { validate: (0, i2.assertNodeType)("Expression") } } }), o2("Import", { aliases: ["Expression"] }), o2("BigIntLiteral", { builder: ["value"], fields: { value: { validate: (0, i2.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), o2("ExportNamespaceSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, i2.assertNodeType)("Identifier") } } }), o2("OptionalMemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression"], fields: { object: { validate: (0, i2.assertNodeType)("Expression") }, property: { validate: function() {
    const e3 = (0, i2.assertNodeType)("Identifier"), t3 = (0, i2.assertNodeType)("Expression");
    return Object.assign(function(r3, n3, s3) {
      (r3.computed ? t3 : e3)(r3, n3, s3);
    }, { oneOfNodeTypes: ["Expression", "Identifier"] });
  }() }, computed: { default: false }, optional: { validate: (0, i2.assertValueType)("boolean") } } }), o2("OptionalCallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments", "optional"], aliases: ["Expression"], fields: { callee: { validate: (0, i2.assertNodeType)("Expression") }, arguments: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) }, optional: { validate: (0, i2.assertValueType)("boolean") }, typeArguments: { validate: (0, i2.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, i2.assertNodeType)("TSTypeParameterInstantiation"), optional: true } } }), o2("ClassProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property"], fields: Object.assign({}, p(), { value: { validate: (0, i2.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, i2.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, i2.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true }, readonly: { validate: (0, i2.assertValueType)("boolean"), optional: true }, declare: { validate: (0, i2.assertValueType)("boolean"), optional: true }, variance: { validate: (0, i2.assertNodeType)("Variance"), optional: true } }) }), o2("ClassAccessorProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property", "Accessor"], fields: Object.assign({}, p(), { key: { validate: (0, i2.chain)(function() {
    const e3 = (0, i2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), t3 = (0, i2.assertNodeType)("Expression");
    return function(r3, n3, s3) {
      (r3.computed ? t3 : e3)(r3, n3, s3);
    };
  }(), (0, i2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName")) }, value: { validate: (0, i2.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, i2.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, i2.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true }, readonly: { validate: (0, i2.assertValueType)("boolean"), optional: true }, declare: { validate: (0, i2.assertValueType)("boolean"), optional: true }, variance: { validate: (0, i2.assertNodeType)("Variance"), optional: true } }) }), o2("ClassPrivateProperty", { visitor: ["key", "value", "decorators", "typeAnnotation"], builder: ["key", "value", "decorators", "static"], aliases: ["Property", "Private"], fields: { key: { validate: (0, i2.assertNodeType)("PrivateName") }, value: { validate: (0, i2.assertNodeType)("Expression"), optional: true }, typeAnnotation: { validate: (0, i2.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Decorator"))), optional: true }, static: { validate: (0, i2.assertValueType)("boolean"), default: false }, readonly: { validate: (0, i2.assertValueType)("boolean"), optional: true }, definite: { validate: (0, i2.assertValueType)("boolean"), optional: true }, variance: { validate: (0, i2.assertNodeType)("Variance"), optional: true } } }), o2("ClassPrivateMethod", { builder: ["kind", "key", "params", "body", "static"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"], fields: Object.assign({}, d(), l(), { kind: { validate: (0, i2.assertOneOf)("get", "set", "method"), default: "method" }, key: { validate: (0, i2.assertNodeType)("PrivateName") }, body: { validate: (0, i2.assertNodeType)("BlockStatement") } }) }), o2("PrivateName", { visitor: ["id"], aliases: ["Private"], fields: { id: { validate: (0, i2.assertNodeType)("Identifier") } } }), o2("StaticBlock", { visitor: ["body"], fields: { body: { validate: (0, i2.chain)((0, i2.assertValueType)("array"), (0, i2.assertEach)((0, i2.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "FunctionParent"] });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if (e3 === t3) return true;
    const r3 = n2.PLACEHOLDERS_ALIAS[e3];
    if (r3) {
      for (const e4 of r3) if (t3 === e4) return true;
    }
    return false;
  };
  var n2 = r2(9);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.PLACEHOLDERS_FLIPPED_ALIAS = t2.PLACEHOLDERS_ALIAS = t2.PLACEHOLDERS = void 0;
  var n2 = r2(18);
  const s2 = t2.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"], i2 = t2.PLACEHOLDERS_ALIAS = { Declaration: ["Statement"], Pattern: ["PatternLike", "LVal"] };
  for (const e3 of s2) {
    const t3 = n2.ALIAS_KEYS[e3];
    null != t3 && t3.length && (i2[e3] = t3);
  }
  const o2 = t2.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(i2).forEach((e3) => {
    i2[e3].forEach((t3) => {
      Object.hasOwnProperty.call(o2, t3) || (o2[t3] = []), o2[t3].push(e3);
    });
  });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return !(!e3 || !n2.VISITOR_KEYS[e3.type]);
  };
  var n2 = r2(9);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3) {
    const r3 = Array.from(t3), i2 = /* @__PURE__ */ new Map(), o2 = /* @__PURE__ */ new Map(), a2 = /* @__PURE__ */ new Set(), l = [];
    for (let t4 = 0; t4 < r3.length; t4++) {
      const c = r3[t4];
      if (c && !(l.indexOf(c) >= 0)) {
        if ((0, n2.isAnyTypeAnnotation)(c)) return [c];
        if ((0, n2.isFlowBaseAnnotation)(c)) o2.set(c.type, c);
        else if ((0, n2.isUnionTypeAnnotation)(c)) a2.has(c.types) || (r3.push(...c.types), a2.add(c.types));
        else if ((0, n2.isGenericTypeAnnotation)(c)) {
          const t5 = s2(c.id);
          if (i2.has(t5)) {
            let r4 = i2.get(t5);
            r4.typeParameters ? c.typeParameters && (r4.typeParameters.params.push(...c.typeParameters.params), r4.typeParameters.params = e3(r4.typeParameters.params)) : r4 = c.typeParameters;
          } else i2.set(t5, c);
        } else l.push(c);
      }
    }
    for (const [, e4] of o2) l.push(e4);
    for (const [, e4] of i2) l.push(e4);
    return l;
  };
  var n2 = r2(2);
  function s2(e3) {
    return (0, n2.isIdentifier)(e3) ? e3.name : `${e3.id.name}.${s2(e3.qualification)}`;
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r2) {
    if (!r2 || !e3) return e3;
    const n2 = `${t3}Comments`;
    return e3[n2] ? "leading" === t3 ? e3[n2] = r2.concat(e3[n2]) : e3[n2].push(...r2) : e3[n2] = r2, e3;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    (0, n2.default)("innerComments", e3, t3);
  };
  var n2 = r2(99);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    (0, n2.default)("leadingComments", e3, t3);
  };
  var n2 = r2(99);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    return (0, n2.default)(e3, t3), (0, s2.default)(e3, t3), (0, i2.default)(e3, t3), e3;
  };
  var n2 = r2(176), s2 = r2(174), i2 = r2(173);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    (0, n2.default)("trailingComments", e3, t3);
  };
  var n2 = r2(99);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if ((0, n2.isBlockStatement)(e3)) return e3;
    let r3 = [];
    return (0, n2.isEmptyStatement)(e3) ? r3 = [] : ((0, n2.isStatement)(e3) || (e3 = (0, n2.isFunction)(t3) ? (0, s2.returnStatement)(e3) : (0, s2.expressionStatement)(e3)), r3 = [e3]), (0, s2.blockStatement)(r3);
  };
  var n2 = r2(2), s2 = r2(4);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    e3 += "";
    let t3 = "";
    for (const r3 of e3) t3 += (0, s2.isIdentifierChar)(r3.codePointAt(0)) ? r3 : "-";
    return t3 = t3.replace(/^[-0-9]+/, ""), t3 = t3.replace(/[-\s]+(.)?/g, function(e4, t4) {
      return t4 ? t4.toUpperCase() : "";
    }), (0, n2.default)(t3) || (t3 = `_${t3}`), t3 || "_";
  };
  var n2 = r2(43), s2 = r2(59);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    return (0, n2.default)(e3, s2.default, t3), e3;
  };
  var n2 = r2(180), s2 = r2(181);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, r3, s2) {
    if (!t3) return;
    const i2 = n2.VISITOR_KEYS[t3.type];
    if (i2) {
      r3(t3, s2 = s2 || {});
      for (const n3 of i2) {
        const i3 = t3[n3];
        if (Array.isArray(i3)) for (const t4 of i3) e3(t4, r3, s2);
        else e3(i3, r3, s2);
      }
    }
  };
  var n2 = r2(9);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const t3 = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).preserveComments ? s2 : i2;
    for (const r4 of t3) null != e3[r4] && (e3[r4] = void 0);
    for (const t4 of Object.keys(e3)) "_" === t4[0] && null != e3[t4] && (e3[t4] = void 0);
    const r3 = Object.getOwnPropertySymbols(e3);
    for (const t4 of r3) e3[t4] = null;
  };
  var n2 = r2(26);
  const s2 = ["tokens", "start", "end", "loc", "raw", "rawValue"], i2 = [...n2.COMMENT_KEYS, "comments", ...s2];
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.isVariableDeclaration)(e3) && ("var" !== e3.kind || e3[s2.BLOCK_SCOPED_SYMBOL]);
  };
  var n2 = r2(2), s2 = r2(26);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(401), s2 = r2(14), i2 = r2(402), o2 = r2(403), a2 = r2(0), l = a2, c = r2(35), u = r2(57);
  const { NOT_LOCAL_BINDING: p, callExpression: d, cloneNode: f, getBindingIdentifiers: h, identifier: m, isArrayExpression: y, isBinary: g, isClass: b, isClassBody: v, isClassDeclaration: E, isExportAllDeclaration: S, isExportDefaultDeclaration: x, isExportNamedDeclaration: T, isFunctionDeclaration: w, isIdentifier: P, isImportDeclaration: A, isLiteral: C, isMethod: O, isModuleSpecifier: I, isNullLiteral: _, isObjectExpression: k, isProperty: N, isPureish: D, isRegExpLiteral: j, isSuper: L, isTaggedTemplateExpression: M, isTemplateLiteral: B, isThisExpression: R, isUnaryExpression: F, isVariableDeclaration: U, matchesPattern: $, memberExpression: V, numericLiteral: q, toIdentifier: W, variableDeclaration: G, variableDeclarator: H, isRecordExpression: z, isTupleExpression: K, isObjectProperty: X, isTopicReference: J, isMetaProperty: Y, isPrivateName: Q, isExportDeclaration: Z, buildUndefinedNode: ee } = a2;
  function te(e3, t3) {
    switch (null == e3 ? void 0 : e3.type) {
      default:
        var r3;
        if (A(e3) || Z(e3)) if ((S(e3) || T(e3) || A(e3)) && e3.source) te(e3.source, t3);
        else if ((T(e3) || A(e3)) && null != (r3 = e3.specifiers) && r3.length) for (const r4 of e3.specifiers) te(r4, t3);
        else (x(e3) || T(e3)) && e3.declaration && te(e3.declaration, t3);
        else I(e3) ? te(e3.local, t3) : !C(e3) || _(e3) || j(e3) || B(e3) || t3.push(e3.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        te(e3.object, t3), te(e3.property, t3);
        break;
      case "Identifier":
      case "JSXIdentifier":
        t3.push(e3.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        te(e3.callee, t3);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (const r4 of e3.properties) te(r4, t3);
        break;
      case "SpreadElement":
      case "RestElement":
      case "UnaryExpression":
      case "UpdateExpression":
        te(e3.argument, t3);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        te(e3.key, t3);
        break;
      case "ThisExpression":
        t3.push("this");
        break;
      case "Super":
        t3.push("super");
        break;
      case "Import":
        t3.push("import");
        break;
      case "DoExpression":
        t3.push("do");
        break;
      case "YieldExpression":
        t3.push("yield"), te(e3.argument, t3);
        break;
      case "AwaitExpression":
        t3.push("await"), te(e3.argument, t3);
        break;
      case "AssignmentExpression":
        te(e3.left, t3);
        break;
      case "VariableDeclarator":
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
      case "PrivateName":
        te(e3.id, t3);
        break;
      case "ParenthesizedExpression":
        te(e3.expression, t3);
        break;
      case "MetaProperty":
        te(e3.meta, t3), te(e3.property, t3);
        break;
      case "JSXElement":
        te(e3.openingElement, t3);
        break;
      case "JSXOpeningElement":
        te(e3.name, t3);
        break;
      case "JSXFragment":
        te(e3.openingFragment, t3);
        break;
      case "JSXOpeningFragment":
        t3.push("Fragment");
        break;
      case "JSXNamespacedName":
        te(e3.namespace, t3), te(e3.name, t3);
    }
  }
  const re = { ForStatement(e3) {
    const t3 = e3.get("init");
    if (t3.isVar()) {
      const { scope: r3 } = e3;
      (r3.getFunctionParent() || r3.getProgramParent()).registerBinding("var", t3);
    }
  }, Declaration(e3) {
    e3.isBlockScoped() || e3.isImportDeclaration() || e3.isExportDeclaration() || (e3.scope.getFunctionParent() || e3.scope.getProgramParent()).registerDeclaration(e3);
  }, ImportDeclaration(e3) {
    e3.scope.getBlockParent().registerDeclaration(e3);
  }, ReferencedIdentifier(e3, t3) {
    t3.references.push(e3);
  }, ForXStatement(e3, t3) {
    const r3 = e3.get("left");
    if (r3.isPattern() || r3.isIdentifier()) t3.constantViolations.push(e3);
    else if (r3.isVar()) {
      const { scope: t4 } = e3;
      (t4.getFunctionParent() || t4.getProgramParent()).registerBinding("var", r3);
    }
  }, ExportDeclaration: { exit(e3) {
    const { node: t3, scope: r3 } = e3;
    if (S(t3)) return;
    const n3 = t3.declaration;
    if (E(n3) || w(n3)) {
      const t4 = n3.id;
      if (!t4) return;
      const s3 = r3.getBinding(t4.name);
      null == s3 || s3.reference(e3);
    } else if (U(n3)) for (const t4 of n3.declarations) for (const n4 of Object.keys(h(t4))) {
      const t5 = r3.getBinding(n4);
      null == t5 || t5.reference(e3);
    }
  } }, LabeledStatement(e3) {
    e3.scope.getBlockParent().registerDeclaration(e3);
  }, AssignmentExpression(e3, t3) {
    t3.assignments.push(e3);
  }, UpdateExpression(e3, t3) {
    t3.constantViolations.push(e3);
  }, UnaryExpression(e3, t3) {
    "delete" === e3.node.operator && t3.constantViolations.push(e3);
  }, BlockScoped(e3) {
    let t3 = e3.scope;
    if (t3.path === e3 && (t3 = t3.parent), t3.getBlockParent().registerDeclaration(e3), e3.isClassDeclaration() && e3.node.id) {
      const t4 = e3.node.id.name;
      e3.scope.bindings[t4] = e3.scope.parent.getBinding(t4);
    }
  }, CatchClause(e3) {
    e3.scope.registerBinding("let", e3);
  }, Function(e3) {
    const t3 = e3.get("params");
    for (const r3 of t3) e3.scope.registerBinding("param", r3);
    e3.isFunctionExpression() && e3.has("id") && !e3.get("id").node[p] && e3.scope.registerBinding("local", e3.get("id"), e3);
  }, ClassExpression(e3) {
    e3.has("id") && !e3.get("id").node[p] && e3.scope.registerBinding("local", e3);
  } };
  let ne = 0;
  class se {
    constructor(e3) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      const { node: t3 } = e3, r3 = c.scope.get(t3);
      if ((null == r3 ? void 0 : r3.path) === e3) return r3;
      c.scope.set(t3, this), this.uid = ne++, this.block = t3, this.path = e3, this.labels = /* @__PURE__ */ new Map(), this.inited = false;
    }
    get parent() {
      var e3;
      let t3, r3 = this.path;
      do {
        const e4 = "key" === r3.key || "decorators" === r3.listKey;
        r3 = r3.parentPath, e4 && r3.isMethod() && (r3 = r3.parentPath), r3 && r3.isScope() && (t3 = r3);
      } while (r3 && !t3);
      return null == (e3 = t3) ? void 0 : e3.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(e3, t3, r3) {
      (0, s2.default)(e3, t3, this, r3, this.path);
    }
    generateDeclaredUidIdentifier(e3) {
      const t3 = this.generateUidIdentifier(e3);
      return this.push({ id: t3 }), f(t3);
    }
    generateUidIdentifier(e3) {
      return m(this.generateUid(e3));
    }
    generateUid() {
      let e3, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "temp";
      t3 = W(t3).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let r3 = 1;
      do {
        e3 = this._generateUid(t3, r3), r3++;
      } while (this.hasLabel(e3) || this.hasBinding(e3) || this.hasGlobal(e3) || this.hasReference(e3));
      const n3 = this.getProgramParent();
      return n3.references[e3] = true, n3.uids[e3] = true, e3;
    }
    _generateUid(e3, t3) {
      let r3 = e3;
      return t3 > 1 && (r3 += t3), `_${r3}`;
    }
    generateUidBasedOnNode(e3, t3) {
      const r3 = [];
      te(e3, r3);
      let n3 = r3.join("$");
      return n3 = n3.replace(/^_/, "") || t3 || "ref", this.generateUid(n3.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(e3, t3) {
      return m(this.generateUidBasedOnNode(e3, t3));
    }
    isStatic(e3) {
      if (R(e3) || L(e3) || J(e3)) return true;
      if (P(e3)) {
        const t3 = this.getBinding(e3.name);
        return t3 ? t3.constant : this.hasBinding(e3.name);
      }
      return false;
    }
    maybeGenerateMemoised(e3, t3) {
      if (this.isStatic(e3)) return null;
      {
        const r3 = this.generateUidIdentifierBasedOnNode(e3);
        return t3 ? r3 : (this.push({ id: r3 }), f(r3));
      }
    }
    checkBlockScopedCollisions(e3, t3, r3, n3) {
      if ("param" !== t3 && "local" !== e3.kind && ("let" === t3 || "let" === e3.kind || "const" === e3.kind || "module" === e3.kind || "param" === e3.kind && "const" === t3)) throw this.hub.buildError(n3, `Duplicate declaration "${r3}"`, TypeError);
    }
    rename(e3, t3) {
      const r3 = this.getBinding(e3);
      r3 && (t3 || (t3 = this.generateUidIdentifier(e3).name), new n2.default(r3, e3, t3).rename(arguments[2]));
    }
    _renameFromMap(e3, t3, r3, n3) {
      e3[t3] && (e3[r3] = n3, e3[t3] = null);
    }
    dump() {
      "-".repeat(60);
      let e3 = this;
      do {
        for (const t3 of Object.keys(e3.bindings)) e3.bindings[t3];
      } while (e3 = e3.parent);
    }
    toArray(e3, t3, r3) {
      if (P(e3)) {
        const t4 = this.getBinding(e3.name);
        if (null != t4 && t4.constant && t4.path.isGenericType("Array")) return e3;
      }
      if (y(e3)) return e3;
      if (P(e3, { name: "arguments" })) return d(V(V(V(m("Array"), m("prototype")), m("slice")), m("call")), [e3]);
      let n3;
      const s3 = [e3];
      return true === t3 ? n3 = "toConsumableArray" : "number" == typeof t3 ? (s3.push(q(t3)), n3 = "slicedToArray") : n3 = "toArray", r3 && (s3.unshift(this.hub.addHelper(n3)), n3 = "maybeArrayLike"), d(this.hub.addHelper(n3), s3);
    }
    hasLabel(e3) {
      return !!this.getLabel(e3);
    }
    getLabel(e3) {
      return this.labels.get(e3);
    }
    registerLabel(e3) {
      this.labels.set(e3.node.label.name, e3);
    }
    registerDeclaration(e3) {
      if (e3.isLabeledStatement()) this.registerLabel(e3);
      else if (e3.isFunctionDeclaration()) this.registerBinding("hoisted", e3.get("id"), e3);
      else if (e3.isVariableDeclaration()) {
        const t3 = e3.get("declarations"), { kind: r3 } = e3.node;
        for (const e4 of t3) this.registerBinding("using" === r3 || "await using" === r3 ? "const" : r3, e4);
      } else if (e3.isClassDeclaration()) {
        if (e3.node.declare) return;
        this.registerBinding("let", e3);
      } else if (e3.isImportDeclaration()) {
        const t3 = "type" === e3.node.importKind || "typeof" === e3.node.importKind, r3 = e3.get("specifiers");
        for (const e4 of r3) {
          const r4 = t3 || e4.isImportSpecifier() && ("type" === e4.node.importKind || "typeof" === e4.node.importKind);
          this.registerBinding(r4 ? "unknown" : "module", e4);
        }
      } else if (e3.isExportDeclaration()) {
        const t3 = e3.get("declaration");
        (t3.isClassDeclaration() || t3.isFunctionDeclaration() || t3.isVariableDeclaration()) && this.registerDeclaration(t3);
      } else this.registerBinding("unknown", e3);
    }
    buildUndefinedNode() {
      return ee();
    }
    registerConstantViolation(e3) {
      const t3 = e3.getBindingIdentifiers();
      for (const n3 of Object.keys(t3)) {
        var r3;
        null == (r3 = this.getBinding(n3)) || r3.reassign(e3);
      }
    }
    registerBinding(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t3;
      if (!e3) throw new ReferenceError("no `kind`");
      if (t3.isVariableDeclaration()) {
        const r4 = t3.get("declarations");
        for (const t4 of r4) this.registerBinding(e3, t4);
        return;
      }
      const n3 = this.getProgramParent(), s3 = t3.getOuterBindingIdentifiers(true);
      for (const t4 of Object.keys(s3)) {
        n3.references[t4] = true;
        for (const n4 of s3[t4]) {
          const s4 = this.getOwnBinding(t4);
          if (s4) {
            if (s4.identifier === n4) continue;
            this.checkBlockScopedCollisions(s4, e3, t4, n4);
          }
          s4 ? this.registerConstantViolation(r3) : this.bindings[t4] = new i2.default({ identifier: n4, scope: this, path: r3, kind: e3 });
        }
      }
    }
    addGlobal(e3) {
      this.globals[e3.name] = e3;
    }
    hasUid(e3) {
      let t3 = this;
      do {
        if (t3.uids[e3]) return true;
      } while (t3 = t3.parent);
      return false;
    }
    hasGlobal(e3) {
      let t3 = this;
      do {
        if (t3.globals[e3]) return true;
      } while (t3 = t3.parent);
      return false;
    }
    hasReference(e3) {
      return !!this.getProgramParent().references[e3];
    }
    isPure(e3, t3) {
      if (P(e3)) {
        const r4 = this.getBinding(e3.name);
        return !!r4 && (!t3 || r4.constant);
      }
      if (R(e3) || Y(e3) || J(e3) || Q(e3)) return true;
      var r3, n3, s3;
      if (b(e3)) return !(e3.superClass && !this.isPure(e3.superClass, t3)) && !((null == (r3 = e3.decorators) ? void 0 : r3.length) > 0) && this.isPure(e3.body, t3);
      if (v(e3)) {
        for (const r4 of e3.body) if (!this.isPure(r4, t3)) return false;
        return true;
      }
      if (g(e3)) return this.isPure(e3.left, t3) && this.isPure(e3.right, t3);
      if (y(e3) || K(e3)) {
        for (const r4 of e3.elements) if (null !== r4 && !this.isPure(r4, t3)) return false;
        return true;
      }
      if (k(e3) || z(e3)) {
        for (const r4 of e3.properties) if (!this.isPure(r4, t3)) return false;
        return true;
      }
      if (O(e3)) return !(e3.computed && !this.isPure(e3.key, t3) || (null == (n3 = e3.decorators) ? void 0 : n3.length) > 0);
      if (N(e3)) return !(e3.computed && !this.isPure(e3.key, t3) || (null == (s3 = e3.decorators) ? void 0 : s3.length) > 0 || (X(e3) || e3.static) && null !== e3.value && !this.isPure(e3.value, t3));
      if (F(e3)) return this.isPure(e3.argument, t3);
      if (M(e3)) return $(e3.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(e3.quasi, t3);
      if (B(e3)) {
        for (const r4 of e3.expressions) if (!this.isPure(r4, t3)) return false;
        return true;
      }
      return D(e3);
    }
    setData(e3, t3) {
      return this.data[e3] = t3;
    }
    getData(e3) {
      let t3 = this;
      do {
        const r3 = t3.data[e3];
        if (null != r3) return r3;
      } while (t3 = t3.parent);
    }
    removeData(e3) {
      let t3 = this;
      do {
        null != t3.data[e3] && (t3.data[e3] = null);
      } while (t3 = t3.parent);
    }
    init() {
      this.inited || (this.inited = true, this.crawl());
    }
    crawl() {
      const e3 = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      const t3 = this.getProgramParent();
      if (t3.crawling) return;
      const r3 = { references: [], constantViolations: [], assignments: [] };
      if (this.crawling = true, "Program" !== e3.type && (0, u.isExplodedVisitor)(re)) {
        for (const t5 of re.enter) t5.call(r3, e3, r3);
        const t4 = re[e3.type];
        if (t4) for (const n3 of t4.enter) n3.call(r3, e3, r3);
      }
      e3.traverse(re, r3), this.crawling = false;
      for (const e4 of r3.assignments) {
        const r4 = e4.getBindingIdentifiers();
        for (const n3 of Object.keys(r4)) e4.scope.getBinding(n3) || t3.addGlobal(r4[n3]);
        e4.scope.registerConstantViolation(e4);
      }
      for (const e4 of r3.references) {
        const r4 = e4.scope.getBinding(e4.node.name);
        r4 ? r4.reference(e4) : t3.addGlobal(e4.node);
      }
      for (const e4 of r3.constantViolations) e4.scope.registerConstantViolation(e4);
    }
    push(e3) {
      let t3 = this.path;
      t3.isPattern() ? t3 = this.getPatternParent().path : t3.isBlockStatement() || t3.isProgram() || (t3 = this.getBlockParent().path), t3.isSwitchStatement() && (t3 = (this.getFunctionParent() || this.getProgramParent()).path);
      const { init: r3, unique: n3, kind: s3 = "var", id: i3 } = e3;
      if (!r3 && !n3 && ("var" === s3 || "let" === s3) && t3.isFunction() && !t3.node.name && l.isCallExpression(t3.parent, { callee: t3.node }) && t3.parent.arguments.length <= t3.node.params.length && l.isIdentifier(i3)) return t3.pushContainer("params", i3), void t3.scope.registerBinding("param", t3.get("params")[t3.node.params.length - 1]);
      (t3.isLoop() || t3.isCatchClause() || t3.isFunction()) && (t3.ensureBlock(), t3 = t3.get("body"));
      const o3 = null == e3._blockHoist ? 2 : e3._blockHoist, a3 = `declaration:${s3}:${o3}`;
      let c2 = !n3 && t3.getData(a3);
      if (!c2) {
        const e4 = G(s3, []);
        e4._blockHoist = o3, [c2] = t3.unshiftContainer("body", [e4]), n3 || t3.setData(a3, c2);
      }
      const u2 = H(i3, r3), p2 = c2.node.declarations.push(u2);
      t3.scope.registerBinding(s3, c2.get("declarations")[p2 - 1]);
    }
    getProgramParent() {
      let e3 = this;
      do {
        if (e3.path.isProgram()) return e3;
      } while (e3 = e3.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let e3 = this;
      do {
        if (e3.path.isFunctionParent()) return e3;
      } while (e3 = e3.parent);
      return null;
    }
    getBlockParent() {
      let e3 = this;
      do {
        if (e3.path.isBlockParent()) return e3;
      } while (e3 = e3.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let e3 = this;
      do {
        if (!e3.path.isPattern()) return e3.getBlockParent();
      } while (e3 = e3.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      const e3 = /* @__PURE__ */ Object.create(null);
      let t3 = this;
      do {
        for (const r3 of Object.keys(t3.bindings)) r3 in e3 == 0 && (e3[r3] = t3.bindings[r3]);
        t3 = t3.parent;
      } while (t3);
      return e3;
    }
    getAllBindingsOfKind() {
      const e3 = /* @__PURE__ */ Object.create(null);
      for (var t3 = arguments.length, r3 = new Array(t3), n3 = 0; n3 < t3; n3++) r3[n3] = arguments[n3];
      for (const t4 of r3) {
        let r4 = this;
        do {
          for (const n4 of Object.keys(r4.bindings)) {
            const s3 = r4.bindings[n4];
            s3.kind === t4 && (e3[n4] = s3);
          }
          r4 = r4.parent;
        } while (r4);
      }
      return e3;
    }
    bindingIdentifierEquals(e3, t3) {
      return this.getBindingIdentifier(e3) === t3;
    }
    getBinding(e3) {
      let t3, r3 = this;
      do {
        const s3 = r3.getOwnBinding(e3);
        var n3;
        if (s3) {
          if (null == (n3 = t3) || !n3.isPattern() || "param" === s3.kind || "local" === s3.kind) return s3;
        } else if (!s3 && "arguments" === e3 && r3.path.isFunction() && !r3.path.isArrowFunctionExpression()) break;
        t3 = r3.path;
      } while (r3 = r3.parent);
    }
    getOwnBinding(e3) {
      return this.bindings[e3];
    }
    getBindingIdentifier(e3) {
      var t3;
      return null == (t3 = this.getBinding(e3)) ? void 0 : t3.identifier;
    }
    getOwnBindingIdentifier(e3) {
      const t3 = this.bindings[e3];
      return null == t3 ? void 0 : t3.identifier;
    }
    hasOwnBinding(e3) {
      return !!this.getOwnBinding(e3);
    }
    hasBinding(e3, t3) {
      var r3, n3, s3;
      return !(!e3 || !this.hasOwnBinding(e3) && ("boolean" == typeof t3 && (t3 = { noGlobals: t3 }), !this.parentHasBinding(e3, t3) && (null != (r3 = t3) && r3.noUids || !this.hasUid(e3)) && (null != (n3 = t3) && n3.noGlobals || !se.globals.includes(e3)) && (null != (s3 = t3) && s3.noGlobals || !se.contextVariables.includes(e3))));
    }
    parentHasBinding(e3, t3) {
      var r3;
      return null == (r3 = this.parent) ? void 0 : r3.hasBinding(e3, t3);
    }
    moveBindingTo(e3, t3) {
      const r3 = this.getBinding(e3);
      r3 && (r3.scope.removeOwnBinding(e3), r3.scope = t3, t3.bindings[e3] = r3);
    }
    removeOwnBinding(e3) {
      delete this.bindings[e3];
    }
    removeBinding(e3) {
      var t3;
      null == (t3 = this.getBinding(e3)) || t3.scope.removeOwnBinding(e3);
      let r3 = this;
      do {
        r3.uids[e3] && (r3.uids[e3] = false);
      } while (r3 = r3.parent);
    }
  }
  t2.default = se, se.globals = Object.keys(o2.builtin), se.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.needsParens = function(e3, t3, r3) {
    var n3;
    return !!t3 && (!(!u(t3) || t3.callee !== e3 || !h(e3)) || (null == (n3 = d.get(e3.type)) ? void 0 : n3(e3, t3, r3)));
  }, t2.needsWhitespace = m, t2.needsWhitespaceAfter = function(e3, t3) {
    return m(e3, t3, 2);
  }, t2.needsWhitespaceBefore = function(e3, t3) {
    return m(e3, t3, 1);
  };
  var n2 = r2(410), s2 = r2(411), i2 = r2(0);
  const { FLIPPED_ALIAS_KEYS: o2, isCallExpression: a2, isExpressionStatement: l, isMemberExpression: c, isNewExpression: u } = i2;
  function p(e3) {
    const t3 = /* @__PURE__ */ new Map();
    function r3(e4, r4) {
      const n3 = t3.get(e4);
      t3.set(e4, n3 ? function(e5, t4, s3) {
        var i3;
        return null != (i3 = n3(e5, t4, s3)) ? i3 : r4(e5, t4, s3);
      } : r4);
    }
    for (const t4 of Object.keys(e3)) {
      const n3 = o2[t4];
      if (n3) for (const s3 of n3) r3(s3, e3[t4]);
      else r3(t4, e3[t4]);
    }
    return t3;
  }
  const d = p(s2), f = p(n2.nodes);
  function h(e3) {
    return !!a2(e3) || c(e3) && h(e3.object);
  }
  function m(e3, t3, r3) {
    var n3;
    if (!e3) return false;
    l(e3) && (e3 = e3.expression);
    const s3 = null == (n3 = f.get(e3.type)) ? void 0 : n3(e3, t3);
    return "number" == typeof s3 && 0 != (s3 & r3);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ExportAllDeclaration = function(e3) {
    var t3, r3;
    this.word("export"), this.space(), "type" === e3.exportKind && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), null != (t3 = e3.attributes) && t3.length || null != (r3 = e3.assertions) && r3.length ? (this.print(e3.source, e3, true), this.space(), this._printAttributes(e3)) : this.print(e3.source, e3), this.semicolon();
  }, t2.ExportDefaultDeclaration = function(e3) {
    p(this, e3), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
    const t3 = e3.declaration;
    this.print(t3, e3), c(t3) || this.semicolon();
  }, t2.ExportDefaultSpecifier = function(e3) {
    this.print(e3.exported, e3);
  }, t2.ExportNamedDeclaration = function(e3) {
    if (p(this, e3), this.word("export"), this.space(), e3.declaration) {
      const t4 = e3.declaration;
      this.print(t4, e3), c(t4) || this.semicolon();
    } else {
      "type" === e3.exportKind && (this.word("type"), this.space());
      const n3 = e3.specifiers.slice(0);
      let s3 = false;
      for (; ; ) {
        const t4 = n3[0];
        if (!i2(t4) && !o2(t4)) break;
        s3 = true, this.print(n3.shift(), e3), n3.length && (this.tokenChar(44), this.space());
      }
      var t3, r3;
      (n3.length || !n3.length && !s3) && (this.tokenChar(123), n3.length && (this.space(), this.printList(n3, e3), this.space()), this.tokenChar(125)), e3.source && (this.space(), this.word("from"), this.space(), null != (t3 = e3.attributes) && t3.length || null != (r3 = e3.assertions) && r3.length ? (this.print(e3.source, e3, true), this.space(), this._printAttributes(e3)) : this.print(e3.source, e3)), this.semicolon();
    }
  }, t2.ExportNamespaceSpecifier = function(e3) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e3.exported, e3);
  }, t2.ExportSpecifier = function(e3) {
    "type" === e3.exportKind && (this.word("type"), this.space()), this.print(e3.local, e3), e3.exported && e3.local.name !== e3.exported.name && (this.space(), this.word("as"), this.space(), this.print(e3.exported, e3));
  }, t2.ImportAttribute = function(e3) {
    this.print(e3.key), this.tokenChar(58), this.space(), this.print(e3.value);
  }, t2.ImportDeclaration = function(e3) {
    var t3, r3;
    this.word("import"), this.space();
    const n3 = "type" === e3.importKind || "typeof" === e3.importKind;
    n3 ? (this.noIndentInnerCommentsHere(), this.word(e3.importKind), this.space()) : e3.module ? (this.noIndentInnerCommentsHere(), this.word("module"), this.space()) : e3.phase && (this.noIndentInnerCommentsHere(), this.word(e3.phase), this.space());
    const s3 = e3.specifiers.slice(0), i3 = !!s3.length;
    for (; i3; ) {
      const t4 = s3[0];
      if (!a2(t4) && !l(t4)) break;
      this.print(s3.shift(), e3), s3.length && (this.tokenChar(44), this.space());
    }
    s3.length ? (this.tokenChar(123), this.space(), this.printList(s3, e3), this.space(), this.tokenChar(125)) : n3 && !i3 && (this.tokenChar(123), this.tokenChar(125)), (i3 || n3) && (this.space(), this.word("from"), this.space()), null != (t3 = e3.attributes) && t3.length || null != (r3 = e3.assertions) && r3.length ? (this.print(e3.source, e3, true), this.space(), this._printAttributes(e3)) : this.print(e3.source, e3), this.semicolon();
  }, t2.ImportDefaultSpecifier = function(e3) {
    this.print(e3.local, e3);
  }, t2.ImportExpression = function(e3) {
    this.word("import"), e3.phase && (this.tokenChar(46), this.word(e3.phase)), this.tokenChar(40), this.print(e3.source, e3), null != e3.options && (this.tokenChar(44), this.space(), this.print(e3.options, e3)), this.tokenChar(41);
  }, t2.ImportNamespaceSpecifier = function(e3) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e3.local, e3);
  }, t2.ImportSpecifier = function(e3) {
    "type" !== e3.importKind && "typeof" !== e3.importKind || (this.word(e3.importKind), this.space()), this.print(e3.imported, e3), e3.local && e3.local.name !== e3.imported.name && (this.space(), this.word("as"), this.space(), this.print(e3.local, e3));
  }, t2._printAttributes = function(e3) {
    const { importAttributesKeyword: t3 } = this.format, { attributes: r3, assertions: n3 } = e3;
    !r3 || t3 || u || (u = true);
    const s3 = "assert" === t3 || !t3 && n3;
    this.word(s3 ? "assert" : "with"), this.space(), s3 || "with" === t3 ? (this.tokenChar(123), this.space(), this.printList(r3 || n3, e3), this.space(), this.tokenChar(125)) : this.printList(r3 || n3, e3);
  };
  var n2 = r2(0);
  const { isClassDeclaration: s2, isExportDefaultSpecifier: i2, isExportNamespaceSpecifier: o2, isImportDefaultSpecifier: a2, isImportNamespaceSpecifier: l, isStatement: c } = n2;
  let u = false;
  function p(e3, t3) {
    s2(t3.declaration) && e3._shouldPrintDecoratorsBeforeExport(t3) && e3.printJoin(t3.declaration.decorators, t3);
  }
}, (e2, t2, r2) => {
  r2(44), Object.defineProperty(t2, "__esModule", { value: true }), t2.ArgumentPlaceholder = function() {
    this.tokenChar(63);
  }, t2.ArrayPattern = t2.ArrayExpression = function(e3) {
    const t3 = e3.elements, r3 = t3.length;
    this.tokenChar(91);
    for (let n3 = 0; n3 < t3.length; n3++) {
      const s3 = t3[n3];
      s3 ? (n3 > 0 && this.space(), this.print(s3, e3), n3 < r3 - 1 && this.tokenChar(44)) : this.tokenChar(44);
    }
    this.tokenChar(93);
  }, t2.BigIntLiteral = function(e3) {
    const t3 = this.getPossibleRaw(e3);
    this.format.minified || void 0 === t3 ? this.word(e3.value + "n") : this.word(t3);
  }, t2.BooleanLiteral = function(e3) {
    this.word(e3.value ? "true" : "false");
  }, t2.DecimalLiteral = function(e3) {
    const t3 = this.getPossibleRaw(e3);
    this.format.minified || void 0 === t3 ? this.word(e3.value + "m") : this.word(t3);
  }, t2.Identifier = function(e3) {
    var t3;
    this.sourceIdentifierName((null == (t3 = e3.loc) ? void 0 : t3.identifierName) || e3.name), this.word(e3.name);
  }, t2.NullLiteral = function() {
    this.word("null");
  }, t2.NumericLiteral = function(e3) {
    const t3 = this.getPossibleRaw(e3), r3 = this.format.jsescOption, n3 = e3.value, i3 = n3 + "";
    r3.numbers ? this.number(s2(n3, r3), n3) : null == t3 ? this.number(i3, n3) : this.format.minified ? this.number(t3.length < i3.length ? t3 : i3, n3) : this.number(t3, n3);
  }, t2.ObjectPattern = t2.ObjectExpression = function(e3) {
    const t3 = e3.properties;
    this.tokenChar(123), t3.length && (this.space(), this.printList(t3, e3, { indent: true, statement: true }), this.space()), this.sourceWithOffset("end", e3.loc, -1), this.tokenChar(125);
  }, t2.ObjectMethod = function(e3) {
    this.printJoin(e3.decorators, e3), this._methodHead(e3), this.space(), this.print(e3.body, e3);
  }, t2.ObjectProperty = function(e3) {
    if (this.printJoin(e3.decorators, e3), e3.computed) this.tokenChar(91), this.print(e3.key, e3), this.tokenChar(93);
    else {
      if (i2(e3.value) && o2(e3.key) && e3.key.name === e3.value.left.name) return void this.print(e3.value, e3);
      if (this.print(e3.key, e3), e3.shorthand && o2(e3.key) && o2(e3.value) && e3.key.name === e3.value.name) return;
    }
    this.tokenChar(58), this.space(), this.print(e3.value, e3);
  }, t2.PipelineBareFunction = function(e3) {
    this.print(e3.callee, e3);
  }, t2.PipelinePrimaryTopicReference = function() {
    this.tokenChar(35);
  }, t2.PipelineTopicExpression = function(e3) {
    this.print(e3.expression, e3);
  }, t2.RecordExpression = function(e3) {
    const t3 = e3.properties;
    let r3, n3;
    if ("bar" === this.format.recordAndTupleSyntaxType) r3 = "{|", n3 = "|}";
    else {
      if ("hash" !== this.format.recordAndTupleSyntaxType && null != this.format.recordAndTupleSyntaxType) throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
      r3 = "#{", n3 = "}";
    }
    this.token(r3), t3.length && (this.space(), this.printList(t3, e3, { indent: true, statement: true }), this.space()), this.token(n3);
  }, t2.RegExpLiteral = function(e3) {
    this.word(`/${e3.pattern}/${e3.flags}`);
  }, t2.SpreadElement = t2.RestElement = function(e3) {
    this.token("..."), this.print(e3.argument, e3);
  }, t2.StringLiteral = function(e3) {
    const t3 = this.getPossibleRaw(e3);
    if (!this.format.minified && void 0 !== t3) return void this.token(t3);
    const r3 = s2(e3.value, this.format.jsescOption);
    this.token(r3);
  }, t2.TopicReference = function() {
    const { topicToken: e3 } = this.format;
    if (!a2.has(e3)) {
      const t3 = JSON.stringify(e3), r3 = Array.from(a2, (e4) => JSON.stringify(e4));
      throw new Error(`The "topicToken" generator option must be one of ${r3.join(", ")} (${t3} received instead).`);
    }
    this.token(e3);
  }, t2.TupleExpression = function(e3) {
    const t3 = e3.elements, r3 = t3.length;
    let n3, s3;
    if ("bar" === this.format.recordAndTupleSyntaxType) n3 = "[|", s3 = "|]";
    else {
      if ("hash" !== this.format.recordAndTupleSyntaxType) throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
      n3 = "#[", s3 = "]";
    }
    this.token(n3);
    for (let n4 = 0; n4 < t3.length; n4++) {
      const s4 = t3[n4];
      s4 && (n4 > 0 && this.space(), this.print(s4, e3), n4 < r3 - 1 && this.tokenChar(44));
    }
    this.token(s3);
  };
  var n2 = r2(0), s2 = r2(205);
  const { isAssignmentPattern: i2, isIdentifier: o2 } = n2, a2 = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
}, (e2, t2, r2) => {
  var n2 = r2(105), s2 = TypeError;
  e2.exports = function(e3) {
    if (n2(e3)) throw new s2("Can't call method on " + e3);
    return e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(15), s2 = r2(29), i2 = Function.prototype, o2 = n2 && Object.getOwnPropertyDescriptor, a2 = s2(i2, "name"), l = a2 && "something" === (function() {
  }).name, c = a2 && (!n2 || n2 && o2(i2, "name").configurable);
  e2.exports = { EXISTS: a2, PROPER: l, CONFIGURABLE: c };
}, (e2, t2, r2) => {
  var n2 = r2(19), s2 = r2(6), i2 = r2(64), o2 = n2(Function.toString);
  s2(i2.inspectSource) || (i2.inspectSource = function(e3) {
    return o2(e3);
  }), e2.exports = i2.inspectSource;
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(6), i2 = n2.WeakMap;
  e2.exports = s2(i2) && /native code/.test(String(i2));
}, (e2, t2, r2) => {
  var n2 = r2(15), s2 = r2(11), i2 = r2(192);
  e2.exports = !n2 && !s2(function() {
    return 7 !== Object.defineProperty(i2("div"), "a", { get: function() {
      return 7;
    } }).a;
  });
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(20), i2 = n2.document, o2 = s2(i2) && s2(i2.createElement);
  e2.exports = function(e3) {
    return o2 ? i2.createElement(e3) : {};
  };
}, (e2, t2, r2) => {
  var n2 = r2(15), s2 = r2(11);
  e2.exports = n2 && s2(function() {
    return 42 !== Object.defineProperty(function() {
    }, "prototype", { value: 42, writable: false }).prototype;
  });
}, (e2, t2, r2) => {
  var n2 = r2(195), s2 = r2(110);
  e2.exports = function(e3) {
    var t3 = n2(e3, "string");
    return s2(t3) ? t3 : t3 + "";
  };
}, (e2, t2, r2) => {
  var n2 = r2(66), s2 = r2(20), i2 = r2(110), o2 = r2(199), a2 = r2(200), l = r2(45), c = TypeError, u = l("toPrimitive");
  e2.exports = function(e3, t3) {
    if (!s2(e3) || i2(e3)) return e3;
    var r3, l2 = o2(e3, u);
    if (l2) {
      if (void 0 === t3 && (t3 = "default"), r3 = n2(l2, e3, t3), !s2(r3) || i2(r3)) return r3;
      throw new c("Can't convert object to primitive value");
    }
    return void 0 === t3 && (t3 = "number"), a2(e3, t3);
  };
}, (e2, t2, r2) => {
  var n2 = r2(5), s2 = r2(6);
  e2.exports = function(e3, t3) {
    return arguments.length < 2 ? (r3 = n2[e3], s2(r3) ? r3 : void 0) : n2[e3] && n2[e3][t3];
    var r3;
  };
}, (e2, t2, r2) => {
  var n2, s2, i2 = r2(5), o2 = r2(198), a2 = i2.process, l = i2.Deno, c = a2 && a2.versions || l && l.version, u = c && c.v8;
  u && (s2 = (n2 = u.split("."))[0] > 0 && n2[0] < 4 ? 1 : +(n2[0] + n2[1])), !s2 && o2 && (!(n2 = o2.match(/Edge\/(\d+)/)) || n2[1] >= 74) && (n2 = o2.match(/Chrome\/(\d+)/)) && (s2 = +n2[1]), e2.exports = s2;
}, (e2) => {
  e2.exports = "undefined" != typeof navigator && String(navigator.userAgent) || "";
}, (e2, t2, r2) => {
  var n2 = r2(114), s2 = r2(105);
  e2.exports = function(e3, t3) {
    var r3 = e3[t3];
    return s2(r3) ? void 0 : n2(r3);
  };
}, (e2, t2, r2) => {
  var n2 = r2(66), s2 = r2(6), i2 = r2(20), o2 = TypeError;
  e2.exports = function(e3, t3) {
    var r3, a2;
    if ("string" === t3 && s2(r3 = e3.toString) && !i2(a2 = n2(r3, e3))) return a2;
    if (s2(r3 = e3.valueOf) && !i2(a2 = n2(r3, e3))) return a2;
    if ("string" !== t3 && s2(r3 = e3.toString) && !i2(a2 = n2(r3, e3))) return a2;
    throw new o2("Can't convert object to primitive value");
  };
}, (e2) => {
  e2.exports = false;
}, (e2) => {
  e2.exports = function(e3, t2) {
    return { enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t2 };
  };
}, (e2) => {
  e2.exports = {};
}, (e2, t2, r2) => {
  var n2 = r2(65);
  e2.exports = function() {
    var e3 = n2(this), t3 = "";
    return e3.hasIndices && (t3 += "d"), e3.global && (t3 += "g"), e3.ignoreCase && (t3 += "i"), e3.multiline && (t3 += "m"), e3.dotAll && (t3 += "s"), e3.unicode && (t3 += "u"), e3.unicodeSets && (t3 += "v"), e3.sticky && (t3 += "y"), t3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(31).a;
  const s2 = {}, i2 = s2.hasOwnProperty, o2 = (e3, t3) => {
    for (const r3 in e3) i2.call(e3, r3) && t3(r3, e3[r3]);
  }, a2 = s2.toString, l = Array.isArray, c = n2.isBuffer, u = { '"': '\\"', "'": "\\'", "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t" }, p = /["'\\\b\f\n\r\t]/, d = /[0-9]/, f = /[ !#-&\(-\[\]-_a-~]/, h = (e3, t3) => {
    const r3 = () => {
      E = v, ++t3.indentLevel, v = t3.indent.repeat(t3.indentLevel);
    }, n3 = { escapeEverything: false, minimal: false, isScriptContext: false, quotes: "single", wrap: false, es6: false, json: false, compact: true, lowercaseHex: false, numbers: "decimal", indent: "	", indentLevel: 0, __inline1__: false, __inline2__: false }, s3 = t3 && t3.json;
    var i3, m;
    s3 && (n3.quotes = "double", n3.wrap = true), i3 = n3, t3 = (m = t3) ? (o2(m, (e4, t4) => {
      i3[e4] = t4;
    }), i3) : i3, "single" != t3.quotes && "double" != t3.quotes && "backtick" != t3.quotes && (t3.quotes = "single");
    const y = "double" == t3.quotes ? '"' : "backtick" == t3.quotes ? "`" : "'", g = t3.compact, b = t3.lowercaseHex;
    let v = t3.indent.repeat(t3.indentLevel), E = "";
    const S = t3.__inline1__, x = t3.__inline2__, T = g ? "" : "\n";
    let w, P = true;
    const A = "binary" == t3.numbers, C = "octal" == t3.numbers, O = "decimal" == t3.numbers, I = "hexadecimal" == t3.numbers;
    if (s3 && e3 && "function" == typeof e3.toJSON && (e3 = e3.toJSON()), "string" != typeof (_ = e3) && "[object String]" != a2.call(_)) {
      if (((e4) => "[object Map]" == a2.call(e4))(e3)) return 0 == e3.size ? "new Map()" : (g || (t3.__inline1__ = true, t3.__inline2__ = false), "new Map(" + h(Array.from(e3), t3) + ")");
      if (((e4) => "[object Set]" == a2.call(e4))(e3)) return 0 == e3.size ? "new Set()" : "new Set(" + h(Array.from(e3), t3) + ")";
      if (c(e3)) return 0 == e3.length ? "Buffer.from([])" : "Buffer.from(" + h(Array.from(e3), t3) + ")";
      if (l(e3)) return w = [], t3.wrap = true, S && (t3.__inline1__ = false, t3.__inline2__ = true), x || r3(), ((e4, t4) => {
        const r4 = e4.length;
        let n4 = -1;
        for (; ++n4 < r4; ) t4(e4[n4]);
      })(e3, (e4) => {
        P = false, x && (t3.__inline2__ = false), w.push((g || x ? "" : v) + h(e4, t3));
      }), P ? "[]" : x ? "[" + w.join(", ") + "]" : "[" + T + w.join("," + T) + T + (g ? "" : E) + "]";
      if (!((e4) => "number" == typeof e4 || "[object Number]" == a2.call(e4))(e3)) return ((e4) => "[object Object]" == a2.call(e4))(e3) ? (w = [], t3.wrap = true, r3(), o2(e3, (e4, r4) => {
        P = false, w.push((g ? "" : v) + h(e4, t3) + ":" + (g ? "" : " ") + h(r4, t3));
      }), P ? "{}" : "{" + T + w.join("," + T) + T + (g ? "" : E) + "}") : s3 ? JSON.stringify(e3) || "null" : String(e3);
      if (s3) return JSON.stringify(e3);
      if (O) return String(e3);
      if (I) {
        let t4 = e3.toString(16);
        return b || (t4 = t4.toUpperCase()), "0x" + t4;
      }
      if (A) return "0b" + e3.toString(2);
      if (C) return "0o" + e3.toString(8);
    }
    var _;
    const k = e3;
    let N = -1;
    const D = k.length;
    for (w = ""; ++N < D; ) {
      const e4 = k.charAt(N);
      if (t3.es6) {
        const e5 = k.charCodeAt(N);
        if (e5 >= 55296 && e5 <= 56319 && D > N + 1) {
          const t4 = k.charCodeAt(N + 1);
          if (t4 >= 56320 && t4 <= 57343) {
            let r5 = (1024 * (e5 - 55296) + t4 - 56320 + 65536).toString(16);
            b || (r5 = r5.toUpperCase()), w += "\\u{" + r5 + "}", ++N;
            continue;
          }
        }
      }
      if (!t3.escapeEverything) {
        if (f.test(e4)) {
          w += e4;
          continue;
        }
        if ('"' == e4) {
          w += y == e4 ? '\\"' : e4;
          continue;
        }
        if ("`" == e4) {
          w += y == e4 ? "\\`" : e4;
          continue;
        }
        if ("'" == e4) {
          w += y == e4 ? "\\'" : e4;
          continue;
        }
      }
      if ("\0" == e4 && !s3 && !d.test(k.charAt(N + 1))) {
        w += "\\0";
        continue;
      }
      if (p.test(e4)) {
        w += u[e4];
        continue;
      }
      const r4 = e4.charCodeAt(0);
      if (t3.minimal && 8232 != r4 && 8233 != r4) {
        w += e4;
        continue;
      }
      let n4 = r4.toString(16);
      b || (n4 = n4.toUpperCase());
      const i4 = n4.length > 2 || s3, o3 = "\\" + (i4 ? "u" : "x") + ("0000" + n4).slice(i4 ? -4 : -2);
      w += o3;
    }
    return t3.wrap && (w = y + w + y), "`" == y && (w = w.replace(/\$\{/g, "\\${")), t3.isScriptContext ? w.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, s3 ? "\\u003C!--" : "\\x3C!--") : w;
  };
  h.version = "2.5.2", e2.exports = h;
}, (e2, t2, r2) => {
  var n2, s2, i2, o2 = r2(207), a2 = r2(15), l = r2(5), c = r2(6), u = r2(20), p = r2(29), d = r2(208), f = r2(115), h = r2(108), m = r2(211), y = r2(102), g = r2(111), b = r2(212), v = r2(214), E = r2(45), S = r2(67), x = r2(107), T = x.enforce, w = x.get, P = l.Int8Array, A = P && P.prototype, C = l.Uint8ClampedArray, O = C && C.prototype, I = P && b(P), _ = A && b(A), k = Object.prototype, N = l.TypeError, D = E("toStringTag"), j = S("TYPED_ARRAY_TAG"), L = "TypedArrayConstructor", M = o2 && !!v && "Opera" !== d(l.opera), B = false, R = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, F = { BigInt64Array: 8, BigUint64Array: 8 }, U = function(e3) {
    var t3 = b(e3);
    if (u(t3)) {
      var r3 = w(t3);
      return r3 && p(r3, L) ? r3[L] : U(t3);
    }
  }, $ = function(e3) {
    if (!u(e3)) return false;
    var t3 = d(e3);
    return p(R, t3) || p(F, t3);
  };
  for (n2 in R) (i2 = (s2 = l[n2]) && s2.prototype) ? T(i2)[L] = s2 : M = false;
  for (n2 in F) (i2 = (s2 = l[n2]) && s2.prototype) && (T(i2)[L] = s2);
  if ((!M || !c(I) || I === Function.prototype) && (I = function() {
    throw new N("Incorrect invocation");
  }, M)) for (n2 in R) l[n2] && v(l[n2], I);
  if ((!M || !_ || _ === k) && (_ = I.prototype, M)) for (n2 in R) l[n2] && v(l[n2].prototype, _);
  if (M && b(O) !== _ && v(O, _), a2 && !p(_, D)) for (n2 in B = true, y(_, D, { configurable: true, get: function() {
    return u(this) ? this[j] : void 0;
  } }), R) l[n2] && h(l[n2], j, n2);
  e2.exports = { NATIVE_ARRAY_BUFFER_VIEWS: M, TYPED_ARRAY_TAG: B && j, aTypedArray: function(e3) {
    if ($(e3)) return e3;
    throw new N("Target is not a typed array");
  }, aTypedArrayConstructor: function(e3) {
    if (c(e3) && (!v || g(I, e3))) return e3;
    throw new N(f(e3) + " is not a typed array constructor");
  }, exportTypedArrayMethod: function(e3, t3, r3, n3) {
    if (a2) {
      if (r3) for (var s3 in R) {
        var i3 = l[s3];
        if (i3 && p(i3.prototype, e3)) try {
          delete i3.prototype[e3];
        } catch (r4) {
          try {
            i3.prototype[e3] = t3;
          } catch (e4) {
          }
        }
      }
      _[e3] && !r3 || m(_, e3, r3 ? t3 : M && A[e3] || t3, n3);
    }
  }, exportTypedArrayStaticMethod: function(e3, t3, r3) {
    var n3, s3;
    if (a2) {
      if (v) {
        if (r3) {
          for (n3 in R) if ((s3 = l[n3]) && p(s3, e3)) try {
            delete s3[e3];
          } catch (e4) {
          }
        }
        if (I[e3] && !r3) return;
        try {
          return m(I, e3, r3 ? t3 : M && I[e3] || t3);
        } catch (e4) {
        }
      }
      for (n3 in R) !(s3 = l[n3]) || s3[e3] && !r3 || m(s3, e3, t3);
    }
  }, getTypedArrayConstructor: U, isView: function(e3) {
    if (!u(e3)) return false;
    var t3 = d(e3);
    return "DataView" === t3 || p(R, t3) || p(F, t3);
  }, isTypedArray: $, TypedArray: I, TypedArrayPrototype: _ };
}, (e2) => {
  e2.exports = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView;
}, (e2, t2, r2) => {
  var n2 = r2(209), s2 = r2(6), i2 = r2(210), o2 = r2(45)("toStringTag"), a2 = Object, l = "Arguments" === i2(/* @__PURE__ */ function() {
    return arguments;
  }());
  e2.exports = n2 ? i2 : function(e3) {
    var t3, r3, n3;
    return void 0 === e3 ? "Undefined" : null === e3 ? "Null" : "string" == typeof (r3 = function(e4, t4) {
      try {
        return e4[t4];
      } catch (e5) {
      }
    }(t3 = a2(e3), o2)) ? r3 : l ? i2(t3) : "Object" === (n3 = i2(t3)) && s2(t3.callee) ? "Arguments" : n3;
  };
}, (e2, t2, r2) => {
  var n2 = {};
  n2[r2(45)("toStringTag")] = "z", e2.exports = "[object z]" === String(n2);
}, (e2, t2, r2) => {
  var n2 = r2(19), s2 = n2({}.toString), i2 = n2("".slice);
  e2.exports = function(e3) {
    return i2(s2(e3), 8, -1);
  };
}, (e2, t2, r2) => {
  var n2 = r2(6), s2 = r2(109), i2 = r2(103), o2 = r2(106);
  e2.exports = function(e3, t3, r3, a2) {
    a2 || (a2 = {});
    var l = a2.enumerable, c = void 0 !== a2.name ? a2.name : t3;
    if (n2(r3) && i2(r3, c, a2), a2.global) l ? e3[t3] = r3 : o2(t3, r3);
    else {
      try {
        a2.unsafe ? e3[t3] && (l = true) : delete e3[t3];
      } catch (e4) {
      }
      l ? e3[t3] = r3 : s2.f(e3, t3, { value: r3, enumerable: false, configurable: !a2.nonConfigurable, writable: !a2.nonWritable });
    }
    return e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(29), s2 = r2(6), i2 = r2(63), o2 = r2(117), a2 = r2(213), l = o2("IE_PROTO"), c = Object, u = c.prototype;
  e2.exports = a2 ? c.getPrototypeOf : function(e3) {
    var t3 = i2(e3);
    if (n2(t3, l)) return t3[l];
    var r3 = t3.constructor;
    return s2(r3) && t3 instanceof r3 ? r3.prototype : t3 instanceof c ? u : null;
  };
}, (e2, t2, r2) => {
  var n2 = r2(11);
  e2.exports = !n2(function() {
    function e3() {
    }
    return e3.prototype.constructor = null, Object.getPrototypeOf(new e3()) !== e3.prototype;
  });
}, (e2, t2, r2) => {
  var n2 = r2(215), s2 = r2(65), i2 = r2(216);
  e2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
    var e3, t3 = false, r3 = {};
    try {
      (e3 = n2(Object.prototype, "__proto__", "set"))(r3, []), t3 = r3 instanceof Array;
    } catch (e4) {
    }
    return function(r4, n3) {
      return s2(r4), i2(n3), t3 ? e3(r4, n3) : r4.__proto__ = n3, r4;
    };
  }() : void 0);
}, (e2, t2, r2) => {
  var n2 = r2(19), s2 = r2(114);
  e2.exports = function(e3, t3, r3) {
    try {
      return n2(s2(Object.getOwnPropertyDescriptor(e3, t3)[r3]));
    } catch (e4) {
    }
  };
}, (e2, t2, r2) => {
  var n2 = r2(217), s2 = String, i2 = TypeError;
  e2.exports = function(e3) {
    if (n2(e3)) return e3;
    throw new i2("Can't set " + s2(e3) + " as a prototype");
  };
}, (e2, t2, r2) => {
  var n2 = r2(20);
  e2.exports = function(e3) {
    return n2(e3) || null === e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(219);
  e2.exports = function(e3) {
    return n2(e3.length);
  };
}, (e2, t2, r2) => {
  var n2 = r2(118), s2 = Math.min;
  e2.exports = function(e3) {
    var t3 = n2(e3);
    return t3 > 0 ? s2(t3, 9007199254740991) : 0;
  };
}, (e2) => {
  var t2 = Math.ceil, r2 = Math.floor;
  e2.exports = Math.trunc || function(e3) {
    var n2 = +e3;
    return (n2 > 0 ? r2 : t2)(n2);
  };
}, (e2, t2, r2) => {
  var n2 = r2(222), s2 = RangeError;
  e2.exports = function(e3, t3) {
    var r3 = n2(e3);
    if (r3 % t3) throw new s2("Wrong offset");
    return r3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(118), s2 = RangeError;
  e2.exports = function(e3) {
    var t3 = n2(e3);
    if (t3 < 0) throw new s2("The argument can't be less than 0");
    return t3;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.createUnionType = function(e3) {
    return a2(e3[0]) ? s2 ? s2(e3) : o2(e3) : i2 ? i2(e3) : void 0;
  };
  var n2 = r2(0);
  const { createFlowUnionType: s2, createTSUnionType: i2, createUnionTypeAnnotation: o2, isFlowType: a2, isTSType: l } = n2;
}, (e2) => {
  e2.exports = { grey: null, red: { bold: null } };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    const { placeholderWhitelist: n3, placeholderPattern: o3, preserveComments: a3, syntacticPlaceholders: l2 } = r3, c2 = function(e4, t4, r4) {
      const n4 = (t4.plugins || []).slice();
      false !== r4 && n4.push("placeholders"), t4 = Object.assign({ allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, sourceType: "module" }, t4, { plugins: n4 });
      try {
        return (0, s2.parse)(e4, t4);
      } catch (t5) {
        const r5 = t5.loc;
        throw r5 && (t5.message += "\n" + (0, i2.codeFrameColumns)(e4, { start: r5 }), t5.code = "BABEL_TEMPLATE_PARSE_ERROR"), t5;
      }
    }(t3, r3.parser, l2);
    m(c2, { preserveComments: a3 }), e3.validate(c2);
    const u2 = { syntactic: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, legacy: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, placeholderWhitelist: n3, placeholderPattern: o3, syntacticPlaceholders: l2 };
    return y(c2, b, u2), Object.assign({ ast: c2 }, u2.syntactic.placeholders.length ? u2.syntactic : u2.legacy);
  };
  var n2 = r2(0), s2 = r2(21), i2 = r2(36);
  const { isCallExpression: o2, isExpressionStatement: a2, isFunction: l, isIdentifier: c, isJSXIdentifier: u, isNewExpression: p, isPlaceholder: d, isStatement: f, isStringLiteral: h, removePropertiesDeep: m, traverse: y } = n2, g = /^[_$A-Z0-9]+$/;
  function b(e3, t3, r3) {
    var n3;
    let s3, i3 = r3.syntactic.placeholders.length > 0;
    if (d(e3)) {
      if (false === r3.syntacticPlaceholders) throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      s3 = e3.name.name, i3 = true;
    } else {
      if (i3 || r3.syntacticPlaceholders) return;
      if (c(e3) || u(e3)) s3 = e3.name;
      else {
        if (!h(e3)) return;
        s3 = e3.value;
      }
    }
    if (i3 && (null != r3.placeholderPattern || null != r3.placeholderWhitelist)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (!(i3 || false !== r3.placeholderPattern && (r3.placeholderPattern || g).test(s3) || null != (n3 = r3.placeholderWhitelist) && n3.has(s3))) return;
    t3 = t3.slice();
    const { node: m2, key: y2 } = t3[t3.length - 1];
    let b2;
    h(e3) || d(e3, { expectedNode: "StringLiteral" }) ? b2 = "string" : p(m2) && "arguments" === y2 || o2(m2) && "arguments" === y2 || l(m2) && "params" === y2 ? b2 = "param" : a2(m2) && !d(e3) ? (b2 = "statement", t3 = t3.slice(0, -1)) : b2 = f(e3) && d(e3) ? "statement" : "other";
    const { placeholders: v, placeholderNames: E } = i3 ? r3.syntactic : r3.legacy;
    v.push({ name: s3, type: b2, resolve: (e4) => function(e5, t4) {
      let r4 = e5;
      for (let e6 = 0; e6 < t4.length - 1; e6++) {
        const { key: n5, index: s5 } = t4[e6];
        r4 = void 0 === s5 ? r4[n5] : r4[n5][s5];
      }
      const { key: n4, index: s4 } = t4[t4.length - 1];
      return { parent: r4, key: n4, index: s4 };
    }(e4, t3), isDuplicate: E.has(s3) }), E.add(s3);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const r3 = i2(e3.ast);
    return t3 && (e3.placeholders.forEach((e4) => {
      if (!Object.prototype.hasOwnProperty.call(t3, e4.name)) {
        const t4 = e4.name;
        throw new Error(`Error: No substitution given for "${t4}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${t4}'])}
            - { placeholderPattern: /^${t4}$/ }`);
      }
    }), Object.keys(t3).forEach((t4) => {
      if (!e3.placeholderNames.has(t4)) throw new Error(`Unknown substitution "${t4}" given`);
    })), e3.placeholders.slice().reverse().forEach((e4) => {
      try {
        !function(e5, t4, r4) {
          e5.isDuplicate && (Array.isArray(r4) ? r4 = r4.map((e6) => i2(e6)) : "object" == typeof r4 && (r4 = i2(r4)));
          const { parent: n3, key: f, index: h } = e5.resolve(t4);
          if ("string" === e5.type) {
            if ("string" == typeof r4 && (r4 = p(r4)), !r4 || !u(r4)) throw new Error("Expected string substitution");
          } else if ("statement" === e5.type) void 0 === h ? r4 ? Array.isArray(r4) ? r4 = s2(r4) : "string" == typeof r4 ? r4 = a2(l(r4)) : c(r4) || (r4 = a2(r4)) : r4 = o2() : r4 && !Array.isArray(r4) && ("string" == typeof r4 && (r4 = l(r4)), c(r4) || (r4 = a2(r4)));
          else if ("param" === e5.type) {
            if ("string" == typeof r4 && (r4 = l(r4)), void 0 === h) throw new Error("Assertion failure.");
          } else if ("string" == typeof r4 && (r4 = l(r4)), Array.isArray(r4)) throw new Error("Cannot replace single expression with an array.");
          if (void 0 === h) d(n3, f, r4), n3[f] = r4;
          else {
            const t5 = n3[f].slice();
            "statement" === e5.type || "param" === e5.type ? null == r4 ? t5.splice(h, 1) : Array.isArray(r4) ? t5.splice(h, 1, ...r4) : t5[h] = r4 : t5[h] = r4, d(n3, f, t5), n3[f] = t5;
          }
        }(e4, r3, t3 && t3[e4.name] || null);
      } catch (t4) {
        throw t4.message = `@babel/template placeholder "${e4.name}": ${t4.message}`, t4;
      }
    }), r3;
  };
  var n2 = r2(0);
  const { blockStatement: s2, cloneNode: i2, emptyStatement: o2, expressionStatement: a2, identifier: l, isStatement: c, isStringLiteral: u, stringLiteral: p, validate: d } = n2;
}, (e2, t2, r2) => {
  function n2(e3) {
    return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
      return typeof e4;
    } : function(e4) {
      return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
    }, n2(e3);
  }
  function s2(e3, t3) {
    return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
      return e4.__proto__ = t4, e4;
    }, s2(e3, t3);
  }
  function i2(e3) {
    return i2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
      return e4.__proto__ || Object.getPrototypeOf(e4);
    }, i2(e3);
  }
  var o2, a2, l = {};
  function c(e3, t3, r3) {
    r3 || (r3 = Error);
    var o3 = function(r4) {
      !function(e4, t4) {
        if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
        e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && s2(e4, t4);
      }(u2, r4);
      var o4, a3, l2, c2 = (a3 = u2, l2 = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if ("function" == typeof Proxy) return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (e4) {
          return false;
        }
      }(), function() {
        var e4, t4 = i2(a3);
        if (l2) {
          var r5 = i2(this).constructor;
          e4 = Reflect.construct(t4, arguments, r5);
        } else e4 = t4.apply(this, arguments);
        return function(e5, t5) {
          if (t5 && ("object" === n2(t5) || "function" == typeof t5)) return t5;
          if (void 0 !== t5) throw new TypeError("Derived constructors may only return object or undefined");
          return function(e6) {
            if (void 0 === e6) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e6;
          }(e5);
        }(this, e4);
      });
      function u2(r5, n3, s3) {
        var i3;
        return function(e4, t4) {
          if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
        }(this, u2), i3 = c2.call(this, function(e4, r6, n4) {
          return "string" == typeof t3 ? t3 : t3(e4, r6, n4);
        }(r5, n3, s3)), i3.code = e3, i3;
      }
      return o4 = u2, Object.defineProperty(o4, "prototype", { writable: false }), o4;
    }(r3);
    l[e3] = o3;
  }
  function u(e3, t3) {
    if (Array.isArray(e3)) {
      var r3 = e3.length;
      return e3 = e3.map(function(e4) {
        return String(e4);
      }), r3 > 2 ? "one of ".concat(t3, " ").concat(e3.slice(0, r3 - 1).join(", "), ", or ") + e3[r3 - 1] : 2 === r3 ? "one of ".concat(t3, " ").concat(e3[0], " or ").concat(e3[1]) : "of ".concat(t3, " ").concat(e3[0]);
    }
    return "of ".concat(t3, " ").concat(String(e3));
  }
  c("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), c("ERR_INVALID_ARG_TYPE", function(e3, t3, s3) {
    var i3, a3, l2, c2, p;
    if (void 0 === o2 && (o2 = r2(25)), o2("string" == typeof e3, "'name' must be a string"), "string" == typeof t3 && (a3 = "not ", t3.substr(0, 4) === a3) ? (i3 = "must not be", t3 = t3.replace(/^not /, "")) : i3 = "must be", function(e4, t4, r3) {
      return (void 0 === r3 || r3 > e4.length) && (r3 = e4.length), e4.substring(r3 - 9, r3) === t4;
    }(e3, " argument")) l2 = "The ".concat(e3, " ").concat(i3, " ").concat(u(t3, "type"));
    else {
      var d = ("number" != typeof p && (p = 0), p + 1 > (c2 = e3).length || -1 === c2.indexOf(".", p) ? "argument" : "property");
      l2 = 'The "'.concat(e3, '" ').concat(d, " ").concat(i3, " ").concat(u(t3, "type"));
    }
    return l2 + ". Received type ".concat(n2(s3));
  }, TypeError), c("ERR_INVALID_ARG_VALUE", function(e3, t3) {
    var n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
    void 0 === a2 && (a2 = r2(32));
    var s3 = a2.inspect(t3);
    return s3.length > 128 && (s3 = "".concat(s3.slice(0, 128), "...")), "The argument '".concat(e3, "' ").concat(n3, ". Received ").concat(s3);
  }, TypeError, RangeError), c("ERR_INVALID_RETURN_VALUE", function(e3, t3, r3) {
    var s3;
    return s3 = r3 && r3.constructor && r3.constructor.name ? "instance of ".concat(r3.constructor.name) : "type ".concat(n2(r3)), "Expected ".concat(e3, ' to be returned from the "').concat(t3, '"') + " function but got ".concat(s3, ".");
  }, TypeError), c("ERR_MISSING_ARGS", function() {
    for (var e3 = arguments.length, t3 = new Array(e3), n3 = 0; n3 < e3; n3++) t3[n3] = arguments[n3];
    void 0 === o2 && (o2 = r2(25)), o2(t3.length > 0, "At least one arg needs to be specified");
    var s3 = "The ", i3 = t3.length;
    switch (t3 = t3.map(function(e4) {
      return '"'.concat(e4, '"');
    }), i3) {
      case 1:
        s3 += "".concat(t3[0], " argument");
        break;
      case 2:
        s3 += "".concat(t3[0], " and ").concat(t3[1], " arguments");
        break;
      default:
        s3 += t3.slice(0, i3 - 1).join(", "), s3 += ", and ".concat(t3[i3 - 1], " arguments");
    }
    return "".concat(s3, " must be specified");
  }, TypeError), e2.exports.codes = l;
}, (e2, t2, r2) => {
  r2(12);
  var n2 = r2(229), s2 = r2(235), i2 = r2(122), o2 = r2(239);
  function a2(e3) {
    return e3.call.bind(e3);
  }
  var l = "undefined" != typeof BigInt, c = "undefined" != typeof Symbol, u = a2(Object.prototype.toString), p = a2(Number.prototype.valueOf), d = a2(String.prototype.valueOf), f = a2(Boolean.prototype.valueOf);
  if (l) var h = a2(BigInt.prototype.valueOf);
  if (c) var m = a2(Symbol.prototype.valueOf);
  function y(e3, t3) {
    if ("object" != typeof e3) return false;
    try {
      return t3(e3), true;
    } catch (e4) {
      return false;
    }
  }
  function g(e3) {
    return "[object Map]" === u(e3);
  }
  function b(e3) {
    return "[object Set]" === u(e3);
  }
  function v(e3) {
    return "[object WeakMap]" === u(e3);
  }
  function E(e3) {
    return "[object WeakSet]" === u(e3);
  }
  function S(e3) {
    return "[object ArrayBuffer]" === u(e3);
  }
  function x(e3) {
    return "undefined" != typeof ArrayBuffer && (S.working ? S(e3) : e3 instanceof ArrayBuffer);
  }
  function T(e3) {
    return "[object DataView]" === u(e3);
  }
  function w(e3) {
    return "undefined" != typeof DataView && (T.working ? T(e3) : e3 instanceof DataView);
  }
  t2.isArgumentsObject = n2, t2.isGeneratorFunction = s2, t2.isTypedArray = o2, t2.isPromise = function(e3) {
    return "undefined" != typeof Promise && e3 instanceof Promise || null !== e3 && "object" == typeof e3 && "function" == typeof e3.then && "function" == typeof e3.catch;
  }, t2.isArrayBufferView = function(e3) {
    return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e3) : o2(e3) || w(e3);
  }, t2.isUint8Array = function(e3) {
    return "Uint8Array" === i2(e3);
  }, t2.isUint8ClampedArray = function(e3) {
    return "Uint8ClampedArray" === i2(e3);
  }, t2.isUint16Array = function(e3) {
    return "Uint16Array" === i2(e3);
  }, t2.isUint32Array = function(e3) {
    return "Uint32Array" === i2(e3);
  }, t2.isInt8Array = function(e3) {
    return "Int8Array" === i2(e3);
  }, t2.isInt16Array = function(e3) {
    return "Int16Array" === i2(e3);
  }, t2.isInt32Array = function(e3) {
    return "Int32Array" === i2(e3);
  }, t2.isFloat32Array = function(e3) {
    return "Float32Array" === i2(e3);
  }, t2.isFloat64Array = function(e3) {
    return "Float64Array" === i2(e3);
  }, t2.isBigInt64Array = function(e3) {
    return "BigInt64Array" === i2(e3);
  }, t2.isBigUint64Array = function(e3) {
    return "BigUint64Array" === i2(e3);
  }, g.working = "undefined" != typeof Map && g(/* @__PURE__ */ new Map()), t2.isMap = function(e3) {
    return "undefined" != typeof Map && (g.working ? g(e3) : e3 instanceof Map);
  }, b.working = "undefined" != typeof Set && b(/* @__PURE__ */ new Set()), t2.isSet = function(e3) {
    return "undefined" != typeof Set && (b.working ? b(e3) : e3 instanceof Set);
  }, v.working = "undefined" != typeof WeakMap && v(/* @__PURE__ */ new WeakMap()), t2.isWeakMap = function(e3) {
    return "undefined" != typeof WeakMap && (v.working ? v(e3) : e3 instanceof WeakMap);
  }, E.working = "undefined" != typeof WeakSet && E(/* @__PURE__ */ new WeakSet()), t2.isWeakSet = function(e3) {
    return E(e3);
  }, S.working = "undefined" != typeof ArrayBuffer && S(new ArrayBuffer()), t2.isArrayBuffer = x, T.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && T(new DataView(new ArrayBuffer(1), 0, 1)), t2.isDataView = w;
  var P = "undefined" != typeof SharedArrayBuffer ? SharedArrayBuffer : void 0;
  function A(e3) {
    return "[object SharedArrayBuffer]" === u(e3);
  }
  function C(e3) {
    return void 0 !== P && (void 0 === A.working && (A.working = A(new P())), A.working ? A(e3) : e3 instanceof P);
  }
  function O(e3) {
    return y(e3, p);
  }
  function I(e3) {
    return y(e3, d);
  }
  function _(e3) {
    return y(e3, f);
  }
  function k(e3) {
    return l && y(e3, h);
  }
  function N(e3) {
    return c && y(e3, m);
  }
  t2.isSharedArrayBuffer = C, t2.isAsyncFunction = function(e3) {
    return "[object AsyncFunction]" === u(e3);
  }, t2.isMapIterator = function(e3) {
    return "[object Map Iterator]" === u(e3);
  }, t2.isSetIterator = function(e3) {
    return "[object Set Iterator]" === u(e3);
  }, t2.isGeneratorObject = function(e3) {
    return "[object Generator]" === u(e3);
  }, t2.isWebAssemblyCompiledModule = function(e3) {
    return "[object WebAssembly.Module]" === u(e3);
  }, t2.isNumberObject = O, t2.isStringObject = I, t2.isBooleanObject = _, t2.isBigIntObject = k, t2.isSymbolObject = N, t2.isBoxedPrimitive = function(e3) {
    return O(e3) || I(e3) || _(e3) || k(e3) || N(e3);
  }, t2.isAnyArrayBuffer = function(e3) {
    return "undefined" != typeof Uint8Array && (x(e3) || C(e3));
  }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e3) {
    Object.defineProperty(t2, e3, { enumerable: false, value: function() {
      throw new Error(e3 + " is not supported in userland");
    } });
  });
}, (e2, t2, r2) => {
  var n2 = r2(69)(), s2 = r2(38)("Object.prototype.toString"), i2 = function(e3) {
    return !(n2 && e3 && "object" == typeof e3 && Symbol.toStringTag in e3) && "[object Arguments]" === s2(e3);
  }, o2 = function(e3) {
    return !!i2(e3) || null !== e3 && "object" == typeof e3 && "number" == typeof e3.length && e3.length >= 0 && "[object Array]" !== s2(e3) && "[object Function]" === s2(e3.callee);
  }, a2 = function() {
    return i2(arguments);
  }();
  i2.isLegacyArguments = o2, e2.exports = a2 ? i2 : o2;
}, (e2, t2, r2) => {
  var n2 = "undefined" != typeof Symbol && Symbol, s2 = r2(70);
  e2.exports = function() {
    return "function" == typeof n2 && "function" == typeof Symbol && "symbol" == typeof n2("foo") && "symbol" == typeof Symbol("bar") && s2();
  };
}, (e2) => {
  var t2 = { foo: {} }, r2 = Object;
  e2.exports = function() {
    return { __proto__: t2 }.foo === t2.foo && !({ __proto__: null } instanceof r2);
  };
}, (e2) => {
  var t2 = Object.prototype.toString, r2 = Math.max, n2 = function(e3, t3) {
    for (var r3 = [], n3 = 0; n3 < e3.length; n3 += 1) r3[n3] = e3[n3];
    for (var s2 = 0; s2 < t3.length; s2 += 1) r3[s2 + e3.length] = t3[s2];
    return r3;
  };
  e2.exports = function(e3) {
    var s2 = this;
    if ("function" != typeof s2 || "[object Function]" !== t2.apply(s2)) throw new TypeError("Function.prototype.bind called on incompatible " + s2);
    for (var i2, o2 = function(e4, t3) {
      for (var r3 = [], n3 = 1, s3 = 0; n3 < e4.length; n3 += 1, s3 += 1) r3[s3] = e4[n3];
      return r3;
    }(arguments), a2 = r2(0, s2.length - o2.length), l = [], c = 0; c < a2; c++) l[c] = "$" + c;
    if (i2 = Function("binder", "return function (" + function(e4, t3) {
      for (var r3 = "", n3 = 0; n3 < e4.length; n3 += 1) r3 += e4[n3], n3 + 1 < e4.length && (r3 += ",");
      return r3;
    }(l) + "){ return binder.apply(this,arguments); }")(function() {
      if (this instanceof i2) {
        var t3 = s2.apply(this, n2(o2, arguments));
        return Object(t3) === t3 ? t3 : this;
      }
      return s2.apply(e3, n2(o2, arguments));
    }), s2.prototype) {
      var u = function() {
      };
      u.prototype = s2.prototype, i2.prototype = new u(), u.prototype = null;
    }
    return i2;
  };
}, (e2, t2, r2) => {
  var n2 = Function.prototype.call, s2 = Object.prototype.hasOwnProperty, i2 = r2(71);
  e2.exports = i2.call(n2, s2);
}, (e2, t2, r2) => {
  var n2 = r2(22), s2 = r2(121), i2 = r2(72)(), o2 = r2(73), a2 = n2("%TypeError%"), l = n2("%Math.floor%");
  e2.exports = function(e3, t3) {
    if ("function" != typeof e3) throw new a2("`fn` is not a function");
    if ("number" != typeof t3 || t3 < 0 || t3 > 4294967295 || l(t3) !== t3) throw new a2("`length` must be a positive 32-bit integer");
    var r3 = arguments.length > 2 && !!arguments[2], n3 = true, c = true;
    if ("length" in e3 && o2) {
      var u = o2(e3, "length");
      u && !u.configurable && (n3 = false), u && !u.writable && (c = false);
    }
    return (n3 || c || !r3) && (i2 ? s2(e3, "length", t3, true, true) : s2(e3, "length", t3)), e3;
  };
}, (e2, t2, r2) => {
  var n2, s2 = Object.prototype.toString, i2 = Function.prototype.toString, o2 = /^\s*(?:function)?\*/, a2 = r2(69)(), l = Object.getPrototypeOf;
  e2.exports = function(e3) {
    if ("function" != typeof e3) return false;
    if (o2.test(i2.call(e3))) return true;
    if (!a2) return "[object GeneratorFunction]" === s2.call(e3);
    if (!l) return false;
    if (void 0 === n2) {
      var t3 = function() {
        if (!a2) return false;
        try {
          return Function("return function*() {}")();
        } catch (e4) {
        }
      }();
      n2 = !!t3 && l(t3);
    }
    return l(e3) === n2;
  };
}, (e2, t2, r2) => {
  var n2 = r2(237), s2 = Object.prototype.toString, i2 = Object.prototype.hasOwnProperty;
  e2.exports = function(e3, t3, r3) {
    if (!n2(t3)) throw new TypeError("iterator must be a function");
    var o2;
    arguments.length >= 3 && (o2 = r3), "[object Array]" === s2.call(e3) ? function(e4, t4, r4) {
      for (var n3 = 0, s3 = e4.length; n3 < s3; n3++) i2.call(e4, n3) && (null == r4 ? t4(e4[n3], n3, e4) : t4.call(r4, e4[n3], n3, e4));
    }(e3, t3, o2) : "string" == typeof e3 ? function(e4, t4, r4) {
      for (var n3 = 0, s3 = e4.length; n3 < s3; n3++) null == r4 ? t4(e4.charAt(n3), n3, e4) : t4.call(r4, e4.charAt(n3), n3, e4);
    }(e3, t3, o2) : function(e4, t4, r4) {
      for (var n3 in e4) i2.call(e4, n3) && (null == r4 ? t4(e4[n3], n3, e4) : t4.call(r4, e4[n3], n3, e4));
    }(e3, t3, o2);
  };
}, (e2) => {
  var t2, r2, n2 = Function.prototype.toString, s2 = "object" == typeof Reflect && null !== Reflect && Reflect.apply;
  if ("function" == typeof s2 && "function" == typeof Object.defineProperty) try {
    t2 = Object.defineProperty({}, "length", { get: function() {
      throw r2;
    } }), r2 = {}, s2(function() {
      throw 42;
    }, null, t2);
  } catch (e3) {
    e3 !== r2 && (s2 = null);
  }
  else s2 = null;
  var i2 = /^\s*class\b/, o2 = function(e3) {
    try {
      var t3 = n2.call(e3);
      return i2.test(t3);
    } catch (e4) {
      return false;
    }
  }, a2 = function(e3) {
    try {
      return !o2(e3) && (n2.call(e3), true);
    } catch (e4) {
      return false;
    }
  }, l = Object.prototype.toString, c = "function" == typeof Symbol && !!Symbol.toStringTag, u = !(0 in [,]), p = function() {
    return false;
  };
  if ("object" == typeof document) {
    var d = document.all;
    l.call(d) === l.call(document.all) && (p = function(e3) {
      if ((u || !e3) && (void 0 === e3 || "object" == typeof e3)) try {
        var t3 = l.call(e3);
        return ("[object HTMLAllCollection]" === t3 || "[object HTML document.all class]" === t3 || "[object HTMLCollection]" === t3 || "[object Object]" === t3) && null == e3("");
      } catch (e4) {
      }
      return false;
    });
  }
  e2.exports = s2 ? function(e3) {
    if (p(e3)) return true;
    if (!e3) return false;
    if ("function" != typeof e3 && "object" != typeof e3) return false;
    try {
      s2(e3, null, t2);
    } catch (e4) {
      if (e4 !== r2) return false;
    }
    return !o2(e3) && a2(e3);
  } : function(e3) {
    if (p(e3)) return true;
    if (!e3) return false;
    if ("function" != typeof e3 && "object" != typeof e3) return false;
    if (c) return a2(e3);
    if (o2(e3)) return false;
    var t3 = l.call(e3);
    return !("[object Function]" !== t3 && "[object GeneratorFunction]" !== t3 && !/^\[object HTML/.test(t3)) && a2(e3);
  };
}, (e2, t2, r2) => {
  var n2 = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], s2 = "undefined" == typeof globalThis ? r2.g : globalThis;
  e2.exports = function() {
    for (var e3 = [], t3 = 0; t3 < n2.length; t3++) "function" == typeof s2[n2[t3]] && (e3[e3.length] = n2[t3]);
    return e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(122);
  e2.exports = function(e3) {
    return !!n2(e3);
  };
}, (e2) => {
  e2.exports = function(e3) {
    return e3 && "object" == typeof e3 && "function" == typeof e3.copy && "function" == typeof e3.fill && "function" == typeof e3.readUInt8;
  };
}, (e2, t2, r2) => {
  function n2(e3, t3) {
    var r3 = Object.keys(e3);
    if (Object.getOwnPropertySymbols) {
      var n3 = Object.getOwnPropertySymbols(e3);
      t3 && (n3 = n3.filter(function(t4) {
        return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
      })), r3.push.apply(r3, n3);
    }
    return r3;
  }
  function s2(e3) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var r3 = null != arguments[t3] ? arguments[t3] : {};
      t3 % 2 ? n2(Object(r3), true).forEach(function(t4) {
        var n3, s3, i3;
        n3 = e3, s3 = t4, i3 = r3[t4], (s3 = o2(s3)) in n3 ? Object.defineProperty(n3, s3, { value: i3, enumerable: true, configurable: true, writable: true }) : n3[s3] = i3;
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : n2(Object(r3)).forEach(function(t4) {
        Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
      });
    }
    return e3;
  }
  function i2(e3, t3) {
    for (var r3 = 0; r3 < t3.length; r3++) {
      var n3 = t3[r3];
      n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, o2(n3.key), n3);
    }
  }
  function o2(e3) {
    var t3 = function(e4, t4) {
      if ("object" !== h(e4) || null === e4) return e4;
      var r3 = e4[Symbol.toPrimitive];
      if (void 0 !== r3) {
        var n3 = r3.call(e4, "string");
        if ("object" !== h(n3)) return n3;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(e4);
    }(e3);
    return "symbol" === h(t3) ? t3 : String(t3);
  }
  function a2(e3, t3) {
    if (t3 && ("object" === h(t3) || "function" == typeof t3)) return t3;
    if (void 0 !== t3) throw new TypeError("Derived constructors may only return object or undefined");
    return l(e3);
  }
  function l(e3) {
    if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e3;
  }
  function c(e3) {
    var t3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
    return c = function(e4) {
      if (null === e4 || (r3 = e4, -1 === Function.toString.call(r3).indexOf("[native code]"))) return e4;
      var r3;
      if ("function" != typeof e4) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== t3) {
        if (t3.has(e4)) return t3.get(e4);
        t3.set(e4, n3);
      }
      function n3() {
        return u(e4, arguments, f(this).constructor);
      }
      return n3.prototype = Object.create(e4.prototype, { constructor: { value: n3, enumerable: false, writable: true, configurable: true } }), d(n3, e4);
    }, c(e3);
  }
  function u(e3, t3, r3) {
    return u = p() ? Reflect.construct.bind() : function(e4, t4, r4) {
      var n3 = [null];
      n3.push.apply(n3, t4);
      var s3 = new (Function.bind.apply(e4, n3))();
      return r4 && d(s3, r4.prototype), s3;
    }, u.apply(null, arguments);
  }
  function p() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if ("function" == typeof Proxy) return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch (e3) {
      return false;
    }
  }
  function d(e3, t3) {
    return d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
      return e4.__proto__ = t4, e4;
    }, d(e3, t3);
  }
  function f(e3) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
      return e4.__proto__ || Object.getPrototypeOf(e4);
    }, f(e3);
  }
  function h(e3) {
    return h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
      return typeof e4;
    } : function(e4) {
      return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
    }, h(e3);
  }
  var m = r2(32).inspect, y = r2(227).codes.ERR_INVALID_ARG_TYPE;
  function g(e3, t3, r3) {
    return (void 0 === r3 || r3 > e3.length) && (r3 = e3.length), e3.substring(r3 - t3.length, r3) === t3;
  }
  var b = "", v = "", E = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
  function S(e3) {
    var t3 = Object.keys(e3), r3 = Object.create(Object.getPrototypeOf(e3));
    return t3.forEach(function(t4) {
      r3[t4] = e3[t4];
    }), Object.defineProperty(r3, "message", { value: e3.message }), r3;
  }
  function x(e3) {
    return m(e3, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
  }
  var T = function(e3, t3) {
    !function(e4, t4) {
      if ("function" != typeof t4 && null !== t4) throw new TypeError("Super expression must either be null or a function");
      e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && d(e4, t4);
    }(T2, e3);
    var r3, n3, o3, c2, u2 = (r3 = T2, n3 = p(), function() {
      var e4, t4 = f(r3);
      if (n3) {
        var s3 = f(this).constructor;
        e4 = Reflect.construct(t4, arguments, s3);
      } else e4 = t4.apply(this, arguments);
      return a2(this, e4);
    });
    function T2(e4) {
      var t4;
      if (function(e5, t5) {
        if (!(e5 instanceof t5)) throw new TypeError("Cannot call a class as a function");
      }(this, T2), "object" !== h(e4) || null === e4) throw new y("options", "Object", e4);
      var r4 = e4.message, n4 = e4.operator, s3 = e4.stackStartFn, i3 = e4.actual, o4 = e4.expected, c3 = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, null != r4) t4 = u2.call(this, String(r4));
      else if ("object" === h(i3) && null !== i3 && "object" === h(o4) && null !== o4 && "stack" in i3 && i3 instanceof Error && "stack" in o4 && o4 instanceof Error && (i3 = S(i3), o4 = S(o4)), "deepStrictEqual" === n4 || "strictEqual" === n4) t4 = u2.call(this, function(e5, t5, r5) {
        var n5 = "", s4 = "", i4 = 0, o5 = "", a3 = false, l2 = x(e5), c4 = l2.split("\n"), u3 = x(t5).split("\n"), p3 = 0, d3 = "";
        if ("strictEqual" === r5 && "object" === h(e5) && "object" === h(t5) && null !== e5 && null !== t5 && (r5 = "strictEqualObject"), 1 === c4.length && 1 === u3.length && c4[0] !== u3[0]) {
          var f3 = c4[0].length + u3[0].length;
          if (f3 <= 10) {
            if (!("object" === h(e5) && null !== e5 || "object" === h(t5) && null !== t5 || 0 === e5 && 0 === t5)) return "".concat(E[r5], "\n\n") + "".concat(c4[0], " !== ").concat(u3[0], "\n");
          } else if ("strictEqualObject" !== r5 && f3 < 80) {
            for (; c4[0][p3] === u3[0][p3]; ) p3++;
            p3 > 2 && (d3 = "\n  ".concat(function(e6, t6) {
              if (t6 = Math.floor(t6), 0 == e6.length || 0 == t6) return "";
              var r6 = e6.length * t6;
              for (t6 = Math.floor(Math.log(t6) / Math.log(2)); t6; ) e6 += e6, t6--;
              return e6 + e6.substring(0, r6 - e6.length);
            }(" ", p3), "^"), p3 = 0);
          }
        }
        for (var m3 = c4[c4.length - 1], y2 = u3[u3.length - 1]; m3 === y2 && (p3++ < 2 ? o5 = "\n  ".concat(m3).concat(o5) : n5 = m3, c4.pop(), u3.pop(), 0 !== c4.length && 0 !== u3.length); ) m3 = c4[c4.length - 1], y2 = u3[u3.length - 1];
        var S2 = Math.max(c4.length, u3.length);
        if (0 === S2) {
          var T3 = l2.split("\n");
          if (T3.length > 30) for (T3[26] = "".concat(b, "...").concat(v); T3.length > 27; ) T3.pop();
          return "".concat(E.notIdentical, "\n\n").concat(T3.join("\n"), "\n");
        }
        p3 > 3 && (o5 = "\n".concat(b, "...").concat(v).concat(o5), a3 = true), "" !== n5 && (o5 = "\n  ".concat(n5).concat(o5), n5 = "");
        var w2 = 0, P = E[r5] + "\n".concat("", "+ actual").concat(v, " ").concat("", "- expected").concat(v), A = " ".concat(b, "...").concat(v, " Lines skipped");
        for (p3 = 0; p3 < S2; p3++) {
          var C = p3 - i4;
          if (c4.length < p3 + 1) C > 1 && p3 > 2 && (C > 4 ? (s4 += "\n".concat(b, "...").concat(v), a3 = true) : C > 3 && (s4 += "\n  ".concat(u3[p3 - 2]), w2++), s4 += "\n  ".concat(u3[p3 - 1]), w2++), i4 = p3, n5 += "\n".concat("", "-").concat(v, " ").concat(u3[p3]), w2++;
          else if (u3.length < p3 + 1) C > 1 && p3 > 2 && (C > 4 ? (s4 += "\n".concat(b, "...").concat(v), a3 = true) : C > 3 && (s4 += "\n  ".concat(c4[p3 - 2]), w2++), s4 += "\n  ".concat(c4[p3 - 1]), w2++), i4 = p3, s4 += "\n".concat("", "+").concat(v, " ").concat(c4[p3]), w2++;
          else {
            var O = u3[p3], I = c4[p3], _ = I !== O && (!g(I, ",") || I.slice(0, -1) !== O);
            _ && g(O, ",") && O.slice(0, -1) === I && (_ = false, I += ","), _ ? (C > 1 && p3 > 2 && (C > 4 ? (s4 += "\n".concat(b, "...").concat(v), a3 = true) : C > 3 && (s4 += "\n  ".concat(c4[p3 - 2]), w2++), s4 += "\n  ".concat(c4[p3 - 1]), w2++), i4 = p3, s4 += "\n".concat("", "+").concat(v, " ").concat(I), n5 += "\n".concat("", "-").concat(v, " ").concat(O), w2 += 2) : (s4 += n5, n5 = "", 1 !== C && 0 !== p3 || (s4 += "\n  ".concat(I), w2++));
          }
          if (w2 > 20 && p3 < S2 - 2) return "".concat(P).concat(A, "\n").concat(s4, "\n").concat(b, "...").concat(v).concat(n5, "\n") + "".concat(b, "...").concat(v);
        }
        return "".concat(P).concat(a3 ? A : "", "\n").concat(s4).concat(n5).concat(o5).concat(d3);
      }(i3, o4, n4));
      else if ("notDeepStrictEqual" === n4 || "notStrictEqual" === n4) {
        var p2 = E[n4], d2 = x(i3).split("\n");
        if ("notStrictEqual" === n4 && "object" === h(i3) && null !== i3 && (p2 = E.notStrictEqualObject), d2.length > 30) for (d2[26] = "".concat(b, "...").concat(v); d2.length > 27; ) d2.pop();
        t4 = 1 === d2.length ? u2.call(this, "".concat(p2, " ").concat(d2[0])) : u2.call(this, "".concat(p2, "\n\n").concat(d2.join("\n"), "\n"));
      } else {
        var f2 = x(i3), m2 = "", w = E[n4];
        "notDeepEqual" === n4 || "notEqual" === n4 ? (f2 = "".concat(E[n4], "\n\n").concat(f2)).length > 1024 && (f2 = "".concat(f2.slice(0, 1021), "...")) : (m2 = "".concat(x(o4)), f2.length > 512 && (f2 = "".concat(f2.slice(0, 509), "...")), m2.length > 512 && (m2 = "".concat(m2.slice(0, 509), "...")), "deepEqual" === n4 || "equal" === n4 ? f2 = "".concat(w, "\n\n").concat(f2, "\n\nshould equal\n\n") : m2 = " ".concat(n4, " ").concat(m2)), t4 = u2.call(this, "".concat(f2).concat(m2));
      }
      return Error.stackTraceLimit = c3, t4.generatedMessage = !r4, Object.defineProperty(l(t4), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), t4.code = "ERR_ASSERTION", t4.actual = i3, t4.expected = o4, t4.operator = n4, Error.captureStackTrace && Error.captureStackTrace(l(t4), s3), t4.stack, t4.name = "AssertionError", a2(t4);
    }
    return o3 = T2, (c2 = [{ key: "toString", value: function() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    } }, { key: t3, value: function(e4, t4) {
      return m(this, s2(s2({}, t4), {}, { customInspect: false, depth: 0 }));
    } }]) && i2(o3.prototype, c2), Object.defineProperty(o3, "prototype", { writable: false }), T2;
  }(c(Error), m.custom);
  e2.exports = T;
}, (e2, t2, r2) => {
  var n2 = r2(243);
  e2.exports = function() {
    return Object.assign ? function() {
      if (!Object.assign) return false;
      for (var e3 = "abcdefghijklmnopqrst", t3 = e3.split(""), r3 = {}, n3 = 0; n3 < t3.length; ++n3) r3[t3[n3]] = t3[n3];
      var s2 = Object.assign({}, r3), i2 = "";
      for (var o2 in s2) i2 += o2;
      return e3 !== i2;
    }() || function() {
      if (!Object.assign || !Object.preventExtensions) return false;
      var e3 = Object.preventExtensions({ 1: 2 });
      try {
        Object.assign(e3, "xy");
      } catch (t3) {
        return "y" === e3[1];
      }
      return false;
    }() ? n2 : Object.assign : n2;
  };
}, (e2, t2, r2) => {
  var n2 = r2(123), s2 = r2(70)(), i2 = r2(38), o2 = Object, a2 = i2("Array.prototype.push"), l = i2("Object.prototype.propertyIsEnumerable"), c = s2 ? Object.getOwnPropertySymbols : null;
  e2.exports = function(e3, t3) {
    if (null == e3) throw new TypeError("target must be an object");
    var r3 = o2(e3);
    if (1 === arguments.length) return r3;
    for (var i3 = 1; i3 < arguments.length; ++i3) {
      var u = o2(arguments[i3]), p = n2(u), d = s2 && (Object.getOwnPropertySymbols || c);
      if (d) for (var f = d(u), h = 0; h < f.length; ++h) {
        var m = f[h];
        l(u, m) && a2(p, m);
      }
      for (var y = 0; y < p.length; ++y) {
        var g = p[y];
        if (l(u, g)) {
          var b = u[g];
          r3[g] = b;
        }
      }
    }
    return r3;
  };
}, (e2, t2, r2) => {
  var n2;
  if (!Object.keys) {
    var s2 = Object.prototype.hasOwnProperty, i2 = Object.prototype.toString, o2 = r2(124), a2 = Object.prototype.propertyIsEnumerable, l = !a2.call({ toString: null }, "toString"), c = a2.call(function() {
    }, "prototype"), u = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], p = function(e3) {
      var t3 = e3.constructor;
      return t3 && t3.prototype === e3;
    }, d = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, f = function() {
      if ("undefined" == typeof window) return false;
      for (var e3 in window) try {
        if (!d["$" + e3] && s2.call(window, e3) && null !== window[e3] && "object" == typeof window[e3]) try {
          p(window[e3]);
        } catch (e4) {
          return true;
        }
      } catch (e4) {
        return true;
      }
      return false;
    }();
    n2 = function(e3) {
      var t3 = null !== e3 && "object" == typeof e3, r3 = "[object Function]" === i2.call(e3), n3 = o2(e3), a3 = t3 && "[object String]" === i2.call(e3), d2 = [];
      if (!t3 && !r3 && !n3) throw new TypeError("Object.keys called on a non-object");
      var h = c && r3;
      if (a3 && e3.length > 0 && !s2.call(e3, 0)) for (var m = 0; m < e3.length; ++m) d2.push(String(m));
      if (n3 && e3.length > 0) for (var y = 0; y < e3.length; ++y) d2.push(String(y));
      else for (var g in e3) h && "prototype" === g || !s2.call(e3, g) || d2.push(String(g));
      if (l) for (var b = function(e4) {
        if ("undefined" == typeof window || !f) return p(e4);
        try {
          return p(e4);
        } catch (e5) {
          return false;
        }
      }(e3), v = 0; v < u.length; ++v) b && "constructor" === u[v] || !s2.call(e3, u[v]) || d2.push(u[v]);
      return d2;
    };
  }
  e2.exports = n2;
}, (e2, t2, r2) => {
  function n2(e3, t3) {
    return function(e4) {
      if (Array.isArray(e4)) return e4;
    }(e3) || function(e4, t4) {
      var r3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
      if (null != r3) {
        var n3, s3, i3, o3, a3 = [], l2 = true, c2 = false;
        try {
          if (i3 = (r3 = r3.call(e4)).next, 0 === t4) {
            if (Object(r3) !== r3) return;
            l2 = false;
          } else for (; !(l2 = (n3 = i3.call(r3)).done) && (a3.push(n3.value), a3.length !== t4); l2 = true) ;
        } catch (e5) {
          c2 = true, s3 = e5;
        } finally {
          try {
            if (!l2 && null != r3.return && (o3 = r3.return(), Object(o3) !== o3)) return;
          } finally {
            if (c2) throw s3;
          }
        }
        return a3;
      }
    }(e3, t3) || function(e4, t4) {
      if (e4) {
        if ("string" == typeof e4) return s2(e4, t4);
        var r3 = Object.prototype.toString.call(e4).slice(8, -1);
        return "Object" === r3 && e4.constructor && (r3 = e4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? s2(e4, t4) : void 0;
      }
    }(e3, t3) || function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function s2(e3, t3) {
    (null == t3 || t3 > e3.length) && (t3 = e3.length);
    for (var r3 = 0, n3 = new Array(t3); r3 < t3; r3++) n3[r3] = e3[r3];
    return n3;
  }
  function i2(e3) {
    return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
      return typeof e4;
    } : function(e4) {
      return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
    }, i2(e3);
  }
  r2(44), r2(12);
  var o2 = void 0 !== /a/g.flags, a2 = function(e3) {
    var t3 = [];
    return e3.forEach(function(e4) {
      return t3.push(e4);
    }), t3;
  }, l = function(e3) {
    var t3 = [];
    return e3.forEach(function(e4, r3) {
      return t3.push([r3, e4]);
    }), t3;
  }, c = Object.is ? Object.is : r2(246), u = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, p = Number.isNaN ? Number.isNaN : r2(248);
  function d(e3) {
    return e3.call.bind(e3);
  }
  var f = d(Object.prototype.hasOwnProperty), h = d(Object.prototype.propertyIsEnumerable), m = d(Object.prototype.toString), y = r2(32).types, g = y.isAnyArrayBuffer, b = y.isArrayBufferView, v = y.isDate, E = y.isMap, S = y.isRegExp, x = y.isSet, T = y.isNativeError, w = y.isBoxedPrimitive, P = y.isNumberObject, A = y.isStringObject, C = y.isBooleanObject, O = y.isBigIntObject, I = y.isSymbolObject, _ = y.isFloat32Array, k = y.isFloat64Array;
  function N(e3) {
    if (0 === e3.length || e3.length > 10) return true;
    for (var t3 = 0; t3 < e3.length; t3++) {
      var r3 = e3.charCodeAt(t3);
      if (r3 < 48 || r3 > 57) return true;
    }
    return 10 === e3.length && e3 >= Math.pow(2, 32);
  }
  function D(e3) {
    return Object.keys(e3).filter(N).concat(u(e3).filter(Object.prototype.propertyIsEnumerable.bind(e3)));
  }
  function j(e3, t3) {
    if (e3 === t3) return 0;
    for (var r3 = e3.length, n3 = t3.length, s3 = 0, i3 = Math.min(r3, n3); s3 < i3; ++s3) if (e3[s3] !== t3[s3]) {
      r3 = e3[s3], n3 = t3[s3];
      break;
    }
    return r3 < n3 ? -1 : n3 < r3 ? 1 : 0;
  }
  var L = 0, M = 1, B = 2, R = 3;
  function F(e3, t3, r3, n3) {
    if (e3 === t3) return 0 !== e3 || !r3 || c(e3, t3);
    if (r3) {
      if ("object" !== i2(e3)) return "number" == typeof e3 && p(e3) && p(t3);
      if ("object" !== i2(t3) || null === e3 || null === t3) return false;
      if (Object.getPrototypeOf(e3) !== Object.getPrototypeOf(t3)) return false;
    } else {
      if (null === e3 || "object" !== i2(e3)) return (null === t3 || "object" !== i2(t3)) && e3 == t3;
      if (null === t3 || "object" !== i2(t3)) return false;
    }
    var s3, a3, l2, u2, d2 = m(e3);
    if (d2 !== m(t3)) return false;
    if (Array.isArray(e3)) {
      if (e3.length !== t3.length) return false;
      var f2 = D(e3), h2 = D(t3);
      return f2.length === h2.length && $(e3, t3, r3, n3, M, f2);
    }
    if ("[object Object]" === d2 && (!E(e3) && E(t3) || !x(e3) && x(t3))) return false;
    if (v(e3)) {
      if (!v(t3) || Date.prototype.getTime.call(e3) !== Date.prototype.getTime.call(t3)) return false;
    } else if (S(e3)) {
      if (!S(t3) || (l2 = e3, u2 = t3, !(o2 ? l2.source === u2.source && l2.flags === u2.flags : RegExp.prototype.toString.call(l2) === RegExp.prototype.toString.call(u2)))) return false;
    } else if (T(e3) || e3 instanceof Error) {
      if (e3.message !== t3.message || e3.name !== t3.name) return false;
    } else {
      if (b(e3)) {
        if (r3 || !_(e3) && !k(e3)) {
          if (!function(e4, t4) {
            return e4.byteLength === t4.byteLength && 0 === j(new Uint8Array(e4.buffer, e4.byteOffset, e4.byteLength), new Uint8Array(t4.buffer, t4.byteOffset, t4.byteLength));
          }(e3, t3)) return false;
        } else if (!function(e4, t4) {
          if (e4.byteLength !== t4.byteLength) return false;
          for (var r4 = 0; r4 < e4.byteLength; r4++) if (e4[r4] !== t4[r4]) return false;
          return true;
        }(e3, t3)) return false;
        var y2 = D(e3), N2 = D(t3);
        return y2.length === N2.length && $(e3, t3, r3, n3, L, y2);
      }
      if (x(e3)) return !(!x(t3) || e3.size !== t3.size) && $(e3, t3, r3, n3, B);
      if (E(e3)) return !(!E(t3) || e3.size !== t3.size) && $(e3, t3, r3, n3, R);
      if (g(e3)) {
        if (a3 = t3, (s3 = e3).byteLength !== a3.byteLength || 0 !== j(new Uint8Array(s3), new Uint8Array(a3))) return false;
      } else if (w(e3) && !function(e4, t4) {
        return P(e4) ? P(t4) && c(Number.prototype.valueOf.call(e4), Number.prototype.valueOf.call(t4)) : A(e4) ? A(t4) && String.prototype.valueOf.call(e4) === String.prototype.valueOf.call(t4) : C(e4) ? C(t4) && Boolean.prototype.valueOf.call(e4) === Boolean.prototype.valueOf.call(t4) : O(e4) ? O(t4) && BigInt.prototype.valueOf.call(e4) === BigInt.prototype.valueOf.call(t4) : I(t4) && Symbol.prototype.valueOf.call(e4) === Symbol.prototype.valueOf.call(t4);
      }(e3, t3)) return false;
    }
    return $(e3, t3, r3, n3, L);
  }
  function U(e3, t3) {
    return t3.filter(function(t4) {
      return h(e3, t4);
    });
  }
  function $(e3, t3, r3, s3, o3, c2) {
    if (5 === arguments.length) {
      c2 = Object.keys(e3);
      var p2 = Object.keys(t3);
      if (c2.length !== p2.length) return false;
    }
    for (var d2 = 0; d2 < c2.length; d2++) if (!f(t3, c2[d2])) return false;
    if (r3 && 5 === arguments.length) {
      var m2 = u(e3);
      if (0 !== m2.length) {
        var y2 = 0;
        for (d2 = 0; d2 < m2.length; d2++) {
          var g2 = m2[d2];
          if (h(e3, g2)) {
            if (!h(t3, g2)) return false;
            c2.push(g2), y2++;
          } else if (h(t3, g2)) return false;
        }
        var b2 = u(t3);
        if (m2.length !== b2.length && U(t3, b2).length !== y2) return false;
      } else {
        var v2 = u(t3);
        if (0 !== v2.length && 0 !== U(t3, v2).length) return false;
      }
    }
    if (0 === c2.length && (o3 === L || o3 === M && 0 === e3.length || 0 === e3.size)) return true;
    if (void 0 === s3) s3 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
    else {
      var E2 = s3.val1.get(e3);
      if (void 0 !== E2) {
        var S2 = s3.val2.get(t3);
        if (void 0 !== S2) return E2 === S2;
      }
      s3.position++;
    }
    s3.val1.set(e3, s3.position), s3.val2.set(t3, s3.position);
    var x2 = function(e4, t4, r4, s4, o4, c3) {
      var u2 = 0;
      if (c3 === B) {
        if (!function(e5, t5, r5, n3) {
          for (var s5 = null, o5 = a2(e5), l2 = 0; l2 < o5.length; l2++) {
            var c4 = o5[l2];
            if ("object" === i2(c4) && null !== c4) null === s5 && (s5 = /* @__PURE__ */ new Set()), s5.add(c4);
            else if (!t5.has(c4)) {
              if (r5) return false;
              if (!W(e5, t5, c4)) return false;
              null === s5 && (s5 = /* @__PURE__ */ new Set()), s5.add(c4);
            }
          }
          if (null !== s5) {
            for (var u3 = a2(t5), p4 = 0; p4 < u3.length; p4++) {
              var d4 = u3[p4];
              if ("object" === i2(d4) && null !== d4) {
                if (!V(s5, d4, r5, n3)) return false;
              } else if (!r5 && !e5.has(d4) && !V(s5, d4, r5, n3)) return false;
            }
            return 0 === s5.size;
          }
          return true;
        }(e4, t4, r4, o4)) return false;
      } else if (c3 === R) {
        if (!function(e5, t5, r5, s5) {
          for (var o5 = null, a3 = l(e5), c4 = 0; c4 < a3.length; c4++) {
            var u3 = n2(a3[c4], 2), p4 = u3[0], d4 = u3[1];
            if ("object" === i2(p4) && null !== p4) null === o5 && (o5 = /* @__PURE__ */ new Set()), o5.add(p4);
            else {
              var f2 = t5.get(p4);
              if (void 0 === f2 && !t5.has(p4) || !F(d4, f2, r5, s5)) {
                if (r5) return false;
                if (!G(e5, t5, p4, d4, s5)) return false;
                null === o5 && (o5 = /* @__PURE__ */ new Set()), o5.add(p4);
              }
            }
          }
          if (null !== o5) {
            for (var h3 = l(t5), m3 = 0; m3 < h3.length; m3++) {
              var y3 = n2(h3[m3], 2), g3 = y3[0], b3 = y3[1];
              if ("object" === i2(g3) && null !== g3) {
                if (!H(o5, e5, g3, b3, r5, s5)) return false;
              } else if (!(r5 || e5.has(g3) && F(e5.get(g3), b3, false, s5) || H(o5, e5, g3, b3, false, s5))) return false;
            }
            return 0 === o5.size;
          }
          return true;
        }(e4, t4, r4, o4)) return false;
      } else if (c3 === M) for (; u2 < e4.length; u2++) {
        if (!f(e4, u2)) {
          if (f(t4, u2)) return false;
          for (var p3 = Object.keys(e4); u2 < p3.length; u2++) {
            var d3 = p3[u2];
            if (!f(t4, d3) || !F(e4[d3], t4[d3], r4, o4)) return false;
          }
          return p3.length === Object.keys(t4).length;
        }
        if (!f(t4, u2) || !F(e4[u2], t4[u2], r4, o4)) return false;
      }
      for (u2 = 0; u2 < s4.length; u2++) {
        var h2 = s4[u2];
        if (!F(e4[h2], t4[h2], r4, o4)) return false;
      }
      return true;
    }(e3, t3, r3, c2, s3, o3);
    return s3.val1.delete(e3), s3.val2.delete(t3), x2;
  }
  function V(e3, t3, r3, n3) {
    for (var s3 = a2(e3), i3 = 0; i3 < s3.length; i3++) {
      var o3 = s3[i3];
      if (F(t3, o3, r3, n3)) return e3.delete(o3), true;
    }
    return false;
  }
  function q(e3) {
    switch (i2(e3)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return false;
      case "string":
        e3 = +e3;
      case "number":
        if (p(e3)) return false;
    }
    return true;
  }
  function W(e3, t3, r3) {
    var n3 = q(r3);
    return null != n3 ? n3 : t3.has(n3) && !e3.has(n3);
  }
  function G(e3, t3, r3, n3, s3) {
    var i3 = q(r3);
    if (null != i3) return i3;
    var o3 = t3.get(i3);
    return !(void 0 === o3 && !t3.has(i3) || !F(n3, o3, false, s3)) && !e3.has(i3) && F(n3, o3, false, s3);
  }
  function H(e3, t3, r3, n3, s3, i3) {
    for (var o3 = a2(e3), l2 = 0; l2 < o3.length; l2++) {
      var c2 = o3[l2];
      if (F(r3, c2, s3, i3) && F(n3, t3.get(c2), s3, i3)) return e3.delete(c2), true;
    }
    return false;
  }
  e2.exports = { isDeepEqual: function(e3, t3) {
    return F(e3, t3, false);
  }, isDeepStrictEqual: function(e3, t3) {
    return F(e3, t3, true);
  } };
}, (e2, t2, r2) => {
  var n2 = r2(46), s2 = r2(41), i2 = r2(125), o2 = r2(74), a2 = r2(247), l = s2(o2(), Object);
  n2(l, { getPolyfill: o2, implementation: i2, shim: a2 }), e2.exports = l;
}, (e2, t2, r2) => {
  var n2 = r2(74), s2 = r2(46);
  e2.exports = function() {
    var e3 = n2();
    return s2(Object, { is: e3 }, { is: function() {
      return Object.is !== e3;
    } }), e3;
  };
}, (e2, t2, r2) => {
  var n2 = r2(41), s2 = r2(46), i2 = r2(126), o2 = r2(127), a2 = r2(249), l = n2(o2(), Number);
  s2(l, { getPolyfill: o2, implementation: i2, shim: a2 }), e2.exports = l;
}, (e2, t2, r2) => {
  var n2 = r2(46), s2 = r2(127);
  e2.exports = function() {
    var e3 = s2();
    return n2(Number, { isNaN: e3 }, { isNaN: function() {
      return Number.isNaN !== e3;
    } }), e3;
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return "module" === e3.node.sourceType;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    var r3;
    e3.traverse(f, { scope: e3.scope, bindingNames: t3, seen: /* @__PURE__ */ new WeakSet(), includeUpdateExpression: null == (r3 = arguments[2]) || r3 });
  };
  var n2 = r2(0);
  const { LOGICAL_OPERATORS: s2, assignmentExpression: i2, binaryExpression: o2, cloneNode: a2, identifier: l, logicalExpression: c, numericLiteral: u, sequenceExpression: p, unaryExpression: d } = n2, f = { AssignmentExpression: { exit(e3) {
    const { scope: t3, seen: r3, bindingNames: n3 } = this;
    if ("=" === e3.node.operator) return;
    if (r3.has(e3.node)) return;
    r3.add(e3.node);
    const l2 = e3.get("left");
    if (!l2.isIdentifier()) return;
    const u2 = l2.node.name;
    if (!n3.has(u2)) return;
    if (t3.getBinding(u2) !== e3.scope.getBinding(u2)) return;
    const p2 = e3.node.operator.slice(0, -1);
    s2.includes(p2) ? e3.replaceWith(c(p2, e3.node.left, i2("=", a2(e3.node.left), e3.node.right))) : (e3.node.right = o2(p2, a2(e3.node.left), e3.node.right), e3.node.operator = "=");
  } } };
  f.UpdateExpression = { exit(e3) {
    if (!this.includeUpdateExpression) return;
    const { scope: t3, bindingNames: r3 } = this, n3 = e3.get("argument");
    if (!n3.isIdentifier()) return;
    const s3 = n3.node.name;
    if (r3.has(s3) && t3.getBinding(s3) === e3.scope.getBinding(s3)) if (e3.parentPath.isExpressionStatement() && !e3.isCompletionRecord()) {
      const t4 = "++" == e3.node.operator ? "+=" : "-=";
      e3.replaceWith(i2(t4, n3.node, u(1)));
    } else if (e3.node.prefix) e3.replaceWith(i2("=", l(s3), o2(e3.node.operator[0], d("+", n3.node), u(1))));
    else {
      const t4 = e3.scope.generateUidIdentifierBasedOnNode(n3.node, "old"), r4 = t4.name;
      e3.scope.push({ id: t4 });
      const s4 = o2(e3.node.operator[0], l(r4), u(1));
      e3.replaceWith(p([i2("=", l(r4), d("+", n3.node)), i2("=", a2(n3.node), s4), l(r4)]));
    }
  } };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    let { importInterop: s3, initializeReexports: o3 = false, getWrapperPayload: u, esNamespaceOnly: p = false, filename: d } = r3;
    t3 || (t3 = e3.scope.generateUidIdentifier("exports").name);
    const f = /* @__PURE__ */ new Set();
    !function(e4) {
      e4.get("body").forEach((e5) => {
        e5.isExportDefaultDeclaration() && (0, i2.default)(e5);
      });
    }(e3);
    const { local: h, sources: m, hasExports: y } = function(e4, t4, r4) {
      let { getWrapperPayload: s4, initializeReexports: i3 } = t4;
      const o4 = function(e5, t5, r5) {
        const n3 = /* @__PURE__ */ new Map();
        e5.get("body").forEach((e6) => {
          let r6;
          if (e6.isImportDeclaration()) r6 = "import";
          else {
            if (e6.isExportDefaultDeclaration() && (e6 = e6.get("declaration")), e6.isExportNamedDeclaration()) {
              if (e6.node.declaration) e6 = e6.get("declaration");
              else if (t5 && e6.node.source && e6.get("source").isStringLiteral()) return void e6.get("specifiers").forEach((e7) => {
                c(e7), n3.set(e7.get("local").node.name, "block");
              });
            }
            if (e6.isFunctionDeclaration()) r6 = "hoisted";
            else if (e6.isClassDeclaration()) r6 = "block";
            else if (e6.isVariableDeclaration({ kind: "var" })) r6 = "var";
            else {
              if (!e6.isVariableDeclaration()) return;
              r6 = "block";
            }
          }
          Object.keys(e6.getOuterBindingIdentifiers()).forEach((e7) => {
            n3.set(e7, r6);
          });
        });
        const s5 = /* @__PURE__ */ new Map(), i4 = (e6) => {
          const t6 = e6.node.name;
          let r6 = s5.get(t6);
          if (!r6) {
            const i5 = n3.get(t6);
            if (void 0 === i5) throw e6.buildCodeFrameError(`Exporting local "${t6}", which is not declared.`);
            r6 = { names: [], kind: i5 }, s5.set(t6, r6);
          }
          return r6;
        };
        return e5.get("body").forEach((e6) => {
          if (!e6.isExportNamedDeclaration() || !t5 && e6.node.source) {
            if (e6.isExportDefaultDeclaration()) {
              const t6 = e6.get("declaration");
              if (!t6.isFunctionDeclaration() && !t6.isClassDeclaration()) throw t6.buildCodeFrameError("Unexpected default expression export.");
              i4(t6.get("id")).names.push("default");
            }
          } else if (e6.node.declaration) {
            const t6 = e6.get("declaration"), r6 = t6.getOuterBindingIdentifierPaths();
            Object.keys(r6).forEach((e7) => {
              if ("__esModule" === e7) throw t6.buildCodeFrameError('Illegal export "__esModule".');
              i4(r6[e7]).names.push(e7);
            });
          } else e6.get("specifiers").forEach((e7) => {
            const t6 = e7.get("local"), n4 = e7.get("exported"), s6 = i4(t6), o5 = l(n4, r5);
            if ("__esModule" === o5) throw n4.buildCodeFrameError('Illegal export "__esModule".');
            s6.names.push(o5);
          });
        }), s5;
      }(e4, i3, r4), a3 = /* @__PURE__ */ new Map(), u2 = /* @__PURE__ */ new Map(), p2 = (t5, r5) => {
        const s5 = t5.value;
        let i4 = u2.get(s5);
        return i4 ? a3.get(s5).push(r5) : (i4 = { name: e4.scope.generateUidIdentifier((0, n2.basename)(s5, (0, n2.extname)(s5))).name, interop: "none", loc: null, imports: /* @__PURE__ */ new Map(), importsNamespace: /* @__PURE__ */ new Set(), reexports: /* @__PURE__ */ new Map(), reexportNamespace: /* @__PURE__ */ new Set(), reexportAll: null, wrap: null, get lazy() {
          return "lazy" === this.wrap;
        }, referenced: false }, u2.set(s5, i4), a3.set(s5, [r5])), i4;
      };
      let d2 = false;
      e4.get("body").forEach((e5) => {
        if (e5.isImportDeclaration()) {
          const t5 = p2(e5.node.source, e5.node);
          t5.loc || (t5.loc = e5.node.loc), e5.get("specifiers").forEach((e6) => {
            if (e6.isImportDefaultSpecifier()) {
              const r5 = e6.get("local").node.name;
              t5.imports.set(r5, "default");
              const n3 = o4.get(r5);
              n3 && (o4.delete(r5), n3.names.forEach((e7) => {
                t5.reexports.set(e7, "default");
              }), t5.referenced = true);
            } else if (e6.isImportNamespaceSpecifier()) {
              const r5 = e6.get("local").node.name;
              t5.importsNamespace.add(r5);
              const n3 = o4.get(r5);
              n3 && (o4.delete(r5), n3.names.forEach((e7) => {
                t5.reexportNamespace.add(e7);
              }), t5.referenced = true);
            } else if (e6.isImportSpecifier()) {
              const n3 = l(e6.get("imported"), r4), s5 = e6.get("local").node.name;
              t5.imports.set(s5, n3);
              const i4 = o4.get(s5);
              i4 && (o4.delete(s5), i4.names.forEach((e7) => {
                t5.reexports.set(e7, n3);
              }), t5.referenced = true);
            }
          });
        } else if (e5.isExportAllDeclaration()) {
          d2 = true;
          const t5 = p2(e5.node.source, e5.node);
          t5.loc || (t5.loc = e5.node.loc), t5.reexportAll = { loc: e5.node.loc }, t5.referenced = true;
        } else if (e5.isExportNamedDeclaration() && e5.node.source) {
          d2 = true;
          const t5 = p2(e5.node.source, e5.node);
          t5.loc || (t5.loc = e5.node.loc), e5.get("specifiers").forEach((e6) => {
            c(e6);
            const n3 = l(e6.get("local"), r4), s5 = l(e6.get("exported"), r4);
            if (t5.reexports.set(s5, n3), t5.referenced = true, "__esModule" === s5) throw e6.get("exported").buildCodeFrameError('Illegal export "__esModule".');
          });
        } else (e5.isExportNamedDeclaration() || e5.isExportDefaultDeclaration()) && (d2 = true);
      });
      for (const e5 of u2.values()) {
        let t5 = false, r5 = false;
        e5.importsNamespace.size > 0 && (t5 = true, r5 = true), e5.reexportAll && (r5 = true);
        for (const n3 of e5.imports.values()) "default" === n3 ? t5 = true : r5 = true;
        for (const n3 of e5.reexports.values()) "default" === n3 ? t5 = true : r5 = true;
        t5 && r5 ? e5.interop = "namespace" : t5 && (e5.interop = "default");
      }
      if (s4) for (const [e5, t5] of u2) t5.wrap = s4(e5, t5, a3.get(e5));
      return { hasExports: d2, local: o4, sources: u2 };
    }(e3, { initializeReexports: o3, getWrapperPayload: u }, f);
    !function(e4) {
      e4.get("body").forEach((e5) => {
        if (e5.isImportDeclaration()) e5.remove();
        else if (e5.isExportNamedDeclaration()) e5.node.declaration ? (e5.node.declaration._blockHoist = e5.node._blockHoist, e5.replaceWith(e5.node.declaration)) : e5.remove();
        else if (e5.isExportDefaultDeclaration()) {
          const t4 = e5.get("declaration");
          if (!t4.isFunctionDeclaration() && !t4.isClassDeclaration()) throw t4.buildCodeFrameError("Unexpected default expression export.");
          t4._blockHoist = e5.node._blockHoist, e5.replaceWith(t4);
        } else e5.isExportAllDeclaration() && e5.remove();
      });
    }(e3);
    for (const [e4, t4] of m) {
      const { importsNamespace: r4, imports: n3 } = t4;
      if (r4.size > 0 && 0 === n3.size) {
        const [e5] = r4;
        t4.name = e5;
      }
      const i3 = a2(s3, e4, d);
      "none" === i3 ? t4.interop = "none" : "node" === i3 && "namespace" === t4.interop ? t4.interop = "node-namespace" : "node" === i3 && "default" === t4.interop ? t4.interop = "node-default" : p && "namespace" === t4.interop && (t4.interop = "default");
    }
    return { exportName: t3, exportNameListName: null, hasExports: y, local: h, source: m, stringSpecifiers: f };
  }, t2.hasExports = function(e3) {
    return e3.hasExports;
  }, t2.isSideEffectImport = function(e3) {
    return 0 === e3.imports.size && 0 === e3.importsNamespace.size && 0 === e3.reexports.size && 0 === e3.reexportNamespace.size && !e3.reexportAll;
  }, t2.validateImportInteropOption = o2;
  var n2 = r2(10), s2 = r2(59), i2 = r2(62);
  function o2(e3) {
    if ("function" != typeof e3 && "none" !== e3 && "babel" !== e3 && "node" !== e3) throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${e3}).`);
    return e3;
  }
  function a2(e3, t3, r3) {
    return "function" == typeof e3 ? o2(e3(t3, r3)) : e3;
  }
  function l(e3, t3) {
    if (e3.isIdentifier()) return e3.node.name;
    if (e3.isStringLiteral()) {
      const r3 = e3.node.value;
      return (0, s2.isIdentifierName)(r3) || t3.add(r3), r3;
    }
    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${e3.node.type}`);
  }
  function c(e3) {
    if (!e3.isExportSpecifier()) throw e3.isExportNamespaceSpecifier() ? e3.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.") : e3.buildCodeFrameError("Unexpected export specifier type");
  }
}, (e2, t2, r2) => {
  const n2 = r2(30);
  e2.exports = (e3, t3) => {
    const r3 = n2(e3, t3);
    return r3 ? r3.version : null;
  };
}, (e2, t2, r2) => {
  const n2 = r2(30);
  e2.exports = (e3, t3) => {
    const r3 = n2(e3.trim().replace(/^[=v]+/, ""), t3);
    return r3 ? r3.version : null;
  };
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = (e3, t3, r3, s2, i2) => {
    "string" == typeof r3 && (i2 = s2, s2 = r3, r3 = void 0);
    try {
      return new n2(e3 instanceof n2 ? e3.version : e3, r3).inc(t3, s2, i2).version;
    } catch (e4) {
      return null;
    }
  };
}, (e2, t2, r2) => {
  const n2 = r2(30);
  e2.exports = (e3, t3) => {
    const r3 = n2(e3, null, true), s2 = n2(t3, null, true), i2 = r3.compare(s2);
    if (0 === i2) return null;
    const o2 = i2 > 0, a2 = o2 ? r3 : s2, l = o2 ? s2 : r3, c = !!a2.prerelease.length;
    if (l.prerelease.length && !c) return l.patch || l.minor ? a2.patch ? "patch" : a2.minor ? "minor" : "major" : "major";
    const u = c ? "pre" : "";
    return r3.major !== s2.major ? u + "major" : r3.minor !== s2.minor ? u + "minor" : r3.patch !== s2.patch ? u + "patch" : "prerelease";
  };
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = (e3, t3) => new n2(e3, t3).major;
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = (e3, t3) => new n2(e3, t3).minor;
}, (e2, t2, r2) => {
  const n2 = r2(3);
  e2.exports = (e3, t3) => new n2(e3, t3).patch;
}, (e2, t2, r2) => {
  const n2 = r2(30);
  e2.exports = (e3, t3) => {
    const r3 = n2(e3, t3);
    return r3 && r3.prerelease.length ? r3.prerelease : null;
  };
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3, r3) => n2(t3, e3, r3);
}, (e2, t2, r2) => {
  const n2 = r2(7);
  e2.exports = (e3, t3) => n2(e3, t3, true);
}, (e2, t2, r2) => {
  const n2 = r2(76);
  e2.exports = (e3, t3) => e3.sort((e4, r3) => n2(e4, r3, t3));
}, (e2, t2, r2) => {
  const n2 = r2(76);
  e2.exports = (e3, t3) => e3.sort((e4, r3) => n2(r3, e4, t3));
}, (e2, t2, r2) => {
  const n2 = r2(3), s2 = r2(30), { safeRe: i2, t: o2 } = r2(34);
  e2.exports = (e3, t3) => {
    if (e3 instanceof n2) return e3;
    if ("number" == typeof e3 && (e3 = String(e3)), "string" != typeof e3) return null;
    let r3 = null;
    if ((t3 = t3 || {}).rtl) {
      let t4;
      for (; (t4 = i2[o2.COERCERTL].exec(e3)) && (!r3 || r3.index + r3[0].length !== e3.length); ) r3 && t4.index + t4[0].length === r3.index + r3[0].length || (r3 = t4), i2[o2.COERCERTL].lastIndex = t4.index + t4[1].length + t4[2].length;
      i2[o2.COERCERTL].lastIndex = -1;
    } else r3 = e3.match(i2[o2.COERCE]);
    return null === r3 ? null : s2(`${r3[2]}.${r3[3] || "0"}.${r3[4] || "0"}`, t3);
  };
}, (e2, t2, r2) => {
  function n2(e3) {
    var t3 = this;
    if (t3 instanceof n2 || (t3 = new n2()), t3.tail = null, t3.head = null, t3.length = 0, e3 && "function" == typeof e3.forEach) e3.forEach(function(e4) {
      t3.push(e4);
    });
    else if (arguments.length > 0) for (var r3 = 0, s3 = arguments.length; r3 < s3; r3++) t3.push(arguments[r3]);
    return t3;
  }
  function s2(e3, t3, r3) {
    var n3 = t3 === e3.head ? new a2(r3, null, t3, e3) : new a2(r3, t3, t3.next, e3);
    return null === n3.next && (e3.tail = n3), null === n3.prev && (e3.head = n3), e3.length++, n3;
  }
  function i2(e3, t3) {
    e3.tail = new a2(t3, e3.tail, null, e3), e3.head || (e3.head = e3.tail), e3.length++;
  }
  function o2(e3, t3) {
    e3.head = new a2(t3, null, e3.head, e3), e3.tail || (e3.tail = e3.head), e3.length++;
  }
  function a2(e3, t3, r3, n3) {
    if (!(this instanceof a2)) return new a2(e3, t3, r3, n3);
    this.list = n3, this.value = e3, t3 ? (t3.next = this, this.prev = t3) : this.prev = null, r3 ? (r3.prev = this, this.next = r3) : this.next = null;
  }
  e2.exports = n2, n2.Node = a2, n2.create = n2, n2.prototype.removeNode = function(e3) {
    if (e3.list !== this) throw new Error("removing node which does not belong to this list");
    var t3 = e3.next, r3 = e3.prev;
    return t3 && (t3.prev = r3), r3 && (r3.next = t3), e3 === this.head && (this.head = t3), e3 === this.tail && (this.tail = r3), e3.list.length--, e3.next = null, e3.prev = null, e3.list = null, t3;
  }, n2.prototype.unshiftNode = function(e3) {
    if (e3 !== this.head) {
      e3.list && e3.list.removeNode(e3);
      var t3 = this.head;
      e3.list = this, e3.next = t3, t3 && (t3.prev = e3), this.head = e3, this.tail || (this.tail = e3), this.length++;
    }
  }, n2.prototype.pushNode = function(e3) {
    if (e3 !== this.tail) {
      e3.list && e3.list.removeNode(e3);
      var t3 = this.tail;
      e3.list = this, e3.prev = t3, t3 && (t3.next = e3), this.tail = e3, this.head || (this.head = e3), this.length++;
    }
  }, n2.prototype.push = function() {
    for (var e3 = 0, t3 = arguments.length; e3 < t3; e3++) i2(this, arguments[e3]);
    return this.length;
  }, n2.prototype.unshift = function() {
    for (var e3 = 0, t3 = arguments.length; e3 < t3; e3++) o2(this, arguments[e3]);
    return this.length;
  }, n2.prototype.pop = function() {
    if (this.tail) {
      var e3 = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e3;
    }
  }, n2.prototype.shift = function() {
    if (this.head) {
      var e3 = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e3;
    }
  }, n2.prototype.forEach = function(e3, t3) {
    t3 = t3 || this;
    for (var r3 = this.head, n3 = 0; null !== r3; n3++) e3.call(t3, r3.value, n3, this), r3 = r3.next;
  }, n2.prototype.forEachReverse = function(e3, t3) {
    t3 = t3 || this;
    for (var r3 = this.tail, n3 = this.length - 1; null !== r3; n3--) e3.call(t3, r3.value, n3, this), r3 = r3.prev;
  }, n2.prototype.get = function(e3) {
    for (var t3 = 0, r3 = this.head; null !== r3 && t3 < e3; t3++) r3 = r3.next;
    if (t3 === e3 && null !== r3) return r3.value;
  }, n2.prototype.getReverse = function(e3) {
    for (var t3 = 0, r3 = this.tail; null !== r3 && t3 < e3; t3++) r3 = r3.prev;
    if (t3 === e3 && null !== r3) return r3.value;
  }, n2.prototype.map = function(e3, t3) {
    t3 = t3 || this;
    for (var r3 = new n2(), s3 = this.head; null !== s3; ) r3.push(e3.call(t3, s3.value, this)), s3 = s3.next;
    return r3;
  }, n2.prototype.mapReverse = function(e3, t3) {
    t3 = t3 || this;
    for (var r3 = new n2(), s3 = this.tail; null !== s3; ) r3.push(e3.call(t3, s3.value, this)), s3 = s3.prev;
    return r3;
  }, n2.prototype.reduce = function(e3, t3) {
    var r3, n3 = this.head;
    if (arguments.length > 1) r3 = t3;
    else {
      if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
      n3 = this.head.next, r3 = this.head.value;
    }
    for (var s3 = 0; null !== n3; s3++) r3 = e3(r3, n3.value, s3), n3 = n3.next;
    return r3;
  }, n2.prototype.reduceReverse = function(e3, t3) {
    var r3, n3 = this.tail;
    if (arguments.length > 1) r3 = t3;
    else {
      if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
      n3 = this.tail.prev, r3 = this.tail.value;
    }
    for (var s3 = this.length - 1; null !== n3; s3--) r3 = e3(r3, n3.value, s3), n3 = n3.prev;
    return r3;
  }, n2.prototype.toArray = function() {
    for (var e3 = new Array(this.length), t3 = 0, r3 = this.head; null !== r3; t3++) e3[t3] = r3.value, r3 = r3.next;
    return e3;
  }, n2.prototype.toArrayReverse = function() {
    for (var e3 = new Array(this.length), t3 = 0, r3 = this.tail; null !== r3; t3++) e3[t3] = r3.value, r3 = r3.prev;
    return e3;
  }, n2.prototype.slice = function(e3, t3) {
    (t3 = t3 || this.length) < 0 && (t3 += this.length), (e3 = e3 || 0) < 0 && (e3 += this.length);
    var r3 = new n2();
    if (t3 < e3 || t3 < 0) return r3;
    e3 < 0 && (e3 = 0), t3 > this.length && (t3 = this.length);
    for (var s3 = 0, i3 = this.head; null !== i3 && s3 < e3; s3++) i3 = i3.next;
    for (; null !== i3 && s3 < t3; s3++, i3 = i3.next) r3.push(i3.value);
    return r3;
  }, n2.prototype.sliceReverse = function(e3, t3) {
    (t3 = t3 || this.length) < 0 && (t3 += this.length), (e3 = e3 || 0) < 0 && (e3 += this.length);
    var r3 = new n2();
    if (t3 < e3 || t3 < 0) return r3;
    e3 < 0 && (e3 = 0), t3 > this.length && (t3 = this.length);
    for (var s3 = this.length, i3 = this.tail; null !== i3 && s3 > t3; s3--) i3 = i3.prev;
    for (; null !== i3 && s3 > e3; s3--, i3 = i3.prev) r3.push(i3.value);
    return r3;
  }, n2.prototype.splice = function(e3, t3) {
    e3 > this.length && (e3 = this.length - 1), e3 < 0 && (e3 = this.length + e3);
    for (var r3 = 0, n3 = this.head; null !== n3 && r3 < e3; r3++) n3 = n3.next;
    var i3 = [];
    for (r3 = 0; n3 && r3 < t3; r3++) i3.push(n3.value), n3 = this.removeNode(n3);
    for (null === n3 && (n3 = this.tail), n3 !== this.head && n3 !== this.tail && (n3 = n3.prev), r3 = 0; r3 < (arguments.length <= 2 ? 0 : arguments.length - 2); r3++) n3 = s2(this, n3, r3 + 2 < 2 || arguments.length <= r3 + 2 ? void 0 : arguments[r3 + 2]);
    return i3;
  }, n2.prototype.reverse = function() {
    for (var e3 = this.head, t3 = this.tail, r3 = e3; null !== r3; r3 = r3.prev) {
      var n3 = r3.prev;
      r3.prev = r3.next, r3.next = n3;
    }
    return this.head = t3, this.tail = e3, this;
  };
  try {
    r2(267)(n2);
  } catch (e3) {
  }
}, (e2) => {
  e2.exports = function(e3) {
    e3.prototype[Symbol.iterator] = function* () {
      for (let e4 = this.head; e4; e4 = e4.next) yield e4.value;
    };
  };
}, (e2, t2, r2) => {
  const n2 = r2(8);
  e2.exports = (e3, t3) => new n2(e3, t3).set.map((e4) => e4.map((e5) => e5.value).join(" ").trim().split(" "));
}, (e2, t2, r2) => {
  const n2 = r2(3), s2 = r2(8);
  e2.exports = (e3, t3, r3) => {
    let i2 = null, o2 = null, a2 = null;
    try {
      a2 = new s2(t3, r3);
    } catch (e4) {
      return null;
    }
    return e3.forEach((e4) => {
      a2.test(e4) && (i2 && -1 !== o2.compare(e4) || (i2 = e4, o2 = new n2(i2, r3)));
    }), i2;
  };
}, (e2, t2, r2) => {
  const n2 = r2(3), s2 = r2(8);
  e2.exports = (e3, t3, r3) => {
    let i2 = null, o2 = null, a2 = null;
    try {
      a2 = new s2(t3, r3);
    } catch (e4) {
      return null;
    }
    return e3.forEach((e4) => {
      a2.test(e4) && (i2 && 1 !== o2.compare(e4) || (i2 = e4, o2 = new n2(i2, r3)));
    }), i2;
  };
}, (e2, t2, r2) => {
  const n2 = r2(3), s2 = r2(8), i2 = r2(49);
  e2.exports = (e3, t3) => {
    e3 = new s2(e3, t3);
    let r3 = new n2("0.0.0");
    if (e3.test(r3)) return r3;
    if (r3 = new n2("0.0.0-0"), e3.test(r3)) return r3;
    r3 = null;
    for (let t4 = 0; t4 < e3.set.length; ++t4) {
      const s3 = e3.set[t4];
      let o2 = null;
      s3.forEach((e4) => {
        const t5 = new n2(e4.semver.version);
        switch (e4.operator) {
          case ">":
            0 === t5.prerelease.length ? t5.patch++ : t5.prerelease.push(0), t5.raw = t5.format();
          case "":
          case ">=":
            o2 && !i2(t5, o2) || (o2 = t5);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${e4.operator}`);
        }
      }), !o2 || r3 && !i2(r3, o2) || (r3 = o2);
    }
    return r3 && e3.test(r3) ? r3 : null;
  };
}, (e2, t2, r2) => {
  const n2 = r2(8);
  e2.exports = (e3, t3) => {
    try {
      return new n2(e3, t3).range || "*";
    } catch (e4) {
      return null;
    }
  };
}, (e2, t2, r2) => {
  const n2 = r2(80);
  e2.exports = (e3, t3, r3) => n2(e3, t3, ">", r3);
}, (e2, t2, r2) => {
  const n2 = r2(80);
  e2.exports = (e3, t3, r3) => n2(e3, t3, "<", r3);
}, (e2, t2, r2) => {
  const n2 = r2(8);
  e2.exports = (e3, t3, r3) => (e3 = new n2(e3, r3), t3 = new n2(t3, r3), e3.intersects(t3, r3));
}, (e2, t2, r2) => {
  const n2 = r2(51), s2 = r2(7);
  e2.exports = (e3, t3, r3) => {
    const i2 = [];
    let o2 = null, a2 = null;
    const l = e3.sort((e4, t4) => s2(e4, t4, r3));
    for (const e4 of l) n2(e4, t3, r3) ? (a2 = e4, o2 || (o2 = e4)) : (a2 && i2.push([o2, a2]), a2 = null, o2 = null);
    o2 && i2.push([o2, null]);
    const c = [];
    for (const [e4, t4] of i2) e4 === t4 ? c.push(e4) : t4 || e4 !== l[0] ? t4 ? e4 === l[0] ? c.push(`<=${t4}`) : c.push(`${e4} - ${t4}`) : c.push(`>=${e4}`) : c.push("*");
    const u = c.join(" || "), p = "string" == typeof t3.raw ? t3.raw : String(t3);
    return u.length < p.length ? u : t3;
  };
}, (e2, t2, r2) => {
  const n2 = r2(8), s2 = r2(50), { ANY: i2 } = s2, o2 = r2(51), a2 = r2(7), l = [new s2(">=0.0.0-0")], c = [new s2(">=0.0.0")], u = (e3, t3, r3) => {
    if (e3 === t3) return true;
    if (1 === e3.length && e3[0].semver === i2) {
      if (1 === t3.length && t3[0].semver === i2) return true;
      e3 = r3.includePrerelease ? l : c;
    }
    if (1 === t3.length && t3[0].semver === i2) {
      if (r3.includePrerelease) return true;
      t3 = c;
    }
    const n3 = /* @__PURE__ */ new Set();
    let s3, u2, f, h, m, y, g;
    for (const t4 of e3) ">" === t4.operator || ">=" === t4.operator ? s3 = p(s3, t4, r3) : "<" === t4.operator || "<=" === t4.operator ? u2 = d(u2, t4, r3) : n3.add(t4.semver);
    if (n3.size > 1) return null;
    if (s3 && u2) {
      if (f = a2(s3.semver, u2.semver, r3), f > 0) return null;
      if (0 === f && (">=" !== s3.operator || "<=" !== u2.operator)) return null;
    }
    for (const e4 of n3) {
      if (s3 && !o2(e4, String(s3), r3)) return null;
      if (u2 && !o2(e4, String(u2), r3)) return null;
      for (const n4 of t3) if (!o2(e4, String(n4), r3)) return false;
      return true;
    }
    let b = !(!u2 || r3.includePrerelease || !u2.semver.prerelease.length) && u2.semver, v = !(!s3 || r3.includePrerelease || !s3.semver.prerelease.length) && s3.semver;
    b && 1 === b.prerelease.length && "<" === u2.operator && 0 === b.prerelease[0] && (b = false);
    for (const e4 of t3) {
      if (g = g || ">" === e4.operator || ">=" === e4.operator, y = y || "<" === e4.operator || "<=" === e4.operator, s3) {
        if (v && e4.semver.prerelease && e4.semver.prerelease.length && e4.semver.major === v.major && e4.semver.minor === v.minor && e4.semver.patch === v.patch && (v = false), ">" === e4.operator || ">=" === e4.operator) {
          if (h = p(s3, e4, r3), h === e4 && h !== s3) return false;
        } else if (">=" === s3.operator && !o2(s3.semver, String(e4), r3)) return false;
      }
      if (u2) {
        if (b && e4.semver.prerelease && e4.semver.prerelease.length && e4.semver.major === b.major && e4.semver.minor === b.minor && e4.semver.patch === b.patch && (b = false), "<" === e4.operator || "<=" === e4.operator) {
          if (m = d(u2, e4, r3), m === e4 && m !== u2) return false;
        } else if ("<=" === u2.operator && !o2(u2.semver, String(e4), r3)) return false;
      }
      if (!e4.operator && (u2 || s3) && 0 !== f) return false;
    }
    return !(s3 && y && !u2 && 0 !== f || u2 && g && !s3 && 0 !== f || v || b);
  }, p = (e3, t3, r3) => {
    if (!e3) return t3;
    const n3 = a2(e3.semver, t3.semver, r3);
    return n3 > 0 ? e3 : n3 < 0 || ">" === t3.operator && ">=" === e3.operator ? t3 : e3;
  }, d = (e3, t3, r3) => {
    if (!e3) return t3;
    const n3 = a2(e3.semver, t3.semver, r3);
    return n3 < 0 ? e3 : n3 > 0 || "<" === t3.operator && "<=" === e3.operator ? t3 : e3;
  };
  e2.exports = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if (e3 === t3) return true;
    e3 = new n2(e3, r3), t3 = new n2(t3, r3);
    let s3 = false;
    e: for (const n3 of e3.set) {
      for (const e4 of t3.set) {
        const t4 = u(n3, e4, r3);
        if (s3 = s3 || null !== t4, t4) continue e;
      }
      if (s3) return false;
    }
    return true;
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.getEnv = function() {
    return "production";
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.createCachedDescriptors = function(e3, t3, r3) {
    const { plugins: n3, presets: s3, passPerPreset: i3 } = t3;
    return { options: u(t3, e3), plugins: n3 ? () => h(n3, e3)(r3) : () => c([]), presets: s3 ? () => d(s3, e3)(r3)(!!i3) : () => c([]) };
  }, t2.createDescriptor = E, t2.createUncachedDescriptors = function(e3, t3, r3) {
    return { options: u(t3, e3), plugins: (0, s2.once)(() => b(t3.plugins || [], e3, r3)), presets: (0, s2.once)(() => g(t3.presets || [], e3, r3, !!t3.passPerPreset)) };
  };
  var s2 = r2(455), i2 = r2(81), o2 = r2(83), a2 = r2(84), l = r2(280);
  function* c(e3) {
    return e3;
  }
  function u(e3, t3) {
    return "string" == typeof e3.browserslistConfigFile && (e3.browserslistConfigFile = (0, l.resolveBrowserslistConfigFile)(e3.browserslistConfigFile, t3)), e3;
  }
  const p = /* @__PURE__ */ new WeakMap(), d = (0, a2.makeWeakCacheSync)((e3, t3) => {
    const r3 = t3.using((e4) => e4);
    return (0, a2.makeStrongCacheSync)((t4) => (0, a2.makeStrongCache)(function* (n3) {
      return (yield* g(e3, r3, t4, n3)).map((e4) => y(p, e4));
    }));
  }), f = /* @__PURE__ */ new WeakMap(), h = (0, a2.makeWeakCacheSync)((e3, t3) => {
    const r3 = t3.using((e4) => e4);
    return (0, a2.makeStrongCache)(function* (t4) {
      return (yield* b(e3, r3, t4)).map((e4) => y(f, e4));
    });
  }), m = {};
  function y(e3, t3) {
    const { value: r3, options: n3 = m } = t3;
    if (false === n3) return t3;
    let s3 = e3.get(r3);
    s3 || (s3 = /* @__PURE__ */ new WeakMap(), e3.set(r3, s3));
    let i3 = s3.get(n3);
    if (i3 || (i3 = [], s3.set(n3, i3)), -1 === i3.indexOf(t3)) {
      const e4 = i3.filter((e5) => {
        return n4 = t3, (r4 = e5).name === n4.name && r4.value === n4.value && r4.options === n4.options && r4.dirname === n4.dirname && r4.alias === n4.alias && r4.ownPass === n4.ownPass && (null == (s4 = r4.file) ? void 0 : s4.request) === (null == (i4 = n4.file) ? void 0 : i4.request) && (null == (o3 = r4.file) ? void 0 : o3.resolved) === (null == (a3 = n4.file) ? void 0 : a3.resolved);
        var r4, n4, s4, i4, o3, a3;
      });
      if (e4.length > 0) return e4[0];
      i3.push(t3);
    }
    return t3;
  }
  function* g(e3, t3, r3, n3) {
    return yield* v("preset", e3, t3, r3, n3);
  }
  function* b(e3, t3, r3) {
    return yield* v("plugin", e3, t3, r3);
  }
  function* v(e3, t3, r3, s3, i3) {
    const o3 = yield* n2().all(t3.map((t4, n3) => E(t4, r3, { type: e3, alias: `${s3}$${n3}`, ownPass: !!i3 })));
    return function(e4) {
      const t4 = /* @__PURE__ */ new Map();
      for (const r4 of e4) {
        if ("function" != typeof r4.value) continue;
        let n3 = t4.get(r4.value);
        if (n3 || (n3 = /* @__PURE__ */ new Set(), t4.set(r4.value, n3)), n3.has(r4.name)) {
          const t5 = e4.filter((e5) => e5.value === r4.value);
          throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", `${JSON.stringify(t5, null, 2)}`].join("\n"));
        }
        n3.add(r4.name);
      }
    }(o3), o3;
  }
  function E(e3, t3, r3) {
    let { type: n3, alias: s3, ownPass: a3 } = r3;
    return function* () {
      const r4 = (0, o2.getItemDescriptor)(e3);
      if (r4) return r4;
      let l2, c2, u2, p2 = e3;
      Array.isArray(p2) && (3 === p2.length ? [p2, c2, l2] = p2 : [p2, c2] = p2);
      let d2 = null;
      if ("string" == typeof p2) {
        if ("string" != typeof n3) throw new Error("To resolve a string-based item, the type of item must be given");
        const e4 = "plugin" === n3 ? i2.loadPlugin : i2.loadPreset, r5 = p2;
        ({ filepath: d2, value: p2 } = yield* e4(p2, t3)), u2 = { request: r5, resolved: d2 };
      }
      if (!p2) throw new Error(`Unexpected falsy value: ${String(p2)}`);
      if ("object" == typeof p2 && p2.__esModule) {
        if (!p2.default) throw new Error("Must export a default export when using ES6 modules.");
        p2 = p2.default;
      }
      if ("object" != typeof p2 && "function" != typeof p2) throw new Error(`Unsupported format: ${typeof p2}. Expected an object or a function.`);
      if (null !== d2 && "object" == typeof p2 && p2) throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${d2}`);
      return { name: l2, alias: d2 || s3, value: p2, options: c2, dirname: t3, ownPass: a3, file: u2 };
    }();
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(281);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.resolveBrowserslistConfigFile = function(e3, t3) {
  }, t2.resolveTargets = function(e3, t3) {
    const r3 = e3.targets;
    let s2;
    return "string" == typeof r3 || Array.isArray(r3) ? s2 = { browsers: r3 } : r3 && (s2 = "esmodules" in r3 ? Object.assign({}, r3, { esmodules: "intersect" }) : r3), (0, n2().default)(s2, { ignoreBrowserslistConfig: true, browserslistEnv: e3.browserslistEnv });
  };
}, (e2, t2, r2) => {
  var n2 = r2(17);
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "TargetNames", { enumerable: true, get: function() {
    return u.TargetNames;
  } }), t2.default = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var r3, n3;
    let { browsers: o3, esmodules: a3 } = e3;
    const { configPath: p2 = "." } = t3;
    !function(e4) {
      m.invariant(void 0 === e4 || y(e4), `'${String(e4)}' is not a valid browserslist query`);
    }(o3);
    let d2 = function(e4) {
      const t4 = Object.keys(u.TargetNames);
      for (const r4 of Object.keys(e4)) if (!(r4 in u.TargetNames)) throw new Error(m.formatMessage(`'${r4}' is not a valid target
- Did you mean '${(0, i2.findSuggestion)(r4, t4)}'?`));
      return e4;
    }(function(e4) {
      const t4 = Object.assign({}, e4);
      return delete t4.esmodules, delete t4.browsers, t4;
    }(e3));
    const f2 = !!o3 || Object.keys(d2).length > 0, g2 = !t3.ignoreBrowserslistConfig && !f2;
    if (!o3 && g2 && (o3 = s2.loadConfig({ config: t3.configFile, path: p2, env: t3.browserslistEnv }), null == o3 && (o3 = [])), !a3 || "intersect" === a3 && null != (r3 = o3) && r3.length || (o3 = Object.keys(h).map((e4) => `${e4} >= ${h[e4]}`).join(", "), a3 = false), null != (n3 = o3) && n3.length) {
      const e4 = function(e5, t4) {
        const r4 = "string" == typeof e5 ? e5 : e5.join() + t4;
        let n4 = E.get(r4);
        return n4 || (n4 = function(e6, t5) {
          return function(e7) {
            return e7.reduce((e8, t6) => {
              const [r5, n5] = t6.split(" "), s3 = c.browserNameMap[r5];
              if (!s3) return e8;
              try {
                const t7 = n5.split("-")[0].toLowerCase(), r6 = (0, l.isUnreleasedVersion)(t7, s3);
                if (!e8[s3]) return e8[s3] = r6 ? t7 : (0, l.semverify)(t7), e8;
                const i3 = e8[s3], o4 = (0, l.isUnreleasedVersion)(i3, s3);
                if (o4 && r6) e8[s3] = (0, l.getLowestUnreleased)(i3, t7, s3);
                else if (o4) e8[s3] = (0, l.semverify)(t7);
                else if (!o4 && !r6) {
                  const r7 = (0, l.semverify)(t7);
                  e8[s3] = (0, l.semverMin)(i3, r7);
                }
              } catch (e9) {
              }
              return e8;
            }, {});
          }(s2(e6, { mobileToDesktop: true, env: t5 }));
        }(e5, t4), E.set(r4, n4)), Object.assign({}, n4);
      }(o3, t3.browserslistEnv);
      if ("intersect" === a3) for (const t4 of Object.keys(e4)) if ("deno" !== t4 && "ie" !== t4) {
        const r4 = h["opera_mobile" === t4 ? "op_mob" : t4];
        if (r4) {
          const n4 = e4[t4];
          e4[t4] = (0, l.getHighestUnreleased)(n4, (0, l.semverify)(r4), t4);
        } else delete e4[t4];
      } else delete e4[t4];
      d2 = Object.assign(e4, d2);
    }
    const S = {}, x = [];
    for (const e4 of Object.keys(d2).sort()) {
      const t4 = d2[e4];
      "number" == typeof t4 && t4 % 1 != 0 && x.push({ target: e4, value: t4 });
      const [r4, n4] = "node" === e4 ? b(t4) : v(e4, t4);
      n4 && (S[r4] = n4);
    }
    return (T = x).length && T.forEach((e4) => {
      let { target: t4, value: r4 } = e4;
    }), S;
    var T;
  }, Object.defineProperty(t2, "filterItems", { enumerable: true, get: function() {
    return f.default;
  } }), Object.defineProperty(t2, "getInclusionReasons", { enumerable: true, get: function() {
    return d.getInclusionReasons;
  } }), t2.isBrowsersQueryValid = y, Object.defineProperty(t2, "isRequired", { enumerable: true, get: function() {
    return f.isRequired;
  } }), Object.defineProperty(t2, "prettifyTargets", { enumerable: true, get: function() {
    return p.prettifyTargets;
  } }), Object.defineProperty(t2, "unreleasedLabels", { enumerable: true, get: function() {
    return c.unreleasedLabels;
  } });
  var s2 = r2(282), i2 = r2(289), o2 = r2(463), a2 = r2(132), l = r2(138), c = r2(139), u = r2(465), p = r2(291), d = r2(466), f = r2(467);
  const h = o2["es6.module"], m = new i2.OptionValidator("@babel/helper-compilation-targets");
  function y(e3) {
    return "string" == typeof e3 || Array.isArray(e3) && e3.every((e4) => "string" == typeof e4);
  }
  function g(e3, t3) {
    try {
      return (0, l.semverify)(t3);
    } catch (r3) {
      throw new Error(m.formatMessage(`'${t3}' is not a valid value for 'targets.${e3}'.`));
    }
  }
  function b(e3) {
    return ["node", true === e3 || "current" === e3 ? n2.versions.node : g("node", e3)];
  }
  function v(e3, t3) {
    return [e3, (0, l.isUnreleasedVersion)(t3, e3) ? t3.toLowerCase() : g(e3, t3)];
  }
  const E = new a2({ max: 64 });
}, (e2, t2, r2) => {
  var n2 = r2(456), s2 = r2(457).a, i2 = r2(460), o2 = r2(461), a2 = r2(286), l = r2(137), c = r2(287), u = r2(288), p = "37";
  function d(e3, t3) {
    return 0 === (e3 + ".").indexOf(t3 + ".");
  }
  function f(e3) {
    return e3.filter(function(e4) {
      return "string" == typeof e4;
    });
  }
  function h(e3) {
    var t3 = e3;
    return 3 === e3.split(".").length && (t3 = e3.split(".").slice(0, -1).join(".")), t3;
  }
  function m(e3) {
    return function(t3) {
      return e3 + " " + t3;
    };
  }
  function y(e3) {
    return parseInt(e3.split(".")[0]);
  }
  function g(e3, t3) {
    if (0 === e3.length) return [];
    var r3 = b(e3.map(y)), n3 = r3[r3.length - t3];
    if (!n3) return e3;
    for (var s3 = [], i3 = e3.length - 1; i3 >= 0 && !(n3 > y(e3[i3])); i3--) s3.unshift(e3[i3]);
    return s3;
  }
  function b(e3) {
    for (var t3 = [], r3 = 0; r3 < e3.length; r3++) -1 === t3.indexOf(e3[r3]) && t3.push(e3[r3]);
    return t3;
  }
  function v(e3, t3, r3) {
    for (var n3 in r3) e3[t3 + " " + n3] = r3[n3];
  }
  function E(e3, t3) {
    return t3 = parseFloat(t3), ">" === e3 ? function(e4) {
      return parseFloat(e4) > t3;
    } : ">=" === e3 ? function(e4) {
      return parseFloat(e4) >= t3;
    } : "<" === e3 ? function(e4) {
      return parseFloat(e4) < t3;
    } : function(e4) {
      return parseFloat(e4) <= t3;
    };
  }
  function S(e3) {
    return parseInt(e3);
  }
  function x(e3, t3) {
    return e3 < t3 ? -1 : e3 > t3 ? 1 : 0;
  }
  function T(e3, t3) {
    return x(parseInt(e3[0]), parseInt(t3[0])) || x(parseInt(e3[1] || "0"), parseInt(t3[1] || "0")) || x(parseInt(e3[2] || "0"), parseInt(t3[2] || "0"));
  }
  function w(e3, t3) {
    return void 0 === (t3 = t3.split(".").map(S))[1] && (t3[1] = "x"), "<=" === e3 ? function(e4) {
      return P(e4 = e4.split(".").map(S), t3) <= 0;
    } : function(e4) {
      return P(e4 = e4.split(".").map(S), t3) >= 0;
    };
  }
  function P(e3, t3) {
    return e3[0] !== t3[0] ? e3[0] < t3[0] ? -1 : 1 : "x" === t3[1] ? 0 : e3[1] !== t3[1] ? e3[1] < t3[1] ? -1 : 1 : 0;
  }
  function A(e3, t3) {
    var r3 = function(e4, t4) {
      return -1 !== e4.versions.indexOf(t4) ? t4 : !!F.versionAliases[e4.name][t4] && F.versionAliases[e4.name][t4];
    }(e3, t3);
    return r3 || 1 === e3.versions.length && e3.versions[0];
  }
  function C(e3, t3) {
    return e3 /= 1e3, Object.keys(s2).reduce(function(r3, n3) {
      var s3 = I(n3, t3);
      if (!s3) return r3;
      var i3 = Object.keys(s3.releaseDate).filter(function(t4) {
        var r4 = s3.releaseDate[t4];
        return null !== r4 && r4 >= e3;
      });
      return r3.concat(i3.map(m(s3.name)));
    }, []);
  }
  function O(e3) {
    return { name: e3.name, versions: e3.versions, released: e3.released, releaseDate: e3.releaseDate };
  }
  function I(e3, t3) {
    if (e3 = e3.toLowerCase(), e3 = F.aliases[e3] || e3, t3.mobileToDesktop && F.desktopNames[e3]) {
      var r3 = F.data[F.desktopNames[e3]];
      if ("android" === e3) return s3 = O(F.data[e3]), i3 = r3, s3.released = _(s3.released, i3.released), s3.versions = _(s3.versions, i3.versions), s3.releaseDate = function(e4) {
        var t4 = {};
        for (var r4 in e4) t4[r4] = e4[r4];
        return t4;
      }(s3.releaseDate), s3.released.forEach(function(e4) {
        void 0 === s3.releaseDate[e4] && (s3.releaseDate[e4] = i3.releaseDate[e4]);
      }), s3;
      var n3 = O(r3);
      return n3.name = e3, n3;
    }
    var s3, i3;
    return F.data[e3];
  }
  function _(e3, t3) {
    var r3 = t3.indexOf(p);
    return e3.filter(function(e4) {
      return /^(?:[2-4]\.|[34]$)/.test(e4);
    }).concat(t3.slice(r3));
  }
  function k(e3, t3) {
    var r3 = I(e3, t3);
    if (!r3) throw new l("Unknown browser " + e3);
    return r3;
  }
  function N(e3, t3, r3, n3) {
    var s3 = 1;
    switch (t3) {
      case "android":
        if (n3.mobileToDesktop) return e3;
        var i3 = F.data.chrome.released;
        s3 = i3.length - i3.indexOf(p);
        break;
      case "op_mob":
        s3 = y(F.data.op_mob.released.slice(-1)[0]) - 14 + 1;
        break;
      default:
        return e3;
    }
    return r3 <= s3 ? e3.slice(-1) : e3.slice(s3 - 1 - r3);
  }
  function D(e3, t3) {
    return "string" == typeof e3 && (e3.indexOf("y") >= 0 || t3 && e3.indexOf("a") >= 0);
  }
  function j(e3, t3) {
    return c(q, e3).reduce(function(e4, r3, n3) {
      if (r3.not && 0 === n3) throw new l("Write any browsers query (for instance, `defaults`) before `" + r3.query + "`");
      var s3 = q[r3.type].select.call(F, t3, r3).map(function(e5) {
        var r4 = e5.split(" ");
        return "0" === r4[1] ? r4[0] + " " + I(r4[0], t3).versions[0] : e5;
      });
      if ("and" === r3.compose) return r3.not ? e4.filter(function(e5) {
        return -1 === s3.indexOf(e5);
      }) : e4.filter(function(e5) {
        return -1 !== s3.indexOf(e5);
      });
      if (r3.not) {
        var i3 = {};
        return s3.forEach(function(e5) {
          i3[e5] = true;
        }), e4.filter(function(e5) {
          return !i3[e5];
        });
      }
      return e4.concat(s3);
    }, []);
  }
  function L(e3) {
    return void 0 === e3 && (e3 = {}), void 0 === e3.path && (e3.path = o2.resolve ? o2.resolve(".") : "."), e3;
  }
  function M(e3, t3) {
    null == e3 && (e3 = F.loadConfig(t3) || F.defaults);
    return e3;
  }
  function B(e3) {
    if ("string" != typeof e3 && !Array.isArray(e3)) throw new l("Browser queries must be an array or string. Got " + typeof e3 + ".");
  }
  var R = {};
  function F(e3, t3) {
    B(e3 = M(e3, t3 = L(t3)));
    var r3 = { ignoreUnknownVersions: t3.ignoreUnknownVersions, dangerousExtend: t3.dangerousExtend, mobileToDesktop: t3.mobileToDesktop, path: t3.path, env: t3.env };
    u.oldDataWarning(F.data);
    var n3 = u.getStat(t3, F.data);
    if (n3) for (var s3 in r3.customUsage = {}, n3) v(r3.customUsage, s3, n3[s3]);
    var i3 = JSON.stringify([e3, r3]);
    if (R[i3]) return R[i3];
    var o3 = b(j(e3, r3)).sort(function(e4, t4) {
      if (e4 = e4.split(" "), t4 = t4.split(" "), e4[0] === t4[0]) {
        var r4 = e4[1].split("-")[0];
        return T(t4[1].split("-")[0].split("."), r4.split("."));
      }
      return x(e4[0], t4[0]);
    });
    return u.env.BROWSERSLIST_DISABLE_CACHE || (R[i3] = o3), o3;
  }
  function U(e3, t3) {
    var r3 = F.nodeVersions.filter(function(e4) {
      return d(e4, t3.version);
    });
    if (0 === r3.length) {
      if (e3.ignoreUnknownVersions) return [];
      throw new l("Unknown version " + t3.version + " of Node.js");
    }
    return ["node " + r3[r3.length - 1]];
  }
  function $(e3, t3) {
    var r3 = parseInt(t3.year), n3 = parseInt(t3.month || "01") - 1, s3 = parseInt(t3.day || "01");
    return C(Date.UTC(r3, n3, s3, 0, 0, 0), e3);
  }
  function V(e3, t3) {
    var r3 = parseFloat(t3.coverage), n3 = F.usage.global;
    if (t3.place) if (t3.place.match(/^my\s+stats$/i)) {
      if (!e3.customUsage) throw new l("Custom usage statistics was not provided");
      n3 = e3.customUsage;
    } else {
      var s3;
      s3 = 2 === t3.place.length ? t3.place.toUpperCase() : t3.place.toLowerCase(), u.loadCountry(F.usage, s3, F.data), n3 = F.usage[s3];
    }
    for (var i3, o3 = Object.keys(n3).sort(function(e4, t4) {
      return n3[t4] - n3[e4];
    }), a3 = 0, c2 = [], p2 = 0; p2 < o3.length && (i3 = o3[p2], 0 !== n3[i3]) && (a3 += n3[i3], c2.push(i3), !(a3 >= r3)); p2++) ;
    return c2;
  }
  F.parse = function(e3, t3) {
    return B(e3 = M(e3, t3 = L(t3))), c(q, e3);
  }, F.cache = {}, F.data = {}, F.usage = { global: {}, custom: null }, F.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"], F.aliases = { fx: "firefox", ff: "firefox", ios: "ios_saf", explorer: "ie", blackberry: "bb", explorermobile: "ie_mob", operamini: "op_mini", operamobile: "op_mob", chromeandroid: "and_chr", firefoxandroid: "and_ff", ucandroid: "and_uc", qqandroid: "and_qq" }, F.desktopNames = { and_chr: "chrome", and_ff: "firefox", ie_mob: "ie", android: "chrome" }, F.versionAliases = {}, F.clearCaches = u.clearCaches, F.parseConfig = u.parseConfig, F.readConfig = u.readConfig, F.findConfig = u.findConfig, F.loadConfig = u.loadConfig, F.coverage = function(e3, t3) {
    var r3;
    if (void 0 === t3) r3 = F.usage.global;
    else if ("my stats" === t3) {
      var n3 = {};
      n3.path = o2.resolve ? o2.resolve(".") : ".";
      var s3 = u.getStat(n3);
      if (!s3) throw new l("Custom usage statistics was not provided");
      for (var i3 in r3 = {}, s3) v(r3, i3, s3[i3]);
    } else if ("string" == typeof t3) t3 = t3.length > 2 ? t3.toLowerCase() : t3.toUpperCase(), u.loadCountry(F.usage, t3, F.data), r3 = F.usage[t3];
    else for (var a3 in "dataByBrowser" in t3 && (t3 = t3.dataByBrowser), r3 = {}, t3) for (var c2 in t3[a3]) r3[a3 + " " + c2] = t3[a3][c2];
    return e3.reduce(function(e4, t4) {
      var n4 = r3[t4];
      return void 0 === n4 && (n4 = r3[t4.replace(/ \S+$/, " 0")]), e4 + (n4 || 0);
    }, 0);
  };
  var q = { last_major_versions: { matches: ["versions"], regexp: /^last\s+(\d+)\s+major\s+versions?$/i, select: function(e3, t3) {
    return Object.keys(s2).reduce(function(r3, n3) {
      var s3 = I(n3, e3);
      if (!s3) return r3;
      var i3 = g(s3.released, t3.versions);
      return i3 = N(i3 = i3.map(m(s3.name)), s3.name, t3.versions, e3), r3.concat(i3);
    }, []);
  } }, last_versions: { matches: ["versions"], regexp: /^last\s+(\d+)\s+versions?$/i, select: function(e3, t3) {
    return Object.keys(s2).reduce(function(r3, n3) {
      var s3 = I(n3, e3);
      if (!s3) return r3;
      var i3 = s3.released.slice(-t3.versions);
      return i3 = N(i3 = i3.map(m(s3.name)), s3.name, t3.versions, e3), r3.concat(i3);
    }, []);
  } }, last_electron_major_versions: { matches: ["versions"], regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i, select: function(e3, t3) {
    return g(Object.keys(a2), t3.versions).map(function(e4) {
      return "chrome " + a2[e4];
    });
  } }, last_node_major_versions: { matches: ["versions"], regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i, select: function(e3, t3) {
    return g(F.nodeVersions, t3.versions).map(function(e4) {
      return "node " + e4;
    });
  } }, last_browser_major_versions: { matches: ["versions", "browser"], regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i, select: function(e3, t3) {
    var r3 = k(t3.browser, e3), n3 = g(r3.released, t3.versions).map(m(r3.name));
    return N(n3, r3.name, t3.versions, e3);
  } }, last_electron_versions: { matches: ["versions"], regexp: /^last\s+(\d+)\s+electron\s+versions?$/i, select: function(e3, t3) {
    return Object.keys(a2).slice(-t3.versions).map(function(e4) {
      return "chrome " + a2[e4];
    });
  } }, last_node_versions: { matches: ["versions"], regexp: /^last\s+(\d+)\s+node\s+versions?$/i, select: function(e3, t3) {
    return F.nodeVersions.slice(-t3.versions).map(function(e4) {
      return "node " + e4;
    });
  } }, last_browser_versions: { matches: ["versions", "browser"], regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i, select: function(e3, t3) {
    var r3 = k(t3.browser, e3), n3 = r3.released.slice(-t3.versions).map(m(r3.name));
    return N(n3, r3.name, t3.versions, e3);
  } }, unreleased_versions: { matches: [], regexp: /^unreleased\s+versions$/i, select: function(e3) {
    return Object.keys(s2).reduce(function(t3, r3) {
      var n3 = I(r3, e3);
      if (!n3) return t3;
      var s3 = n3.versions.filter(function(e4) {
        return -1 === n3.released.indexOf(e4);
      });
      return s3 = s3.map(m(n3.name)), t3.concat(s3);
    }, []);
  } }, unreleased_electron_versions: { matches: [], regexp: /^unreleased\s+electron\s+versions?$/i, select: function() {
    return [];
  } }, unreleased_browser_versions: { matches: ["browser"], regexp: /^unreleased\s+(\w+)\s+versions?$/i, select: function(e3, t3) {
    var r3 = k(t3.browser, e3);
    return r3.versions.filter(function(e4) {
      return -1 === r3.released.indexOf(e4);
    }).map(m(r3.name));
  } }, last_years: { matches: ["years"], regexp: /^last\s+(\d*.?\d+)\s+years?$/i, select: function(e3, t3) {
    return C(Date.now() - 315584329824e-1 * t3.years, e3);
  } }, since_y: { matches: ["year"], regexp: /^since (\d+)$/i, select: $ }, since_y_m: { matches: ["year", "month"], regexp: /^since (\d+)-(\d+)$/i, select: $ }, since_y_m_d: { matches: ["year", "month", "day"], regexp: /^since (\d+)-(\d+)-(\d+)$/i, select: $ }, popularity: { matches: ["sign", "popularity"], regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/, select: function(e3, t3) {
    var r3 = parseFloat(t3.popularity), n3 = F.usage.global;
    return Object.keys(n3).reduce(function(e4, s3) {
      return ">" === t3.sign ? n3[s3] > r3 && e4.push(s3) : "<" === t3.sign ? n3[s3] < r3 && e4.push(s3) : "<=" === t3.sign ? n3[s3] <= r3 && e4.push(s3) : n3[s3] >= r3 && e4.push(s3), e4;
    }, []);
  } }, popularity_in_my_stats: { matches: ["sign", "popularity"], regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/, select: function(e3, t3) {
    var r3 = parseFloat(t3.popularity);
    if (!e3.customUsage) throw new l("Custom usage statistics was not provided");
    var n3 = e3.customUsage;
    return Object.keys(n3).reduce(function(e4, s3) {
      var i3 = n3[s3];
      return null == i3 || (">" === t3.sign ? i3 > r3 && e4.push(s3) : "<" === t3.sign ? i3 < r3 && e4.push(s3) : "<=" === t3.sign ? i3 <= r3 && e4.push(s3) : i3 >= r3 && e4.push(s3)), e4;
    }, []);
  } }, popularity_in_config_stats: { matches: ["sign", "popularity", "config"], regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/, select: function(e3, t3) {
    var r3 = parseFloat(t3.popularity), n3 = u.loadStat(e3, t3.config, F.data);
    if (n3) for (var s3 in e3.customUsage = {}, n3) v(e3.customUsage, s3, n3[s3]);
    if (!e3.customUsage) throw new l("Custom usage statistics was not provided");
    var i3 = e3.customUsage;
    return Object.keys(i3).reduce(function(e4, n4) {
      var s4 = i3[n4];
      return null == s4 || (">" === t3.sign ? s4 > r3 && e4.push(n4) : "<" === t3.sign ? s4 < r3 && e4.push(n4) : "<=" === t3.sign ? s4 <= r3 && e4.push(n4) : s4 >= r3 && e4.push(n4)), e4;
    }, []);
  } }, popularity_in_place: { matches: ["sign", "popularity", "place"], regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/, select: function(e3, t3) {
    var r3 = parseFloat(t3.popularity), n3 = t3.place;
    n3 = 2 === n3.length ? n3.toUpperCase() : n3.toLowerCase(), u.loadCountry(F.usage, n3, F.data);
    var s3 = F.usage[n3];
    return Object.keys(s3).reduce(function(e4, n4) {
      var i3 = s3[n4];
      return null == i3 || (">" === t3.sign ? i3 > r3 && e4.push(n4) : "<" === t3.sign ? i3 < r3 && e4.push(n4) : "<=" === t3.sign ? i3 <= r3 && e4.push(n4) : i3 >= r3 && e4.push(n4)), e4;
    }, []);
  } }, cover: { matches: ["coverage"], regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i, select: V }, cover_in: { matches: ["coverage", "place"], regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i, select: V }, supports: { matches: ["supportType", "feature"], regexp: /^(?:(fully|partially) )?supports\s+([\w-]+)$/, select: function(e3, t3) {
    u.loadFeature(F.cache, t3.feature);
    var r3 = "fully" !== t3.supportType, n3 = F.cache[t3.feature], s3 = [];
    for (var i3 in n3) {
      var o3 = I(i3, e3), a3 = e3.mobileToDesktop && i3 in F.desktopNames && D(n3[i3][o3.released.slice(-1)[0]], r3);
      o3.versions.forEach(function(e4) {
        var t4 = n3[i3][e4];
        void 0 === t4 && a3 && (t4 = n3[F.desktopNames[i3]][e4]), D(t4, r3) && s3.push(i3 + " " + e4);
      });
    }
    return s3;
  } }, electron_range: { matches: ["from", "to"], regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i, select: function(e3, t3) {
    var r3 = h(t3.from), n3 = h(t3.to), s3 = parseFloat(t3.from), i3 = parseFloat(t3.to);
    if (!a2[r3]) throw new l("Unknown version " + s3 + " of electron");
    if (!a2[n3]) throw new l("Unknown version " + i3 + " of electron");
    return Object.keys(a2).filter(function(e4) {
      var t4 = parseFloat(e4);
      return t4 >= s3 && t4 <= i3;
    }).map(function(e4) {
      return "chrome " + a2[e4];
    });
  } }, node_range: { matches: ["from", "to"], regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i, select: function(e3, t3) {
    return F.nodeVersions.filter(w(">=", t3.from)).filter(w("<=", t3.to)).map(function(e4) {
      return "node " + e4;
    });
  } }, browser_range: { matches: ["browser", "from", "to"], regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i, select: function(e3, t3) {
    var r3 = k(t3.browser, e3), n3 = parseFloat(A(r3, t3.from) || t3.from), s3 = parseFloat(A(r3, t3.to) || t3.to);
    return r3.released.filter(function(e4) {
      var t4 = parseFloat(e4);
      return t4 >= n3 && t4 <= s3;
    }).map(m(r3.name));
  } }, electron_ray: { matches: ["sign", "version"], regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i, select: function(e3, t3) {
    var r3 = h(t3.version);
    return Object.keys(a2).filter(E(t3.sign, r3)).map(function(e4) {
      return "chrome " + a2[e4];
    });
  } }, node_ray: { matches: ["sign", "version"], regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i, select: function(e3, t3) {
    return F.nodeVersions.filter((r3 = t3.sign, n3 = t3.version, (n3 = n3.split(".").map(S))[1] = n3[1] || 0, n3[2] = n3[2] || 0, ">" === r3 ? function(e4) {
      return T(e4 = e4.split(".").map(S), n3) > 0;
    } : ">=" === r3 ? function(e4) {
      return T(e4 = e4.split(".").map(S), n3) >= 0;
    } : "<" === r3 ? function(e4) {
      return e4 = e4.split(".").map(S), T(n3, e4) > 0;
    } : function(e4) {
      return e4 = e4.split(".").map(S), T(n3, e4) >= 0;
    })).map(function(e4) {
      return "node " + e4;
    });
    var r3, n3;
  } }, browser_ray: { matches: ["browser", "sign", "version"], regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/, select: function(e3, t3) {
    var r3 = t3.version, n3 = k(t3.browser, e3), s3 = F.versionAliases[n3.name][r3];
    return s3 && (r3 = s3), n3.released.filter(E(t3.sign, r3)).map(function(e4) {
      return n3.name + " " + e4;
    });
  } }, firefox_esr: { matches: [], regexp: /^(firefox|ff|fx)\s+esr$/i, select: function() {
    return ["firefox 115"];
  } }, opera_mini_all: { matches: [], regexp: /(operamini|op_mini)\s+all/i, select: function() {
    return ["op_mini all"];
  } }, electron_version: { matches: ["version"], regexp: /^electron\s+([\d.]+)$/i, select: function(e3, t3) {
    var r3 = h(t3.version), n3 = a2[r3];
    if (!n3) throw new l("Unknown version " + t3.version + " of electron");
    return ["chrome " + n3];
  } }, node_major_version: { matches: ["version"], regexp: /^node\s+(\d+)$/i, select: U }, node_minor_version: { matches: ["version"], regexp: /^node\s+(\d+\.\d+)$/i, select: U }, node_patch_version: { matches: ["version"], regexp: /^node\s+(\d+\.\d+\.\d+)$/i, select: U }, current_node: { matches: [], regexp: /^current\s+node$/i, select: function(e3) {
    return [u.currentNode(j, e3)];
  } }, maintained_node: { matches: [], regexp: /^maintained\s+node\s+versions$/i, select: function(e3) {
    var t3 = Date.now();
    return j(Object.keys(i2).filter(function(e4) {
      return t3 < Date.parse(i2[e4].end) && t3 > Date.parse(i2[e4].start) && (r3 = e4.slice(1), F.nodeVersions.some(function(e5) {
        return d(e5, r3);
      }));
      var r3;
    }).map(function(e4) {
      return "node " + e4.slice(1);
    }), e3);
  } }, phantomjs_1_9: { matches: [], regexp: /^phantomjs\s+1.9$/i, select: function() {
    return ["safari 5"];
  } }, phantomjs_2_1: { matches: [], regexp: /^phantomjs\s+2.1$/i, select: function() {
    return ["safari 6"];
  } }, browser_version: { matches: ["browser", "version"], regexp: /^(\w+)\s+(tp|[\d.]+)$/i, select: function(e3, t3) {
    var r3 = t3.version;
    /^tp$/i.test(r3) && (r3 = "TP");
    var n3 = k(t3.browser, e3), s3 = A(n3, r3);
    if (s3) r3 = s3;
    else {
      if (!(s3 = A(n3, s3 = -1 === r3.indexOf(".") ? r3 + ".0" : r3.replace(/\.0$/, "")))) {
        if (e3.ignoreUnknownVersions) return [];
        throw new l("Unknown version " + r3 + " of " + t3.browser);
      }
      r3 = s3;
    }
    return [n3.name + " " + r3];
  } }, browserslist_config: { matches: [], regexp: /^browserslist config$/i, select: function(e3) {
    return F(void 0, e3);
  } }, extends: { matches: ["config"], regexp: /^extends (.+)$/i, select: function(e3, t3) {
    return j(u.loadQueries(e3, t3.config), e3);
  } }, defaults: { matches: [], regexp: /^defaults$/i, select: function(e3) {
    return j(F.defaults, e3);
  } }, dead: { matches: [], regexp: /^dead$/i, select: function(e3) {
    return j(["Baidu >= 0", "ie <= 11", "ie_mob <= 11", "bb <= 10", "op_mob <= 12.1", "samsung 4"], e3);
  } }, unknown: { matches: [], regexp: /^(\w+)$/i, select: function(e3, t3) {
    throw I(t3.query, e3) ? new l("Specify versions in Browserslist query for browser " + t3.query) : (r3 = t3.query, new l("Unknown browser query `" + r3 + "`. Maybe you are using old Browserslist or made typo in query."));
    var r3;
  } } };
  !function() {
    for (var e3 in s2) {
      var t3 = s2[e3];
      F.data[e3] = { name: e3, versions: f(s2[e3].versions), released: f(s2[e3].versions.slice(0, -3)), releaseDate: s2[e3].release_date }, v(F.usage.global, e3, t3.usage_global), F.versionAliases[e3] = {};
      for (var r3 = 0; r3 < t3.versions.length; r3++) {
        var i3 = t3.versions[r3];
        if (i3 && -1 !== i3.indexOf("-")) for (var o3 = i3.split("-"), a3 = 0; a3 < o3.length; a3++) F.versionAliases[e3][o3[a3]] = i3;
      }
    }
    F.nodeVersions = n2.map(function(e4) {
      return e4.version;
    });
  }(), e2.exports = F;
}, (e2) => {
  e2.exports = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
}, (e2) => {
  e2.exports = { 0: "111", 1: "112", 2: "113", 3: "114", 4: "115", 5: "116", 6: "117", 7: "118", 8: "5", 9: "19", A: "10", B: "11", C: "12", D: "7", E: "8", F: "9", G: "15", H: "120", I: "4", J: "6", K: "13", L: "14", M: "16", N: "17", O: "18", P: "79", Q: "80", R: "81", S: "83", T: "84", U: "85", V: "86", W: "87", X: "88", Y: "89", Z: "90", a: "91", b: "92", c: "93", d: "94", e: "95", f: "96", g: "97", h: "98", i: "99", j: "100", k: "101", l: "102", m: "103", n: "104", o: "105", p: "106", q: "119", r: "20", s: "21", t: "22", u: "23", v: "73", w: "107", x: "108", y: "109", z: "110", AB: "24", BB: "25", CB: "26", DB: "27", EB: "28", FB: "29", GB: "30", HB: "31", IB: "32", JB: "33", KB: "34", LB: "35", MB: "36", NB: "37", OB: "38", PB: "39", QB: "40", RB: "41", SB: "42", TB: "43", UB: "44", VB: "45", WB: "46", XB: "47", YB: "48", ZB: "49", aB: "50", bB: "51", cB: "52", dB: "53", eB: "54", fB: "55", gB: "56", hB: "57", iB: "58", jB: "60", kB: "62", lB: "63", mB: "64", nB: "65", oB: "66", pB: "67", qB: "68", rB: "69", sB: "70", tB: "71", uB: "72", vB: "74", wB: "75", xB: "76", yB: "77", zB: "78", "0B": "11.1", "1B": "12.1", "2B": "15.5", "3B": "16.0", "4B": "17.0", "5B": "3", "6B": "59", "7B": "61", "8B": "82", "9B": "121", AC: "122", BC: "123", CC: "3.2", DC: "10.1", EC: "13.1", FC: "15.2-15.3", GC: "15.4", HC: "16.1", IC: "16.2", JC: "16.3", KC: "16.4", LC: "16.5", MC: "17.1", NC: "17.2", OC: "17.3", PC: "11.5", QC: "4.2-4.3", RC: "5.5", SC: "2", TC: "124", UC: "3.5", VC: "3.6", WC: "3.1", XC: "5.1", YC: "6.1", ZC: "7.1", aC: "9.1", bC: "14.1", cC: "15.1", dC: "15.6", eC: "16.6", fC: "TP", gC: "9.5-9.6", hC: "10.0-10.1", iC: "10.5", jC: "10.6", kC: "11.6", lC: "4.0-4.1", mC: "5.0-5.1", nC: "6.0-6.1", oC: "7.0-7.1", pC: "8.1-8.4", qC: "9.0-9.2", rC: "9.3", sC: "10.0-10.2", tC: "10.3", uC: "11.0-11.2", vC: "11.3-11.4", wC: "12.0-12.1", xC: "12.2-12.5", yC: "13.0-13.1", zC: "13.2", "0C": "13.3", "1C": "13.4-13.7", "2C": "14.0-14.4", "3C": "14.5-14.8", "4C": "15.0-15.1", "5C": "15.6-15.8", "6C": "16.6-16.7", "7C": "all", "8C": "2.1", "9C": "2.2", AD: "2.3", BD: "4.1", CD: "4.4", DD: "4.4.3-4.4.4", ED: "5.0-5.4", FD: "6.2-6.4", GD: "7.2-7.4", HD: "8.2", ID: "9.2", JD: "11.1-11.2", KD: "12.0", LD: "13.0", MD: "14.0", ND: "15.0", OD: "18.0", PD: "19.0", QD: "13.18", RD: "2.5", SD: "3.0-3.1" };
}, (e2) => {
  e2.exports = { A: { A: { J: 0, D: 0, E: 0.0223482, F: 0.0446964, A: 0, B: 0.424615, RC: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "RC", "J", "D", "E", "F", "A", "B", "", "", ""], E: "IE", F: { RC: 962323200, J: 998870400, D: 1161129600, E: 1237420800, F: 1300060800, A: 1346716800, B: 1381968e3 } }, B: { A: { 0: 0.01209, 1: 806e-5, 2: 0.01209, 3: 0.02015, 4: 0.01209, 5: 0.02015, 6: 0.02821, 7: 0.05239, C: 403e-5, K: 403e-5, L: 403e-5, G: 403e-5, M: 0, N: 806e-5, O: 0.01209, P: 0, Q: 0, R: 0, S: 0, T: 0, U: 0, V: 0, W: 0.31434, X: 0, Y: 0, Z: 0, a: 0, b: 0.01209, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0, i: 0.02015, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 806e-5, w: 0.01612, x: 0.01612, y: 0.07657, z: 0.01612, q: 1.56364, H: 2.5389 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "K", "L", "G", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "q", "H", "", "", ""], E: "Edge", F: { 0: 1678665600, 1: 1680825600, 2: 1683158400, 3: 1685664e3, 4: 1689897600, 5: 1692576e3, 6: 1694649600, 7: 1697155200, C: 1438128e3, K: 1447286400, L: 1470096e3, G: 1491868800, M: 1508198400, N: 1525046400, O: 1542067200, P: 1579046400, Q: 1581033600, R: 1586736e3, S: 1590019200, T: 1594857600, U: 1598486400, V: 1602201600, W: 1605830400, X: 161136e4, Y: 1614816e3, Z: 1618358400, a: 1622073600, b: 1626912e3, c: 1630627200, d: 1632441600, e: 1634774400, f: 1637539200, g: 1641427200, h: 1643932800, i: 1646265600, j: 1649635200, k: 1651190400, l: 1653955200, m: 1655942400, n: 1659657600, o: 1661990400, p: 1664755200, w: 1666915200, x: 1670198400, y: 1673481600, z: 1675900800, q: 1698969600, H: 1701993600 }, D: { C: "ms", K: "ms", L: "ms", G: "ms", M: "ms", N: "ms", O: "ms" } }, C: { A: { 0: 806e-5, 1: 403e-5, 2: 0.01209, 3: 0.01612, 4: 0.43927, 5: 806e-5, 6: 0.01209, 7: 0.10881, 8: 0, 9: 0, SC: 0, "5B": 0, I: 403e-5, J: 0, D: 0, E: 0, F: 0, A: 0, B: 0.0403, C: 0.0403, K: 0, L: 0, G: 0, M: 0, N: 0, O: 0, r: 0, s: 0, t: 0, u: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 0, LB: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 806e-5, UB: 806e-5, VB: 0, WB: 0, XB: 0, YB: 806e-5, ZB: 0, aB: 806e-5, bB: 0, cB: 0.06448, dB: 806e-5, eB: 806e-5, fB: 806e-5, gB: 0.01612, hB: 0, iB: 0, "6B": 403e-5, jB: 0, "7B": 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 403e-5, v: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0.02015, P: 0, Q: 0, R: 0, "8B": 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 806e-5, Y: 0, Z: 0, a: 0.01612, b: 0, c: 0, d: 806e-5, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0.01209, l: 0.03224, m: 0.02418, n: 0.01209, o: 806e-5, p: 403e-5, w: 806e-5, x: 806e-5, y: 0.01209, z: 806e-5, q: 0.27807, H: 1.24124, "9B": 0.41912, AC: 0, BC: 0, TC: 0, UC: 0, VC: 0 }, B: "moz", C: ["SC", "5B", "UC", "VC", "I", "8", "J", "D", "E", "F", "A", "B", "C", "K", "L", "G", "M", "N", "O", "9", "r", "s", "t", "u", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "6B", "jB", "7B", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "v", "vB", "wB", "xB", "yB", "zB", "P", "Q", "R", "8B", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "q", "H", "9B", "AC", "BC", "TC"], E: "Firefox", F: { 0: 1678752e3, 1: 1681171200, 2: 1683590400, 3: 1686009600, 4: 1688428800, 5: 1690848e3, 6: 1693267200, 7: 1695686400, 8: 1308614400, 9: 1357603200, SC: 1161648e3, "5B": 1213660800, UC: 124632e4, VC: 1264032e3, I: 1300752e3, J: 1313452800, D: 1317081600, E: 1317081600, F: 1320710400, A: 1324339200, B: 1327968e3, C: 1331596800, K: 1335225600, L: 1338854400, G: 1342483200, M: 1346112e3, N: 1349740800, O: 1353628800, r: 1361232e3, s: 1364860800, t: 1368489600, u: 1372118400, AB: 1375747200, BB: 1379376e3, CB: 1386633600, DB: 1391472e3, EB: 1395100800, FB: 1398729600, GB: 1402358400, HB: 1405987200, IB: 1409616e3, JB: 1413244800, KB: 1417392e3, LB: 1421107200, MB: 1424736e3, NB: 1428278400, OB: 1431475200, PB: 1435881600, QB: 1439251200, RB: 144288e4, SB: 1446508800, TB: 1450137600, UB: 1453852800, VB: 1457395200, WB: 1461628800, XB: 1465257600, YB: 1470096e3, ZB: 1474329600, aB: 1479168e3, bB: 1485216e3, cB: 1488844800, dB: 149256e4, eB: 1497312e3, fB: 1502150400, gB: 1506556800, hB: 1510617600, iB: 1516665600, "6B": 1520985600, jB: 1525824e3, "7B": 1529971200, kB: 1536105600, lB: 1540252800, mB: 1544486400, nB: 154872e4, oB: 1552953600, pB: 1558396800, qB: 1562630400, rB: 1567468800, sB: 1571788800, tB: 1575331200, uB: 1578355200, v: 1581379200, vB: 1583798400, wB: 1586304e3, xB: 1588636800, yB: 1591056e3, zB: 1593475200, P: 1595894400, Q: 1598313600, R: 1600732800, "8B": 1603152e3, S: 1605571200, T: 1607990400, U: 1611619200, V: 1614038400, W: 1616457600, X: 1618790400, Y: 1622505600, Z: 1626134400, a: 1628553600, b: 1630972800, c: 1633392e3, d: 1635811200, e: 1638835200, f: 1641859200, g: 1644364800, h: 1646697600, i: 1649116800, j: 1651536e3, k: 1653955200, l: 1656374400, m: 1658793600, n: 1661212800, o: 1663632e3, p: 1666051200, w: 1668470400, x: 1670889600, y: 1673913600, z: 1676332800, q: 1698105600, H: 1700524800, "9B": 1702944e3, AC: null, BC: null, TC: null } }, D: { A: { 0: 0.10478, 1: 0.12896, 2: 0.21359, 3: 0.14508, 4: 0.10075, 5: 0.2821, 6: 0.26598, 7: 0.82615, 8: 0, 9: 0, I: 0, J: 0, D: 0, E: 0, F: 0, A: 0, B: 0, C: 0, K: 0, L: 0, G: 0, M: 0, N: 0, O: 0, r: 0, s: 0, t: 0, u: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 806e-5, LB: 0, MB: 0, NB: 0, OB: 0.01612, PB: 0, QB: 0, RB: 403e-5, SB: 0, TB: 0, UB: 0, VB: 806e-5, WB: 0, XB: 806e-5, YB: 0.03627, ZB: 0.02821, aB: 0.01209, bB: 0, cB: 0, dB: 806e-5, eB: 806e-5, fB: 403e-5, gB: 0.01612, hB: 806e-5, iB: 403e-5, "6B": 0, jB: 0.03224, "7B": 403e-5, kB: 0, lB: 403e-5, mB: 0, nB: 403e-5, oB: 0.03224, pB: 403e-5, qB: 403e-5, rB: 0.04836, sB: 0.0806, tB: 806e-5, uB: 806e-5, v: 0.01209, vB: 0.01209, wB: 0.01209, xB: 0.02015, yB: 0.01209, zB: 0.01612, P: 0.13299, Q: 0.02821, R: 0.02821, S: 0.04433, T: 0.01209, U: 0.03627, V: 0.04433, W: 0.06851, X: 0.01612, Y: 0.01612, Z: 0.01612, a: 0.06448, b: 0.03627, c: 0.09672, d: 0.04836, e: 0.02418, f: 0.01612, g: 0.02015, h: 0.07254, i: 0.0403, j: 0.03224, k: 0.04433, l: 0.03627, m: 0.26598, n: 0.06851, o: 0.08463, p: 0.0806, w: 0.0806, x: 0.12896, y: 1.7732, z: 0.10075, q: 8.53554, H: 10.1596, "9B": 0.01612, AC: 0.01209, BC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "I", "8", "J", "D", "E", "F", "A", "B", "C", "K", "L", "G", "M", "N", "O", "9", "r", "s", "t", "u", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "6B", "jB", "7B", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "v", "vB", "wB", "xB", "yB", "zB", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "q", "H", "9B", "AC", "BC"], E: "Chrome", F: { 0: 1678147200, 1: 1680566400, 2: 1682985600, 3: 1685404800, 4: 1689724800, 5: 1692057600, 6: 1694476800, 7: 1696896e3, 8: 1274745600, 9: 1332892800, I: 1264377600, J: 1283385600, D: 1287619200, E: 1291248e3, F: 1296777600, A: 1299542400, B: 1303862400, C: 1307404800, K: 1312243200, L: 1316131200, G: 1316131200, M: 1319500800, N: 1323734400, O: 1328659200, r: 133704e4, s: 1340668800, t: 1343692800, u: 1348531200, AB: 1352246400, BB: 1357862400, CB: 1361404800, DB: 1364428800, EB: 1369094400, FB: 1374105600, GB: 1376956800, HB: 1384214400, IB: 1389657600, JB: 1392940800, KB: 1397001600, LB: 1400544e3, MB: 1405468800, NB: 1409011200, OB: 141264e4, PB: 1416268800, QB: 1421798400, RB: 1425513600, SB: 1429401600, TB: 143208e4, UB: 1437523200, VB: 1441152e3, WB: 1444780800, XB: 1449014400, YB: 1453248e3, ZB: 1456963200, aB: 1460592e3, bB: 1464134400, cB: 1469059200, dB: 1472601600, eB: 1476230400, fB: 1480550400, gB: 1485302400, hB: 1489017600, iB: 149256e4, "6B": 1496707200, jB: 1500940800, "7B": 1504569600, kB: 1508198400, lB: 1512518400, mB: 1516752e3, nB: 1520294400, oB: 1523923200, pB: 1527552e3, qB: 1532390400, rB: 1536019200, sB: 1539648e3, tB: 1543968e3, uB: 154872e4, v: 1552348800, vB: 1555977600, wB: 1559606400, xB: 1564444800, yB: 1568073600, zB: 1571702400, P: 1575936e3, Q: 1580860800, R: 1586304e3, S: 1589846400, T: 1594684800, U: 1598313600, V: 1601942400, W: 1605571200, X: 1611014400, Y: 1614556800, Z: 1618272e3, a: 1621987200, b: 1626739200, c: 1630368e3, d: 1632268800, e: 1634601600, f: 1637020800, g: 1641340800, h: 1643673600, i: 1646092800, j: 1648512e3, k: 1650931200, l: 1653350400, m: 1655769600, n: 1659398400, o: 1661817600, p: 1664236800, w: 1666656e3, x: 166968e4, y: 1673308800, z: 1675728e3, q: 1698710400, H: 1701993600, "9B": null, AC: null, BC: null } }, E: { A: { 8: 0, I: 0, J: 0, D: 806e-5, E: 403e-5, F: 403e-5, A: 0, B: 0, C: 0, K: 806e-5, L: 0.05239, G: 806e-5, WC: 0, CC: 0, XC: 806e-5, YC: 0, ZC: 0, aC: 0.01209, DC: 0, "0B": 0.01612, "1B": 0.02015, EC: 0.0806, bC: 0.12493, cC: 0.02821, FC: 0.01612, GC: 0.03224, "2B": 0.04836, dC: 0.3224, "3B": 0.03224, HC: 0.0806, IC: 0.06448, JC: 0.1612, KC: 0.07254, LC: 0.12493, eC: 0.59241, "4B": 0.14911, MC: 1.26139, NC: 0.1612, OC: 403e-5, fC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "WC", "CC", "I", "8", "XC", "J", "YC", "D", "ZC", "E", "F", "aC", "A", "DC", "B", "0B", "C", "1B", "K", "EC", "L", "bC", "G", "cC", "FC", "GC", "2B", "dC", "3B", "HC", "IC", "JC", "KC", "LC", "eC", "4B", "MC", "NC", "OC", "fC", ""], E: "Safari", F: { 8: 1275868800, WC: 1205798400, CC: 1226534400, I: 1244419200, XC: 131112e4, J: 1343174400, YC: 13824e5, D: 13824e5, ZC: 1410998400, E: 1413417600, F: 1443657600, aC: 1458518400, A: 1474329600, DC: 1490572800, B: 1505779200, "0B": 1522281600, C: 1537142400, "1B": 1553472e3, K: 1568851200, EC: 1585008e3, L: 1600214400, bC: 1619395200, G: 1632096e3, cC: 1635292800, FC: 1639353600, GC: 1647216e3, "2B": 1652745600, dC: 1658275200, "3B": 1662940800, HC: 1666569600, IC: 1670889600, JC: 1674432e3, KC: 1679875200, LC: 1684368e3, eC: 1690156800, "4B": 1695686400, MC: 1698192e3, NC: 1702252800, OC: null, fC: null } }, F: { A: { 9: 0, F: 0, B: 0, C: 0, G: 0, M: 0, N: 0, O: 0, r: 0, s: 0, t: 0, u: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, FB: 0, GB: 0, HB: 0, IB: 0, JB: 0, KB: 0, LB: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0.01612, XB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, v: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0, P: 0, Q: 0, R: 0, "8B": 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0, c: 0, d: 403e-5, e: 0.05642, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0.02015, m: 0, n: 0.50778, o: 0.78585, p: 0.01612, gC: 0, hC: 0, iC: 0, jC: 0, "0B": 0, PC: 0, kC: 0, "1B": 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "gC", "hC", "iC", "jC", "B", "0B", "PC", "kC", "C", "1B", "G", "M", "N", "O", "9", "r", "s", "t", "u", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "v", "vB", "wB", "xB", "yB", "zB", "P", "Q", "R", "8B", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "", "", ""], E: "Opera", F: { 9: 1390867200, F: 1150761600, gC: 1223424e3, hC: 1251763200, iC: 1267488e3, jC: 1277942400, B: 1292457600, "0B": 1302566400, PC: 1309219200, kC: 1323129600, C: 1323129600, "1B": 1352073600, G: 1372723200, M: 1377561600, N: 1381104e3, O: 1386288e3, r: 1393891200, s: 1399334400, t: 1401753600, u: 1405987200, AB: 1409616e3, BB: 1413331200, CB: 1417132800, DB: 1422316800, EB: 1425945600, FB: 1430179200, GB: 1433808e3, HB: 1438646400, IB: 1442448e3, JB: 1445904e3, KB: 1449100800, LB: 1454371200, MB: 1457308800, NB: 146232e4, OB: 1465344e3, PB: 1470096e3, QB: 1474329600, RB: 1477267200, SB: 1481587200, TB: 1486425600, UB: 1490054400, VB: 1494374400, WB: 1498003200, XB: 1502236800, YB: 1506470400, ZB: 1510099200, aB: 1515024e3, bB: 1517961600, cB: 1521676800, dB: 1525910400, eB: 1530144e3, fB: 1534982400, gB: 1537833600, hB: 1543363200, iB: 1548201600, jB: 1554768e3, kB: 1561593600, lB: 1566259200, mB: 1570406400, nB: 1573689600, oB: 1578441600, pB: 1583971200, qB: 1587513600, rB: 1592956800, sB: 1595894400, tB: 1600128e3, uB: 1603238400, v: 161352e4, vB: 1612224e3, wB: 1616544e3, xB: 1619568e3, yB: 1623715200, zB: 1627948800, P: 1631577600, Q: 1633392e3, R: 1635984e3, "8B": 1638403200, S: 1642550400, T: 1644969600, U: 1647993600, V: 1650412800, W: 1652745600, X: 1654646400, Y: 1657152e3, Z: 1660780800, a: 1663113600, b: 1668816e3, c: 1668643200, d: 1671062400, e: 1675209600, f: 1677024e3, g: 1679529600, h: 1681948800, i: 1684195200, j: 1687219200, k: 1690329600, l: 1692748800, m: 1696204800, n: 169992e4, o: 169992e4, p: 1702944e3 }, D: { F: "o", B: "o", C: "o", gC: "o", hC: "o", iC: "o", jC: "o", "0B": "o", PC: "o", kC: "o", "1B": "o" } }, G: { A: { E: 0, CC: 0, lC: 0, QC: 294848e-8, mC: 294848e-8, nC: 589696e-8, oC: 0.0103197, pC: 294848e-8, qC: 0.0103197, rC: 0.0353818, sC: 294848e-8, tC: 0.0545469, uC: 0.0221136, vC: 0.0250621, wC: 0.0132682, xC: 0.27126, yC: 589696e-8, zC: 0.042753, "0C": 0.0147424, "1C": 0.0530726, "2C": 0.106145, "3C": 0.165115, "4C": 0.0707635, FC: 0.0810832, GC: 0.0987741, "2B": 0.126785, "5C": 0.971524, "3B": 0.308116, HC: 0.661934, IC: 0.293374, JC: 0.551366, KC: 0.110568, LC: 0.263889, "6C": 2.32635, "4B": 0.412787, MC: 6.85816, NC: 0.717955, OC: 0.0353818 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "CC", "lC", "QC", "mC", "nC", "oC", "E", "pC", "qC", "rC", "sC", "tC", "uC", "vC", "wC", "xC", "yC", "zC", "0C", "1C", "2C", "3C", "4C", "FC", "GC", "2B", "5C", "3B", "HC", "IC", "JC", "KC", "LC", "6C", "4B", "MC", "NC", "OC", "", ""], E: "Safari on iOS", F: { CC: 1270252800, lC: 1283904e3, QC: 1299628800, mC: 1331078400, nC: 1359331200, oC: 1394409600, E: 1410912e3, pC: 1413763200, qC: 1442361600, rC: 1458518400, sC: 1473724800, tC: 1490572800, uC: 1505779200, vC: 1522281600, wC: 1537142400, xC: 1553472e3, yC: 1568851200, zC: 1572220800, "0C": 1580169600, "1C": 1585008e3, "2C": 1600214400, "3C": 1619395200, "4C": 1632096e3, FC: 1639353600, GC: 1647216e3, "2B": 1652659200, "5C": 1658275200, "3B": 1662940800, HC: 1666569600, IC: 1670889600, JC: 1674432e3, KC: 1679875200, LC: 1684368e3, "6C": 1690156800, "4B": 1694995200, MC: 1698192e3, NC: 1702252800, OC: null } }, H: { A: { "7C": 0.07 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "7C", "", "", ""], E: "Opera Mini", F: { "7C": 1426464e3 } }, I: { A: { "5B": 0, I: 489622e-10, H: 0.24366, "8C": 0, "9C": 244811e-10, AD: 0, BD: 489622e-10, QC: 171368e-9, CD: 0, DD: 709952e-9 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "8C", "9C", "AD", "5B", "I", "BD", "QC", "CD", "DD", "H", "", "", ""], E: "Android Browser", F: { "8C": 1256515200, "9C": 1274313600, AD: 1291593600, "5B": 1298332800, I: 1318896e3, BD: 1341792e3, QC: 1374624e3, CD: 1386547200, DD: 1401667200, H: 1701734400 } }, J: { A: { D: 0, A: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "A", "", "", ""], E: "Blackberry Browser", F: { D: 1325376e3, A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, v: 1.27348, "0B": 0, PC: 0, "1B": 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "0B", "PC", "C", "1B", "v", "", "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, "0B": 1314835200, PC: 1318291200, C: 1330300800, "1B": 1349740800, v: 1673827200 }, D: { v: "webkit" } }, L: { A: { H: 40.1948 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "H", "", "", ""], E: "Chrome for Android", F: { H: 1701734400 } }, M: { A: { q: 0.310492 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "q", "", "", ""], E: "Firefox for Android", F: { q: 1698105600 } }, N: { A: { A: 0, B: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } }, O: { A: { "2B": 0.883708 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "2B", "", "", ""], E: "UC Browser for Android", F: { "2B": 1687132800 }, D: { "2B": "webkit" } }, P: { A: { I: 0.1284, r: 0.0428001, s: 0.0856003, t: 0.1605, u: 2.04371, ED: 0.0107, FD: 0, GD: 0.0535002, HD: 0, ID: 0, DC: 0, JD: 0.0107, KD: 0, LD: 0.0214001, MD: 0, ND: 0, "3B": 0.0214001, "4B": 0.0321001, OD: 0.0214001, PD: 0.0428001 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "ED", "FD", "GD", "HD", "ID", "DC", "JD", "KD", "LD", "MD", "ND", "3B", "4B", "OD", "PD", "r", "s", "t", "u", "", "", ""], E: "Samsung Internet", F: { I: 1461024e3, ED: 1481846400, FD: 1509408e3, GD: 1528329600, HD: 1546128e3, ID: 1554163200, DC: 1567900800, JD: 1582588800, KD: 1593475200, LD: 1605657600, MD: 1618531200, ND: 1629072e3, "3B": 1640736e3, "4B": 1651708800, OD: 1659657600, PD: 1667260800, r: 1677369600, s: 1684454400, t: 1689292800, u: 1697587200 } }, Q: { A: { EC: 0.167188 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "EC", "", "", ""], E: "QQ Browser", F: { EC: 1663718400 } }, R: { A: { QD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "QD", "", "", ""], E: "Baidu Browser", F: { QD: 1663027200 } }, S: { A: { RD: 0.083594, SD: 0 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "RD", "SD", "", "", ""], E: "KaiOS Browser", F: { RD: 1527811200, SD: 1631664e3 } } };
}, (e2) => {
  e2.exports = { "0.20": "39", 0.21: "41", 0.22: "41", 0.23: "41", 0.24: "41", 0.25: "42", 0.26: "42", 0.27: "43", 0.28: "43", 0.29: "43", "0.30": "44", 0.31: "45", 0.32: "45", 0.33: "45", 0.34: "45", 0.35: "45", 0.36: "47", 0.37: "49", "1.0": "49", 1.1: "50", 1.2: "51", 1.3: "52", 1.4: "53", 1.5: "54", 1.6: "56", 1.7: "58", 1.8: "59", "2.0": "61", 2.1: "61", "3.0": "66", 3.1: "66", "4.0": "69", 4.1: "69", 4.2: "69", "5.0": "73", "6.0": "76", 6.1: "76", "7.0": "78", 7.1: "78", 7.2: "78", 7.3: "78", "8.0": "80", 8.1: "80", 8.2: "80", 8.3: "80", 8.4: "80", 8.5: "80", "9.0": "83", 9.1: "83", 9.2: "83", 9.3: "83", 9.4: "83", "10.0": "85", 10.1: "85", 10.2: "85", 10.3: "85", 10.4: "85", "11.0": "87", 11.1: "87", 11.2: "87", 11.3: "87", 11.4: "87", 11.5: "87", "12.0": "89", 12.1: "89", 12.2: "89", "13.0": "91", 13.1: "91", 13.2: "91", 13.3: "91", 13.4: "91", 13.5: "91", 13.6: "91", "14.0": "93", 14.1: "93", 14.2: "93", "15.0": "94", 15.1: "94", 15.2: "94", 15.3: "94", 15.4: "94", 15.5: "94", "16.0": "96", 16.1: "96", 16.2: "96", "17.0": "98", 17.1: "98", 17.2: "98", 17.3: "98", 17.4: "98", "18.0": "100", 18.1: "100", 18.2: "100", 18.3: "100", "19.0": "102", 19.1: "102", "20.0": "104", 20.1: "104", 20.2: "104", 20.3: "104", "21.0": "106", 21.1: "106", 21.2: "106", 21.3: "106", 21.4: "106", "22.0": "108", 22.1: "108", 22.2: "108", 22.3: "108", "23.0": "110", 23.1: "110", 23.2: "110", 23.3: "110", "24.0": "112", 24.1: "112", 24.2: "112", 24.3: "112", 24.4: "112", 24.5: "112", 24.6: "112", 24.7: "112", 24.8: "112", "25.0": "114", 25.1: "114", 25.2: "114", 25.3: "114", 25.4: "114", 25.5: "114", 25.6: "114", 25.7: "114", 25.8: "114", 25.9: "114", "26.0": "116", 26.1: "116", 26.2: "116", 26.3: "116", 26.4: "116", 26.5: "116", 26.6: "116", "27.0": "118", 27.1: "118", 27.2: "118", "28.0": "120", 28.1: "120", "29.0": "121" };
}, (e2) => {
  var t2 = /^\s+and\s+(.*)/i, r2 = /^(?:,\s*|\s+or\s+)(.*)/i;
  function n2(e3) {
    return Array.isArray(e3) ? e3.reduce(function(e4, t3) {
      return e4.concat(n2(t3));
    }, []) : [e3];
  }
  function s2(e3, t3) {
    var r3 = { query: t3 };
    for (var n3 in 0 === t3.indexOf("not ") && (r3.not = true, t3 = t3.slice(4)), e3) {
      var s3 = e3[n3], i3 = t3.match(s3.regexp);
      if (i3) {
        r3.type = n3;
        for (var o2 = 0; o2 < s3.matches.length; o2++) r3[s3.matches[o2]] = i3[o2 + 1];
        return r3;
      }
    }
    return r3.type = "unknown", r3;
  }
  function i2(e3, n3, i3) {
    var o2;
    return function(e4, t3) {
      for (var r3 = 1, n4 = e4.length; r3 <= n4; r3++) if (t3(e4.substr(-r3, r3), r3, n4)) return e4.slice(0, -r3);
      return "";
    }(n3, function(n4, a2, l) {
      return t2.test(n4) ? ((o2 = s2(e3, n4.match(t2)[1])).compose = "and", i3.unshift(o2), true) : r2.test(n4) ? ((o2 = s2(e3, n4.match(r2)[1])).compose = "or", i3.unshift(o2), true) : a2 === l && ((o2 = s2(e3, n4.trim())).compose = "or", i3.unshift(o2), true);
    });
  }
  e2.exports = function(e3, t3) {
    return Array.isArray(t3) || (t3 = [t3]), n2(t3.map(function(t4) {
      var r3 = [];
      do {
        t4 = i2(e3, t4, r3);
      } while (t4);
      return r3;
    }));
  };
}, (e2, t2, r2) => {
  var n2 = r2(137);
  function s2() {
  }
  e2.exports = { loadQueries: function() {
    throw new n2("Sharable configs are not supported in client-side build of Browserslist");
  }, getStat: function(e3) {
    return e3.stats;
  }, loadConfig: function(e3) {
    if (e3.config) throw new n2("Browserslist config are not supported in client-side build");
  }, loadCountry: function() {
    throw new n2("Country statistics are not supported in client-side build of Browserslist");
  }, loadFeature: function() {
    throw new n2("Supports queries are not available in client-side build of Browserslist");
  }, currentNode: function(e3, t3) {
    return e3(["maintained node versions"], t3)[0];
  }, parseConfig: s2, readConfig: s2, findConfig: s2, clearCaches: s2, oldDataWarning: s2, env: {} };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "OptionValidator", { enumerable: true, get: function() {
    return n2.OptionValidator;
  } }), Object.defineProperty(t2, "findSuggestion", { enumerable: true, get: function() {
    return s2.findSuggestion;
  } });
  var n2 = r2(462), s2 = r2(290);
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.findSuggestion = function(e3, t3) {
    const n2 = t3.map((t4) => function(e4, t5) {
      let n3, s2, i2 = [], o2 = [];
      const a2 = e4.length, l = t5.length;
      if (!a2) return l;
      if (!l) return a2;
      for (s2 = 0; s2 <= l; s2++) i2[s2] = s2;
      for (n3 = 1; n3 <= a2; n3++) {
        for (o2 = [n3], s2 = 1; s2 <= l; s2++) o2[s2] = e4[n3 - 1] === t5[s2 - 1] ? i2[s2 - 1] : r2(i2[s2 - 1], i2[s2], o2[s2 - 1]) + 1;
        i2 = o2;
      }
      return o2[l];
    }(t4, e3));
    return t3[n2.indexOf(r2(...n2))];
  };
  const { min: r2 } = Math;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.prettifyTargets = function(e3) {
    return Object.keys(e3).reduce((t3, r3) => {
      let n3 = e3[r3];
      const o2 = s2.unreleasedLabels[r3];
      return "string" == typeof n3 && o2 !== n3 && (n3 = i2(n3)), t3[r3] = n3, t3;
    }, {});
  }, t2.prettifyVersion = i2;
  var n2 = r2(23), s2 = r2(139);
  function i2(e3) {
    if ("string" != typeof e3) return e3;
    const { major: t3, minor: r3, patch: s3 } = n2.parse(e3), i3 = [t3];
    return (r3 || s3) && i3.push(r3), s3 && i3.push(s3), i3.join(".");
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(10);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2() {
    const e3 = r2(61);
    return s2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.buildPresetChain = function* (e3, t3) {
    const r3 = yield* h(e3, t3);
    return r3 ? { plugins: F(r3.plugins), presets: F(r3.presets), options: r3.options.map((e4) => R(e4)), files: /* @__PURE__ */ new Set() } : null;
  }, t2.buildPresetChainWalker = void 0, t2.buildRootChain = function* (e3, t3) {
    let r3, s3;
    const i3 = new a2.ConfigPrinter(), l2 = yield* x({ options: e3, dirname: t3.cwd }, t3, void 0, i3);
    if (!l2) return null;
    let c2;
    yield* i3.output(), "string" == typeof e3.configFile ? c2 = yield* (0, u.loadConfig)(e3.configFile, t3.cwd, t3.envName, t3.caller) : false !== e3.configFile && (c2 = yield* (0, u.findRootConfig)(t3.root, t3.envName, t3.caller));
    let { babelrc: p2, babelrcRoots: d2 } = e3, f2 = t3.cwd;
    const h2 = B(), m2 = new a2.ConfigPrinter();
    if (c2) {
      const e4 = v(c2), n3 = yield* w(e4, t3, void 0, m2);
      if (!n3) return null;
      r3 = yield* m2.output(), void 0 === p2 && (p2 = e4.options.babelrc), void 0 === d2 && (f2 = e4.dirname, d2 = e4.options.babelrcRoots), L(h2, n3);
    }
    let y2, g2, b2 = false;
    const S2 = B();
    if ((true === p2 || void 0 === p2) && "string" == typeof t3.filename) {
      const e4 = yield* (0, u.findPackageData)(t3.filename);
      if (e4 && function(e5, t4, r4, s4) {
        if ("boolean" == typeof r4) return r4;
        const i4 = e5.root;
        if (void 0 === r4) return -1 !== t4.directories.indexOf(i4);
        let a3 = r4;
        return Array.isArray(a3) || (a3 = [a3]), a3 = a3.map((e6) => "string" == typeof e6 ? n2().resolve(s4, e6) : e6), 1 === a3.length && a3[0] === i4 ? -1 !== t4.directories.indexOf(i4) : a3.some((r5) => ("string" == typeof r5 && (r5 = (0, o2.default)(r5, s4)), t4.directories.some((t5) => G(r5, s4, t5, e5))));
      }(t3, e4, d2, f2)) {
        if ({ ignore: y2, config: g2 } = yield* (0, u.findRelativeConfig)(e4, t3.envName, t3.caller), y2 && S2.files.add(y2.filepath), y2 && q(t3, y2.ignore, null, y2.dirname) && (b2 = true), g2 && !b2) {
          const e5 = E(g2), r4 = new a2.ConfigPrinter(), n3 = yield* w(e5, t3, void 0, r4);
          n3 ? (s3 = yield* r4.output(), L(S2, n3)) : b2 = true;
        }
        g2 && b2 && S2.files.add(g2.filepath);
      }
    }
    t3.showConfig;
    const T2 = L(L(L(B(), h2), S2), l2);
    return { plugins: b2 ? [] : F(T2.plugins), presets: b2 ? [] : F(T2.presets), options: b2 ? [] : T2.options.map((e4) => R(e4)), fileHandling: b2 ? "ignored" : "transpile", ignore: y2 || void 0, babelrc: g2 || void 0, config: c2 || void 0, files: T2.files };
  };
  var i2 = r2(85), o2 = r2(471), a2 = r2(472), l = r2(39), c = r2(140), u = r2(81), p = r2(84), d = r2(279);
  const f = s2()("babel:config:config-chain"), h = t2.buildPresetChainWalker = D({ root: (e3) => m(e3), env: (e3, t3) => y(e3)(t3), overrides: (e3, t3) => g(e3)(t3), overridesEnv: (e3, t3, r3) => b(e3)(t3)(r3), createLogger: () => () => {
  } }), m = (0, p.makeWeakCacheSync)((e3) => I(e3, e3.alias, d.createUncachedDescriptors)), y = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => _(e3, e3.alias, d.createUncachedDescriptors, t3))), g = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => k(e3, e3.alias, d.createUncachedDescriptors, t3))), b = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => (0, p.makeStrongCacheSync)((r3) => N(e3, e3.alias, d.createUncachedDescriptors, t3, r3)))), v = (0, p.makeWeakCacheSync)((e3) => ({ filepath: e3.filepath, dirname: e3.dirname, options: (0, i2.validate)("configfile", e3.options, e3.filepath) })), E = (0, p.makeWeakCacheSync)((e3) => ({ filepath: e3.filepath, dirname: e3.dirname, options: (0, i2.validate)("babelrcfile", e3.options, e3.filepath) })), S = (0, p.makeWeakCacheSync)((e3) => ({ filepath: e3.filepath, dirname: e3.dirname, options: (0, i2.validate)("extendsfile", e3.options, e3.filepath) })), x = D({ root: (e3) => I(e3, "base", d.createCachedDescriptors), env: (e3, t3) => _(e3, "base", d.createCachedDescriptors, t3), overrides: (e3, t3) => k(e3, "base", d.createCachedDescriptors, t3), overridesEnv: (e3, t3, r3) => N(e3, "base", d.createCachedDescriptors, t3, r3), createLogger: (e3, t3, r3) => function(e4, t4, r4) {
    var n3;
    return r4 ? r4.configure(t4.showConfig, a2.ChainFormatter.Programmatic, { callerName: null == (n3 = t4.caller) ? void 0 : n3.name }) : () => {
    };
  }(0, t3, r3) }), T = D({ root: (e3) => P(e3), env: (e3, t3) => A(e3)(t3), overrides: (e3, t3) => C(e3)(t3), overridesEnv: (e3, t3, r3) => O(e3)(t3)(r3), createLogger: (e3, t3, r3) => function(e4, t4, r4) {
    return r4 ? r4.configure(t4.showConfig, a2.ChainFormatter.Config, { filepath: e4 }) : () => {
    };
  }(e3.filepath, t3, r3) });
  function* w(e3, t3, r3, n3) {
    const s3 = yield* T(e3, t3, r3, n3);
    return null == s3 || s3.files.add(e3.filepath), s3;
  }
  const P = (0, p.makeWeakCacheSync)((e3) => I(e3, e3.filepath, d.createUncachedDescriptors)), A = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => _(e3, e3.filepath, d.createUncachedDescriptors, t3))), C = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => k(e3, e3.filepath, d.createUncachedDescriptors, t3))), O = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => (0, p.makeStrongCacheSync)((r3) => N(e3, e3.filepath, d.createUncachedDescriptors, t3, r3))));
  function I(e3, t3, r3) {
    let { dirname: n3, options: s3 } = e3;
    return r3(n3, s3, t3);
  }
  function _(e3, t3, r3, n3) {
    let { dirname: s3, options: i3 } = e3;
    var o3;
    const a3 = null == (o3 = i3.env) ? void 0 : o3[n3];
    return a3 ? r3(s3, a3, `${t3}.env["${n3}"]`) : null;
  }
  function k(e3, t3, r3, n3) {
    let { dirname: s3, options: i3 } = e3;
    var o3;
    const a3 = null == (o3 = i3.overrides) ? void 0 : o3[n3];
    if (!a3) throw new Error("Assertion failure - missing override");
    return r3(s3, a3, `${t3}.overrides[${n3}]`);
  }
  function N(e3, t3, r3, n3, s3) {
    let { dirname: i3, options: o3 } = e3;
    var a3, l2;
    const c2 = null == (a3 = o3.overrides) ? void 0 : a3[n3];
    if (!c2) throw new Error("Assertion failure - missing override");
    const u2 = null == (l2 = c2.env) ? void 0 : l2[s3];
    return u2 ? r3(i3, u2, `${t3}.overrides[${n3}].env["${s3}"]`) : null;
  }
  function D(e3) {
    let { root: t3, env: r3, overrides: n3, overridesEnv: s3, createLogger: i3 } = e3;
    return function(e4, o3) {
      let a3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : /* @__PURE__ */ new Set(), l2 = arguments.length > 3 ? arguments[3] : void 0;
      return function* () {
        const { dirname: c2 } = e4, u2 = [], p2 = t3(e4);
        if (U(p2, c2, o3, e4.filepath)) {
          u2.push({ config: p2, envName: void 0, index: void 0 });
          const t4 = r3(e4, o3.envName);
          t4 && U(t4, c2, o3, e4.filepath) && u2.push({ config: t4, envName: o3.envName, index: void 0 }), (p2.options.overrides || []).forEach((t5, r4) => {
            const i4 = n3(e4, r4);
            if (U(i4, c2, o3, e4.filepath)) {
              u2.push({ config: i4, index: r4, envName: void 0 });
              const t6 = s3(e4, r4, o3.envName);
              t6 && U(t6, c2, o3, e4.filepath) && u2.push({ config: t6, index: r4, envName: o3.envName });
            }
          });
        }
        if (u2.some((e5) => {
          let { config: { options: { ignore: t4, only: r4 } } } = e5;
          return q(o3, t4, r4, c2);
        })) return null;
        const d2 = B(), f2 = i3(e4, o3, l2);
        for (const { config: e5, index: t4, envName: r4 } of u2) {
          if (!(yield* j(d2, e5.options, c2, o3, a3, l2))) return null;
          f2(e5, t4, r4), yield* M(d2, e5);
        }
        return d2;
      }();
    };
  }
  function* j(e3, t3, r3, n3, s3, i3) {
    if (void 0 === t3.extends) return true;
    const o3 = yield* (0, u.loadConfig)(t3.extends, r3, n3.envName, n3.caller);
    if (s3.has(o3)) throw new Error(`Configuration cycle detected loading ${o3.filepath}.
File already loaded following the config chain:
` + Array.from(s3, (e4) => ` - ${e4.filepath}`).join("\n"));
    s3.add(o3);
    const a3 = yield* w(S(o3), n3, s3, i3);
    return s3.delete(o3), !!a3 && (L(e3, a3), true);
  }
  function L(e3, t3) {
    e3.options.push(...t3.options), e3.plugins.push(...t3.plugins), e3.presets.push(...t3.presets);
    for (const r3 of t3.files) e3.files.add(r3);
    return e3;
  }
  function M(e3, t3) {
    let { options: r3, plugins: n3, presets: s3 } = t3;
    return function* () {
      return e3.options.push(r3), e3.plugins.push(...yield* n3()), e3.presets.push(...yield* s3()), e3;
    }();
  }
  function B() {
    return { options: [], presets: [], plugins: [], files: /* @__PURE__ */ new Set() };
  }
  function R(e3) {
    const t3 = Object.assign({}, e3);
    return delete t3.extends, delete t3.env, delete t3.overrides, delete t3.plugins, delete t3.presets, delete t3.passPerPreset, delete t3.ignore, delete t3.only, delete t3.test, delete t3.include, delete t3.exclude, Object.prototype.hasOwnProperty.call(t3, "sourceMap") && (t3.sourceMaps = t3.sourceMap, delete t3.sourceMap), t3;
  }
  function F(e3) {
    const t3 = /* @__PURE__ */ new Map(), r3 = [];
    for (const n3 of e3) if ("function" == typeof n3.value) {
      const e4 = n3.value;
      let s3 = t3.get(e4);
      s3 || (s3 = /* @__PURE__ */ new Map(), t3.set(e4, s3));
      let i3 = s3.get(n3.name);
      i3 ? i3.value = n3 : (i3 = { value: n3 }, r3.push(i3), n3.ownPass || s3.set(n3.name, i3));
    } else r3.push({ value: n3 });
    return r3.reduce((e4, t4) => (e4.push(t4.value), e4), []);
  }
  function U(e3, t3, r3, n3) {
    let { options: s3 } = e3;
    return (void 0 === s3.test || $(r3, s3.test, t3, n3)) && (void 0 === s3.include || $(r3, s3.include, t3, n3)) && (void 0 === s3.exclude || !$(r3, s3.exclude, t3, n3));
  }
  function $(e3, t3, r3, n3) {
    return W(e3, Array.isArray(t3) ? t3 : [t3], r3, n3);
  }
  function V(e3, t3) {
    return t3 instanceof RegExp ? String(t3) : t3;
  }
  function q(e3, t3, r3, n3) {
    if (t3 && W(e3, t3, n3)) {
      var s3;
      const r4 = `No config is applied to "${null != (s3 = e3.filename) ? s3 : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(t3, V)}\` from "${n3}"`;
      return f(r4), e3.showConfig, true;
    }
    if (r3 && !W(e3, r3, n3)) {
      var i3;
      const t4 = `No config is applied to "${null != (i3 = e3.filename) ? i3 : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(r3, V)}\` from "${n3}"`;
      return f(t4), e3.showConfig, true;
    }
    return false;
  }
  function W(e3, t3, r3, n3) {
    return t3.some((t4) => G(t4, r3, e3.filename, e3, n3));
  }
  function G(e3, t3, r3, n3, s3) {
    if ("function" == typeof e3) return !!(0, l.endHiddenCallStack)(e3)(r3, { dirname: t3, envName: n3.envName, caller: n3.caller });
    if ("string" != typeof r3) throw new c.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", s3);
    return "string" == typeof e3 && (e3 = (0, o2.default)(e3, t3)), e3.test(r3);
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(281);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.access = o2, t2.assertArray = c, t2.assertAssumptions = function(e3, t3) {
    if (void 0 === t3) return;
    if ("object" != typeof t3 || null === t3) throw new Error(`${i2(e3)} must be an object or undefined.`);
    let r3 = e3;
    do {
      r3 = r3.parent;
    } while ("root" !== r3.type);
    const n3 = "preset" === r3.source;
    for (const r4 of Object.keys(t3)) {
      const a3 = o2(e3, r4);
      if (!s2.assumptionsNames.has(r4)) throw new Error(`${i2(a3)} is not a supported assumption.`);
      if ("boolean" != typeof t3[r4]) throw new Error(`${i2(a3)} must be a boolean.`);
      if (n3 && false === t3[r4]) throw new Error(`${i2(a3)} cannot be set to 'false' inside presets.`);
    }
    return t3;
  }, t2.assertBabelrcSearch = function(e3, t3) {
    if (void 0 === t3 || "boolean" == typeof t3) return t3;
    if (Array.isArray(t3)) t3.forEach((t4, r3) => {
      if (!u(t4)) throw new Error(`${i2(o2(e3, r3))} must be a string/Function/RegExp.`);
    });
    else if (!u(t3)) throw new Error(`${i2(e3)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(t3)}`);
    return t3;
  }, t2.assertBoolean = a2, t2.assertCallerMetadata = function(e3, t3) {
    const r3 = l(e3, t3);
    if (r3) {
      if ("string" != typeof r3.name) throw new Error(`${i2(e3)} set but does not contain "name" property string`);
      for (const t4 of Object.keys(r3)) {
        const n3 = o2(e3, t4), s3 = r3[t4];
        if (null != s3 && "boolean" != typeof s3 && "string" != typeof s3 && "number" != typeof s3) throw new Error(`${i2(n3)} must be null, undefined, a boolean, a string, or a number.`);
      }
    }
    return t3;
  }, t2.assertCompact = function(e3, t3) {
    if (void 0 !== t3 && "boolean" != typeof t3 && "auto" !== t3) throw new Error(`${i2(e3)} must be a boolean, "auto", or undefined`);
    return t3;
  }, t2.assertConfigApplicableTest = function(e3, t3) {
    if (void 0 === t3) return t3;
    if (Array.isArray(t3)) t3.forEach((t4, r3) => {
      if (!u(t4)) throw new Error(`${i2(o2(e3, r3))} must be a string/Function/RegExp.`);
    });
    else if (!u(t3)) throw new Error(`${i2(e3)} must be a string/Function/RegExp, or an array of those`);
    return t3;
  }, t2.assertConfigFileSearch = function(e3, t3) {
    if (void 0 !== t3 && "boolean" != typeof t3 && "string" != typeof t3) throw new Error(`${i2(e3)} must be a undefined, a boolean, a string, got ${JSON.stringify(t3)}`);
    return t3;
  }, t2.assertFunction = function(e3, t3) {
    if (void 0 !== t3 && "function" != typeof t3) throw new Error(`${i2(e3)} must be a function, or undefined`);
    return t3;
  }, t2.assertIgnoreList = function(e3, t3) {
    const r3 = c(e3, t3);
    return null == r3 || r3.forEach((t4, r4) => function(e4, t5) {
      if ("string" != typeof t5 && "function" != typeof t5 && !(t5 instanceof RegExp)) throw new Error(`${i2(e4)} must be an array of string/Function/RegExp values, or undefined`);
      return t5;
    }(o2(e3, r4), t4)), r3;
  }, t2.assertInputSourceMap = function(e3, t3) {
    if (void 0 !== t3 && "boolean" != typeof t3 && ("object" != typeof t3 || !t3)) throw new Error(`${i2(e3)} must be a boolean, object, or undefined`);
    return t3;
  }, t2.assertObject = l, t2.assertPluginList = function(e3, t3) {
    const r3 = c(e3, t3);
    return r3 && r3.forEach((t4, r4) => function(e4, t5) {
      if (Array.isArray(t5)) {
        if (0 === t5.length) throw new Error(`${i2(e4)} must include an object`);
        if (t5.length > 3) throw new Error(`${i2(e4)} may only be a two-tuple or three-tuple`);
        if (p(o2(e4, 0), t5[0]), t5.length > 1) {
          const r5 = t5[1];
          if (void 0 !== r5 && false !== r5 && ("object" != typeof r5 || Array.isArray(r5) || null === r5)) throw new Error(`${i2(o2(e4, 1))} must be an object, false, or undefined`);
        }
        if (3 === t5.length) {
          const r5 = t5[2];
          if (void 0 !== r5 && "string" != typeof r5) throw new Error(`${i2(o2(e4, 2))} must be a string, or undefined`);
        }
      } else p(e4, t5);
      return t5;
    }(o2(e3, r4), t4)), r3;
  }, t2.assertRootMode = function(e3, t3) {
    if (void 0 !== t3 && "root" !== t3 && "upward" !== t3 && "upward-optional" !== t3) throw new Error(`${i2(e3)} must be a "root", "upward", "upward-optional" or undefined`);
    return t3;
  }, t2.assertSourceMaps = function(e3, t3) {
    if (void 0 !== t3 && "boolean" != typeof t3 && "inline" !== t3 && "both" !== t3) throw new Error(`${i2(e3)} must be a boolean, "inline", "both", or undefined`);
    return t3;
  }, t2.assertSourceType = function(e3, t3) {
    if (void 0 !== t3 && "module" !== t3 && "script" !== t3 && "unambiguous" !== t3) throw new Error(`${i2(e3)} must be "module", "script", "unambiguous", or undefined`);
    return t3;
  }, t2.assertString = function(e3, t3) {
    if (void 0 !== t3 && "string" != typeof t3) throw new Error(`${i2(e3)} must be a string, or undefined`);
    return t3;
  }, t2.assertTargets = function(e3, t3) {
    if ((0, n2().isBrowsersQueryValid)(t3)) return t3;
    if ("object" != typeof t3 || !t3 || Array.isArray(t3)) throw new Error(`${i2(e3)} must be a string, an array of strings or an object`);
    const r3 = o2(e3, "browsers"), s3 = o2(e3, "esmodules");
    d(r3, t3.browsers), a2(s3, t3.esmodules);
    for (const r4 of Object.keys(t3)) {
      const s4 = t3[r4], l2 = o2(e3, r4);
      if ("esmodules" === r4) a2(l2, s4);
      else if ("browsers" === r4) d(l2, s4);
      else {
        if (!Object.hasOwnProperty.call(n2().TargetNames, r4)) {
          const e4 = Object.keys(n2().TargetNames).join(", ");
          throw new Error(`${i2(l2)} is not a valid target. Supported targets are ${e4}`);
        }
        f(l2, s4);
      }
    }
    return t3;
  }, t2.msg = i2;
  var s2 = r2(85);
  function i2(e3) {
    switch (e3.type) {
      case "root":
        return "";
      case "env":
        return `${i2(e3.parent)}.env["${e3.name}"]`;
      case "overrides":
        return `${i2(e3.parent)}.overrides[${e3.index}]`;
      case "option":
        return `${i2(e3.parent)}.${e3.name}`;
      case "access":
        return `${i2(e3.parent)}[${JSON.stringify(e3.name)}]`;
      default:
        throw new Error(`Assertion failure: Unknown type ${e3.type}`);
    }
  }
  function o2(e3, t3) {
    return { type: "access", name: t3, parent: e3 };
  }
  function a2(e3, t3) {
    if (void 0 !== t3 && "boolean" != typeof t3) throw new Error(`${i2(e3)} must be a boolean, or undefined`);
    return t3;
  }
  function l(e3, t3) {
    if (void 0 !== t3 && ("object" != typeof t3 || Array.isArray(t3) || !t3)) throw new Error(`${i2(e3)} must be an object, or undefined`);
    return t3;
  }
  function c(e3, t3) {
    if (null != t3 && !Array.isArray(t3)) throw new Error(`${i2(e3)} must be an array, or undefined`);
    return t3;
  }
  function u(e3) {
    return "string" == typeof e3 || "function" == typeof e3 || e3 instanceof RegExp;
  }
  function p(e3, t3) {
    if (("object" != typeof t3 || !t3) && "string" != typeof t3 && "function" != typeof t3) throw new Error(`${i2(e3)} must be a string, object, function`);
    return t3;
  }
  function d(e3, t3) {
    if (void 0 !== t3 && !(0, n2().isBrowsersQueryValid)(t3)) throw new Error(`${i2(e3)} must be undefined, a string or an array of strings`);
  }
  function f(e3, t3) {
    if (("number" != typeof t3 || Math.round(t3) !== t3) && "string" != typeof t3) throw new Error(`${i2(e3)} must be a string or an integer number`);
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(10);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = f, t2.loadPartialConfig = function* (e3) {
    let t3 = false;
    if ("object" == typeof e3 && null !== e3 && !Array.isArray(e3)) {
      var r3 = e3;
      ({ showIgnoredFiles: t3 } = r3), e3 = function(e4, t4) {
        if (null == e4) return {};
        var r4, n4, s3 = {}, i4 = Object.keys(e4);
        for (n4 = 0; n4 < i4.length; n4++) r4 = i4[n4], t4.indexOf(r4) >= 0 || (s3[r4] = e4[r4]);
        return s3;
      }(r3, d);
    }
    const n3 = yield* f(e3);
    if (!n3) return null;
    const { options: i3, babelrc: o3, ignore: a3, config: l2, fileHandling: c2, files: u2 } = n3;
    return "ignored" !== c2 || t3 ? ((i3.plugins || []).forEach((e4) => {
      if (e4.value instanceof s2.default) throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
    }), new h(i3, o3 ? o3.filepath : void 0, a3 ? a3.filepath : void 0, l2 ? l2.filepath : void 0, c2, u2)) : null;
  };
  var s2 = r2(135), i2 = r2(134), o2 = r2(83), a2 = r2(292), l = r2(278), c = r2(85), u = r2(81), p = r2(280);
  const d = ["showIgnoredFiles"];
  function* f(e3) {
    if (null != e3 && ("object" != typeof e3 || Array.isArray(e3))) throw new Error("Babel options must be an object, null, or undefined");
    const t3 = e3 ? (0, c.validate)("arguments", e3) : {}, { envName: r3 = (0, l.getEnv)(), cwd: s3 = ".", root: d2 = ".", rootMode: f2 = "root", caller: h2, cloneInputAst: m = true } = t3, y = n2().resolve(s3), g = function(e4, t4) {
      switch (t4) {
        case "root":
          return e4;
        case "upward-optional": {
          const t5 = (0, u.findConfigUpwards)(e4);
          return null === t5 ? e4 : t5;
        }
        case "upward": {
          const t5 = (0, u.findConfigUpwards)(e4);
          if (null !== t5) return t5;
          throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${e4}".
One of the following config files must be in the directory tree: "${u.ROOT_CONFIG_FILENAMES.join(", ")}".`), { code: "BABEL_ROOT_NOT_FOUND", dirname: e4 });
        }
        default:
          throw new Error("Assertion failure - unknown rootMode value.");
      }
    }(n2().resolve(y, d2), f2), b = "string" == typeof t3.filename ? n2().resolve(s3, t3.filename) : void 0, v = { filename: b, cwd: y, root: g, envName: r3, caller: h2, showConfig: (yield* (0, u.resolveShowConfigPath)(y)) === b }, E = yield* (0, a2.buildRootChain)(t3, v);
    if (!E) return null;
    const S = { assumptions: {} };
    return E.options.forEach((e4) => {
      (0, i2.mergeOptions)(S, e4);
    }), { options: Object.assign({}, S, { targets: (0, p.resolveTargets)(S, g), cloneInputAst: m, babelrc: false, configFile: false, browserslistConfigFile: false, passPerPreset: false, envName: v.envName, cwd: v.cwd, root: v.root, rootMode: "root", filename: "string" == typeof v.filename ? v.filename : void 0, plugins: E.plugins.map((e4) => (0, o2.createItemFromDescriptor)(e4)), presets: E.presets.map((e4) => (0, o2.createItemFromDescriptor)(e4)) }), context: v, fileHandling: E.fileHandling, ignore: E.ignore, babelrc: E.babelrc, config: E.config, files: E.files };
  }
  class h {
    constructor(e3, t3, r3, n3, s3, i3) {
      this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files = void 0, this.options = e3, this.babelignore = r3, this.babelrc = t3, this.config = n3, this.fileHandling = s3, this.files = i3, Object.freeze(this);
    }
    hasFilesystemConfig() {
      return void 0 !== this.babelrc || void 0 !== this.config;
    }
  }
  Object.freeze(h.prototype);
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(14);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.run = function* (e3, t3, r3) {
    const p = yield* (0, a2.default)(e3.passes, (0, o2.default)(e3), t3, r3), d = p.opts;
    try {
      yield* function* (e4, t4) {
        for (const r4 of t4) {
          const t5 = [], o3 = [], a3 = [];
          for (const n3 of r4.concat([(0, i2.default)()])) {
            const r5 = new s2.default(e4, n3.key, n3.options);
            t5.push([n3, r5]), o3.push(r5), a3.push(n3.visitor);
          }
          for (const [r5, n3] of t5) {
            const t6 = r5.pre;
            if (t6) {
              const r6 = t6.call(n3, e4);
              if (yield* [], u(r6)) throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
            }
          }
          const l2 = n2().default.visitors.merge(a3, o3, e4.opts.wrapPluginVisitorMethod);
          (0, n2().default)(e4.ast, l2, e4.scope);
          for (const [r5, n3] of t5) {
            const t6 = r5.post;
            if (t6) {
              const r6 = t6.call(n3, e4);
              if (yield* [], u(r6)) throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
            }
          }
        }
      }(p, e3.passes);
    } catch (e4) {
      var f;
      throw e4.message = `${null != (f = d.filename) ? f : "unknown file"}: ${e4.message}`, e4.code || (e4.code = "BABEL_TRANSFORM_ERROR"), e4;
    }
    let h, m;
    try {
      false !== d.code && ({ outputCode: h, outputMap: m } = (0, l.default)(e3.passes, p));
    } catch (e4) {
      var y;
      throw e4.message = `${null != (y = d.filename) ? y : "unknown file"}: ${e4.message}`, e4.code || (e4.code = "BABEL_GENERATE_ERROR"), e4;
    }
    return { metadata: p.metadata, options: d, ast: true === d.ast ? p.ast : null, code: void 0 === h ? null : h, map: void 0 === m ? null : m, sourceType: p.ast.program.sourceType, externalDependencies: (0, c.flattenToSet)(e3.externalDependencies) };
  };
  var s2 = r2(476), i2 = r2(477), o2 = r2(296), a2 = r2(478), l = r2(483), c = r2(136);
  function u(e3) {
    return !(!e3 || "object" != typeof e3 && "function" != typeof e3 || !e3.then || "function" != typeof e3.then);
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(10);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const { filename: t3, cwd: r3, filenameRelative: s2 = "string" == typeof t3 ? n2().relative(r3, t3) : "unknown", sourceType: i2 = "module", inputSourceMap: o2, sourceMaps: a2 = !!o2, sourceRoot: l = e3.options.moduleRoot, sourceFileName: c = n2().basename(s2), comments: u = true, compact: p = "auto" } = e3.options, d = e3.options, f = Object.assign({}, d, { parserOpts: Object.assign({ sourceType: ".mjs" === n2().extname(s2) ? "module" : i2, sourceFileName: t3, plugins: [] }, d.parserOpts), generatorOpts: Object.assign({ filename: t3, auxiliaryCommentBefore: d.auxiliaryCommentBefore, auxiliaryCommentAfter: d.auxiliaryCommentAfter, retainLines: d.retainLines, comments: u, shouldPrintComment: d.shouldPrintComment, compact: p, minified: d.minified, sourceMaps: a2, sourceRoot: l, sourceFileName: c }, d.generatorOpts) });
    for (const t4 of e3.passes) for (const e4 of t4) e4.manipulateOptions && e4.manipulateOptions(f, f.parserOpts);
    return f;
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(21);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2() {
    const e3 = r2(36);
    return s2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    let { parserOpts: o2, highlightCode: a2 = true, filename: l = "unknown" } = t3;
    return function* () {
      try {
        const t4 = [];
        for (const s3 of e3) for (const e4 of s3) {
          const { parserOverride: s4 } = e4;
          if (s4) {
            const e5 = s4(r3, o2, n2().parse);
            void 0 !== e5 && t4.push(e5);
          }
        }
        if (0 === t4.length) return (0, n2().parse)(r3, o2);
        if (1 === t4.length) {
          if (yield* [], "function" == typeof t4[0].then) throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
          return t4[0];
        }
        throw new Error("More than one plugin attempted to override parsing.");
      } catch (e4) {
        "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" === e4.code && (e4.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.");
        const { loc: t4, missingPlugin: n3 } = e4;
        if (t4) {
          const o3 = (0, s2().codeFrameColumns)(r3, { start: { line: t4.line, column: t4.column + 1 } }, { highlightCode: a2 });
          e4.message = n3 ? `${l}: ` + (0, i2.default)(n3[0], t4, o3) : `${l}: ${e4.message}

` + o3, e4.code = "BABEL_PARSE_ERROR";
        }
        throw e4;
      }
    }();
  };
  var i2 = r2(481);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "FEATURES", { enumerable: true, get: function() {
    return p.FEATURES;
  } }), Object.defineProperty(t2, "buildCheckInRHS", { enumerable: true, get: function() {
    return l.buildCheckInRHS;
  } }), t2.createClassFeaturePlugin = function(e3) {
    let { name: t3, feature: r3, loose: h, manipulateOptions: m, api: y, inherits: g, decoratorVersion: b } = e3;
    if (r3 & p.FEATURES.decorators && ("2021-12" === b || "2022-03" === b || "2023-01" === b || "2023-05" === b)) return (0, o2.default)(y, { loose: h }, b, g);
    null != y || (y = { assumption: () => {
    } });
    const v = y.assumption("setPublicClassFields"), E = y.assumption("privateFieldsAsSymbols"), S = y.assumption("privateFieldsAsProperties"), x = y.assumption("constantSuper"), T = y.assumption("noDocumentAll");
    if (S && E) throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');
    const w = S || E;
    if (true === h) {
      const e4 = [];
      void 0 !== v && e4.push('"setPublicClassFields"'), void 0 !== S && e4.push('"privateFieldsAsProperties"'), void 0 !== E && e4.push('"privateFieldsAsSymbols"'), e4.length;
    }
    return { name: t3, manipulateOptions: m, inherits: g, pre(e4) {
      (0, p.enableFeature)(e4, r3, h), "number" != typeof e4.get(f) && e4.get(f) && !a2.lt(e4.get(f), "7.23.7") || e4.set(f, "7.23.7");
    }, visitor: { Class(e4, t4) {
      let { file: i3 } = t4;
      var o3;
      if ("7.23.7" !== i3.get(f)) return;
      if (!(0, p.shouldTransform)(e4, i3)) return;
      const a3 = e4.isClassDeclaration();
      a3 && (0, d.assertFieldTransformed)(e4);
      const h2 = (0, p.isLoose)(i3, r3);
      let m2;
      const y2 = (0, c.hasDecorators)(e4.node), g2 = [], b2 = [], P = [], A = /* @__PURE__ */ new Set(), C = e4.get("body");
      for (const e5 of C.get("body")) {
        if ((e5.isClassProperty() || e5.isClassMethod()) && e5.node.computed && P.push(e5), e5.isPrivate()) {
          const { name: t5 } = e5.node.key.id, r4 = `get ${t5}`, n3 = `set ${t5}`;
          if (e5.isClassPrivateMethod()) {
            if ("get" === e5.node.kind) {
              if (A.has(r4) || A.has(t5) && !A.has(n3)) throw e5.buildCodeFrameError("Duplicate private field");
              A.add(r4).add(t5);
            } else if ("set" === e5.node.kind) {
              if (A.has(n3) || A.has(t5) && !A.has(r4)) throw e5.buildCodeFrameError("Duplicate private field");
              A.add(n3).add(t5);
            }
          } else {
            if (A.has(t5) && !A.has(r4) && !A.has(n3) || A.has(t5) && (A.has(r4) || A.has(n3))) throw e5.buildCodeFrameError("Duplicate private field");
            A.add(t5);
          }
        }
        e5.isClassMethod({ kind: "constructor" }) ? m2 = e5 : (b2.push(e5), (e5.isProperty() || e5.isPrivate() || null != e5.isStaticBlock && e5.isStaticBlock()) && g2.push(e5));
      }
      if (!g2.length && !y2) return;
      const O = e4.node.id;
      let I;
      O && a3 || ((0, s2.default)(e4), I = e4.scope.generateUidIdentifier("class"));
      const _ = null != (o3 = I) ? o3 : n2.types.cloneNode(O), k = (0, l.buildPrivateNamesMap)(g2), N = (0, l.buildPrivateNamesNodes)(k, null != S ? S : h2, null != E && E, i3);
      let D, j, L, M, B, R, F;
      (0, l.transformPrivateNamesUsage)(_, e4, k, { privateFieldsAsProperties: null != w ? w : h2, noDocumentAll: T, innerBinding: O }, i3), y2 ? (j = B = D = [], { instanceNodes: L, wrapClass: F } = (0, c.buildDecoratedClass)(_, e4, b2, i3)) : (D = (0, u.extractComputedKeys)(e4, P, i3), { staticNodes: j, pureStaticNodes: B, instanceNodes: L, lastInstanceNodeReturnsThis: M, classBindingNode: R, wrapClass: F } = (0, l.buildFieldsInitNodes)(I, e4.node.superClass, g2, k, i3, null != v ? v : h2, null != w ? w : h2, null != x ? x : h2, O)), L.length > 0 && (0, u.injectInitialization)(e4, m2, L, (e5, t5) => {
        if (!y2) for (const r4 of g2) null != n2.types.isStaticBlock && n2.types.isStaticBlock(r4.node) || r4.node.static || r4.traverse(e5, t5);
      }, M);
      const U = F(e4);
      U.insertBefore([...N, ...D]), j.length > 0 && U.insertAfter(j), B.length > 0 && U.find((e5) => e5.isStatement() || e5.isDeclaration()).insertAfter(B), null != R && a3 && U.insertAfter(R);
    }, ExportDefaultDeclaration(e4, t4) {
      let { file: r4 } = t4;
      {
        if ("7.23.7" !== r4.get(f)) return;
        const t5 = e4.get("declaration");
        t5.isClassDeclaration() && (0, c.hasDecorators)(t5.node) && (t5.node.id ? (0, i2.default)(e4) : t5.node.type = "ClassExpression");
      }
    } } };
  }, Object.defineProperty(t2, "enableFeature", { enumerable: true, get: function() {
    return p.enableFeature;
  } }), Object.defineProperty(t2, "injectInitialization", { enumerable: true, get: function() {
    return u.injectInitialization;
  } });
  var n2 = r2(1), s2 = r2(119), i2 = r2(62), o2 = r2(496), a2 = r2(23), l = r2(497), c = r2(304), u = r2(498), p = r2(499), d = r2(303);
  const f = "@babel/plugin-class-features/version";
}, (e2, t2, r2) => {
  function n2(e3) {
    if (e3 && e3.__esModule) return e3;
    var t3 = /* @__PURE__ */ Object.create(null);
    return e3 && Object.keys(e3).forEach(function(r3) {
      if ("default" !== r3) {
        var n3 = Object.getOwnPropertyDescriptor(e3, r3);
        Object.defineProperty(t3, r3, n3.get ? n3 : { enumerable: true, get: function() {
          return e3[r3];
        } });
      }
    }), t3.default = e3, Object.freeze(t3);
  }
  Object.defineProperty(t2, "__esModule", { value: true });
  var s2 = n2(r2(0));
  function i2(e3) {
    const t3 = e3, { node: r3, parentPath: n3 } = t3;
    if (n3.isLogicalExpression()) {
      const { operator: e4, right: t4 } = n3.node;
      if ("&&" === e4 || "||" === e4 || "??" === e4 && r3 === t4) return i2(n3);
    }
    if (n3.isSequenceExpression()) {
      const { expressions: e4 } = n3.node;
      return e4[e4.length - 1] !== r3 || i2(n3);
    }
    return n3.isConditional({ test: r3 }) || n3.isUnaryExpression({ operator: "!" }) || n3.isLoop({ test: r3 });
  }
  const { LOGICAL_OPERATORS: o2, arrowFunctionExpression: a2, assignmentExpression: l, binaryExpression: c, booleanLiteral: u, callExpression: p, cloneNode: d, conditionalExpression: f, identifier: h, isMemberExpression: m, isOptionalCallExpression: y, isOptionalMemberExpression: g, isUpdateExpression: b, logicalExpression: v, memberExpression: E, nullLiteral: S, optionalCallExpression: x, optionalMemberExpression: T, sequenceExpression: w, updateExpression: P } = s2;
  class A {
    constructor() {
      this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
    }
    has(e3) {
      return this._map.has(e3);
    }
    get(e3) {
      if (!this.has(e3)) return;
      const t3 = this._map.get(e3), { value: r3 } = t3;
      return t3.count--, 0 === t3.count ? l("=", r3, e3) : r3;
    }
    set(e3, t3, r3) {
      return this._map.set(e3, { count: r3, value: t3 });
    }
  }
  function C(e3, t3) {
    const { node: r3 } = e3;
    if (g(r3)) return E(t3, r3.property, r3.computed);
    if (e3.isOptionalCallExpression()) {
      const r4 = e3.get("callee");
      if (e3.node.optional && r4.isOptionalMemberExpression()) {
        const n3 = r4.node.object, s3 = e3.scope.maybeGenerateMemoised(n3);
        return r4.get("object").replaceWith(l("=", s3, n3)), p(E(t3, h("call")), [s3, ...e3.node.arguments]);
      }
      return p(t3, e3.node.arguments);
    }
    return e3.node;
  }
  const O = { memoise() {
  }, handle(e3, t3) {
    const { node: r3, parent: n3, parentPath: s3, scope: o3 } = e3;
    if (e3.isOptionalMemberExpression()) {
      if (function(e4) {
        for (; e4 && !e4.isProgram(); ) {
          const { parentPath: t4, container: r4, listKey: n4 } = e4, s4 = t4.node;
          if (n4) {
            if (r4 !== s4[n4]) return true;
          } else if (r4 !== s4) return true;
          e4 = t4;
        }
        return false;
      }(e3)) return;
      const b2 = e3.find((t4) => {
        let { node: r4, parent: n4 } = t4;
        return g(n4) ? n4.optional || n4.object !== r4 : !y(n4) || r4 !== e3.node && n4.optional || n4.callee !== r4;
      });
      if (o3.path.isPattern()) return void b2.replaceWith(p(a2([], b2.node), []));
      const E2 = i2(b2), w2 = b2.parentPath;
      if (w2.isUpdateExpression({ argument: r3 })) throw e3.buildCodeFrameError("can't handle update expression");
      const P2 = w2.isAssignmentExpression({ left: b2.node }), A2 = w2.isUnaryExpression({ operator: "delete" });
      if (A2 && b2.isOptionalMemberExpression() && b2.get("property").isPrivateName()) throw e3.buildCodeFrameError("can't delete a private class element");
      let O2 = e3;
      for (; ; ) if (O2.isOptionalMemberExpression()) {
        if (O2.node.optional) break;
        O2 = O2.get("object");
      } else {
        if (!O2.isOptionalCallExpression()) throw new Error(`Internal error: unexpected ${O2.node.type}`);
        if (O2.node.optional) break;
        O2 = O2.get("callee");
      }
      const _ = O2.isOptionalMemberExpression() ? O2.node.object : O2.node.callee, k = o3.maybeGenerateMemoised(_), N = null != k ? k : _, D = s3.isOptionalCallExpression({ callee: r3 }), j = (e4) => D, L = s3.isCallExpression({ callee: r3 });
      O2.replaceWith(C(O2, N)), j() ? n3.optional ? s3.replaceWith(this.optionalCall(e3, n3.arguments)) : s3.replaceWith(this.call(e3, n3.arguments)) : L ? e3.replaceWith(this.boundGet(e3)) : this.delete && s3.isUnaryExpression({ operator: "delete" }) ? s3.replaceWith(this.delete(e3)) : s3.isAssignmentExpression() ? I(this, e3, s3) : e3.replaceWith(this.get(e3));
      let M, B = e3.node;
      for (let t4 = e3; t4 !== b2; ) {
        const e4 = t4.parentPath;
        if (e4 === b2 && j() && n3.optional) {
          B = e4.node;
          break;
        }
        B = C(e4, B), t4 = e4;
      }
      const R = b2.parentPath;
      if (m(B) && R.isOptionalCallExpression({ callee: b2.node, optional: true })) {
        const { object: t4 } = B;
        M = e3.scope.maybeGenerateMemoised(t4), M && (B.object = l("=", M, t4));
      }
      let F = b2;
      (A2 || P2) && (F = R, B = R.node);
      const U = k ? l("=", d(N), d(_)) : d(N);
      if (E2) {
        let e4;
        e4 = t3 ? c("!=", U, S()) : v("&&", c("!==", U, S()), c("!==", d(N), o3.buildUndefinedNode())), F.replaceWith(v("&&", e4, B));
      } else {
        let e4;
        e4 = t3 ? c("==", U, S()) : v("||", c("===", U, S()), c("===", d(N), o3.buildUndefinedNode())), F.replaceWith(f(e4, A2 ? u(true) : o3.buildUndefinedNode(), B));
      }
      if (M) {
        const e4 = R.node;
        R.replaceWith(x(T(e4.callee, h("call"), false, true), [d(M), ...e4.arguments], false));
      }
    } else {
      if (b(n3, { argument: r3 })) {
        if (this.simpleSet) return void e3.replaceWith(this.simpleSet(e3));
        const { operator: t4, prefix: i3 } = n3;
        this.memoise(e3, 2);
        const a3 = o3.generateUidIdentifierBasedOnNode(r3);
        o3.push({ id: a3 });
        const c2 = [l("=", d(a3), this.get(e3))];
        if (i3) {
          c2.push(P(t4, d(a3), i3));
          const r4 = w(c2);
          return void s3.replaceWith(this.set(e3, r4));
        }
        {
          const n4 = o3.generateUidIdentifierBasedOnNode(r3);
          o3.push({ id: n4 }), c2.push(l("=", d(n4), P(t4, d(a3), i3)), d(a3));
          const u2 = w(c2);
          return void s3.replaceWith(w([this.set(e3, u2), d(n4)]));
        }
      }
      if (s3.isAssignmentExpression({ left: r3 })) I(this, e3, s3);
      else {
        if (!s3.isCallExpression({ callee: r3 })) return s3.isOptionalCallExpression({ callee: r3 }) ? o3.path.isPattern() ? void s3.replaceWith(p(a2([], s3.node), [])) : void s3.replaceWith(this.optionalCall(e3, s3.node.arguments)) : void (this.delete && s3.isUnaryExpression({ operator: "delete" }) ? s3.replaceWith(this.delete(e3)) : s3.isForXStatement({ left: r3 }) || s3.isObjectProperty({ value: r3 }) && s3.parentPath.isObjectPattern() || s3.isAssignmentPattern({ left: r3 }) && s3.parentPath.isObjectProperty({ value: n3 }) && s3.parentPath.parentPath.isObjectPattern() || s3.isArrayPattern() || s3.isAssignmentPattern({ left: r3 }) && s3.parentPath.isArrayPattern() || s3.isRestElement() ? e3.replaceWith(this.destructureSet(e3)) : s3.isTaggedTemplateExpression() ? e3.replaceWith(this.boundGet(e3)) : e3.replaceWith(this.get(e3)));
        s3.replaceWith(this.call(e3, s3.node.arguments));
      }
    }
  } };
  function I(e3, t3, r3) {
    if (e3.simpleSet) return void t3.replaceWith(e3.simpleSet(t3));
    const { operator: n3, right: s3 } = r3.node;
    if ("=" === n3) r3.replaceWith(e3.set(t3, s3));
    else {
      const i3 = n3.slice(0, -1);
      o2.includes(i3) ? (e3.memoise(t3, 1), r3.replaceWith(v(i3, e3.get(t3), e3.set(t3, s3)))) : (e3.memoise(t3, 2), r3.replaceWith(e3.set(t3, c(i3, e3.get(t3), s3))));
    }
  }
  t2.default = function(e3, t3, r3) {
    e3.traverse(t3, Object.assign({}, O, r3, { memoiser: new A() }));
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, n3) {
    return 1 === r3.length && a2(r3[0]) && o2(r3[0].argument, { name: "arguments" }) ? n3 ? c(u(e3, i2("apply"), false, true), [t3, r3[0].argument], false) : s2(l(e3, i2("apply")), [t3, r3[0].argument]) : n3 ? c(u(e3, i2("call"), false, true), [t3, ...r3], false) : s2(l(e3, i2("call")), [t3, ...r3]);
  };
  var n2 = r2(0);
  const { callExpression: s2, identifier: i2, isIdentifier: o2, isSpreadElement: a2, memberExpression: l, optionalCallExpression: c, optionalMemberExpression: u } = n2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isTransparentExprWrapper = u, t2.skipTransparentExprWrapperNodes = function(e3) {
    for (; u(e3); ) e3 = e3.expression;
    return e3;
  }, t2.skipTransparentExprWrappers = function(e3) {
    for (; u(e3.node); ) e3 = e3.get("expression");
    return e3;
  };
  var n2 = r2(0);
  const { isParenthesizedExpression: s2, isTSAsExpression: i2, isTSNonNullExpression: o2, isTSSatisfiesExpression: a2, isTSTypeAssertion: l, isTypeCastExpression: c } = n2;
  function u(e3) {
    return i2(e3) || a2(e3) || l(e3) || o2(e3) || c(e3) || s2(e3);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const t3 = e3.node || e3;
    o2(t3) || s2(t3, "leading", i2);
  };
  var n2 = r2(0);
  const { addComment: s2 } = n2, i2 = "#__PURE__", o2 = (e3) => {
    let { leadingComments: t3 } = e3;
    return !!t3 && t3.some((e4) => /[@#]__PURE__/.test(e4.value));
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.assertFieldTransformed = function(e3) {
    if (e3.node.declare) throw e3.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-transform-class-properties\n - @babel/plugin-transform-private-methods\n - @babel/plugin-proposal-decorators");
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.buildDecoratedClass = function(e3, t3, r3, o3) {
    const { node: u, scope: p } = t3, d = p.generateUidIdentifier("initialize"), f = u.id && t3.isDeclaration(), h = t3.isInStrictMode(), { superClass: m } = u;
    let y;
    u.type = "ClassDeclaration", u.id || (u.id = n2.types.cloneNode(e3)), m && (y = p.generateUidIdentifierBasedOnNode(u.superClass, "super"), u.superClass = y);
    const g = l(u), b = n2.types.arrayExpression(r3.filter((e4) => !e4.node.abstract && "TSIndexSignature" !== e4.node.type).map((e4) => function(e5, t4, r4, o4) {
      const u2 = o4.isClassMethod();
      if (o4.isPrivate()) throw o4.buildCodeFrameError(`Private ${u2 ? "methods" : "fields"} in decorated classes are not supported yet.`);
      if ("ClassAccessorProperty" === o4.node.type) throw o4.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
      if ("StaticBlock" === o4.node.type) throw o4.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
      const { node: p2, scope: d2 } = o4;
      o4.isTSDeclareMethod() || new s2.default({ methodPath: o4, objectRef: t4, superRef: r4, file: e5, refToPreserve: t4 }).replace();
      const f2 = [a2("kind", n2.types.stringLiteral(n2.types.isClassMethod(p2) ? p2.kind : "field")), a2("decorators", l(p2)), a2("static", p2.static && n2.types.booleanLiteral(true)), a2("key", c(p2))].filter(Boolean);
      if (n2.types.isClassMethod(p2)) {
        const e6 = p2.computed ? null : p2.key, t5 = n2.types.toExpression(p2);
        f2.push(a2("value", (0, i2.default)({ node: t5, id: e6, scope: d2 }) || t5));
      } else n2.types.isClassProperty(p2) && p2.value ? f2.push(("value", h2 = n2.template.statements.ast`return ${p2.value}`, n2.types.objectMethod("method", n2.types.identifier("value"), [], n2.types.blockStatement(h2)))) : f2.push(a2("value", d2.buildUndefinedNode()));
      var h2;
      return o4.remove(), n2.types.objectExpression(f2);
    }(o3, u.id, y, e4))), v = n2.template.expression.ast`
    ${function(e4) {
      return e4.addHelper("decorate");
    }(o3)}(
      ${g || n2.types.nullLiteral()},
      function (${d}, ${m ? n2.types.cloneNode(y) : null}) {
        ${u}
        return { F: ${n2.types.cloneNode(u.id)}, d: ${b} };
      },
      ${m}
    )
  `;
    h || v.arguments[1].body.directives.push(n2.types.directive(n2.types.directiveLiteral("use strict")));
    let E = v, S = "arguments.1.body.body.0";
    return f && (E = n2.template.statement.ast`let ${e3} = ${v}`, S = "declarations.0.init." + S), { instanceNodes: [n2.template.statement.ast`
        ${n2.types.cloneNode(d)}(this)
      `], wrapClass: (e4) => (e4.replaceWith(E), e4.get(S)) };
  }, t2.hasDecorators = function(e3) {
    return o2(e3) || e3.body.body.some(o2);
  }, t2.hasOwnDecorators = o2;
  var n2 = r2(1), s2 = r2(141), i2 = r2(119);
  function o2(e3) {
    var t3;
    return !(null == (t3 = e3.decorators) || !t3.length);
  }
  function a2(e3, t3) {
    return t3 ? n2.types.objectProperty(n2.types.identifier(e3), t3) : null;
  }
  function l(e3) {
    let t3;
    return e3.decorators && e3.decorators.length > 0 && (t3 = n2.types.arrayExpression(e3.decorators.map((e4) => e4.expression))), e3.decorators = void 0, t3;
  }
  function c(e3) {
    return e3.computed ? e3.key : n2.types.isIdentifier(e3.key) ? n2.types.stringLiteral(e3.key.name) : n2.types.stringLiteral(String(e3.key.value));
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const { node: r3, parentPath: n3 } = e3;
    if (r3.declare) return void e3.remove();
    const s3 = r3.id.name, { fill: l2, data: c2, isPure: p2 } = function(e4, t4, r4) {
      const { enumValues: n4, data: s4, isPure: i3 } = f(e4, t4), o3 = n4.map((e5) => {
        let [n5, s5] = e5;
        return u(t4.isStringLiteral(s5), { ENUM: t4.cloneNode(r4), NAME: n5, VALUE: s5 });
      });
      return { fill: { ID: t4.cloneNode(r4), ASSIGNMENTS: o3 }, data: s4, isPure: i3 };
    }(e3, t3, r3.id);
    switch (n3.type) {
      case "BlockStatement":
      case "ExportNamedDeclaration":
      case "Program": {
        const u2 = t3.isProgram(e3.parent), d2 = function e4(t4) {
          return t4.isExportDeclaration() ? e4(t4.parentPath) : !!t4.getData(s3) || (t4.setData(s3, true), false);
        }(n3);
        let f2 = t3.objectExpression([]);
        (d2 || u2) && (f2 = t3.logicalExpression("||", t3.cloneNode(l2.ID), f2));
        const h2 = a2(Object.assign({}, l2, { INIT: f2 }));
        p2 && (0, i2.default)(h2), d2 ? (n3.isExportDeclaration() ? n3 : e3).replaceWith(t3.expressionStatement(t3.assignmentExpression("=", t3.cloneNode(r3.id), h2))) : e3.scope.registerDeclaration(e3.replaceWith(t3.variableDeclaration(u2 ? "var" : "let", [t3.variableDeclarator(r3.id, h2)]))[0]), o2.set(e3.scope.getBindingIdentifier(s3), c2);
        break;
      }
      default:
        throw new Error(`Unexpected enum parent '${e3.parent.type}`);
    }
  }, t2.translateEnumValues = f;
  var n2 = r2(1), s2 = r2(25), i2 = r2(302);
  const o2 = /* @__PURE__ */ new WeakMap(), a2 = n2.template.expression("\n    (function (ID) {\n      ASSIGNMENTS;\n      return ID;\n    })(INIT)\n  "), l = (0, n2.template)('\n  ENUM["NAME"] = VALUE;\n'), c = (0, n2.template)('\n  ENUM[ENUM["NAME"] = VALUE] = "NAME";\n'), u = (e3, t3) => (e3 ? l : c)(t3);
  function p(e3, t3) {
    const { seen: r3, path: n3, t: s3 } = t3, i3 = e3.node.name;
    r3.has(i3) && !e3.scope.hasOwnBinding(i3) && (e3.replaceWith(s3.memberExpression(s3.cloneNode(n3.node.id), s3.cloneNode(e3.node))), e3.skip());
  }
  const d = { ReferencedIdentifier: p };
  function f(e3, t3) {
    var r3;
    const n3 = e3.scope.getBindingIdentifier(e3.node.id.name), i3 = null != (r3 = o2.get(n3)) ? r3 : /* @__PURE__ */ new Map();
    let a3, l2 = -1, c2 = true;
    const u2 = e3.get("members").map((r4) => {
      const n4 = r4.node, o3 = t3.isIdentifier(n4.id) ? n4.id.name : n4.id.value, u3 = r4.get("initializer");
      let f2;
      if (n4.initializer) l2 = h(u3, i3), void 0 !== l2 ? (i3.set(o3, l2), s2("number" == typeof l2 || "string" == typeof l2), f2 = l2 === 1 / 0 || Number.isNaN(l2) ? t3.identifier(String(l2)) : l2 === -1 / 0 ? t3.unaryExpression("-", t3.identifier("Infinity")) : t3.valueToNode(l2)) : (c2 && (c2 = u3.isPure()), u3.isReferencedIdentifier() ? p(u3, { t: t3, seen: i3, path: e3 }) : u3.traverse(d, { t: t3, seen: i3, path: e3 }), f2 = u3.node, i3.set(o3, void 0));
      else if ("number" == typeof l2) l2 += 1, f2 = t3.numericLiteral(l2), i3.set(o3, l2);
      else {
        if ("string" == typeof l2) throw e3.buildCodeFrameError("Enum member must have initializer.");
        {
          const r5 = t3.memberExpression(t3.cloneNode(e3.node.id), t3.stringLiteral(a3), true);
          f2 = t3.binaryExpression("+", t3.numericLiteral(1), r5), i3.set(o3, void 0);
        }
      }
      return a3 = o3, [o3, f2];
    });
    return { isPure: c2, data: i3, enumValues: u2 };
  }
  function h(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : /* @__PURE__ */ new Set();
    return function e4(n3) {
      const i3 = n3.node;
      switch (i3.type) {
        case "MemberExpression":
        case "Identifier":
          return s3(n3, t3, r3);
        case "StringLiteral":
        case "NumericLiteral":
          return i3.value;
        case "UnaryExpression":
          return function(t4) {
            const r4 = e4(t4.get("argument"));
            if (void 0 !== r4) switch (t4.node.operator) {
              case "+":
                return r4;
              case "-":
                return -r4;
              case "~":
                return ~r4;
              default:
                return;
            }
          }(n3);
        case "BinaryExpression":
          return function(t4) {
            const r4 = e4(t4.get("left"));
            if (void 0 === r4) return;
            const n4 = e4(t4.get("right"));
            if (void 0 !== n4) switch (t4.node.operator) {
              case "|":
                return r4 | n4;
              case "&":
                return r4 & n4;
              case ">>":
                return r4 >> n4;
              case ">>>":
                return r4 >>> n4;
              case "<<":
                return r4 << n4;
              case "^":
                return r4 ^ n4;
              case "*":
                return r4 * n4;
              case "/":
                return r4 / n4;
              case "+":
                return r4 + n4;
              case "-":
                return r4 - n4;
              case "%":
                return r4 % n4;
              case "**":
                return Math.pow(r4, n4);
              default:
                return;
            }
          }(n3);
        case "ParenthesizedExpression":
          return e4(n3.get("expression"));
        case "TemplateLiteral": {
          if (1 === i3.quasis.length) return i3.quasis[0].value.cooked;
          const e5 = n3.get("expressions"), o3 = i3.quasis;
          let a3 = "";
          for (let n4 = 0; n4 < o3.length; n4++) if (a3 += o3[n4].value.cooked, n4 + 1 < o3.length) {
            const i4 = s3(e5[n4], t3, r3);
            if (void 0 === i4) return;
            a3 += i4;
          }
          return a3;
        }
        default:
          return;
      }
    }(e3);
    function s3(e4, t4, r4) {
      if (e4.isMemberExpression()) {
        const t5 = e4.node, r5 = t5.object, s4 = t5.property;
        if (!n2.types.isIdentifier(r5) || (t5.computed ? !n2.types.isStringLiteral(s4) : !n2.types.isIdentifier(s4))) return;
        const i3 = e4.scope.getBindingIdentifier(r5.name), a3 = o2.get(i3);
        if (!a3) return;
        return a3.get(s4.computed ? s4.value : s4.name);
      }
      if (e4.isIdentifier()) {
        const n3 = e4.node.name;
        if (["Infinity", "NaN"].includes(n3)) return Number(n3);
        let s4 = null == t4 ? void 0 : t4.get(n3);
        if (void 0 !== s4) return s4;
        if (r4.has(e4.node)) return;
        return r4.add(e4.node), s4 = h(e4.resolve(), t4, r4), null == t4 || t4.set(n3, s4), s4;
      }
    }
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.GLOBAL_TYPES = void 0, t2.isGlobalType = function(e3, t3) {
    let { scope: n2 } = e3;
    return !n2.hasBinding(t3) && !!r2.get(n2).has(t3);
  }, t2.registerGlobalType = function(e3, t3) {
    r2.get(e3).add(t3);
  };
  const r2 = t2.GLOBAL_TYPES = /* @__PURE__ */ new WeakMap();
}, (e2, t2, r2) => {
  r2(12), e2.exports = function(e3) {
    var t3 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function r3(e4, t4) {
      var r4 = e4[0], n3 = e4[1], s3 = e4[2], i3 = e4[3];
      n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & s3 | ~n3 & i3) + t4[0] - 680876936 | 0) << 7 | r4 >>> 25) + n3 | 0) & n3 | ~r4 & s3) + t4[1] - 389564586 | 0) << 12 | i3 >>> 20) + r4 | 0) & r4 | ~i3 & n3) + t4[2] + 606105819 | 0) << 17 | s3 >>> 15) + i3 | 0) & i3 | ~s3 & r4) + t4[3] - 1044525330 | 0) << 22 | n3 >>> 10) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & s3 | ~n3 & i3) + t4[4] - 176418897 | 0) << 7 | r4 >>> 25) + n3 | 0) & n3 | ~r4 & s3) + t4[5] + 1200080426 | 0) << 12 | i3 >>> 20) + r4 | 0) & r4 | ~i3 & n3) + t4[6] - 1473231341 | 0) << 17 | s3 >>> 15) + i3 | 0) & i3 | ~s3 & r4) + t4[7] - 45705983 | 0) << 22 | n3 >>> 10) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & s3 | ~n3 & i3) + t4[8] + 1770035416 | 0) << 7 | r4 >>> 25) + n3 | 0) & n3 | ~r4 & s3) + t4[9] - 1958414417 | 0) << 12 | i3 >>> 20) + r4 | 0) & r4 | ~i3 & n3) + t4[10] - 42063 | 0) << 17 | s3 >>> 15) + i3 | 0) & i3 | ~s3 & r4) + t4[11] - 1990404162 | 0) << 22 | n3 >>> 10) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & s3 | ~n3 & i3) + t4[12] + 1804603682 | 0) << 7 | r4 >>> 25) + n3 | 0) & n3 | ~r4 & s3) + t4[13] - 40341101 | 0) << 12 | i3 >>> 20) + r4 | 0) & r4 | ~i3 & n3) + t4[14] - 1502002290 | 0) << 17 | s3 >>> 15) + i3 | 0) & i3 | ~s3 & r4) + t4[15] + 1236535329 | 0) << 22 | n3 >>> 10) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & i3 | s3 & ~i3) + t4[1] - 165796510 | 0) << 5 | r4 >>> 27) + n3 | 0) & s3 | n3 & ~s3) + t4[6] - 1069501632 | 0) << 9 | i3 >>> 23) + r4 | 0) & n3 | r4 & ~n3) + t4[11] + 643717713 | 0) << 14 | s3 >>> 18) + i3 | 0) & r4 | i3 & ~r4) + t4[0] - 373897302 | 0) << 20 | n3 >>> 12) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & i3 | s3 & ~i3) + t4[5] - 701558691 | 0) << 5 | r4 >>> 27) + n3 | 0) & s3 | n3 & ~s3) + t4[10] + 38016083 | 0) << 9 | i3 >>> 23) + r4 | 0) & n3 | r4 & ~n3) + t4[15] - 660478335 | 0) << 14 | s3 >>> 18) + i3 | 0) & r4 | i3 & ~r4) + t4[4] - 405537848 | 0) << 20 | n3 >>> 12) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & i3 | s3 & ~i3) + t4[9] + 568446438 | 0) << 5 | r4 >>> 27) + n3 | 0) & s3 | n3 & ~s3) + t4[14] - 1019803690 | 0) << 9 | i3 >>> 23) + r4 | 0) & n3 | r4 & ~n3) + t4[3] - 187363961 | 0) << 14 | s3 >>> 18) + i3 | 0) & r4 | i3 & ~r4) + t4[8] + 1163531501 | 0) << 20 | n3 >>> 12) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 & i3 | s3 & ~i3) + t4[13] - 1444681467 | 0) << 5 | r4 >>> 27) + n3 | 0) & s3 | n3 & ~s3) + t4[2] - 51403784 | 0) << 9 | i3 >>> 23) + r4 | 0) & n3 | r4 & ~n3) + t4[7] + 1735328473 | 0) << 14 | s3 >>> 18) + i3 | 0) & r4 | i3 & ~r4) + t4[12] - 1926607734 | 0) << 20 | n3 >>> 12) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 ^ s3 ^ i3) + t4[5] - 378558 | 0) << 4 | r4 >>> 28) + n3 | 0) ^ n3 ^ s3) + t4[8] - 2022574463 | 0) << 11 | i3 >>> 21) + r4 | 0) ^ r4 ^ n3) + t4[11] + 1839030562 | 0) << 16 | s3 >>> 16) + i3 | 0) ^ i3 ^ r4) + t4[14] - 35309556 | 0) << 23 | n3 >>> 9) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 ^ s3 ^ i3) + t4[1] - 1530992060 | 0) << 4 | r4 >>> 28) + n3 | 0) ^ n3 ^ s3) + t4[4] + 1272893353 | 0) << 11 | i3 >>> 21) + r4 | 0) ^ r4 ^ n3) + t4[7] - 155497632 | 0) << 16 | s3 >>> 16) + i3 | 0) ^ i3 ^ r4) + t4[10] - 1094730640 | 0) << 23 | n3 >>> 9) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 ^ s3 ^ i3) + t4[13] + 681279174 | 0) << 4 | r4 >>> 28) + n3 | 0) ^ n3 ^ s3) + t4[0] - 358537222 | 0) << 11 | i3 >>> 21) + r4 | 0) ^ r4 ^ n3) + t4[3] - 722521979 | 0) << 16 | s3 >>> 16) + i3 | 0) ^ i3 ^ r4) + t4[6] + 76029189 | 0) << 23 | n3 >>> 9) + s3 | 0, n3 = ((n3 += ((s3 = ((s3 += ((i3 = ((i3 += ((r4 = ((r4 += (n3 ^ s3 ^ i3) + t4[9] - 640364487 | 0) << 4 | r4 >>> 28) + n3 | 0) ^ n3 ^ s3) + t4[12] - 421815835 | 0) << 11 | i3 >>> 21) + r4 | 0) ^ r4 ^ n3) + t4[15] + 530742520 | 0) << 16 | s3 >>> 16) + i3 | 0) ^ i3 ^ r4) + t4[2] - 995338651 | 0) << 23 | n3 >>> 9) + s3 | 0, n3 = ((n3 += ((i3 = ((i3 += (n3 ^ ((r4 = ((r4 += (s3 ^ (n3 | ~i3)) + t4[0] - 198630844 | 0) << 6 | r4 >>> 26) + n3 | 0) | ~s3)) + t4[7] + 1126891415 | 0) << 10 | i3 >>> 22) + r4 | 0) ^ ((s3 = ((s3 += (r4 ^ (i3 | ~n3)) + t4[14] - 1416354905 | 0) << 15 | s3 >>> 17) + i3 | 0) | ~r4)) + t4[5] - 57434055 | 0) << 21 | n3 >>> 11) + s3 | 0, n3 = ((n3 += ((i3 = ((i3 += (n3 ^ ((r4 = ((r4 += (s3 ^ (n3 | ~i3)) + t4[12] + 1700485571 | 0) << 6 | r4 >>> 26) + n3 | 0) | ~s3)) + t4[3] - 1894986606 | 0) << 10 | i3 >>> 22) + r4 | 0) ^ ((s3 = ((s3 += (r4 ^ (i3 | ~n3)) + t4[10] - 1051523 | 0) << 15 | s3 >>> 17) + i3 | 0) | ~r4)) + t4[1] - 2054922799 | 0) << 21 | n3 >>> 11) + s3 | 0, n3 = ((n3 += ((i3 = ((i3 += (n3 ^ ((r4 = ((r4 += (s3 ^ (n3 | ~i3)) + t4[8] + 1873313359 | 0) << 6 | r4 >>> 26) + n3 | 0) | ~s3)) + t4[15] - 30611744 | 0) << 10 | i3 >>> 22) + r4 | 0) ^ ((s3 = ((s3 += (r4 ^ (i3 | ~n3)) + t4[6] - 1560198380 | 0) << 15 | s3 >>> 17) + i3 | 0) | ~r4)) + t4[13] + 1309151649 | 0) << 21 | n3 >>> 11) + s3 | 0, n3 = ((n3 += ((i3 = ((i3 += (n3 ^ ((r4 = ((r4 += (s3 ^ (n3 | ~i3)) + t4[4] - 145523070 | 0) << 6 | r4 >>> 26) + n3 | 0) | ~s3)) + t4[11] - 1120210379 | 0) << 10 | i3 >>> 22) + r4 | 0) ^ ((s3 = ((s3 += (r4 ^ (i3 | ~n3)) + t4[2] + 718787259 | 0) << 15 | s3 >>> 17) + i3 | 0) | ~r4)) + t4[9] - 343485551 | 0) << 21 | n3 >>> 11) + s3 | 0, e4[0] = r4 + e4[0] | 0, e4[1] = n3 + e4[1] | 0, e4[2] = s3 + e4[2] | 0, e4[3] = i3 + e4[3] | 0;
    }
    function n2(e4) {
      var t4, r4 = [];
      for (t4 = 0; t4 < 64; t4 += 4) r4[t4 >> 2] = e4.charCodeAt(t4) + (e4.charCodeAt(t4 + 1) << 8) + (e4.charCodeAt(t4 + 2) << 16) + (e4.charCodeAt(t4 + 3) << 24);
      return r4;
    }
    function s2(e4) {
      var t4, r4 = [];
      for (t4 = 0; t4 < 64; t4 += 4) r4[t4 >> 2] = e4[t4] + (e4[t4 + 1] << 8) + (e4[t4 + 2] << 16) + (e4[t4 + 3] << 24);
      return r4;
    }
    function i2(e4) {
      var t4, s3, i3, o3, a3, l2, c2 = e4.length, u2 = [1732584193, -271733879, -1732584194, 271733878];
      for (t4 = 64; t4 <= c2; t4 += 64) r3(u2, n2(e4.substring(t4 - 64, t4)));
      for (s3 = (e4 = e4.substring(t4 - 64)).length, i3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], t4 = 0; t4 < s3; t4 += 1) i3[t4 >> 2] |= e4.charCodeAt(t4) << (t4 % 4 << 3);
      if (i3[t4 >> 2] |= 128 << (t4 % 4 << 3), t4 > 55) for (r3(u2, i3), t4 = 0; t4 < 16; t4 += 1) i3[t4] = 0;
      return o3 = (o3 = 8 * c2).toString(16).match(/(.*?)(.{0,8})$/), a3 = parseInt(o3[2], 16), l2 = parseInt(o3[1], 16) || 0, i3[14] = a3, i3[15] = l2, r3(u2, i3), u2;
    }
    function o2(e4) {
      var r4, n3 = "";
      for (r4 = 0; r4 < 4; r4 += 1) n3 += t3[e4 >> 8 * r4 + 4 & 15] + t3[e4 >> 8 * r4 & 15];
      return n3;
    }
    function a2(e4) {
      var t4;
      for (t4 = 0; t4 < e4.length; t4 += 1) e4[t4] = o2(e4[t4]);
      return e4.join("");
    }
    function l(e4) {
      return /[\u0080-\uFFFF]/.test(e4) && (e4 = unescape(encodeURIComponent(e4))), e4;
    }
    function c(e4) {
      var t4, r4 = [], n3 = e4.length;
      for (t4 = 0; t4 < n3 - 1; t4 += 2) r4.push(parseInt(e4.substr(t4, 2), 16));
      return String.fromCharCode.apply(String, r4);
    }
    function u() {
      this.reset();
    }
    return a2(i2("hello")), "undefined" == typeof ArrayBuffer || ArrayBuffer.prototype.slice || function() {
      function e4(e5, t4) {
        return (e5 = 0 | e5 || 0) < 0 ? Math.max(e5 + t4, 0) : Math.min(e5, t4);
      }
      ArrayBuffer.prototype.slice = function(t4, r4) {
        var n3, s3, i3, o3, a3 = this.byteLength, l2 = e4(t4, a3), c2 = a3;
        return void 0 !== r4 && (c2 = e4(r4, a3)), l2 > c2 ? new ArrayBuffer(0) : (n3 = c2 - l2, s3 = new ArrayBuffer(n3), i3 = new Uint8Array(s3), o3 = new Uint8Array(this, l2, n3), i3.set(o3), s3);
      };
    }(), u.prototype.append = function(e4) {
      return this.appendBinary(l(e4)), this;
    }, u.prototype.appendBinary = function(e4) {
      this._buff += e4, this._length += e4.length;
      var t4, s3 = this._buff.length;
      for (t4 = 64; t4 <= s3; t4 += 64) r3(this._hash, n2(this._buff.substring(t4 - 64, t4)));
      return this._buff = this._buff.substring(t4 - 64), this;
    }, u.prototype.end = function(e4) {
      var t4, r4, n3 = this._buff, s3 = n3.length, i3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (t4 = 0; t4 < s3; t4 += 1) i3[t4 >> 2] |= n3.charCodeAt(t4) << (t4 % 4 << 3);
      return this._finish(i3, s3), r4 = a2(this._hash), e4 && (r4 = c(r4)), this.reset(), r4;
    }, u.prototype.reset = function() {
      return this._buff = "", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, u.prototype.getState = function() {
      return { buff: this._buff, length: this._length, hash: this._hash.slice() };
    }, u.prototype.setState = function(e4) {
      return this._buff = e4.buff, this._length = e4.length, this._hash = e4.hash, this;
    }, u.prototype.destroy = function() {
      delete this._hash, delete this._buff, delete this._length;
    }, u.prototype._finish = function(e4, t4) {
      var n3, s3, i3, o3 = t4;
      if (e4[o3 >> 2] |= 128 << (o3 % 4 << 3), o3 > 55) for (r3(this._hash, e4), o3 = 0; o3 < 16; o3 += 1) e4[o3] = 0;
      n3 = (n3 = 8 * this._length).toString(16).match(/(.*?)(.{0,8})$/), s3 = parseInt(n3[2], 16), i3 = parseInt(n3[1], 16) || 0, e4[14] = s3, e4[15] = i3, r3(this._hash, e4);
    }, u.hash = function(e4, t4) {
      return u.hashBinary(l(e4), t4);
    }, u.hashBinary = function(e4, t4) {
      var r4 = a2(i2(e4));
      return t4 ? c(r4) : r4;
    }, u.ArrayBuffer = function() {
      this.reset();
    }, u.ArrayBuffer.prototype.append = function(e4) {
      var t4, n3, i3, o3, a3, l2 = (n3 = this._buff.buffer, i3 = e4, o3 = true, (a3 = new Uint8Array(n3.byteLength + i3.byteLength)).set(new Uint8Array(n3)), a3.set(new Uint8Array(i3), n3.byteLength), o3 ? a3 : a3.buffer), c2 = l2.length;
      for (this._length += e4.byteLength, t4 = 64; t4 <= c2; t4 += 64) r3(this._hash, s2(l2.subarray(t4 - 64, t4)));
      return this._buff = t4 - 64 < c2 ? new Uint8Array(l2.buffer.slice(t4 - 64)) : new Uint8Array(0), this;
    }, u.ArrayBuffer.prototype.end = function(e4) {
      var t4, r4, n3 = this._buff, s3 = n3.length, i3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (t4 = 0; t4 < s3; t4 += 1) i3[t4 >> 2] |= n3[t4] << (t4 % 4 << 3);
      return this._finish(i3, s3), r4 = a2(this._hash), e4 && (r4 = c(r4)), this.reset(), r4;
    }, u.ArrayBuffer.prototype.reset = function() {
      return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, u.ArrayBuffer.prototype.getState = function() {
      var e4, t4 = u.prototype.getState.call(this);
      return t4.buff = (e4 = t4.buff, String.fromCharCode.apply(null, new Uint8Array(e4))), t4;
    }, u.ArrayBuffer.prototype.setState = function(e4) {
      return e4.buff = function(e5, t4) {
        var r4, n3 = e5.length, s3 = new ArrayBuffer(n3), i3 = new Uint8Array(s3);
        for (r4 = 0; r4 < n3; r4 += 1) i3[r4] = e5.charCodeAt(r4);
        return t4 ? i3 : s3;
      }(e4.buff, true), u.prototype.setState.call(this, e4);
    }, u.ArrayBuffer.prototype.destroy = u.prototype.destroy, u.ArrayBuffer.prototype._finish = u.prototype._finish, u.ArrayBuffer.hash = function(e4, t4) {
      var n3 = a2(function(e5) {
        var t5, n4, i3, o3, a3, l2, c2 = e5.length, u2 = [1732584193, -271733879, -1732584194, 271733878];
        for (t5 = 64; t5 <= c2; t5 += 64) r3(u2, s2(e5.subarray(t5 - 64, t5)));
        for (n4 = (e5 = t5 - 64 < c2 ? e5.subarray(t5 - 64) : new Uint8Array(0)).length, i3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], t5 = 0; t5 < n4; t5 += 1) i3[t5 >> 2] |= e5[t5] << (t5 % 4 << 3);
        if (i3[t5 >> 2] |= 128 << (t5 % 4 << 3), t5 > 55) for (r3(u2, i3), t5 = 0; t5 < 16; t5 += 1) i3[t5] = 0;
        return o3 = (o3 = 8 * c2).toString(16).match(/(.*?)(.{0,8})$/), a3 = parseInt(o3[2], 16), l2 = parseInt(o3[1], 16) || 0, i3[14] = a3, i3[15] = l2, r3(u2, i3), u2;
      }(new Uint8Array(e4)));
      return t4 ? c(n3) : n3;
    }, u;
  }();
}, (e2, t2, r2) => {
  var _a2, _e2, _t2, _r2, _n2, _s2, _i2, _o2, _a3, _l2, _c2, _u, _p, _d, _f, _h, _m, _y, _g, _b, _v, _E, _S, _x, _pe_instances, __fn, _N, _D, _k, _O, I_fn, _j, _M, _L, A_fn, C_fn, R_fn, B_fn, w_fn, T_fn, F_fn, P_fn, _U, _$, _V, _q, _W, _G, _H, _z, _K, _X, _J, _el_instances, Y_fn, _el_static, Q_fn, ee_fn, Z_fn;
  var n2 = r2(17), s2 = r2(31).a;
  r2(44), r2(12), Object.defineProperty(t2, "__esModule", { value: true });
  var i2 = r2(309), o2 = r2(328), a2 = r2(507), l = r2(10), c = r2(142), u = r2(508), p = r2(510), d = r2(32), f = r2(511), h = r2(315), m = r2(94), y = r2(325), g = r2(21), b = r2(17);
  function v(e3) {
    var t3 = /* @__PURE__ */ Object.create(null);
    if (e3) for (var r3 in e3) t3[r3] = e3[r3];
    return t3.default = e3, Object.freeze(t3);
  }
  var E = v(o2), S = v(p), x = v(b);
  const T = "Unknown";
  function w(e3, t3) {
    switch (e3.type) {
      case "StringLiteral":
      case "NumericLiteral":
        return String(e3.value);
      case "Identifier":
        if (!t3) return e3.name;
    }
  }
  function P(e3) {
    return e3.filter((e4) => !!e4).join(", ");
  }
  function A(e3) {
    return e3.type.endsWith("Literal");
  }
  function C(e3, t3) {
    return !!(e3 && t3 && "CallExpression" === e3.type && "Identifier" === e3.callee.type && ("string" == typeof t3 ? e3.callee.name === t3 : t3(e3.callee.name)));
  }
  function O(e3) {
    return e3.length > 1 ? `[${e3.join(", ")}]` : e3[0];
  }
  function I(e3) {
    return "ImportSpecifier" === e3.type ? "Identifier" === e3.imported.type ? e3.imported.name : e3.imported.value : "ImportNamespaceSpecifier" === e3.type ? "*" : "default";
  }
  function _(e3) {
    return "Identifier" === e3.type ? e3.name : "StringLiteral" === e3.type ? e3.value : null;
  }
  const k = (e3) => e3, N = /[^\u0130\u0131\u00DFa-z0-9\\/:\-_\. ]+/g, D = (e3) => e3.toLowerCase();
  function j(e3) {
    return N.test(e3) ? e3.replace(N, D) : e3;
  }
  const L = (l.posix || l).normalize, M = /\\/g;
  function B(e3) {
    return L(e3.replace(M, "/"));
  }
  const R = (l.posix || l).join, F = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~\-]/;
  function U(e3) {
    return F.test(e3) ? JSON.stringify(e3) : e3;
  }
  const $ = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
  var V = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== r2.g ? r2.g : "undefined" != typeof self ? self : {};
  function q(e3) {
    return e3 && e3.__esModule && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
  }
  function W(e3, t3) {
    var r3, n3;
    if (0 === t3.length) return e3;
    for (r3 = 0, n3 = t3.length; r3 < n3; r3++) e3 = (e3 << 5) - e3 + t3.charCodeAt(r3), e3 |= 0;
    return e3 < 0 ? -2 * e3 : e3;
  }
  function G(e3, t3, r3, n3) {
    var s3, i3 = W(W(W(e3, r3), (s3 = t3, Object.prototype.toString.call(s3))), typeof t3);
    if (null === t3) return W(i3, "null");
    if (void 0 === t3) return W(i3, "undefined");
    if ("object" == typeof t3 || "function" == typeof t3) {
      if (-1 !== n3.indexOf(t3)) return W(i3, "[Circular]" + r3);
      n3.push(t3);
      var o3 = function(e4, t4, r4) {
        return Object.keys(t4).sort().reduce(function(e5, n4) {
          return G(e5, t4[n4], n4, r4);
        }, e4);
      }(i3, t3, n3);
      if (!("valueOf" in t3) || "function" != typeof t3.valueOf) return o3;
      try {
        return W(o3, String(t3.valueOf()));
      } catch (e4) {
        return W(o3, "[valueOf exception]" + (e4.stack || e4.message));
      }
    }
    return W(i3, t3.toString());
  }
  var H = q(function(e3) {
    return function(e4, t3) {
      for (; e4.length < 8; ) e4 = "0" + e4;
      return e4;
    }(G(0, e3, "", []).toString(16));
  });
  const z = "useCssVars";
  function K(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    return `{
  ${e3.map((e4) => `"${n3 ? "--" : ""}${X(t3, e4, r3, n3)}": (${e4})`).join(",\n  ")}
}`;
  }
  function X(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    return r3 ? H(e3 + t3) : `${e3}-${s3 = t3, i3 = n3, s3.replace($, (e4) => i3 ? `\\\\${e4}` : `\\${e4}`)}`;
    var s3, i3;
  }
  function J(e3) {
    return "'" === (e3 = e3.trim())[0] && "'" === e3[e3.length - 1] || '"' === e3[0] && '"' === e3[e3.length - 1] ? e3.slice(1, -1) : e3;
  }
  const Y = /v-bind\s*\(/g;
  function Q(e3, t3) {
    let r3 = 0, n3 = 0;
    for (let s3 = t3; s3 < e3.length; s3++) {
      const t4 = e3.charAt(s3);
      switch (r3) {
        case 0:
          if ("'" === t4) r3 = 1;
          else if ('"' === t4) r3 = 2;
          else if ("(" === t4) n3++;
          else if (")" === t4) {
            if (!(n3 > 0)) return s3;
            n3--;
          }
          break;
        case 1:
          "'" === t4 && (r3 = 0);
          break;
        case 2:
          '"' === t4 && (r3 = 0);
      }
    }
    return null;
  }
  const Z = (e3) => {
    const { id: t3, isProd: r3 } = e3;
    return { postcssPlugin: "vue-sfc-vars", Declaration(e4) {
      const n3 = e4.value;
      if (Y.test(n3)) {
        Y.lastIndex = 0;
        let s3, i3 = "", o3 = 0;
        for (; s3 = Y.exec(n3); ) {
          const e5 = s3.index + s3[0].length, a3 = Q(n3, e5);
          if (null !== a3) {
            const l2 = J(n3.slice(e5, a3));
            i3 += n3.slice(o3, s3.index) + `var(--${X(t3, l2, r3)})`, o3 = a3 + 1;
          }
        }
        e4.value = i3 + n3.slice(o3);
      }
    } };
  };
  function ee(e3, t3, r3, n3) {
    const s3 = K(e3, r3, n3), i3 = o2.createSimpleExpression(s3, false), a3 = o2.createTransformContext(o2.createRoot([]), { prefixIdentifiers: true, inline: true, bindingMetadata: false === t3.__isScriptSetup ? void 0 : t3 }), l2 = o2.processExpression(i3, a3), c2 = 4 === l2.type ? l2.content : l2.children.map((e4) => "string" == typeof e4 ? e4 : e4.content).join("");
    return `_${z}(_ctx => (${c2}))`;
  }
  Z.postcss = true;
  const te = "object" == typeof performance && performance && "function" == typeof performance.now ? performance : Date, re = /* @__PURE__ */ new Set(), ne = "object" == typeof n2 && n2 ? n2 : {}, se = (e3, t3, r3, n3) => {
    "function" == typeof ne.emitWarning && ne.emitWarning(e3, t3, r3, n3);
  };
  let ie = globalThis.AbortController, oe = globalThis.AbortSignal;
  if (void 0 === ie) {
    oe = class {
      constructor() {
        __publicField(this, "onabort");
        __publicField(this, "_onabort", []);
        __publicField(this, "reason");
        __publicField(this, "aborted", false);
      }
      addEventListener(e4, t4) {
        this._onabort.push(t4);
      }
    }, ie = class {
      constructor() {
        __publicField(this, "signal", new oe());
        t3();
      }
      abort(e4) {
        var _a4, _b2;
        if (!this.signal.aborted) {
          this.signal.reason = e4, this.signal.aborted = true;
          for (const t4 of this.signal._onabort) t4(e4);
          (_b2 = (_a4 = this.signal).onabort) == null ? void 0 : _b2.call(_a4, e4);
        }
      }
    };
    let e3 = "1" !== ((_a2 = ne.env) == null ? void 0 : _a2.LRU_CACHE_IGNORE_AC_WARNING);
    const t3 = () => {
      e3 && (e3 = false, se("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", t3));
    };
  }
  const ae = (e3) => e3 && e3 === Math.floor(e3) && e3 > 0 && isFinite(e3), le = (e3) => ae(e3) ? e3 <= Math.pow(2, 8) ? Uint8Array : e3 <= Math.pow(2, 16) ? Uint16Array : e3 <= Math.pow(2, 32) ? Uint32Array : e3 <= Number.MAX_SAFE_INTEGER ? ce : null : null;
  class ce extends Array {
    constructor(e3) {
      super(e3), this.fill(0);
    }
  }
  const _ue = class _ue {
    constructor(e3, t3) {
      __publicField(this, "heap");
      __publicField(this, "length");
      if (!__privateGet(_ue, _e2)) throw new TypeError("instantiate Stack using Stack.create(n)");
      this.heap = new t3(e3), this.length = 0;
    }
    static create(e3) {
      const t3 = le(e3);
      if (!t3) return [];
      __privateSet(_ue, _e2, true);
      const r3 = new _ue(e3, t3);
      return __privateSet(_ue, _e2, false), r3;
    }
    push(e3) {
      this.heap[this.length++] = e3;
    }
    pop() {
      return this.heap[--this.length];
    }
  };
  _e2 = new WeakMap();
  __privateAdd(_ue, _e2, false);
  let ue = _ue;
  const _pe = class _pe {
    constructor(e3) {
      __privateAdd(this, _pe_instances);
      __privateAdd(this, _t2);
      __privateAdd(this, _r2);
      __privateAdd(this, _n2);
      __privateAdd(this, _s2);
      __privateAdd(this, _i2);
      __publicField(this, "ttl");
      __publicField(this, "ttlResolution");
      __publicField(this, "ttlAutopurge");
      __publicField(this, "updateAgeOnGet");
      __publicField(this, "updateAgeOnHas");
      __publicField(this, "allowStale");
      __publicField(this, "noDisposeOnSet");
      __publicField(this, "noUpdateTTL");
      __publicField(this, "maxEntrySize");
      __publicField(this, "sizeCalculation");
      __publicField(this, "noDeleteOnFetchRejection");
      __publicField(this, "noDeleteOnStaleGet");
      __publicField(this, "allowStaleOnFetchAbort");
      __publicField(this, "allowStaleOnFetchRejection");
      __publicField(this, "ignoreFetchAbort");
      __privateAdd(this, _o2);
      __privateAdd(this, _a3);
      __privateAdd(this, _l2);
      __privateAdd(this, _c2);
      __privateAdd(this, _u);
      __privateAdd(this, _p);
      __privateAdd(this, _d);
      __privateAdd(this, _f);
      __privateAdd(this, _h);
      __privateAdd(this, _m);
      __privateAdd(this, _y);
      __privateAdd(this, _g);
      __privateAdd(this, _b);
      __privateAdd(this, _v);
      __privateAdd(this, _E);
      __privateAdd(this, _S);
      __privateAdd(this, _x);
      __privateAdd(this, _N, () => {
      });
      __privateAdd(this, _D, () => {
      });
      __privateAdd(this, _k, () => {
      });
      __privateAdd(this, _O, () => false);
      __privateAdd(this, _j, (e3) => {
      });
      __privateAdd(this, _M, (e3, t3, r3) => {
      });
      __privateAdd(this, _L, (e3, t3, r3, n3) => {
        if (r3 || n3) throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        return 0;
      });
      const { max: t3 = 0, ttl: r3, ttlResolution: n3 = 1, ttlAutopurge: s3, updateAgeOnGet: i3, updateAgeOnHas: o3, allowStale: a3, dispose: l2, disposeAfter: c2, noDisposeOnSet: u2, noUpdateTTL: p2, maxSize: d2 = 0, maxEntrySize: f2 = 0, sizeCalculation: h2, fetchMethod: m2, noDeleteOnFetchRejection: y2, noDeleteOnStaleGet: g2, allowStaleOnFetchRejection: b2, allowStaleOnFetchAbort: v2, ignoreFetchAbort: E2 } = e3;
      if (0 !== t3 && !ae(t3)) throw new TypeError("max option must be a nonnegative integer");
      const S2 = t3 ? le(t3) : Array;
      if (!S2) throw new Error("invalid max value: " + t3);
      if (__privateSet(this, _t2, t3), __privateSet(this, _r2, d2), this.maxEntrySize = f2 || __privateGet(this, _r2), this.sizeCalculation = h2, this.sizeCalculation) {
        if (!__privateGet(this, _r2) && !this.maxEntrySize) throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        if ("function" != typeof this.sizeCalculation) throw new TypeError("sizeCalculation set to non-function");
      }
      if (void 0 !== m2 && "function" != typeof m2) throw new TypeError("fetchMethod must be a function if specified");
      if (__privateSet(this, _i2, m2), __privateSet(this, _S, !!m2), __privateSet(this, _l2, /* @__PURE__ */ new Map()), __privateSet(this, _c2, new Array(t3).fill(void 0)), __privateSet(this, _u, new Array(t3).fill(void 0)), __privateSet(this, _p, new S2(t3)), __privateSet(this, _d, new S2(t3)), __privateSet(this, _f, 0), __privateSet(this, _h, 0), __privateSet(this, _m, ue.create(t3)), __privateSet(this, _o2, 0), __privateSet(this, _a3, 0), "function" == typeof l2 && __privateSet(this, _n2, l2), "function" == typeof c2 ? (__privateSet(this, _s2, c2), __privateSet(this, _y, [])) : (__privateSet(this, _s2, void 0), __privateSet(this, _y, void 0)), __privateSet(this, _E, !!__privateGet(this, _n2)), __privateSet(this, _x, !!__privateGet(this, _s2)), this.noDisposeOnSet = !!u2, this.noUpdateTTL = !!p2, this.noDeleteOnFetchRejection = !!y2, this.allowStaleOnFetchRejection = !!b2, this.allowStaleOnFetchAbort = !!v2, this.ignoreFetchAbort = !!E2, 0 !== this.maxEntrySize) {
        if (0 !== __privateGet(this, _r2) && !ae(__privateGet(this, _r2))) throw new TypeError("maxSize must be a positive integer if specified");
        if (!ae(this.maxEntrySize)) throw new TypeError("maxEntrySize must be a positive integer if specified");
        __privateMethod(this, _pe_instances, I_fn).call(this);
      }
      if (this.allowStale = !!a3, this.noDeleteOnStaleGet = !!g2, this.updateAgeOnGet = !!i3, this.updateAgeOnHas = !!o3, this.ttlResolution = ae(n3) || 0 === n3 ? n3 : 1, this.ttlAutopurge = !!s3, this.ttl = r3 || 0, this.ttl) {
        if (!ae(this.ttl)) throw new TypeError("ttl must be a positive integer if specified");
        __privateMethod(this, _pe_instances, __fn).call(this);
      }
      if (0 === __privateGet(this, _t2) && 0 === this.ttl && 0 === __privateGet(this, _r2)) throw new TypeError("At least one of max, maxSize, or ttl is required");
      if (!this.ttlAutopurge && !__privateGet(this, _t2) && !__privateGet(this, _r2)) {
        const e4 = "LRU_CACHE_UNBOUNDED";
        ((e5) => !re.has(e5))(e4) && (re.add(e4), se("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", e4, _pe));
      }
    }
    static unsafeExposeInternals(e3) {
      return { starts: __privateGet(e3, _b), ttls: __privateGet(e3, _v), sizes: __privateGet(e3, _g), keyMap: __privateGet(e3, _l2), keyList: __privateGet(e3, _c2), valList: __privateGet(e3, _u), next: __privateGet(e3, _p), prev: __privateGet(e3, _d), get head() {
        return __privateGet(e3, _f);
      }, get tail() {
        return __privateGet(e3, _h);
      }, free: __privateGet(e3, _m), isBackgroundFetch: (t3) => {
        var _a4;
        return __privateMethod(_a4 = e3, _pe_instances, T_fn).call(_a4, t3);
      }, backgroundFetch: (t3, r3, n3, s3) => {
        var _a4;
        return __privateMethod(_a4 = e3, _pe_instances, w_fn).call(_a4, t3, r3, n3, s3);
      }, moveToTail: (t3) => {
        var _a4;
        return __privateMethod(_a4 = e3, _pe_instances, P_fn).call(_a4, t3);
      }, indexes: (t3) => {
        var _a4;
        return __privateMethod(_a4 = e3, _pe_instances, A_fn).call(_a4, t3);
      }, rindexes: (t3) => {
        var _a4;
        return __privateMethod(_a4 = e3, _pe_instances, C_fn).call(_a4, t3);
      }, isStale: (t3) => {
        var _a4;
        return __privateGet(_a4 = e3, _O).call(_a4, t3);
      } };
    }
    get max() {
      return __privateGet(this, _t2);
    }
    get maxSize() {
      return __privateGet(this, _r2);
    }
    get calculatedSize() {
      return __privateGet(this, _a3);
    }
    get size() {
      return __privateGet(this, _o2);
    }
    get fetchMethod() {
      return __privateGet(this, _i2);
    }
    get dispose() {
      return __privateGet(this, _n2);
    }
    get disposeAfter() {
      return __privateGet(this, _s2);
    }
    getRemainingTTL(e3) {
      return __privateGet(this, _l2).has(e3) ? 1 / 0 : 0;
    }
    *entries() {
      for (const e3 of __privateMethod(this, _pe_instances, A_fn).call(this)) void 0 === __privateGet(this, _u)[e3] || void 0 === __privateGet(this, _c2)[e3] || __privateMethod(this, _pe_instances, T_fn).call(this, __privateGet(this, _u)[e3]) || (yield [__privateGet(this, _c2)[e3], __privateGet(this, _u)[e3]]);
    }
    *rentries() {
      for (const e3 of __privateMethod(this, _pe_instances, C_fn).call(this)) void 0 === __privateGet(this, _u)[e3] || void 0 === __privateGet(this, _c2)[e3] || __privateMethod(this, _pe_instances, T_fn).call(this, __privateGet(this, _u)[e3]) || (yield [__privateGet(this, _c2)[e3], __privateGet(this, _u)[e3]]);
    }
    *keys() {
      for (const e3 of __privateMethod(this, _pe_instances, A_fn).call(this)) {
        const t3 = __privateGet(this, _c2)[e3];
        void 0 === t3 || __privateMethod(this, _pe_instances, T_fn).call(this, __privateGet(this, _u)[e3]) || (yield t3);
      }
    }
    *rkeys() {
      for (const e3 of __privateMethod(this, _pe_instances, C_fn).call(this)) {
        const t3 = __privateGet(this, _c2)[e3];
        void 0 === t3 || __privateMethod(this, _pe_instances, T_fn).call(this, __privateGet(this, _u)[e3]) || (yield t3);
      }
    }
    *values() {
      for (const e3 of __privateMethod(this, _pe_instances, A_fn).call(this)) void 0 === __privateGet(this, _u)[e3] || __privateMethod(this, _pe_instances, T_fn).call(this, __privateGet(this, _u)[e3]) || (yield __privateGet(this, _u)[e3]);
    }
    *rvalues() {
      for (const e3 of __privateMethod(this, _pe_instances, C_fn).call(this)) void 0 === __privateGet(this, _u)[e3] || __privateMethod(this, _pe_instances, T_fn).call(this, __privateGet(this, _u)[e3]) || (yield __privateGet(this, _u)[e3]);
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    find(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      for (const r3 of __privateMethod(this, _pe_instances, A_fn).call(this)) {
        const n3 = __privateGet(this, _u)[r3], s3 = __privateMethod(this, _pe_instances, T_fn).call(this, n3) ? n3.__staleWhileFetching : n3;
        if (void 0 !== s3 && e3(s3, __privateGet(this, _c2)[r3], this)) return this.get(__privateGet(this, _c2)[r3], t3);
      }
    }
    forEach(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this;
      for (const r3 of __privateMethod(this, _pe_instances, A_fn).call(this)) {
        const n3 = __privateGet(this, _u)[r3], s3 = __privateMethod(this, _pe_instances, T_fn).call(this, n3) ? n3.__staleWhileFetching : n3;
        void 0 !== s3 && e3.call(t3, s3, __privateGet(this, _c2)[r3], this);
      }
    }
    rforEach(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this;
      for (const r3 of __privateMethod(this, _pe_instances, C_fn).call(this)) {
        const n3 = __privateGet(this, _u)[r3], s3 = __privateMethod(this, _pe_instances, T_fn).call(this, n3) ? n3.__staleWhileFetching : n3;
        void 0 !== s3 && e3.call(t3, s3, __privateGet(this, _c2)[r3], this);
      }
    }
    purgeStale() {
      let e3 = false;
      for (const t3 of __privateMethod(this, _pe_instances, C_fn).call(this, { allowStale: true })) __privateGet(this, _O).call(this, t3) && (this.delete(__privateGet(this, _c2)[t3]), e3 = true);
      return e3;
    }
    info(e3) {
      const t3 = __privateGet(this, _l2).get(e3);
      if (void 0 === t3) return;
      const r3 = __privateGet(this, _u)[t3], n3 = __privateMethod(this, _pe_instances, T_fn).call(this, r3) ? r3.__staleWhileFetching : r3;
      if (void 0 === n3) return;
      const s3 = { value: n3 };
      if (__privateGet(this, _v) && __privateGet(this, _b)) {
        const e4 = __privateGet(this, _v)[t3], r4 = __privateGet(this, _b)[t3];
        if (e4 && r4) {
          const t4 = e4 - (te.now() - r4);
          s3.ttl = t4, s3.start = Date.now();
        }
      }
      return __privateGet(this, _g) && (s3.size = __privateGet(this, _g)[t3]), s3;
    }
    dump() {
      const e3 = [];
      for (const t3 of __privateMethod(this, _pe_instances, A_fn).call(this, { allowStale: true })) {
        const r3 = __privateGet(this, _c2)[t3], n3 = __privateGet(this, _u)[t3], s3 = __privateMethod(this, _pe_instances, T_fn).call(this, n3) ? n3.__staleWhileFetching : n3;
        if (void 0 === s3 || void 0 === r3) continue;
        const i3 = { value: s3 };
        if (__privateGet(this, _v) && __privateGet(this, _b)) {
          i3.ttl = __privateGet(this, _v)[t3];
          const e4 = te.now() - __privateGet(this, _b)[t3];
          i3.start = Math.floor(Date.now() - e4);
        }
        __privateGet(this, _g) && (i3.size = __privateGet(this, _g)[t3]), e3.unshift([r3, i3]);
      }
      return e3;
    }
    load(e3) {
      this.clear();
      for (const [t3, r3] of e3) {
        if (r3.start) {
          const e4 = Date.now() - r3.start;
          r3.start = te.now() - e4;
        }
        this.set(t3, r3.value, r3);
      }
    }
    set(e3, t3) {
      var _a4, _b2, _c3, _d2, _e3;
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      if (void 0 === t3) return this.delete(e3), this;
      const { ttl: n3 = this.ttl, start: s3, noDisposeOnSet: i3 = this.noDisposeOnSet, sizeCalculation: o3 = this.sizeCalculation, status: a3 } = r3;
      let { noUpdateTTL: l2 = this.noUpdateTTL } = r3;
      const c2 = __privateGet(this, _L).call(this, e3, t3, r3.size || 0, o3);
      if (this.maxEntrySize && c2 > this.maxEntrySize) return a3 && (a3.set = "miss", a3.maxEntrySizeExceeded = true), this.delete(e3), this;
      let u2 = 0 === __privateGet(this, _o2) ? void 0 : __privateGet(this, _l2).get(e3);
      if (void 0 === u2) u2 = 0 === __privateGet(this, _o2) ? __privateGet(this, _h) : 0 !== __privateGet(this, _m).length ? __privateGet(this, _m).pop() : __privateGet(this, _o2) === __privateGet(this, _t2) ? __privateMethod(this, _pe_instances, B_fn).call(this, false) : __privateGet(this, _o2), __privateGet(this, _c2)[u2] = e3, __privateGet(this, _u)[u2] = t3, __privateGet(this, _l2).set(e3, u2), __privateGet(this, _p)[__privateGet(this, _h)] = u2, __privateGet(this, _d)[u2] = __privateGet(this, _h), __privateSet(this, _h, u2), __privateWrapper(this, _o2)._++, __privateGet(this, _M).call(this, u2, c2, a3), a3 && (a3.set = "add"), l2 = false;
      else {
        __privateMethod(this, _pe_instances, P_fn).call(this, u2);
        const r4 = __privateGet(this, _u)[u2];
        if (t3 !== r4) {
          if (__privateGet(this, _S) && __privateMethod(this, _pe_instances, T_fn).call(this, r4)) {
            r4.__abortController.abort(new Error("replaced"));
            const { __staleWhileFetching: t4 } = r4;
            void 0 === t4 || i3 || (__privateGet(this, _E) && ((_a4 = __privateGet(this, _n2)) == null ? void 0 : _a4.call(this, t4, e3, "set")), __privateGet(this, _x) && ((_b2 = __privateGet(this, _y)) == null ? void 0 : _b2.push([t4, e3, "set"])));
          } else i3 || (__privateGet(this, _E) && ((_c3 = __privateGet(this, _n2)) == null ? void 0 : _c3.call(this, r4, e3, "set")), __privateGet(this, _x) && ((_d2 = __privateGet(this, _y)) == null ? void 0 : _d2.push([r4, e3, "set"])));
          if (__privateGet(this, _j).call(this, u2), __privateGet(this, _M).call(this, u2, c2, a3), __privateGet(this, _u)[u2] = t3, a3) {
            a3.set = "replace";
            const e4 = r4 && __privateMethod(this, _pe_instances, T_fn).call(this, r4) ? r4.__staleWhileFetching : r4;
            void 0 !== e4 && (a3.oldValue = e4);
          }
        } else a3 && (a3.set = "update");
      }
      if (0 === n3 || __privateGet(this, _v) || __privateMethod(this, _pe_instances, __fn).call(this), __privateGet(this, _v) && (l2 || __privateGet(this, _k).call(this, u2, n3, s3), a3 && __privateGet(this, _D).call(this, a3, u2)), !i3 && __privateGet(this, _x) && __privateGet(this, _y)) {
        const e4 = __privateGet(this, _y);
        let t4;
        for (; t4 = e4 == null ? void 0 : e4.shift(); ) (_e3 = __privateGet(this, _s2)) == null ? void 0 : _e3.call(this, ...t4);
      }
      return this;
    }
    pop() {
      var _a4;
      try {
        for (; __privateGet(this, _o2); ) {
          const e3 = __privateGet(this, _u)[__privateGet(this, _f)];
          if (__privateMethod(this, _pe_instances, B_fn).call(this, true), __privateMethod(this, _pe_instances, T_fn).call(this, e3)) {
            if (e3.__staleWhileFetching) return e3.__staleWhileFetching;
          } else if (void 0 !== e3) return e3;
        }
      } finally {
        if (__privateGet(this, _x) && __privateGet(this, _y)) {
          const e3 = __privateGet(this, _y);
          let t3;
          for (; t3 = e3 == null ? void 0 : e3.shift(); ) (_a4 = __privateGet(this, _s2)) == null ? void 0 : _a4.call(this, ...t3);
        }
      }
    }
    has(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const { updateAgeOnHas: r3 = this.updateAgeOnHas, status: n3 } = t3, s3 = __privateGet(this, _l2).get(e3);
      if (void 0 !== s3) {
        const e4 = __privateGet(this, _u)[s3];
        if (__privateMethod(this, _pe_instances, T_fn).call(this, e4) && void 0 === e4.__staleWhileFetching) return false;
        if (!__privateGet(this, _O).call(this, s3)) return r3 && __privateGet(this, _N).call(this, s3), n3 && (n3.has = "hit", __privateGet(this, _D).call(this, n3, s3)), true;
        n3 && (n3.has = "stale", __privateGet(this, _D).call(this, n3, s3));
      } else n3 && (n3.has = "miss");
      return false;
    }
    peek(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const { allowStale: r3 = this.allowStale } = t3, n3 = __privateGet(this, _l2).get(e3);
      if (void 0 === n3 || !r3 && __privateGet(this, _O).call(this, n3)) return;
      const s3 = __privateGet(this, _u)[n3];
      return __privateMethod(this, _pe_instances, T_fn).call(this, s3) ? s3.__staleWhileFetching : s3;
    }
    async fetch(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const { allowStale: r3 = this.allowStale, updateAgeOnGet: n3 = this.updateAgeOnGet, noDeleteOnStaleGet: s3 = this.noDeleteOnStaleGet, ttl: i3 = this.ttl, noDisposeOnSet: o3 = this.noDisposeOnSet, size: a3 = 0, sizeCalculation: l2 = this.sizeCalculation, noUpdateTTL: c2 = this.noUpdateTTL, noDeleteOnFetchRejection: u2 = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection: p2 = this.allowStaleOnFetchRejection, ignoreFetchAbort: d2 = this.ignoreFetchAbort, allowStaleOnFetchAbort: f2 = this.allowStaleOnFetchAbort, context: h2, forceRefresh: m2 = false, status: y2, signal: g2 } = t3;
      if (!__privateGet(this, _S)) return y2 && (y2.fetch = "get"), this.get(e3, { allowStale: r3, updateAgeOnGet: n3, noDeleteOnStaleGet: s3, status: y2 });
      const b2 = { allowStale: r3, updateAgeOnGet: n3, noDeleteOnStaleGet: s3, ttl: i3, noDisposeOnSet: o3, size: a3, sizeCalculation: l2, noUpdateTTL: c2, noDeleteOnFetchRejection: u2, allowStaleOnFetchRejection: p2, allowStaleOnFetchAbort: f2, ignoreFetchAbort: d2, status: y2, signal: g2 };
      let v2 = __privateGet(this, _l2).get(e3);
      if (void 0 === v2) {
        y2 && (y2.fetch = "miss");
        const t4 = __privateMethod(this, _pe_instances, w_fn).call(this, e3, v2, b2, h2);
        return t4.__returned = t4;
      }
      {
        const t4 = __privateGet(this, _u)[v2];
        if (__privateMethod(this, _pe_instances, T_fn).call(this, t4)) {
          const e4 = r3 && void 0 !== t4.__staleWhileFetching;
          return y2 && (y2.fetch = "inflight", e4 && (y2.returnedStale = true)), e4 ? t4.__staleWhileFetching : t4.__returned = t4;
        }
        const s4 = __privateGet(this, _O).call(this, v2);
        if (!m2 && !s4) return y2 && (y2.fetch = "hit"), __privateMethod(this, _pe_instances, P_fn).call(this, v2), n3 && __privateGet(this, _N).call(this, v2), y2 && __privateGet(this, _D).call(this, y2, v2), t4;
        const i4 = __privateMethod(this, _pe_instances, w_fn).call(this, e3, v2, b2, h2), o4 = void 0 !== i4.__staleWhileFetching && r3;
        return y2 && (y2.fetch = s4 ? "stale" : "refresh", o4 && s4 && (y2.returnedStale = true)), o4 ? i4.__staleWhileFetching : i4.__returned = i4;
      }
    }
    get(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const { allowStale: r3 = this.allowStale, updateAgeOnGet: n3 = this.updateAgeOnGet, noDeleteOnStaleGet: s3 = this.noDeleteOnStaleGet, status: i3 } = t3, o3 = __privateGet(this, _l2).get(e3);
      if (void 0 !== o3) {
        const t4 = __privateGet(this, _u)[o3], a3 = __privateMethod(this, _pe_instances, T_fn).call(this, t4);
        return i3 && __privateGet(this, _D).call(this, i3, o3), __privateGet(this, _O).call(this, o3) ? (i3 && (i3.get = "stale"), a3 ? (i3 && r3 && void 0 !== t4.__staleWhileFetching && (i3.returnedStale = true), r3 ? t4.__staleWhileFetching : void 0) : (s3 || this.delete(e3), i3 && r3 && (i3.returnedStale = true), r3 ? t4 : void 0)) : (i3 && (i3.get = "hit"), a3 ? t4.__staleWhileFetching : (__privateMethod(this, _pe_instances, P_fn).call(this, o3), n3 && __privateGet(this, _N).call(this, o3), t4));
      }
      i3 && (i3.get = "miss");
    }
    delete(e3) {
      var _a4, _b2, _c3, _d2;
      let t3 = false;
      if (0 !== __privateGet(this, _o2)) {
        const r3 = __privateGet(this, _l2).get(e3);
        if (void 0 !== r3) if (t3 = true, 1 === __privateGet(this, _o2)) this.clear();
        else {
          __privateGet(this, _j).call(this, r3);
          const t4 = __privateGet(this, _u)[r3];
          if (__privateMethod(this, _pe_instances, T_fn).call(this, t4) ? t4.__abortController.abort(new Error("deleted")) : (__privateGet(this, _E) || __privateGet(this, _x)) && (__privateGet(this, _E) && ((_a4 = __privateGet(this, _n2)) == null ? void 0 : _a4.call(this, t4, e3, "delete")), __privateGet(this, _x) && ((_b2 = __privateGet(this, _y)) == null ? void 0 : _b2.push([t4, e3, "delete"]))), __privateGet(this, _l2).delete(e3), __privateGet(this, _c2)[r3] = void 0, __privateGet(this, _u)[r3] = void 0, r3 === __privateGet(this, _h)) __privateSet(this, _h, __privateGet(this, _d)[r3]);
          else if (r3 === __privateGet(this, _f)) __privateSet(this, _f, __privateGet(this, _p)[r3]);
          else {
            const e4 = __privateGet(this, _d)[r3];
            __privateGet(this, _p)[e4] = __privateGet(this, _p)[r3];
            const t5 = __privateGet(this, _p)[r3];
            __privateGet(this, _d)[t5] = __privateGet(this, _d)[r3];
          }
          __privateWrapper(this, _o2)._--, __privateGet(this, _m).push(r3);
        }
      }
      if (__privateGet(this, _x) && ((_c3 = __privateGet(this, _y)) == null ? void 0 : _c3.length)) {
        const e4 = __privateGet(this, _y);
        let t4;
        for (; t4 = e4 == null ? void 0 : e4.shift(); ) (_d2 = __privateGet(this, _s2)) == null ? void 0 : _d2.call(this, ...t4);
      }
      return t3;
    }
    clear() {
      var _a4, _b2, _c3;
      for (const e3 of __privateMethod(this, _pe_instances, C_fn).call(this, { allowStale: true })) {
        const t3 = __privateGet(this, _u)[e3];
        if (__privateMethod(this, _pe_instances, T_fn).call(this, t3)) t3.__abortController.abort(new Error("deleted"));
        else {
          const r3 = __privateGet(this, _c2)[e3];
          __privateGet(this, _E) && ((_a4 = __privateGet(this, _n2)) == null ? void 0 : _a4.call(this, t3, r3, "delete")), __privateGet(this, _x) && ((_b2 = __privateGet(this, _y)) == null ? void 0 : _b2.push([t3, r3, "delete"]));
        }
      }
      if (__privateGet(this, _l2).clear(), __privateGet(this, _u).fill(void 0), __privateGet(this, _c2).fill(void 0), __privateGet(this, _v) && __privateGet(this, _b) && (__privateGet(this, _v).fill(0), __privateGet(this, _b).fill(0)), __privateGet(this, _g) && __privateGet(this, _g).fill(0), __privateSet(this, _f, 0), __privateSet(this, _h, 0), __privateGet(this, _m).length = 0, __privateSet(this, _a3, 0), __privateSet(this, _o2, 0), __privateGet(this, _x) && __privateGet(this, _y)) {
        const e3 = __privateGet(this, _y);
        let t3;
        for (; t3 = e3 == null ? void 0 : e3.shift(); ) (_c3 = __privateGet(this, _s2)) == null ? void 0 : _c3.call(this, ...t3);
      }
    }
  };
  _t2 = new WeakMap();
  _r2 = new WeakMap();
  _n2 = new WeakMap();
  _s2 = new WeakMap();
  _i2 = new WeakMap();
  _o2 = new WeakMap();
  _a3 = new WeakMap();
  _l2 = new WeakMap();
  _c2 = new WeakMap();
  _u = new WeakMap();
  _p = new WeakMap();
  _d = new WeakMap();
  _f = new WeakMap();
  _h = new WeakMap();
  _m = new WeakMap();
  _y = new WeakMap();
  _g = new WeakMap();
  _b = new WeakMap();
  _v = new WeakMap();
  _E = new WeakMap();
  _S = new WeakMap();
  _x = new WeakMap();
  _pe_instances = new WeakSet();
  __fn = function() {
    var e3 = this;
    const t3 = new ce(__privateGet(this, _t2)), r3 = new ce(__privateGet(this, _t2));
    __privateSet(this, _v, t3), __privateSet(this, _b, r3), __privateSet(this, _k, function(n4, s4) {
      let i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : te.now();
      if (r3[n4] = 0 !== s4 ? i3 : 0, t3[n4] = s4, 0 !== s4 && e3.ttlAutopurge) {
        const t4 = setTimeout(() => {
          var _a4;
          __privateGet(_a4 = e3, _O).call(_a4, n4) && e3.delete(__privateGet(e3, _c2)[n4]);
        }, s4 + 1);
        t4.unref && t4.unref();
      }
    }), __privateSet(this, _N, (e4) => {
      r3[e4] = 0 !== t3[e4] ? te.now() : 0;
    }), __privateSet(this, _D, (e4, i3) => {
      if (t3[i3]) {
        const o3 = t3[i3], a3 = r3[i3];
        if (!o3 || !a3) return;
        e4.ttl = o3, e4.start = a3, e4.now = n3 || s3();
        const l2 = e4.now - a3;
        e4.remainingTTL = o3 - l2;
      }
    });
    let n3 = 0;
    const s3 = () => {
      const e4 = te.now();
      if (this.ttlResolution > 0) {
        n3 = e4;
        const t4 = setTimeout(() => n3 = 0, this.ttlResolution);
        t4.unref && t4.unref();
      }
      return e4;
    };
    this.getRemainingTTL = (e4) => {
      const i3 = __privateGet(this, _l2).get(e4);
      if (void 0 === i3) return 0;
      const o3 = t3[i3], a3 = r3[i3];
      return o3 && a3 ? o3 - ((n3 || s3()) - a3) : 1 / 0;
    }, __privateSet(this, _O, (e4) => {
      const i3 = r3[e4], o3 = t3[e4];
      return !!o3 && !!i3 && (n3 || s3()) - i3 > o3;
    });
  };
  _N = new WeakMap();
  _D = new WeakMap();
  _k = new WeakMap();
  _O = new WeakMap();
  I_fn = function() {
    const e3 = new ce(__privateGet(this, _t2));
    __privateSet(this, _a3, 0), __privateSet(this, _g, e3), __privateSet(this, _j, (t3) => {
      __privateSet(this, _a3, __privateGet(this, _a3) - e3[t3]), e3[t3] = 0;
    }), __privateSet(this, _L, (e4, t3, r3, n3) => {
      if (__privateMethod(this, _pe_instances, T_fn).call(this, t3)) return 0;
      if (!ae(r3)) {
        if (!n3) throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        if ("function" != typeof n3) throw new TypeError("sizeCalculation must be a function");
        if (r3 = n3(t3, e4), !ae(r3)) throw new TypeError("sizeCalculation return invalid (expect positive integer)");
      }
      return r3;
    }), __privateSet(this, _M, (t3, r3, n3) => {
      if (e3[t3] = r3, __privateGet(this, _r2)) {
        const r4 = __privateGet(this, _r2) - e3[t3];
        for (; __privateGet(this, _a3) > r4; ) __privateMethod(this, _pe_instances, B_fn).call(this, true);
      }
      __privateSet(this, _a3, __privateGet(this, _a3) + e3[t3]), n3 && (n3.entrySize = r3, n3.totalCalculatedSize = __privateGet(this, _a3));
    });
  };
  _j = new WeakMap();
  _M = new WeakMap();
  _L = new WeakMap();
  A_fn = function() {
    var e3 = this;
    let { allowStale: t3 = this.allowStale } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return function* () {
      var _a4, _b2;
      if (__privateGet(e3, _o2)) for (let r3 = __privateGet(e3, _h); __privateMethod(_a4 = e3, _pe_instances, R_fn).call(_a4, r3) && (!t3 && __privateGet(_b2 = e3, _O).call(_b2, r3) || (yield r3), r3 !== __privateGet(e3, _f)); ) r3 = __privateGet(e3, _d)[r3];
    }();
  };
  C_fn = function() {
    var e3 = this;
    let { allowStale: t3 = this.allowStale } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return function* () {
      var _a4, _b2;
      if (__privateGet(e3, _o2)) for (let r3 = __privateGet(e3, _f); __privateMethod(_a4 = e3, _pe_instances, R_fn).call(_a4, r3) && (!t3 && __privateGet(_b2 = e3, _O).call(_b2, r3) || (yield r3), r3 !== __privateGet(e3, _h)); ) r3 = __privateGet(e3, _p)[r3];
    }();
  };
  R_fn = function(e3) {
    return void 0 !== e3 && __privateGet(this, _l2).get(__privateGet(this, _c2)[e3]) === e3;
  };
  B_fn = function(e3) {
    var _a4, _b2;
    const t3 = __privateGet(this, _f), r3 = __privateGet(this, _c2)[t3], n3 = __privateGet(this, _u)[t3];
    return __privateGet(this, _S) && __privateMethod(this, _pe_instances, T_fn).call(this, n3) ? n3.__abortController.abort(new Error("evicted")) : (__privateGet(this, _E) || __privateGet(this, _x)) && (__privateGet(this, _E) && ((_a4 = __privateGet(this, _n2)) == null ? void 0 : _a4.call(this, n3, r3, "evict")), __privateGet(this, _x) && ((_b2 = __privateGet(this, _y)) == null ? void 0 : _b2.push([n3, r3, "evict"]))), __privateGet(this, _j).call(this, t3), e3 && (__privateGet(this, _c2)[t3] = void 0, __privateGet(this, _u)[t3] = void 0, __privateGet(this, _m).push(t3)), 1 === __privateGet(this, _o2) ? (__privateSet(this, _f, __privateSet(this, _h, 0)), __privateGet(this, _m).length = 0) : __privateSet(this, _f, __privateGet(this, _p)[t3]), __privateGet(this, _l2).delete(r3), __privateWrapper(this, _o2)._--, t3;
  };
  w_fn = function(e3, t3, r3, n3) {
    var s3 = this;
    const i3 = void 0 === t3 ? void 0 : __privateGet(this, _u)[t3];
    if (__privateMethod(this, _pe_instances, T_fn).call(this, i3)) return i3;
    const o3 = new ie(), { signal: a3 } = r3;
    a3 == null ? void 0 : a3.addEventListener("abort", () => o3.abort(a3.reason), { signal: o3.signal });
    const l2 = { signal: o3.signal, options: r3, context: n3 }, c2 = function(n4) {
      let i4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      const { aborted: a4 } = o3.signal, c3 = r3.ignoreFetchAbort && void 0 !== n4;
      if (r3.status && (a4 && !i4 ? (r3.status.fetchAborted = true, r3.status.fetchError = o3.signal.reason, c3 && (r3.status.fetchAbortIgnored = true)) : r3.status.fetchResolved = true), a4 && !c3 && !i4) return u2(o3.signal.reason);
      const d3 = p2;
      return __privateGet(s3, _u)[t3] === p2 && (void 0 === n4 ? d3.__staleWhileFetching ? __privateGet(s3, _u)[t3] = d3.__staleWhileFetching : s3.delete(e3) : (r3.status && (r3.status.fetchUpdated = true), s3.set(e3, n4, l2.options))), n4;
    }, u2 = (n4) => {
      const { aborted: s4 } = o3.signal, i4 = s4 && r3.allowStaleOnFetchAbort, a4 = i4 || r3.allowStaleOnFetchRejection, l3 = a4 || r3.noDeleteOnFetchRejection, c3 = p2;
      if (__privateGet(this, _u)[t3] === p2 && (l3 && void 0 !== c3.__staleWhileFetching ? i4 || (__privateGet(this, _u)[t3] = c3.__staleWhileFetching) : this.delete(e3)), a4) return r3.status && void 0 !== c3.__staleWhileFetching && (r3.status.returnedStale = true), c3.__staleWhileFetching;
      if (c3.__returned === c3) throw n4;
    };
    r3.status && (r3.status.fetchDispatched = true);
    const p2 = new Promise((t4, n4) => {
      var _a4;
      const s4 = (_a4 = __privateGet(this, _i2)) == null ? void 0 : _a4.call(this, e3, i3, l2);
      s4 && s4 instanceof Promise && s4.then((e4) => t4(void 0 === e4 ? void 0 : e4), n4), o3.signal.addEventListener("abort", () => {
        r3.ignoreFetchAbort && !r3.allowStaleOnFetchAbort || (t4(void 0), r3.allowStaleOnFetchAbort && (t4 = (e4) => c2(e4, true)));
      });
    }).then(c2, (e4) => (r3.status && (r3.status.fetchRejected = true, r3.status.fetchError = e4), u2(e4))), d2 = Object.assign(p2, { __abortController: o3, __staleWhileFetching: i3, __returned: void 0 });
    return void 0 === t3 ? (this.set(e3, d2, { ...l2.options, status: void 0 }), t3 = __privateGet(this, _l2).get(e3)) : __privateGet(this, _u)[t3] = d2, d2;
  };
  T_fn = function(e3) {
    if (!__privateGet(this, _S)) return false;
    const t3 = e3;
    return !!t3 && t3 instanceof Promise && t3.hasOwnProperty("__staleWhileFetching") && t3.__abortController instanceof ie;
  };
  F_fn = function(e3, t3) {
    __privateGet(this, _d)[t3] = e3, __privateGet(this, _p)[e3] = t3;
  };
  P_fn = function(e3) {
    e3 !== __privateGet(this, _h) && (e3 === __privateGet(this, _f) ? __privateSet(this, _f, __privateGet(this, _p)[e3]) : __privateMethod(this, _pe_instances, F_fn).call(this, __privateGet(this, _d)[e3], __privateGet(this, _p)[e3]), __privateMethod(this, _pe_instances, F_fn).call(this, __privateGet(this, _h), e3), __privateSet(this, _h, e3));
  };
  let pe = _pe;
  function de() {
    return new pe({ max: arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 500 });
  }
  function fe(e3, t3) {
    return function(e4) {
      const { content: t4, ast: r3 } = e4.template, n3 = he.get(t4);
      if (n3) return n3;
      const s3 = /* @__PURE__ */ new Set();
      return r3.children.forEach(function e5(t5) {
        var r4;
        switch (t5.type) {
          case 1:
            let n4 = t5.tag;
            n4.includes(".") && (n4 = n4.split(".")[0].trim()), o2.parserOptions.isNativeTag(n4) || o2.parserOptions.isBuiltInComponent(n4) || (s3.add(c.camelize(n4)), s3.add(c.capitalize(c.camelize(n4))));
            for (let e6 = 0; e6 < t5.props.length; e6++) {
              const n5 = t5.props[e6];
              7 === n5.type && (c.isBuiltInDirective(n5.name) || s3.add(`v${c.capitalize(c.camelize(n5.name))}`), n5.arg && !n5.arg.isStatic && me(s3, n5.arg), "for" === n5.name ? me(s3, n5.forParseResult.source) : n5.exp && me(s3, n5.exp)), 6 === n5.type && "ref" === n5.name && (null == (r4 = n5.value) ? void 0 : r4.content) && s3.add(n5.value.content);
            }
            t5.children.forEach(e5);
            break;
          case 5:
            me(s3, t5.content);
        }
      }), he.set(t4, s3), s3;
    }(t3).has(e3);
  }
  const he = de();
  function me(e3, t3) {
    t3.ast ? o2.walkIdentifiers(t3.ast, (t4) => e3.add(t4.name)) : null === t3.ast && e3.add(t3.content);
  }
  const ye = "anonymous.vue", ge = de();
  function be(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const r3 = function(e4, t4) {
      var r4;
      return e4 + JSON.stringify({ ...t4, compiler: { parse: null == (r4 = t4.compiler) ? void 0 : r4.parse } }, (e5, t5) => "function" == typeof t5 ? t5.toString() : t5);
    }(e3, t3), n3 = ge.get(r3);
    if (n3) return n3;
    const { sourceMap: s3 = true, filename: o3 = ye, sourceRoot: l2 = "", pad: c2 = false, ignoreEmpty: u2 = true, compiler: p2 = E, templateParseOptions: d2 = {}, parseExpressions: f2 = true } = t3, h2 = { filename: o3, source: e3, template: null, script: null, scriptSetup: null, styles: [], customBlocks: [], cssVars: [], slotted: false, shouldForceReload: (e4) => function(e5, t4) {
      if (!t4.scriptSetup || "ts" !== t4.scriptSetup.lang && "tsx" !== t4.scriptSetup.lang) return false;
      for (const r4 in e5) if (!e5[r4].isUsedInTemplate && fe(r4, t4)) return true;
      return false;
    }(e4, h2) }, m2 = [];
    p2.parse(e3, { parseMode: "sfc", prefixIdentifiers: f2, ...d2, onError: (e4) => {
      m2.push(e4);
    } }).children.forEach((t4) => {
      if (1 === t4.type && (!u2 || "template" === t4.tag || !function(e4) {
        for (let t5 = 0; t5 < e4.children.length; t5++) {
          const r4 = e4.children[t5];
          if (2 !== r4.type || "" !== r4.content.trim()) return false;
        }
        return true;
      }(t4) || function(e4) {
        return e4.props.some((e5) => 6 === e5.type && "src" === e5.name);
      }(t4))) switch (t4.tag) {
        case "template":
          if (h2.template) m2.push(ve(t4));
          else {
            const r5 = h2.template = Ee(t4, e3, false);
            if (r5.attrs.src || (r5.ast = i2.createRoot(t4.children, e3)), r5.attrs.functional) {
              const e4 = new SyntaxError("<template functional> is no longer supported in Vue 3, since functional components no longer have significant performance difference from stateful ones. Just use a normal <template> instead.");
              e4.loc = t4.props.find((e5) => 6 === e5.type && "functional" === e5.name).loc, m2.push(e4);
            }
          }
          break;
        case "script":
          const r4 = Ee(t4, e3, c2), n4 = !!r4.attrs.setup;
          if (n4 && !h2.scriptSetup) {
            h2.scriptSetup = r4;
            break;
          }
          if (!n4 && !h2.script) {
            h2.script = r4;
            break;
          }
          m2.push(ve(t4, n4));
          break;
        case "style":
          const s4 = Ee(t4, e3, c2);
          s4.attrs.vars && m2.push(new SyntaxError("<style vars> has been replaced by a new proposal: https://github.com/vuejs/rfcs/pull/231")), h2.styles.push(s4);
          break;
        default:
          h2.customBlocks.push(Ee(t4, e3, c2));
      }
    }), h2.template || h2.script || h2.scriptSetup || m2.push(new SyntaxError("At least one <template> or <script> is required in a single file component.")), h2.scriptSetup && (h2.scriptSetup.src && (m2.push(new SyntaxError('<script setup> cannot use the "src" attribute because its syntax will be ambiguous outside of the component.')), h2.scriptSetup = null), h2.script && h2.script.src && (m2.push(new SyntaxError('<script> cannot use the "src" attribute when <script setup> is also present because they must be processed together.')), h2.script = null));
    let y2 = 0;
    if (!h2.template || "pug" !== h2.template.lang && "jade" !== h2.template.lang || ([h2.template.content, y2] = function(e4) {
      const t4 = e4.split("\n"), r4 = t4.reduce(function(e5, t5) {
        var r5, n4;
        if ("" === t5.trim()) return e5;
        const s4 = (null == (n4 = null == (r5 = t5.match(/^\s*/)) ? void 0 : r5[0]) ? void 0 : n4.length) || 0;
        return Math.min(s4, e5);
      }, 1 / 0);
      return 0 === r4 ? [e4, r4] : [t4.map(function(e5) {
        return e5.slice(r4);
      }).join("\n"), r4];
    }(h2.template.content)), s3) {
      const t4 = function(t5) {
        let r4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        t5 && !t5.src && (t5.map = function(e4, t6, r5, n4, s4, i3) {
          const o4 = new a2.SourceMapGenerator({ file: e4.replace(/\\/g, "/"), sourceRoot: n4.replace(/\\/g, "/") });
          return o4.setSourceContent(e4, t6), o4._sources.add(e4), r5.split(Se).forEach((t7, r6) => {
            if (!xe.test(t7)) {
              const n5 = r6 + 1 + s4, a3 = r6 + 1;
              for (let r7 = 0; r7 < t7.length; r7++) /\s/.test(t7[r7]) || o4._mappings.add({ originalLine: n5, originalColumn: r7 + i3, generatedLine: a3, generatedColumn: r7, source: e4, name: null });
            }
          }), o4.toJSON();
        }(o3, e3, t5.content, l2, c2 && "template" !== t5.type ? 0 : t5.loc.start.line - 1, r4));
      };
      t4(h2.template, y2), t4(h2.script), h2.styles.forEach((e4) => t4(e4)), h2.customBlocks.forEach((e4) => t4(e4));
    }
    h2.cssVars = function(e4) {
      const t4 = [];
      return e4.styles.forEach((e5) => {
        let r4;
        const n4 = e5.content.replace(/\/\*([\s\S]*?)\*\/|\/\/.*/g, "");
        for (; r4 = Y.exec(n4); ) {
          const e6 = r4.index + r4[0].length, s4 = Q(n4, e6);
          if (null !== s4) {
            const r5 = J(n4.slice(e6, s4));
            t4.includes(r5) || t4.push(r5);
          }
        }
      }), t4;
    }(h2);
    const g2 = /(?:::v-|:)slotted\(/;
    h2.slotted = h2.styles.some((e4) => e4.scoped && g2.test(e4.content));
    const b2 = { descriptor: h2, errors: m2 };
    return ge.set(r3, b2), b2;
  }
  function ve(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    const r3 = new SyntaxError(`Single file component can contain only one <${e3.tag}${t3 ? " setup" : ""}> element`);
    return r3.loc = e3.loc, r3;
  }
  function Ee(e3, t3, r3) {
    const n3 = e3.tag, s3 = e3.innerLoc, i3 = {}, o3 = { type: n3, content: t3.slice(s3.start.offset, s3.end.offset), loc: s3, attrs: i3 };
    return r3 && (o3.content = function(e4, t4, r4) {
      if (e4 = e4.slice(0, t4.loc.start.offset), "space" === r4) return e4.replace(Te, " ");
      {
        const r5 = e4.split(Se).length, n4 = "script" !== t4.type || t4.lang ? "\n" : "//\n";
        return Array(r5).join(n4);
      }
    }(t3, o3, r3) + o3.content), e3.props.forEach((e4) => {
      if (6 === e4.type) {
        const t4 = e4.name;
        i3[t4] = e4.value && e4.value.content || true, "lang" === t4 ? o3.lang = e4.value && e4.value.content : "src" === t4 ? o3.src = e4.value && e4.value.content : "style" === n3 ? "scoped" === t4 ? o3.scoped = true : "module" === t4 && (o3.module = i3[t4]) : "script" === n3 && "setup" === t4 && (o3.setup = i3.setup);
      }
    }), o3;
  }
  const Se = /\r?\n/g, xe = /^(?:\/\/)?\s*$/, Te = /./g;
  function we(e3) {
    const t3 = e3.charAt(0);
    return "." === t3 || "~" === t3 || "@" === t3;
  }
  const Pe = /^(https?:)?\/\//;
  function Ae(e3) {
    return Pe.test(e3);
  }
  const Ce = /^\s*data:/i;
  function Oe(e3) {
    return Ce.test(e3);
  }
  function Ie(e3) {
    if ("~" === e3.charAt(0)) {
      const t3 = e3.charAt(1);
      e3 = e3.slice("/" === t3 ? 2 : 1);
    }
    return _e(e3);
  }
  function _e(e3) {
    return u.parse(c.isString(e3) ? e3 : "", false, true);
  }
  const ke = { base: null, includeAbsolute: false, tags: { video: ["src", "poster"], source: ["src"], img: ["src"], image: ["xlink:href", "href"], use: ["xlink:href", "href"] } }, Ne = (e3) => Object.keys(e3).some((t3) => c.isArray(e3[t3])) ? { ...ke, tags: e3 } : { ...ke, ...e3 }, De = (e3) => (t3, r3) => je(t3, r3, e3), je = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ke;
    if (1 === e3.type) {
      if (!e3.props.length) return;
      const n3 = r3.tags || ke.tags, s3 = n3[e3.tag], o3 = n3["*"];
      if (!s3 && !o3) return;
      const a3 = (s3 || []).concat(o3 || []);
      e3.props.forEach((n4, s4) => {
        if (6 !== n4.type || !a3.includes(n4.name) || !n4.value || Ae(n4.value.content) || Oe(n4.value.content) || "#" === n4.value.content[0] || !r3.includeAbsolute && !we(n4.value.content)) return;
        const o4 = Ie(n4.value.content);
        if (r3.base && "." === n4.value.content[0]) {
          const e4 = Ie(r3.base), t4 = e4.protocol || "", s5 = e4.host ? t4 + "//" + e4.host : "", i3 = e4.path || "/";
          return void (n4.value.content = s5 + (l.posix || l).join(i3, o4.path + (o4.hash || "")));
        }
        const c2 = function(e4, t4, r4, n5) {
          if (e4) {
            let s5, o5;
            const a4 = n5.imports.findIndex((t5) => t5.path === e4);
            if (a4 > -1 ? (s5 = `_imports_${a4}`, o5 = n5.imports[a4].exp) : (s5 = `_imports_${n5.imports.length}`, o5 = i2.createSimpleExpression(s5, false, r4, 3), n5.imports.push({ exp: o5, path: decodeURIComponent(e4) })), !t4) return o5;
            const l2 = `${s5} + '${t4}'`, c3 = i2.createSimpleExpression(l2, false, r4, 3);
            if (!n5.hoistStatic) return c3;
            const u2 = n5.hoists.findIndex((e5) => e5 && 4 === e5.type && !e5.isStatic && e5.content === l2);
            return u2 > -1 ? i2.createSimpleExpression(`_hoisted_${u2 + 1}`, false, r4, 3) : n5.hoist(c3);
          }
          return i2.createSimpleExpression("''", false, r4, 3);
        }(o4.path, o4.hash, n4.loc, t3);
        e3.props[s4] = { type: 7, name: "bind", arg: i2.createSimpleExpression(n4.name, true, n4.loc), exp: c2, modifiers: [], loc: n4.loc };
      });
    }
  }, Le = ["img", "source"], Me = /( |\\t|\\n|\\f|\\r)+/g, Be = (e3) => (t3, r3) => Re(t3, r3, e3), Re = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ke;
    1 === e3.type && Le.includes(e3.tag) && e3.props.length && e3.props.forEach((n3, s3) => {
      if ("srcset" === n3.name && 6 === n3.type) {
        if (!n3.value) return;
        const o3 = n3.value.content;
        if (!o3) return;
        const a3 = o3.split(",").map((e4) => {
          const [t4, r4] = e4.replace(Me, " ").trim().split(" ", 2);
          return { url: t4, descriptor: r4 };
        });
        for (let e4 = 0; e4 < a3.length; e4++) {
          const { url: t4 } = a3[e4];
          Oe(t4) && (a3[e4 + 1].url = t4 + "," + a3[e4 + 1].url, a3.splice(e4, 1));
        }
        const c2 = (e4) => !Ae(e4) && !Oe(e4) && (r3.includeAbsolute || we(e4));
        if (!a3.some((e4) => {
          let { url: t4 } = e4;
          return c2(t4);
        })) return;
        if (r3.base) {
          const e4 = r3.base, t4 = [];
          let s4 = false;
          if (a3.forEach((r4) => {
            let { url: n4, descriptor: i3 } = r4;
            i3 = i3 ? ` ${i3}` : "", "." === n4[0] ? (r4.url = (l.posix || l).join(e4, n4), t4.push(r4.url + i3)) : c2(n4) ? s4 = true : t4.push(n4 + i3);
          }), !s4) return void (n3.value.content = t4.join(", "));
        }
        const u2 = i2.createCompoundExpression([], n3.loc);
        a3.forEach((e4, r4) => {
          let { url: s4, descriptor: o4 } = e4;
          if (c2(s4)) {
            const { path: e5 } = Ie(s4);
            let r5;
            if (e5) {
              const s5 = t3.imports.findIndex((t4) => t4.path === e5);
              s5 > -1 ? r5 = i2.createSimpleExpression(`_imports_${s5}`, false, n3.loc, 3) : (r5 = i2.createSimpleExpression(`_imports_${t3.imports.length}`, false, n3.loc, 3), t3.imports.push({ exp: r5, path: e5 })), u2.children.push(r5);
            }
          } else {
            const e5 = i2.createSimpleExpression(`"${s4}"`, false, n3.loc, 3);
            u2.children.push(e5);
          }
          const l2 = a3.length - 1 > r4;
          o4 && l2 ? u2.children.push(` + ' ${o4}, ' + `) : o4 ? u2.children.push(` + ' ${o4}'`) : l2 && u2.children.push(" + ', ' + ");
        });
        let p2 = u2;
        t3.hoistStatic && (p2 = t3.hoist(u2), p2.constType = 3), e3.props[s3] = { type: 7, name: "bind", arg: i2.createSimpleExpression("srcset", true, n3.loc), exp: p2, modifiers: [], loc: n3.loc };
      }
    });
  };
  function Fe(e3) {
    throw new Error('Could not dynamically require "' + e3 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var Ue = { exports: {} };
  !function(e3, t3) {
    var s3 = f, i3 = l, o3 = d, a3 = i3.join, c2 = i3.resolve, u2 = i3.extname, p2 = i3.dirname, h2 = i3.isAbsolute, m2 = {}, y2 = {}, g2 = {};
    function b2(e4, t4) {
      return t4 && e4.filename && e4.cache ? (delete m2[e4.filename], y2[e4.filename] = t4, t4) : e4.filename && e4.cache ? y2[e4.filename] : t4;
    }
    function v2(e4, t4, r3) {
      var n3 = m2[e4];
      if (t4.cache && n3 && "string" == typeof n3) return r3(null, n3);
      s3.readFile(e4, "utf8", function(n4, s4) {
        if (n4) return r3(n4);
        s4 = s4.replace(/^\uFEFF/, ""), t4.cache && (m2[e4] = s4), r3(null, s4);
      });
    }
    function E2(e4, t4) {
      return new Promise(function(r3, n3) {
        t4(e4 = e4 || function(e5, t5) {
          if (e5) return n3(e5);
          r3(t5);
        });
      });
    }
    function S2(e4) {
      return function(r3, n3, s4) {
        return n3.filename = r3, E2(s4, function(s5) {
          !function(e5, t4, r4) {
            if (!t4.partials) return r4();
            var n4 = Object.keys(t4.partials), s6 = {};
            !function i4(o4) {
              if (o4 === n4.length) return r4(null, s6);
              var l2 = n4[o4], c3 = t4.partials[l2];
              if (null == c3 || false === c3) return i4(++o4);
              v2(h2(c3) ? "" !== u2(c3) ? c3 : a3(c3 + u2(e5)) : a3(p2(e5), c3 + u2(e5)), t4, function(e6, t5) {
                if (e6) return r4(e6);
                s6[l2] = t5, i4(++o4);
              });
            }(0);
          }(r3, n3, function(i4, o4) {
            var a4 = (g2.extend || (g2.extend = d._extend))({}, n3);
            if (a4.partials = o4, i4) return s5(i4);
            b2(a4) ? t3[e4].render("", a4, s5) : v2(r3, a4, function(r4, n4) {
              if (r4) return s5(r4);
              t3[e4].render(n4, a4, s5);
            });
          });
        });
      };
    }
    function x2(e4, t4) {
      var n3 = (g2.babel || (g2.babel = r2(341))).transformFileSync(t4, { presets: ["react"] }).code;
      return e4._compile(n3, t4);
    }
    function T2(t4) {
      return Fe.extensions && (Fe.extensions[".jsx"] || (Fe.extensions[".jsx"] = x2), Fe.extensions[".react"] || (Fe.extensions[".react"] = x2)), function(n3, i4, o4) {
        return E2(o4, function(o5) {
          var a4 = g2.ReactDOM || (g2.ReactDOM = r2(547)), l2 = g2.react || (g2.react = r2(548)), u3 = i4.base;
          delete i4.base;
          var p3 = i4.cache;
          delete i4.cache;
          var d2 = i4.isNonStatic;
          delete i4.isNonStatic;
          try {
            var f2, h3, y3, v3, E3;
            if (b2(i4)) h3 = b2(i4);
            else {
              if ("path" === t4) {
                var S3 = c2(n3);
                delete r2.c[S3], f2 = Fe(S3);
              } else f2 = function(t5, n4) {
                var s4 = g2.babel || (g2.babel = r2(341));
                n4 || (n4 = "");
                var i5 = new e3.constructor();
                n4 = n4 || "";
                var o6 = s4.transform(t5, { presets: ["react"] }).code;
                return i5.paths = e3.paths, i5._compile(o6, n4), i5.exports;
              }(n3);
              h3 = b2(i4, l2.createFactory(f2));
            }
            E3 = new h3(i4), v3 = d2 ? a4.renderToString(E3) : a4.renderToStaticMarkup(E3), u3 && (y3 = m2[n3] || s3.readFileSync(c2(u3), "utf8"), p3 && (m2[n3] = y3), i4.content = v3, v3 = function(e4, t5) {
              var r3;
              for (var n4 in t5) t5.hasOwnProperty(n4) && (r3 = new RegExp("{{" + n4 + "}}", "g"), e4.match(r3) && (e4 = e4.replace(r3, t5[n4])));
              return e4;
            }(y3, i4)), o5(null, v3);
          } catch (e4) {
            o5(e4);
          }
        });
      };
    }
    t3.clearCache = function() {
      m2 = {}, y2 = {};
    }, t3.velocityjs = S2("velocityjs"), t3.velocityjs.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.velocityjs || (g2.velocityjs = r2(514));
        try {
          t4.locals = t4, n4(null, s4.render(e4, t4).trimLeft());
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.liquid = S2("liquid"), t3.liquid.render = function(e4, t4, o4) {
      return E2(o4, function(o5) {
        var a4, l2 = g2.liquid;
        try {
          return void function(e5, t5, r3, o6) {
            var a5, l3 = e5.newContext();
            if (r3.locals) {
              for (a5 in r3.locals) l3.setLocals(a5, r3.locals[a5]);
              delete r3.locals;
            }
            if (r3.meta && (l3.setLocals("page", r3.meta), delete r3.meta), r3.filters) {
              for (a5 in r3.filters) l3.setFilter(a5, r3.filters[a5]);
              delete r3.filters;
            }
            var c4 = r3.includeDir || n2.cwd();
            l3.onInclude(function(t6, r4) {
              var n3 = i3.extname(t6) ? "" : ".liquid", o7 = i3.resolve(c4, t6 + n3);
              s3.readFile(o7, { encoding: "utf8" }, function(t7, n4) {
                if (t7) return r4(t7);
                r4(null, e5.parse(n4));
              });
            }), delete r3.includeDir;
            var u4 = { customTags: {} };
            if (r3.customTags) {
              var p4 = r3.customTags;
              for (a5 in r3.customTags) u4.customTags[a5] = function(t6, r4, n3) {
                var s4 = p4[r4](n3.trim());
                t6.astStack.push(e5.parse(s4));
              };
              delete r3.customTags;
            }
            for (a5 in r3) l3.setLocals(a5, r3[a5]);
            (b2(l3) || b2(l3, e5.compile(t5, u4)))(l3, o6);
          }(l2 = g2.liquid = r2(515), e4, t4, o5);
        } catch (e5) {
          try {
            l2 = new (a4 = g2.liquid = r2(516)).Engine();
          } catch (e6) {
            throw e6;
          }
        }
        try {
          var c3 = t4.locals || {};
          t4.meta && (c3.pages = t4.meta, delete t4.meta), t4.filters && (l2.registerFilters(t4.filters), delete t4.filters);
          var u3 = t4.includeDir || n2.cwd();
          if (l2.fileSystem = new a4.LocalFileSystem(u3, "liquid"), delete t4.includeDir, t4.customTags) {
            var p3 = t4.customTags;
            for (d2 in t4.customTags) l2.registerTag(d2, p3[d2]);
            delete t4.customTags;
          }
          for (var d2 in t4) c3[d2] = t4[d2];
          return l2.parseAndRender(e4, c3).nodeify(function(e5, t5) {
            if (e5) throw new Error(e5);
            return o5(null, t5);
          });
        } catch (e5) {
          o5(e5);
        }
      });
    }, t3.jade = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.jade;
        if (!s4) try {
          s4 = g2.jade = r2(332);
        } catch (e5) {
          try {
            s4 = g2.jade = r2(333);
          } catch (t5) {
            throw e5;
          }
        }
        try {
          n4(null, (b2(t4) || b2(t4, s4.compileFile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.jade.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.jade;
        if (!s4) try {
          s4 = g2.jade = r2(332);
        } catch (e5) {
          try {
            s4 = g2.jade = r2(333);
          } catch (t5) {
            throw e5;
          }
        }
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.dust = S2("dust"), t3.dust.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.dust;
        if (!s4) try {
          s4 = g2.dust = r2(517);
        } catch (e5) {
          try {
            s4 = g2.dust = r2(518);
          } catch (e6) {
            s4 = g2.dust = r2(519);
          }
        }
        var i4 = "dust", o4 = ".";
        t4 && (t4.ext && (i4 = t4.ext), t4.views && (o4 = t4.views), t4.settings && t4.settings.views && (o4 = t4.settings.views)), (!t4 || t4 && !t4.cache) && (s4.cache = {}), s4.onLoad = function(e5, r3) {
          "" === u2(e5) && (e5 += "." + i4), "/" !== e5[0] && (e5 = o4 + "/" + e5), v2(e5, t4, r3);
        };
        try {
          var a4;
          t4.filename && (a4 = t4.filename.replace(new RegExp("^" + o4 + "/"), "").replace(new RegExp("\\." + i4), "")), (b2(t4) || b2(t4, s4.compileFn(e4, a4)))(t4, n4);
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.swig = S2("swig"), t3.swig.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.swig;
        if (!s4) try {
          s4 = g2.swig = r2(520);
        } catch (e5) {
          try {
            s4 = g2.swig = r2(521);
          } catch (t5) {
            throw e5;
          }
        }
        try {
          true === t4.cache && (t4.cache = "memory"), s4.setDefaults({ cache: t4.cache }), n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.razor = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.razor;
        if (!s4) try {
          s4 = g2.razor = r2(334);
        } catch (e5) {
          throw e5;
        }
        try {
          n4(null, (b2(t4) || b2(t4, (t5) => s4.renderFileSync(e4, t5)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.razor.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        try {
          var s4 = g2.razor = r2(334);
        } catch (e5) {
          throw e5;
        }
        try {
          var i4 = s4.compile(e4);
          n4(null, (b2(t4) || b2(t4, i4))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.atpl = S2("atpl"), t3.atpl.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.atpl || (g2.atpl = r2(522));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.liquor = S2("liquor"), t3.liquor.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.liquor || (g2.liquor = r2(523));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.twig = S2("twig"), t3.twig.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.twig || (g2.twig = r2(524).twig), i4 = { data: e4, allowInlineIncludes: t4.allowInlineIncludes, namespaces: t4.namespaces, path: t4.path };
        try {
          n4(null, (b2(i4) || b2(i4, s4(i4))).render(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.ejs = S2("ejs"), t3.ejs.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.ejs || (g2.ejs = r2(525));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.eco = S2("eco"), t3.eco.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.eco || (g2.eco = r2(526));
        try {
          n4(null, s4.render(e4, t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.jazz = S2("jazz"), t3.jazz.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.jazz || (g2.jazz = r2(527));
        try {
          (b2(t4) || b2(t4, s4.compile(e4, t4))).eval(t4, function(e5) {
            n4(null, e5);
          });
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.jqtpl = S2("jqtpl"), t3.jqtpl.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.jqtpl || (g2.jqtpl = r2(528));
        try {
          s4.template(e4, e4), n4(null, s4.tmpl(e4, t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.haml = S2("haml"), t3.haml.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.haml || (g2.haml = r2(529));
        try {
          t4.locals = t4, n4(null, s4.render(e4, t4).trimLeft());
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.hamlet = S2("hamlet"), t3.hamlet.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.hamlet || (g2.hamlet = r2(530));
        try {
          t4.locals = t4, n4(null, s4.render(e4, t4).trimLeft());
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.whiskers = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        (g2.whiskers || (g2.whiskers = r2(335))).__express(e4, t4, n4);
      });
    }, t3.whiskers.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.whiskers || (g2.whiskers = r2(335));
        try {
          n4(null, s4.render(e4, t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3["haml-coffee"] = S2("haml-coffee"), t3["haml-coffee"].render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2["haml-coffee"] || (g2["haml-coffee"] = r2(531));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.hogan = S2("hogan"), t3.hogan.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.hogan || (g2.hogan = r2(532));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4))).render(t4, t4.partials));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.templayed = S2("templayed"), t3.templayed.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.templayed || (g2.templayed = r2(533));
        try {
          n4(null, (b2(t4) || b2(t4, s4(e4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.handlebars = S2("handlebars"), t3.handlebars.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.handlebars || (g2.handlebars = r2(534));
        try {
          for (var i4 in t4.partials) s4.registerPartial(i4, t4.partials[i4]);
          for (var o4 in t4.helpers) s4.registerHelper(o4, t4.helpers[o4]);
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.underscore = S2("underscore"), t3.underscore.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.underscore || (g2.underscore = r2(535));
        try {
          const r3 = {};
          for (var i4 in t4.partials) r3[i4] = s4.template(t4.partials[i4]);
          t4.partials = r3, n4(null, (b2(t4) || b2(t4, s4.template(e4, null, t4)))(t4).replace(/\n$/, ""));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.lodash = S2("lodash"), t3.lodash.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.lodash || (g2.lodash = r2(536));
        try {
          n4(null, (b2(t4) || b2(t4, s4.template(e4, t4)))(t4).replace(/\n$/, ""));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.pug = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.pug;
        if (!s4) try {
          s4 = g2.pug = r2(336);
        } catch (e5) {
          try {
            s4 = g2.pug = r2(337);
          } catch (t5) {
            throw e5;
          }
        }
        try {
          n4(null, (b2(t4) || b2(t4, s4.compileFile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.pug.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.pug;
        if (!s4) try {
          s4 = g2.pug = r2(336);
        } catch (e5) {
          try {
            s4 = g2.pug = r2(337);
          } catch (t5) {
            throw e5;
          }
        }
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.qejs = S2("qejs"), t3.qejs.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        try {
          (g2.qejs || (g2.qejs = r2(537))).render(e4, t4).then(function(e5) {
            n4(null, e5);
          }, function(e5) {
            n4(e5);
          }).done();
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.walrus = S2("walrus"), t3.walrus.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.walrus || (g2.walrus = r2(538));
        try {
          n4(null, (b2(t4) || b2(t4, s4.parse(e4))).compile(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.mustache = S2("mustache"), t3.mustache.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.mustache || (g2.mustache = r2(539));
        try {
          n4(null, s4.render(e4, t4, t4.partials));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.just = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.just;
        if (!s4) {
          var i4 = r2(338);
          s4 = g2.just = new i4();
        }
        s4.configure({ useCache: t4.cache }), s4.render(e4, t4, n4);
      });
    }, t3.just.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        new (r2(338))({ root: { page: e4 } }).render("page", t4, n4);
      });
    }, t3.ect = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.ect;
        if (!s4) {
          var i4 = r2(339);
          s4 = g2.ect = new i4(t4);
        }
        s4.configure({ cache: t4.cache }), s4.render(e4, t4, n4);
      });
    }, t3.ect.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        new (r2(339))({ root: { page: e4 } }).render("page", t4, n4);
      });
    }, t3.mote = S2("mote"), t3.mote.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.mote || (g2.mote = r2(540));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.toffee = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        (g2.toffee || (g2.toffee = r2(340))).__consolidate_engine_render(e4, t4, n4);
      });
    }, t3.toffee.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.toffee || (g2.toffee = r2(340));
        try {
          s4.str_render(e4, t4, n4);
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.dot = S2("dot"), t3.dot.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.dot || (g2.dot = r2(541)), i4 = g2.extend || (g2.extend = d._extend);
        try {
          var o4 = {};
          o4 = i4(o4, s4.templateSettings), o4 = i4(o4, t4 ? t4.dot : {}), n4(null, (b2(t4) || b2(t4, s4.template(e4, o4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.bracket = S2("bracket"), t3.bracket.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.bracket || (g2.bracket = r2(542));
        try {
          n4(null, (b2(t4) || b2(t4, s4.default.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.ractive = S2("ractive"), t3.ractive.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.ractive || (g2.ractive = r2(543)), i4 = b2(t4) || b2(t4, s4.parse(e4));
        if (t4.template = i4, null === t4.data || void 0 === t4.data) {
          var o4, a4, l2 = g2.extend || (g2.extend = d._extend);
          t4.data = l2({}, t4);
          var c3 = ["template", "filename", "cache", "partials"];
          for (o4 = 0, a4 = c3.length; o4 < a4; o4++) {
            var u3 = c3[o4];
            delete t4.data[u3];
          }
        }
        try {
          n4(null, new s4(t4).toHTML());
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.nunjucks = S2("nunjucks"), t3.nunjucks.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        try {
          var s4 = t4.nunjucksEnv || g2.nunjucks || (g2.nunjucks = r2(544)), i4 = s4;
          t4.settings && t4.settings.views ? i4 = s4.configure(t4.settings.views) : t4.nunjucks && t4.nunjucks.configure && (i4 = s4.configure.apply(s4, t4.nunjucks.configure)), t4.loader ? i4 = new s4.Environment(t4.loader) : t4.settings && t4.settings.views ? i4 = new s4.Environment(new s4.FileSystemLoader(t4.settings.views)) : t4.nunjucks && t4.nunjucks.loader && (i4 = "string" == typeof t4.nunjucks.loader ? new s4.Environment(new s4.FileSystemLoader(t4.nunjucks.loader)) : new s4.Environment(new s4.FileSystemLoader(t4.nunjucks.loader[0], t4.nunjucks.loader[1]))), i4.renderString(e4, t4, n4);
        } catch (e5) {
          throw n4(e5);
        }
      });
    }, t3.htmling = S2("htmling"), t3.htmling.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.htmling || (g2.htmling = r2(545));
        try {
          n4(null, (b2(t4) || b2(t4, s4.string(e4))).render(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.requireReact = x2, t3.plates = S2("plates"), t3.plates.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.plates || (g2.plates = r2(546)), i4 = t4.map || void 0;
        try {
          n4(null, s4.bind(e4, t4, i4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.react = T2("path"), t3.react.render = T2("string"), t3["arc-templates"] = S2("arc-templates"), t3["arc-templates"].render = function(e4, t4, n3) {
      var s4 = o3.promisify(v2), i4 = { readFile: function(e5) {
        return s4(e5, t4);
      } };
      return E2(n3, function(n4) {
        try {
          var s5 = g2["arc-templates"];
          if (!s5) {
            var o4 = r2(549);
            s5 = g2["arc-templates"] = new o4({ filesystem: i4 });
          }
          (b2(t4) || b2(t4, s5.compileString(e4, t4.filename))).then(function(e5) {
            return e5(t4);
          }).then(function(e5) {
            n4(null, e5.content);
          }).catch(n4);
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.vash = S2("vash"), t3.vash.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.vash || (g2.vash = r2(550));
        try {
          if (t4.helpers) for (var i4 in t4.helpers) t4.helpers.hasOwnProperty(i4) && "function" == typeof t4.helpers[i4] && (s4.helpers[i4] = t4.helpers[i4]);
          (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4, function(e5, t5) {
            e5 && n4(e5), t5.finishLayout(), n4(null, t5.toString().replace(/\n$/, ""));
          });
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.slm = S2("slm"), t3.slm.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.slm || (g2.slm = r2(551));
        try {
          n4(null, (b2(t4) || b2(t4, s4.compile(e4, t4)))(t4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.marko = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.marko || (g2.marko = r2(342));
        t4.writeToDisk = !!t4.cache;
        try {
          (b2(t4) || b2(t4, s4.load(e4, t4))).renderToString(t4, n4);
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.marko.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.marko || (g2.marko = r2(342));
        t4.writeToDisk = !!t4.cache, t4.filename = t4.filename || "string.marko";
        try {
          (b2(t4) || b2(t4, s4.load(t4.filename, e4, t4))).renderToString(t4, n4);
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.teacup = function(e4, t4, s4) {
      return E2(s4, function(s5) {
        var i4 = g2.teacup || (g2.teacup = r2(552));
        if (Fe.extensions[".teacup"] = Fe.extensions[".coffee"], "/" !== e4[0] && (e4 = a3(n2.cwd(), e4)), !t4.cache) {
          var o4 = s5;
          s5 = function() {
            delete r2.c[e4], o4.apply(this, arguments);
          };
        }
        i4.renderFile(e4, t4, s5);
      });
    }, t3.teacup.render = function(e4, t4, n3) {
      var s4 = r2(553), i4 = r2(554), o4 = { module: { exports: {} }, require: Fe };
      return E2(n3, function(r3) {
        i4.runInNewContext(s4.compile(e4), o4), r3(null, (0, o4.module.exports)(t4));
      });
    }, t3.squirrelly = S2("squirrelly"), t3.squirrelly.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.squirrelly || (g2.squirrelly = r2(555));
        try {
          for (var i4 in t4.partials) s4.definePartial(i4, t4.partials[i4]);
          for (var o4 in t4.helpers) s4.defineHelper(o4, t4.helpers[o4]);
          n4(null, (b2(t4) || b2(t4, s4.Compile(e4, t4)))(t4, s4));
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.twing = S2("twing"), t3.twing.render = function(e4, t4, n3) {
      return E2(n3, function(n4) {
        var s4 = g2.twing || (g2.twing = r2(556));
        try {
          new s4.TwingEnvironment(new s4.TwingLoaderNull()).createTemplate(e4).then((e5) => {
            e5.render(t4).then((e6) => {
              var r3 = b2(t4) || b2(t4, e6);
              n4(null, r3);
            });
          });
        } catch (e5) {
          n4(e5);
        }
      });
    }, t3.requires = g2;
  }(Ue, Ue.exports);
  var $e = q(Ue.exports);
  const Ve = {};
  function qe(e3) {
    void 0 !== n2 || Ve[e3] || (Ve[e3] = true);
  }
  function We(e3, t3) {
    let { source: r3, filename: n3, preprocessOptions: s3 } = e3, i3 = "", o3 = null;
    if (t3.render(r3, { filename: n3, ...s3 }, (e4, t4) => {
      e4 && (o3 = e4), i3 = t4;
    }), o3) throw o3;
    return i3;
  }
  function Ge(e3) {
    const { preprocessLang: t3, preprocessCustomRequire: r3 } = e3, n3 = !!t3 && (r3 ? r3(t3) : $e[t3]);
    if (!n3) return t3 ? { code: "export default function render() {}", source: e3.source, tips: [`Component ${e3.filename} uses lang ${t3} for template. Please install the language preprocessor.`], errors: [`Component ${e3.filename} uses lang ${t3} for template, however it is not installed.`] } : He(e3);
    try {
      return He({ ...e3, source: We(e3, n3), ast: void 0 });
    } catch (t4) {
      return { code: "export default function render() {}", source: e3.source, tips: [], errors: [t4] };
    }
  }
  function He(e3) {
    let { filename: t3, id: r3, scoped: n3, slotted: s3, inMap: o3, source: l2, ast: u2, ssr: p2 = false, ssrCssVars: d2, isProd: f2 = false, compiler: h2, compilerOptions: m2 = {}, transformAssetUrls: y2 } = e3;
    const g2 = [], b2 = [];
    let v2 = [];
    if (c.isObject(y2)) {
      const e4 = Ne(y2);
      v2 = [De(e4), Be(e4)];
    } else false !== y2 && (v2 = [je, Re]);
    p2 && !d2 && qe("compileTemplate is called with `ssr: true` but no corresponding `cssVars` option.`."), r3 || (qe("compileTemplate now requires the `id` option.`."), r3 = "");
    const x2 = r3.replace(/^data-v-/, ""), T2 = `data-v-${x2}`, w2 = p2 ? S : E;
    if (h2 = h2 || w2, h2 !== w2 && (u2 = void 0), null == u2 ? void 0 : u2.transformed) {
      const e4 = (p2 ? E : h2).parse(u2.source, { prefixIdentifiers: true, ...m2, parseMode: "sfc", onError: (e5) => g2.push(e5) }).children.find((e5) => 1 === e5.type && "template" === e5.tag);
      u2 = i2.createRoot(e4.children, u2.source);
    }
    let { code: P2, ast: A2, preamble: C2, map: O2 } = h2.compile(u2 || l2, { mode: "module", prefixIdentifiers: true, hoistStatic: true, cacheHandlers: true, ssrCssVars: p2 && d2 && d2.length ? K(d2, x2, f2, true) : "", scopeId: n3 ? T2 : void 0, slotted: s3, sourceMap: true, ...m2, hmr: !f2, nodeTransforms: v2.concat(m2.nodeTransforms || []), filename: t3, onError: (e4) => g2.push(e4), onWarn: (e4) => b2.push(e4) });
    o3 && !u2 && (O2 && (O2 = function(e4, t4) {
      if (!e4) return t4;
      if (!t4) return e4;
      const r4 = new a2.SourceMapConsumer(e4), n4 = new a2.SourceMapConsumer(t4), s4 = new a2.SourceMapGenerator();
      n4.eachMapping((e5) => {
        if (null == e5.originalLine) return;
        const t5 = r4.originalPositionFor({ line: e5.originalLine, column: e5.originalColumn });
        null != t5.source && s4.addMapping({ generated: { line: e5.generatedLine, column: e5.generatedColumn }, original: { line: t5.line, column: e5.originalColumn }, source: t5.source, name: t5.name });
      });
      const i3 = s4;
      return r4.sources.forEach((e5) => {
        i3._sources.add(e5);
        const t5 = r4.sourceContentFor(e5);
        null != t5 && s4.setSourceContent(e5, t5);
      }), i3._sourceRoot = e4.sourceRoot, i3._file = e4.file, i3.toJSON();
    }(o3, O2)), g2.length && function(e4, t4, r4) {
      const n4 = r4.sourcesContent[0], s4 = n4.indexOf(t4), i3 = n4.slice(0, s4).split(/\r?\n/).length - 1;
      e4.forEach((e5) => {
        e5.loc && (e5.loc.start.line += i3, e5.loc.start.offset += s4, e5.loc.end !== e5.loc.start && (e5.loc.end.line += i3, e5.loc.end.offset += s4));
      });
    }(g2, l2, o3));
    const I2 = b2.map((e4) => {
      let t4 = e4.message;
      return e4.loc && (t4 += `
${c.generateCodeFrame((null == u2 ? void 0 : u2.source) || l2, e4.loc.start.offset, e4.loc.end.offset)}`), t4;
    });
    return { code: P2, ast: A2, preamble: C2, source: l2, errors: g2, tips: I2, map: O2 };
  }
  const ze = () => ({ postcssPlugin: "vue-sfc-trim", Once(e3) {
    e3.walk((e4) => {
      let { type: t3, raws: r3 } = e4;
      "rule" !== t3 && "atrule" !== t3 || (r3.before && (r3.before = "\n"), "after" in r3 && r3.after && (r3.after = "\n"));
    });
  } });
  ze.postcss = true;
  var Ke = ze, Xe = { exports: {} }, Je = { exports: {} }, Ye = { exports: {} }, Qe = { exports: {} }, Ze = { exports: {} }, et = { exports: {} }, tt = {}, rt = { exports: {} };
  !function(e3, t3) {
    function r3(e4) {
      for (var t4 = e4.toLowerCase(), r4 = "", n4 = false, s3 = 0; s3 < 6 && void 0 !== t4[s3]; s3++) {
        var i3 = t4.charCodeAt(s3);
        if (n4 = 32 === i3, !(i3 >= 97 && i3 <= 102 || i3 >= 48 && i3 <= 57)) break;
        r4 += t4[s3];
      }
      if (0 !== r4.length) {
        var o3 = parseInt(r4, 16);
        return o3 >= 55296 && o3 <= 57343 || 0 === o3 || o3 > 1114111 ? ["", r4.length + (n4 ? 1 : 0)] : [String.fromCodePoint(o3), r4.length + (n4 ? 1 : 0)];
      }
    }
    t3.__esModule = true, t3.default = function(e4) {
      if (!n3.test(e4)) return e4;
      for (var t4 = "", s3 = 0; s3 < e4.length; s3++) if ("\\" !== e4[s3]) t4 += e4[s3];
      else {
        var i3 = r3(e4.slice(s3 + 1, s3 + 7));
        if (void 0 !== i3) {
          t4 += i3[0], s3 += i3[1];
          continue;
        }
        if ("\\" === e4[s3 + 1]) {
          t4 += "\\", s3++;
          continue;
        }
        e4.length === s3 + 1 && (t4 += e4[s3]);
      }
      return t4;
    };
    var n3 = /\\/;
    e3.exports = t3.default;
  }(rt, rt.exports);
  var nt = rt.exports, st = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = function(e4) {
      for (var t4 = arguments.length, r3 = new Array(t4 > 1 ? t4 - 1 : 0), n3 = 1; n3 < t4; n3++) r3[n3 - 1] = arguments[n3];
      for (; r3.length > 0; ) {
        var s3 = r3.shift();
        if (!e4[s3]) return;
        e4 = e4[s3];
      }
      return e4;
    }, e3.exports = t3.default;
  }(st, st.exports);
  var it = st.exports, ot = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = function(e4) {
      for (var t4 = arguments.length, r3 = new Array(t4 > 1 ? t4 - 1 : 0), n3 = 1; n3 < t4; n3++) r3[n3 - 1] = arguments[n3];
      for (; r3.length > 0; ) {
        var s3 = r3.shift();
        e4[s3] || (e4[s3] = {}), e4 = e4[s3];
      }
    }, e3.exports = t3.default;
  }(ot, ot.exports);
  var at = ot.exports, lt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = function(e4) {
      for (var t4 = "", r3 = e4.indexOf("/*"), n3 = 0; r3 >= 0; ) {
        t4 += e4.slice(n3, r3);
        var s3 = e4.indexOf("*/", r3 + 2);
        if (s3 < 0) return t4;
        n3 = s3 + 2, r3 = e4.indexOf("/*", n3);
      }
      return t4 += e4.slice(n3);
    }, e3.exports = t3.default;
  }(lt, lt.exports);
  var ct = lt.exports;
  tt.__esModule = true, tt.unesc = tt.stripComments = tt.getProp = tt.ensureObject = void 0;
  var ut = ht(nt);
  tt.unesc = ut.default;
  var pt = ht(it);
  tt.getProp = pt.default;
  var dt = ht(at);
  tt.ensureObject = dt.default;
  var ft = ht(ct);
  function ht(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  }
  tt.stripComments = ft.default, function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3 = tt;
    function n3(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    var s3 = function e4(t4, r4) {
      if ("object" != typeof t4 || null === t4) return t4;
      var n4 = new t4.constructor();
      for (var s4 in t4) if (t4.hasOwnProperty(s4)) {
        var i4 = t4[s4];
        "parent" === s4 && "object" == typeof i4 ? r4 && (n4[s4] = r4) : n4[s4] = i4 instanceof Array ? i4.map(function(t5) {
          return e4(t5, n4);
        }) : e4(i4, n4);
      }
      return n4;
    }, i3 = function() {
      function e4(e5) {
        void 0 === e5 && (e5 = {}), Object.assign(this, e5), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
      }
      var t4, i4, o3 = e4.prototype;
      return o3.remove = function() {
        return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
      }, o3.replaceWith = function() {
        if (this.parent) {
          for (var e5 in arguments) this.parent.insertBefore(this, arguments[e5]);
          this.remove();
        }
        return this;
      }, o3.next = function() {
        return this.parent.at(this.parent.index(this) + 1);
      }, o3.prev = function() {
        return this.parent.at(this.parent.index(this) - 1);
      }, o3.clone = function(e5) {
        void 0 === e5 && (e5 = {});
        var t5 = s3(this);
        for (var r4 in e5) t5[r4] = e5[r4];
        return t5;
      }, o3.appendToPropertyAndEscape = function(e5, t5, r4) {
        this.raws || (this.raws = {});
        var n4 = this[e5], s4 = this.raws[e5];
        this[e5] = n4 + t5, s4 || r4 !== t5 ? this.raws[e5] = (s4 || n4) + r4 : delete this.raws[e5];
      }, o3.setPropertyAndEscape = function(e5, t5, r4) {
        this.raws || (this.raws = {}), this[e5] = t5, this.raws[e5] = r4;
      }, o3.setPropertyWithoutEscape = function(e5, t5) {
        this[e5] = t5, this.raws && delete this.raws[e5];
      }, o3.isAtPosition = function(e5, t5) {
        if (this.source && this.source.start && this.source.end) return !(this.source.start.line > e5 || this.source.end.line < e5 || this.source.start.line === e5 && this.source.start.column > t5 || this.source.end.line === e5 && this.source.end.column < t5);
      }, o3.stringifyProperty = function(e5) {
        return this.raws && this.raws[e5] || this[e5];
      }, o3.valueToString = function() {
        return String(this.stringifyProperty("value"));
      }, o3.toString = function() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      }, t4 = e4, (i4 = [{ key: "rawSpaceBefore", get: function() {
        var e5 = this.raws && this.raws.spaces && this.raws.spaces.before;
        return void 0 === e5 && (e5 = this.spaces && this.spaces.before), e5 || "";
      }, set: function(e5) {
        (0, r3.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = e5;
      } }, { key: "rawSpaceAfter", get: function() {
        var e5 = this.raws && this.raws.spaces && this.raws.spaces.after;
        return void 0 === e5 && (e5 = this.spaces.after), e5 || "";
      }, set: function(e5) {
        (0, r3.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = e5;
      } }]) && n3(t4.prototype, i4), Object.defineProperty(t4, "prototype", { writable: false }), e4;
    }();
    t3.default = i3, e3.exports = t3.default;
  }(et, et.exports);
  var mt = et.exports, yt = { __esModule: true };
  yt.UNIVERSAL = yt.TAG = yt.STRING = yt.SELECTOR = yt.ROOT = yt.PSEUDO = yt.NESTING = yt.ID = yt.COMMENT = yt.COMBINATOR = yt.CLASS = yt.ATTRIBUTE = void 0, yt.TAG = "tag", yt.STRING = "string", yt.SELECTOR = "selector", yt.ROOT = "root", yt.PSEUDO = "pseudo", yt.NESTING = "nesting", yt.ID = "id", yt.COMMENT = "comment", yt.COMBINATOR = "combinator", yt.CLASS = "class", yt.ATTRIBUTE = "attribute", yt.UNIVERSAL = "universal", function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = mt) && r3.__esModule ? r3 : { default: r3 }, s3 = function(e4, t4) {
      if (e4 && e4.__esModule) return e4;
      if (null === e4 || "object" != typeof e4 && "function" != typeof e4) return { default: e4 };
      var r4 = i3(t4);
      if (r4 && r4.has(e4)) return r4.get(e4);
      var n4 = {}, s4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var o4 in e4) if ("default" !== o4 && Object.prototype.hasOwnProperty.call(e4, o4)) {
        var a4 = s4 ? Object.getOwnPropertyDescriptor(e4, o4) : null;
        a4 && (a4.get || a4.set) ? Object.defineProperty(n4, o4, a4) : n4[o4] = e4[o4];
      }
      return n4.default = e4, r4 && r4.set(e4, n4), n4;
    }(yt);
    function i3(e4) {
      if ("function" != typeof WeakMap) return null;
      var t4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
      return (i3 = function(e5) {
        return e5 ? r4 : t4;
      })(e4);
    }
    function o3(e4, t4) {
      (null == t4 || t4 > e4.length) && (t4 = e4.length);
      for (var r4 = 0, n4 = new Array(t4); r4 < t4; r4++) n4[r4] = e4[r4];
      return n4;
    }
    function a3(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    function l2(e4, t4) {
      return l2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, l2(e4, t4);
    }
    var c2 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).nodes || (r5.nodes = []), r5;
      }
      r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, l2(t4, r4);
      var i4, c3, u2 = n4.prototype;
      return u2.append = function(e5) {
        return e5.parent = this, this.nodes.push(e5), this;
      }, u2.prepend = function(e5) {
        return e5.parent = this, this.nodes.unshift(e5), this;
      }, u2.at = function(e5) {
        return this.nodes[e5];
      }, u2.index = function(e5) {
        return "number" == typeof e5 ? e5 : this.nodes.indexOf(e5);
      }, u2.removeChild = function(e5) {
        var t5;
        for (var r5 in e5 = this.index(e5), this.at(e5).parent = void 0, this.nodes.splice(e5, 1), this.indexes) (t5 = this.indexes[r5]) >= e5 && (this.indexes[r5] = t5 - 1);
        return this;
      }, u2.removeAll = function() {
        for (var e5, t5 = function(e6, t6) {
          var r5 = "undefined" != typeof Symbol && e6[Symbol.iterator] || e6["@@iterator"];
          if (r5) return (r5 = r5.call(e6)).next.bind(r5);
          if (Array.isArray(e6) || (r5 = function(e7, t7) {
            if (e7) {
              if ("string" == typeof e7) return o3(e7, t7);
              var r6 = Object.prototype.toString.call(e7).slice(8, -1);
              return "Object" === r6 && e7.constructor && (r6 = e7.constructor.name), "Map" === r6 || "Set" === r6 ? Array.from(e7) : "Arguments" === r6 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r6) ? o3(e7, t7) : void 0;
            }
          }(e6)) || t6 && e6 && "number" == typeof e6.length) {
            r5 && (e6 = r5);
            var n5 = 0;
            return function() {
              return n5 >= e6.length ? { done: true } : { done: false, value: e6[n5++] };
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }(this.nodes); !(e5 = t5()).done; ) e5.value.parent = void 0;
        return this.nodes = [], this;
      }, u2.empty = function() {
        return this.removeAll();
      }, u2.insertAfter = function(e5, t5) {
        t5.parent = this;
        var r5, n5 = this.index(e5);
        for (var s4 in this.nodes.splice(n5 + 1, 0, t5), t5.parent = this, this.indexes) n5 <= (r5 = this.indexes[s4]) && (this.indexes[s4] = r5 + 1);
        return this;
      }, u2.insertBefore = function(e5, t5) {
        t5.parent = this;
        var r5, n5 = this.index(e5);
        for (var s4 in this.nodes.splice(n5, 0, t5), t5.parent = this, this.indexes) (r5 = this.indexes[s4]) <= n5 && (this.indexes[s4] = r5 + 1);
        return this;
      }, u2._findChildAtPosition = function(e5, t5) {
        var r5 = void 0;
        return this.each(function(n5) {
          if (n5.atPosition) {
            var s4 = n5.atPosition(e5, t5);
            if (s4) return r5 = s4, false;
          } else if (n5.isAtPosition(e5, t5)) return r5 = n5, false;
        }), r5;
      }, u2.atPosition = function(e5, t5) {
        return this.isAtPosition(e5, t5) ? this._findChildAtPosition(e5, t5) || this : void 0;
      }, u2._inferEndPosition = function() {
        this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
      }, u2.each = function(e5) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var t5 = this.lastEach;
        if (this.indexes[t5] = 0, this.length) {
          for (var r5, n5; this.indexes[t5] < this.length && (r5 = this.indexes[t5], false !== (n5 = e5(this.at(r5), r5))); ) this.indexes[t5] += 1;
          return delete this.indexes[t5], false !== n5 && void 0;
        }
      }, u2.walk = function(e5) {
        return this.each(function(t5, r5) {
          var n5 = e5(t5, r5);
          if (false !== n5 && t5.length && (n5 = t5.walk(e5)), false === n5) return false;
        });
      }, u2.walkAttributes = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.ATTRIBUTE) return e5.call(t5, r5);
        });
      }, u2.walkClasses = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.CLASS) return e5.call(t5, r5);
        });
      }, u2.walkCombinators = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.COMBINATOR) return e5.call(t5, r5);
        });
      }, u2.walkComments = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.COMMENT) return e5.call(t5, r5);
        });
      }, u2.walkIds = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.ID) return e5.call(t5, r5);
        });
      }, u2.walkNesting = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.NESTING) return e5.call(t5, r5);
        });
      }, u2.walkPseudos = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.PSEUDO) return e5.call(t5, r5);
        });
      }, u2.walkTags = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.TAG) return e5.call(t5, r5);
        });
      }, u2.walkUniversals = function(e5) {
        var t5 = this;
        return this.walk(function(r5) {
          if (r5.type === s3.UNIVERSAL) return e5.call(t5, r5);
        });
      }, u2.split = function(e5) {
        var t5 = this, r5 = [];
        return this.reduce(function(n5, s4, i5) {
          var o4 = e5.call(t5, s4);
          return r5.push(s4), o4 ? (n5.push(r5), r5 = []) : i5 === t5.length - 1 && n5.push(r5), n5;
        }, []);
      }, u2.map = function(e5) {
        return this.nodes.map(e5);
      }, u2.reduce = function(e5, t5) {
        return this.nodes.reduce(e5, t5);
      }, u2.every = function(e5) {
        return this.nodes.every(e5);
      }, u2.some = function(e5) {
        return this.nodes.some(e5);
      }, u2.filter = function(e5) {
        return this.nodes.filter(e5);
      }, u2.sort = function(e5) {
        return this.nodes.sort(e5);
      }, u2.toString = function() {
        return this.map(String).join("");
      }, i4 = n4, (c3 = [{ key: "first", get: function() {
        return this.at(0);
      } }, { key: "last", get: function() {
        return this.at(this.length - 1);
      } }, { key: "length", get: function() {
        return this.nodes.length;
      } }]) && a3(i4.prototype, c3), Object.defineProperty(i4, "prototype", { writable: false }), n4;
    }(n3.default);
    t3.default = c2, e3.exports = t3.default;
  }(Ze, Ze.exports);
  var gt = Ze.exports;
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = gt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    function o3(e4, t4) {
      return o3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, o3(e4, t4);
    }
    var a3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.ROOT, r5;
      }
      r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, o3(t4, r4);
      var a4, l2, c2 = n4.prototype;
      return c2.toString = function() {
        var e5 = this.reduce(function(e6, t5) {
          return e6.push(String(t5)), e6;
        }, []).join(",");
        return this.trailingComma ? e5 + "," : e5;
      }, c2.error = function(e5, t5) {
        return this._error ? this._error(e5, t5) : new Error(e5);
      }, a4 = n4, (l2 = [{ key: "errorGenerator", set: function(e5) {
        this._error = e5;
      } }]) && i3(a4.prototype, l2), Object.defineProperty(a4, "prototype", { writable: false }), n4;
    }(n3.default);
    t3.default = a3, e3.exports = t3.default;
  }(Qe, Qe.exports);
  var bt = Qe.exports, vt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = gt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.SELECTOR, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(vt, vt.exports);
  var Et = vt.exports, St = { exports: {} }, xt = {}.hasOwnProperty, Tt = /[ -,\.\/:-@\[-\^`\{-~]/, wt = /[ -,\.\/:-@\[\]\^`\{-~]/, Pt = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, At = function e3(t3, r3) {
    "single" != (r3 = function(e4, t4) {
      if (!e4) return t4;
      var r4 = {};
      for (var n4 in t4) r4[n4] = xt.call(e4, n4) ? e4[n4] : t4[n4];
      return r4;
    }(r3, e3.options)).quotes && "double" != r3.quotes && (r3.quotes = "single");
    for (var n3 = "double" == r3.quotes ? '"' : "'", s3 = r3.isIdentifier, i3 = t3.charAt(0), o3 = "", a3 = 0, l2 = t3.length; a3 < l2; ) {
      var c2 = t3.charAt(a3++), u2 = c2.charCodeAt(), p2 = void 0;
      if (u2 < 32 || u2 > 126) {
        if (u2 >= 55296 && u2 <= 56319 && a3 < l2) {
          var d2 = t3.charCodeAt(a3++);
          56320 == (64512 & d2) ? u2 = ((1023 & u2) << 10) + (1023 & d2) + 65536 : a3--;
        }
        p2 = "\\" + u2.toString(16).toUpperCase() + " ";
      } else p2 = r3.escapeEverything ? Tt.test(c2) ? "\\" + c2 : "\\" + u2.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(c2) ? "\\" + u2.toString(16).toUpperCase() + " " : "\\" == c2 || !s3 && ('"' == c2 && n3 == c2 || "'" == c2 && n3 == c2) || s3 && wt.test(c2) ? "\\" + c2 : c2;
      o3 += p2;
    }
    return s3 && (/^-[-\d]/.test(o3) ? o3 = "\\-" + o3.slice(1) : /\d/.test(i3) && (o3 = "\\3" + i3 + " " + o3.slice(1))), o3 = o3.replace(Pt, function(e4, t4, r4) {
      return t4 && t4.length % 2 ? e4 : (t4 || "") + r4;
    }), !s3 && r3.wrap ? n3 + o3 + n3 : o3;
  };
  At.options = { escapeEverything: false, isIdentifier: false, quotes: "single", wrap: false }, At.version = "3.0.0";
  var Ct = At;
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3 = o3(Ct), n3 = tt, s3 = o3(mt), i3 = yt;
    function o3(e4) {
      return e4 && e4.__esModule ? e4 : { default: e4 };
    }
    function a3(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    function l2(e4, t4) {
      return l2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, l2(e4, t4);
    }
    var c2 = function(e4) {
      var t4, s4, o4, c3;
      function u2(t5) {
        var r4;
        return (r4 = e4.call(this, t5) || this).type = i3.CLASS, r4._constructed = true, r4;
      }
      return s4 = e4, (t4 = u2).prototype = Object.create(s4.prototype), t4.prototype.constructor = t4, l2(t4, s4), u2.prototype.valueToString = function() {
        return "." + e4.prototype.valueToString.call(this);
      }, o4 = u2, (c3 = [{ key: "value", get: function() {
        return this._value;
      }, set: function(e5) {
        if (this._constructed) {
          var t5 = (0, r3.default)(e5, { isIdentifier: true });
          t5 !== e5 ? ((0, n3.ensureObject)(this, "raws"), this.raws.value = t5) : this.raws && delete this.raws.value;
        }
        this._value = e5;
      } }]) && a3(o4.prototype, c3), Object.defineProperty(o4, "prototype", { writable: false }), u2;
    }(s3.default);
    t3.default = c2, e3.exports = t3.default;
  }(St, St.exports);
  var Ot = St.exports, It = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = mt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.COMMENT, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(It, It.exports);
  var _t = It.exports, kt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = mt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.ID, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4.prototype.valueToString = function() {
        return "#" + e4.prototype.valueToString.call(this);
      }, n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(kt, kt.exports);
  var Nt = kt.exports, Dt = { exports: {} }, jt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3 = s3(Ct), n3 = tt;
    function s3(e4) {
      return e4 && e4.__esModule ? e4 : { default: e4 };
    }
    function i3(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    function o3(e4, t4) {
      return o3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, o3(e4, t4);
    }
    var a3 = function(e4) {
      var t4, s4;
      function a4() {
        return e4.apply(this, arguments) || this;
      }
      s4 = e4, (t4 = a4).prototype = Object.create(s4.prototype), t4.prototype.constructor = t4, o3(t4, s4);
      var l2, c2, u2 = a4.prototype;
      return u2.qualifiedName = function(e5) {
        return this.namespace ? this.namespaceString + "|" + e5 : e5;
      }, u2.valueToString = function() {
        return this.qualifiedName(e4.prototype.valueToString.call(this));
      }, l2 = a4, c2 = [{ key: "namespace", get: function() {
        return this._namespace;
      }, set: function(e5) {
        if (true === e5 || "*" === e5 || "&" === e5) return this._namespace = e5, void (this.raws && delete this.raws.namespace);
        var t5 = (0, r3.default)(e5, { isIdentifier: true });
        this._namespace = e5, t5 !== e5 ? ((0, n3.ensureObject)(this, "raws"), this.raws.namespace = t5) : this.raws && delete this.raws.namespace;
      } }, { key: "ns", get: function() {
        return this._namespace;
      }, set: function(e5) {
        this.namespace = e5;
      } }, { key: "namespaceString", get: function() {
        if (this.namespace) {
          var e5 = this.stringifyProperty("namespace");
          return true === e5 ? "" : e5;
        }
        return "";
      } }], c2 && i3(l2.prototype, c2), Object.defineProperty(l2, "prototype", { writable: false }), a4;
    }(s3(mt).default);
    t3.default = a3, e3.exports = t3.default;
  }(jt, jt.exports);
  var Lt = jt.exports;
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = Lt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.TAG, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(Dt, Dt.exports);
  var Mt = Dt.exports, Bt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = mt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.STRING, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(Bt, Bt.exports);
  var Rt = Bt.exports, Ft = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = gt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.PSEUDO, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4.prototype.toString = function() {
        var e5 = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), e5, this.rawSpaceAfter].join("");
      }, n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(Ft, Ft.exports);
  var Ut = Ft.exports, $t = {}, Vt = d.deprecate;
  !function(e3) {
    e3.__esModule = true, e3.default = void 0, e3.unescapeValue = h2;
    var t3, r3 = o3(Ct), n3 = o3(nt), s3 = o3(Lt), i3 = yt;
    function o3(e4) {
      return e4 && e4.__esModule ? e4 : { default: e4 };
    }
    function a3(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    function l2(e4, t4) {
      return l2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, l2(e4, t4);
    }
    var c2 = Vt, u2 = /^('|")([^]*)\1$/, p2 = c2(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), d2 = c2(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), f2 = c2(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function h2(e4) {
      var t4 = false, r4 = null, s4 = e4, i4 = s4.match(u2);
      return i4 && (r4 = i4[1], s4 = i4[2]), (s4 = (0, n3.default)(s4)) !== e4 && (t4 = true), { deprecatedUsage: t4, unescaped: s4, quoteMark: r4 };
    }
    var m2 = function(e4) {
      var t4, n4;
      function s4(t5) {
        var r4;
        return void 0 === t5 && (t5 = {}), r4 = e4.call(this, function(e5) {
          if (void 0 !== e5.quoteMark) return e5;
          if (void 0 === e5.value) return e5;
          f2();
          var t6 = h2(e5.value), r5 = t6.quoteMark, n5 = t6.unescaped;
          return e5.raws || (e5.raws = {}), void 0 === e5.raws.value && (e5.raws.value = e5.value), e5.value = n5, e5.quoteMark = r5, e5;
        }(t5)) || this, r4.type = i3.ATTRIBUTE, r4.raws = r4.raws || {}, Object.defineProperty(r4.raws, "unquoted", { get: c2(function() {
          return r4.value;
        }, "attr.raws.unquoted is deprecated. Call attr.value instead."), set: c2(function() {
          return r4.value;
        }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") }), r4._constructed = true, r4;
      }
      n4 = e4, (t4 = s4).prototype = Object.create(n4.prototype), t4.prototype.constructor = t4, l2(t4, n4);
      var o4, u3, m3 = s4.prototype;
      return m3.getQuotedValue = function(e5) {
        void 0 === e5 && (e5 = {});
        var t5 = this._determineQuoteMark(e5), n5 = y2[t5];
        return (0, r3.default)(this._value, n5);
      }, m3._determineQuoteMark = function(e5) {
        return e5.smart ? this.smartQuoteMark(e5) : this.preferredQuoteMark(e5);
      }, m3.setValue = function(e5, t5) {
        void 0 === t5 && (t5 = {}), this._value = e5, this._quoteMark = this._determineQuoteMark(t5), this._syncRawValue();
      }, m3.smartQuoteMark = function(e5) {
        var t5 = this.value, n5 = t5.replace(/[^']/g, "").length, i4 = t5.replace(/[^"]/g, "").length;
        if (n5 + i4 === 0) {
          var o5 = (0, r3.default)(t5, { isIdentifier: true });
          if (o5 === t5) return s4.NO_QUOTE;
          var a4 = this.preferredQuoteMark(e5);
          if (a4 === s4.NO_QUOTE) {
            var l3 = this.quoteMark || e5.quoteMark || s4.DOUBLE_QUOTE, c3 = y2[l3];
            if ((0, r3.default)(t5, c3).length < o5.length) return l3;
          }
          return a4;
        }
        return i4 === n5 ? this.preferredQuoteMark(e5) : i4 < n5 ? s4.DOUBLE_QUOTE : s4.SINGLE_QUOTE;
      }, m3.preferredQuoteMark = function(e5) {
        var t5 = e5.preferCurrentQuoteMark ? this.quoteMark : e5.quoteMark;
        return void 0 === t5 && (t5 = e5.preferCurrentQuoteMark ? e5.quoteMark : this.quoteMark), void 0 === t5 && (t5 = s4.DOUBLE_QUOTE), t5;
      }, m3._syncRawValue = function() {
        var e5 = (0, r3.default)(this._value, y2[this.quoteMark]);
        e5 === this._value ? this.raws && delete this.raws.value : this.raws.value = e5;
      }, m3._handleEscapes = function(e5, t5) {
        if (this._constructed) {
          var n5 = (0, r3.default)(t5, { isIdentifier: true });
          n5 !== t5 ? this.raws[e5] = n5 : delete this.raws[e5];
        }
      }, m3._spacesFor = function(e5) {
        var t5 = this.spaces[e5] || {}, r4 = this.raws.spaces && this.raws.spaces[e5] || {};
        return Object.assign({ before: "", after: "" }, t5, r4);
      }, m3._stringFor = function(e5, t5, r4) {
        void 0 === t5 && (t5 = e5), void 0 === r4 && (r4 = g2);
        var n5 = this._spacesFor(t5);
        return r4(this.stringifyProperty(e5), n5);
      }, m3.offsetOf = function(e5) {
        var t5 = 1, r4 = this._spacesFor("attribute");
        if (t5 += r4.before.length, "namespace" === e5 || "ns" === e5) return this.namespace ? t5 : -1;
        if ("attributeNS" === e5) return t5;
        if (t5 += this.namespaceString.length, this.namespace && (t5 += 1), "attribute" === e5) return t5;
        t5 += this.stringifyProperty("attribute").length, t5 += r4.after.length;
        var n5 = this._spacesFor("operator");
        t5 += n5.before.length;
        var s5 = this.stringifyProperty("operator");
        if ("operator" === e5) return s5 ? t5 : -1;
        t5 += s5.length, t5 += n5.after.length;
        var i4 = this._spacesFor("value");
        t5 += i4.before.length;
        var o5 = this.stringifyProperty("value");
        return "value" === e5 ? o5 ? t5 : -1 : (t5 += o5.length, t5 += i4.after.length, t5 += this._spacesFor("insensitive").before.length, "insensitive" === e5 && this.insensitive ? t5 : -1);
      }, m3.toString = function() {
        var e5 = this, t5 = [this.rawSpaceBefore, "["];
        return t5.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || "" === this.value) && (t5.push(this._stringFor("operator")), t5.push(this._stringFor("value")), t5.push(this._stringFor("insensitiveFlag", "insensitive", function(t6, r4) {
          return !(t6.length > 0) || e5.quoted || 0 !== r4.before.length || e5.spaces.value && e5.spaces.value.after || (r4.before = " "), g2(t6, r4);
        }))), t5.push("]"), t5.push(this.rawSpaceAfter), t5.join("");
      }, o4 = s4, (u3 = [{ key: "quoted", get: function() {
        var e5 = this.quoteMark;
        return "'" === e5 || '"' === e5;
      }, set: function(e5) {
        d2();
      } }, { key: "quoteMark", get: function() {
        return this._quoteMark;
      }, set: function(e5) {
        this._constructed ? this._quoteMark !== e5 && (this._quoteMark = e5, this._syncRawValue()) : this._quoteMark = e5;
      } }, { key: "qualifiedAttribute", get: function() {
        return this.qualifiedName(this.raws.attribute || this.attribute);
      } }, { key: "insensitiveFlag", get: function() {
        return this.insensitive ? "i" : "";
      } }, { key: "value", get: function() {
        return this._value;
      }, set: function(e5) {
        if (this._constructed) {
          var t5 = h2(e5), r4 = t5.deprecatedUsage, n5 = t5.unescaped, s5 = t5.quoteMark;
          if (r4 && p2(), n5 === this._value && s5 === this._quoteMark) return;
          this._value = n5, this._quoteMark = s5, this._syncRawValue();
        } else this._value = e5;
      } }, { key: "insensitive", get: function() {
        return this._insensitive;
      }, set: function(e5) {
        e5 || (this._insensitive = false, !this.raws || "I" !== this.raws.insensitiveFlag && "i" !== this.raws.insensitiveFlag || (this.raws.insensitiveFlag = void 0)), this._insensitive = e5;
      } }, { key: "attribute", get: function() {
        return this._attribute;
      }, set: function(e5) {
        this._handleEscapes("attribute", e5), this._attribute = e5;
      } }]) && a3(o4.prototype, u3), Object.defineProperty(o4, "prototype", { writable: false }), s4;
    }(s3.default);
    e3.default = m2, m2.NO_QUOTE = null, m2.SINGLE_QUOTE = "'", m2.DOUBLE_QUOTE = '"';
    var y2 = ((t3 = { "'": { quotes: "single", wrap: true }, '"': { quotes: "double", wrap: true } }).null = { isIdentifier: true }, t3);
    function g2(e4, t4) {
      return "" + t4.before + e4 + t4.after;
    }
  }($t);
  var qt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = Lt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.UNIVERSAL, r5.value = "*", r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(qt, qt.exports);
  var Wt = qt.exports, Gt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = mt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.COMBINATOR, r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(Gt, Gt.exports);
  var Ht = Gt.exports, zt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = mt) && r3.__esModule ? r3 : { default: r3 }, s3 = yt;
    function i3(e4, t4) {
      return i3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
        return e5.__proto__ = t5, e5;
      }, i3(e4, t4);
    }
    var o3 = function(e4) {
      var t4, r4;
      function n4(t5) {
        var r5;
        return (r5 = e4.call(this, t5) || this).type = s3.NESTING, r5.value = "&", r5;
      }
      return r4 = e4, (t4 = n4).prototype = Object.create(r4.prototype), t4.prototype.constructor = t4, i3(t4, r4), n4;
    }(n3.default);
    t3.default = o3, e3.exports = t3.default;
  }(zt, zt.exports);
  var Kt = zt.exports, Xt = { exports: {} };
  !function(e3, t3) {
    t3.__esModule = true, t3.default = function(e4) {
      return e4.sort(function(e5, t4) {
        return e5 - t4;
      });
    }, e3.exports = t3.default;
  }(Xt, Xt.exports);
  var Jt = Xt.exports, Yt = {}, Qt = { __esModule: true };
  Qt.word = Qt.tilde = Qt.tab = Qt.str = Qt.space = Qt.slash = Qt.singleQuote = Qt.semicolon = Qt.plus = Qt.pipe = Qt.openSquare = Qt.openParenthesis = Qt.newline = Qt.greaterThan = Qt.feed = Qt.equals = Qt.doubleQuote = Qt.dollar = Qt.cr = Qt.comment = Qt.comma = Qt.combinator = Qt.colon = Qt.closeSquare = Qt.closeParenthesis = Qt.caret = Qt.bang = Qt.backslash = Qt.at = Qt.asterisk = Qt.ampersand = void 0, Qt.ampersand = 38, Qt.asterisk = 42, Qt.at = 64, Qt.comma = 44, Qt.colon = 58, Qt.semicolon = 59, Qt.openParenthesis = 40, Qt.closeParenthesis = 41, Qt.openSquare = 91, Qt.closeSquare = 93, Qt.dollar = 36, Qt.tilde = 126, Qt.caret = 94, Qt.plus = 43, Qt.equals = 61, Qt.pipe = 124, Qt.greaterThan = 62, Qt.space = 32, Qt.singleQuote = 39, Qt.doubleQuote = 34, Qt.slash = 47, Qt.bang = 33, Qt.backslash = 92, Qt.cr = 13, Qt.feed = 12, Qt.newline = 10, Qt.tab = 9, Qt.str = 39, Qt.comment = -1, Qt.word = -2, Qt.combinator = -3, function(e3) {
    e3.__esModule = true, e3.FIELDS = void 0, e3.default = function(e4) {
      var t4, r4, s4, i4, o4, a4, l3, u3, p2, d2, f2, h2, m2 = [], y2 = e4.css.valueOf(), g2 = y2.length, b2 = -1, v2 = 1, E2 = 0, S2 = 0;
      function x2(t5, r5) {
        if (!e4.safe) throw e4.error("Unclosed " + t5, v2, E2 - b2, E2);
        u3 = (y2 += r5).length - 1;
      }
      for (; E2 < g2; ) {
        switch ((t4 = y2.charCodeAt(E2)) === n3.newline && (b2 = E2, v2 += 1), t4) {
          case n3.space:
          case n3.tab:
          case n3.newline:
          case n3.cr:
          case n3.feed:
            u3 = E2;
            do {
              u3 += 1, (t4 = y2.charCodeAt(u3)) === n3.newline && (b2 = u3, v2 += 1);
            } while (t4 === n3.space || t4 === n3.newline || t4 === n3.tab || t4 === n3.cr || t4 === n3.feed);
            h2 = n3.space, s4 = v2, r4 = u3 - b2 - 1, S2 = u3;
            break;
          case n3.plus:
          case n3.greaterThan:
          case n3.tilde:
          case n3.pipe:
            u3 = E2;
            do {
              u3 += 1, t4 = y2.charCodeAt(u3);
            } while (t4 === n3.plus || t4 === n3.greaterThan || t4 === n3.tilde || t4 === n3.pipe);
            h2 = n3.combinator, s4 = v2, r4 = E2 - b2, S2 = u3;
            break;
          case n3.asterisk:
          case n3.ampersand:
          case n3.bang:
          case n3.comma:
          case n3.equals:
          case n3.dollar:
          case n3.caret:
          case n3.openSquare:
          case n3.closeSquare:
          case n3.colon:
          case n3.semicolon:
          case n3.openParenthesis:
          case n3.closeParenthesis:
            h2 = t4, s4 = v2, r4 = E2 - b2, S2 = (u3 = E2) + 1;
            break;
          case n3.singleQuote:
          case n3.doubleQuote:
            f2 = t4 === n3.singleQuote ? "'" : '"', u3 = E2;
            do {
              for (i4 = false, -1 === (u3 = y2.indexOf(f2, u3 + 1)) && x2("quote", f2), o4 = u3; y2.charCodeAt(o4 - 1) === n3.backslash; ) o4 -= 1, i4 = !i4;
            } while (i4);
            h2 = n3.str, s4 = v2, r4 = E2 - b2, S2 = u3 + 1;
            break;
          default:
            t4 === n3.slash && y2.charCodeAt(E2 + 1) === n3.asterisk ? (0 === (u3 = y2.indexOf("*/", E2 + 2) + 1) && x2("comment", "*/"), (a4 = (l3 = y2.slice(E2, u3 + 1).split("\n")).length - 1) > 0 ? (p2 = v2 + a4, d2 = u3 - l3[a4].length) : (p2 = v2, d2 = b2), h2 = n3.comment, v2 = p2, s4 = p2, r4 = u3 - d2) : t4 === n3.slash ? (h2 = t4, s4 = v2, r4 = E2 - b2, S2 = (u3 = E2) + 1) : (u3 = c2(y2, E2), h2 = n3.word, s4 = v2, r4 = u3 - b2), S2 = u3 + 1;
        }
        m2.push([h2, v2, E2 - b2, s4, r4, E2, S2]), d2 && (b2 = d2, d2 = null), E2 = S2;
      }
      return m2;
    };
    var t3, r3, n3 = function(e4, t4) {
      if (e4 && e4.__esModule) return e4;
      if (null === e4 || "object" != typeof e4 && "function" != typeof e4) return { default: e4 };
      var r4 = s3(t4);
      if (r4 && r4.has(e4)) return r4.get(e4);
      var n4 = {}, i4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var o4 in e4) if ("default" !== o4 && Object.prototype.hasOwnProperty.call(e4, o4)) {
        var a4 = i4 ? Object.getOwnPropertyDescriptor(e4, o4) : null;
        a4 && (a4.get || a4.set) ? Object.defineProperty(n4, o4, a4) : n4[o4] = e4[o4];
      }
      return n4.default = e4, r4 && r4.set(e4, n4), n4;
    }(Qt);
    function s3(e4) {
      if ("function" != typeof WeakMap) return null;
      var t4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
      return (s3 = function(e5) {
        return e5 ? r4 : t4;
      })(e4);
    }
    for (var i3 = ((t3 = {})[n3.tab] = true, t3[n3.newline] = true, t3[n3.cr] = true, t3[n3.feed] = true, t3), o3 = ((r3 = {})[n3.space] = true, r3[n3.tab] = true, r3[n3.newline] = true, r3[n3.cr] = true, r3[n3.feed] = true, r3[n3.ampersand] = true, r3[n3.asterisk] = true, r3[n3.bang] = true, r3[n3.comma] = true, r3[n3.colon] = true, r3[n3.semicolon] = true, r3[n3.openParenthesis] = true, r3[n3.closeParenthesis] = true, r3[n3.openSquare] = true, r3[n3.closeSquare] = true, r3[n3.singleQuote] = true, r3[n3.doubleQuote] = true, r3[n3.plus] = true, r3[n3.pipe] = true, r3[n3.tilde] = true, r3[n3.greaterThan] = true, r3[n3.equals] = true, r3[n3.dollar] = true, r3[n3.caret] = true, r3[n3.slash] = true, r3), a3 = {}, l2 = 0; l2 < 22; l2++) a3["0123456789abcdefABCDEF".charCodeAt(l2)] = true;
    function c2(e4, t4) {
      var r4, s4 = t4;
      do {
        if (r4 = e4.charCodeAt(s4), o3[r4]) return s4 - 1;
        r4 === n3.backslash ? s4 = u2(e4, s4) + 1 : s4++;
      } while (s4 < e4.length);
      return s4 - 1;
    }
    function u2(e4, t4) {
      var r4 = t4, s4 = e4.charCodeAt(r4 + 1);
      if (i3[s4]) ;
      else if (a3[s4]) {
        var o4 = 0;
        do {
          r4++, o4++, s4 = e4.charCodeAt(r4 + 1);
        } while (a3[s4] && o4 < 6);
        o4 < 6 && s4 === n3.space && r4++;
      } else r4++;
      return r4;
    }
    e3.FIELDS = { TYPE: 0, START_LINE: 1, START_COL: 2, END_LINE: 3, END_COL: 4, START_POS: 5, END_POS: 6 };
  }(Yt), function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3, s3 = T2(bt), i3 = T2(Et), o3 = T2(Ot), a3 = T2(_t), l2 = T2(Nt), c2 = T2(Mt), u2 = T2(Rt), p2 = T2(Ut), d2 = x2($t), f2 = T2(Wt), h2 = T2(Ht), m2 = T2(Kt), y2 = T2(Jt), g2 = x2(Yt), b2 = x2(Qt), v2 = x2(yt), E2 = tt;
    function S2(e4) {
      if ("function" != typeof WeakMap) return null;
      var t4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
      return (S2 = function(e5) {
        return e5 ? r4 : t4;
      })(e4);
    }
    function x2(e4, t4) {
      if (!t4 && e4 && e4.__esModule) return e4;
      if (null === e4 || "object" != typeof e4 && "function" != typeof e4) return { default: e4 };
      var r4 = S2(t4);
      if (r4 && r4.has(e4)) return r4.get(e4);
      var n4 = {}, s4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var i4 in e4) if ("default" !== i4 && Object.prototype.hasOwnProperty.call(e4, i4)) {
        var o4 = s4 ? Object.getOwnPropertyDescriptor(e4, i4) : null;
        o4 && (o4.get || o4.set) ? Object.defineProperty(n4, i4, o4) : n4[i4] = e4[i4];
      }
      return n4.default = e4, r4 && r4.set(e4, n4), n4;
    }
    function T2(e4) {
      return e4 && e4.__esModule ? e4 : { default: e4 };
    }
    function w2(e4, t4) {
      for (var r4 = 0; r4 < t4.length; r4++) {
        var n4 = t4[r4];
        n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
      }
    }
    var P2 = ((r3 = {})[b2.space] = true, r3[b2.cr] = true, r3[b2.feed] = true, r3[b2.newline] = true, r3[b2.tab] = true, r3), A2 = Object.assign({}, P2, ((n3 = {})[b2.comment] = true, n3));
    function C2(e4) {
      return { line: e4[g2.FIELDS.START_LINE], column: e4[g2.FIELDS.START_COL] };
    }
    function O2(e4) {
      return { line: e4[g2.FIELDS.END_LINE], column: e4[g2.FIELDS.END_COL] };
    }
    function I2(e4, t4, r4, n4) {
      return { start: { line: e4, column: t4 }, end: { line: r4, column: n4 } };
    }
    function _2(e4) {
      return I2(e4[g2.FIELDS.START_LINE], e4[g2.FIELDS.START_COL], e4[g2.FIELDS.END_LINE], e4[g2.FIELDS.END_COL]);
    }
    function k2(e4, t4) {
      if (e4) return I2(e4[g2.FIELDS.START_LINE], e4[g2.FIELDS.START_COL], t4[g2.FIELDS.END_LINE], t4[g2.FIELDS.END_COL]);
    }
    function N2(e4, t4) {
      var r4 = e4[t4];
      if ("string" == typeof r4) return -1 !== r4.indexOf("\\") && ((0, E2.ensureObject)(e4, "raws"), e4[t4] = (0, E2.unesc)(r4), void 0 === e4.raws[t4] && (e4.raws[t4] = r4)), e4;
    }
    function D2(e4, t4) {
      for (var r4 = -1, n4 = []; -1 !== (r4 = e4.indexOf(t4, r4 + 1)); ) n4.push(r4);
      return n4;
    }
    var j2 = function() {
      function e4(e5, t5) {
        void 0 === t5 && (t5 = {}), this.rule = e5, this.options = Object.assign({ lossy: false, safe: false }, t5), this.position = 0, this.css = "string" == typeof this.rule ? this.rule : this.rule.selector, this.tokens = (0, g2.default)({ css: this.css, error: this._errorGenerator(), safe: this.options.safe });
        var r5 = k2(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new s3.default({ source: r5 }), this.root.errorGenerator = this._errorGenerator();
        var n5 = new i3.default({ source: { start: { line: 1, column: 1 } } });
        this.root.append(n5), this.current = n5, this.loop();
      }
      var t4, r4, n4 = e4.prototype;
      return n4._errorGenerator = function() {
        var e5 = this;
        return function(t5, r5) {
          return "string" == typeof e5.rule ? new Error(t5) : e5.rule.error(t5, r5);
        };
      }, n4.attribute = function() {
        var e5 = [], t5 = this.currToken;
        for (this.position++; this.position < this.tokens.length && this.currToken[g2.FIELDS.TYPE] !== b2.closeSquare; ) e5.push(this.currToken), this.position++;
        if (this.currToken[g2.FIELDS.TYPE] !== b2.closeSquare) return this.expected("closing square bracket", this.currToken[g2.FIELDS.START_POS]);
        var r5 = e5.length, n5 = { source: I2(t5[1], t5[2], this.currToken[3], this.currToken[4]), sourceIndex: t5[g2.FIELDS.START_POS] };
        if (1 === r5 && !~[b2.word].indexOf(e5[0][g2.FIELDS.TYPE])) return this.expected("attribute", e5[0][g2.FIELDS.START_POS]);
        for (var s4 = 0, i4 = "", o4 = "", a4 = null, l3 = false; s4 < r5; ) {
          var c3 = e5[s4], u3 = this.content(c3), p3 = e5[s4 + 1];
          switch (c3[g2.FIELDS.TYPE]) {
            case b2.space:
              if (l3 = true, this.options.lossy) break;
              if (a4) {
                (0, E2.ensureObject)(n5, "spaces", a4);
                var f3 = n5.spaces[a4].after || "";
                n5.spaces[a4].after = f3 + u3;
                var h3 = (0, E2.getProp)(n5, "raws", "spaces", a4, "after") || null;
                h3 && (n5.raws.spaces[a4].after = h3 + u3);
              } else i4 += u3, o4 += u3;
              break;
            case b2.asterisk:
              p3[g2.FIELDS.TYPE] === b2.equals ? (n5.operator = u3, a4 = "operator") : n5.namespace && ("namespace" !== a4 || l3) || !p3 || (i4 && ((0, E2.ensureObject)(n5, "spaces", "attribute"), n5.spaces.attribute.before = i4, i4 = ""), o4 && ((0, E2.ensureObject)(n5, "raws", "spaces", "attribute"), n5.raws.spaces.attribute.before = i4, o4 = ""), n5.namespace = (n5.namespace || "") + u3, (0, E2.getProp)(n5, "raws", "namespace") && (n5.raws.namespace += u3), a4 = "namespace"), l3 = false;
              break;
            case b2.dollar:
              if ("value" === a4) {
                var m3 = (0, E2.getProp)(n5, "raws", "value");
                n5.value += "$", m3 && (n5.raws.value = m3 + "$");
                break;
              }
            case b2.caret:
              p3[g2.FIELDS.TYPE] === b2.equals && (n5.operator = u3, a4 = "operator"), l3 = false;
              break;
            case b2.combinator:
              if ("~" === u3 && p3[g2.FIELDS.TYPE] === b2.equals && (n5.operator = u3, a4 = "operator"), "|" !== u3) {
                l3 = false;
                break;
              }
              p3[g2.FIELDS.TYPE] === b2.equals ? (n5.operator = u3, a4 = "operator") : n5.namespace || n5.attribute || (n5.namespace = true), l3 = false;
              break;
            case b2.word:
              if (p3 && "|" === this.content(p3) && e5[s4 + 2] && e5[s4 + 2][g2.FIELDS.TYPE] !== b2.equals && !n5.operator && !n5.namespace) n5.namespace = u3, a4 = "namespace";
              else if (!n5.attribute || "attribute" === a4 && !l3) i4 && ((0, E2.ensureObject)(n5, "spaces", "attribute"), n5.spaces.attribute.before = i4, i4 = ""), o4 && ((0, E2.ensureObject)(n5, "raws", "spaces", "attribute"), n5.raws.spaces.attribute.before = o4, o4 = ""), n5.attribute = (n5.attribute || "") + u3, (0, E2.getProp)(n5, "raws", "attribute") && (n5.raws.attribute += u3), a4 = "attribute";
              else if (!n5.value && "" !== n5.value || "value" === a4 && !l3 && !n5.quoteMark) {
                var y3 = (0, E2.unesc)(u3), v3 = (0, E2.getProp)(n5, "raws", "value") || "", S3 = n5.value || "";
                n5.value = S3 + y3, n5.quoteMark = null, (y3 !== u3 || v3) && ((0, E2.ensureObject)(n5, "raws"), n5.raws.value = (v3 || S3) + u3), a4 = "value";
              } else {
                var x3 = "i" === u3 || "I" === u3;
                !n5.value && "" !== n5.value || !n5.quoteMark && !l3 ? (n5.value || "" === n5.value) && (a4 = "value", n5.value += u3, n5.raws.value && (n5.raws.value += u3)) : (n5.insensitive = x3, x3 && "I" !== u3 || ((0, E2.ensureObject)(n5, "raws"), n5.raws.insensitiveFlag = u3), a4 = "insensitive", i4 && ((0, E2.ensureObject)(n5, "spaces", "insensitive"), n5.spaces.insensitive.before = i4, i4 = ""), o4 && ((0, E2.ensureObject)(n5, "raws", "spaces", "insensitive"), n5.raws.spaces.insensitive.before = o4, o4 = ""));
              }
              l3 = false;
              break;
            case b2.str:
              if (!n5.attribute || !n5.operator) return this.error("Expected an attribute followed by an operator preceding the string.", { index: c3[g2.FIELDS.START_POS] });
              var T3 = (0, d2.unescapeValue)(u3), w3 = T3.unescaped, P3 = T3.quoteMark;
              n5.value = w3, n5.quoteMark = P3, a4 = "value", (0, E2.ensureObject)(n5, "raws"), n5.raws.value = u3, l3 = false;
              break;
            case b2.equals:
              if (!n5.attribute) return this.expected("attribute", c3[g2.FIELDS.START_POS], u3);
              if (n5.value) return this.error('Unexpected "=" found; an operator was already defined.', { index: c3[g2.FIELDS.START_POS] });
              n5.operator = n5.operator ? n5.operator + u3 : u3, a4 = "operator", l3 = false;
              break;
            case b2.comment:
              if (a4) if (l3 || p3 && p3[g2.FIELDS.TYPE] === b2.space || "insensitive" === a4) {
                var A3 = (0, E2.getProp)(n5, "spaces", a4, "after") || "", C3 = (0, E2.getProp)(n5, "raws", "spaces", a4, "after") || A3;
                (0, E2.ensureObject)(n5, "raws", "spaces", a4), n5.raws.spaces[a4].after = C3 + u3;
              } else {
                var O3 = n5[a4] || "", _3 = (0, E2.getProp)(n5, "raws", a4) || O3;
                (0, E2.ensureObject)(n5, "raws"), n5.raws[a4] = _3 + u3;
              }
              else o4 += u3;
              break;
            default:
              return this.error('Unexpected "' + u3 + '" found.', { index: c3[g2.FIELDS.START_POS] });
          }
          s4++;
        }
        N2(n5, "attribute"), N2(n5, "namespace"), this.newNode(new d2.default(n5)), this.position++;
      }, n4.parseWhitespaceEquivalentTokens = function(e5) {
        e5 < 0 && (e5 = this.tokens.length);
        var t5 = this.position, r5 = [], n5 = "", s4 = void 0;
        do {
          if (P2[this.currToken[g2.FIELDS.TYPE]]) this.options.lossy || (n5 += this.content());
          else if (this.currToken[g2.FIELDS.TYPE] === b2.comment) {
            var i4 = {};
            n5 && (i4.before = n5, n5 = ""), s4 = new a3.default({ value: this.content(), source: _2(this.currToken), sourceIndex: this.currToken[g2.FIELDS.START_POS], spaces: i4 }), r5.push(s4);
          }
        } while (++this.position < e5);
        if (n5) {
          if (s4) s4.spaces.after = n5;
          else if (!this.options.lossy) {
            var o4 = this.tokens[t5], l3 = this.tokens[this.position - 1];
            r5.push(new u2.default({ value: "", source: I2(o4[g2.FIELDS.START_LINE], o4[g2.FIELDS.START_COL], l3[g2.FIELDS.END_LINE], l3[g2.FIELDS.END_COL]), sourceIndex: o4[g2.FIELDS.START_POS], spaces: { before: n5, after: "" } }));
          }
        }
        return r5;
      }, n4.convertWhitespaceNodesToSpace = function(e5, t5) {
        var r5 = this;
        void 0 === t5 && (t5 = false);
        var n5 = "", s4 = "";
        return e5.forEach(function(e6) {
          var i4 = r5.lossySpace(e6.spaces.before, t5), o4 = r5.lossySpace(e6.rawSpaceBefore, t5);
          n5 += i4 + r5.lossySpace(e6.spaces.after, t5 && 0 === i4.length), s4 += i4 + e6.value + r5.lossySpace(e6.rawSpaceAfter, t5 && 0 === o4.length);
        }), s4 === n5 && (s4 = void 0), { space: n5, rawSpace: s4 };
      }, n4.isNamedCombinator = function(e5) {
        return void 0 === e5 && (e5 = this.position), this.tokens[e5 + 0] && this.tokens[e5 + 0][g2.FIELDS.TYPE] === b2.slash && this.tokens[e5 + 1] && this.tokens[e5 + 1][g2.FIELDS.TYPE] === b2.word && this.tokens[e5 + 2] && this.tokens[e5 + 2][g2.FIELDS.TYPE] === b2.slash;
      }, n4.namedCombinator = function() {
        if (this.isNamedCombinator()) {
          var e5 = this.content(this.tokens[this.position + 1]), t5 = (0, E2.unesc)(e5).toLowerCase(), r5 = {};
          t5 !== e5 && (r5.value = "/" + e5 + "/");
          var n5 = new h2.default({ value: "/" + t5 + "/", source: I2(this.currToken[g2.FIELDS.START_LINE], this.currToken[g2.FIELDS.START_COL], this.tokens[this.position + 2][g2.FIELDS.END_LINE], this.tokens[this.position + 2][g2.FIELDS.END_COL]), sourceIndex: this.currToken[g2.FIELDS.START_POS], raws: r5 });
          return this.position = this.position + 3, n5;
        }
        this.unexpected();
      }, n4.combinator = function() {
        var e5 = this;
        if ("|" === this.content()) return this.namespace();
        var t5 = this.locateNextMeaningfulToken(this.position);
        if (!(t5 < 0 || this.tokens[t5][g2.FIELDS.TYPE] === b2.comma)) {
          var r5, n5 = this.currToken, s4 = void 0;
          if (t5 > this.position && (s4 = this.parseWhitespaceEquivalentTokens(t5)), this.isNamedCombinator() ? r5 = this.namedCombinator() : this.currToken[g2.FIELDS.TYPE] === b2.combinator ? (r5 = new h2.default({ value: this.content(), source: _2(this.currToken), sourceIndex: this.currToken[g2.FIELDS.START_POS] }), this.position++) : P2[this.currToken[g2.FIELDS.TYPE]] || s4 || this.unexpected(), r5) {
            if (s4) {
              var i4 = this.convertWhitespaceNodesToSpace(s4), o4 = i4.space, a4 = i4.rawSpace;
              r5.spaces.before = o4, r5.rawSpaceBefore = a4;
            }
          } else {
            var l3 = this.convertWhitespaceNodesToSpace(s4, true), c3 = l3.space, u3 = l3.rawSpace;
            u3 || (u3 = c3);
            var p3 = {}, d3 = { spaces: {} };
            c3.endsWith(" ") && u3.endsWith(" ") ? (p3.before = c3.slice(0, c3.length - 1), d3.spaces.before = u3.slice(0, u3.length - 1)) : c3.startsWith(" ") && u3.startsWith(" ") ? (p3.after = c3.slice(1), d3.spaces.after = u3.slice(1)) : d3.value = u3, r5 = new h2.default({ value: " ", source: k2(n5, this.tokens[this.position - 1]), sourceIndex: n5[g2.FIELDS.START_POS], spaces: p3, raws: d3 });
          }
          return this.currToken && this.currToken[g2.FIELDS.TYPE] === b2.space && (r5.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(r5);
        }
        var f3 = this.parseWhitespaceEquivalentTokens(t5);
        if (f3.length > 0) {
          var m3 = this.current.last;
          if (m3) {
            var y3 = this.convertWhitespaceNodesToSpace(f3), v3 = y3.space, E3 = y3.rawSpace;
            void 0 !== E3 && (m3.rawSpaceAfter += E3), m3.spaces.after += v3;
          } else f3.forEach(function(t6) {
            return e5.newNode(t6);
          });
        }
      }, n4.comma = function() {
        if (this.position === this.tokens.length - 1) return this.root.trailingComma = true, void this.position++;
        this.current._inferEndPosition();
        var e5 = new i3.default({ source: { start: C2(this.tokens[this.position + 1]) } });
        this.current.parent.append(e5), this.current = e5, this.position++;
      }, n4.comment = function() {
        var e5 = this.currToken;
        this.newNode(new a3.default({ value: this.content(), source: _2(e5), sourceIndex: e5[g2.FIELDS.START_POS] })), this.position++;
      }, n4.error = function(e5, t5) {
        throw this.root.error(e5, t5);
      }, n4.missingBackslash = function() {
        return this.error("Expected a backslash preceding the semicolon.", { index: this.currToken[g2.FIELDS.START_POS] });
      }, n4.missingParenthesis = function() {
        return this.expected("opening parenthesis", this.currToken[g2.FIELDS.START_POS]);
      }, n4.missingSquareBracket = function() {
        return this.expected("opening square bracket", this.currToken[g2.FIELDS.START_POS]);
      }, n4.unexpected = function() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[g2.FIELDS.START_POS]);
      }, n4.unexpectedPipe = function() {
        return this.error("Unexpected '|'.", this.currToken[g2.FIELDS.START_POS]);
      }, n4.namespace = function() {
        var e5 = this.prevToken && this.content(this.prevToken) || true;
        return this.nextToken[g2.FIELDS.TYPE] === b2.word ? (this.position++, this.word(e5)) : this.nextToken[g2.FIELDS.TYPE] === b2.asterisk ? (this.position++, this.universal(e5)) : void this.unexpectedPipe();
      }, n4.nesting = function() {
        if (this.nextToken && "|" === this.content(this.nextToken)) this.position++;
        else {
          var e5 = this.currToken;
          this.newNode(new m2.default({ value: this.content(), source: _2(e5), sourceIndex: e5[g2.FIELDS.START_POS] })), this.position++;
        }
      }, n4.parentheses = function() {
        var e5 = this.current.last, t5 = 1;
        if (this.position++, e5 && e5.type === v2.PSEUDO) {
          var r5 = new i3.default({ source: { start: C2(this.tokens[this.position - 1]) } }), n5 = this.current;
          for (e5.append(r5), this.current = r5; this.position < this.tokens.length && t5; ) this.currToken[g2.FIELDS.TYPE] === b2.openParenthesis && t5++, this.currToken[g2.FIELDS.TYPE] === b2.closeParenthesis && t5--, t5 ? this.parse() : (this.current.source.end = O2(this.currToken), this.current.parent.source.end = O2(this.currToken), this.position++);
          this.current = n5;
        } else {
          for (var s4, o4 = this.currToken, a4 = "("; this.position < this.tokens.length && t5; ) this.currToken[g2.FIELDS.TYPE] === b2.openParenthesis && t5++, this.currToken[g2.FIELDS.TYPE] === b2.closeParenthesis && t5--, s4 = this.currToken, a4 += this.parseParenthesisToken(this.currToken), this.position++;
          e5 ? e5.appendToPropertyAndEscape("value", a4, a4) : this.newNode(new u2.default({ value: a4, source: I2(o4[g2.FIELDS.START_LINE], o4[g2.FIELDS.START_COL], s4[g2.FIELDS.END_LINE], s4[g2.FIELDS.END_COL]), sourceIndex: o4[g2.FIELDS.START_POS] }));
        }
        if (t5) return this.expected("closing parenthesis", this.currToken[g2.FIELDS.START_POS]);
      }, n4.pseudo = function() {
        for (var e5 = this, t5 = "", r5 = this.currToken; this.currToken && this.currToken[g2.FIELDS.TYPE] === b2.colon; ) t5 += this.content(), this.position++;
        return this.currToken ? this.currToken[g2.FIELDS.TYPE] !== b2.word ? this.expected(["pseudo-class", "pseudo-element"], this.currToken[g2.FIELDS.START_POS]) : void this.splitWord(false, function(n5, s4) {
          t5 += n5, e5.newNode(new p2.default({ value: t5, source: k2(r5, e5.currToken), sourceIndex: r5[g2.FIELDS.START_POS] })), s4 > 1 && e5.nextToken && e5.nextToken[g2.FIELDS.TYPE] === b2.openParenthesis && e5.error("Misplaced parenthesis.", { index: e5.nextToken[g2.FIELDS.START_POS] });
        }) : this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      }, n4.space = function() {
        var e5 = this.content();
        0 === this.position || this.prevToken[g2.FIELDS.TYPE] === b2.comma || this.prevToken[g2.FIELDS.TYPE] === b2.openParenthesis || this.current.nodes.every(function(e6) {
          return "comment" === e6.type;
        }) ? (this.spaces = this.optionalSpace(e5), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[g2.FIELDS.TYPE] === b2.comma || this.nextToken[g2.FIELDS.TYPE] === b2.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(e5), this.position++) : this.combinator();
      }, n4.string = function() {
        var e5 = this.currToken;
        this.newNode(new u2.default({ value: this.content(), source: _2(e5), sourceIndex: e5[g2.FIELDS.START_POS] })), this.position++;
      }, n4.universal = function(e5) {
        var t5 = this.nextToken;
        if (t5 && "|" === this.content(t5)) return this.position++, this.namespace();
        var r5 = this.currToken;
        this.newNode(new f2.default({ value: this.content(), source: _2(r5), sourceIndex: r5[g2.FIELDS.START_POS] }), e5), this.position++;
      }, n4.splitWord = function(e5, t5) {
        for (var r5 = this, n5 = this.nextToken, s4 = this.content(); n5 && ~[b2.dollar, b2.caret, b2.equals, b2.word].indexOf(n5[g2.FIELDS.TYPE]); ) {
          this.position++;
          var i4 = this.content();
          if (s4 += i4, i4.lastIndexOf("\\") === i4.length - 1) {
            var a4 = this.nextToken;
            a4 && a4[g2.FIELDS.TYPE] === b2.space && (s4 += this.requiredSpace(this.content(a4)), this.position++);
          }
          n5 = this.nextToken;
        }
        var u3 = D2(s4, ".").filter(function(e6) {
          var t6 = "\\" === s4[e6 - 1], r6 = /^\d+\.\d+%$/.test(s4);
          return !t6 && !r6;
        }), p3 = D2(s4, "#").filter(function(e6) {
          return "\\" !== s4[e6 - 1];
        }), d3 = D2(s4, "#{");
        d3.length && (p3 = p3.filter(function(e6) {
          return !~d3.indexOf(e6);
        }));
        var f3 = (0, y2.default)(function() {
          var e6 = Array.prototype.concat.apply([], arguments);
          return e6.filter(function(t6, r6) {
            return r6 === e6.indexOf(t6);
          });
        }([0].concat(u3, p3)));
        f3.forEach(function(n6, i5) {
          var a5, d4 = f3[i5 + 1] || s4.length, h3 = s4.slice(n6, d4);
          if (0 === i5 && t5) return t5.call(r5, h3, f3.length);
          var m3 = r5.currToken, y3 = m3[g2.FIELDS.START_POS] + f3[i5], b3 = I2(m3[1], m3[2] + n6, m3[3], m3[2] + (d4 - 1));
          if (~u3.indexOf(n6)) {
            var v3 = { value: h3.slice(1), source: b3, sourceIndex: y3 };
            a5 = new o3.default(N2(v3, "value"));
          } else if (~p3.indexOf(n6)) {
            var E3 = { value: h3.slice(1), source: b3, sourceIndex: y3 };
            a5 = new l2.default(N2(E3, "value"));
          } else {
            var S3 = { value: h3, source: b3, sourceIndex: y3 };
            N2(S3, "value"), a5 = new c2.default(S3);
          }
          r5.newNode(a5, e5), e5 = null;
        }), this.position++;
      }, n4.word = function(e5) {
        var t5 = this.nextToken;
        return t5 && "|" === this.content(t5) ? (this.position++, this.namespace()) : this.splitWord(e5);
      }, n4.loop = function() {
        for (; this.position < this.tokens.length; ) this.parse(true);
        return this.current._inferEndPosition(), this.root;
      }, n4.parse = function(e5) {
        switch (this.currToken[g2.FIELDS.TYPE]) {
          case b2.space:
            this.space();
            break;
          case b2.comment:
            this.comment();
            break;
          case b2.openParenthesis:
            this.parentheses();
            break;
          case b2.closeParenthesis:
            e5 && this.missingParenthesis();
            break;
          case b2.openSquare:
            this.attribute();
            break;
          case b2.dollar:
          case b2.caret:
          case b2.equals:
          case b2.word:
            this.word();
            break;
          case b2.colon:
            this.pseudo();
            break;
          case b2.comma:
            this.comma();
            break;
          case b2.asterisk:
            this.universal();
            break;
          case b2.ampersand:
            this.nesting();
            break;
          case b2.slash:
          case b2.combinator:
            this.combinator();
            break;
          case b2.str:
            this.string();
            break;
          case b2.closeSquare:
            this.missingSquareBracket();
          case b2.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      }, n4.expected = function(e5, t5, r5) {
        if (Array.isArray(e5)) {
          var n5 = e5.pop();
          e5 = e5.join(", ") + " or " + n5;
        }
        var s4 = /^[aeiou]/.test(e5[0]) ? "an" : "a";
        return r5 ? this.error("Expected " + s4 + " " + e5 + ', found "' + r5 + '" instead.', { index: t5 }) : this.error("Expected " + s4 + " " + e5 + ".", { index: t5 });
      }, n4.requiredSpace = function(e5) {
        return this.options.lossy ? " " : e5;
      }, n4.optionalSpace = function(e5) {
        return this.options.lossy ? "" : e5;
      }, n4.lossySpace = function(e5, t5) {
        return this.options.lossy ? t5 ? " " : "" : e5;
      }, n4.parseParenthesisToken = function(e5) {
        var t5 = this.content(e5);
        return e5[g2.FIELDS.TYPE] === b2.space ? this.requiredSpace(t5) : t5;
      }, n4.newNode = function(e5, t5) {
        return t5 && (/^ +$/.test(t5) && (this.options.lossy || (this.spaces = (this.spaces || "") + t5), t5 = true), e5.namespace = t5, N2(e5, "namespace")), this.spaces && (e5.spaces.before = this.spaces, this.spaces = ""), this.current.append(e5);
      }, n4.content = function(e5) {
        return void 0 === e5 && (e5 = this.currToken), this.css.slice(e5[g2.FIELDS.START_POS], e5[g2.FIELDS.END_POS]);
      }, n4.locateNextMeaningfulToken = function(e5) {
        void 0 === e5 && (e5 = this.position + 1);
        for (var t5 = e5; t5 < this.tokens.length; ) {
          if (!A2[this.tokens[t5][g2.FIELDS.TYPE]]) return t5;
          t5++;
        }
        return -1;
      }, t4 = e4, (r4 = [{ key: "currToken", get: function() {
        return this.tokens[this.position];
      } }, { key: "nextToken", get: function() {
        return this.tokens[this.position + 1];
      } }, { key: "prevToken", get: function() {
        return this.tokens[this.position - 1];
      } }]) && w2(t4.prototype, r4), Object.defineProperty(t4, "prototype", { writable: false }), e4;
    }();
    t3.default = j2, e3.exports = t3.default;
  }(Ye, Ye.exports);
  var Zt = Ye.exports;
  !function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = Zt) && r3.__esModule ? r3 : { default: r3 }, s3 = function() {
      function e4(e5, t5) {
        this.func = e5 || function() {
        }, this.funcRes = null, this.options = t5;
      }
      var t4 = e4.prototype;
      return t4._shouldUpdateSelector = function(e5, t5) {
        return void 0 === t5 && (t5 = {}), false !== Object.assign({}, this.options, t5).updateSelector && "string" != typeof e5;
      }, t4._isLossy = function(e5) {
        return void 0 === e5 && (e5 = {}), false === Object.assign({}, this.options, e5).lossless;
      }, t4._root = function(e5, t5) {
        return void 0 === t5 && (t5 = {}), new n3.default(e5, this._parseOptions(t5)).root;
      }, t4._parseOptions = function(e5) {
        return { lossy: this._isLossy(e5) };
      }, t4._run = function(e5, t5) {
        var r4 = this;
        return void 0 === t5 && (t5 = {}), new Promise(function(n4, s4) {
          try {
            var i3 = r4._root(e5, t5);
            Promise.resolve(r4.func(i3)).then(function(n5) {
              var s5 = void 0;
              return r4._shouldUpdateSelector(e5, t5) && (s5 = i3.toString(), e5.selector = s5), { transform: n5, root: i3, string: s5 };
            }).then(n4, s4);
          } catch (e6) {
            return void s4(e6);
          }
        });
      }, t4._runSync = function(e5, t5) {
        void 0 === t5 && (t5 = {});
        var r4 = this._root(e5, t5), n4 = this.func(r4);
        if (n4 && "function" == typeof n4.then) throw new Error("Selector processor returned a promise to a synchronous call.");
        var s4 = void 0;
        return t5.updateSelector && "string" != typeof e5 && (s4 = r4.toString(), e5.selector = s4), { transform: n4, root: r4, string: s4 };
      }, t4.ast = function(e5, t5) {
        return this._run(e5, t5).then(function(e6) {
          return e6.root;
        });
      }, t4.astSync = function(e5, t5) {
        return this._runSync(e5, t5).root;
      }, t4.transform = function(e5, t5) {
        return this._run(e5, t5).then(function(e6) {
          return e6.transform;
        });
      }, t4.transformSync = function(e5, t5) {
        return this._runSync(e5, t5).transform;
      }, t4.process = function(e5, t5) {
        return this._run(e5, t5).then(function(e6) {
          return e6.string || e6.root.toString();
        });
      }, t4.processSync = function(e5, t5) {
        var r4 = this._runSync(e5, t5);
        return r4.string || r4.root.toString();
      }, e4;
    }();
    t3.default = s3, e3.exports = t3.default;
  }(Je, Je.exports);
  var er = Je.exports, tr = {}, rr = { __esModule: true };
  rr.universal = rr.tag = rr.string = rr.selector = rr.root = rr.pseudo = rr.nesting = rr.id = rr.comment = rr.combinator = rr.className = rr.attribute = void 0;
  var nr = mr($t), sr = mr(Ot), ir = mr(Ht), or = mr(_t), ar = mr(Nt), lr = mr(Kt), cr = mr(Ut), ur = mr(bt), pr = mr(Et), dr = mr(Rt), fr = mr(Mt), hr = mr(Wt);
  function mr(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  }
  rr.attribute = function(e3) {
    return new nr.default(e3);
  }, rr.className = function(e3) {
    return new sr.default(e3);
  }, rr.combinator = function(e3) {
    return new ir.default(e3);
  }, rr.comment = function(e3) {
    return new or.default(e3);
  }, rr.id = function(e3) {
    return new ar.default(e3);
  }, rr.nesting = function(e3) {
    return new lr.default(e3);
  }, rr.pseudo = function(e3) {
    return new cr.default(e3);
  }, rr.root = function(e3) {
    return new ur.default(e3);
  }, rr.selector = function(e3) {
    return new pr.default(e3);
  }, rr.string = function(e3) {
    return new dr.default(e3);
  }, rr.tag = function(e3) {
    return new fr.default(e3);
  }, rr.universal = function(e3) {
    return new hr.default(e3);
  };
  var yr = { __esModule: true };
  yr.isComment = yr.isCombinator = yr.isClassName = yr.isAttribute = void 0, yr.isContainer = function(e3) {
    return !(!Er(e3) || !e3.walk);
  }, yr.isIdentifier = void 0, yr.isNamespace = function(e3) {
    return xr(e3) || Nr(e3);
  }, yr.isNesting = void 0, yr.isNode = Er, yr.isPseudo = void 0, yr.isPseudoClass = function(e3) {
    return Or(e3) && !jr(e3);
  }, yr.isPseudoElement = jr, yr.isUniversal = yr.isTag = yr.isString = yr.isSelector = yr.isRoot = void 0;
  var gr, br = yt, vr = ((gr = {})[br.ATTRIBUTE] = true, gr[br.CLASS] = true, gr[br.COMBINATOR] = true, gr[br.COMMENT] = true, gr[br.ID] = true, gr[br.NESTING] = true, gr[br.PSEUDO] = true, gr[br.ROOT] = true, gr[br.SELECTOR] = true, gr[br.STRING] = true, gr[br.TAG] = true, gr[br.UNIVERSAL] = true, gr);
  function Er(e3) {
    return "object" == typeof e3 && vr[e3.type];
  }
  function Sr(e3, t3) {
    return Er(t3) && t3.type === e3;
  }
  var xr = Sr.bind(null, br.ATTRIBUTE);
  yr.isAttribute = xr;
  var Tr = Sr.bind(null, br.CLASS);
  yr.isClassName = Tr;
  var wr = Sr.bind(null, br.COMBINATOR);
  yr.isCombinator = wr;
  var Pr = Sr.bind(null, br.COMMENT);
  yr.isComment = Pr;
  var Ar = Sr.bind(null, br.ID);
  yr.isIdentifier = Ar;
  var Cr = Sr.bind(null, br.NESTING);
  yr.isNesting = Cr;
  var Or = Sr.bind(null, br.PSEUDO);
  yr.isPseudo = Or;
  var Ir = Sr.bind(null, br.ROOT);
  yr.isRoot = Ir;
  var _r = Sr.bind(null, br.SELECTOR);
  yr.isSelector = _r;
  var kr = Sr.bind(null, br.STRING);
  yr.isString = kr;
  var Nr = Sr.bind(null, br.TAG);
  yr.isTag = Nr;
  var Dr = Sr.bind(null, br.UNIVERSAL);
  function jr(e3) {
    return Or(e3) && e3.value && (e3.value.startsWith("::") || ":before" === e3.value.toLowerCase() || ":after" === e3.value.toLowerCase() || ":first-letter" === e3.value.toLowerCase() || ":first-line" === e3.value.toLowerCase());
  }
  yr.isUniversal = Dr, function(e3) {
    e3.__esModule = true;
    var t3 = yt;
    Object.keys(t3).forEach(function(r4) {
      "default" !== r4 && "__esModule" !== r4 && (r4 in e3 && e3[r4] === t3[r4] || (e3[r4] = t3[r4]));
    });
    var r3 = rr;
    Object.keys(r3).forEach(function(t4) {
      "default" !== t4 && "__esModule" !== t4 && (t4 in e3 && e3[t4] === r3[t4] || (e3[t4] = r3[t4]));
    });
    var n3 = yr;
    Object.keys(n3).forEach(function(t4) {
      "default" !== t4 && "__esModule" !== t4 && (t4 in e3 && e3[t4] === n3[t4] || (e3[t4] = n3[t4]));
    });
  }(tr), function(e3, t3) {
    t3.__esModule = true, t3.default = void 0;
    var r3, n3 = (r3 = er) && r3.__esModule ? r3 : { default: r3 }, s3 = function(e4, t4) {
      if (e4 && e4.__esModule) return e4;
      if (null === e4 || "object" != typeof e4 && "function" != typeof e4) return { default: e4 };
      var r4 = i3(t4);
      if (r4 && r4.has(e4)) return r4.get(e4);
      var n4 = {}, s4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var o4 in e4) if ("default" !== o4 && Object.prototype.hasOwnProperty.call(e4, o4)) {
        var a4 = s4 ? Object.getOwnPropertyDescriptor(e4, o4) : null;
        a4 && (a4.get || a4.set) ? Object.defineProperty(n4, o4, a4) : n4[o4] = e4[o4];
      }
      return n4.default = e4, r4 && r4.set(e4, n4), n4;
    }(tr);
    function i3(e4) {
      if ("function" != typeof WeakMap) return null;
      var t4 = /* @__PURE__ */ new WeakMap(), r4 = /* @__PURE__ */ new WeakMap();
      return (i3 = function(e5) {
        return e5 ? r4 : t4;
      })(e4);
    }
    var o3 = function(e4) {
      return new n3.default(e4);
    };
    Object.assign(o3, s3), delete o3.__esModule;
    var a3 = o3;
    t3.default = a3, e3.exports = t3.default;
  }(Xe, Xe.exports);
  var Lr = Xe.exports, Mr = q(Lr);
  const Br = /^(-\w+-)?animation-name$/, Rr = /^(-\w+-)?animation$/, Fr = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
    const t3 = /* @__PURE__ */ Object.create(null), r3 = e3.replace(/^data-v-/, "");
    return { postcssPlugin: "vue-sfc-scoped", Rule(t4) {
      !function(e4, t5) {
        Ur.has(t5) || t5.parent && "atrule" === t5.parent.type && /-?keyframes$/.test(t5.parent.name) || (Ur.add(t5), t5.selector = Mr((t6) => {
          t6.each((r4) => {
            $r(e4, r4, t6);
          });
        }).processSync(t5.selector));
      }(e3, t4);
    }, AtRule(e4) {
      /-?keyframes$/.test(e4.name) && !e4.params.endsWith(`-${r3}`) && (t3[e4.params] = e4.params = e4.params + "-" + r3);
    }, OnceExit(e4) {
      Object.keys(t3).length && e4.walkDecls((e5) => {
        Br.test(e5.prop) && (e5.value = e5.value.split(",").map((e6) => t3[e6.trim()] || e6.trim()).join(",")), Rr.test(e5.prop) && (e5.value = e5.value.split(",").map((e6) => {
          const r4 = e6.trim().split(/\s+/), n3 = r4.findIndex((e7) => t3[e7]);
          return -1 !== n3 ? (r4.splice(n3, 1, t3[r4[n3]]), r4.join(" ")) : e6;
        }).join(","));
      });
    } };
  }, Ur = /* @__PURE__ */ new WeakSet();
  function $r(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], s3 = null, i3 = true;
    if (t3.each((n4) => {
      if ("combinator" === n4.type && (">>>" === n4.value || "/deep/" === n4.value)) return n4.value = " ", n4.spaces.before = n4.spaces.after = "", false;
      if ("pseudo" === n4.type) {
        const { value: s4 } = n4;
        if (":deep" === s4 || "::v-deep" === s4) {
          if (n4.nodes.length) {
            let e4 = n4;
            n4.nodes[0].each((r5) => {
              t3.insertAfter(e4, r5), e4 = r5;
            });
            const r4 = t3.at(t3.index(n4) - 1);
            r4 && Vr(r4) || t3.insertAfter(n4, Mr.combinator({ value: " " })), t3.removeChild(n4);
          } else {
            const e4 = t3.at(t3.index(n4) - 1);
            e4 && Vr(e4) && t3.removeChild(e4), t3.removeChild(n4);
          }
          return false;
        }
        if (":slotted" === s4 || "::v-slotted" === s4) {
          $r(e3, n4.nodes[0], r3, true);
          let s5 = n4;
          return n4.nodes[0].each((e4) => {
            t3.insertAfter(s5, e4), s5 = e4;
          }), t3.removeChild(n4), i3 = false, false;
        }
        if (":global" === s4 || "::v-global" === s4) return r3.insertAfter(t3, n4.nodes[0]), r3.removeChild(t3), false;
      }
      ("pseudo" !== n4.type && "combinator" !== n4.type || "pseudo" === n4.type && (":is" === n4.value || ":where" === n4.value)) && (s3 = n4);
    }), s3) {
      const { type: t4, value: o3 } = s3;
      "pseudo" !== t4 || ":is" !== o3 && ":where" !== o3 || (s3.nodes.forEach((t5) => $r(e3, t5, r3, n3)), i3 = false);
    }
    if (s3 ? s3.spaces.after = "" : t3.first.spaces.before = "", i3) {
      const r4 = n3 ? e3 + "-s" : e3;
      t3.insertAfter(s3, Mr.attribute({ attribute: r4, value: r4, raws: {}, quoteMark: '"' }));
    }
  }
  function Vr(e3) {
    return "combinator" === e3.type && /^\s+$/.test(e3.value);
  }
  Fr.postcss = true;
  var qr = Fr, Wr = {}, Gr = {}, Hr = {}, zr = {}, Kr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  zr.encode = function(e3) {
    if (0 <= e3 && e3 < Kr.length) return Kr[e3];
    throw new TypeError("Must be between 0 and 63: " + e3);
  }, zr.decode = function(e3) {
    return 65 <= e3 && e3 <= 90 ? e3 - 65 : 97 <= e3 && e3 <= 122 ? e3 - 97 + 26 : 48 <= e3 && e3 <= 57 ? e3 - 48 + 52 : 43 == e3 ? 62 : 47 == e3 ? 63 : -1;
  };
  var Xr = zr;
  Hr.encode = function(e3) {
    var t3, r3 = "", n3 = function(e4) {
      return e4 < 0 ? 1 + (-e4 << 1) : 0 + (e4 << 1);
    }(e3);
    do {
      t3 = 31 & n3, (n3 >>>= 5) > 0 && (t3 |= 32), r3 += Xr.encode(t3);
    } while (n3 > 0);
    return r3;
  }, Hr.decode = function(e3, t3, r3) {
    var n3, s3, i3, o3, a3 = e3.length, l2 = 0, c2 = 0;
    do {
      if (t3 >= a3) throw new Error("Expected more digits in base 64 VLQ value.");
      if (-1 === (s3 = Xr.decode(e3.charCodeAt(t3++)))) throw new Error("Invalid base64 digit: " + e3.charAt(t3 - 1));
      n3 = !!(32 & s3), l2 += (s3 &= 31) << c2, c2 += 5;
    } while (n3);
    r3.value = (o3 = (i3 = l2) >> 1, 1 == (1 & i3) ? -o3 : o3), r3.rest = t3;
  };
  var Jr = {};
  !function(e3) {
    e3.getArg = function(e4, t4, r4) {
      if (t4 in e4) return e4[t4];
      if (3 === arguments.length) return r4;
      throw new Error('"' + t4 + '" is a required argument.');
    };
    var t3 = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, r3 = /^data:.+\,.+$/;
    function n3(e4) {
      var r4 = e4.match(t3);
      return r4 ? { scheme: r4[1], auth: r4[2], host: r4[3], port: r4[4], path: r4[5] } : null;
    }
    function s3(e4) {
      var t4 = "";
      return e4.scheme && (t4 += e4.scheme + ":"), t4 += "//", e4.auth && (t4 += e4.auth + "@"), e4.host && (t4 += e4.host), e4.port && (t4 += ":" + e4.port), e4.path && (t4 += e4.path), t4;
    }
    function i3(t4) {
      var r4 = t4, i4 = n3(t4);
      if (i4) {
        if (!i4.path) return t4;
        r4 = i4.path;
      }
      for (var o4, a4 = e3.isAbsolute(r4), l3 = r4.split(/\/+/), c3 = 0, u3 = l3.length - 1; u3 >= 0; u3--) "." === (o4 = l3[u3]) ? l3.splice(u3, 1) : ".." === o4 ? c3++ : c3 > 0 && ("" === o4 ? (l3.splice(u3 + 1, c3), c3 = 0) : (l3.splice(u3, 2), c3--));
      return "" === (r4 = l3.join("/")) && (r4 = a4 ? "/" : "."), i4 ? (i4.path = r4, s3(i4)) : r4;
    }
    function o3(e4, t4) {
      "" === e4 && (e4 = "."), "" === t4 && (t4 = ".");
      var o4 = n3(t4), a4 = n3(e4);
      if (a4 && (e4 = a4.path || "/"), o4 && !o4.scheme) return a4 && (o4.scheme = a4.scheme), s3(o4);
      if (o4 || t4.match(r3)) return t4;
      if (a4 && !a4.host && !a4.path) return a4.host = t4, s3(a4);
      var l3 = "/" === t4.charAt(0) ? t4 : i3(e4.replace(/\/+$/, "") + "/" + t4);
      return a4 ? (a4.path = l3, s3(a4)) : l3;
    }
    e3.urlParse = n3, e3.urlGenerate = s3, e3.normalize = i3, e3.join = o3, e3.isAbsolute = function(e4) {
      return "/" === e4.charAt(0) || t3.test(e4);
    }, e3.relative = function(e4, t4) {
      "" === e4 && (e4 = "."), e4 = e4.replace(/\/$/, "");
      for (var r4 = 0; 0 !== t4.indexOf(e4 + "/"); ) {
        var n4 = e4.lastIndexOf("/");
        if (n4 < 0) return t4;
        if ((e4 = e4.slice(0, n4)).match(/^([^\/]+:\/)?\/*$/)) return t4;
        ++r4;
      }
      return Array(r4 + 1).join("../") + t4.substr(e4.length + 1);
    };
    var a3 = !("__proto__" in /* @__PURE__ */ Object.create(null));
    function l2(e4) {
      return e4;
    }
    function c2(e4) {
      if (!e4) return false;
      var t4 = e4.length;
      if (t4 < 9) return false;
      if (95 !== e4.charCodeAt(t4 - 1) || 95 !== e4.charCodeAt(t4 - 2) || 111 !== e4.charCodeAt(t4 - 3) || 116 !== e4.charCodeAt(t4 - 4) || 111 !== e4.charCodeAt(t4 - 5) || 114 !== e4.charCodeAt(t4 - 6) || 112 !== e4.charCodeAt(t4 - 7) || 95 !== e4.charCodeAt(t4 - 8) || 95 !== e4.charCodeAt(t4 - 9)) return false;
      for (var r4 = t4 - 10; r4 >= 0; r4--) if (36 !== e4.charCodeAt(r4)) return false;
      return true;
    }
    function u2(e4, t4) {
      return e4 === t4 ? 0 : null === e4 ? 1 : null === t4 ? -1 : e4 > t4 ? 1 : -1;
    }
    e3.toSetString = a3 ? l2 : function(e4) {
      return c2(e4) ? "$" + e4 : e4;
    }, e3.fromSetString = a3 ? l2 : function(e4) {
      return c2(e4) ? e4.slice(1) : e4;
    }, e3.compareByOriginalPositions = function(e4, t4, r4) {
      var n4 = u2(e4.source, t4.source);
      return 0 !== n4 || 0 != (n4 = e4.originalLine - t4.originalLine) || 0 != (n4 = e4.originalColumn - t4.originalColumn) || r4 || 0 != (n4 = e4.generatedColumn - t4.generatedColumn) || 0 != (n4 = e4.generatedLine - t4.generatedLine) ? n4 : u2(e4.name, t4.name);
    }, e3.compareByGeneratedPositionsDeflated = function(e4, t4, r4) {
      var n4 = e4.generatedLine - t4.generatedLine;
      return 0 !== n4 || 0 != (n4 = e4.generatedColumn - t4.generatedColumn) || r4 || 0 !== (n4 = u2(e4.source, t4.source)) || 0 != (n4 = e4.originalLine - t4.originalLine) || 0 != (n4 = e4.originalColumn - t4.originalColumn) ? n4 : u2(e4.name, t4.name);
    }, e3.compareByGeneratedPositionsInflated = function(e4, t4) {
      var r4 = e4.generatedLine - t4.generatedLine;
      return 0 !== r4 || 0 != (r4 = e4.generatedColumn - t4.generatedColumn) || 0 !== (r4 = u2(e4.source, t4.source)) || 0 != (r4 = e4.originalLine - t4.originalLine) || 0 != (r4 = e4.originalColumn - t4.originalColumn) ? r4 : u2(e4.name, t4.name);
    }, e3.parseSourceMapInput = function(e4) {
      return JSON.parse(e4.replace(/^\)]}'[^\n]*\n/, ""));
    }, e3.computeSourceURL = function(e4, t4, r4) {
      if (t4 = t4 || "", e4 && ("/" !== e4[e4.length - 1] && "/" !== t4[0] && (e4 += "/"), t4 = e4 + t4), r4) {
        var a4 = n3(r4);
        if (!a4) throw new Error("sourceMapURL could not be parsed");
        if (a4.path) {
          var l3 = a4.path.lastIndexOf("/");
          l3 >= 0 && (a4.path = a4.path.substring(0, l3 + 1));
        }
        t4 = o3(s3(a4), t4);
      }
      return i3(t4);
    };
  }(Jr);
  var Yr = {}, Qr = Jr, Zr = Object.prototype.hasOwnProperty, en = "undefined" != typeof Map;
  function tn() {
    this._array = [], this._set = en ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  tn.fromArray = function(e3, t3) {
    for (var r3 = new tn(), n3 = 0, s3 = e3.length; n3 < s3; n3++) r3.add(e3[n3], t3);
    return r3;
  }, tn.prototype.size = function() {
    return en ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, tn.prototype.add = function(e3, t3) {
    var r3 = en ? e3 : Qr.toSetString(e3), n3 = en ? this.has(e3) : Zr.call(this._set, r3), s3 = this._array.length;
    n3 && !t3 || this._array.push(e3), n3 || (en ? this._set.set(e3, s3) : this._set[r3] = s3);
  }, tn.prototype.has = function(e3) {
    if (en) return this._set.has(e3);
    var t3 = Qr.toSetString(e3);
    return Zr.call(this._set, t3);
  }, tn.prototype.indexOf = function(e3) {
    if (en) {
      var t3 = this._set.get(e3);
      if (t3 >= 0) return t3;
    } else {
      var r3 = Qr.toSetString(e3);
      if (Zr.call(this._set, r3)) return this._set[r3];
    }
    throw new Error('"' + e3 + '" is not in the set.');
  }, tn.prototype.at = function(e3) {
    if (e3 >= 0 && e3 < this._array.length) return this._array[e3];
    throw new Error("No element indexed by " + e3);
  }, tn.prototype.toArray = function() {
    return this._array.slice();
  }, Yr.ArraySet = tn;
  var rn = {}, nn = Jr;
  function sn() {
    this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  sn.prototype.unsortedForEach = function(e3, t3) {
    this._array.forEach(e3, t3);
  }, sn.prototype.add = function(e3) {
    var t3, r3, n3, s3, i3, o3;
    r3 = e3, n3 = (t3 = this._last).generatedLine, s3 = r3.generatedLine, i3 = t3.generatedColumn, o3 = r3.generatedColumn, s3 > n3 || s3 == n3 && o3 >= i3 || nn.compareByGeneratedPositionsInflated(t3, r3) <= 0 ? (this._last = e3, this._array.push(e3)) : (this._sorted = false, this._array.push(e3));
  }, sn.prototype.toArray = function() {
    return this._sorted || (this._array.sort(nn.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
  }, rn.MappingList = sn;
  var on = Hr, an = Jr, ln = Yr.ArraySet, cn = rn.MappingList;
  function un(e3) {
    e3 || (e3 = {}), this._file = an.getArg(e3, "file", null), this._sourceRoot = an.getArg(e3, "sourceRoot", null), this._skipValidation = an.getArg(e3, "skipValidation", false), this._sources = new ln(), this._names = new ln(), this._mappings = new cn(), this._sourcesContents = null;
  }
  un.prototype._version = 3, un.fromSourceMap = function(e3) {
    var t3 = e3.sourceRoot, r3 = new un({ file: e3.file, sourceRoot: t3 });
    return e3.eachMapping(function(e4) {
      var n3 = { generated: { line: e4.generatedLine, column: e4.generatedColumn } };
      null != e4.source && (n3.source = e4.source, null != t3 && (n3.source = an.relative(t3, n3.source)), n3.original = { line: e4.originalLine, column: e4.originalColumn }, null != e4.name && (n3.name = e4.name)), r3.addMapping(n3);
    }), e3.sources.forEach(function(n3) {
      var s3 = n3;
      null !== t3 && (s3 = an.relative(t3, n3)), r3._sources.has(s3) || r3._sources.add(s3);
      var i3 = e3.sourceContentFor(n3);
      null != i3 && r3.setSourceContent(n3, i3);
    }), r3;
  }, un.prototype.addMapping = function(e3) {
    var t3 = an.getArg(e3, "generated"), r3 = an.getArg(e3, "original", null), n3 = an.getArg(e3, "source", null), s3 = an.getArg(e3, "name", null);
    this._skipValidation || this._validateMapping(t3, r3, n3, s3), null != n3 && (n3 = String(n3), this._sources.has(n3) || this._sources.add(n3)), null != s3 && (s3 = String(s3), this._names.has(s3) || this._names.add(s3)), this._mappings.add({ generatedLine: t3.line, generatedColumn: t3.column, originalLine: null != r3 && r3.line, originalColumn: null != r3 && r3.column, source: n3, name: s3 });
  }, un.prototype.setSourceContent = function(e3, t3) {
    var r3 = e3;
    null != this._sourceRoot && (r3 = an.relative(this._sourceRoot, r3)), null != t3 ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[an.toSetString(r3)] = t3) : this._sourcesContents && (delete this._sourcesContents[an.toSetString(r3)], 0 === Object.keys(this._sourcesContents).length && (this._sourcesContents = null));
  }, un.prototype.applySourceMap = function(e3, t3, r3) {
    var n3 = t3;
    if (null == t3) {
      if (null == e3.file) throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      n3 = e3.file;
    }
    var s3 = this._sourceRoot;
    null != s3 && (n3 = an.relative(s3, n3));
    var i3 = new ln(), o3 = new ln();
    this._mappings.unsortedForEach(function(t4) {
      if (t4.source === n3 && null != t4.originalLine) {
        var a3 = e3.originalPositionFor({ line: t4.originalLine, column: t4.originalColumn });
        null != a3.source && (t4.source = a3.source, null != r3 && (t4.source = an.join(r3, t4.source)), null != s3 && (t4.source = an.relative(s3, t4.source)), t4.originalLine = a3.line, t4.originalColumn = a3.column, null != a3.name && (t4.name = a3.name));
      }
      var l2 = t4.source;
      null == l2 || i3.has(l2) || i3.add(l2);
      var c2 = t4.name;
      null == c2 || o3.has(c2) || o3.add(c2);
    }, this), this._sources = i3, this._names = o3, e3.sources.forEach(function(t4) {
      var n4 = e3.sourceContentFor(t4);
      null != n4 && (null != r3 && (t4 = an.join(r3, t4)), null != s3 && (t4 = an.relative(s3, t4)), this.setSourceContent(t4, n4));
    }, this);
  }, un.prototype._validateMapping = function(e3, t3, r3, n3) {
    if (t3 && "number" != typeof t3.line && "number" != typeof t3.column) throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    if ((!(e3 && "line" in e3 && "column" in e3 && e3.line > 0 && e3.column >= 0) || t3 || r3 || n3) && !(e3 && "line" in e3 && "column" in e3 && t3 && "line" in t3 && "column" in t3 && e3.line > 0 && e3.column >= 0 && t3.line > 0 && t3.column >= 0 && r3)) throw new Error("Invalid mapping: " + JSON.stringify({ generated: e3, source: r3, original: t3, name: n3 }));
  }, un.prototype._serializeMappings = function() {
    for (var e3, t3, r3, n3, s3 = 0, i3 = 1, o3 = 0, a3 = 0, l2 = 0, c2 = 0, u2 = "", p2 = this._mappings.toArray(), d2 = 0, f2 = p2.length; d2 < f2; d2++) {
      if (e3 = "", (t3 = p2[d2]).generatedLine !== i3) for (s3 = 0; t3.generatedLine !== i3; ) e3 += ";", i3++;
      else if (d2 > 0) {
        if (!an.compareByGeneratedPositionsInflated(t3, p2[d2 - 1])) continue;
        e3 += ",";
      }
      e3 += on.encode(t3.generatedColumn - s3), s3 = t3.generatedColumn, null != t3.source && (n3 = this._sources.indexOf(t3.source), e3 += on.encode(n3 - c2), c2 = n3, e3 += on.encode(t3.originalLine - 1 - a3), a3 = t3.originalLine - 1, e3 += on.encode(t3.originalColumn - o3), o3 = t3.originalColumn, null != t3.name && (r3 = this._names.indexOf(t3.name), e3 += on.encode(r3 - l2), l2 = r3)), u2 += e3;
    }
    return u2;
  }, un.prototype._generateSourcesContent = function(e3, t3) {
    return e3.map(function(e4) {
      if (!this._sourcesContents) return null;
      null != t3 && (e4 = an.relative(t3, e4));
      var r3 = an.toSetString(e4);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, r3) ? this._sourcesContents[r3] : null;
    }, this);
  }, un.prototype.toJSON = function() {
    var e3 = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
    return null != this._file && (e3.file = this._file), null != this._sourceRoot && (e3.sourceRoot = this._sourceRoot), this._sourcesContents && (e3.sourcesContent = this._generateSourcesContent(e3.sources, e3.sourceRoot)), e3;
  }, un.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, Gr.SourceMapGenerator = un;
  var pn = {}, dn = {};
  !function(e3) {
    function t3(r3, n3, s3, i3, o3, a3) {
      var l2 = Math.floor((n3 - r3) / 2) + r3, c2 = o3(s3, i3[l2], true);
      return 0 === c2 ? l2 : c2 > 0 ? n3 - l2 > 1 ? t3(l2, n3, s3, i3, o3, a3) : a3 == e3.LEAST_UPPER_BOUND ? n3 < i3.length ? n3 : -1 : l2 : l2 - r3 > 1 ? t3(r3, l2, s3, i3, o3, a3) : a3 == e3.LEAST_UPPER_BOUND ? l2 : r3 < 0 ? -1 : r3;
    }
    e3.GREATEST_LOWER_BOUND = 1, e3.LEAST_UPPER_BOUND = 2, e3.search = function(r3, n3, s3, i3) {
      if (0 === n3.length) return -1;
      var o3 = t3(-1, n3.length, r3, n3, s3, i3 || e3.GREATEST_LOWER_BOUND);
      if (o3 < 0) return -1;
      for (; o3 - 1 >= 0 && 0 === s3(n3[o3], n3[o3 - 1], true); ) --o3;
      return o3;
    };
  }(dn);
  var fn = {};
  function hn(e3, t3, r3) {
    var n3 = e3[t3];
    e3[t3] = e3[r3], e3[r3] = n3;
  }
  function mn(e3, t3, r3, n3) {
    if (r3 < n3) {
      var s3 = r3 - 1;
      hn(e3, (l2 = r3, c2 = n3, Math.round(l2 + Math.random() * (c2 - l2))), n3);
      for (var i3 = e3[n3], o3 = r3; o3 < n3; o3++) t3(e3[o3], i3) <= 0 && hn(e3, s3 += 1, o3);
      hn(e3, s3 + 1, o3);
      var a3 = s3 + 1;
      mn(e3, t3, r3, a3 - 1), mn(e3, t3, a3 + 1, n3);
    }
    var l2, c2;
  }
  fn.quickSort = function(e3, t3) {
    mn(e3, t3, 0, e3.length - 1);
  };
  var yn = Jr, gn = dn, bn = Yr.ArraySet, vn = Hr, En = fn.quickSort;
  function Sn(e3, t3) {
    var r3 = e3;
    return "string" == typeof e3 && (r3 = yn.parseSourceMapInput(e3)), null != r3.sections ? new wn(r3, t3) : new xn(r3, t3);
  }
  function xn(e3, t3) {
    var r3 = e3;
    "string" == typeof e3 && (r3 = yn.parseSourceMapInput(e3));
    var n3 = yn.getArg(r3, "version"), s3 = yn.getArg(r3, "sources"), i3 = yn.getArg(r3, "names", []), o3 = yn.getArg(r3, "sourceRoot", null), a3 = yn.getArg(r3, "sourcesContent", null), l2 = yn.getArg(r3, "mappings"), c2 = yn.getArg(r3, "file", null);
    if (n3 != this._version) throw new Error("Unsupported version: " + n3);
    o3 && (o3 = yn.normalize(o3)), s3 = s3.map(String).map(yn.normalize).map(function(e4) {
      return o3 && yn.isAbsolute(o3) && yn.isAbsolute(e4) ? yn.relative(o3, e4) : e4;
    }), this._names = bn.fromArray(i3.map(String), true), this._sources = bn.fromArray(s3, true), this._absoluteSources = this._sources.toArray().map(function(e4) {
      return yn.computeSourceURL(o3, e4, t3);
    }), this.sourceRoot = o3, this.sourcesContent = a3, this._mappings = l2, this._sourceMapURL = t3, this.file = c2;
  }
  function Tn() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  function wn(e3, t3) {
    var r3 = e3;
    "string" == typeof e3 && (r3 = yn.parseSourceMapInput(e3));
    var n3 = yn.getArg(r3, "version"), s3 = yn.getArg(r3, "sections");
    if (n3 != this._version) throw new Error("Unsupported version: " + n3);
    this._sources = new bn(), this._names = new bn();
    var i3 = { line: -1, column: 0 };
    this._sections = s3.map(function(e4) {
      if (e4.url) throw new Error("Support for url field in sections not implemented.");
      var r4 = yn.getArg(e4, "offset"), n4 = yn.getArg(r4, "line"), s4 = yn.getArg(r4, "column");
      if (n4 < i3.line || n4 === i3.line && s4 < i3.column) throw new Error("Section offsets must be ordered and non-overlapping.");
      return i3 = r4, { generatedOffset: { generatedLine: n4 + 1, generatedColumn: s4 + 1 }, consumer: new Sn(yn.getArg(e4, "map"), t3) };
    });
  }
  Sn.fromSourceMap = function(e3, t3) {
    return xn.fromSourceMap(e3, t3);
  }, Sn.prototype._version = 3, Sn.prototype.__generatedMappings = null, Object.defineProperty(Sn.prototype, "_generatedMappings", { configurable: true, enumerable: true, get: function() {
    return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
  } }), Sn.prototype.__originalMappings = null, Object.defineProperty(Sn.prototype, "_originalMappings", { configurable: true, enumerable: true, get: function() {
    return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
  } }), Sn.prototype._charIsMappingSeparator = function(e3, t3) {
    var r3 = e3.charAt(t3);
    return ";" === r3 || "," === r3;
  }, Sn.prototype._parseMappings = function(e3, t3) {
    throw new Error("Subclasses must implement _parseMappings");
  }, Sn.GENERATED_ORDER = 1, Sn.ORIGINAL_ORDER = 2, Sn.GREATEST_LOWER_BOUND = 1, Sn.LEAST_UPPER_BOUND = 2, Sn.prototype.eachMapping = function(e3, t3, r3) {
    var n3, s3 = t3 || null;
    switch (r3 || Sn.GENERATED_ORDER) {
      case Sn.GENERATED_ORDER:
        n3 = this._generatedMappings;
        break;
      case Sn.ORIGINAL_ORDER:
        n3 = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var i3 = this.sourceRoot;
    n3.map(function(e4) {
      var t4 = null === e4.source ? null : this._sources.at(e4.source);
      return { source: t4 = yn.computeSourceURL(i3, t4, this._sourceMapURL), generatedLine: e4.generatedLine, generatedColumn: e4.generatedColumn, originalLine: e4.originalLine, originalColumn: e4.originalColumn, name: null === e4.name ? null : this._names.at(e4.name) };
    }, this).forEach(e3, s3);
  }, Sn.prototype.allGeneratedPositionsFor = function(e3) {
    var t3 = yn.getArg(e3, "line"), r3 = { source: yn.getArg(e3, "source"), originalLine: t3, originalColumn: yn.getArg(e3, "column", 0) };
    if (r3.source = this._findSourceIndex(r3.source), r3.source < 0) return [];
    var n3 = [], s3 = this._findMapping(r3, this._originalMappings, "originalLine", "originalColumn", yn.compareByOriginalPositions, gn.LEAST_UPPER_BOUND);
    if (s3 >= 0) {
      var i3 = this._originalMappings[s3];
      if (void 0 === e3.column) for (var o3 = i3.originalLine; i3 && i3.originalLine === o3; ) n3.push({ line: yn.getArg(i3, "generatedLine", null), column: yn.getArg(i3, "generatedColumn", null), lastColumn: yn.getArg(i3, "lastGeneratedColumn", null) }), i3 = this._originalMappings[++s3];
      else for (var a3 = i3.originalColumn; i3 && i3.originalLine === t3 && i3.originalColumn == a3; ) n3.push({ line: yn.getArg(i3, "generatedLine", null), column: yn.getArg(i3, "generatedColumn", null), lastColumn: yn.getArg(i3, "lastGeneratedColumn", null) }), i3 = this._originalMappings[++s3];
    }
    return n3;
  }, pn.SourceMapConsumer = Sn, xn.prototype = Object.create(Sn.prototype), xn.prototype.consumer = Sn, xn.prototype._findSourceIndex = function(e3) {
    var t3, r3 = e3;
    if (null != this.sourceRoot && (r3 = yn.relative(this.sourceRoot, r3)), this._sources.has(r3)) return this._sources.indexOf(r3);
    for (t3 = 0; t3 < this._absoluteSources.length; ++t3) if (this._absoluteSources[t3] == e3) return t3;
    return -1;
  }, xn.fromSourceMap = function(e3, t3) {
    var r3 = Object.create(xn.prototype), n3 = r3._names = bn.fromArray(e3._names.toArray(), true), s3 = r3._sources = bn.fromArray(e3._sources.toArray(), true);
    r3.sourceRoot = e3._sourceRoot, r3.sourcesContent = e3._generateSourcesContent(r3._sources.toArray(), r3.sourceRoot), r3.file = e3._file, r3._sourceMapURL = t3, r3._absoluteSources = r3._sources.toArray().map(function(e4) {
      return yn.computeSourceURL(r3.sourceRoot, e4, t3);
    });
    for (var i3 = e3._mappings.toArray().slice(), o3 = r3.__generatedMappings = [], a3 = r3.__originalMappings = [], l2 = 0, c2 = i3.length; l2 < c2; l2++) {
      var u2 = i3[l2], p2 = new Tn();
      p2.generatedLine = u2.generatedLine, p2.generatedColumn = u2.generatedColumn, u2.source && (p2.source = s3.indexOf(u2.source), p2.originalLine = u2.originalLine, p2.originalColumn = u2.originalColumn, u2.name && (p2.name = n3.indexOf(u2.name)), a3.push(p2)), o3.push(p2);
    }
    return En(r3.__originalMappings, yn.compareByOriginalPositions), r3;
  }, xn.prototype._version = 3, Object.defineProperty(xn.prototype, "sources", { get: function() {
    return this._absoluteSources.slice();
  } }), xn.prototype._parseMappings = function(e3, t3) {
    for (var r3, n3, s3, i3, o3, a3 = 1, l2 = 0, c2 = 0, u2 = 0, p2 = 0, d2 = 0, f2 = e3.length, h2 = 0, m2 = {}, y2 = {}, g2 = [], b2 = []; h2 < f2; ) if (";" === e3.charAt(h2)) a3++, h2++, l2 = 0;
    else if ("," === e3.charAt(h2)) h2++;
    else {
      for ((r3 = new Tn()).generatedLine = a3, i3 = h2; i3 < f2 && !this._charIsMappingSeparator(e3, i3); i3++) ;
      if (s3 = m2[n3 = e3.slice(h2, i3)]) h2 += n3.length;
      else {
        for (s3 = []; h2 < i3; ) vn.decode(e3, h2, y2), o3 = y2.value, h2 = y2.rest, s3.push(o3);
        if (2 === s3.length) throw new Error("Found a source, but no line and column");
        if (3 === s3.length) throw new Error("Found a source and line, but no column");
        m2[n3] = s3;
      }
      r3.generatedColumn = l2 + s3[0], l2 = r3.generatedColumn, s3.length > 1 && (r3.source = p2 + s3[1], p2 += s3[1], r3.originalLine = c2 + s3[2], c2 = r3.originalLine, r3.originalLine += 1, r3.originalColumn = u2 + s3[3], u2 = r3.originalColumn, s3.length > 4 && (r3.name = d2 + s3[4], d2 += s3[4])), b2.push(r3), "number" == typeof r3.originalLine && g2.push(r3);
    }
    En(b2, yn.compareByGeneratedPositionsDeflated), this.__generatedMappings = b2, En(g2, yn.compareByOriginalPositions), this.__originalMappings = g2;
  }, xn.prototype._findMapping = function(e3, t3, r3, n3, s3, i3) {
    if (e3[r3] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + e3[r3]);
    if (e3[n3] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + e3[n3]);
    return gn.search(e3, t3, s3, i3);
  }, xn.prototype.computeColumnSpans = function() {
    for (var e3 = 0; e3 < this._generatedMappings.length; ++e3) {
      var t3 = this._generatedMappings[e3];
      if (e3 + 1 < this._generatedMappings.length) {
        var r3 = this._generatedMappings[e3 + 1];
        if (t3.generatedLine === r3.generatedLine) {
          t3.lastGeneratedColumn = r3.generatedColumn - 1;
          continue;
        }
      }
      t3.lastGeneratedColumn = 1 / 0;
    }
  }, xn.prototype.originalPositionFor = function(e3) {
    var t3 = { generatedLine: yn.getArg(e3, "line"), generatedColumn: yn.getArg(e3, "column") }, r3 = this._findMapping(t3, this._generatedMappings, "generatedLine", "generatedColumn", yn.compareByGeneratedPositionsDeflated, yn.getArg(e3, "bias", Sn.GREATEST_LOWER_BOUND));
    if (r3 >= 0) {
      var n3 = this._generatedMappings[r3];
      if (n3.generatedLine === t3.generatedLine) {
        var s3 = yn.getArg(n3, "source", null);
        null !== s3 && (s3 = this._sources.at(s3), s3 = yn.computeSourceURL(this.sourceRoot, s3, this._sourceMapURL));
        var i3 = yn.getArg(n3, "name", null);
        return null !== i3 && (i3 = this._names.at(i3)), { source: s3, line: yn.getArg(n3, "originalLine", null), column: yn.getArg(n3, "originalColumn", null), name: i3 };
      }
    }
    return { source: null, line: null, column: null, name: null };
  }, xn.prototype.hasContentsOfAllSources = function() {
    return !!this.sourcesContent && this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e3) {
      return null == e3;
    });
  }, xn.prototype.sourceContentFor = function(e3, t3) {
    if (!this.sourcesContent) return null;
    var r3 = this._findSourceIndex(e3);
    if (r3 >= 0) return this.sourcesContent[r3];
    var n3, s3 = e3;
    if (null != this.sourceRoot && (s3 = yn.relative(this.sourceRoot, s3)), null != this.sourceRoot && (n3 = yn.urlParse(this.sourceRoot))) {
      var i3 = s3.replace(/^file:\/\//, "");
      if ("file" == n3.scheme && this._sources.has(i3)) return this.sourcesContent[this._sources.indexOf(i3)];
      if ((!n3.path || "/" == n3.path) && this._sources.has("/" + s3)) return this.sourcesContent[this._sources.indexOf("/" + s3)];
    }
    if (t3) return null;
    throw new Error('"' + s3 + '" is not in the SourceMap.');
  }, xn.prototype.generatedPositionFor = function(e3) {
    var t3 = yn.getArg(e3, "source");
    if ((t3 = this._findSourceIndex(t3)) < 0) return { line: null, column: null, lastColumn: null };
    var r3 = { source: t3, originalLine: yn.getArg(e3, "line"), originalColumn: yn.getArg(e3, "column") }, n3 = this._findMapping(r3, this._originalMappings, "originalLine", "originalColumn", yn.compareByOriginalPositions, yn.getArg(e3, "bias", Sn.GREATEST_LOWER_BOUND));
    if (n3 >= 0) {
      var s3 = this._originalMappings[n3];
      if (s3.source === r3.source) return { line: yn.getArg(s3, "generatedLine", null), column: yn.getArg(s3, "generatedColumn", null), lastColumn: yn.getArg(s3, "lastGeneratedColumn", null) };
    }
    return { line: null, column: null, lastColumn: null };
  }, pn.BasicSourceMapConsumer = xn, wn.prototype = Object.create(Sn.prototype), wn.prototype.constructor = Sn, wn.prototype._version = 3, Object.defineProperty(wn.prototype, "sources", { get: function() {
    for (var e3 = [], t3 = 0; t3 < this._sections.length; t3++) for (var r3 = 0; r3 < this._sections[t3].consumer.sources.length; r3++) e3.push(this._sections[t3].consumer.sources[r3]);
    return e3;
  } }), wn.prototype.originalPositionFor = function(e3) {
    var t3 = { generatedLine: yn.getArg(e3, "line"), generatedColumn: yn.getArg(e3, "column") }, r3 = gn.search(t3, this._sections, function(e4, t4) {
      return e4.generatedLine - t4.generatedOffset.generatedLine || e4.generatedColumn - t4.generatedOffset.generatedColumn;
    }), n3 = this._sections[r3];
    return n3 ? n3.consumer.originalPositionFor({ line: t3.generatedLine - (n3.generatedOffset.generatedLine - 1), column: t3.generatedColumn - (n3.generatedOffset.generatedLine === t3.generatedLine ? n3.generatedOffset.generatedColumn - 1 : 0), bias: e3.bias }) : { source: null, line: null, column: null, name: null };
  }, wn.prototype.hasContentsOfAllSources = function() {
    return this._sections.every(function(e3) {
      return e3.consumer.hasContentsOfAllSources();
    });
  }, wn.prototype.sourceContentFor = function(e3, t3) {
    for (var r3 = 0; r3 < this._sections.length; r3++) {
      var n3 = this._sections[r3].consumer.sourceContentFor(e3, true);
      if (n3) return n3;
    }
    if (t3) return null;
    throw new Error('"' + e3 + '" is not in the SourceMap.');
  }, wn.prototype.generatedPositionFor = function(e3) {
    for (var t3 = 0; t3 < this._sections.length; t3++) {
      var r3 = this._sections[t3];
      if (-1 !== r3.consumer._findSourceIndex(yn.getArg(e3, "source"))) {
        var n3 = r3.consumer.generatedPositionFor(e3);
        if (n3) return { line: n3.line + (r3.generatedOffset.generatedLine - 1), column: n3.column + (r3.generatedOffset.generatedLine === n3.line ? r3.generatedOffset.generatedColumn - 1 : 0) };
      }
    }
    return { line: null, column: null };
  }, wn.prototype._parseMappings = function(e3, t3) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var r3 = 0; r3 < this._sections.length; r3++) for (var n3 = this._sections[r3], s3 = n3.consumer._generatedMappings, i3 = 0; i3 < s3.length; i3++) {
      var o3 = s3[i3], a3 = n3.consumer._sources.at(o3.source);
      a3 = yn.computeSourceURL(n3.consumer.sourceRoot, a3, this._sourceMapURL), this._sources.add(a3), a3 = this._sources.indexOf(a3);
      var l2 = null;
      o3.name && (l2 = n3.consumer._names.at(o3.name), this._names.add(l2), l2 = this._names.indexOf(l2));
      var c2 = { source: a3, generatedLine: o3.generatedLine + (n3.generatedOffset.generatedLine - 1), generatedColumn: o3.generatedColumn + (n3.generatedOffset.generatedLine === o3.generatedLine ? n3.generatedOffset.generatedColumn - 1 : 0), originalLine: o3.originalLine, originalColumn: o3.originalColumn, name: l2 };
      this.__generatedMappings.push(c2), "number" == typeof c2.originalLine && this.__originalMappings.push(c2);
    }
    En(this.__generatedMappings, yn.compareByGeneratedPositionsDeflated), En(this.__originalMappings, yn.compareByOriginalPositions);
  }, pn.IndexedSourceMapConsumer = wn;
  var Pn = {}, An = Gr.SourceMapGenerator, Cn = Jr, On = /(\r?\n)/, In = "$$$isSourceNode$$$";
  function _n(e3, t3, r3, n3, s3) {
    this.children = [], this.sourceContents = {}, this.line = null == e3 ? null : e3, this.column = null == t3 ? null : t3, this.source = null == r3 ? null : r3, this.name = null == s3 ? null : s3, this[In] = true, null != n3 && this.add(n3);
  }
  _n.fromStringWithSourceMap = function(e3, t3, r3) {
    var n3 = new _n(), s3 = e3.split(On), i3 = 0, o3 = function() {
      return e4() + (e4() || "");
      function e4() {
        return i3 < s3.length ? s3[i3++] : void 0;
      }
    }, a3 = 1, l2 = 0, c2 = null;
    return t3.eachMapping(function(e4) {
      if (null !== c2) {
        if (!(a3 < e4.generatedLine)) {
          var t4 = (r4 = s3[i3] || "").substr(0, e4.generatedColumn - l2);
          return s3[i3] = r4.substr(e4.generatedColumn - l2), l2 = e4.generatedColumn, u2(c2, t4), void (c2 = e4);
        }
        u2(c2, o3()), a3++, l2 = 0;
      }
      for (; a3 < e4.generatedLine; ) n3.add(o3()), a3++;
      if (l2 < e4.generatedColumn) {
        var r4 = s3[i3] || "";
        n3.add(r4.substr(0, e4.generatedColumn)), s3[i3] = r4.substr(e4.generatedColumn), l2 = e4.generatedColumn;
      }
      c2 = e4;
    }, this), i3 < s3.length && (c2 && u2(c2, o3()), n3.add(s3.splice(i3).join(""))), t3.sources.forEach(function(e4) {
      var s4 = t3.sourceContentFor(e4);
      null != s4 && (null != r3 && (e4 = Cn.join(r3, e4)), n3.setSourceContent(e4, s4));
    }), n3;
    function u2(e4, t4) {
      if (null === e4 || void 0 === e4.source) n3.add(t4);
      else {
        var s4 = r3 ? Cn.join(r3, e4.source) : e4.source;
        n3.add(new _n(e4.originalLine, e4.originalColumn, s4, t4, e4.name));
      }
    }
  }, _n.prototype.add = function(e3) {
    if (Array.isArray(e3)) e3.forEach(function(e4) {
      this.add(e4);
    }, this);
    else {
      if (!e3[In] && "string" != typeof e3) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e3);
      e3 && this.children.push(e3);
    }
    return this;
  }, _n.prototype.prepend = function(e3) {
    if (Array.isArray(e3)) for (var t3 = e3.length - 1; t3 >= 0; t3--) this.prepend(e3[t3]);
    else {
      if (!e3[In] && "string" != typeof e3) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e3);
      this.children.unshift(e3);
    }
    return this;
  }, _n.prototype.walk = function(e3) {
    for (var t3, r3 = 0, n3 = this.children.length; r3 < n3; r3++) (t3 = this.children[r3])[In] ? t3.walk(e3) : "" !== t3 && e3(t3, { source: this.source, line: this.line, column: this.column, name: this.name });
  }, _n.prototype.join = function(e3) {
    var t3, r3, n3 = this.children.length;
    if (n3 > 0) {
      for (t3 = [], r3 = 0; r3 < n3 - 1; r3++) t3.push(this.children[r3]), t3.push(e3);
      t3.push(this.children[r3]), this.children = t3;
    }
    return this;
  }, _n.prototype.replaceRight = function(e3, t3) {
    var r3 = this.children[this.children.length - 1];
    return r3[In] ? r3.replaceRight(e3, t3) : "string" == typeof r3 ? this.children[this.children.length - 1] = r3.replace(e3, t3) : this.children.push("".replace(e3, t3)), this;
  }, _n.prototype.setSourceContent = function(e3, t3) {
    this.sourceContents[Cn.toSetString(e3)] = t3;
  }, _n.prototype.walkSourceContents = function(e3) {
    for (var t3 = 0, r3 = this.children.length; t3 < r3; t3++) this.children[t3][In] && this.children[t3].walkSourceContents(e3);
    var n3 = Object.keys(this.sourceContents);
    for (t3 = 0, r3 = n3.length; t3 < r3; t3++) e3(Cn.fromSetString(n3[t3]), this.sourceContents[n3[t3]]);
  }, _n.prototype.toString = function() {
    var e3 = "";
    return this.walk(function(t3) {
      e3 += t3;
    }), e3;
  }, _n.prototype.toStringWithSourceMap = function(e3) {
    var t3 = { code: "", line: 1, column: 0 }, r3 = new An(e3), n3 = false, s3 = null, i3 = null, o3 = null, a3 = null;
    return this.walk(function(e4, l2) {
      t3.code += e4, null !== l2.source && null !== l2.line && null !== l2.column ? (s3 === l2.source && i3 === l2.line && o3 === l2.column && a3 === l2.name || r3.addMapping({ source: l2.source, original: { line: l2.line, column: l2.column }, generated: { line: t3.line, column: t3.column }, name: l2.name }), s3 = l2.source, i3 = l2.line, o3 = l2.column, a3 = l2.name, n3 = true) : n3 && (r3.addMapping({ generated: { line: t3.line, column: t3.column } }), s3 = null, n3 = false);
      for (var c2 = 0, u2 = e4.length; c2 < u2; c2++) 10 === e4.charCodeAt(c2) ? (t3.line++, t3.column = 0, c2 + 1 === u2 ? (s3 = null, n3 = false) : n3 && r3.addMapping({ source: l2.source, original: { line: l2.line, column: l2.column }, generated: { line: t3.line, column: t3.column }, name: l2.name })) : t3.column++;
    }), this.walkSourceContents(function(e4, t4) {
      r3.setSourceContent(e4, t4);
    }), { code: t3.code, map: r3 };
  }, Pn.SourceNode = _n, Wr.SourceMapGenerator = Gr.SourceMapGenerator, Wr.SourceMapConsumer = pn.SourceMapConsumer, Wr.SourceNode = Pn.SourceNode;
  var kn = Wr, Nn = kn.SourceMapConsumer, Dn = kn.SourceMapGenerator, jn = q(function(e3, t3) {
    if (!e3) return t3;
    if (!t3) return e3;
    var r3 = new Nn(e3), n3 = new Nn(t3), s3 = new Dn();
    return n3.eachMapping(function(e4) {
      if (null != e4.originalLine) {
        var t4 = r3.originalPositionFor({ line: e4.originalLine, column: e4.originalColumn });
        null != t4.source && s3.addMapping({ original: { line: t4.line, column: t4.column }, generated: { line: e4.generatedLine, column: e4.generatedColumn }, source: t4.source, name: t4.name });
      }
    }), [r3, n3].forEach(function(e4) {
      e4.sources.forEach(function(t4) {
        s3._sources.add(t4);
        var r4 = e4.sourceContentFor(t4);
        null != r4 && s3.setSourceContent(t4, r4);
      });
    }), s3._sourceRoot = e3.sourceRoot, s3._file = e3.file, JSON.parse(s3.toString());
  });
  const Ln = function(e3, t3, n3) {
    const s3 = (arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : r2(329))("sass"), i3 = { ...n3, data: Bn(e3, n3.filename, n3.additionalData), file: n3.filename, outFile: n3.filename, sourceMap: !!t3 };
    try {
      const e4 = s3.renderSync(i3), r3 = e4.stats.includedFiles;
      return t3 ? { code: e4.css.toString(), map: jn(t3, JSON.parse(e4.map.toString())), errors: [], dependencies: r3 } : { code: e4.css.toString(), errors: [], dependencies: r3 };
    } catch (e4) {
      return { code: "", errors: [e4], dependencies: [] };
    }
  }, Mn = function(e3, t3, n3) {
    const s3 = (arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : r2(329))("stylus");
    try {
      const r3 = s3(e3, n3);
      t3 && r3.set("sourcemap", { inline: false, comment: false });
      const i3 = r3.render(), o3 = r3.deps();
      return t3 ? { code: i3, map: jn(t3, r3.sourcemap), errors: [], dependencies: o3 } : { code: i3, errors: [], dependencies: o3 };
    } catch (e4) {
      return { code: "", errors: [e4], dependencies: [] };
    }
  };
  function Bn(e3, t3, r3) {
    return r3 ? c.isFunction(r3) ? r3(e3, t3) : r3 + e3 : e3;
  }
  const Rn = { less: function(e3, t3, n3) {
    const s3 = (arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : r2(329))("less");
    let i3, o3 = null;
    if (s3.render(Bn(e3, n3.filename, n3.additionalData), { ...n3, syncImport: true }, (e4, t4) => {
      o3 = e4, i3 = t4;
    }), o3) return { code: "", errors: [o3], dependencies: [] };
    const a3 = i3.imports;
    return t3 ? { code: i3.css.toString(), map: jn(t3, i3.map), errors: [], dependencies: a3 } : { code: i3.css.toString(), errors: [], dependencies: a3 };
  }, sass: (e3, t3, r3, n3) => Ln(e3, t3, { ...r3, indentedSyntax: true }, n3), scss: Ln, styl: Mn, stylus: Mn };
  var Fn = { exports: {} }, Un = {};
  Object.defineProperty(Un, "__esModule", { value: true }), Un.getFileSystem = function() {
    return $n;
  }, Un.setFileSystem = function(e3) {
    $n.readFile = e3.readFile, $n.writeFile = e3.writeFile;
  };
  let $n = { readFile: () => {
    throw Error("readFile not implemented");
  }, writeFile: () => {
    throw Error("writeFile not implemented");
  } };
  var Vn = {}, qn = {};
  Object.defineProperty(qn, "__esModule", { value: true }), qn.default = function(e3) {
    return e3 ? (Wn.test(e3.charAt(0)) && (e3 = e3.substr(1)), Wn.test(e3.charAt(e3.length - 1)) && (e3 = e3.substr(0, e3.length - 1)), e3) : "";
  };
  const Wn = /['"]/;
  var Gn = {};
  const Hn = /[$]?[\w-]+/g;
  var zn = (e3, t3) => {
    let r3;
    for (; r3 = Hn.exec(e3); ) {
      const n3 = t3[r3[0]];
      n3 && (e3 = e3.slice(0, r3.index) + n3 + e3.slice(Hn.lastIndex), Hn.lastIndex -= r3[0].length - n3.length);
    }
    return e3;
  };
  const Kn = zn;
  const Xn = /^:import\(("[^"]*"|'[^']*'|[^"']+)\)$/, Jn = /^("[^"]*"|'[^']*'|[^"']+)$/, Yn = (e3) => {
    const t3 = {};
    return e3.walkDecls((e4) => {
      const r3 = e4.raws.before ? e4.raws.before.trim() : "";
      t3[r3 + e4.prop] = e4.value;
    }), t3;
  };
  const Qn = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "rule";
    return Object.keys(e3).map((n3) => {
      const s3 = e3[n3], i3 = Object.keys(s3).map((e4) => t3.decl({ prop: e4, value: s3[e4], raws: { before: "\n  " } })), o3 = i3.length > 0, a3 = "rule" === r3 ? t3.rule({ selector: `:import('${n3}')`, raws: { after: o3 ? "\n" : "" } }) : t3.atRule({ name: "icss-import", params: `'${n3}'`, raws: { after: o3 ? "\n" : "" } });
      return o3 && a3.append(i3), a3;
    });
  }, Zn = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "rule";
    const n3 = Object.keys(e3).map((r4) => t3.decl({ prop: r4, value: e3[r4], raws: { before: "\n  " } }));
    if (0 === n3.length) return [];
    const s3 = "rule" === r3 ? t3.rule({ selector: ":export", raws: { after: "\n" } }) : t3.atRule({ name: "icss-export", raws: { after: "\n" } });
    return s3.append(n3), [s3];
  };
  var es = { replaceValueSymbols: zn, replaceSymbols: (e3, t3) => {
    e3.walk((e4) => {
      "decl" === e4.type && e4.value ? e4.value = Kn(e4.value.toString(), t3) : "rule" === e4.type && e4.selector ? e4.selector = Kn(e4.selector.toString(), t3) : "atrule" === e4.type && e4.params && (e4.params = Kn(e4.params.toString(), t3));
    });
  }, extractICSS: function(e3) {
    let t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "auto";
    const n3 = {}, s3 = {};
    function i3(e4, r4) {
      const s4 = r4.replace(/'|"/g, "");
      n3[s4] = Object.assign(n3[s4] || {}, Yn(e4)), t3 && e4.remove();
    }
    function o3(e4) {
      Object.assign(s3, Yn(e4)), t3 && e4.remove();
    }
    return e3.each((e4) => {
      if ("rule" === e4.type && "at-rule" !== r3) {
        if (":import" === e4.selector.slice(0, 7)) {
          const t4 = Xn.exec(e4.selector);
          t4 && i3(e4, t4[1]);
        }
        ":export" === e4.selector && o3(e4);
      }
      if ("atrule" === e4.type && "rule" !== r3) {
        if ("icss-import" === e4.name) {
          const t4 = Jn.exec(e4.params);
          t4 && i3(e4, t4[1]);
        }
        "icss-export" === e4.name && o3(e4);
      }
    }), { icssImports: n3, icssExports: s3 };
  }, createICSSRules: (e3, t3, r3, n3) => [...Qn(e3, r3, n3), ...Zn(t3, r3, n3)] };
  Object.defineProperty(Gn, "__esModule", { value: true }), Gn.default = void 0;
  var ts = es;
  const rs = /^:import\((.+)\)$/;
  Gn.default = class {
    constructor(e3, t3) {
      this.pathFetcher = e3, this.plugin = this.plugin.bind(this), this.exportTokens = {}, this.translations = {}, this.trace = t3;
    }
    plugin() {
      const e3 = this;
      return { postcssPlugin: "css-modules-parser", OnceExit: async (t3) => (await Promise.all(e3.fetchAllImports(t3)), e3.linkImportedSymbols(t3), e3.extractExports(t3)) };
    }
    fetchAllImports(e3) {
      let t3 = [];
      return e3.each((r3) => {
        "rule" == r3.type && r3.selector.match(rs) && t3.push(this.fetchImport(r3, e3.source.input.from, t3.length));
      }), t3;
    }
    linkImportedSymbols(e3) {
      (0, ts.replaceSymbols)(e3, this.translations);
    }
    extractExports(e3) {
      e3.each((e4) => {
        "rule" == e4.type && ":export" == e4.selector && this.handleExport(e4);
      });
    }
    handleExport(e3) {
      e3.each((e4) => {
        "decl" == e4.type && (Object.keys(this.translations).forEach((t3) => {
          e4.value = e4.value.replace(t3, this.translations[t3]);
        }), this.exportTokens[e4.prop] = e4.value);
      }), e3.remove();
    }
    async fetchImport(e3, t3, r3) {
      const n3 = e3.selector.match(rs)[1], s3 = this.trace + String.fromCharCode(r3), i3 = await this.pathFetcher(n3, t3, s3);
      try {
        e3.each((e4) => {
          "decl" == e4.type && (this.translations[e4.prop] = i3[e4.value]);
        }), e3.remove();
      } catch (e4) {
      }
    }
  };
  var ns = {};
  Object.defineProperty(ns, "__esModule", { value: true }), ns.default = function(e3, t3) {
    return new Promise((r3, n3) => {
      const { writeFile: s3 } = (0, is.getFileSystem)();
      s3(`${e3}.json`, JSON.stringify(t3), (e4) => e4 ? n3(e4) : r3(t3));
    });
  };
  var ss, is = Un, os = {}, as = 1 / 0, ls = "[object Symbol]", cs = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, us = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, ps = "\\ud800-\\udfff", ds = "\\u0300-\\u036f\\ufe20-\\ufe23", fs = "\\u20d0-\\u20f0", hs = "\\u2700-\\u27bf", ms = "a-z\\xdf-\\xf6\\xf8-\\xff", ys = "A-Z\\xc0-\\xd6\\xd8-\\xde", gs = "\\ufe0e\\ufe0f", bs = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", vs = "[" + ps + "]", Es = "[" + bs + "]", Ss = "[" + ds + fs + "]", xs = "\\d+", Ts = "[" + hs + "]", ws = "[" + ms + "]", Ps = "[^" + ps + bs + xs + hs + ms + ys + "]", As = "\\ud83c[\\udffb-\\udfff]", Cs = "[^" + ps + "]", Os = "(?:\\ud83c[\\udde6-\\uddff]){2}", Is = "[\\ud800-\\udbff][\\udc00-\\udfff]", _s = "[" + ys + "]", ks = "\\u200d", Ns = "(?:" + ws + "|" + Ps + ")", Ds = "(?:" + _s + "|" + Ps + ")", js = "(?:['](?:d|ll|m|re|s|t|ve))?", Ls = "(?:['](?:D|LL|M|RE|S|T|VE))?", Ms = "(?:" + Ss + "|" + As + ")?", Bs = "[" + gs + "]?", Rs = Bs + Ms + "(?:" + ks + "(?:" + [Cs, Os, Is].join("|") + ")" + Bs + Ms + ")*", Fs = "(?:" + [Ts, Os, Is].join("|") + ")" + Rs, Us = "(?:" + [Cs + Ss + "?", Ss, Os, Is, vs].join("|") + ")", $s = RegExp("[']", "g"), Vs = RegExp(Ss, "g"), qs = RegExp(As + "(?=" + As + ")|" + Us + Rs, "g"), Ws = RegExp([_s + "?" + ws + "+" + js + "(?=" + [Es, _s, "$"].join("|") + ")", Ds + "+" + Ls + "(?=" + [Es, _s + Ns, "$"].join("|") + ")", _s + "?" + Ns + "+" + js, _s + "+" + Ls, xs, Fs].join("|"), "g"), Gs = RegExp("[" + ks + ps + ds + fs + gs + "]"), Hs = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, zs = "object" == typeof V && V && V.Object === Object && V, Ks = "object" == typeof self && self && self.Object === Object && self, Xs = zs || Ks || Function("return this")(), Js = (ss = { : "A", : "A", : "A", : "A", : "A", : "A", : "a", : "a", : "a", : "a", : "a", : "a", : "C", : "c", : "D", : "d", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "N", : "n", : "O", : "O", : "O", : "O", : "O", : "O", : "o", : "o", : "o", : "o", : "o", : "o", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "Y", : "y", : "y", : "Ae", : "ae", : "Th", : "th", : "ss", : "A", : "A", : "A", : "a", : "a", : "a", : "C", : "C", : "C", : "C", : "c", : "c", : "c", : "c", : "D", : "D", : "d", : "d", : "E", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "e", : "G", : "G", : "G", : "G", : "g", : "g", : "g", : "g", : "H", : "H", : "h", : "h", : "I", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "i", : "J", : "j", : "K", : "k", : "k", : "L", : "L", : "L", : "L", : "L", : "l", : "l", : "l", : "l", : "l", : "N", : "N", : "N", : "N", : "n", : "n", : "n", : "n", : "O", : "O", : "O", : "o", : "o", : "o", : "R", : "R", : "R", : "r", : "r", : "r", : "S", : "S", : "S", : "S", : "s", : "s", : "s", : "s", : "T", : "T", : "T", : "t", : "t", : "t", : "U", : "U", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "u", : "u", : "W", : "w", : "Y", : "y", : "Y", : "Z", : "Z", : "Z", : "z", : "z", : "z", : "IJ", : "ij", : "Oe", : "oe", : "'n", : "ss" }, function(e3) {
    return null == ss ? void 0 : ss[e3];
  });
  function Ys(e3) {
    return Gs.test(e3);
  }
  var Qs = Object.prototype.toString, Zs = Xs.Symbol, ei = Zs ? Zs.prototype : void 0, ti = ei ? ei.toString : void 0;
  function ri(e3) {
    return null == e3 ? "" : function(e4) {
      if ("string" == typeof e4) return e4;
      if (function(e5) {
        return "symbol" == typeof e5 || /* @__PURE__ */ function(e6) {
          return !!e6 && "object" == typeof e6;
        }(e5) && Qs.call(e5) == ls;
      }(e4)) return ti ? ti.call(e4) : "";
      var t3 = e4 + "";
      return "0" == t3 && 1 / e4 == -as ? "-0" : t3;
    }(e3);
  }
  var ni, si = (ni = function(e3, t3, r3) {
    return t3 = t3.toLowerCase(), e3 + (r3 ? ii(ri(t3).toLowerCase()) : t3);
  }, function(e3) {
    return function(e4, t3, r3, n3) {
      for (var s3 = -1, i3 = e4 ? e4.length : 0; ++s3 < i3; ) r3 = t3(r3, e4[s3], s3, e4);
      return r3;
    }(function(e4, t3, r3) {
      return e4 = ri(e4), void 0 === t3 ? function(e5) {
        return Hs.test(e5);
      }(e4) ? function(e5) {
        return e5.match(Ws) || [];
      }(e4) : function(e5) {
        return e5.match(cs) || [];
      }(e4) : e4.match(t3) || [];
    }(function(e4) {
      return (e4 = ri(e4)) && e4.replace(us, Js).replace(Vs, "");
    }(e3).replace($s, "")), ni, "");
  }), ii = ("toUpperCase", function(e3) {
    var t3, r3, n3, s3, i3 = Ys(e3 = ri(e3)) ? function(e4) {
      return Ys(e4) ? function(e5) {
        return e5.match(qs) || [];
      }(e4) : function(e5) {
        return e5.split("");
      }(e4);
    }(e3) : void 0, o3 = i3 ? i3[0] : e3.charAt(0), a3 = i3 ? (t3 = i3, r3 = 1, s3 = t3.length, n3 = void 0 === n3 ? s3 : n3, !r3 && n3 >= s3 ? t3 : function(e4, t4, r4) {
      var n4 = -1, s4 = e4.length;
      t4 < 0 && (t4 = -t4 > s4 ? 0 : s4 + t4), (r4 = r4 > s4 ? s4 : r4) < 0 && (r4 += s4), s4 = t4 > r4 ? 0 : r4 - t4 >>> 0, t4 >>>= 0;
      for (var i4 = Array(s4); ++n4 < s4; ) i4[n4] = e4[n4 + t4];
      return i4;
    }(t3, r3, n3)).join("") : e3.slice(1);
    return o3.toUpperCase() + a3;
  }), oi = si;
  Object.defineProperty(os, "__esModule", { value: true }), os.makeLocalsConventionReducer = function(e3, t3) {
    const r3 = "function" == typeof e3;
    return (n3, s3) => {
      let [i3, o3] = s3;
      if (r3) return n3[e3(i3, o3, t3)] = o3, n3;
      switch (e3) {
        case "camelCase":
          n3[i3] = o3, n3[(0, li.default)(i3)] = o3;
          break;
        case "camelCaseOnly":
          n3[(0, li.default)(i3)] = o3;
          break;
        case "dashes":
          n3[i3] = o3, n3[ci(i3)] = o3;
          break;
        case "dashesOnly":
          n3[ci(i3)] = o3;
      }
      return n3;
    };
  };
  var ai, li = (ai = oi) && ai.__esModule ? ai : { default: ai };
  function ci(e3) {
    return e3.replace(/-+(\w)/g, (e4, t3) => t3.toUpperCase());
  }
  var ui = {};
  Object.defineProperty(ui, "__esModule", { value: true }), ui.default = void 0;
  var pi = mi(h), di = mi(l), fi = mi(Gn), hi = Un;
  function mi(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  }
  class yi {
    constructor(e3) {
      this.plugins = e3 || yi.defaultPlugins;
    }
    async load(e3, t3, r3, n3) {
      const s3 = new fi.default(n3, r3), i3 = this.plugins.concat([s3.plugin()]);
      return { injectableSource: (await (0, pi.default)(i3).process(e3, { from: t3 })).css, exportTokens: s3.exportTokens };
    }
  }
  const gi = (e3, t3) => e3.length < t3.length ? e3 < t3.substring(0, e3.length) ? -1 : 1 : e3.length > t3.length ? e3.substring(0, t3.length) <= t3 ? -1 : 1 : e3 < t3 ? -1 : 1;
  ui.default = class {
    constructor(e3, t3, r3) {
      if ("/" === e3 && "win32" === n2.platform) {
        const t4 = n2.cwd().slice(0, 3);
        if (!/^[A-Za-z]:\\$/.test(t4)) throw new Error(`Failed to obtain root from "${n2.cwd()}".`);
        e3 = t4;
      }
      this.root = e3, this.fileResolve = r3, this.sources = {}, this.traces = {}, this.importNr = 0, this.core = new yi(t3), this.tokensByFile = {}, this.fs = (0, hi.getFileSystem)();
    }
    async fetch(e3, t3, n3) {
      const s3 = e3.replace(/^["']|["']$/g, ""), i3 = n3 || String.fromCharCode(this.importNr++), o3 = "function" == typeof this.fileResolve, a3 = o3 ? await this.fileResolve(s3, t3) : await Promise.resolve();
      if (a3 && !di.default.isAbsolute(a3)) throw new Error('The returned path from the "fileResolve" option must be absolute.');
      const l2 = di.default.dirname(t3), c2 = a3 || di.default.resolve(l2, s3);
      let u2 = a3 || di.default.resolve(di.default.resolve(this.root, l2), s3);
      if (!o3 && "." !== s3[0] && !di.default.isAbsolute(s3)) try {
        u2 = r2(329).resolve(s3);
      } catch (e4) {
      }
      return this.tokensByFile[u2] || new Promise((e4, t4) => {
        this.fs.readFile(u2, "utf-8", async (r3, n4) => {
          r3 && t4(r3);
          const { injectableSource: s4, exportTokens: o4 } = await this.core.load(n4, c2, i3, this.fetch.bind(this));
          this.sources[u2] = s4, this.traces[i3] = u2, this.tokensByFile[u2] = o4, e4(o4);
        });
      });
    }
    get finalSource() {
      const e3 = this.traces, t3 = this.sources;
      let r3 = /* @__PURE__ */ new Set();
      return Object.keys(e3).sort(gi).map((n3) => {
        const s3 = e3[n3];
        return r3.has(s3) ? null : (r3.add(s3), t3[s3]);
      }).join("");
    }
  };
  var bi = {}, vi = { exports: {} };
  function Ei(e3, t3, r3, n3, s3) {
    if (2 === r3[e3]) return;
    if (1 === r3[e3]) return s3 ? function(e4, t4) {
      const r4 = new Error("Nondeterministic import's order"), n4 = t4[e4].find((r5) => t4[r5].indexOf(e4) > -1);
      return r4.nodes = [e4, n4], r4;
    }(e3, t3) : void 0;
    r3[e3] = 1;
    const i3 = t3[e3], o3 = i3.length;
    for (let e4 = 0; e4 < o3; ++e4) {
      const o4 = Ei(i3[e4], t3, r3, n3, s3);
      if (o4 instanceof Error) return o4;
    }
    r3[e3] = 2, n3.push(e3);
  }
  const Si = /^(.+?)\s+from\s+(?:"([^"]+)"|'([^']+)'|(global))$/, xi = /^:import\((?:"([^"]+)"|'([^']+)')\)/;
  function Ti(e3, t3, r3, n3) {
    const s3 = t3 + "_siblings", i3 = t3 + "_" + e3;
    if (1 !== n3[i3]) {
      Array.isArray(n3[s3]) || (n3[s3] = []);
      const t4 = n3[s3];
      Array.isArray(r3[e3]) ? r3[e3] = r3[e3].concat(t4) : r3[e3] = t4.slice(), n3[i3] = 1, t4.push(e3);
    }
  }
  vi.exports = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = 0;
    const r3 = "function" != typeof e3.createImportedName ? (e4) => `i__imported_${e4.replace(/\W/g, "_")}_${t3++}` : e3.createImportedName, n3 = e3.failOnWrongOrder;
    return { postcssPlugin: "postcss-modules-extract-imports", prepare() {
      const e4 = {}, t4 = {}, s3 = {}, i3 = {}, o3 = {};
      return { Once(a3, l2) {
        a3.walkRules((r4) => {
          const n4 = xi.exec(r4.selector);
          if (n4) {
            const [, i4, o4] = n4, a4 = i4 || o4;
            Ti(a4, "root", e4, t4), s3[a4] = r4;
          }
        }), a3.walkDecls(/^composes$/, (n4) => {
          const s4 = n4.value.match(Si);
          if (!s4) return;
          let a4, [, l3, c3, u3, p2] = s4;
          if (p2) a4 = l3.split(/\s+/).map((e5) => `global(${e5})`);
          else {
            const s5 = c3 || u3;
            let p3 = n4.parent, d2 = "";
            for (; "root" !== p3.type; ) d2 = p3.parent.index(p3) + "_" + d2, p3 = p3.parent;
            const { selector: f2 } = n4.parent;
            Ti(s5, `_${d2}${f2}`, e4, t4), i3[s5] = n4, o3[s5] = o3[s5] || {}, a4 = l3.split(/\s+/).map((e5) => (o3[s5][e5] || (o3[s5][e5] = r3(e5, s5)), o3[s5][e5]));
          }
          n4.value = a4.join(" ");
        });
        const c2 = function(e5, t5) {
          const r4 = [], n4 = {}, s4 = Object.keys(e5), i4 = s4.length;
          for (let o4 = 0; o4 < i4; ++o4) {
            const i5 = Ei(s4[o4], e5, n4, r4, t5);
            if (i5 instanceof Error) return i5;
          }
          return r4;
        }(e4, n3);
        if (c2 instanceof Error) {
          const e5 = c2.nodes.find((e6) => i3.hasOwnProperty(e6));
          throw i3[e5].error("Failed to resolve order of composed modules " + c2.nodes.map((e6) => "`" + e6 + "`").join(", ") + ".", { plugin: "postcss-modules-extract-imports", word: "composes" });
        }
        let u2;
        c2.forEach((e5) => {
          const t5 = o3[e5];
          let r4 = s3[e5];
          !r4 && t5 && (r4 = l2.rule({ selector: `:import("${e5}")`, raws: { after: "\n" } }), u2 ? a3.insertAfter(u2, r4) : a3.prepend(r4)), u2 = r4, t5 && Object.keys(t5).forEach((e6) => {
            r4.append(l2.decl({ value: e6, prop: t5[e6], raws: { before: "\n  " } }));
          });
        });
      } };
    } };
  }, vi.exports.postcss = true;
  var wi, Pi, Ai = vi.exports;
  function Ci() {
    if (Pi) return wi;
    Pi = 1;
    const e3 = {};
    return wi = class {
      constructor(e4, t3) {
        this.hashKey = t3, "function" == typeof e4 ? (this.hashFactory = e4, this.hash = void 0) : (this.hashFactory = void 0, this.hash = e4), this.buffer = "";
      }
      update(e4, t3) {
        return void 0 !== t3 || "string" != typeof e4 || e4.length > 2e3 ? (void 0 === this.hash && (this.hash = this.hashFactory()), this.buffer.length > 0 && (this.hash.update(this.buffer), this.buffer = ""), this.hash.update(e4, t3)) : (this.buffer += e4, this.buffer.length > 2e3 && (void 0 === this.hash && (this.hash = this.hashFactory()), this.hash.update(this.buffer), this.buffer = "")), this;
      }
      digest(t3) {
        let r3;
        const n3 = this.buffer;
        if (void 0 === this.hash) {
          const s4 = `${this.hashKey}-${t3}`;
          r3 = e3[s4], void 0 === r3 && (r3 = e3[s4] = /* @__PURE__ */ new Map());
          const i3 = r3.get(n3);
          if (void 0 !== i3) return i3;
          this.hash = this.hashFactory();
        }
        n3.length > 0 && this.hash.update(n3);
        const s3 = this.hash.digest(t3);
        return void 0 !== r3 && r3.set(n3, s3), s3;
      }
    };
  }
  var Oi, Ii, _i, ki, Ni, Di, ji, Li = { exports: {} };
  function Mi() {
    if (Oi) return Li.exports;
    Oi = 1;
    const e3 = -4 & Math.floor(16368);
    class t3 {
      constructor(e4, t4, r3, n3) {
        const i3 = e4.exports;
        i3.init(), this.exports = i3, this.mem = s2.from(i3.memory.buffer, 0, 65536), this.buffered = 0, this.instancesPool = t4, this.chunkSize = r3, this.digestSize = n3;
      }
      reset() {
        this.buffered = 0, this.exports.init();
      }
      update(t4, r3) {
        if ("string" == typeof t4) {
          for (; t4.length > e3; ) this._updateWithShortString(t4.slice(0, e3), r3), t4 = t4.slice(e3);
          return this._updateWithShortString(t4, r3), this;
        }
        return this._updateWithBuffer(t4), this;
      }
      _updateWithShortString(e4, t4) {
        const { exports: r3, buffered: n3, mem: s3, chunkSize: i3 } = this;
        let o3;
        if (e4.length < 70) if (t4 && "utf-8" !== t4 && "utf8" !== t4) if ("latin1" === t4) {
          o3 = n3;
          for (let t5 = 0; t5 < e4.length; t5++) {
            const r4 = e4.charCodeAt(t5);
            s3[o3++] = r4;
          }
        } else o3 = n3 + s3.write(e4, n3, t4);
        else {
          o3 = n3;
          for (let r4 = 0; r4 < e4.length; r4++) {
            const n4 = e4.charCodeAt(r4);
            if (n4 < 128) s3[o3++] = n4;
            else {
              if (!(n4 < 2048)) {
                o3 += s3.write(e4.slice(r4), o3, t4);
                break;
              }
              s3[o3] = n4 >> 6 | 192, s3[o3 + 1] = 63 & n4 | 128, o3 += 2;
            }
          }
        }
        else o3 = n3 + s3.write(e4, n3, t4);
        if (o3 < i3) this.buffered = o3;
        else {
          const e5 = o3 & ~(this.chunkSize - 1);
          r3.update(e5);
          const t5 = o3 - e5;
          this.buffered = t5, t5 > 0 && s3.copyWithin(0, e5, o3);
        }
      }
      _updateWithBuffer(e4) {
        const { exports: t4, buffered: r3, mem: n3 } = this, s3 = e4.length;
        if (r3 + s3 < this.chunkSize) e4.copy(n3, r3, 0, s3), this.buffered += s3;
        else {
          const i3 = r3 + s3 & ~(this.chunkSize - 1);
          if (i3 > 65536) {
            let s4 = 65536 - r3;
            e4.copy(n3, r3, 0, s4), t4.update(65536);
            const o4 = i3 - r3 - 65536;
            for (; s4 < o4; ) e4.copy(n3, 0, s4, s4 + 65536), t4.update(65536), s4 += 65536;
            e4.copy(n3, 0, s4, i3 - r3), t4.update(i3 - r3 - s4);
          } else e4.copy(n3, r3, 0, i3 - r3), t4.update(i3);
          const o3 = s3 + r3 - i3;
          this.buffered = o3, o3 > 0 && e4.copy(n3, 0, s3 - o3, s3);
        }
      }
      digest(e4) {
        const { exports: t4, buffered: r3, mem: n3, digestSize: i3 } = this;
        t4.final(r3), this.instancesPool.push(this);
        const o3 = n3.toString("latin1", 0, i3);
        return "hex" === e4 ? o3 : "binary" !== e4 && e4 ? s2.from(o3, "hex").toString(e4) : s2.from(o3, "hex");
      }
    }
    return Li.exports = (e4, r3, n3, s3) => {
      if (r3.length > 0) {
        const e5 = r3.pop();
        return e5.reset(), e5;
      }
      return new t3(new WebAssembly.Instance(e4), r3, n3, s3);
    }, Li.exports.MAX_SHORT_STRING = e3, Li.exports;
  }
  function Bi() {
    if (Ni) return ki;
    Ni = 1;
    const e3 = Mi().MAX_SHORT_STRING;
    return ki = class {
      constructor(e4) {
        this.string = void 0, this.encoding = void 0, this.hash = e4;
      }
      update(t3, r3) {
        if (void 0 !== this.string) {
          if ("string" == typeof t3 && r3 === this.encoding && this.string.length + t3.length < e3) return this.string += t3, this;
          this.hash.update(this.string, this.encoding), this.string = void 0;
        }
        return "string" == typeof t3 ? !(t3.length < e3) || r3 && r3.startsWith("ba") ? this.hash.update(t3, r3) : (this.string = t3, this.encoding = r3) : this.hash.update(t3), this;
      }
      digest(e4) {
        return void 0 !== this.string && this.hash.update(this.string, this.encoding), this.hash.digest(e4);
      }
    };
  }
  const Ri = { 26: "abcdefghijklmnopqrstuvwxyz", 32: "123456789abcdefghjkmnpqrstuvwxyz", 36: "0123456789abcdefghijklmnopqrstuvwxyz", 49: "abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ", 52: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", 58: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ", 62: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", 64: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_" };
  function Fi(e3, t3) {
    let r3 = 0;
    for (let n3 = e3.length - 1; n3 >= 0; n3--) {
      const s3 = 4294967296 * r3 + e3[n3];
      r3 = s3 % t3, e3[n3] = Math.floor(s3 / t3);
    }
    return r3;
  }
  let Ui, $i, Vi, qi, Wi;
  const Gi = l, Hi = function(e3, t3, n3, i3) {
    let o3;
    return i3 = i3 || 9999, "xxhash64" === (t3 = t3 || "xxhash64") ? (void 0 === $i && ($i = function() {
      if (ji) return Di;
      ji = 1;
      const e4 = Mi(), t4 = new WebAssembly.Module(s2.from("AGFzbQEAAAABCAJgAX8AYAAAAwQDAQAABQMBAAEGGgV+AUIAC34BQgALfgFCAAt+AUIAC34BQgALByIEBGluaXQAAAZ1cGRhdGUAAQVmaW5hbAACBm1lbW9yeQIACrUIAzAAQtbrgu7q/Yn14AAkAELP1tO+0ser2UIkAUIAJAJC+erQ0OfJoeThACQDQgAkBAvUAQIBfwR+IABFBEAPCyMEIACtfCQEIwAhAiMBIQMjAiEEIwMhBQNAIAIgASkDAELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiECIAMgASkDCELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEDIAQgASkDEELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEEIAUgASkDGELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEFIAAgAUEgaiIBSw0ACyACJAAgAyQBIAQkAiAFJAMLqwYCAX8EfiMEQgBSBH4jACICQgGJIwEiA0IHiXwjAiIEQgyJfCMDIgVCEol8IAJCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0gA0LP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkKdo7Xqg7GNivoAfSAEQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IAVCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0FQsXP2bLx5brqJwsjBCAArXx8IQIDQCABQQhqIABNBEAgAiABKQMAQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQhuJQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IQIgAUEIaiEBDAELCyABQQRqIABNBEACfyACIAE1AgBCh5Wvr5i23puef36FQheJQs/W077Sx6vZQn5C+fPd8Zn2masWfCECIAFBBGoLIQELA0AgACABRwRAIAIgATEAAELFz9my8eW66id+hUILiUKHla+vmLbem55/fiECIAFBAWohAQwBCwtBACACIAJCIYiFQs/W077Sx6vZQn4iAiACQh2IhUL5893xmfaZqxZ+IgIgAkIgiIUiAkIgiCIDQv//A4NCIIYgA0KAgPz/D4NCEIiEIgNC/4GAgPAfg0IQhiADQoD+g4CA4D+DQgiIhCIDQo+AvIDwgcAHg0IIhiADQvCBwIeAnoD4AINCBIiEIgNChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IANCsODAgYOGjJgwhHw3AwBBCCACQv////8PgyICQv//A4NCIIYgAkKAgPz/D4NCEIiEIgJC/4GAgPAfg0IQhiACQoD+g4CA4D+DQgiIhCICQo+AvIDwgcAHg0IIhiACQvCBwIeAnoD4AINCBIiEIgJChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IAJCsODAgYOGjJgwhHw3AwAL", "base64"));
      return Di = e4.bind(null, t4, [], 32, 16);
    }(), void 0 === qi && (qi = Bi())), o3 = new qi($i())) : "md4" === t3 ? (void 0 === Vi && (Vi = function() {
      if (_i) return Ii;
      _i = 1;
      const e4 = Mi(), t4 = new WebAssembly.Module(s2.from("AGFzbQEAAAABCAJgAX8AYAAAAwUEAQAAAAUDAQABBhoFfwFBAAt/AUEAC38BQQALfwFBAAt/AUEACwciBARpbml0AAAGdXBkYXRlAAIFZmluYWwAAwZtZW1vcnkCAAqFEAQmAEGBxpS6BiQBQYnXtv5+JAJB/rnrxXkkA0H2qMmBASQEQQAkAAvMCgEYfyMBIQojAiEGIwMhByMEIQgDQCAAIAVLBEAgBSgCCCINIAcgBiAFKAIEIgsgCCAHIAUoAgAiDCAKIAggBiAHIAhzcXNqakEDdyIDIAYgB3Nxc2pqQQd3IgEgAyAGc3FzampBC3chAiAFKAIUIg8gASACIAUoAhAiCSADIAEgBSgCDCIOIAYgAyACIAEgA3Nxc2pqQRN3IgQgASACc3FzampBA3ciAyACIARzcXNqakEHdyEBIAUoAiAiEiADIAEgBSgCHCIRIAQgAyAFKAIYIhAgAiAEIAEgAyAEc3FzampBC3ciAiABIANzcXNqakETdyIEIAEgAnNxc2pqQQN3IQMgBSgCLCIVIAQgAyAFKAIoIhQgAiAEIAUoAiQiEyABIAIgAyACIARzcXNqakEHdyIBIAMgBHNxc2pqQQt3IgIgASADc3FzampBE3chBCAPIBAgCSAVIBQgEyAFKAI4IhYgAiAEIAUoAjQiFyABIAIgBSgCMCIYIAMgASAEIAEgAnNxc2pqQQN3IgEgAiAEc3FzampBB3ciAiABIARzcXNqakELdyIDIAkgAiAMIAEgBSgCPCIJIAQgASADIAEgAnNxc2pqQRN3IgEgAiADcnEgAiADcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyaiASakGZ84nUBWpBCXciAyAPIAQgCyACIBggASADIAIgBHJxIAIgBHFyampBmfOJ1AVqQQ13IgEgAyAEcnEgAyAEcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyampBmfOJ1AVqQQl3IgMgECAEIAIgFyABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmogDWpBmfOJ1AVqQQN3IgIgASADcnEgASADcXJqakGZ84nUBWpBBXciBCABIAJycSABIAJxcmpqQZnzidQFakEJdyIDIBEgBCAOIAIgFiABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmpqQZnzidQFakEDdyICIAEgA3JxIAEgA3FyampBmfOJ1AVqQQV3IgQgASACcnEgASACcXJqakGZ84nUBWpBCXciAyAMIAIgAyAJIAEgAyACIARycSACIARxcmpqQZnzidQFakENdyIBcyAEc2pqQaHX5/YGakEDdyICIAQgASACcyADc2ogEmpBodfn9gZqQQl3IgRzIAFzampBodfn9gZqQQt3IgMgAiADIBggASADIARzIAJzampBodfn9gZqQQ93IgFzIARzaiANakGh1+f2BmpBA3ciAiAUIAQgASACcyADc2pqQaHX5/YGakEJdyIEcyABc2pqQaHX5/YGakELdyIDIAsgAiADIBYgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgIgEyAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3chAyAKIA4gAiADIBcgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgJqIQogBiAJIAEgESADIAIgFSAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3ciAyAEcyACc2pqQaHX5/YGakEPd2ohBiADIAdqIQcgBCAIaiEIIAVBQGshBQwBCwsgCiQBIAYkAiAHJAMgCCQECw0AIAAQASMAIABqJAAL/wQCA38BfiMAIABqrUIDhiEEIABByABqQUBxIgJBCGshAyAAIgFBAWohACABQYABOgAAA0AgACACSUEAIABBB3EbBEAgAEEAOgAAIABBAWohAAwBCwsDQCAAIAJJBEAgAEIANwMAIABBCGohAAwBCwsgAyAENwMAIAIQAUEAIwGtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEIIwKtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEQIwOtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEYIwStIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAAs=", "base64"));
      return Ii = e4.bind(null, t4, [], 64, 32);
    }(), void 0 === qi && (qi = Bi())), o3 = new qi(Vi())) : "native-md4" === t3 ? (void 0 === Ui && (Ui = r2(343), void 0 === Wi && (Wi = Ci())), o3 = new Wi(() => Ui.createHash("md4"), "md4")) : (void 0 === Ui && (Ui = r2(343), void 0 === Wi && (Wi = Ci())), o3 = new Wi(() => Ui.createHash(t3), t3)), o3.update(e3), "base26" === n3 || "base32" === n3 || "base36" === n3 || "base49" === n3 || "base52" === n3 || "base58" === n3 || "base62" === n3 ? function(e4, t4, r3) {
      const n4 = Ri[t4];
      if (!n4) throw new Error("Unknown encoding base" + t4);
      const i4 = Math.ceil(8 * e4.length / Math.log2(t4));
      r3 = Math.min(r3, i4);
      const o4 = new Uint32Array(Math.ceil(e4.length / 4));
      e4.copy(s2.from(o4.buffer));
      let a3 = "";
      for (let e5 = 0; e5 < r3; e5++) a3 = n4[Fi(o4, t4)] + a3;
      return a3;
    }(o3.digest(), n3.substr(4), i3) : o3.digest(n3 || "hex").substr(0, i3);
  };
  var zi, Ki, Xi = function(e3, t3) {
    let r3, n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    const s3 = e3.resourceQuery && e3.resourceQuery.length > 1;
    r3 = "function" == typeof t3 ? t3(e3.resourcePath, s3 ? e3.resourceQuery : void 0) : t3 || "[hash].[ext]";
    const i3 = n3.context, o3 = n3.content, a3 = n3.regExp;
    let l2 = "bin", c2 = "file", u2 = "", p2 = "", d2 = "";
    if (e3.resourcePath) {
      const t4 = Gi.parse(e3.resourcePath);
      let r4 = e3.resourcePath;
      t4.ext && (l2 = t4.ext.substr(1)), t4.dir && (c2 = t4.name, r4 = t4.dir + Gi.sep), void 0 !== i3 ? (u2 = Gi.relative(i3, r4 + "_").replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1"), u2 = u2.substr(0, u2.length - 1)) : u2 = r4.replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1"), 1 === u2.length ? u2 = "" : u2.length > 1 && (p2 = Gi.basename(u2));
    }
    if (e3.resourceQuery && e3.resourceQuery.length > 1) {
      d2 = e3.resourceQuery;
      const t4 = d2.indexOf("#");
      t4 >= 0 && (d2 = d2.substr(0, t4));
    }
    let f2 = r3;
    if (o3 && (f2 = f2.replace(/\[(?:([^[:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*))?(?::(\d+))?\]/gi, (e4, t4, r4, n4) => Hi(o3, t4, r4, parseInt(n4, 10)))), f2 = f2.replace(/\[ext\]/gi, () => l2).replace(/\[name\]/gi, () => c2).replace(/\[path\]/gi, () => u2).replace(/\[folder\]/gi, () => p2).replace(/\[query\]/gi, () => d2), a3 && e3.resourcePath) {
      const t4 = e3.resourcePath.match(new RegExp(a3));
      t4 && t4.forEach((e4, t5) => {
        f2 = f2.replace(new RegExp("\\[" + t5 + "\\]", "ig"), e4);
      });
    }
    return "object" == typeof e3.options && "function" == typeof e3.options.customInterpolateName && (f2 = e3.options.customInterpolateName.call(e3, f2, t3, n3)), f2;
  }, Ji = l, Yi = { exports: {} }, Qi = "(".charCodeAt(0), Zi = ")".charCodeAt(0), eo = "'".charCodeAt(0), to = '"'.charCodeAt(0), ro = "\\".charCodeAt(0), no = "/".charCodeAt(0), so = ",".charCodeAt(0), io = ":".charCodeAt(0), oo = "*".charCodeAt(0), ao = "u".charCodeAt(0), lo = "U".charCodeAt(0), co = "+".charCodeAt(0), uo = /^[a-f0-9?-]+$/i;
  function po(e3, t3) {
    var r3, n3, s3 = e3.type, i3 = e3.value;
    return t3 && void 0 !== (n3 = t3(e3)) ? n3 : "word" === s3 || "space" === s3 ? i3 : "string" === s3 ? (r3 = e3.quote || "") + i3 + (e3.unclosed ? "" : r3) : "comment" === s3 ? "/*" + i3 + (e3.unclosed ? "" : "*/") : "div" === s3 ? (e3.before || "") + i3 + (e3.after || "") : Array.isArray(e3.nodes) ? (r3 = fo(e3.nodes, t3), "function" !== s3 ? r3 : i3 + "(" + (e3.before || "") + r3 + (e3.after || "") + (e3.unclosed ? "" : ")")) : i3;
  }
  function fo(e3, t3) {
    var r3, n3;
    if (Array.isArray(e3)) {
      for (r3 = "", n3 = e3.length - 1; ~n3; n3 -= 1) r3 = po(e3[n3], t3) + r3;
      return r3;
    }
    return po(e3, t3);
  }
  var ho = function e3(t3, r3, n3) {
    var s3, i3, o3, a3;
    for (s3 = 0, i3 = t3.length; s3 < i3; s3 += 1) o3 = t3[s3], n3 || (a3 = r3(o3, s3, t3)), false !== a3 && "function" === o3.type && Array.isArray(o3.nodes) && e3(o3.nodes, r3, n3), n3 && r3(o3, s3, t3);
  }, mo = fo;
  function yo(e3) {
    return this instanceof yo ? (this.nodes = function(e4) {
      for (var t3, r3, n3, s3, i3, o3, a3, l2, c2, u2 = [], p2 = e4, d2 = 0, f2 = p2.charCodeAt(d2), h2 = p2.length, m2 = [{ nodes: u2 }], y2 = 0, g2 = "", b2 = "", v2 = ""; d2 < h2; ) if (f2 <= 32) {
        t3 = d2;
        do {
          t3 += 1, f2 = p2.charCodeAt(t3);
        } while (f2 <= 32);
        s3 = p2.slice(d2, t3), n3 = u2[u2.length - 1], f2 === Zi && y2 ? v2 = s3 : n3 && "div" === n3.type ? (n3.after = s3, n3.sourceEndIndex += s3.length) : f2 === so || f2 === io || f2 === no && p2.charCodeAt(t3 + 1) !== oo && (!c2 || c2 && "function" === c2.type && "calc" !== c2.value) ? b2 = s3 : u2.push({ type: "space", sourceIndex: d2, sourceEndIndex: t3, value: s3 }), d2 = t3;
      } else if (f2 === eo || f2 === to) {
        t3 = d2, s3 = { type: "string", sourceIndex: d2, quote: r3 = f2 === eo ? "'" : '"' };
        do {
          if (i3 = false, ~(t3 = p2.indexOf(r3, t3 + 1))) for (o3 = t3; p2.charCodeAt(o3 - 1) === ro; ) o3 -= 1, i3 = !i3;
          else t3 = (p2 += r3).length - 1, s3.unclosed = true;
        } while (i3);
        s3.value = p2.slice(d2 + 1, t3), s3.sourceEndIndex = s3.unclosed ? t3 : t3 + 1, u2.push(s3), d2 = t3 + 1, f2 = p2.charCodeAt(d2);
      } else if (f2 === no && p2.charCodeAt(d2 + 1) === oo) s3 = { type: "comment", sourceIndex: d2, sourceEndIndex: (t3 = p2.indexOf("*/", d2)) + 2 }, -1 === t3 && (s3.unclosed = true, t3 = p2.length, s3.sourceEndIndex = t3), s3.value = p2.slice(d2 + 2, t3), u2.push(s3), d2 = t3 + 2, f2 = p2.charCodeAt(d2);
      else if (f2 !== no && f2 !== oo || !c2 || "function" !== c2.type || "calc" !== c2.value) if (f2 === no || f2 === so || f2 === io) s3 = p2[d2], u2.push({ type: "div", sourceIndex: d2 - b2.length, sourceEndIndex: d2 + s3.length, value: s3, before: b2, after: "" }), b2 = "", d2 += 1, f2 = p2.charCodeAt(d2);
      else if (Qi === f2) {
        t3 = d2;
        do {
          t3 += 1, f2 = p2.charCodeAt(t3);
        } while (f2 <= 32);
        if (l2 = d2, s3 = { type: "function", sourceIndex: d2 - g2.length, value: g2, before: p2.slice(l2 + 1, t3) }, d2 = t3, "url" === g2 && f2 !== eo && f2 !== to) {
          t3 -= 1;
          do {
            if (i3 = false, ~(t3 = p2.indexOf(")", t3 + 1))) for (o3 = t3; p2.charCodeAt(o3 - 1) === ro; ) o3 -= 1, i3 = !i3;
            else t3 = (p2 += ")").length - 1, s3.unclosed = true;
          } while (i3);
          a3 = t3;
          do {
            a3 -= 1, f2 = p2.charCodeAt(a3);
          } while (f2 <= 32);
          l2 < a3 ? (s3.nodes = d2 !== a3 + 1 ? [{ type: "word", sourceIndex: d2, sourceEndIndex: a3 + 1, value: p2.slice(d2, a3 + 1) }] : [], s3.unclosed && a3 + 1 !== t3 ? (s3.after = "", s3.nodes.push({ type: "space", sourceIndex: a3 + 1, sourceEndIndex: t3, value: p2.slice(a3 + 1, t3) })) : (s3.after = p2.slice(a3 + 1, t3), s3.sourceEndIndex = t3)) : (s3.after = "", s3.nodes = []), d2 = t3 + 1, s3.sourceEndIndex = s3.unclosed ? t3 : d2, f2 = p2.charCodeAt(d2), u2.push(s3);
        } else y2 += 1, s3.after = "", s3.sourceEndIndex = d2 + 1, u2.push(s3), m2.push(s3), u2 = s3.nodes = [], c2 = s3;
        g2 = "";
      } else if (Zi === f2 && y2) d2 += 1, f2 = p2.charCodeAt(d2), c2.after = v2, c2.sourceEndIndex += v2.length, v2 = "", y2 -= 1, m2[m2.length - 1].sourceEndIndex = d2, m2.pop(), u2 = (c2 = m2[y2]).nodes;
      else {
        t3 = d2;
        do {
          f2 === ro && (t3 += 1), t3 += 1, f2 = p2.charCodeAt(t3);
        } while (t3 < h2 && !(f2 <= 32 || f2 === eo || f2 === to || f2 === so || f2 === io || f2 === no || f2 === Qi || f2 === oo && c2 && "function" === c2.type && "calc" === c2.value || f2 === no && "function" === c2.type && "calc" === c2.value || f2 === Zi && y2));
        s3 = p2.slice(d2, t3), Qi === f2 ? g2 = s3 : ao !== s3.charCodeAt(0) && lo !== s3.charCodeAt(0) || co !== s3.charCodeAt(1) || !uo.test(s3.slice(2)) ? u2.push({ type: "word", sourceIndex: d2, sourceEndIndex: t3, value: s3 }) : u2.push({ type: "unicode-range", sourceIndex: d2, sourceEndIndex: t3, value: s3 }), d2 = t3;
      }
      else s3 = p2[d2], u2.push({ type: "word", sourceIndex: d2 - b2.length, sourceEndIndex: d2 + s3.length, value: s3 }), d2 += 1, f2 = p2.charCodeAt(d2);
      for (d2 = m2.length - 1; d2; d2 -= 1) m2[d2].unclosed = true, m2[d2].sourceEndIndex = p2.length;
      return m2[0].nodes;
    }(e3), this) : new yo(e3);
  }
  yo.prototype.toString = function() {
    return Array.isArray(this.nodes) ? mo(this.nodes) : "";
  }, yo.prototype.walk = function(e3, t3) {
    return ho(this.nodes, e3, t3), this;
  }, yo.unit = function() {
    if (Ki) return zi;
    Ki = 1;
    var e3 = "-".charCodeAt(0), t3 = "+".charCodeAt(0), r3 = ".".charCodeAt(0), n3 = "e".charCodeAt(0), s3 = "E".charCodeAt(0);
    return zi = function(i3) {
      var o3, a3, l2, c2 = 0, u2 = i3.length;
      if (0 === u2 || !function(n4) {
        var s4, i4 = n4.charCodeAt(0);
        if (i4 === t3 || i4 === e3) {
          if ((s4 = n4.charCodeAt(1)) >= 48 && s4 <= 57) return true;
          var o4 = n4.charCodeAt(2);
          return s4 === r3 && o4 >= 48 && o4 <= 57;
        }
        return i4 === r3 ? (s4 = n4.charCodeAt(1)) >= 48 && s4 <= 57 : i4 >= 48 && i4 <= 57;
      }(i3)) return false;
      for ((o3 = i3.charCodeAt(c2)) !== t3 && o3 !== e3 || c2++; c2 < u2 && !((o3 = i3.charCodeAt(c2)) < 48 || o3 > 57); ) c2 += 1;
      if (o3 = i3.charCodeAt(c2), a3 = i3.charCodeAt(c2 + 1), o3 === r3 && a3 >= 48 && a3 <= 57) for (c2 += 2; c2 < u2 && !((o3 = i3.charCodeAt(c2)) < 48 || o3 > 57); ) c2 += 1;
      if (o3 = i3.charCodeAt(c2), a3 = i3.charCodeAt(c2 + 1), l2 = i3.charCodeAt(c2 + 2), (o3 === n3 || o3 === s3) && (a3 >= 48 && a3 <= 57 || (a3 === t3 || a3 === e3) && l2 >= 48 && l2 <= 57)) for (c2 += a3 === t3 || a3 === e3 ? 3 : 2; c2 < u2 && !((o3 = i3.charCodeAt(c2)) < 48 || o3 > 57); ) c2 += 1;
      return { number: i3.slice(0, c2), unit: i3.slice(c2) };
    };
  }(), yo.walk = ho, yo.stringify = mo;
  const go = Lr, bo = yo, { extractICSS: vo } = es, Eo = (e3) => "combinator" === e3.type && " " === e3.value;
  function So(e3) {
    const t3 = [];
    return e3.forEach((e4) => {
      Array.isArray(e4) ? So(e4).forEach((e5) => {
        t3.push(e5);
      }) : e4 && t3.push(e4);
    }), t3.length > 0 && Eo(t3[t3.length - 1]) && t3.pop(), t3;
  }
  function xo(e3, t3) {
    switch (e3.type) {
      case "word":
        t3.localizeNextItem && (t3.localAliasMap.has(e3.value) || (e3.value = ":local(" + e3.value + ")", t3.localizeNextItem = false));
        break;
      case "function":
        t3.options && t3.options.rewriteUrl && "url" === e3.value.toLowerCase() && e3.nodes.map((e4) => {
          if ("string" !== e4.type && "word" !== e4.type) return;
          let r3 = t3.options.rewriteUrl(t3.global, e4.value);
          switch (e4.type) {
            case "string":
              "'" === e4.quote && (r3 = r3.replace(/(\\)/g, "\\$1").replace(/'/g, "\\'")), '"' === e4.quote && (r3 = r3.replace(/(\\)/g, "\\$1").replace(/"/g, '\\"'));
              break;
            case "word":
              r3 = r3.replace(/("|'|\)|\\)/g, "\\$1");
          }
          e4.value = r3;
        });
    }
    return e3;
  }
  const To = ["none", "inherit", "initial", "revert", "revert-layer", "unset"];
  function wo(e3, t3, r3) {
    const n3 = bo(t3.value);
    n3.walk((t4, n4, s3) => {
      if ("function" === t4.type && ("var" === t4.value.toLowerCase() || "env" === t4.value.toLowerCase())) return false;
      if ("word" === t4.type && To.includes(t4.value.toLowerCase())) return;
      const i3 = { options: r3.options, global: r3.global, localizeNextItem: e3 && !r3.global, localAliasMap: r3.localAliasMap };
      s3[n4] = xo(t4, i3);
    }), t3.value = n3.toString();
  }
  function Po(e3, t3) {
    if (!/animation$/i.test(e3.prop)) return /animation(-name)?$/i.test(e3.prop) ? wo(true, e3, t3) : /url\(/i.test(e3.value) ? wo(false, e3, t3) : void 0;
    {
      const r3 = /^-?([a-z\u0080-\uFFFF_]|(\\[^\r\n\f])|-)((\\[^\r\n\f])|[a-z\u0080-\uFFFF_0-9-])*$/i, n3 = { $normal: 1, $reverse: 1, $alternate: 1, "$alternate-reverse": 1, $forwards: 1, $backwards: 1, $both: 1, $infinite: 1, $paused: 1, $running: 1, $ease: 1, "$ease-in": 1, "$ease-out": 1, "$ease-in-out": 1, $linear: 1, "$step-end": 1, "$step-start": 1, $none: 1 / 0, $initial: 1 / 0, $inherit: 1 / 0, $unset: 1 / 0, $revert: 1 / 0, "$revert-layer": 1 / 0 };
      let s3 = {};
      const i3 = bo(e3.value).walk((e4) => {
        if ("div" === e4.type) return void (s3 = {});
        if ("function" === e4.type) return false;
        if ("word" !== e4.type) return;
        const i4 = "word" === e4.type ? e4.value.toLowerCase() : null;
        let o3 = false;
        return i4 && r3.test(i4) && ("$" + i4 in n3 ? (s3["$" + i4] = "$" + i4 in s3 ? s3["$" + i4] + 1 : 0, o3 = s3["$" + i4] >= n3["$" + i4]) : o3 = true), xo(e4, { options: t3.options, global: t3.global, localizeNextItem: o3 && !t3.global, localAliasMap: t3.localAliasMap });
      });
      e3.value = i3.toString();
    }
  }
  Yi.exports = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (e3 && e3.mode && "global" !== e3.mode && "local" !== e3.mode && "pure" !== e3.mode) throw new Error('options.mode must be either "global", "local" or "pure" (default "local")');
    const t3 = e3 && "pure" === e3.mode, r3 = e3 && "global" === e3.mode;
    return { postcssPlugin: "postcss-modules-local-by-default", prepare() {
      const n3 = /* @__PURE__ */ new Map();
      return { Once(s3) {
        const { icssImports: i3 } = vo(s3, false);
        Object.keys(i3).forEach((e4) => {
          Object.keys(i3[e4]).forEach((t4) => {
            n3.set(t4, i3[e4][t4]);
          });
        }), s3.walkAtRules((s4) => {
          if (/keyframes$/i.test(s4.name)) {
            const i4 = /^\s*:global\s*\((.+)\)\s*$/.exec(s4.params), o3 = /^\s*:local\s*\((.+)\)\s*$/.exec(s4.params);
            let a3 = r3;
            if (i4) {
              if (t3) throw s4.error("@keyframes :global(...) is not allowed in pure mode");
              s4.params = i4[1], a3 = true;
            } else o3 ? (s4.params = o3[0], a3 = false) : r3 || s4.params && !n3.has(s4.params) && (s4.params = ":local(" + s4.params + ")");
            s4.walkDecls((t4) => {
              Po(t4, { localAliasMap: n3, options: e3, global: a3 });
            });
          } else s4.nodes && s4.nodes.forEach((t4) => {
            "decl" === t4.type && Po(t4, { localAliasMap: n3, options: e3, global: r3 });
          });
        }), s3.walkRules((r4) => {
          if (r4.parent && "atrule" === r4.parent.type && /keyframes$/i.test(r4.parent.name)) return;
          const s4 = function(e4, t4, r5) {
            const n4 = (e5, t5) => {
              if (t5.ignoreNextSpacing && !Eo(e5)) throw new Error("Missing whitespace after " + t5.ignoreNextSpacing);
              if (t5.enforceNoSpacing && Eo(e5)) throw new Error("Missing whitespace before " + t5.enforceNoSpacing);
              let s6;
              switch (e5.type) {
                case "root": {
                  let r6;
                  t5.hasPureGlobals = false, s6 = e5.nodes.map((s7) => {
                    const i4 = { global: t5.global, lastWasSpacing: true, hasLocals: false, explicit: false };
                    if (s7 = n4(s7, i4), void 0 === r6) r6 = i4.global;
                    else if (r6 !== i4.global) throw new Error('Inconsistent rule global/local result in rule "' + e5 + '" (multiple selectors must result in the same mode for the rule)');
                    return i4.hasLocals || (t5.hasPureGlobals = true), s7;
                  }), t5.global = r6, e5.nodes = So(s6);
                  break;
                }
                case "selector":
                  s6 = e5.map((e6) => n4(e6, t5)), (e5 = e5.clone()).nodes = So(s6);
                  break;
                case "combinator":
                  if (Eo(e5)) return t5.ignoreNextSpacing ? (t5.ignoreNextSpacing = false, t5.lastWasSpacing = false, t5.enforceNoSpacing = false, null) : (t5.lastWasSpacing = true, e5);
                  break;
                case "pseudo": {
                  let r6;
                  const i4 = !!e5.length, o3 = ":local" === e5.value || ":global" === e5.value;
                  if (":import" === e5.value || ":export" === e5.value) t5.hasLocals = true;
                  else {
                    if (i4) {
                      if (o3) {
                        if (0 === e5.nodes.length) throw new Error(`${e5.value}() can't be empty`);
                        if (t5.inside) throw new Error(`A ${e5.value} is not allowed inside of a ${t5.inside}(...)`);
                        if (r6 = { global: ":global" === e5.value, inside: e5.value, hasLocals: false, explicit: true }, s6 = e5.map((e6) => n4(e6, r6)).reduce((e6, t6) => e6.concat(t6.nodes), []), s6.length) {
                          const { before: t6, after: r7 } = e5.spaces, n5 = s6[0], i5 = s6[s6.length - 1];
                          n5.spaces = { before: t6, after: n5.spaces.after }, i5.spaces = { before: i5.spaces.before, after: r7 };
                        }
                        e5 = s6;
                        break;
                      }
                      r6 = { global: t5.global, inside: t5.inside, lastWasSpacing: true, hasLocals: false, explicit: t5.explicit }, s6 = e5.map((e6) => {
                        const t6 = { ...r6, enforceNoSpacing: false }, s7 = n4(e6, t6);
                        return r6.global = t6.global, r6.hasLocals = t6.hasLocals, s7;
                      }), (e5 = e5.clone()).nodes = So(s6), r6.hasLocals && (t5.hasLocals = true);
                      break;
                    }
                    if (o3) {
                      if (t5.inside) throw new Error(`A ${e5.value} is not allowed inside of a ${t5.inside}(...)`);
                      const r7 = !!e5.spaces.before;
                      return t5.ignoreNextSpacing = !!t5.lastWasSpacing && e5.value, t5.enforceNoSpacing = !t5.lastWasSpacing && e5.value, t5.global = ":global" === e5.value, t5.explicit = true, r7 ? go.combinator({ value: " " }) : null;
                    }
                  }
                  break;
                }
                case "id":
                case "class": {
                  if (!e5.value) throw new Error("Invalid class or id selector syntax");
                  if (t5.global) break;
                  const n5 = r5.has(e5.value), s7 = n5 && t5.explicit;
                  if (!n5 || s7) {
                    const r6 = e5.clone();
                    r6.spaces = { before: "", after: "" }, e5 = go.pseudo({ value: ":local", nodes: [r6], spaces: e5.spaces }), t5.hasLocals = true;
                  }
                  break;
                }
              }
              return t5.lastWasSpacing = false, t5.ignoreNextSpacing = false, t5.enforceNoSpacing = false, e5;
            }, s5 = { global: "global" === t4, hasPureGlobals: false };
            return s5.selector = go((e5) => {
              n4(e5, s5);
            }).processSync(e4, { updateSelector: false, lossless: true }), s5;
          }(r4, e3.mode, n3);
          if (s4.options = e3, s4.localAliasMap = n3, t3 && s4.hasPureGlobals) throw r4.error('Selector "' + r4.selector + '" is not pure (pure selectors must contain at least one local class or id)');
          r4.selector = s4.selector, r4.nodes && r4.nodes.forEach((e4) => Po(e4, s4));
        });
      } };
    } };
  }, Yi.exports.postcss = true;
  var Ao = Yi.exports;
  const Co = Lr, Oo = Object.prototype.hasOwnProperty, Io = "[\\x20\\t\\r\\n\\f]", _o = new RegExp("\\\\([\\da-f]{1,6}" + Io + "?|(" + Io + ")|.)", "ig");
  function ko(e3) {
    return e3.replace(_o, (e4, t3, r3) => {
      const n3 = "0x" + t3 - 65536;
      return n3 != n3 || r3 ? t3 : n3 < 0 ? String.fromCharCode(n3 + 65536) : String.fromCharCode(n3 >> 10 | 55296, 1023 & n3 | 56320);
    });
  }
  const No = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const t3 = e3 && e3.generateScopedName || No.generateScopedName, r3 = e3 && e3.generateExportEntry || No.generateExportEntry, n3 = e3 && e3.exportGlobals;
    return { postcssPlugin: "postcss-modules-scope", Once(e4, s3) {
      let { rule: i3 } = s3;
      const o3 = /* @__PURE__ */ Object.create(null);
      function a3(n4, s4) {
        const i4 = t3(s4 || n4, e4.source.input.from, e4.source.input.css), a4 = r3(s4 || n4, i4, e4.source.input.from, e4.source.input.css), { key: l3, value: c3 } = a4;
        return o3[l3] = o3[l3] || [], o3[l3].indexOf(c3) < 0 && o3[l3].push(c3), i4;
      }
      function l2(e5) {
        switch (e5.type) {
          case "selector":
            return e5.nodes = e5.map(l2), e5;
          case "class":
            return Co.className({ value: a3(e5.value, e5.raws && e5.raws.value ? e5.raws.value : null) });
          case "id":
            return Co.id({ value: a3(e5.value, e5.raws && e5.raws.value ? e5.raws.value : null) });
        }
        throw new Error(`${e5.type} ("${e5}") is not allowed in a :local block`);
      }
      function c2(e5) {
        switch (e5.type) {
          case "pseudo":
            if (":local" === e5.value) {
              if (1 !== e5.nodes.length) throw new Error('Unexpected comma (",") in :local block');
              const t4 = l2(e5.first, e5.spaces);
              t4.first.spaces = e5.spaces;
              const r4 = e5.next();
              return r4 && "combinator" === r4.type && " " === r4.value && /\\[A-F0-9]{1,6}$/.test(t4.last.value) && (t4.last.spaces.after = " "), void e5.replaceWith(t4);
            }
          case "root":
          case "selector":
            e5.each(c2);
            break;
          case "id":
          case "class":
            n3 && (o3[e5.value] = [e5.value]);
        }
        return e5;
      }
      const u2 = {};
      e4.walkRules(/^:import\(.+\)$/, (e5) => {
        e5.walkDecls((e6) => {
          u2[e6.prop] = true;
        });
      }), e4.walkRules((e5) => {
        let t4 = Co().astSync(e5);
        e5.selector = c2(t4.clone()).toString(), e5.walkDecls(/composes|compose-with/i, (e6) => {
          const r4 = function(e7) {
            return e7.nodes.map((t5) => {
              if ("selector" !== t5.type || 1 !== t5.nodes.length) throw new Error(`composition is only allowed when selector is single :local class name not in "${e7}"`);
              if ("pseudo" !== (t5 = t5.nodes[0]).type || ":local" !== t5.value || 1 !== t5.nodes.length) throw new Error('composition is only allowed when selector is single :local class name not in "' + e7 + '", "' + t5 + '" is weird');
              if ("selector" !== (t5 = t5.first).type || 1 !== t5.length) throw new Error('composition is only allowed when selector is single :local class name not in "' + e7 + '", "' + t5 + '" is weird');
              if ("class" !== (t5 = t5.first).type) throw new Error('composition is only allowed when selector is single :local class name not in "' + e7 + '", "' + t5 + '" is weird');
              return t5.value;
            });
          }(t4);
          e6.value.split(/\s+/).forEach((t5) => {
            const n4 = /^global\(([^)]+)\)$/.exec(t5);
            if (n4) r4.forEach((e7) => {
              o3[e7].push(n4[1]);
            });
            else if (Oo.call(u2, t5)) r4.forEach((e7) => {
              o3[e7].push(t5);
            });
            else {
              if (!Oo.call(o3, t5)) throw e6.error(`referenced class name "${t5}" in ${e6.prop} not found`);
              r4.forEach((e7) => {
                o3[t5].forEach((t6) => {
                  o3[e7].push(t6);
                });
              });
            }
          }), e6.remove();
        }), e5.walkDecls((e6) => {
          if (!/:local\s*\((.+?)\)/.test(e6.value)) return;
          let t5 = e6.value.split(/(,|'[^']*'|"[^"]*")/);
          t5 = t5.map((e7, r4) => {
            if (0 === r4 || "," === t5[r4 - 1]) {
              let t6 = e7;
              const r5 = /:local\s*\((.+?)\)/.exec(e7);
              if (!r5) return e7;
              {
                const e8 = r5.input, n4 = r5[0], s4 = a3(r5[1]);
                t6 = e8.replace(n4, s4);
              }
              return t6;
            }
            return e7;
          }), e6.value = t5.join("");
        });
      }), e4.walkAtRules(/keyframes$/i, (e5) => {
        const t4 = /^\s*:local\s*\((.+?)\)\s*$/.exec(e5.params);
        t4 && (e5.params = a3(t4[1]));
      });
      const p2 = Object.keys(o3);
      if (p2.length > 0) {
        const t4 = i3({ selector: ":export" });
        p2.forEach((e5) => t4.append({ prop: e5, value: o3[e5].join(" "), raws: { before: "\n  " } })), e4.append(t4);
      }
    } };
  };
  No.postcss = true, No.generateScopedName = function(e3, t3) {
    return `_${t3.replace(/\.[^./\\]+$/, "").replace(/[\W_]+/g, "_").replace(/^_|_$/g, "")}__${e3}`.trim();
  }, No.generateExportEntry = function(e3, t3) {
    return { key: ko(e3), value: ko(t3) };
  };
  var Do = No, jo = { exports: {} };
  const Lo = es, Mo = /^(.+?|\([\s\S]+?\))\s+from\s+("[^"]*"|'[^']*'|[\w-]+)$/, Bo = /(?:\s+|^)([\w-]+):?(.*?)$/, Ro = /^([\w-]+)(?:\s+as\s+([\w-]+))?/;
  jo.exports = (e3) => {
    let t3 = 0;
    const r3 = e3 && e3.createImportedName || ((e4) => `i__const_${e4.replace(/\W/g, "_")}_${t3++}`);
    return { postcssPlugin: "postcss-modules-values", prepare(e4) {
      const t4 = [], n3 = {};
      return { Once(s3, i3) {
        if (s3.walkAtRules(/value/i, (s4) => {
          const i4 = s4.params.match(Mo);
          if (i4) {
            let [, e5, o5] = i4;
            n3[o5] && (o5 = n3[o5]);
            const a4 = e5.replace(/^\(\s*([\s\S]+)\s*\)$/, "$1").split(/\s*,\s*/).map((e6) => {
              const t5 = Ro.exec(e6);
              if (t5) {
                const [, e7, s5 = e7] = t5, i5 = r3(s5);
                return n3[s5] = i5, { theirName: e7, importedName: i5 };
              }
              throw new Error(`@import statement "${e6}" is invalid!`);
            });
            return t4.push({ path: o5, imports: a4 }), void s4.remove();
          }
          -1 !== s4.params.indexOf("@value") && e4.warn("Invalid value definition: " + s4.params);
          let [, o4, a3] = `${s4.params}${s4.raws.between}`.match(Bo);
          const l2 = a3.replace(/\/\*((?!\*\/).*?)\*\//g, "");
          if (0 === l2.length) return e4.warn("Invalid value definition: " + s4.params), void s4.remove();
          /^\s+$/.test(l2) || (a3 = a3.trim()), n3[o4] = Lo.replaceValueSymbols(a3, n3), s4.remove();
        }), !Object.keys(n3).length) return;
        Lo.replaceSymbols(s3, n3);
        const o3 = Object.keys(n3).map((e5) => i3.decl({ value: n3[e5], prop: e5, raws: { before: "\n  " } }));
        if (o3.length > 0) {
          const e5 = i3.rule({ selector: ":export", raws: { after: "\n" } });
          e5.append(o3), s3.prepend(e5);
        }
        t4.reverse().forEach((e5) => {
          let { path: t5, imports: r4 } = e5;
          const n4 = i3.rule({ selector: `:import(${t5})`, raws: { after: "\n" } });
          r4.forEach((e6) => {
            let { theirName: t6, importedName: r5 } = e6;
            n4.append({ value: t6, prop: r5, raws: { before: "\n  " } });
          }), s3.prepend(n4);
        });
      } };
    } };
  }, jo.exports.postcss = true;
  var Fo = jo.exports;
  Object.defineProperty(bi, "__esModule", { value: true }), bi.behaviours = void 0, bi.getDefaultPlugins = function(e3) {
    let { behaviour: t3, generateScopedName: r3, exportGlobals: n3 } = e3;
    const s3 = (0, qo.default)({ generateScopedName: r3, exportGlobals: n3 });
    return { [zo.LOCAL]: [Go.default, (0, Vo.default)({ mode: "local" }), Uo.default, s3], [zo.GLOBAL]: [Go.default, (0, Vo.default)({ mode: "global" }), Uo.default, s3] }[t3];
  }, bi.getDefaultScopeBehaviour = function(e3) {
    return e3 && (t3 = e3, Object.keys(zo).map((e4) => zo[e4]).indexOf(t3) > -1) ? e3 : zo.LOCAL;
    var t3;
  }, bi.getScopedNameGenerator = function(e3, t3) {
    const r3 = e3 || Ko;
    return "function" == typeof r3 ? r3 : (0, $o.default)(r3, { context: n2.cwd(), hashPrefix: t3 });
  };
  var Uo = Ho(Ai), $o = Ho(function(e3, t3) {
    var r3 = (t3 = t3 || {}) && "string" == typeof t3.context ? t3.context : n2.cwd(), s3 = t3 && "string" == typeof t3.hashPrefix ? t3.hashPrefix : "";
    return function(t4, n3) {
      var i3 = e3.replace(/\[local\]/gi, t4), o3 = { resourcePath: n3 }, a3 = { content: s3 + Ji.relative(r3, n3).replace(/\\/g, "/") + "\0" + t4, context: r3 };
      return Xi(o3, i3, a3).replace(new RegExp("[^a-zA-Z0-9\\-_-]", "g"), "-").replace(/^((-?[0-9])|--)/, "_$1");
    };
  }), Vo = Ho(Ao), qo = Ho(Do), Wo = Ho(function(e3) {
    for (var t3 = 5381, r3 = e3.length; r3; ) t3 = 33 * t3 ^ e3.charCodeAt(--r3);
    return t3 >>> 0;
  }), Go = Ho(Fo);
  function Ho(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  }
  const zo = { LOCAL: "local", GLOBAL: "global" };
  function Ko(e3, t3, r3) {
    const n3 = r3.indexOf(`.${e3}`), s3 = r3.substr(0, n3).split(/[\r\n]/).length;
    return `_${e3}_${(0, Wo.default)(r3).toString(36).substr(0, 5)}_${s3}`;
  }
  bi.behaviours = zo, Object.defineProperty(Vn, "__esModule", { value: true }), Vn.makePlugin = function(e3) {
    return { postcssPlugin: na, async OnceExit(t3, r3) {
      let { result: n3 } = r3;
      const s3 = e3.getJSON || Qo.default, i3 = t3.source.input.file, o3 = function(e4, t4) {
        const r4 = e4.globalModulePaths || null, n4 = e4.exportGlobals || false, s4 = (0, ta.getDefaultScopeBehaviour)(e4.scopeBehaviour), i4 = (0, ta.getScopedNameGenerator)(e4.generateScopedName, e4.hashPrefix);
        return r4 && function(e5, t5) {
          return e5.some((e6) => t5.match(e6));
        }(r4, t4) ? (0, ta.getDefaultPlugins)({ behaviour: ta.behaviours.GLOBAL, generateScopedName: i4, exportGlobals: n4 }) : (0, ta.getDefaultPlugins)({ behaviour: s4, generateScopedName: i4, exportGlobals: n4 });
      }(e3, i3), a3 = n3.processor.plugins.findIndex((e4) => function(e5) {
        return e5.postcssPlugin === na;
      }(e4));
      if (-1 === a3) throw new Error("Plugin missing from options.");
      const l2 = [...n3.processor.plugins.slice(0, a3), ...o3], c2 = function(e4, t4) {
        const r4 = void 0 === e4.root ? "/" : e4.root;
        return "function" == typeof e4.Loader ? new e4.Loader(r4, t4, e4.resolve) : new ea.default(r4, t4, e4.resolve);
      }(e3, l2), u2 = new Yo.default(async (e4, t4, r4) => {
        const n4 = (0, Jo.default)(e4);
        return c2.fetch.call(c2, n4, t4, r4);
      });
      await (0, Xo.default)([...o3, u2.plugin()]).process(t3, { from: i3 });
      const p2 = c2.finalSource;
      if (p2 && t3.prepend(p2), e3.localsConvention) {
        const t4 = (0, Zo.makeLocalsConventionReducer)(e3.localsConvention, i3);
        u2.exportTokens = Object.entries(u2.exportTokens).reduce(t4, {});
      }
      return n3.messages.push({ type: "export", plugin: "postcss-modules", exportTokens: u2.exportTokens }), s3(t3.source.input.file, u2.exportTokens, n3.opts.to);
    } };
  };
  var Xo = ra(h), Jo = ra(qn), Yo = ra(Gn), Qo = ra(ns), Zo = os, ea = ra(ui), ta = bi;
  function ra(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  }
  const na = "postcss-modules";
  var sa = f, ia = Vn;
  (0, Un.setFileSystem)({ readFile: sa.readFile, writeFile: sa.writeFile }), Fn.exports = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return (0, ia.makePlugin)(e3);
  }, Fn.exports.postcss = true;
  var oa, aa, la = q(Fn.exports);
  function ca(e3) {
    const { filename: t3, id: r3, scoped: n3 = false, trim: s3 = true, isProd: i3 = false, modules: o3 = false, modulesOptions: a3 = {}, preprocessLang: l2, postcssOptions: c2, postcssPlugins: u2 } = e3, p2 = l2 && Rn[l2], d2 = p2 && function(e4, t4) {
      return t4(e4.source, e4.inMap || e4.map, { filename: e4.filename, ...e4.preprocessOptions }, e4.preprocessCustomRequire);
    }(e3, p2), f2 = d2 ? d2.map : e3.inMap || e3.map, m2 = d2 ? d2.code : e3.source, y2 = r3.replace(/^data-v-/, ""), g2 = `data-v-${y2}`, b2 = (u2 || []).slice();
    let v2;
    if (b2.unshift(Z({ id: y2, isProd: i3 })), s3 && b2.push(Ke()), n3 && b2.push(qr(g2)), o3) {
      if (!e3.isAsync) throw new Error("[@vue/compiler-sfc] `modules` option can only be used with compileStyleAsync().");
      b2.push(la({ ...a3, getJSON: (e4, t4) => {
        v2 = t4;
      } }));
    }
    const E2 = { ...c2, to: t3, from: t3 };
    let S2, x2, T2;
    f2 && (E2.map = { inline: false, annotation: false, prev: f2 });
    const w2 = new Set(d2 ? d2.dependencies : []);
    w2.delete(t3);
    const P2 = [];
    d2 && d2.errors.length && P2.push(...d2.errors);
    const A2 = (e4) => (e4.forEach((e5) => {
      "dependency" === e5.type && w2.add(e5.file);
    }), w2);
    try {
      if (S2 = h(b2).process(m2, E2), e3.isAsync) return S2.then((e4) => ({ code: e4.css || "", map: e4.map && e4.map.toJSON(), errors: P2, modules: v2, rawResult: e4, dependencies: A2(e4.messages) })).catch((e4) => ({ code: "", map: void 0, errors: [...P2, e4], rawResult: void 0, dependencies: w2 }));
      A2(S2.messages), x2 = S2.css, T2 = S2.map;
    } catch (e4) {
      P2.push(e4);
    }
    return { code: x2 || "", map: T2 && T2.toJSON(), errors: P2, rawResult: S2, dependencies: w2 };
  }
  function ua(e3) {
    for (const t3 of e3) if ("ExportDefaultDeclaration" === t3.type && "ObjectExpression" === t3.declaration.type) return pa(t3.declaration);
    return {};
  }
  function pa(e3) {
    const t3 = {};
    Object.defineProperty(t3, "__isScriptSetup", { enumerable: false, value: false });
    for (const r3 of e3.properties) if ("ObjectProperty" !== r3.type || r3.computed || "Identifier" !== r3.key.type) {
      if ("ObjectMethod" === r3.type && "Identifier" === r3.key.type && ("setup" === r3.key.name || "data" === r3.key.name)) {
        for (const e4 of r3.body.body) if ("ReturnStatement" === e4.type && e4.argument && "ObjectExpression" === e4.argument.type) for (const n3 of da(e4.argument)) t3[n3] = "setup" === r3.key.name ? "setup-maybe-ref" : "data";
      }
    } else if ("props" === r3.key.name) for (const e4 of fa(r3.value)) t3[e4] = "props";
    else if ("inject" === r3.key.name) for (const e4 of fa(r3.value)) t3[e4] = "options";
    else if ("ObjectExpression" === r3.value.type && ("computed" === r3.key.name || "methods" === r3.key.name)) for (const e4 of da(r3.value)) t3[e4] = "options";
    return t3;
  }
  function da(e3) {
    const t3 = [];
    for (const r3 of e3.properties) {
      if ("SpreadElement" === r3.type) continue;
      const e4 = w(r3.key, r3.computed);
      e4 && t3.push(String(e4));
    }
    return t3;
  }
  function fa(e3) {
    return "ArrayExpression" === e3.type ? function(e4) {
      const t3 = [];
      for (const r3 of e4.elements) r3 && "StringLiteral" === r3.type && t3.push(r3.value);
      return t3;
    }(e3) : "ObjectExpression" === e3.type ? da(e3) : [];
  }
  class ha {
    constructor(e3, t3) {
      this.descriptor = e3, this.options = t3, this.isCE = false, this.source = this.descriptor.source, this.filename = this.descriptor.filename, this.s = new y(this.source), this.startOffset = null == (oa = this.descriptor.scriptSetup) ? void 0 : oa.loc.start.offset, this.endOffset = null == (aa = this.descriptor.scriptSetup) ? void 0 : aa.loc.end.offset, this.userImports = /* @__PURE__ */ Object.create(null), this.hasDefinePropsCall = false, this.hasDefineEmitCall = false, this.hasDefineExposeCall = false, this.hasDefaultExportName = false, this.hasDefaultExportRender = false, this.hasDefineOptionsCall = false, this.hasDefineSlotsCall = false, this.hasDefineModelCall = false, this.propsDestructuredBindings = /* @__PURE__ */ Object.create(null), this.modelDecls = /* @__PURE__ */ Object.create(null), this.bindingMetadata = {}, this.helperImports = /* @__PURE__ */ new Set();
      const { script: r3, scriptSetup: n3 } = e3, s3 = r3 && r3.lang, i3 = n3 && n3.lang;
      this.isJS = "js" === s3 || "jsx" === s3 || "js" === i3 || "jsx" === i3, this.isTS = "ts" === s3 || "tsx" === s3 || "ts" === i3 || "tsx" === i3;
      const o3 = t3.customElement, a3 = this.descriptor.filename;
      o3 && (this.isCE = "boolean" == typeof o3 ? o3 : o3(a3));
      const l2 = ma(s3 || i3, t3.babelParserPlugins);
      function u2(t4, r4) {
        try {
          return g.parse(t4, { plugins: l2, sourceType: "module" }).program;
        } catch (t5) {
          throw t5.message = `[vue/compiler-sfc] ${t5.message}

${e3.filename}
${c.generateCodeFrame(e3.source, t5.pos + r4, t5.pos + r4 + 1)}`, t5;
        }
      }
      this.scriptAst = e3.script && u2(e3.script.content, e3.script.loc.start.offset), this.scriptSetupAst = e3.scriptSetup && u2(e3.scriptSetup.content, this.startOffset);
    }
    helper(e3) {
      return this.helperImports.add(e3), `_${e3}`;
    }
    getString(e3) {
      return (arguments.length > 1 && void 0 !== arguments[1] && !arguments[1] ? this.descriptor.script : this.descriptor.scriptSetup).content.slice(e3.start, e3.end);
    }
    error(e3, t3, r3) {
      const n3 = r3 ? r3.offset : this.startOffset;
      throw new Error(`[@vue/compiler-sfc] ${e3}

${(r3 || this.descriptor).filename}
${c.generateCodeFrame((r3 || this.descriptor).source, t3.start + n3, t3.end + n3)}`);
    }
  }
  function ma(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    const n3 = [];
    return t3 && t3.some((e4) => "importAssertions" === e4 || "importAttributes" === e4 || c.isArray(e4) && "importAttributes" === e4[0]) || n3.push("importAttributes"), "jsx" === e3 || "tsx" === e3 ? n3.push("jsx") : t3 && (t3 = t3.filter((e4) => "jsx" !== e4)), "ts" !== e3 && "tsx" !== e3 || (n3.push(["typescript", { dts: r3 }], "explicitResourceManagement"), t3 && t3.includes("decorators") || n3.push("decorators-legacy")), t3 && n3.push(...t3), n3;
  }
  function ya(e3, t3, r3) {
    !function(e4) {
      for (const t4 of e4) {
        if ("ExportDefaultDeclaration" === t4.type) return true;
        if ("ExportNamedDeclaration" === t4.type && t4.specifiers.some((e5) => "default" === e5.exported.name)) return true;
      }
      return false;
    }(e3) ? t3.append(`
const ${r3} = {}`) : e3.forEach((e4) => {
      if ("ExportDefaultDeclaration" === e4.type) if ("ClassDeclaration" === e4.declaration.type && e4.declaration.id) {
        let n3 = e4.declaration.decorators && e4.declaration.decorators.length > 0 ? e4.declaration.decorators[e4.declaration.decorators.length - 1].end : e4.start;
        t3.overwrite(n3, e4.declaration.id.start, " class "), t3.append(`
const ${r3} = ${e4.declaration.id.name}`);
      } else t3.overwrite(e4.start, e4.declaration.start, `const ${r3} = `);
      else if ("ExportNamedDeclaration" === e4.type) {
        for (const n3 of e4.specifiers) if ("ExportSpecifier" === n3.type && "Identifier" === n3.exported.type && "default" === n3.exported.name) {
          if (e4.source) {
            if ("default" === n3.local.name) {
              t3.prepend(`import { default as __VUE_DEFAULT__ } from '${e4.source.value}'
`);
              const s4 = ga(t3, n3.local.end, e4.end);
              t3.remove(n3.start, s4), t3.append(`
const ${r3} = __VUE_DEFAULT__`);
              continue;
            }
            {
              t3.prepend(`import { ${t3.slice(n3.local.start, n3.local.end)} as __VUE_DEFAULT__ } from '${e4.source.value}'
`);
              const s4 = ga(t3, n3.exported.end, e4.end);
              t3.remove(n3.start, s4), t3.append(`
const ${r3} = __VUE_DEFAULT__`);
              continue;
            }
          }
          const s3 = ga(t3, n3.end, e4.end);
          t3.remove(n3.start, s3), t3.append(`
const ${r3} = ${n3.local.name}`);
        }
      }
    });
  }
  function ga(e3, t3, r3) {
    let n3 = false, s3 = t3;
    for (; t3 < r3; ) if (/\s/.test(e3.slice(t3, t3 + 1))) t3++;
    else {
      if ("," === e3.slice(t3, t3 + 1)) {
        t3++, n3 = true;
        break;
      }
      if ("}" === e3.slice(t3, t3 + 1)) break;
    }
    return n3 ? t3 : s3;
  }
  const ba = "__default__";
  var va = Ea;
  function Ea(e3, t3, r3) {
    e3 instanceof RegExp && (e3 = Sa(e3, r3)), t3 instanceof RegExp && (t3 = Sa(t3, r3));
    var n3 = xa(e3, t3, r3);
    return n3 && { start: n3[0], end: n3[1], pre: r3.slice(0, n3[0]), body: r3.slice(n3[0] + e3.length, n3[1]), post: r3.slice(n3[1] + t3.length) };
  }
  function Sa(e3, t3) {
    var r3 = t3.match(e3);
    return r3 ? r3[0] : null;
  }
  function xa(e3, t3, r3) {
    var n3, s3, i3, o3, a3, l2 = r3.indexOf(e3), c2 = r3.indexOf(t3, l2 + 1), u2 = l2;
    if (l2 >= 0 && c2 > 0) {
      if (e3 === t3) return [l2, c2];
      for (n3 = [], i3 = r3.length; u2 >= 0 && !a3; ) u2 == l2 ? (n3.push(u2), l2 = r3.indexOf(e3, u2 + 1)) : 1 == n3.length ? a3 = [n3.pop(), c2] : ((s3 = n3.pop()) < i3 && (i3 = s3, o3 = c2), c2 = r3.indexOf(t3, u2 + 1)), u2 = l2 < c2 && l2 >= 0 ? l2 : c2;
      n3.length && (a3 = [i3, o3]);
    }
    return a3;
  }
  Ea.range = xa;
  var Ta = va, wa = function(e3) {
    return e3 ? ("{}" === e3.substr(0, 2) && (e3 = "\\{\\}" + e3.substr(2)), Ba(function(e4) {
      return e4.split("\\\\").join(Pa).split("\\{").join(Aa).split("\\}").join(Ca).split("\\,").join(Oa).split("\\.").join(Ia);
    }(e3), true).map(ka)) : [];
  }, Pa = "\0SLASH" + Math.random() + "\0", Aa = "\0OPEN" + Math.random() + "\0", Ca = "\0CLOSE" + Math.random() + "\0", Oa = "\0COMMA" + Math.random() + "\0", Ia = "\0PERIOD" + Math.random() + "\0";
  function _a(e3) {
    return parseInt(e3, 10) == e3 ? parseInt(e3, 10) : e3.charCodeAt(0);
  }
  function ka(e3) {
    return e3.split(Pa).join("\\").split(Aa).join("{").split(Ca).join("}").split(Oa).join(",").split(Ia).join(".");
  }
  function Na(e3) {
    if (!e3) return [""];
    var t3 = [], r3 = Ta("{", "}", e3);
    if (!r3) return e3.split(",");
    var n3 = r3.pre, s3 = r3.body, i3 = r3.post, o3 = n3.split(",");
    o3[o3.length - 1] += "{" + s3 + "}";
    var a3 = Na(i3);
    return i3.length && (o3[o3.length - 1] += a3.shift(), o3.push.apply(o3, a3)), t3.push.apply(t3, o3), t3;
  }
  function Da(e3) {
    return "{" + e3 + "}";
  }
  function ja(e3) {
    return /^-?0\d/.test(e3);
  }
  function La(e3, t3) {
    return e3 <= t3;
  }
  function Ma(e3, t3) {
    return e3 >= t3;
  }
  function Ba(e3, t3) {
    var r3 = [], n3 = Ta("{", "}", e3);
    if (!n3) return [e3];
    var s3 = n3.pre, i3 = n3.post.length ? Ba(n3.post, false) : [""];
    if (/\$$/.test(n3.pre)) for (var o3 = 0; o3 < i3.length; o3++) {
      var a3 = s3 + "{" + n3.body + "}" + i3[o3];
      r3.push(a3);
    }
    else {
      var l2, c2, u2 = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(n3.body), p2 = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(n3.body), d2 = u2 || p2, f2 = n3.body.indexOf(",") >= 0;
      if (!d2 && !f2) return n3.post.match(/,.*\}/) ? Ba(e3 = n3.pre + "{" + n3.body + Ca + n3.post) : [e3];
      if (d2) l2 = n3.body.split(/\.\./);
      else if (1 === (l2 = Na(n3.body)).length && 1 === (l2 = Ba(l2[0], false).map(Da)).length) return i3.map(function(e4) {
        return n3.pre + l2[0] + e4;
      });
      if (d2) {
        var h2 = _a(l2[0]), m2 = _a(l2[1]), y2 = Math.max(l2[0].length, l2[1].length), g2 = 3 == l2.length ? Math.abs(_a(l2[2])) : 1, b2 = La;
        m2 < h2 && (g2 *= -1, b2 = Ma);
        var v2 = l2.some(ja);
        c2 = [];
        for (var E2 = h2; b2(E2, m2); E2 += g2) {
          var S2;
          if (p2) "\\" === (S2 = String.fromCharCode(E2)) && (S2 = "");
          else if (S2 = String(E2), v2) {
            var x2 = y2 - S2.length;
            if (x2 > 0) {
              var T2 = new Array(x2 + 1).join("0");
              S2 = E2 < 0 ? "-" + T2 + S2.slice(1) : T2 + S2;
            }
          }
          c2.push(S2);
        }
      } else {
        c2 = [];
        for (var w2 = 0; w2 < l2.length; w2++) c2.push.apply(c2, Ba(l2[w2], false));
      }
      for (w2 = 0; w2 < c2.length; w2++) for (o3 = 0; o3 < i3.length; o3++) a3 = s3 + c2[w2] + i3[o3], (!t3 || d2 || a3) && r3.push(a3);
    }
    return r3;
  }
  var Ra = q(wa);
  const Fa = (e3) => {
    if ("string" != typeof e3) throw new TypeError("invalid pattern");
    if (e3.length > 65536) throw new TypeError("pattern is too long");
  }, Ua = { "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true], "[:alpha:]": ["\\p{L}\\p{Nl}", true], "[:ascii:]": ["\\x00-\\x7f", false], "[:blank:]": ["\\p{Zs}\\t", true], "[:cntrl:]": ["\\p{Cc}", true], "[:digit:]": ["\\p{Nd}", true], "[:graph:]": ["\\p{Z}\\p{C}", true, true], "[:lower:]": ["\\p{Ll}", true], "[:print:]": ["\\p{C}", true], "[:punct:]": ["\\p{P}", true], "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true], "[:upper:]": ["\\p{Lu}", true], "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true], "[:xdigit:]": ["A-Fa-f0-9", false] }, $a = (e3) => e3.replace(/[[\]\\-]/g, "\\$&"), Va = (e3) => e3.join(""), qa = (e3, t3) => {
    const r3 = t3;
    if ("[" !== e3.charAt(r3)) throw new Error("not in a brace expression");
    const n3 = [], s3 = [];
    let i3 = r3 + 1, o3 = false, a3 = false, l2 = false, c2 = false, u2 = r3, p2 = "";
    e: for (; i3 < e3.length; ) {
      const t4 = e3.charAt(i3);
      if ("!" !== t4 && "^" !== t4 || i3 !== r3 + 1) {
        if ("]" === t4 && o3 && !l2) {
          u2 = i3 + 1;
          break;
        }
        if (o3 = true, "\\" !== t4 || l2) {
          if ("[" === t4 && !l2) {
            for (const [t5, [o4, l3, c3]] of Object.entries(Ua)) if (e3.startsWith(t5, i3)) {
              if (p2) return ["$.", false, e3.length - r3, true];
              i3 += t5.length, c3 ? s3.push(o4) : n3.push(o4), a3 = a3 || l3;
              continue e;
            }
          }
          l2 = false, p2 ? (t4 > p2 ? n3.push($a(p2) + "-" + $a(t4)) : t4 === p2 && n3.push($a(t4)), p2 = "", i3++) : e3.startsWith("-]", i3 + 1) ? (n3.push($a(t4 + "-")), i3 += 2) : e3.startsWith("-", i3 + 1) ? (p2 = t4, i3 += 2) : (n3.push($a(t4)), i3++);
        } else l2 = true, i3++;
      } else c2 = true, i3++;
    }
    if (u2 < i3) return ["", false, 0, false];
    if (!n3.length && !s3.length) return ["$.", false, e3.length - r3, true];
    if (0 === s3.length && 1 === n3.length && /^\\?.$/.test(n3[0]) && !c2) {
      return [(d2 = 2 === n3[0].length ? n3[0].slice(-1) : n3[0], d2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")), false, u2 - r3, false];
    }
    var d2;
    const f2 = "[" + (c2 ? "^" : "") + Va(n3) + "]", h2 = "[" + (c2 ? "" : "^") + Va(s3) + "]";
    return [n3.length && s3.length ? "(" + f2 + "|" + h2 + ")" : n3.length ? f2 : h2, a3, u2 - r3, true];
  }, Wa = function(e3) {
    let { windowsPathsNoEscape: t3 = false } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return t3 ? e3.replace(/\[([^\/\\])\]/g, "$1") : e3.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  }, Ga = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]), Ha = (e3) => Ga.has(e3), za = "(?!\\.)", Ka = /* @__PURE__ */ new Set(["[", "."]), Xa = /* @__PURE__ */ new Set(["..", "."]), Ja = new Set("().*{}+?[]^$\\!"), Ya = "[^/]", Qa = Ya + "*?", Za = Ya + "+?";
  const _el = class _el {
    constructor(e3, t3) {
      __privateAdd(this, _el_instances);
      __publicField(this, "type");
      __privateAdd(this, _U);
      __privateAdd(this, _$);
      __privateAdd(this, _V, false);
      __privateAdd(this, _q, []);
      __privateAdd(this, _W);
      __privateAdd(this, _G);
      __privateAdd(this, _H);
      __privateAdd(this, _z, false);
      __privateAdd(this, _K);
      __privateAdd(this, _X);
      __privateAdd(this, _J, false);
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      this.type = e3, e3 && __privateSet(this, _$, true), __privateSet(this, _W, t3), __privateSet(this, _U, __privateGet(this, _W) ? __privateGet(__privateGet(this, _W), _U) : this), __privateSet(this, _K, __privateGet(this, _U) === this ? r3 : __privateGet(__privateGet(this, _U), _K)), __privateSet(this, _H, __privateGet(this, _U) === this ? [] : __privateGet(__privateGet(this, _U), _H)), "!" !== e3 || __privateGet(__privateGet(this, _U), _z) || __privateGet(this, _H).push(this), __privateSet(this, _G, __privateGet(this, _W) ? __privateGet(__privateGet(this, _W), _q).length : 0);
    }
    get hasMagic() {
      if (void 0 !== __privateGet(this, _$)) return __privateGet(this, _$);
      for (const e3 of __privateGet(this, _q)) if ("string" != typeof e3 && (e3.type || e3.hasMagic)) return __privateSet(this, _$, true);
      return __privateGet(this, _$);
    }
    toString() {
      return void 0 !== __privateGet(this, _X) ? __privateGet(this, _X) : this.type ? __privateSet(this, _X, this.type + "(" + __privateGet(this, _q).map((e3) => String(e3)).join("|") + ")") : __privateSet(this, _X, __privateGet(this, _q).map((e3) => String(e3)).join(""));
    }
    push() {
      for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
      for (const e4 of t3) if ("" !== e4) {
        if ("string" != typeof e4 && !(e4 instanceof _el && __privateGet(e4, _W) === this)) throw new Error("invalid part: " + e4);
        __privateGet(this, _q).push(e4);
      }
    }
    toJSON() {
      var _a4;
      const e3 = null === this.type ? __privateGet(this, _q).slice().map((e4) => "string" == typeof e4 ? e4 : e4.toJSON()) : [this.type, ...__privateGet(this, _q).map((e4) => e4.toJSON())];
      return this.isStart() && !this.type && e3.unshift([]), this.isEnd() && (this === __privateGet(this, _U) || __privateGet(__privateGet(this, _U), _z) && "!" === ((_a4 = __privateGet(this, _W)) == null ? void 0 : _a4.type)) && e3.push({}), e3;
    }
    isStart() {
      var _a4;
      if (__privateGet(this, _U) === this) return true;
      if (!((_a4 = __privateGet(this, _W)) == null ? void 0 : _a4.isStart())) return false;
      if (0 === __privateGet(this, _G)) return true;
      const e3 = __privateGet(this, _W);
      for (let t3 = 0; t3 < __privateGet(this, _G); t3++) {
        const r3 = __privateGet(e3, _q)[t3];
        if (!(r3 instanceof _el && "!" === r3.type)) return false;
      }
      return true;
    }
    isEnd() {
      var _a4, _b2, _c3;
      if (__privateGet(this, _U) === this) return true;
      if ("!" === ((_a4 = __privateGet(this, _W)) == null ? void 0 : _a4.type)) return true;
      if (!((_b2 = __privateGet(this, _W)) == null ? void 0 : _b2.isEnd())) return false;
      if (!this.type) return (_c3 = __privateGet(this, _W)) == null ? void 0 : _c3.isEnd();
      const e3 = __privateGet(this, _W) ? __privateGet(__privateGet(this, _W), _q).length : 0;
      return __privateGet(this, _G) === e3 - 1;
    }
    copyIn(e3) {
      "string" == typeof e3 ? this.push(e3) : this.push(e3.clone(this));
    }
    clone(e3) {
      const t3 = new _el(this.type, e3);
      for (const e4 of __privateGet(this, _q)) t3.copyIn(e4);
      return t3;
    }
    static fromGlob(e3) {
      var _a4;
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const r3 = new _el(null, void 0, t3);
      return __privateMethod(_a4 = _el, _el_static, Q_fn).call(_a4, e3, r3, 0, t3), r3;
    }
    toMMPattern() {
      if (this !== __privateGet(this, _U)) return __privateGet(this, _U).toMMPattern();
      const e3 = this.toString(), [t3, r3, n3, s3] = this.toRegExpSource();
      if (!(n3 || __privateGet(this, _$) || __privateGet(this, _K).nocase && !__privateGet(this, _K).nocaseMagicOnly && e3.toUpperCase() !== e3.toLowerCase())) return r3;
      const i3 = (__privateGet(this, _K).nocase ? "i" : "") + (s3 ? "u" : "");
      return Object.assign(new RegExp(`^${t3}$`, i3), { _src: t3, _glob: e3 });
    }
    toRegExpSource(e3) {
      var _a4;
      const t3 = e3 ?? !!__privateGet(this, _K).dot;
      if (__privateGet(this, _U) === this && __privateMethod(this, _el_instances, Y_fn).call(this), !this.type) {
        const r4 = this.isStart() && this.isEnd(), n4 = __privateGet(this, _q).map((t4) => {
          var _a5;
          const [n5, s5, i5, o4] = "string" == typeof t4 ? __privateMethod(_a5 = _el, _el_static, Z_fn).call(_a5, t4, __privateGet(this, _$), r4) : t4.toRegExpSource(e3);
          return __privateSet(this, _$, __privateGet(this, _$) || i5), __privateSet(this, _V, __privateGet(this, _V) || o4), n5;
        }).join("");
        let s4 = "";
        if (this.isStart() && "string" == typeof __privateGet(this, _q)[0] && (1 !== __privateGet(this, _q).length || !Xa.has(__privateGet(this, _q)[0]))) {
          const r5 = Ka, i5 = t3 && r5.has(n4.charAt(0)) || n4.startsWith("\\.") && r5.has(n4.charAt(2)) || n4.startsWith("\\.\\.") && r5.has(n4.charAt(4)), o4 = !t3 && !e3 && r5.has(n4.charAt(0));
          s4 = i5 ? "(?!(?:^|/)\\.\\.?(?:$|/))" : o4 ? za : "";
        }
        let i4 = "";
        return this.isEnd() && __privateGet(__privateGet(this, _U), _z) && "!" === ((_a4 = __privateGet(this, _W)) == null ? void 0 : _a4.type) && (i4 = "(?:$|\\/)"), [s4 + n4 + i4, Wa(n4), __privateSet(this, _$, !!__privateGet(this, _$)), __privateGet(this, _V)];
      }
      const r3 = "*" === this.type || "+" === this.type, n3 = "!" === this.type ? "(?:(?!(?:" : "(?:";
      let s3 = __privateMethod(this, _el_instances, ee_fn).call(this, t3);
      if (this.isStart() && this.isEnd() && !s3 && "!" !== this.type) {
        const e4 = this.toString();
        return __privateSet(this, _q, [e4]), this.type = null, __privateSet(this, _$, void 0), [e4, Wa(this.toString()), false, false];
      }
      let i3 = !r3 || e3 || t3 ? "" : __privateMethod(this, _el_instances, ee_fn).call(this, true);
      i3 === s3 && (i3 = ""), i3 && (s3 = `(?:${s3})(?:${i3})*?`);
      let o3 = "";
      return o3 = "!" === this.type && __privateGet(this, _J) ? (this.isStart() && !t3 ? za : "") + Za : n3 + s3 + ("!" === this.type ? "))" + (!this.isStart() || t3 || e3 ? "" : za) + Qa + ")" : "@" === this.type ? ")" : "?" === this.type ? ")?" : "+" === this.type && i3 ? ")" : "*" === this.type && i3 ? ")?" : `)${this.type}`), [o3, Wa(s3), __privateSet(this, _$, !!__privateGet(this, _$)), __privateGet(this, _V)];
    }
  };
  _U = new WeakMap();
  _$ = new WeakMap();
  _V = new WeakMap();
  _q = new WeakMap();
  _W = new WeakMap();
  _G = new WeakMap();
  _H = new WeakMap();
  _z = new WeakMap();
  _K = new WeakMap();
  _X = new WeakMap();
  _J = new WeakMap();
  _el_instances = new WeakSet();
  Y_fn = function() {
    if (this !== __privateGet(this, _U)) throw new Error("should only call on root");
    if (__privateGet(this, _z)) return this;
    let e3;
    for (this.toString(), __privateSet(this, _z, true); e3 = __privateGet(this, _H).pop(); ) {
      if ("!" !== e3.type) continue;
      let t3 = e3, r3 = __privateGet(t3, _W);
      for (; r3; ) {
        for (let n3 = __privateGet(t3, _G) + 1; !r3.type && n3 < __privateGet(r3, _q).length; n3++) for (const t4 of __privateGet(e3, _q)) {
          if ("string" == typeof t4) throw new Error("string part in extglob AST??");
          t4.copyIn(__privateGet(r3, _q)[n3]);
        }
        t3 = r3, r3 = __privateGet(t3, _W);
      }
    }
    return this;
  };
  _el_static = new WeakSet();
  Q_fn = function(e3, t3, r3, n3) {
    var _a4, _b2;
    let s3 = false, i3 = false, o3 = -1, a3 = false;
    if (null === t3.type) {
      let l3 = r3, c3 = "";
      for (; l3 < e3.length; ) {
        const r4 = e3.charAt(l3++);
        if (s3 || "\\" === r4) s3 = !s3, c3 += r4;
        else if (i3) l3 === o3 + 1 ? "^" !== r4 && "!" !== r4 || (a3 = true) : "]" !== r4 || l3 === o3 + 2 && a3 || (i3 = false), c3 += r4;
        else if ("[" !== r4) if (n3.noext || !Ha(r4) || "(" !== e3.charAt(l3)) c3 += r4;
        else {
          t3.push(c3), c3 = "";
          const s4 = new _el(r4, t3);
          l3 = __privateMethod(_a4 = _el, _el_static, Q_fn).call(_a4, e3, s4, l3, n3), t3.push(s4);
        }
        else i3 = true, o3 = l3, a3 = false, c3 += r4;
      }
      return t3.push(c3), l3;
    }
    let l2 = r3 + 1, c2 = new _el(null, t3);
    const u2 = [];
    let p2 = "";
    for (; l2 < e3.length; ) {
      const r4 = e3.charAt(l2++);
      if (s3 || "\\" === r4) s3 = !s3, p2 += r4;
      else if (i3) l2 === o3 + 1 ? "^" !== r4 && "!" !== r4 || (a3 = true) : "]" !== r4 || l2 === o3 + 2 && a3 || (i3 = false), p2 += r4;
      else if ("[" !== r4) if (Ha(r4) && "(" === e3.charAt(l2)) {
        c2.push(p2), p2 = "";
        const t4 = new _el(r4, c2);
        c2.push(t4), l2 = __privateMethod(_b2 = _el, _el_static, Q_fn).call(_b2, e3, t4, l2, n3);
      } else if ("|" !== r4) {
        if (")" === r4) return "" === p2 && 0 === __privateGet(t3, _q).length && __privateSet(t3, _J, true), c2.push(p2), p2 = "", t3.push(...u2, c2), l2;
        p2 += r4;
      } else c2.push(p2), p2 = "", u2.push(c2), c2 = new _el(null, t3);
      else i3 = true, o3 = l2, a3 = false, p2 += r4;
    }
    return t3.type = null, __privateSet(t3, _$, void 0), __privateSet(t3, _q, [e3.substring(r3 - 1)]), l2;
  };
  ee_fn = function(e3) {
    return __privateGet(this, _q).map((t3) => {
      if ("string" == typeof t3) throw new Error("string type in extglob ast??");
      const [r3, n3, s3, i3] = t3.toRegExpSource(e3);
      return __privateSet(this, _V, __privateGet(this, _V) || i3), r3;
    }).filter((e4) => !(this.isStart() && this.isEnd() && !e4)).join("|");
  };
  Z_fn = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = false, s3 = "", i3 = false;
    for (let o3 = 0; o3 < e3.length; o3++) {
      const a3 = e3.charAt(o3);
      if (n3) n3 = false, s3 += (Ja.has(a3) ? "\\" : "") + a3;
      else if ("\\" !== a3) {
        if ("[" === a3) {
          const [r4, n4, a4, l2] = qa(e3, o3);
          if (a4) {
            s3 += r4, i3 = i3 || n4, o3 += a4 - 1, t3 = t3 || l2;
            continue;
          }
        }
        "*" !== a3 ? "?" !== a3 ? s3 += a3.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : (s3 += Ya, t3 = true) : (s3 += r3 && "*" === e3 ? Za : Qa, t3 = true);
      } else o3 === e3.length - 1 ? s3 += "\\\\" : n3 = true;
    }
    return [s3, Wa(e3), !!t3, i3];
  };
  __privateAdd(_el, _el_static);
  let el = _el;
  const tl = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    return Fa(t3), !(!r3.nocomment && "#" === t3.charAt(0)) && new Ol(t3, r3).match(e3);
  }, rl = /^\*+([^+@!?\*\[\(]*)$/, nl = (e3) => (t3) => !t3.startsWith(".") && t3.endsWith(e3), sl = (e3) => (t3) => t3.endsWith(e3), il = (e3) => (e3 = e3.toLowerCase(), (t3) => !t3.startsWith(".") && t3.toLowerCase().endsWith(e3)), ol = (e3) => (e3 = e3.toLowerCase(), (t3) => t3.toLowerCase().endsWith(e3)), al = /^\*+\.\*+$/, ll = (e3) => !e3.startsWith(".") && e3.includes("."), cl = (e3) => "." !== e3 && ".." !== e3 && e3.includes("."), ul = /^\.\*+$/, pl = (e3) => "." !== e3 && ".." !== e3 && e3.startsWith("."), dl = /^\*+$/, fl = (e3) => 0 !== e3.length && !e3.startsWith("."), hl = (e3) => 0 !== e3.length && "." !== e3 && ".." !== e3, ml = /^\?+([^+@!?\*\[\(]*)?$/, yl = (e3) => {
    let [t3, r3 = ""] = e3;
    const n3 = El([t3]);
    return r3 ? (r3 = r3.toLowerCase(), (e4) => n3(e4) && e4.toLowerCase().endsWith(r3)) : n3;
  }, gl = (e3) => {
    let [t3, r3 = ""] = e3;
    const n3 = Sl([t3]);
    return r3 ? (r3 = r3.toLowerCase(), (e4) => n3(e4) && e4.toLowerCase().endsWith(r3)) : n3;
  }, bl = (e3) => {
    let [t3, r3 = ""] = e3;
    const n3 = Sl([t3]);
    return r3 ? (e4) => n3(e4) && e4.endsWith(r3) : n3;
  }, vl = (e3) => {
    let [t3, r3 = ""] = e3;
    const n3 = El([t3]);
    return r3 ? (e4) => n3(e4) && e4.endsWith(r3) : n3;
  }, El = (e3) => {
    let [t3] = e3;
    const r3 = t3.length;
    return (e4) => e4.length === r3 && !e4.startsWith(".");
  }, Sl = (e3) => {
    let [t3] = e3;
    const r3 = t3.length;
    return (e4) => e4.length === r3 && "." !== e4 && ".." !== e4;
  }, xl = "object" == typeof n2 && n2 ? "object" == typeof n2.env && n2.env && n2.env.__MINIMATCH_TESTING_PLATFORM__ || n2.platform : "posix", Tl = "win32" === xl ? "\\" : "/";
  tl.sep = Tl;
  const wl = Symbol("globstar **");
  tl.GLOBSTAR = wl, tl.filter = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return (r3) => tl(r3, e3, t3);
  };
  const Pl = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return Object.assign({}, e3, t3);
  };
  tl.defaults = (e3) => {
    if (!e3 || "object" != typeof e3 || !Object.keys(e3).length) return tl;
    const t3 = tl;
    return Object.assign(function(r3, n3) {
      return t3(r3, n3, Pl(e3, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}));
    }, { Minimatch: class extends t3.Minimatch {
      constructor(t4) {
        super(t4, Pl(e3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}));
      }
      static defaults(r3) {
        return t3.defaults(Pl(e3, r3)).Minimatch;
      }
    }, AST: class extends t3.AST {
      constructor(t4, r3) {
        super(t4, r3, Pl(e3, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}));
      }
      static fromGlob(r3) {
        let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return t3.AST.fromGlob(r3, Pl(e3, n3));
      }
    }, unescape: function(r3) {
      let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3.unescape(r3, Pl(e3, n3));
    }, escape: function(r3) {
      let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3.escape(r3, Pl(e3, n3));
    }, filter: function(r3) {
      let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3.filter(r3, Pl(e3, n3));
    }, defaults: (r3) => t3.defaults(Pl(e3, r3)), makeRe: function(r3) {
      let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3.makeRe(r3, Pl(e3, n3));
    }, braceExpand: function(r3) {
      let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3.braceExpand(r3, Pl(e3, n3));
    }, match: function(r3, n3) {
      let s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      return t3.match(r3, n3, Pl(e3, s3));
    }, sep: t3.sep, GLOBSTAR: wl });
  };
  const Al = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return Fa(e3), t3.nobrace || !/\{(?:(?!\{).)*\}/.test(e3) ? [e3] : Ra(e3);
  };
  tl.braceExpand = Al, tl.makeRe = function(e3) {
    return new Ol(e3, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).makeRe();
  }, tl.match = function(e3, t3) {
    const r3 = new Ol(t3, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {});
    return e3 = e3.filter((e4) => r3.match(e4)), r3.options.nonull && !e3.length && e3.push(t3), e3;
  };
  const Cl = /[?*]|[+@!]\(.*?\)|\[|\]/;
  class Ol {
    constructor(e3) {
      __publicField(this, "options");
      __publicField(this, "set");
      __publicField(this, "pattern");
      __publicField(this, "windowsPathsNoEscape");
      __publicField(this, "nonegate");
      __publicField(this, "negate");
      __publicField(this, "comment");
      __publicField(this, "empty");
      __publicField(this, "preserveMultipleSlashes");
      __publicField(this, "partial");
      __publicField(this, "globSet");
      __publicField(this, "globParts");
      __publicField(this, "nocase");
      __publicField(this, "isWindows");
      __publicField(this, "platform");
      __publicField(this, "windowsNoMagicRoot");
      __publicField(this, "regexp");
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      Fa(e3), t3 = t3 || {}, this.options = t3, this.pattern = e3, this.platform = t3.platform || xl, this.isWindows = "win32" === this.platform, this.windowsPathsNoEscape = !!t3.windowsPathsNoEscape || false === t3.allowWindowsEscape, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!t3.preserveMultipleSlashes, this.regexp = null, this.negate = false, this.nonegate = !!t3.nonegate, this.comment = false, this.empty = false, this.partial = !!t3.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = void 0 !== t3.windowsNoMagicRoot ? t3.windowsNoMagicRoot : !(!this.isWindows || !this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
    }
    hasMagic() {
      if (this.options.magicalBraces && this.set.length > 1) return true;
      for (const e3 of this.set) for (const t3 of e3) if ("string" != typeof t3) return true;
      return false;
    }
    debug() {
    }
    make() {
      const e3 = this.pattern, t3 = this.options;
      if (!t3.nocomment && "#" === e3.charAt(0)) return void (this.comment = true);
      if (!e3) return void (this.empty = true);
      this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], t3.debug && (this.debug = function() {
      }), this.debug(this.pattern, this.globSet);
      const r3 = this.globSet.map((e4) => this.slashSplit(e4));
      this.globParts = this.preprocess(r3), this.debug(this.pattern, this.globParts);
      let n3 = this.globParts.map((e4, t4, r4) => {
        if (this.isWindows && this.windowsNoMagicRoot) {
          const t5 = !("" !== e4[0] || "" !== e4[1] || "?" !== e4[2] && Cl.test(e4[2]) || Cl.test(e4[3])), r5 = /^[a-z]:/i.test(e4[0]);
          if (t5) return [...e4.slice(0, 4), ...e4.slice(4).map((e5) => this.parse(e5))];
          if (r5) return [e4[0], ...e4.slice(1).map((e5) => this.parse(e5))];
        }
        return e4.map((e5) => this.parse(e5));
      });
      if (this.debug(this.pattern, n3), this.set = n3.filter((e4) => -1 === e4.indexOf(false)), this.isWindows) for (let e4 = 0; e4 < this.set.length; e4++) {
        const t4 = this.set[e4];
        "" === t4[0] && "" === t4[1] && "?" === this.globParts[e4][2] && "string" == typeof t4[3] && /^[a-z]:$/i.test(t4[3]) && (t4[2] = "?");
      }
      this.debug(this.pattern, this.set);
    }
    preprocess(e3) {
      if (this.options.noglobstar) for (let t4 = 0; t4 < e3.length; t4++) for (let r3 = 0; r3 < e3[t4].length; r3++) "**" === e3[t4][r3] && (e3[t4][r3] = "*");
      const { optimizationLevel: t3 = 1 } = this.options;
      return t3 >= 2 ? (e3 = this.firstPhasePreProcess(e3), e3 = this.secondPhasePreProcess(e3)) : e3 = t3 >= 1 ? this.levelOneOptimize(e3) : this.adjascentGlobstarOptimize(e3), e3;
    }
    adjascentGlobstarOptimize(e3) {
      return e3.map((e4) => {
        let t3 = -1;
        for (; -1 !== (t3 = e4.indexOf("**", t3 + 1)); ) {
          let r3 = t3;
          for (; "**" === e4[r3 + 1]; ) r3++;
          r3 !== t3 && e4.splice(t3, r3 - t3);
        }
        return e4;
      });
    }
    levelOneOptimize(e3) {
      return e3.map((e4) => 0 === (e4 = e4.reduce((e5, t3) => {
        const r3 = e5[e5.length - 1];
        return "**" === t3 && "**" === r3 ? e5 : ".." === t3 && r3 && ".." !== r3 && "." !== r3 && "**" !== r3 ? (e5.pop(), e5) : (e5.push(t3), e5);
      }, [])).length ? [""] : e4);
    }
    levelTwoFileOptimize(e3) {
      Array.isArray(e3) || (e3 = this.slashSplit(e3));
      let t3 = false;
      do {
        if (t3 = false, !this.preserveMultipleSlashes) {
          for (let r4 = 1; r4 < e3.length - 1; r4++) {
            const n3 = e3[r4];
            1 === r4 && "" === n3 && "" === e3[0] || "." !== n3 && "" !== n3 || (t3 = true, e3.splice(r4, 1), r4--);
          }
          "." !== e3[0] || 2 !== e3.length || "." !== e3[1] && "" !== e3[1] || (t3 = true, e3.pop());
        }
        let r3 = 0;
        for (; -1 !== (r3 = e3.indexOf("..", r3 + 1)); ) {
          const n3 = e3[r3 - 1];
          n3 && "." !== n3 && ".." !== n3 && "**" !== n3 && (t3 = true, e3.splice(r3 - 1, 2), r3 -= 2);
        }
      } while (t3);
      return 0 === e3.length ? [""] : e3;
    }
    firstPhasePreProcess(e3) {
      let t3 = false;
      do {
        t3 = false;
        for (let r3 of e3) {
          let n3 = -1;
          for (; -1 !== (n3 = r3.indexOf("**", n3 + 1)); ) {
            let s4 = n3;
            for (; "**" === r3[s4 + 1]; ) s4++;
            s4 > n3 && r3.splice(n3 + 1, s4 - n3);
            let i3 = r3[n3 + 1];
            const o3 = r3[n3 + 2], a3 = r3[n3 + 3];
            if (".." !== i3) continue;
            if (!o3 || "." === o3 || ".." === o3 || !a3 || "." === a3 || ".." === a3) continue;
            t3 = true, r3.splice(n3, 1);
            const l2 = r3.slice(0);
            l2[n3] = "**", e3.push(l2), n3--;
          }
          if (!this.preserveMultipleSlashes) {
            for (let e4 = 1; e4 < r3.length - 1; e4++) {
              const n4 = r3[e4];
              1 === e4 && "" === n4 && "" === r3[0] || "." !== n4 && "" !== n4 || (t3 = true, r3.splice(e4, 1), e4--);
            }
            "." !== r3[0] || 2 !== r3.length || "." !== r3[1] && "" !== r3[1] || (t3 = true, r3.pop());
          }
          let s3 = 0;
          for (; -1 !== (s3 = r3.indexOf("..", s3 + 1)); ) {
            const e4 = r3[s3 - 1];
            if (e4 && "." !== e4 && ".." !== e4 && "**" !== e4) {
              t3 = true;
              const e5 = 1 === s3 && "**" === r3[s3 + 1] ? ["."] : [];
              r3.splice(s3 - 1, 2, ...e5), 0 === r3.length && r3.push(""), s3 -= 2;
            }
          }
        }
      } while (t3);
      return e3;
    }
    secondPhasePreProcess(e3) {
      for (let t3 = 0; t3 < e3.length - 1; t3++) for (let r3 = t3 + 1; r3 < e3.length; r3++) {
        const n3 = this.partsMatch(e3[t3], e3[r3], !this.preserveMultipleSlashes);
        n3 && (e3[t3] = n3, e3[r3] = []);
      }
      return e3.filter((e4) => e4.length);
    }
    partsMatch(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = 0, s3 = 0, i3 = [], o3 = "";
      for (; n3 < e3.length && s3 < t3.length; ) if (e3[n3] === t3[s3]) i3.push("b" === o3 ? t3[s3] : e3[n3]), n3++, s3++;
      else if (r3 && "**" === e3[n3] && t3[s3] === e3[n3 + 1]) i3.push(e3[n3]), n3++;
      else if (r3 && "**" === t3[s3] && e3[n3] === t3[s3 + 1]) i3.push(t3[s3]), s3++;
      else if ("*" !== e3[n3] || !t3[s3] || !this.options.dot && t3[s3].startsWith(".") || "**" === t3[s3]) {
        if ("*" !== t3[s3] || !e3[n3] || !this.options.dot && e3[n3].startsWith(".") || "**" === e3[n3]) return false;
        if ("a" === o3) return false;
        o3 = "b", i3.push(t3[s3]), n3++, s3++;
      } else {
        if ("b" === o3) return false;
        o3 = "a", i3.push(e3[n3]), n3++, s3++;
      }
      return e3.length === t3.length && i3;
    }
    parseNegate() {
      if (this.nonegate) return;
      const e3 = this.pattern;
      let t3 = false, r3 = 0;
      for (let n3 = 0; n3 < e3.length && "!" === e3.charAt(n3); n3++) t3 = !t3, r3++;
      r3 && (this.pattern = e3.slice(r3)), this.negate = t3;
    }
    matchOne(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      const n3 = this.options;
      if (this.isWindows) {
        const r4 = "string" == typeof e3[0] && /^[a-z]:$/i.test(e3[0]), n4 = !r4 && "" === e3[0] && "" === e3[1] && "?" === e3[2] && /^[a-z]:$/i.test(e3[3]), s4 = "string" == typeof t3[0] && /^[a-z]:$/i.test(t3[0]), i4 = n4 ? 3 : r4 ? 0 : void 0, o4 = !s4 && "" === t3[0] && "" === t3[1] && "?" === t3[2] && "string" == typeof t3[3] && /^[a-z]:$/i.test(t3[3]) ? 3 : s4 ? 0 : void 0;
        if ("number" == typeof i4 && "number" == typeof o4) {
          const [r5, n5] = [e3[i4], t3[o4]];
          r5.toLowerCase() === n5.toLowerCase() && (t3[o4] = r5, o4 > i4 ? t3 = t3.slice(o4) : i4 > o4 && (e3 = e3.slice(i4)));
        }
      }
      const { optimizationLevel: s3 = 1 } = this.options;
      s3 >= 2 && (e3 = this.levelTwoFileOptimize(e3)), this.debug("matchOne", this, { file: e3, pattern: t3 }), this.debug("matchOne", e3.length, t3.length);
      for (var i3 = 0, o3 = 0, a3 = e3.length, l2 = t3.length; i3 < a3 && o3 < l2; i3++, o3++) {
        this.debug("matchOne loop");
        var c2 = t3[o3], u2 = e3[i3];
        if (this.debug(t3, c2, u2), false === c2) return false;
        if (c2 === wl) {
          this.debug("GLOBSTAR", [t3, c2, u2]);
          var p2 = i3, d2 = o3 + 1;
          if (d2 === l2) {
            for (this.debug("** at the end"); i3 < a3; i3++) if ("." === e3[i3] || ".." === e3[i3] || !n3.dot && "." === e3[i3].charAt(0)) return false;
            return true;
          }
          for (; p2 < a3; ) {
            var f2 = e3[p2];
            if (this.debug("\nglobstar while", e3, p2, t3, d2, f2), this.matchOne(e3.slice(p2), t3.slice(d2), r3)) return this.debug("globstar found match!", p2, a3, f2), true;
            if ("." === f2 || ".." === f2 || !n3.dot && "." === f2.charAt(0)) {
              this.debug("dot detected!", e3, p2, t3, d2);
              break;
            }
            this.debug("globstar swallow a segment, and continue"), p2++;
          }
          return !(!r3 || (this.debug("\n>>> no match, partial?", e3, p2, t3, d2), p2 !== a3));
        }
        let s4;
        if ("string" == typeof c2 ? (s4 = u2 === c2, this.debug("string match", c2, u2, s4)) : (s4 = c2.test(u2), this.debug("pattern match", c2, u2, s4)), !s4) return false;
      }
      if (i3 === a3 && o3 === l2) return true;
      if (i3 === a3) return r3;
      if (o3 === l2) return i3 === a3 - 1 && "" === e3[i3];
      throw new Error("wtf?");
    }
    braceExpand() {
      return Al(this.pattern, this.options);
    }
    parse(e3) {
      Fa(e3);
      const t3 = this.options;
      if ("**" === e3) return wl;
      if ("" === e3) return "";
      let r3, n3 = null;
      (r3 = e3.match(dl)) ? n3 = t3.dot ? hl : fl : (r3 = e3.match(rl)) ? n3 = (t3.nocase ? t3.dot ? ol : il : t3.dot ? sl : nl)(r3[1]) : (r3 = e3.match(ml)) ? n3 = (t3.nocase ? t3.dot ? gl : yl : t3.dot ? bl : vl)(r3) : (r3 = e3.match(al)) ? n3 = t3.dot ? cl : ll : (r3 = e3.match(ul)) && (n3 = pl);
      const s3 = el.fromGlob(e3, this.options).toMMPattern();
      return n3 ? Object.assign(s3, { test: n3 }) : s3;
    }
    makeRe() {
      if (this.regexp || false === this.regexp) return this.regexp;
      const e3 = this.set;
      if (!e3.length) return this.regexp = false, this.regexp;
      const t3 = this.options, r3 = t3.noglobstar ? "[^/]*?" : t3.dot ? "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?" : "(?:(?!(?:\\/|^)\\.).)*?", n3 = new Set(t3.nocase ? ["i"] : []);
      let s3 = e3.map((e4) => {
        const t4 = e4.map((e5) => {
          if (e5 instanceof RegExp) for (const t5 of e5.flags.split("")) n3.add(t5);
          return "string" == typeof e5 ? e5.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : e5 === wl ? wl : e5._src;
        });
        return t4.forEach((e5, n4) => {
          const s4 = t4[n4 + 1], i4 = t4[n4 - 1];
          e5 === wl && i4 !== wl && (void 0 === i4 ? void 0 !== s4 && s4 !== wl ? t4[n4 + 1] = "(?:\\/|" + r3 + "\\/)?" + s4 : t4[n4] = r3 : void 0 === s4 ? t4[n4 - 1] = i4 + "(?:\\/|" + r3 + ")?" : s4 !== wl && (t4[n4 - 1] = i4 + "(?:\\/|\\/" + r3 + "\\/)" + s4, t4[n4 + 1] = wl));
        }), t4.filter((e5) => e5 !== wl).join("/");
      }).join("|");
      const [i3, o3] = e3.length > 1 ? ["(?:", ")"] : ["", ""];
      s3 = "^" + i3 + s3 + o3 + "$", this.negate && (s3 = "^(?!" + s3 + ").+$");
      try {
        this.regexp = new RegExp(s3, [...n3].join(""));
      } catch (e4) {
        this.regexp = false;
      }
      return this.regexp;
    }
    slashSplit(e3) {
      return this.preserveMultipleSlashes ? e3.split("/") : this.isWindows && /^\/\/[^\/]+/.test(e3) ? ["", ...e3.split(/\/+/)] : e3.split(/\/+/);
    }
    match(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.partial;
      if (this.debug("match", e3, this.pattern), this.comment) return false;
      if (this.empty) return "" === e3;
      if ("/" === e3 && t3) return true;
      const r3 = this.options;
      this.isWindows && (e3 = e3.split("\\").join("/"));
      const n3 = this.slashSplit(e3);
      this.debug(this.pattern, "split", n3);
      const s3 = this.set;
      this.debug(this.pattern, "set", s3);
      let i3 = n3[n3.length - 1];
      if (!i3) for (let e4 = n3.length - 2; !i3 && e4 >= 0; e4--) i3 = n3[e4];
      for (let e4 = 0; e4 < s3.length; e4++) {
        const o3 = s3[e4];
        let a3 = n3;
        if (r3.matchBase && 1 === o3.length && (a3 = [i3]), this.matchOne(a3, o3, t3)) return !!r3.flipNegate || !this.negate;
      }
      return !r3.flipNegate && this.negate;
    }
    static defaults(e3) {
      return tl.defaults(e3).Minimatch;
    }
  }
  tl.AST = el, tl.Minimatch = Ol, tl.escape = function(e3) {
    let { windowsPathsNoEscape: t3 = false } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return t3 ? e3.replace(/[?*()[\]]/g, "[$&]") : e3.replace(/[?*()[\]\\]/g, "\\$&");
  }, tl.unescape = Wa;
  class Il {
    constructor(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : /* @__PURE__ */ Object.create(null), s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : /* @__PURE__ */ Object.create(null), i3 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : /* @__PURE__ */ Object.create(null);
      this.filename = e3, this.source = t3, this.offset = r3, this.imports = n3, this.types = s3, this.declares = i3, this.isGenericScope = false, this.resolvedImportSources = /* @__PURE__ */ Object.create(null), this.exportedTypes = /* @__PURE__ */ Object.create(null), this.exportedDeclares = /* @__PURE__ */ Object.create(null);
    }
  }
  function _l(e3, t3, r3, n3) {
    const s3 = !n3;
    if (s3 && t3._resolvedElements) return t3._resolvedElements;
    const i3 = function(e4, t4, r4, n4) {
      var s4, i4;
      switch (t4.type) {
        case "TSTypeLiteral":
          return kl(e4, t4.members, r4, n4);
        case "TSInterfaceDeclaration":
          return function(e5, t5, r5, n5) {
            const s5 = kl(e5, t5.body.body, t5._ownerScope, n5);
            if (t5.extends) {
              for (const n6 of t5.extends) if (!n6.leadingComments || !n6.leadingComments.some((e6) => e6.value.includes("@vue-ignore"))) try {
                const { props: t6, calls: i5 } = _l(e5, n6, r5);
                for (const e6 in t6) c.hasOwn(s5.props, e6) || (s5.props[e6] = t6[e6]);
                i5 && (s5.calls || (s5.calls = [])).push(...i5);
              } catch (t6) {
                e5.error("Failed to resolve extends base type.\nIf this previously worked in 3.2, you can instruct the compiler to ignore this extend by adding /* @vue-ignore */ before it, for example:\n\ninterface Props extends /* @vue-ignore */ Base {}\n\nNote: both in 3.2 or with the ignore, the properties in the base type are treated as fallthrough attrs at runtime.", n6);
              }
            }
            return s5;
          }(e4, t4, r4, n4);
        case "TSTypeAliasDeclaration":
        case "TSParenthesizedType":
          return _l(e4, t4.typeAnnotation, r4, n4);
        case "TSFunctionType":
          return { props: {}, calls: [t4] };
        case "TSUnionType":
        case "TSIntersectionType":
          return Nl(t4.types.map((t5) => _l(e4, t5, r4, n4)), t4.type);
        case "TSMappedType":
          return function(e5, t5, r5) {
            const n5 = { props: {} }, s5 = Ml(e5, t5.typeParameter.constraint, r5);
            for (const e6 of s5) n5.props[e6] = Dl({ type: "Identifier", name: e6 }, t5.typeAnnotation, r5, !!t5.optional);
            return n5;
          }(e4, t4, r4);
        case "TSIndexedAccessType":
          return Nl(jl(e4, t4, r4).map((t5) => _l(e4, t5, t5._ownerScope)), "TSUnionType");
        case "TSExpressionWithTypeArguments":
        case "TSTypeReference": {
          const i5 = $l(t4);
          if (("ExtractPropTypes" === i5 || "ExtractPublicPropTypes" === i5) && t4.typeParameters && "vue" === (null == (s4 = r4.imports[i5]) ? void 0 : s4.source)) return uc(_l(e4, t4.typeParameters.params[0], r4, n4), r4);
          const o3 = Fl(e4, t4, r4);
          if (o3) {
            let r5;
            return ("TSTypeAliasDeclaration" === o3.type || "TSInterfaceDeclaration" === o3.type) && o3.typeParameters && t4.typeParameters && (r5 = /* @__PURE__ */ Object.create(null), o3.typeParameters.params.forEach((e5, s5) => {
              let i6 = n4 && n4[e5.name];
              i6 || (i6 = t4.typeParameters.params[s5]), r5[e5.name] = i6;
            })), _l(e4, o3, o3._ownerScope, r5);
          }
          if ("string" == typeof i5) {
            if (n4 && n4[i5]) return _l(e4, n4[i5], r4, n4);
            if (Rl.has(i5)) return function(e5, t5, r5, n5, s5) {
              const i6 = _l(e5, t5.typeParameters.params[0], n5, s5);
              switch (r5) {
                case "Partial": {
                  const e6 = { props: {}, calls: i6.calls };
                  return Object.keys(i6.props).forEach((t6) => {
                    e6.props[t6] = { ...i6.props[t6], optional: true };
                  }), e6;
                }
                case "Required": {
                  const e6 = { props: {}, calls: i6.calls };
                  return Object.keys(i6.props).forEach((t6) => {
                    e6.props[t6] = { ...i6.props[t6], optional: false };
                  }), e6;
                }
                case "Readonly":
                  return i6;
                case "Pick": {
                  const r7 = Ml(e5, t5.typeParameters.params[1], n5), s7 = { props: {}, calls: i6.calls };
                  for (const e6 of r7) s7.props[e6] = i6.props[e6];
                  return s7;
                }
                case "Omit":
                  const r6 = Ml(e5, t5.typeParameters.params[1], n5), s6 = { props: {}, calls: i6.calls };
                  for (const e6 in i6.props) r6.includes(e6) || (s6.props[e6] = i6.props[e6]);
                  return s6;
              }
            }(e4, t4, i5, r4, n4);
            if ("ReturnType" === i5 && t4.typeParameters) {
              const n5 = function(e5, t5, r5) {
                var n6;
                let s5 = t5;
                if ("TSTypeReference" !== t5.type && "TSTypeQuery" !== t5.type && "TSImportType" !== t5.type || (s5 = Fl(e5, t5, r5)), s5) return "TSFunctionType" === s5.type ? null == (n6 = s5.typeAnnotation) ? void 0 : n6.typeAnnotation : "TSDeclareFunction" === s5.type ? s5.returnType : void 0;
              }(e4, t4.typeParameters.params[0], r4);
              if (n5) return _l(e4, n5, r4);
            }
          }
          return e4.error("Unresolvable type reference or unsupported built-in utility type", t4, r4);
        }
        case "TSImportType": {
          if ("vue" === _(t4.argument) && "Identifier" === (null == (i4 = t4.qualifier) ? void 0 : i4.type) && "ExtractPropTypes" === t4.qualifier.name && t4.typeParameters) return uc(_l(e4, t4.typeParameters.params[0], r4), r4);
          const n5 = Hl(e4, t4.argument, r4, t4.argument.value), s5 = Fl(e4, t4, n5);
          if (s5) return _l(e4, s5, s5._ownerScope);
          break;
        }
        case "TSTypeQuery": {
          const n5 = Fl(e4, t4, r4);
          if (n5) return _l(e4, n5, n5._ownerScope);
        }
      }
      return e4.error(`Unresolvable type: ${t4.type}`, t4, r4);
    }(e3, t3, t3._ownerScope || r3 || Zl(e3), n3);
    return s3 ? t3._resolvedElements = i3 : i3;
  }
  function kl(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Zl(e3), n3 = arguments.length > 3 ? arguments[3] : void 0;
    const s3 = { props: {} };
    for (const i3 of t3) if ("TSPropertySignature" === i3.type || "TSMethodSignature" === i3.type) {
      n3 && (r3 = ec(r3), r3.isGenericScope = true, Object.assign(r3.types, n3)), i3._ownerScope = r3;
      const t4 = _(i3.key);
      if (t4 && !i3.computed) s3.props[t4] = i3;
      else if ("TemplateLiteral" === i3.key.type) for (const t5 of Bl(e3, i3.key, r3)) s3.props[t5] = i3;
      else e3.error("Unsupported computed key in type referenced by a macro", i3.key, r3);
    } else "TSCallSignatureDeclaration" === i3.type && (s3.calls || (s3.calls = [])).push(i3);
    return s3;
  }
  function Nl(e3, t3) {
    if (1 === e3.length) return e3[0];
    const r3 = { props: {} }, { props: n3 } = r3;
    for (const { props: s3, calls: i3 } of e3) {
      for (const e4 in s3) c.hasOwn(n3, e4) ? n3[e4] = Dl(n3[e4].key, { type: t3, types: [n3[e4], s3[e4]] }, n3[e4]._ownerScope, n3[e4].optional || s3[e4].optional) : n3[e4] = s3[e4];
      i3 && (r3.calls || (r3.calls = [])).push(...i3);
    }
    return r3;
  }
  function Dl(e3, t3, r3, n3) {
    return { type: "TSPropertySignature", key: e3, kind: "get", optional: n3, typeAnnotation: { type: "TSTypeAnnotation", typeAnnotation: t3 }, _ownerScope: r3 };
  }
  function jl(e3, t3, r3) {
    var n3, s3;
    if ("TSNumberKeyword" === t3.indexType.type) return Ll(e3, t3.objectType, r3);
    const { indexType: i3, objectType: o3 } = t3, a3 = [];
    let l2, c2;
    "TSStringKeyword" === i3.type ? (c2 = _l(e3, o3, r3), l2 = Object.keys(c2.props)) : (l2 = Ml(e3, i3, r3), c2 = _l(e3, o3, r3));
    for (const e4 of l2) {
      const t4 = null == (s3 = null == (n3 = c2.props[e4]) ? void 0 : n3.typeAnnotation) ? void 0 : s3.typeAnnotation;
      t4 && (t4._ownerScope = c2.props[e4]._ownerScope, a3.push(t4));
    }
    return a3;
  }
  function Ll(e3, t3, r3) {
    if ("TSArrayType" === t3.type) return [t3.elementType];
    if ("TSTupleType" === t3.type) return t3.elementTypes.map((e4) => "TSNamedTupleMember" === e4.type ? e4.elementType : e4);
    if ("TSTypeReference" === t3.type) {
      if ("Array" === $l(t3) && t3.typeParameters) return t3.typeParameters.params;
      {
        const n3 = Fl(e3, t3, r3);
        if (n3) return Ll(e3, n3, r3);
      }
    }
    return e3.error("Failed to resolve element type from target type", t3, r3);
  }
  function Ml(e3, t3, r3) {
    switch (t3.type) {
      case "StringLiteral":
        return [t3.value];
      case "TSLiteralType":
        return Ml(e3, t3.literal, r3);
      case "TSUnionType":
        return t3.types.map((t4) => Ml(e3, t4, r3)).flat();
      case "TemplateLiteral":
        return Bl(e3, t3, r3);
      case "TSTypeReference": {
        const n3 = Fl(e3, t3, r3);
        if (n3) return Ml(e3, n3, r3);
        if ("Identifier" === t3.typeName.type) {
          const n4 = function() {
            let n5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return Ml(e3, t3.typeParameters.params[n5], r3);
          };
          switch (t3.typeName.name) {
            case "Extract":
              return n4(1);
            case "Exclude": {
              const e4 = n4(1);
              return n4().filter((t4) => !e4.includes(t4));
            }
            case "Uppercase":
              return n4().map((e4) => e4.toUpperCase());
            case "Lowercase":
              return n4().map((e4) => e4.toLowerCase());
            case "Capitalize":
              return n4().map(c.capitalize);
            case "Uncapitalize":
              return n4().map((e4) => e4[0].toLowerCase() + e4.slice(1));
            default:
              e3.error("Unsupported type when resolving index type", t3.typeName, r3);
          }
        }
      }
    }
    return e3.error("Failed to resolve index type into finite keys", t3, r3);
  }
  function Bl(e3, t3, r3) {
    if (!t3.expressions.length) return [t3.quasis[0].value.raw];
    const n3 = [], s3 = t3.expressions[0], i3 = t3.quasis[0], o3 = i3 ? i3.value.raw : "", a3 = Ml(e3, s3, r3), l2 = Bl(e3, { ...t3, expressions: t3.expressions.slice(1), quasis: i3 ? t3.quasis.slice(1) : t3.quasis }, r3);
    for (const e4 of a3) for (const t4 of l2) n3.push(o3 + e4 + t4);
    return n3;
  }
  const Rl = /* @__PURE__ */ new Set(["Partial", "Required", "Readonly", "Pick", "Omit"]);
  function Fl(e3, t3, r3, n3) {
    let s3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    const i3 = !(null == r3 ? void 0 : r3.isGenericScope);
    if (i3 && t3._resolvedReference) return t3._resolvedReference;
    const o3 = Ul(e3, r3 || Zl(e3), n3 || $l(t3), t3, s3);
    return i3 ? t3._resolvedReference = o3 : o3;
  }
  function Ul(e3, t3, r3, n3, s3) {
    if ("string" == typeof r3) {
      if (t3.imports[r3]) return function(e4, t4, r4, n4) {
        const { source: s4, imported: i3 } = n4.imports[r4];
        return Fl(e4, t4, Hl(e4, t4, n4, s4), i3, true);
      }(e3, n3, r3, t3);
      {
        const i3 = "TSTypeQuery" === n3.type ? s3 ? t3.exportedDeclares : t3.declares : s3 ? t3.exportedTypes : t3.types;
        if (i3[r3]) return i3[r3];
        {
          const t4 = function(e4) {
            if (e4.options.globalTypeFiles) {
              if (!Gl(e4)) throw new Error("[vue/compiler-sfc] globalTypeFiles requires fs access.");
              return e4.options.globalTypeFiles.map((t5) => Ql(e4, B(t5), true));
            }
          }(e3);
          if (t4) for (const s4 of t4) {
            const t5 = "TSTypeQuery" === n3.type ? s4.declares : s4.types;
            if (t5[r3]) return (e3.deps || (e3.deps = /* @__PURE__ */ new Set())).add(s4.filename), t5[r3];
          }
        }
      }
    } else {
      let i3 = Ul(e3, t3, r3[0], n3, s3);
      if (i3 && ("TSModuleDeclaration" !== i3.type && (i3 = i3._ns), i3)) {
        const s4 = function(e4, t4, r4) {
          if (t4._resolvedChildScope) return t4._resolvedChildScope;
          const n4 = ec(r4);
          if ("TSModuleDeclaration" === t4.body.type) {
            const e5 = t4.body;
            e5._ownerScope = n4;
            const r5 = _(e5.id);
            n4.types[r5] = n4.exportedTypes[r5] = e5;
          } else rc(e4, t4.body.body, n4);
          return t4._resolvedChildScope = n4;
        }(e3, i3, i3._ownerScope || t3);
        return Ul(e3, s4, r3.length > 2 ? r3.slice(1) : r3[r3.length - 1], n3, !i3.declare);
      }
    }
  }
  function $l(e3) {
    const t3 = "TSTypeReference" === e3.type ? e3.typeName : "TSExpressionWithTypeArguments" === e3.type ? e3.expression : "TSImportType" === e3.type ? e3.qualifier : e3.exprName;
    return "Identifier" === (null == t3 ? void 0 : t3.type) ? t3.name : "TSQualifiedName" === (null == t3 ? void 0 : t3.type) ? Vl(t3) : "default";
  }
  function Vl(e3) {
    return "Identifier" === e3.type ? [e3.name] : [...Vl(e3.left), e3.right.name];
  }
  let ql, Wl;
  function Gl(e3) {
    if (e3.fs) return e3.fs;
    !ql && Wl && (ql = Wl());
    const t3 = e3.options.fs || (null == ql ? void 0 : ql.sys);
    return t3 ? e3.fs = { fileExists: (e4) => (e4.endsWith(".vue.ts") && (e4 = e4.replace(/\.ts$/, "")), t3.fileExists(e4)), readFile: (e4) => (e4.endsWith(".vue.ts") && (e4 = e4.replace(/\.ts$/, "")), t3.readFile(e4)), realpath: t3.realpath } : void 0;
  }
  function Hl(e3, t3, r3, n3) {
    let s3;
    try {
      s3 = Gl(e3);
    } catch (n4) {
      return e3.error(n4.message, t3, r3);
    }
    if (!s3) return e3.error("No fs option provided to `compileScript` in non-Node environment. File system access is required for resolving imported types.", t3, r3);
    let i3 = r3.resolvedImportSources[n3];
    if (!i3) {
      if (n3.startsWith("..")) i3 = zl(("win32" === x.platform ? l.join : R)(l.dirname(r3.filename), n3), s3);
      else if (n3.startsWith(".")) i3 = zl(R(l.dirname(r3.filename), n3), s3);
      else {
        if (!ql && (Wl && (ql = Wl()), !ql)) return e3.error(`Failed to resolve import source ${JSON.stringify(n3)}. typescript is required as a peer dep for vue in order to support resolving types from module imports.`, t3, r3);
        i3 = function(e4, t4, r4, n4) {
          var s4, i4;
          const o3 = r4.findConfigFile(e4, n4.fileExists);
          let a3, c2;
          if (o3) {
            let t5;
            const u3 = B(o3), p2 = Kl.get(u3);
            let d2;
            if (p2 ? t5 = p2 : (t5 = Jl(o3, r4, n4).map((e5) => ({ config: e5 })), Kl.set(u3, t5)), 1 === t5.length) d2 = t5[0];
            else {
              for (const r5 of t5) {
                const t6 = B(r5.config.options.pathsBasePath || l.dirname(r5.config.options.configFilePath)), n5 = null == (s4 = r5.config.raw) ? void 0 : s4.include, o4 = null == (i4 = r5.config.raw) ? void 0 : i4.exclude;
                if (!n5 && (!t6 || e4.startsWith(t6)) || n5.some((r6) => tl(e4, R(t6, r6)))) {
                  if (o4 && o4.some((r6) => tl(e4, R(t6, r6)))) continue;
                  d2 = r5;
                  break;
                }
              }
              d2 || (d2 = t5[t5.length - 1]);
            }
            a3 = d2.config.options, c2 = d2.cache || (d2.cache = r4.createModuleResolutionCache(x.cwd(), r4.sys.useCaseSensitiveFileNames ? k : j, a3));
          } else a3 = {};
          const u2 = r4.resolveModuleName(t4, e4, a3, n4, c2);
          if (u2.resolvedModule) {
            let e5 = u2.resolvedModule.resolvedFileName;
            return e5.endsWith(".vue.ts") && (e5 = e5.replace(/\.ts$/, "")), n4.realpath ? n4.realpath(e5) : e5;
          }
        }(r3.filename, n3, ql, s3);
      }
      i3 && (i3 = r3.resolvedImportSources[n3] = B(i3));
    }
    return i3 ? ((e3.deps || (e3.deps = /* @__PURE__ */ new Set())).add(i3), Ql(e3, i3)) : e3.error(`Failed to resolve import source ${JSON.stringify(n3)}.`, t3, r3);
  }
  function zl(e3, t3) {
    const r3 = (e4) => {
      if (t3.fileExists(e4)) return e4;
    };
    return r3(e3 = e3.replace(/\.js$/, "")) || r3(e3 + ".ts") || r3(e3 + ".d.ts") || r3(R(e3, "index.ts")) || r3(R(e3, "index.d.ts"));
  }
  const Kl = de(), Xl = /* @__PURE__ */ new Map();
  function Jl(e3, t3, r3) {
    const n3 = t3.sys, s3 = t3.parseJsonConfigFileContent(t3.readConfigFile(e3, r3.readFile).config, n3, l.dirname(e3), void 0, e3), i3 = [s3];
    if (s3.projectReferences) for (const n4 of s3.projectReferences) Xl.set(n4.path, e3), i3.unshift(...Jl(n4.path, t3, r3));
    return i3;
  }
  const Yl = de();
  function Ql(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    const n3 = Yl.get(t3);
    if (n3) return n3;
    const s3 = Gl(e3).readFile(t3) || "", i3 = function(e4, t4, r4) {
      const n4 = l.extname(e4);
      if (".ts" === n4 || ".tsx" === n4) return g.parse(t4, { plugins: ma(n4.slice(1), r4, e4.endsWith(".d.ts")), sourceType: "module" }).program.body;
      if (".vue" === n4) {
        const { descriptor: { script: e5, scriptSetup: n5 } } = be(t4);
        if (!e5 && !n5) return [];
        const s4 = e5 ? e5.loc.start.offset : 1 / 0, i4 = n5 ? n5.loc.start.offset : 1 / 0, o4 = s4 < i4 ? e5 : n5, a3 = s4 < i4 ? n5 : e5;
        let l2 = " ".repeat(Math.min(s4, i4)) + o4.content;
        a3 && (l2 += " ".repeat(a3.loc.start.offset - e5.loc.end.offset) + a3.content);
        const c2 = (null == e5 ? void 0 : e5.lang) || (null == n5 ? void 0 : n5.lang);
        return g.parse(l2, { plugins: ma(c2, r4), sourceType: "module" }).program.body;
      }
      return [];
    }(t3, s3, e3.options.babelParserPlugins), o3 = new Il(t3, s3, 0, oc(i3));
    return rc(e3, i3, o3, r3), Yl.set(t3, o3), o3;
  }
  function Zl(e3) {
    if (e3.scope) return e3.scope;
    const t3 = "ast" in e3 ? e3.ast : e3.scriptAst ? [...e3.scriptAst.body, ...e3.scriptSetupAst.body] : e3.scriptSetupAst.body, r3 = new Il(e3.filename, e3.source, "startOffset" in e3 ? e3.startOffset : 0, "userImports" in e3 ? Object.create(e3.userImports) : oc(t3));
    return rc(e3, t3, r3), e3.scope = r3;
  }
  function ec(e3) {
    return new Il(e3.filename, e3.source, e3.offset, Object.create(e3.imports), Object.create(e3.types), Object.create(e3.declares));
  }
  const tc = /^Import|^Export/;
  function rc(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    const { types: s3, declares: i3, exportedTypes: o3, exportedDeclares: a3, imports: l2 } = r3, c2 = !!n3 && !t3.some((e4) => tc.test(e4.type));
    for (const e4 of t3) if (n3) {
      if (c2) e4.declare && nc(e4, s3, i3);
      else if ("TSModuleDeclaration" === e4.type && e4.global) for (const t4 of e4.body.body) nc(t4, s3, i3);
    } else nc(e4, s3, i3);
    if (!n3) for (const n4 of t3) if ("ExportNamedDeclaration" === n4.type) {
      if (n4.declaration) nc(n4.declaration, s3, i3), nc(n4.declaration, o3, a3);
      else for (const e4 of n4.specifiers) if ("ExportSpecifier" === e4.type) {
        const t4 = e4.local.name, i4 = _(e4.exported);
        n4.source ? (l2[i4] = { source: n4.source.value, imported: t4 }, o3[i4] = { type: "TSTypeReference", typeName: { type: "Identifier", name: t4 }, _ownerScope: r3 }) : s3[t4] && (o3[i4] = s3[t4]);
      }
    } else if ("ExportAllDeclaration" === n4.type) {
      const t4 = Hl(e3, n4.source, r3, n4.source.value);
      Object.assign(r3.exportedTypes, t4.exportedTypes);
    } else "ExportDefaultDeclaration" === n4.type && n4.declaration && ("Identifier" !== n4.declaration.type ? (nc(n4.declaration, s3, i3, "default"), nc(n4.declaration, o3, a3, "default")) : s3[n4.declaration.name] && (o3.default = s3[n4.declaration.name]));
    for (const e4 of Object.keys(s3)) {
      const t4 = s3[e4];
      t4._ownerScope = r3, t4._ns && (t4._ns._ownerScope = r3);
    }
    for (const e4 of Object.keys(i3)) i3[e4]._ownerScope = r3;
  }
  function nc(e3, t3, r3, n3) {
    switch (e3.type) {
      case "TSInterfaceDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration": {
        const r4 = n3 || _(e3.id);
        let s3 = t3[r4];
        if (s3) {
          if ("TSModuleDeclaration" === e3.type) {
            "TSModuleDeclaration" === s3.type ? sc(s3, e3) : ic(s3, e3);
            break;
          }
          if ("TSModuleDeclaration" === s3.type) {
            t3[r4] = e3, ic(e3, s3);
            break;
          }
          if (s3.type !== e3.type) break;
          "TSInterfaceDeclaration" === e3.type ? s3.body.body.push(...e3.body.body) : s3.members.push(...e3.members);
        } else t3[r4] = e3;
        break;
      }
      case "ClassDeclaration":
        (n3 || e3.id) && (t3[n3 || _(e3.id)] = e3);
        break;
      case "TSTypeAliasDeclaration":
        t3[e3.id.name] = e3.typeParameters ? e3 : e3.typeAnnotation;
        break;
      case "TSDeclareFunction":
        e3.id && (r3[e3.id.name] = e3);
        break;
      case "VariableDeclaration":
        if (e3.declare) for (const t4 of e3.declarations) "Identifier" === t4.id.type && t4.id.typeAnnotation && (r3[t4.id.name] = t4.id.typeAnnotation.typeAnnotation);
    }
  }
  function sc(e3, t3) {
    const r3 = e3.body, n3 = t3.body;
    "TSModuleDeclaration" === r3.type ? "TSModuleDeclaration" === n3.type ? sc(r3, n3) : n3.body.push({ type: "ExportNamedDeclaration", declaration: r3, exportKind: "type", specifiers: [] }) : "TSModuleDeclaration" === n3.type ? r3.body.push({ type: "ExportNamedDeclaration", declaration: n3, exportKind: "type", specifiers: [] }) : r3.body.push(...n3.body);
  }
  function ic(e3, t3) {
    e3._ns ? sc(e3._ns, t3) : e3._ns = t3;
  }
  function oc(e3) {
    const t3 = /* @__PURE__ */ Object.create(null);
    for (const r3 of e3) ac(r3, t3);
    return t3;
  }
  function ac(e3, t3) {
    if ("ImportDeclaration" === e3.type) for (const r3 of e3.specifiers) t3[r3.local.name] = { imported: I(r3), source: e3.source.value };
  }
  function lc(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t3._ownerScope || Zl(e3);
    try {
      switch (t3.type) {
        case "TSStringKeyword":
          return ["String"];
        case "TSNumberKeyword":
          return ["Number"];
        case "TSBooleanKeyword":
          return ["Boolean"];
        case "TSObjectKeyword":
          return ["Object"];
        case "TSNullKeyword":
          return ["null"];
        case "TSTypeLiteral":
        case "TSInterfaceDeclaration": {
          const e4 = /* @__PURE__ */ new Set(), r4 = "TSTypeLiteral" === t3.type ? t3.members : t3.body.body;
          for (const t4 of r4) "TSCallSignatureDeclaration" === t4.type || "TSConstructSignatureDeclaration" === t4.type ? e4.add("Function") : e4.add("Object");
          return e4.size ? Array.from(e4) : ["Object"];
        }
        case "TSPropertySignature":
          if (t3.typeAnnotation) return lc(e3, t3.typeAnnotation.typeAnnotation, r3);
          break;
        case "TSMethodSignature":
        case "TSFunctionType":
          return ["Function"];
        case "TSArrayType":
        case "TSTupleType":
          return ["Array"];
        case "TSLiteralType":
          switch (t3.literal.type) {
            case "StringLiteral":
              return ["String"];
            case "BooleanLiteral":
              return ["Boolean"];
            case "NumericLiteral":
            case "BigIntLiteral":
              return ["Number"];
            default:
              return [T];
          }
        case "TSTypeReference": {
          const n3 = Fl(e3, t3, r3);
          if (n3) return lc(e3, n3, n3._ownerScope);
          if ("Identifier" === t3.typeName.type) switch (t3.typeName.name) {
            case "Array":
            case "Function":
            case "Object":
            case "Set":
            case "Map":
            case "WeakSet":
            case "WeakMap":
            case "Date":
            case "Promise":
            case "Error":
              return [t3.typeName.name];
            case "Partial":
            case "Required":
            case "Readonly":
            case "Record":
            case "Pick":
            case "Omit":
            case "InstanceType":
              return ["Object"];
            case "Uppercase":
            case "Lowercase":
            case "Capitalize":
            case "Uncapitalize":
              return ["String"];
            case "Parameters":
            case "ConstructorParameters":
              return ["Array"];
            case "NonNullable":
              if (t3.typeParameters && t3.typeParameters.params[0]) return lc(e3, t3.typeParameters.params[0], r3).filter((e4) => "null" !== e4);
              break;
            case "Extract":
              if (t3.typeParameters && t3.typeParameters.params[1]) return lc(e3, t3.typeParameters.params[1], r3);
              break;
            case "Exclude":
            case "OmitThisParameter":
              if (t3.typeParameters && t3.typeParameters.params[0]) return lc(e3, t3.typeParameters.params[0], r3);
          }
          break;
        }
        case "TSParenthesizedType":
          return lc(e3, t3.typeAnnotation, r3);
        case "TSUnionType":
          return cc(e3, t3.types, r3);
        case "TSIntersectionType":
          return cc(e3, t3.types, r3).filter((e4) => e4 !== T);
        case "TSEnumDeclaration":
          return function(e4) {
            const t4 = /* @__PURE__ */ new Set();
            for (const r4 of e4.members) if (r4.initializer) switch (r4.initializer.type) {
              case "StringLiteral":
                t4.add("String");
                break;
              case "NumericLiteral":
                t4.add("Number");
            }
            return t4.size ? [...t4] : ["Number"];
          }(t3);
        case "TSSymbolKeyword":
          return ["Symbol"];
        case "TSIndexedAccessType":
          return cc(e3, jl(e3, t3, r3), r3);
        case "ClassDeclaration":
          return ["Object"];
        case "TSImportType": {
          const n3 = Fl(e3, t3, Hl(e3, t3.argument, r3, t3.argument.value));
          if (n3) return lc(e3, n3, n3._ownerScope);
          break;
        }
        case "TSTypeQuery": {
          const n3 = t3.exprName;
          if ("Identifier" === n3.type) {
            const t4 = r3.declares[n3.name];
            if (t4) return lc(e3, t4, t4._ownerScope);
          }
          break;
        }
      }
    } catch (e4) {
    }
    return [T];
  }
  function cc(e3, t3, r3) {
    return 1 === t3.length ? lc(e3, t3[0], r3) : [...new Set([].concat(...t3.map((t4) => lc(e3, t4, r3))))];
  }
  function uc(e3, t3) {
    let { props: r3 } = e3;
    const n3 = { props: {} };
    for (const e4 in r3) {
      const s3 = r3[e4];
      n3.props[e4] = pc(s3.key, s3.typeAnnotation.typeAnnotation, t3);
    }
    return n3;
  }
  function pc(e3, t3, r3) {
    let n3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
    if (arguments.length > 4 && void 0 !== arguments[4] && !arguments[4] || "TSTypeLiteral" !== t3.type) {
      if ("TSTypeReference" === t3.type && "Identifier" === t3.typeName.type) {
        if (t3.typeName.name.endsWith("Constructor")) return Dl(e3, function(e4) {
          const t4 = e4.slice(0, -11);
          switch (t4) {
            case "String":
            case "Number":
            case "Boolean":
              return { type: `TS${t4}Keyword` };
            case "Array":
            case "Function":
            case "Object":
            case "Set":
            case "Map":
            case "WeakSet":
            case "WeakMap":
            case "Date":
            case "Promise":
              return { type: "TSTypeReference", typeName: { type: "Identifier", name: t4 } };
          }
          return { type: "TSNullKeyword" };
        }(t3.typeName.name), r3, n3);
        if ("PropType" === t3.typeName.name && t3.typeParameters) return Dl(e3, t3.typeParameters.params[0], r3, n3);
      }
    } else {
      const n4 = dc(t3, "type");
      if (n4) {
        const s3 = dc(t3, "required");
        return pc(e3, n4, r3, !s3 || "TSLiteralType" !== s3.type || "BooleanLiteral" !== s3.literal.type || !s3.literal.value, false);
      }
    }
    if (("TSTypeReference" === t3.type || "TSImportType" === t3.type) && t3.typeParameters) for (const s3 of t3.typeParameters.params) {
      const t4 = pc(e3, s3, r3, n3);
      if (t4) return t4;
    }
    return Dl(e3, { type: "TSNullKeyword" }, r3, n3);
  }
  function dc(e3, t3) {
    const r3 = e3.members.find((e4) => "TSPropertySignature" === e4.type && !e4.computed && _(e4.key) === t3 && e4.typeAnnotation);
    return r3 && r3.typeAnnotation.typeAnnotation;
  }
  function fc(e3, t3, r3) {
    if ("TSTypeReference" === t3.type) {
      const n4 = Fl(e3, t3, r3);
      n4 && (t3 = n4);
    }
    let n3;
    return n3 = "TSUnionType" === t3.type ? t3.types.flatMap((t4) => fc(e3, t4, r3)) : [t3], n3;
  }
  const hc = "defineModel";
  function mc(e3, t3, r3) {
    if (!C(t3, hc)) return false;
    e3.hasDefineModelCall = true;
    const n3 = t3.typeParameters && t3.typeParameters.params[0] || void 0;
    let s3, i3;
    const a3 = t3.arguments[0] && o2.unwrapTSNode(t3.arguments[0]), l2 = a3 && "StringLiteral" === a3.type;
    l2 ? (s3 = a3.value, i3 = t3.arguments[1]) : (s3 = "modelValue", i3 = a3), e3.modelDecls[s3] && e3.error(`duplicate model name ${JSON.stringify(s3)}`, t3);
    let c2 = i3 && e3.getString(i3), u2 = !i3;
    const p2 = [];
    if (i3 && "ObjectExpression" === i3.type && !i3.properties.some((e4) => "SpreadElement" === e4.type || e4.computed)) {
      let t4 = 0;
      for (let r4 = i3.properties.length - 1; r4 >= 0; r4--) {
        const n4 = i3.properties[r4], s4 = i3.properties[r4 + 1], o3 = n4.start, a4 = s4 ? s4.start : i3.end - 1;
        "ObjectProperty" !== n4.type && "ObjectMethod" !== n4.type || ("Identifier" !== n4.key.type || "get" !== n4.key.name && "set" !== n4.key.name) && ("StringLiteral" !== n4.key.type || "get" !== n4.key.value && "set" !== n4.key.value) ? (t4++, e3.s.remove(e3.startOffset + o3, e3.startOffset + a4), p2.push(n4)) : c2 = c2.slice(0, o3 - i3.start) + c2.slice(a4 - i3.start);
      }
      t4 === i3.properties.length && (u2 = true, e3.s.remove(e3.startOffset + (l2 ? a3.end : i3.start), e3.startOffset + i3.end));
    }
    return e3.modelDecls[s3] = { type: n3, options: c2, runtimeOptionNodes: p2, identifier: r3 && "Identifier" === r3.type ? r3.name : void 0 }, e3.bindingMetadata[s3] = "props", e3.s.overwrite(e3.startOffset + t3.callee.start, e3.startOffset + t3.callee.end, e3.helper("useModel")), e3.s.appendLeft(e3.startOffset + (t3.arguments.length ? t3.arguments[0].start : t3.end - 1), "__props, " + (l2 ? "" : `${JSON.stringify(s3)}${u2 ? "" : ", "}`)), true;
  }
  const yc = "defineProps", gc = "withDefaults";
  function bc(e3, t3, r3) {
    if (!C(t3, yc)) return function(e4, t4, r4) {
      return !!C(t4, gc) && (bc(e4, t4.arguments[0], r4) || e4.error(`${gc}' first argument must be a ${yc} call.`, t4.arguments[0] || t4), e4.propsRuntimeDecl && e4.error(`${gc} can only be used with type-based ${yc} declaration.`, t4), e4.propsDestructureDecl && e4.error(`${gc}() is unnecessary when using destructure with ${yc}().
Prefer using destructure default values, e.g. const { foo = 1 } = defineProps(...).`, t4.callee), e4.propsRuntimeDefaults = t4.arguments[1], e4.propsRuntimeDefaults || e4.error(`The 2nd argument of ${gc} is required.`, t4), e4.propsCall = t4, true);
    }(e3, t3, r3);
    if (e3.hasDefinePropsCall && e3.error(`duplicate ${yc}() call`, t3), e3.hasDefinePropsCall = true, e3.propsRuntimeDecl = t3.arguments[0], e3.propsRuntimeDecl) for (const t4 of fa(e3.propsRuntimeDecl)) t4 in e3.bindingMetadata || (e3.bindingMetadata[t4] = "props");
    return t3.typeParameters && (e3.propsRuntimeDecl && e3.error(`${yc}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, t3), e3.propsTypeDecl = t3.typeParameters.params[0]), r3 && "ObjectPattern" === r3.type && function(e4, t4) {
      if (!e4.options.propsDestructure) return;
      qe("This project is using reactive props destructure, which is an experimental feature. It may receive breaking changes or be removed in the future, so use at your own risk.\nTo stay updated, follow the RFC at https://github.com/vuejs/rfcs/discussions/502."), e4.propsDestructureDecl = t4;
      const r4 = (t5, r5, n3) => {
        e4.propsDestructuredBindings[t5] = { local: r5, default: n3 }, r5 !== t5 && (e4.bindingMetadata[r5] = "props-aliased", (e4.bindingMetadata.__propsAliases || (e4.bindingMetadata.__propsAliases = {}))[r5] = t5);
      };
      for (const n3 of t4.properties) if ("ObjectProperty" === n3.type) {
        const t5 = w(n3.key, n3.computed);
        if (t5 || e4.error(`${yc}() destructure cannot use computed key.`, n3.key), "AssignmentPattern" === n3.value.type) {
          const { left: s3, right: i3 } = n3.value;
          "Identifier" !== s3.type && e4.error(`${yc}() destructure does not support nested patterns.`, s3), r4(t5, s3.name, i3);
        } else "Identifier" === n3.value.type ? r4(t5, n3.value.name) : e4.error(`${yc}() destructure does not support nested patterns.`, n3.value);
      } else e4.propsDestructureRestId = n3.argument.name, e4.bindingMetadata[e4.propsDestructureRestId] = "setup-reactive-const";
    }(e3, r3), e3.propsCall = t3, e3.propsDecl = r3, true;
  }
  function vc(e3) {
    const t3 = function(e4, t4) {
      const r4 = [], n4 = _l(e4, t4);
      for (const t5 in n4.props) {
        const s4 = n4.props[t5];
        let i3 = lc(e4, s4), o3 = false;
        i3.includes(T) && (i3.includes("Boolean") || i3.includes("Function") ? (i3 = i3.filter((e5) => e5 !== T), o3 = true) : i3 = ["null"]), r4.push({ key: t5, required: !s4.optional, type: i3 || ["null"], skipCheck: o3 });
      }
      return r4;
    }(e3, e3.propsTypeDecl);
    if (!t3.length) return;
    const r3 = [], n3 = function(e4) {
      return !(!e4.propsRuntimeDefaults || "ObjectExpression" !== e4.propsRuntimeDefaults.type || !e4.propsRuntimeDefaults.properties.every((e5) => "SpreadElement" !== e5.type && (!e5.computed || e5.key.type.endsWith("Literal"))));
    }(e3);
    for (const s4 of t3) r3.push(Ec(e3, s4, n3)), "bindingMetadata" in e3 && !(s4.key in e3.bindingMetadata) && (e3.bindingMetadata[s4.key] = "props");
    let s3 = `{
    ${r3.join(",\n    ")}
  }`;
    return e3.propsRuntimeDefaults && !n3 && (s3 = `/*#__PURE__*/${e3.helper("mergeDefaults")}(${s3}, ${e3.getString(e3.propsRuntimeDefaults)})`), s3;
  }
  function Ec(e3, t3, r3) {
    let n3, { key: s3, required: i3, type: o3, skipCheck: a3 } = t3;
    const l2 = Sc(e3, s3, o3);
    if (l2) n3 = `default: ${l2.valueString}${l2.needSkipFactory ? ", skipFactory: true" : ""}`;
    else if (r3) {
      const t4 = e3.propsRuntimeDefaults.properties.find((e4) => "SpreadElement" !== e4.type && w(e4.key, e4.computed) === s3);
      t4 && (n3 = "ObjectProperty" === t4.type ? `default: ${e3.getString(t4.value)}` : `${t4.async ? "async " : ""}${"method" !== t4.kind ? `${t4.kind} ` : ""}default() ${e3.getString(t4.body)}`);
    }
    const c2 = U(s3);
    return e3.options.isProd ? o3.some((e4) => "Boolean" === e4 || (!r3 || n3) && "Function" === e4) ? `${c2}: { ${P([`type: ${O(o3)}`, n3])} }` : e3.isCE ? n3 ? `${c2}: { ${n3}, type: ${O(o3)} }` : `${c2}: {type: ${O(o3)}}` : `${c2}: ${n3 ? `{ ${n3} }` : "{}"}` : `${c2}: { ${P([`type: ${O(o3)}`, `required: ${i3}`, a3 && "skipCheck: true", n3])} }`;
  }
  function Sc(e3, t3, r3) {
    const n3 = e3.propsDestructuredBindings[t3], s3 = n3 && n3.default;
    if (s3) {
      const n4 = e3.getString(s3), i3 = o2.unwrapTSNode(s3);
      if (r3 && r3.length && !r3.includes("null")) {
        const n5 = function(e4) {
          switch (e4.type) {
            case "StringLiteral":
              return "String";
            case "NumericLiteral":
              return "Number";
            case "BooleanLiteral":
              return "Boolean";
            case "ObjectExpression":
              return "Object";
            case "ArrayExpression":
              return "Array";
            case "FunctionExpression":
            case "ArrowFunctionExpression":
              return "Function";
          }
        }(i3);
        n5 && !r3.includes(n5) && e3.error(`Default value of prop "${t3}" does not match declared type.`, i3);
      }
      const a3 = !r3 && (o2.isFunctionType(i3) || "Identifier" === i3.type);
      return { valueString: a3 || A(i3) || (null == r3 ? void 0 : r3.includes("Function")) ? n4 : `() => (${n4})`, needSkipFactory: a3 };
    }
  }
  const xc = "defineEmits";
  function Tc(e3, t3, r3) {
    return !!C(t3, xc) && (e3.hasDefineEmitCall && e3.error(`duplicate ${xc}() call`, t3), e3.hasDefineEmitCall = true, e3.emitsRuntimeDecl = t3.arguments[0], t3.typeParameters && (e3.emitsRuntimeDecl && e3.error(`${xc}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, t3), e3.emitsTypeDecl = t3.typeParameters.params[0]), e3.emitDecl = r3, true);
  }
  function wc(e3) {
    const t3 = /* @__PURE__ */ new Set(), r3 = e3.emitsTypeDecl;
    if ("TSFunctionType" === r3.type) return Pc(e3, r3.parameters[0], t3), t3;
    const { props: n3, calls: s3 } = _l(e3, r3);
    let i3 = false;
    for (const e4 in n3) t3.add(e4), i3 = true;
    if (s3) {
      i3 && e3.error("defineEmits() type cannot mixed call signature and property syntax.", r3);
      for (const r4 of s3) Pc(e3, r4.parameters[0], t3);
    }
    return t3;
  }
  function Pc(e3, t3, r3) {
    if ("Identifier" === t3.type && t3.typeAnnotation && "TSTypeAnnotation" === t3.typeAnnotation.type) {
      const n3 = fc(e3, t3.typeAnnotation.typeAnnotation);
      for (const e4 of n3) "TSLiteralType" === e4.type && "UnaryExpression" !== e4.literal.type && "TemplateLiteral" !== e4.literal.type && r3.add(String(e4.literal.value));
    }
  }
  const Ac = "defineExpose";
  function Cc(e3, t3) {
    return !!C(t3, Ac) && (e3.hasDefineExposeCall && e3.error(`duplicate ${Ac}() call`, t3), e3.hasDefineExposeCall = true, true);
  }
  const Oc = "defineSlots";
  function Ic(e3, t3, r3) {
    return !!C(t3, Oc) && (e3.hasDefineSlotsCall && e3.error(`duplicate ${Oc}() call`, t3), e3.hasDefineSlotsCall = true, t3.arguments.length > 0 && e3.error(`${Oc}() cannot accept arguments`, t3), r3 && e3.s.overwrite(e3.startOffset + t3.start, e3.startOffset + t3.end, `${e3.helper("useSlots")}()`), true);
  }
  const _c = "defineOptions";
  function kc(e3, t3) {
    if (!C(t3, _c)) return false;
    if (e3.hasDefineOptionsCall && e3.error(`duplicate ${_c}() call`, t3), t3.typeParameters && e3.error(`${_c}() cannot accept type arguments`, t3), !t3.arguments[0]) return true;
    let r3, n3, s3, i3;
    if (e3.hasDefineOptionsCall = true, e3.optionsRuntimeDecl = o2.unwrapTSNode(t3.arguments[0]), "ObjectExpression" === e3.optionsRuntimeDecl.type) for (const t4 of e3.optionsRuntimeDecl.properties) "ObjectProperty" !== t4.type && "ObjectMethod" !== t4.type || "Identifier" !== t4.key.type || ("props" === t4.key.name && (r3 = t4), "emits" === t4.key.name && (n3 = t4), "expose" === t4.key.name && (s3 = t4), "slots" === t4.key.name && (i3 = t4));
    return r3 && e3.error(`${_c}() cannot be used to declare props. Use ${yc}() instead.`, r3), n3 && e3.error(`${_c}() cannot be used to declare emits. Use ${xc}() instead.`, n3), s3 && e3.error(`${_c}() cannot be used to declare expose. Use ${Ac}() instead.`, s3), i3 && e3.error(`${_c}() cannot be used to declare slots. Use ${Oc}() instead.`, i3), true;
  }
  function Nc(e3, t3, r3, n3) {
    const s3 = t3.argument.extra && t3.argument.extra.parenthesized ? t3.argument.extra.parenStart : t3.argument.start, i3 = e3.startOffset, o3 = e3.descriptor.source.slice(s3 + i3, t3.argument.end + i3), a3 = /\bawait\b/.test(o3);
    e3.s.overwrite(t3.start + i3, s3 + i3, `${r3 ? ";" : ""}(
  ([__temp,__restore] = ${e3.helper("withAsyncContext")}(${a3 ? "async " : ""}() => `), e3.s.appendLeft(t3.end + i3, `)),
  ${n3 ? "" : "__temp = "}await __temp,
  __restore()${n3 ? "" : ",\n  __temp"}
)`);
  }
  function Dc(e3, t3, r3) {
    e3[t3.name] = r3;
  }
  function jc(e3, t3, r3, n3, s3) {
    let i3 = false;
    if ("VariableDeclaration" === t3.type) {
      const a3 = "const" === t3.kind;
      i3 = a3 && t3.declarations.every((e4) => "Identifier" === e4.id.type && Fc(e4.init));
      for (const { id: l2, init: c2 } of t3.declarations) {
        const t4 = c2 && o2.unwrapTSNode(c2), u2 = !(!a3 || !C(t4, (e4) => e4 === yc || e4 === xc || e4 === gc));
        if ("Identifier" === l2.type) {
          let o3;
          const c3 = n3.reactive;
          o3 = (s3 || "script" === e3) && (i3 || a3 && Fc(t4)) ? "literal-const" : C(t4, c3) ? a3 ? "setup-reactive-const" : "setup-let" : u2 || a3 && Rc(t4, c3) ? C(t4, yc) ? "setup-reactive-const" : "setup-const" : a3 ? C(t4, (e4) => e4 === n3.ref || e4 === n3.computed || e4 === n3.shallowRef || e4 === n3.customRef || e4 === n3.toRef || e4 === hc) ? "setup-ref" : "setup-maybe-ref" : "setup-let", Dc(r3, l2, o3);
        } else {
          if (C(t4, yc)) continue;
          "ObjectPattern" === l2.type ? Lc(l2, r3, a3, u2) : "ArrayPattern" === l2.type && Mc(l2, r3, a3, u2);
        }
      }
    } else "TSEnumDeclaration" === t3.type ? (i3 = t3.members.every((e4) => !e4.initializer || Fc(e4.initializer)), r3[t3.id.name] = i3 ? "literal-const" : "setup-const") : "FunctionDeclaration" !== t3.type && "ClassDeclaration" !== t3.type || (r3[t3.id.name] = "setup-const");
    return i3;
  }
  function Lc(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    for (const s3 of e3.properties) if ("ObjectProperty" === s3.type) if ("Identifier" === s3.key.type && s3.key === s3.value) {
      const e4 = n3 ? "setup-const" : r3 ? "setup-maybe-ref" : "setup-let";
      Dc(t3, s3.key, e4);
    } else Bc(s3.value, t3, r3, n3);
    else {
      const e4 = r3 ? "setup-const" : "setup-let";
      Dc(t3, s3.argument, e4);
    }
  }
  function Mc(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    for (const s3 of e3.elements) s3 && Bc(s3, t3, r3, n3);
  }
  function Bc(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    if ("Identifier" === e3.type) Dc(t3, e3, n3 ? "setup-const" : r3 ? "setup-maybe-ref" : "setup-let");
    else if ("RestElement" === e3.type) {
      const n4 = r3 ? "setup-const" : "setup-let";
      Dc(t3, e3.argument, n4);
    } else if ("ObjectPattern" === e3.type) Lc(e3, t3, r3);
    else if ("ArrayPattern" === e3.type) Mc(e3, t3, r3);
    else if ("AssignmentPattern" === e3.type) if ("Identifier" === e3.left.type) {
      const s3 = n3 ? "setup-const" : r3 ? "setup-maybe-ref" : "setup-let";
      Dc(t3, e3.left, s3);
    } else Bc(e3.left, t3, r3);
  }
  function Rc(e3, t3) {
    if (C(e3, t3)) return true;
    switch (e3.type) {
      case "UnaryExpression":
      case "BinaryExpression":
      case "ArrayExpression":
      case "ObjectExpression":
      case "FunctionExpression":
      case "ArrowFunctionExpression":
      case "UpdateExpression":
      case "ClassExpression":
      case "TaggedTemplateExpression":
        return true;
      case "SequenceExpression":
        return Rc(e3.expressions[e3.expressions.length - 1], t3);
      default:
        return !!A(e3);
    }
  }
  function Fc(e3) {
    switch ((e3 = o2.unwrapTSNode(e3)).type) {
      case "UnaryExpression":
        return Fc(e3.argument);
      case "LogicalExpression":
      case "BinaryExpression":
        return Fc(e3.left) && Fc(e3.right);
      case "ConditionalExpression":
        return Fc(e3.test) && Fc(e3.consequent) && Fc(e3.alternate);
      case "SequenceExpression":
      case "TemplateLiteral":
        return e3.expressions.every((e4) => Fc(e4));
      case "ParenthesizedExpression":
        return Fc(e3.expression);
      case "StringLiteral":
      case "NumericLiteral":
      case "BooleanLiteral":
      case "NullLiteral":
      case "BigIntLiteral":
        return true;
    }
    return false;
  }
  const Uc = ge, $c = { ...o2.errorMessages, ...o2.DOMErrorMessages }, Vc = m.walk;
  t2.extractIdentifiers = i2.extractIdentifiers, t2.generateCodeFrame = i2.generateCodeFrame, t2.isInDestructureAssignment = i2.isInDestructureAssignment, t2.isStaticProperty = i2.isStaticProperty, t2.walkIdentifiers = i2.walkIdentifiers, t2.MagicString = y, t2.babelParse = g.parse, t2.compileScript = function(e3, t3) {
    var r3;
    t3.id || qe("compileScript now requires passing the `id` option.\nUpgrade your vite or vue-loader version for compatibility with the latest experimental proposals.");
    const n3 = new ha(e3, t3), { script: s3, scriptSetup: i3, source: a3, filename: l2 } = e3, u2 = false !== t3.hoistStatic && !s3, p2 = t3.id ? t3.id.replace(/^data-v-/, "") : "", d2 = s3 && s3.lang, f2 = i3 && i3.lang;
    if (!i3) {
      if (!s3) throw new Error("[@vue/compiler-sfc] SFC contains no <script> tags.");
      return function(e4, t4) {
        var r4;
        const n4 = e4.descriptor.script;
        if (n4.lang && !e4.isJS && !e4.isTS) return n4;
        try {
          let s4 = n4.content, i4 = n4.map;
          const o3 = e4.scriptAst, a4 = ua(o3.body), { cssVars: l3 } = e4.descriptor, { genDefaultAs: c2, isProd: u3 } = e4.options;
          if (l3.length || c2) {
            const n5 = c2 || ba, i5 = new y(s4);
            ya(o3.body, i5, n5), s4 = i5.toString(), l3.length && !(null == (r4 = e4.options.templateOptions) ? void 0 : r4.ssr) && (s4 += function(e5, t5, r5, n6, s5) {
              return `
import { ${z} as _${z} } from 'vue'
const __injectCSSVars__ = () => {
${ee(e5, t5, r5, n6)}}
const __setup__ = ${s5}.setup
${s5}.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
`;
            }(l3, a4, t4, !!u3, n5)), c2 || (s4 += `
export default ${n5}`);
          }
          return { ...n4, content: s4, map: i4, bindings: a4, scriptAst: o3.body };
        } catch (e5) {
          return n4;
        }
      }(n3, p2);
    }
    if (s3 && d2 !== f2) throw new Error("[@vue/compiler-sfc] <script> and <script setup> must have the same language type.");
    if (f2 && !n3.isJS && !n3.isTS) return i3;
    const h2 = /* @__PURE__ */ Object.create(null), g2 = /* @__PURE__ */ Object.create(null);
    let b2, v2 = false, E2 = false;
    const S2 = n3.startOffset, x2 = n3.endOffset, w2 = s3 && s3.loc.start.offset, A2 = s3 && s3.loc.end.offset;
    function _2(e4) {
      const t4 = e4.start + S2;
      let r4 = e4.end + S2;
      for (e4.trailingComments && e4.trailingComments.length > 0 && (r4 = e4.trailingComments[e4.trailingComments.length - 1].end + S2); r4 <= a3.length && /\s/.test(a3.charAt(r4)); ) r4++;
      n3.s.move(t4, r4, 0);
    }
    function k2(t4, r4, s4, i4, o3, a4) {
      let l3 = a4;
      a4 && n3.isTS && e3.template && !e3.template.src && !e3.template.lang && (l3 = fe(r4, e3)), n3.userImports[r4] = { isType: i4, imported: s4, local: r4, source: t4, isFromSetup: o3, isUsedInTemplate: l3 };
    }
    function N2(e4, t4) {
      e4 && o2.walkIdentifiers(e4, (e5) => {
        const r4 = g2[e5.name];
        r4 && "literal-const" !== r4 && n3.error(`\`${t4}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function. If your component options require initialization in the module scope, use a separate normal <script> to export the options instead.`, e5);
      });
    }
    const D2 = n3.scriptAst, j2 = n3.scriptSetupAst;
    if (D2) {
      for (const e4 of D2.body) if ("ImportDeclaration" === e4.type) for (const r4 of e4.specifiers) {
        const n4 = I(r4);
        k2(e4.source.value, r4.local.name, n4, "type" === e4.importKind || "ImportSpecifier" === r4.type && "type" === r4.importKind, false, !t3.inlineTemplate);
      }
    }
    for (const e4 of j2.body) if ("ImportDeclaration" === e4.type) {
      _2(e4);
      let r4 = 0;
      const s4 = (t4) => {
        const s5 = t4 > r4;
        r4++;
        const i4 = e4.specifiers[t4], o3 = e4.specifiers[t4 + 1];
        n3.s.remove(s5 ? e4.specifiers[t4 - 1].end + S2 : i4.start + S2, o3 && !s5 ? o3.start + S2 : i4.end + S2);
      };
      for (let r5 = 0; r5 < e4.specifiers.length; r5++) {
        const i4 = e4.specifiers[r5], o3 = i4.local.name, a4 = I(i4), l3 = e4.source.value, c2 = n3.userImports[o3];
        "vue" !== l3 || a4 !== yc && a4 !== xc && a4 !== Ac ? c2 ? c2.source === l3 && c2.imported === a4 ? s4(r5) : n3.error("different imports aliased to same local name.", i4) : k2(l3, o3, a4, "type" === e4.importKind || "ImportSpecifier" === i4.type && "type" === i4.importKind, true, !t3.inlineTemplate) : (qe(`\`${a4}\` is a compiler macro and no longer needs to be imported.`), s4(r5));
      }
      e4.specifiers.length && r4 === e4.specifiers.length && n3.s.remove(e4.start + S2, e4.end + S2);
    }
    const L2 = {};
    for (const e4 in n3.userImports) {
      const { source: t4, imported: r4, local: s4 } = n3.userImports[e4];
      "vue" === t4 && (L2[r4] = s4);
    }
    if (s3 && D2) {
      for (const e4 of D2.body) if ("ExportDefaultDeclaration" === e4.type) {
        let t4;
        if (b2 = e4, "ObjectExpression" === b2.declaration.type ? t4 = b2.declaration.properties : "CallExpression" === b2.declaration.type && b2.declaration.arguments[0] && "ObjectExpression" === b2.declaration.arguments[0].type && (t4 = b2.declaration.arguments[0].properties), t4) for (const e5 of t4) "ObjectProperty" === e5.type && "Identifier" === e5.key.type && "name" === e5.key.name && (n3.hasDefaultExportName = true), "ObjectMethod" !== e5.type && "ObjectProperty" !== e5.type || "Identifier" !== e5.key.type || "render" !== e5.key.name || (n3.hasDefaultExportRender = true);
        const r4 = e4.start + w2, s4 = e4.declaration.start + w2;
        n3.s.overwrite(r4, s4, `const ${ba} = `);
      } else if ("ExportNamedDeclaration" === e4.type) {
        const t4 = e4.specifiers.find((e5) => "Identifier" === e5.exported.type && "default" === e5.exported.name);
        t4 && (b2 = e4, e4.specifiers.length > 1 ? n3.s.remove(t4.start + w2, t4.end + w2) : n3.s.remove(e4.start + w2, e4.end + w2), e4.source ? n3.s.prepend(`import { ${t4.local.name} as ${ba} } from '${e4.source.value}'
`) : n3.s.appendLeft(A2, `
const ${ba} = ${t4.local.name}
`)), e4.declaration && jc("script", e4.declaration, h2, L2, u2);
      } else "VariableDeclaration" !== e4.type && "FunctionDeclaration" !== e4.type && "ClassDeclaration" !== e4.type && "TSEnumDeclaration" !== e4.type || e4.declare || jc("script", e4, h2, L2, u2);
      w2 > S2 && (/\n$/.test(s3.content.trim()) || n3.s.appendLeft(A2, "\n"), n3.s.move(w2, A2, 0));
    }
    for (const e4 of j2.body) {
      if ("ExpressionStatement" === e4.type) {
        const t5 = o2.unwrapTSNode(e4.expression);
        if (bc(n3, t5) || Tc(n3, t5) || kc(n3, t5) || Ic(n3, t5)) n3.s.remove(e4.start + S2, e4.end + S2);
        else if (Cc(n3, t5)) {
          const e5 = t5.callee;
          n3.s.overwrite(e5.start + S2, e5.end + S2, "__expose");
        } else mc(n3, t5);
      }
      if ("VariableDeclaration" === e4.type && !e4.declare) {
        const t5 = e4.declarations.length;
        let r4, s4 = t5;
        for (let i4 = 0; i4 < t5; i4++) {
          const a4 = e4.declarations[i4], l3 = a4.init && o2.unwrapTSNode(a4.init);
          if (l3) {
            kc(n3, l3) && n3.error(`${_c}() has no returning value, it cannot be assigned.`, e4);
            const o3 = bc(n3, l3, a4.id), c2 = !o3 && Tc(n3, l3, a4.id);
            if (!c2 && (Ic(n3, l3, a4.id) || mc(n3, l3, a4.id)), o3 && !n3.propsDestructureRestId && n3.propsDestructureDecl) if (1 === s4) n3.s.remove(e4.start + S2, e4.end + S2);
            else {
              let o4 = a4.start + S2, l4 = a4.end + S2;
              i4 === t5 - 1 ? o4 = e4.declarations[r4].end + S2 : l4 = e4.declarations[i4 + 1].start + S2, n3.s.remove(o4, l4), s4--;
            }
            else c2 ? n3.s.overwrite(S2 + l3.start, S2 + l3.end, "__emit") : r4 = i4;
          }
        }
      }
      let t4 = false;
      if ("VariableDeclaration" !== e4.type && "FunctionDeclaration" !== e4.type && "ClassDeclaration" !== e4.type && "TSEnumDeclaration" !== e4.type || e4.declare || (t4 = jc("scriptSetup", e4, g2, L2, u2)), u2 && t4 && _2(e4), "VariableDeclaration" === e4.type && !e4.declare || e4.type.endsWith("Statement")) {
        const t5 = [j2.body];
        m.walk(e4, { enter(e5, r4) {
          if (o2.isFunctionType(e5) && this.skip(), "BlockStatement" === e5.type && t5.push(e5.body), "AwaitExpression" === e5.type) {
            v2 = true;
            const s4 = t5[t5.length - 1].some((r5, n4) => (1 === t5.length || n4 > 0) && "ExpressionStatement" === r5.type && r5.start === e5.start);
            Nc(n3, e5, s4, "ExpressionStatement" === r4.type);
          }
        }, exit(e5) {
          "BlockStatement" === e5.type && t5.pop();
        } });
      }
      ("ExportNamedDeclaration" === e4.type && "type" !== e4.exportKind || "ExportAllDeclaration" === e4.type || "ExportDefaultDeclaration" === e4.type) && n3.error("<script setup> cannot contain ES module exports. If you are using a previous version of <script setup>, please consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.", e4), n3.isTS && (e4.type.startsWith("TS") || "ExportNamedDeclaration" === e4.type && "type" === e4.exportKind || "VariableDeclaration" === e4.type && e4.declare) && "TSEnumDeclaration" !== e4.type && _2(e4);
    }
    n3.propsDestructureDecl && function(e4, t4) {
      if (!e4.options.propsDestructure) return;
      const r4 = {}, n4 = [r4];
      let s4 = r4;
      const i4 = /* @__PURE__ */ new WeakSet(), a4 = [], l3 = /* @__PURE__ */ Object.create(null);
      for (const t5 in e4.propsDestructuredBindings) {
        const { local: n5 } = e4.propsDestructuredBindings[t5];
        r4[n5] = true, l3[n5] = t5;
      }
      function u3() {
        n4.push(s4 = Object.create(s4));
      }
      function p3(t5) {
        i4.add(t5), s4 ? s4[t5.name] = false : e4.error("registerBinding called without active scope, something is wrong.", t5);
      }
      function d3(e5) {
        let t5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        for (const r5 of e5.body) if ("VariableDeclaration" === r5.type) f3(r5, t5);
        else if ("FunctionDeclaration" === r5.type || "ClassDeclaration" === r5.type) {
          if (r5.declare || !r5.id) continue;
          p3(r5.id);
        } else "ForOfStatement" !== r5.type && "ForInStatement" !== r5.type || "VariableDeclaration" !== r5.left.type ? "ExportNamedDeclaration" === r5.type && r5.declaration && "VariableDeclaration" === r5.declaration.type ? f3(r5.declaration, t5) : "LabeledStatement" === r5.type && "VariableDeclaration" === r5.body.type && f3(r5.body, t5) : f3(r5.left);
      }
      function f3(e5) {
        let t5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (!e5.declare) for (const r5 of e5.declarations) {
          const e6 = t5 && r5.init && C(o2.unwrapTSNode(r5.init), "defineProps");
          for (const t6 of o2.extractIdentifiers(r5.id)) e6 ? i4.add(t6) : p3(t6);
        }
      }
      function h3(t5, r5) {
        if (C(t5, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : r5)) {
          const n5 = o2.unwrapTSNode(t5.arguments[0]);
          "Identifier" === n5.type && s4[n5.name] && e4.error(`"${n5.name}" is a destructured prop and should not be passed directly to ${r5}(). Pass a getter () => ${n5.name} instead.`, n5);
        }
      }
      const y2 = e4.scriptSetupAst;
      d3(y2, true), m.walk(y2, { enter(r5, n5) {
        return n5 && a4.push(n5), n5 && n5.type.startsWith("TS") && "TSAsExpression" !== n5.type && "TSNonNullExpression" !== n5.type && "TSTypeAssertion" !== n5.type ? this.skip() : (h3(r5, "watch", t4.watch), h3(r5, "toRef", t4.toRef), o2.isFunctionType(r5) ? (u3(), o2.walkFunctionParams(r5, p3), void ("BlockStatement" === r5.body.type && d3(r5.body))) : "CatchClause" === r5.type ? (u3(), r5.param && "Identifier" === r5.param.type && p3(r5.param), void d3(r5.body)) : "BlockStatement" !== r5.type || o2.isFunctionType(n5) ? void ("Identifier" === r5.type && o2.isReferencedIdentifier(r5, n5, a4) && !i4.has(r5) && s4[r5.name] && function(t5, r6, n6) {
          ("AssignmentExpression" === r6.type && t5 === r6.left || "UpdateExpression" === r6.type) && e4.error("Cannot assign to destructured props as they are readonly.", t5), o2.isStaticProperty(r6) && r6.shorthand ? r6.inPattern && !o2.isInDestructureAssignment(r6, n6) || e4.s.appendLeft(t5.end + e4.startOffset, `: ${c.genPropsAccessExp(l3[t5.name])}`) : e4.s.overwrite(t5.start + e4.startOffset, t5.end + e4.startOffset, c.genPropsAccessExp(l3[t5.name]));
        }(r5, n5, a4)) : (u3(), void d3(r5)));
      }, leave(e5, t5) {
        t5 && a4.pop(), ("BlockStatement" === e5.type && !o2.isFunctionType(t5) || o2.isFunctionType(e5)) && (n4.pop(), s4 = n4[n4.length - 1] || null);
      } });
    }(n3, L2), N2(n3.propsRuntimeDecl, yc), N2(n3.propsRuntimeDefaults, yc), N2(n3.propsDestructureDecl, yc), N2(n3.emitsRuntimeDecl, xc), N2(n3.optionsRuntimeDecl, _c);
    for (const { runtimeOptionNodes: e4 } of Object.values(n3.modelDecls)) for (const t4 of e4) N2(t4, hc);
    s3 ? S2 < w2 ? (n3.s.remove(0, S2), n3.s.remove(x2, w2), n3.s.remove(A2, a3.length)) : (n3.s.remove(0, w2), n3.s.remove(A2, S2), n3.s.remove(x2, a3.length)) : (n3.s.remove(0, S2), n3.s.remove(x2, a3.length)), D2 && Object.assign(n3.bindingMetadata, ua(D2.body));
    for (const [e4, { isType: t4, imported: r4, source: s4 }] of Object.entries(n3.userImports)) t4 || (n3.bindingMetadata[e4] = "*" === r4 || "default" === r4 && s4.endsWith(".vue") || "vue" === s4 ? "setup-const" : "setup-maybe-ref");
    for (const e4 in h2) n3.bindingMetadata[e4] = h2[e4];
    for (const e4 in g2) n3.bindingMetadata[e4] = g2[e4];
    e3.cssVars.length && !(null == (r3 = t3.templateOptions) ? void 0 : r3.ssr) && (n3.helperImports.add(z), n3.helperImports.add("unref"), n3.s.prependLeft(S2, `
${ee(e3.cssVars, n3.bindingMetadata, p2, !!t3.isProd)}
`));
    let M2 = "__props";
    if (n3.propsTypeDecl && (M2 += ": any"), n3.propsDecl && (n3.propsDestructureRestId ? (n3.s.overwrite(S2 + n3.propsCall.start, S2 + n3.propsCall.end, `${n3.helper("createPropsRestProxy")}(__props, ${JSON.stringify(Object.keys(n3.propsDestructuredBindings))})`), n3.s.overwrite(S2 + n3.propsDestructureDecl.start, S2 + n3.propsDestructureDecl.end, n3.propsDestructureRestId)) : n3.propsDestructureDecl || n3.s.overwrite(S2 + n3.propsCall.start, S2 + n3.propsCall.end, "__props")), v2) {
      const e4 = n3.isTS ? ": any" : "";
      n3.s.prependLeft(S2, `
let __temp${e4}, __restore${e4}
`);
    }
    const B2 = n3.hasDefineExposeCall || !t3.inlineTemplate ? ["expose: __expose"] : [];
    let R2;
    if (n3.emitDecl && B2.push("emit: __emit"), B2.length && (M2 += `, { ${B2.join(", ")} }`), !t3.inlineTemplate || !e3.template && n3.hasDefaultExportRender) {
      const e4 = { ...h2, ...g2 };
      for (const t4 in n3.userImports) !n3.userImports[t4].isType && n3.userImports[t4].isUsedInTemplate && (e4[t4] = true);
      R2 = "{ ";
      for (const t4 in e4) if (true !== e4[t4] || "vue" === n3.userImports[t4].source || n3.userImports[t4].source.endsWith(".vue")) if ("setup-let" === n3.bindingMetadata[t4]) {
        const e5 = "v" === t4 ? "_v" : "v";
        R2 += `get ${t4}() { return ${t4} }, set ${t4}(${e5}) { ${t4} = ${e5} }, `;
      } else R2 += `${t4}, `;
      else R2 += `get ${t4}() { return ${t4} }, `;
      R2 = R2.replace(/, $/, "") + " }";
    } else if (e3.template && !e3.template.src) {
      t3.templateOptions && t3.templateOptions.ssr && (E2 = true);
      const { code: r4, ast: s4, preamble: i4, tips: u3, errors: d3 } = Ge({ filename: l2, ast: e3.template.ast, source: e3.template.content, inMap: e3.template.map, ...t3.templateOptions, id: p2, scoped: e3.styles.some((e4) => e4.scoped), isProd: t3.isProd, ssrCssVars: e3.cssVars, compilerOptions: { ...t3.templateOptions && t3.templateOptions.compilerOptions, inline: true, isTS: n3.isTS, bindingMetadata: n3.bindingMetadata } });
      u3.length && u3.forEach(qe);
      const f3 = d3[0];
      if ("string" == typeof f3) throw new Error(f3);
      if (f3) throw f3.loc && (f3.message += "\n\n" + e3.filename + "\n" + c.generateCodeFrame(a3, f3.loc.start.offset, f3.loc.end.offset) + "\n"), f3;
      i4 && n3.s.prepend(i4), s4 && s4.helpers.has(o2.UNREF) && n3.helperImports.delete("unref"), R2 = r4;
    } else R2 = "() => {}";
    t3.inlineTemplate ? n3.s.appendRight(x2, `
return ${R2}
}

`) : n3.s.appendRight(x2, `
const __returned__ = ${R2}
Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })
return __returned__
}

`);
    const F2 = t3.genDefaultAs ? `const ${t3.genDefaultAs} =` : "export default";
    let $2 = "";
    if (!n3.hasDefaultExportName && l2 && l2 !== ye) {
      const e4 = l2.match(/([^/\\]+)\.\w+$/);
      e4 && ($2 += `
  __name: '${e4[1]}',`);
    }
    E2 && ($2 += "\n  __ssrInlineRender: true,");
    const V2 = function(e4) {
      let t4;
      if (e4.propsRuntimeDecl) {
        if (t4 = e4.getString(e4.propsRuntimeDecl).trim(), e4.propsDestructureDecl) {
          const r5 = [];
          for (const t5 in e4.propsDestructuredBindings) {
            const n4 = Sc(e4, t5), s4 = U(t5);
            n4 && r5.push(`${s4}: ${n4.valueString}${n4.needSkipFactory ? `, __skip_${s4}: true` : ""}`);
          }
          r5.length && (t4 = `/*#__PURE__*/${e4.helper("mergeDefaults")}(${t4}, {
  ${r5.join(",\n  ")}
})`);
        }
      } else e4.propsTypeDecl && (t4 = vc(e4));
      const r4 = function(e5) {
        if (!e5.hasDefineModelCall) return;
        const t5 = !!e5.options.isProd;
        let r5 = "";
        for (const [n4, { type: s4, options: i4 }] of Object.entries(e5.modelDecls)) {
          let o3 = false, a4 = s4 && lc(e5, s4);
          if (a4) {
            const e6 = a4.includes(T);
            a4 = a4.filter((e7) => e7 !== T && (!t5 || "Boolean" === e7 || "Function" === e7 && i4)), o3 = !t5 && e6 && a4.length > 0;
          }
          let l3 = a4 && a4.length > 0 && O(a4) || void 0;
          const c2 = P([l3 && `type: ${l3}`, o3 && "skipCheck: true"]);
          let u3;
          u3 = l3 && i4 ? e5.isTS ? `{ ${c2}, ...${i4} }` : `Object.assign({ ${c2} }, ${i4})` : i4 || (l3 ? `{ ${c2} }` : "{}"), r5 += `
    ${JSON.stringify(n4)}: ${u3},`, r5 += `
    ${JSON.stringify("modelValue" === n4 ? "modelModifiers" : `${n4}Modifiers`)}: {},`;
        }
        return `{${r5}
  }`;
      }(e4);
      return t4 && r4 ? `/*#__PURE__*/${e4.helper("mergeModels")}(${t4}, ${r4})` : r4 || t4;
    }(n3);
    V2 && ($2 += `
  props: ${V2},`);
    const q2 = function(e4) {
      let t4 = "";
      if (e4.emitsRuntimeDecl) t4 = e4.getString(e4.emitsRuntimeDecl).trim();
      else if (e4.emitsTypeDecl) {
        const r4 = wc(e4);
        t4 = r4.size ? `[${Array.from(r4).map((e5) => JSON.stringify(e5)).join(", ")}]` : "";
      }
      if (e4.hasDefineModelCall) {
        let r4 = `[${Object.keys(e4.modelDecls).map((e5) => JSON.stringify(`update:${e5}`)).join(", ")}]`;
        t4 = t4 ? `/*#__PURE__*/${e4.helper("mergeModels")}(${t4}, ${r4})` : r4;
      }
      return t4;
    }(n3);
    q2 && ($2 += `
  emits: ${q2},`);
    let W2 = "";
    n3.optionsRuntimeDecl && (W2 = i3.content.slice(n3.optionsRuntimeDecl.start, n3.optionsRuntimeDecl.end).trim());
    const G2 = n3.hasDefineExposeCall || t3.inlineTemplate ? "" : "  __expose();\n";
    if (n3.isTS) {
      const e4 = (b2 ? `
  ...${ba},` : "") + (W2 ? `
  ...${W2},` : "");
      n3.s.prependLeft(S2, `
${F2} /*#__PURE__*/${n3.helper("defineComponent")}({${e4}${$2}
  ${v2 ? "async " : ""}setup(${M2}) {
${G2}`), n3.s.appendRight(x2, "})");
    } else b2 || W2 ? (n3.s.prependLeft(S2, `
${F2} /*#__PURE__*/Object.assign(${b2 ? `${ba}, ` : ""}${W2 ? `${W2}, ` : ""}{${$2}
  ${v2 ? "async " : ""}setup(${M2}) {
${G2}`), n3.s.appendRight(x2, "})")) : (n3.s.prependLeft(S2, `
${F2} {${$2}
  ${v2 ? "async " : ""}setup(${M2}) {
${G2}`), n3.s.appendRight(x2, "}"));
    return n3.helperImports.size > 0 && n3.s.prepend(`import { ${[...n3.helperImports].map((e4) => `${e4} as _${e4}`).join(", ")} } from 'vue'
`), { ...i3, bindings: n3.bindingMetadata, imports: n3.userImports, content: n3.s.toString(), map: false !== t3.sourceMap ? n3.s.generateMap({ source: l2, hires: true, includeContent: true }) : void 0, scriptAst: null == D2 ? void 0 : D2.body, scriptSetupAst: null == j2 ? void 0 : j2.body, deps: n3.deps ? [...n3.deps] : void 0 };
  }, t2.compileStyle = function(e3) {
    return ca({ ...e3, isAsync: false });
  }, t2.compileStyleAsync = function(e3) {
    return ca({ ...e3, isAsync: true });
  }, t2.compileTemplate = Ge, t2.errorMessages = $c, t2.extractRuntimeEmits = wc, t2.extractRuntimeProps = vc, t2.inferRuntimeType = lc, t2.invalidateTypeCache = function(e3) {
    e3 = B(e3), Yl.delete(e3), Kl.delete(e3);
    const t3 = Xl.get(e3);
    t3 && Kl.delete(t3);
  }, t2.parse = be, t2.parseCache = Uc, t2.registerTS = function(e3) {
    Wl = () => {
      try {
        return e3();
      } catch (e4) {
        throw "string" == typeof e4.message && e4.message.includes("Cannot find module") ? new Error('Failed to load TypeScript, which is required for resolving imported types. Please make sure "typescript" is installed as a project dependency.') : new Error("Failed to load TypeScript for resolving imported types.");
      }
    };
  }, t2.resolveTypeElements = _l, t2.rewriteDefault = function(e3, t3, r3) {
    const n3 = g.parse(e3, { sourceType: "module", plugins: ma("js", r3) }).program.body, s3 = new y(e3);
    return ya(n3, s3, t3), s3.toString();
  }, t2.rewriteDefaultAST = ya, t2.shouldTransformRef = () => false, t2.version = "3.4.15", t2.walk = Vc;
}, (e2, t2, r2) => {
  e2.exports = r2(502);
}, (e2, t2, r2) => {
  var n2 = r2(311), s2 = r2(314), i2 = r2(86);
  e2.exports = { formats: i2, parse: s2, stringify: n2 };
}, (e2, t2, r2) => {
  var n2 = r2(312), s2 = r2(144), i2 = r2(86), o2 = Object.prototype.hasOwnProperty, a2 = { brackets: function(e3) {
    return e3 + "[]";
  }, comma: "comma", indices: function(e3, t3) {
    return e3 + "[" + t3 + "]";
  }, repeat: function(e3) {
    return e3;
  } }, l = Array.isArray, c = Array.prototype.push, u = function(e3, t3) {
    c.apply(e3, l(t3) ? t3 : [t3]);
  }, p = Date.prototype.toISOString, d = i2.default, f = { addQueryPrefix: false, allowDots: false, charset: "utf-8", charsetSentinel: false, delimiter: "&", encode: true, encoder: s2.encode, encodeValuesOnly: false, format: d, formatter: i2.formatters[d], indices: false, serializeDate: function(e3) {
    return p.call(e3);
  }, skipNulls: false, strictNullHandling: false }, h = {}, m = function e3(t3, r3, i3, o3, a3, c2, p2, d2, m2, y, g, b, v, E, S, x) {
    for (var T, w = t3, P = x, A = 0, C = false; void 0 !== (P = P.get(h)) && !C; ) {
      var O = P.get(t3);
      if (A += 1, void 0 !== O) {
        if (O === A) throw new RangeError("Cyclic object value");
        C = true;
      }
      void 0 === P.get(h) && (A = 0);
    }
    if ("function" == typeof d2 ? w = d2(r3, w) : w instanceof Date ? w = g(w) : "comma" === i3 && l(w) && (w = s2.maybeMap(w, function(e4) {
      return e4 instanceof Date ? g(e4) : e4;
    })), null === w) {
      if (a3) return p2 && !E ? p2(r3, f.encoder, S, "key", b) : r3;
      w = "";
    }
    if ("string" == typeof (T = w) || "number" == typeof T || "boolean" == typeof T || "symbol" == typeof T || "bigint" == typeof T || s2.isBuffer(w)) return p2 ? [v(E ? r3 : p2(r3, f.encoder, S, "key", b)) + "=" + v(p2(w, f.encoder, S, "value", b))] : [v(r3) + "=" + v(String(w))];
    var I, _ = [];
    if (void 0 === w) return _;
    if ("comma" === i3 && l(w)) E && p2 && (w = s2.maybeMap(w, p2)), I = [{ value: w.length > 0 ? w.join(",") || null : void 0 }];
    else if (l(d2)) I = d2;
    else {
      var k = Object.keys(w);
      I = m2 ? k.sort(m2) : k;
    }
    for (var N = o3 && l(w) && 1 === w.length ? r3 + "[]" : r3, D = 0; D < I.length; ++D) {
      var j = I[D], L = "object" == typeof j && void 0 !== j.value ? j.value : w[j];
      if (!c2 || null !== L) {
        var M = l(w) ? "function" == typeof i3 ? i3(N, j) : N : N + (y ? "." + j : "[" + j + "]");
        x.set(t3, A);
        var B = n2();
        B.set(h, x), u(_, e3(L, M, i3, o3, a3, c2, "comma" === i3 && E && l(w) ? null : p2, d2, m2, y, g, b, v, E, S, B));
      }
    }
    return _;
  };
  e2.exports = function(e3, t3) {
    var r3, s3 = e3, c2 = function(e4) {
      if (!e4) return f;
      if (null !== e4.encoder && void 0 !== e4.encoder && "function" != typeof e4.encoder) throw new TypeError("Encoder has to be a function.");
      var t4 = e4.charset || f.charset;
      if (void 0 !== e4.charset && "utf-8" !== e4.charset && "iso-8859-1" !== e4.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      var r4 = i2.default;
      if (void 0 !== e4.format) {
        if (!o2.call(i2.formatters, e4.format)) throw new TypeError("Unknown format option provided.");
        r4 = e4.format;
      }
      var n3 = i2.formatters[r4], s4 = f.filter;
      return ("function" == typeof e4.filter || l(e4.filter)) && (s4 = e4.filter), { addQueryPrefix: "boolean" == typeof e4.addQueryPrefix ? e4.addQueryPrefix : f.addQueryPrefix, allowDots: void 0 === e4.allowDots ? f.allowDots : !!e4.allowDots, charset: t4, charsetSentinel: "boolean" == typeof e4.charsetSentinel ? e4.charsetSentinel : f.charsetSentinel, delimiter: void 0 === e4.delimiter ? f.delimiter : e4.delimiter, encode: "boolean" == typeof e4.encode ? e4.encode : f.encode, encoder: "function" == typeof e4.encoder ? e4.encoder : f.encoder, encodeValuesOnly: "boolean" == typeof e4.encodeValuesOnly ? e4.encodeValuesOnly : f.encodeValuesOnly, filter: s4, format: r4, formatter: n3, serializeDate: "function" == typeof e4.serializeDate ? e4.serializeDate : f.serializeDate, skipNulls: "boolean" == typeof e4.skipNulls ? e4.skipNulls : f.skipNulls, sort: "function" == typeof e4.sort ? e4.sort : null, strictNullHandling: "boolean" == typeof e4.strictNullHandling ? e4.strictNullHandling : f.strictNullHandling };
    }(t3);
    "function" == typeof c2.filter ? s3 = (0, c2.filter)("", s3) : l(c2.filter) && (r3 = c2.filter);
    var p2, d2 = [];
    if ("object" != typeof s3 || null === s3) return "";
    p2 = t3 && t3.arrayFormat in a2 ? t3.arrayFormat : t3 && "indices" in t3 ? t3.indices ? "indices" : "repeat" : "indices";
    var h2 = a2[p2];
    if (t3 && "commaRoundTrip" in t3 && "boolean" != typeof t3.commaRoundTrip) throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var y = "comma" === h2 && t3 && t3.commaRoundTrip;
    r3 || (r3 = Object.keys(s3)), c2.sort && r3.sort(c2.sort);
    for (var g = n2(), b = 0; b < r3.length; ++b) {
      var v = r3[b];
      c2.skipNulls && null === s3[v] || u(d2, m(s3[v], v, h2, y, c2.strictNullHandling, c2.skipNulls, c2.encode ? c2.encoder : null, c2.filter, c2.sort, c2.allowDots, c2.serializeDate, c2.format, c2.formatter, c2.encodeValuesOnly, c2.charset, g));
    }
    var E = d2.join(c2.delimiter), S = true === c2.addQueryPrefix ? "?" : "";
    return c2.charsetSentinel && ("iso-8859-1" === c2.charset ? S += "utf8=%26%2310003%3B&" : S += "utf8=%E2%9C%93&"), E.length > 0 ? S + E : "";
  };
}, (e2, t2, r2) => {
  var n2 = r2(22), s2 = r2(38), i2 = r2(313), o2 = n2("%TypeError%"), a2 = n2("%WeakMap%", true), l = n2("%Map%", true), c = s2("WeakMap.prototype.get", true), u = s2("WeakMap.prototype.set", true), p = s2("WeakMap.prototype.has", true), d = s2("Map.prototype.get", true), f = s2("Map.prototype.set", true), h = s2("Map.prototype.has", true), m = function(e3, t3) {
    for (var r3, n3 = e3; null !== (r3 = n3.next); n3 = r3) if (r3.key === t3) return n3.next = r3.next, r3.next = e3.next, e3.next = r3, r3;
  };
  e2.exports = function() {
    var e3, t3, r3, n3 = { assert: function(e4) {
      if (!n3.has(e4)) throw new o2("Side channel does not contain " + i2(e4));
    }, get: function(n4) {
      if (a2 && n4 && ("object" == typeof n4 || "function" == typeof n4)) {
        if (e3) return c(e3, n4);
      } else if (l) {
        if (t3) return d(t3, n4);
      } else if (r3) return function(e4, t4) {
        var r4 = m(e4, t4);
        return r4 && r4.value;
      }(r3, n4);
    }, has: function(n4) {
      if (a2 && n4 && ("object" == typeof n4 || "function" == typeof n4)) {
        if (e3) return p(e3, n4);
      } else if (l) {
        if (t3) return h(t3, n4);
      } else if (r3) return function(e4, t4) {
        return !!m(e4, t4);
      }(r3, n4);
      return false;
    }, set: function(n4, s3) {
      a2 && n4 && ("object" == typeof n4 || "function" == typeof n4) ? (e3 || (e3 = new a2()), u(e3, n4, s3)) : l ? (t3 || (t3 = new l()), f(t3, n4, s3)) : (r3 || (r3 = { key: {}, next: null }), function(e4, t4, r4) {
        var n5 = m(e4, t4);
        n5 ? n5.value = r4 : e4.next = { key: t4, next: e4.next, value: r4 };
      }(r3, n4, s3));
    } };
    return n3;
  };
}, (e2, t2, r2) => {
  var n2 = "function" == typeof Map && Map.prototype, s2 = Object.getOwnPropertyDescriptor && n2 ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, i2 = n2 && s2 && "function" == typeof s2.get ? s2.get : null, o2 = n2 && Map.prototype.forEach, a2 = "function" == typeof Set && Set.prototype, l = Object.getOwnPropertyDescriptor && a2 ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, c = a2 && l && "function" == typeof l.get ? l.get : null, u = a2 && Set.prototype.forEach, p = "function" == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null, d = "function" == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null, f = "function" == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null, h = Boolean.prototype.valueOf, m = Object.prototype.toString, y = Function.prototype.toString, g = String.prototype.match, b = String.prototype.slice, v = String.prototype.replace, E = String.prototype.toUpperCase, S = String.prototype.toLowerCase, x = RegExp.prototype.test, T = Array.prototype.concat, w = Array.prototype.join, P = Array.prototype.slice, A = Math.floor, C = "function" == typeof BigInt ? BigInt.prototype.valueOf : null, O = Object.getOwnPropertySymbols, I = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol.prototype.toString : null, _ = "function" == typeof Symbol && "object" == typeof Symbol.iterator, k = "function" == typeof Symbol && Symbol.toStringTag && (Symbol.toStringTag, 1) ? Symbol.toStringTag : null, N = Object.prototype.propertyIsEnumerable, D = ("function" == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e3) {
    return e3.__proto__;
  } : null);
  function j(e3, t3) {
    if (e3 === 1 / 0 || e3 === -1 / 0 || e3 != e3 || e3 && e3 > -1e3 && e3 < 1e3 || x.call(/e/, t3)) return t3;
    var r3 = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if ("number" == typeof e3) {
      var n3 = e3 < 0 ? -A(-e3) : A(e3);
      if (n3 !== e3) {
        var s3 = String(n3), i3 = b.call(t3, s3.length + 1);
        return v.call(s3, r3, "$&_") + "." + v.call(v.call(i3, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return v.call(t3, r3, "$&_");
  }
  var L = r2(509), M = L.custom, B = V(M) ? M : null;
  function R(e3, t3, r3) {
    var n3 = "double" === (r3.quoteStyle || t3) ? '"' : "'";
    return n3 + e3 + n3;
  }
  function F(e3) {
    return v.call(String(e3), /"/g, "&quot;");
  }
  function U(e3) {
    return !("[object Array]" !== G(e3) || k && "object" == typeof e3 && k in e3);
  }
  function $(e3) {
    return !("[object RegExp]" !== G(e3) || k && "object" == typeof e3 && k in e3);
  }
  function V(e3) {
    if (_) return e3 && "object" == typeof e3 && e3 instanceof Symbol;
    if ("symbol" == typeof e3) return true;
    if (!e3 || "object" != typeof e3 || !I) return false;
    try {
      return I.call(e3), true;
    } catch (e4) {
    }
    return false;
  }
  e2.exports = function e3(t3, n3, s3, a3) {
    var l2 = n3 || {};
    if (W(l2, "quoteStyle") && "single" !== l2.quoteStyle && "double" !== l2.quoteStyle) throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (W(l2, "maxStringLength") && ("number" == typeof l2.maxStringLength ? l2.maxStringLength < 0 && l2.maxStringLength !== 1 / 0 : null !== l2.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var m2 = !W(l2, "customInspect") || l2.customInspect;
    if ("boolean" != typeof m2 && "symbol" !== m2) throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (W(l2, "indent") && null !== l2.indent && "	" !== l2.indent && !(parseInt(l2.indent, 10) === l2.indent && l2.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (W(l2, "numericSeparator") && "boolean" != typeof l2.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var E2 = l2.numericSeparator;
    if (void 0 === t3) return "undefined";
    if (null === t3) return "null";
    if ("boolean" == typeof t3) return t3 ? "true" : "false";
    if ("string" == typeof t3) return z(t3, l2);
    if ("number" == typeof t3) {
      if (0 === t3) return 1 / 0 / t3 > 0 ? "0" : "-0";
      var x2 = String(t3);
      return E2 ? j(t3, x2) : x2;
    }
    if ("bigint" == typeof t3) {
      var A2 = String(t3) + "n";
      return E2 ? j(t3, A2) : A2;
    }
    var O2 = void 0 === l2.depth ? 5 : l2.depth;
    if (void 0 === s3 && (s3 = 0), s3 >= O2 && O2 > 0 && "object" == typeof t3) return U(t3) ? "[Array]" : "[Object]";
    var M2, q2 = function(e4, t4) {
      var r3;
      if ("	" === e4.indent) r3 = "	";
      else {
        if (!("number" == typeof e4.indent && e4.indent > 0)) return null;
        r3 = w.call(Array(e4.indent + 1), " ");
      }
      return { base: r3, prev: w.call(Array(t4 + 1), r3) };
    }(l2, s3);
    if (void 0 === a3) a3 = [];
    else if (H(a3, t3) >= 0) return "[Circular]";
    function K2(t4, r3, n4) {
      if (r3 && (a3 = P.call(a3)).push(r3), n4) {
        var i3 = { depth: l2.depth };
        return W(l2, "quoteStyle") && (i3.quoteStyle = l2.quoteStyle), e3(t4, i3, s3 + 1, a3);
      }
      return e3(t4, l2, s3 + 1, a3);
    }
    if ("function" == typeof t3 && !$(t3)) {
      var ee = function(e4) {
        if (e4.name) return e4.name;
        var t4 = g.call(y.call(e4), /^function\s*([\w$]+)/);
        return t4 ? t4[1] : null;
      }(t3), te = Z(t3, K2);
      return "[Function" + (ee ? ": " + ee : " (anonymous)") + "]" + (te.length > 0 ? " { " + w.call(te, ", ") + " }" : "");
    }
    if (V(t3)) {
      var re = _ ? v.call(String(t3), /^(Symbol\(.*\))_[^)]*$/, "$1") : I.call(t3);
      return "object" != typeof t3 || _ ? re : X(re);
    }
    if ((M2 = t3) && "object" == typeof M2 && ("undefined" != typeof HTMLElement && M2 instanceof HTMLElement || "string" == typeof M2.nodeName && "function" == typeof M2.getAttribute)) {
      for (var ne = "<" + S.call(String(t3.nodeName)), se = t3.attributes || [], ie = 0; ie < se.length; ie++) ne += " " + se[ie].name + "=" + R(F(se[ie].value), "double", l2);
      return ne += ">", t3.childNodes && t3.childNodes.length && (ne += "..."), ne + "</" + S.call(String(t3.nodeName)) + ">";
    }
    if (U(t3)) {
      if (0 === t3.length) return "[]";
      var oe = Z(t3, K2);
      return q2 && !function(e4) {
        for (var t4 = 0; t4 < e4.length; t4++) if (H(e4[t4], "\n") >= 0) return false;
        return true;
      }(oe) ? "[" + Q(oe, q2) + "]" : "[ " + w.call(oe, ", ") + " ]";
    }
    if (function(e4) {
      return !("[object Error]" !== G(e4) || k && "object" == typeof e4 && k in e4);
    }(t3)) {
      var ae = Z(t3, K2);
      return "cause" in Error.prototype || !("cause" in t3) || N.call(t3, "cause") ? 0 === ae.length ? "[" + String(t3) + "]" : "{ [" + String(t3) + "] " + w.call(ae, ", ") + " }" : "{ [" + String(t3) + "] " + w.call(T.call("[cause]: " + K2(t3.cause), ae), ", ") + " }";
    }
    if ("object" == typeof t3 && m2) {
      if (B && "function" == typeof t3[B] && L) return L(t3, { depth: O2 - s3 });
      if ("symbol" !== m2 && "function" == typeof t3.inspect) return t3.inspect();
    }
    if (function(e4) {
      if (!i2 || !e4 || "object" != typeof e4) return false;
      try {
        i2.call(e4);
        try {
          c.call(e4);
        } catch (e5) {
          return true;
        }
        return e4 instanceof Map;
      } catch (e5) {
      }
      return false;
    }(t3)) {
      var le = [];
      return o2 && o2.call(t3, function(e4, r3) {
        le.push(K2(r3, t3, true) + " => " + K2(e4, t3));
      }), Y("Map", i2.call(t3), le, q2);
    }
    if (function(e4) {
      if (!c || !e4 || "object" != typeof e4) return false;
      try {
        c.call(e4);
        try {
          i2.call(e4);
        } catch (e5) {
          return true;
        }
        return e4 instanceof Set;
      } catch (e5) {
      }
      return false;
    }(t3)) {
      var ce = [];
      return u && u.call(t3, function(e4) {
        ce.push(K2(e4, t3));
      }), Y("Set", c.call(t3), ce, q2);
    }
    if (function(e4) {
      if (!p || !e4 || "object" != typeof e4) return false;
      try {
        p.call(e4, p);
        try {
          d.call(e4, d);
        } catch (e5) {
          return true;
        }
        return e4 instanceof WeakMap;
      } catch (e5) {
      }
      return false;
    }(t3)) return J("WeakMap");
    if (function(e4) {
      if (!d || !e4 || "object" != typeof e4) return false;
      try {
        d.call(e4, d);
        try {
          p.call(e4, p);
        } catch (e5) {
          return true;
        }
        return e4 instanceof WeakSet;
      } catch (e5) {
      }
      return false;
    }(t3)) return J("WeakSet");
    if (function(e4) {
      if (!f || !e4 || "object" != typeof e4) return false;
      try {
        return f.call(e4), true;
      } catch (e5) {
      }
      return false;
    }(t3)) return J("WeakRef");
    if (function(e4) {
      return !("[object Number]" !== G(e4) || k && "object" == typeof e4 && k in e4);
    }(t3)) return X(K2(Number(t3)));
    if (function(e4) {
      if (!e4 || "object" != typeof e4 || !C) return false;
      try {
        return C.call(e4), true;
      } catch (e5) {
      }
      return false;
    }(t3)) return X(K2(C.call(t3)));
    if (function(e4) {
      return !("[object Boolean]" !== G(e4) || k && "object" == typeof e4 && k in e4);
    }(t3)) return X(h.call(t3));
    if (function(e4) {
      return !("[object String]" !== G(e4) || k && "object" == typeof e4 && k in e4);
    }(t3)) return X(K2(String(t3)));
    if ("undefined" != typeof window && t3 === window) return "{ [object Window] }";
    if (t3 === r2.g) return "{ [object globalThis] }";
    if (!function(e4) {
      return !("[object Date]" !== G(e4) || k && "object" == typeof e4 && k in e4);
    }(t3) && !$(t3)) {
      var ue = Z(t3, K2), pe = D ? D(t3) === Object.prototype : t3 instanceof Object || t3.constructor === Object, de = t3 instanceof Object ? "" : "null prototype", fe = !pe && k && Object(t3) === t3 && k in t3 ? b.call(G(t3), 8, -1) : de ? "Object" : "", he = (pe || "function" != typeof t3.constructor ? "" : t3.constructor.name ? t3.constructor.name + " " : "") + (fe || de ? "[" + w.call(T.call([], fe || [], de || []), ": ") + "] " : "");
      return 0 === ue.length ? he + "{}" : q2 ? he + "{" + Q(ue, q2) + "}" : he + "{ " + w.call(ue, ", ") + " }";
    }
    return String(t3);
  };
  var q = Object.prototype.hasOwnProperty || function(e3) {
    return e3 in this;
  };
  function W(e3, t3) {
    return q.call(e3, t3);
  }
  function G(e3) {
    return m.call(e3);
  }
  function H(e3, t3) {
    if (e3.indexOf) return e3.indexOf(t3);
    for (var r3 = 0, n3 = e3.length; r3 < n3; r3++) if (e3[r3] === t3) return r3;
    return -1;
  }
  function z(e3, t3) {
    if (e3.length > t3.maxStringLength) {
      var r3 = e3.length - t3.maxStringLength, n3 = "... " + r3 + " more character" + (r3 > 1 ? "s" : "");
      return z(b.call(e3, 0, t3.maxStringLength), t3) + n3;
    }
    return R(v.call(v.call(e3, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, K), "single", t3);
  }
  function K(e3) {
    var t3 = e3.charCodeAt(0), r3 = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[t3];
    return r3 ? "\\" + r3 : "\\x" + (t3 < 16 ? "0" : "") + E.call(t3.toString(16));
  }
  function X(e3) {
    return "Object(" + e3 + ")";
  }
  function J(e3) {
    return e3 + " { ? }";
  }
  function Y(e3, t3, r3, n3) {
    return e3 + " (" + t3 + ") {" + (n3 ? Q(r3, n3) : w.call(r3, ", ")) + "}";
  }
  function Q(e3, t3) {
    if (0 === e3.length) return "";
    var r3 = "\n" + t3.prev + t3.base;
    return r3 + w.call(e3, "," + r3) + "\n" + t3.prev;
  }
  function Z(e3, t3) {
    var r3 = U(e3), n3 = [];
    if (r3) {
      n3.length = e3.length;
      for (var s3 = 0; s3 < e3.length; s3++) n3[s3] = W(e3, s3) ? t3(e3[s3], e3) : "";
    }
    var i3, o3 = "function" == typeof O ? O(e3) : [];
    if (_) {
      i3 = {};
      for (var a3 = 0; a3 < o3.length; a3++) i3["$" + o3[a3]] = o3[a3];
    }
    for (var l2 in e3) W(e3, l2) && (r3 && String(Number(l2)) === l2 && l2 < e3.length || _ && i3["$" + l2] instanceof Symbol || (x.call(/[^\w$]/, l2) ? n3.push(t3(l2, e3) + ": " + t3(e3[l2], e3)) : n3.push(l2 + ": " + t3(e3[l2], e3))));
    if ("function" == typeof O) for (var c2 = 0; c2 < o3.length; c2++) N.call(e3, o3[c2]) && n3.push("[" + t3(o3[c2]) + "]: " + t3(e3[o3[c2]], e3));
    return n3;
  }
}, (e2, t2, r2) => {
  var n2 = r2(144), s2 = Object.prototype.hasOwnProperty, i2 = Array.isArray, o2 = { allowDots: false, allowPrototypes: false, allowSparse: false, arrayLimit: 20, charset: "utf-8", charsetSentinel: false, comma: false, decoder: n2.decode, delimiter: "&", depth: 5, ignoreQueryPrefix: false, interpretNumericEntities: false, parameterLimit: 1e3, parseArrays: true, plainObjects: false, strictNullHandling: false }, a2 = function(e3) {
    return e3.replace(/&#(\d+);/g, function(e4, t3) {
      return String.fromCharCode(parseInt(t3, 10));
    });
  }, l = function(e3, t3) {
    return e3 && "string" == typeof e3 && t3.comma && e3.indexOf(",") > -1 ? e3.split(",") : e3;
  }, c = function(e3, t3, r3, n3) {
    if (e3) {
      var i3 = r3.allowDots ? e3.replace(/\.([^.[]+)/g, "[$1]") : e3, o3 = /(\[[^[\]]*])/g, a3 = r3.depth > 0 && /(\[[^[\]]*])/.exec(i3), c2 = a3 ? i3.slice(0, a3.index) : i3, u = [];
      if (c2) {
        if (!r3.plainObjects && s2.call(Object.prototype, c2) && !r3.allowPrototypes) return;
        u.push(c2);
      }
      for (var p = 0; r3.depth > 0 && null !== (a3 = o3.exec(i3)) && p < r3.depth; ) {
        if (p += 1, !r3.plainObjects && s2.call(Object.prototype, a3[1].slice(1, -1)) && !r3.allowPrototypes) return;
        u.push(a3[1]);
      }
      return a3 && u.push("[" + i3.slice(a3.index) + "]"), function(e4, t4, r4, n4) {
        for (var s3 = n4 ? t4 : l(t4, r4), i4 = e4.length - 1; i4 >= 0; --i4) {
          var o4, a4 = e4[i4];
          if ("[]" === a4 && r4.parseArrays) o4 = [].concat(s3);
          else {
            o4 = r4.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
            var c3 = "[" === a4.charAt(0) && "]" === a4.charAt(a4.length - 1) ? a4.slice(1, -1) : a4, u2 = parseInt(c3, 10);
            r4.parseArrays || "" !== c3 ? !isNaN(u2) && a4 !== c3 && String(u2) === c3 && u2 >= 0 && r4.parseArrays && u2 <= r4.arrayLimit ? (o4 = [])[u2] = s3 : "__proto__" !== c3 && (o4[c3] = s3) : o4 = { 0: s3 };
          }
          s3 = o4;
        }
        return s3;
      }(u, t3, r3, n3);
    }
  };
  e2.exports = function(e3, t3) {
    var r3 = function(e4) {
      if (!e4) return o2;
      if (null !== e4.decoder && void 0 !== e4.decoder && "function" != typeof e4.decoder) throw new TypeError("Decoder has to be a function.");
      if (void 0 !== e4.charset && "utf-8" !== e4.charset && "iso-8859-1" !== e4.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      var t4 = void 0 === e4.charset ? o2.charset : e4.charset;
      return { allowDots: void 0 === e4.allowDots ? o2.allowDots : !!e4.allowDots, allowPrototypes: "boolean" == typeof e4.allowPrototypes ? e4.allowPrototypes : o2.allowPrototypes, allowSparse: "boolean" == typeof e4.allowSparse ? e4.allowSparse : o2.allowSparse, arrayLimit: "number" == typeof e4.arrayLimit ? e4.arrayLimit : o2.arrayLimit, charset: t4, charsetSentinel: "boolean" == typeof e4.charsetSentinel ? e4.charsetSentinel : o2.charsetSentinel, comma: "boolean" == typeof e4.comma ? e4.comma : o2.comma, decoder: "function" == typeof e4.decoder ? e4.decoder : o2.decoder, delimiter: "string" == typeof e4.delimiter || n2.isRegExp(e4.delimiter) ? e4.delimiter : o2.delimiter, depth: "number" == typeof e4.depth || false === e4.depth ? +e4.depth : o2.depth, ignoreQueryPrefix: true === e4.ignoreQueryPrefix, interpretNumericEntities: "boolean" == typeof e4.interpretNumericEntities ? e4.interpretNumericEntities : o2.interpretNumericEntities, parameterLimit: "number" == typeof e4.parameterLimit ? e4.parameterLimit : o2.parameterLimit, parseArrays: false !== e4.parseArrays, plainObjects: "boolean" == typeof e4.plainObjects ? e4.plainObjects : o2.plainObjects, strictNullHandling: "boolean" == typeof e4.strictNullHandling ? e4.strictNullHandling : o2.strictNullHandling };
    }(t3);
    if ("" === e3 || null == e3) return r3.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    for (var u = "string" == typeof e3 ? function(e4, t4) {
      var r4, c2 = { __proto__: null }, u2 = t4.ignoreQueryPrefix ? e4.replace(/^\?/, "") : e4, p2 = t4.parameterLimit === 1 / 0 ? void 0 : t4.parameterLimit, d2 = u2.split(t4.delimiter, p2), f2 = -1, h2 = t4.charset;
      if (t4.charsetSentinel) for (r4 = 0; r4 < d2.length; ++r4) 0 === d2[r4].indexOf("utf8=") && ("utf8=%E2%9C%93" === d2[r4] ? h2 = "utf-8" : "utf8=%26%2310003%3B" === d2[r4] && (h2 = "iso-8859-1"), f2 = r4, r4 = d2.length);
      for (r4 = 0; r4 < d2.length; ++r4) if (r4 !== f2) {
        var m2, y, g = d2[r4], b = g.indexOf("]="), v = -1 === b ? g.indexOf("=") : b + 1;
        -1 === v ? (m2 = t4.decoder(g, o2.decoder, h2, "key"), y = t4.strictNullHandling ? null : "") : (m2 = t4.decoder(g.slice(0, v), o2.decoder, h2, "key"), y = n2.maybeMap(l(g.slice(v + 1), t4), function(e5) {
          return t4.decoder(e5, o2.decoder, h2, "value");
        })), y && t4.interpretNumericEntities && "iso-8859-1" === h2 && (y = a2(y)), g.indexOf("[]=") > -1 && (y = i2(y) ? [y] : y), s2.call(c2, m2) ? c2[m2] = n2.combine(c2[m2], y) : c2[m2] = y;
      }
      return c2;
    }(e3, r3) : e3, p = r3.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, d = Object.keys(u), f = 0; f < d.length; ++f) {
      var h = d[f], m = c(h, u[h], r3, "string" == typeof e3);
      p = n2.merge(p, m, r3);
    }
    return true === r3.allowSparse ? p : n2.compact(p);
  };
}, (e2, t2, r2) => {
  let n2 = r2(87), s2 = r2(52), i2 = r2(147), o2 = r2(24), a2 = r2(322), l = r2(54), c = r2(324), u = r2(88), p = r2(153), d = r2(56), f = r2(91), h = r2(89), m = r2(55), y = r2(90), g = r2(154), b = r2(92), v = r2(40), E = r2(53);
  function S() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    return 1 === t3.length && Array.isArray(t3[0]) && (t3 = t3[0]), new a2(t3);
  }
  S.plugin = function(e3, t3) {
    let r3, n3 = false;
    function s3() {
      console && console.warn && !n3 && (n3 = true);
      let r4 = t3(...arguments);
      return r4.postcssPlugin = e3, r4.postcssVersion = new a2().version, r4;
    }
    return Object.defineProperty(s3, "postcss", { get: () => (r3 || (r3 = s3()), r3) }), s3.process = function(e4, t4, r4) {
      return S([s3(r4)]).process(e4, t4);
    }, s3;
  }, S.stringify = l, S.parse = y, S.fromJSON = c, S.list = g, S.comment = (e3) => new d(e3), S.atRule = (e3) => new f(e3), S.decl = (e3) => new s2(e3), S.rule = (e3) => new b(e3), S.root = (e3) => new v(e3), S.document = (e3) => new u(e3), S.CssSyntaxError = n2, S.Declaration = s2, S.Container = o2, S.Processor = a2, S.Document = u, S.Comment = d, S.Warning = p, S.AtRule = f, S.Result = h, S.Input = m, S.Rule = b, S.Root = v, S.Node = E, i2.registerPostcss(S), e2.exports = S, S.default = S;
}, (e2) => {
  var t2 = String, r2 = function() {
    return { isColorSupported: false, reset: t2, bold: t2, dim: t2, italic: t2, underline: t2, inverse: t2, hidden: t2, strikethrough: t2, black: t2, red: t2, green: t2, yellow: t2, blue: t2, magenta: t2, cyan: t2, white: t2, gray: t2, bgBlack: t2, bgRed: t2, bgGreen: t2, bgYellow: t2, bgBlue: t2, bgMagenta: t2, bgCyan: t2, bgWhite: t2 };
  };
  e2.exports = r2(), e2.exports.createColors = r2;
}, () => {
}, () => {
}, (e2) => {
  e2.exports = { nanoid: function() {
    let e3 = "", t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 21;
    for (; t2--; ) e3 += "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"[64 * Math.random() | 0];
    return e3;
  }, customAlphabet: function(e3) {
    let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 21;
    return function() {
      let r2 = "", n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : t2;
      for (; n2--; ) r2 += e3[Math.random() * e3.length | 0];
      return r2;
    };
  } };
}, (e2, t2, r2) => {
  let n2 = r2(52), s2 = r2(321), i2 = r2(56), o2 = r2(91), a2 = r2(40), l = r2(92);
  const c = { empty: true, space: true };
  e2.exports = class {
    constructor(e3) {
      this.input = e3, this.root = new a2(), this.current = this.root, this.spaces = "", this.semicolon = false, this.customProperty = false, this.createTokenizer(), this.root.source = { input: e3, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(e3) {
      let t3, r3, n3, s3 = new o2();
      s3.name = e3[1].slice(1), "" === s3.name && this.unnamedAtrule(s3, e3), this.init(s3, e3[2]);
      let i3 = false, a3 = false, l2 = [], c2 = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (t3 = (e3 = this.tokenizer.nextToken())[0], "(" === t3 || "[" === t3 ? c2.push("(" === t3 ? ")" : "]") : "{" === t3 && c2.length > 0 ? c2.push("}") : t3 === c2[c2.length - 1] && c2.pop(), 0 === c2.length) {
          if (";" === t3) {
            s3.source.end = this.getPosition(e3[2]), s3.source.end.offset++, this.semicolon = true;
            break;
          }
          if ("{" === t3) {
            a3 = true;
            break;
          }
          if ("}" === t3) {
            if (l2.length > 0) {
              for (n3 = l2.length - 1, r3 = l2[n3]; r3 && "space" === r3[0]; ) r3 = l2[--n3];
              r3 && (s3.source.end = this.getPosition(r3[3] || r3[2]), s3.source.end.offset++);
            }
            this.end(e3);
            break;
          }
          l2.push(e3);
        } else l2.push(e3);
        if (this.tokenizer.endOfFile()) {
          i3 = true;
          break;
        }
      }
      s3.raws.between = this.spacesAndCommentsFromEnd(l2), l2.length ? (s3.raws.afterName = this.spacesAndCommentsFromStart(l2), this.raw(s3, "params", l2), i3 && (e3 = l2[l2.length - 1], s3.source.end = this.getPosition(e3[3] || e3[2]), s3.source.end.offset++, this.spaces = s3.raws.between, s3.raws.between = "")) : (s3.raws.afterName = "", s3.params = ""), a3 && (s3.nodes = [], this.current = s3);
    }
    checkMissedSemicolon(e3) {
      let t3 = this.colon(e3);
      if (false === t3) return;
      let r3, n3 = 0;
      for (let s3 = t3 - 1; s3 >= 0 && (r3 = e3[s3], "space" === r3[0] || (n3 += 1, 2 !== n3)); s3--) ;
      throw this.input.error("Missed semicolon", "word" === r3[0] ? r3[3] + 1 : r3[2]);
    }
    colon(e3) {
      let t3, r3, n3, s3 = 0;
      for (let [i3, o3] of e3.entries()) {
        if (t3 = o3, r3 = t3[0], "(" === r3 && (s3 += 1), ")" === r3 && (s3 -= 1), 0 === s3 && ":" === r3) {
          if (n3) {
            if ("word" === n3[0] && "progid" === n3[1]) continue;
            return i3;
          }
          this.doubleColon(t3);
        }
        n3 = t3;
      }
      return false;
    }
    comment(e3) {
      let t3 = new i2();
      this.init(t3, e3[2]), t3.source.end = this.getPosition(e3[3] || e3[2]), t3.source.end.offset++;
      let r3 = e3[1].slice(2, -2);
      if (/^\s*$/.test(r3)) t3.text = "", t3.raws.left = r3, t3.raws.right = "";
      else {
        let e4 = r3.match(/^(\s*)([^]*\S)(\s*)$/);
        t3.text = e4[2], t3.raws.left = e4[1], t3.raws.right = e4[3];
      }
    }
    createTokenizer() {
      this.tokenizer = s2(this.input);
    }
    decl(e3, t3) {
      let r3 = new n2();
      this.init(r3, e3[0][2]);
      let s3, i3 = e3[e3.length - 1];
      for (";" === i3[0] && (this.semicolon = true, e3.pop()), r3.source.end = this.getPosition(i3[3] || i3[2] || function(e4) {
        for (let t4 = e4.length - 1; t4 >= 0; t4--) {
          let r4 = e4[t4], n3 = r4[3] || r4[2];
          if (n3) return n3;
        }
      }(e3)), r3.source.end.offset++; "word" !== e3[0][0]; ) 1 === e3.length && this.unknownWord(e3), r3.raws.before += e3.shift()[1];
      for (r3.source.start = this.getPosition(e3[0][2]), r3.prop = ""; e3.length; ) {
        let t4 = e3[0][0];
        if (":" === t4 || "space" === t4 || "comment" === t4) break;
        r3.prop += e3.shift()[1];
      }
      for (r3.raws.between = ""; e3.length; ) {
        if (s3 = e3.shift(), ":" === s3[0]) {
          r3.raws.between += s3[1];
          break;
        }
        "word" === s3[0] && /\w/.test(s3[1]) && this.unknownWord([s3]), r3.raws.between += s3[1];
      }
      "_" !== r3.prop[0] && "*" !== r3.prop[0] || (r3.raws.before += r3.prop[0], r3.prop = r3.prop.slice(1));
      let o3, a3 = [];
      for (; e3.length && (o3 = e3[0][0], "space" === o3 || "comment" === o3); ) a3.push(e3.shift());
      this.precheckMissedSemicolon(e3);
      for (let t4 = e3.length - 1; t4 >= 0; t4--) {
        if (s3 = e3[t4], "!important" === s3[1].toLowerCase()) {
          r3.important = true;
          let n3 = this.stringFrom(e3, t4);
          n3 = this.spacesFromEnd(e3) + n3, " !important" !== n3 && (r3.raws.important = n3);
          break;
        }
        if ("important" === s3[1].toLowerCase()) {
          let n3 = e3.slice(0), s4 = "";
          for (let e4 = t4; e4 > 0; e4--) {
            let t5 = n3[e4][0];
            if (0 === s4.trim().indexOf("!") && "space" !== t5) break;
            s4 = n3.pop()[1] + s4;
          }
          0 === s4.trim().indexOf("!") && (r3.important = true, r3.raws.important = s4, e3 = n3);
        }
        if ("space" !== s3[0] && "comment" !== s3[0]) break;
      }
      e3.some((e4) => "space" !== e4[0] && "comment" !== e4[0]) && (r3.raws.between += a3.map((e4) => e4[1]).join(""), a3 = []), this.raw(r3, "value", a3.concat(e3), t3), r3.value.includes(":") && !t3 && this.checkMissedSemicolon(e3);
    }
    doubleColon(e3) {
      throw this.input.error("Double colon", { offset: e3[2] }, { offset: e3[2] + e3[1].length });
    }
    emptyRule(e3) {
      let t3 = new l();
      this.init(t3, e3[2]), t3.selector = "", t3.raws.between = "", this.current = t3;
    }
    end(e3) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e3[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e3);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(e3) {
      if (this.spaces += e3[1], this.current.nodes) {
        let e4 = this.current.nodes[this.current.nodes.length - 1];
        e4 && "rule" === e4.type && !e4.raws.ownSemicolon && (e4.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }
    getPosition(e3) {
      let t3 = this.input.fromOffset(e3);
      return { column: t3.col, line: t3.line, offset: e3 };
    }
    init(e3, t3) {
      this.current.push(e3), e3.source = { input: this.input, start: this.getPosition(t3) }, e3.raws.before = this.spaces, this.spaces = "", "comment" !== e3.type && (this.semicolon = false);
    }
    other(e3) {
      let t3 = false, r3 = null, n3 = false, s3 = null, i3 = [], o3 = e3[1].startsWith("--"), a3 = [], l2 = e3;
      for (; l2; ) {
        if (r3 = l2[0], a3.push(l2), "(" === r3 || "[" === r3) s3 || (s3 = l2), i3.push("(" === r3 ? ")" : "]");
        else if (o3 && n3 && "{" === r3) s3 || (s3 = l2), i3.push("}");
        else if (0 === i3.length) {
          if (";" === r3) {
            if (n3) return void this.decl(a3, o3);
            break;
          }
          if ("{" === r3) return void this.rule(a3);
          if ("}" === r3) {
            this.tokenizer.back(a3.pop()), t3 = true;
            break;
          }
          ":" === r3 && (n3 = true);
        } else r3 === i3[i3.length - 1] && (i3.pop(), 0 === i3.length && (s3 = null));
        l2 = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (t3 = true), i3.length > 0 && this.unclosedBracket(s3), t3 && n3) {
        if (!o3) for (; a3.length && (l2 = a3[a3.length - 1][0], "space" === l2 || "comment" === l2); ) this.tokenizer.back(a3.pop());
        this.decl(a3, o3);
      } else this.unknownWord(a3);
    }
    parse() {
      let e3;
      for (; !this.tokenizer.endOfFile(); ) switch (e3 = this.tokenizer.nextToken(), e3[0]) {
        case "space":
          this.spaces += e3[1];
          break;
        case ";":
          this.freeSemicolon(e3);
          break;
        case "}":
          this.end(e3);
          break;
        case "comment":
          this.comment(e3);
          break;
        case "at-word":
          this.atrule(e3);
          break;
        case "{":
          this.emptyRule(e3);
          break;
        default:
          this.other(e3);
      }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(e3, t3, r3, n3) {
      let s3, i3, o3, a3, l2 = r3.length, u = "", p = true;
      for (let e4 = 0; e4 < l2; e4 += 1) s3 = r3[e4], i3 = s3[0], "space" !== i3 || e4 !== l2 - 1 || n3 ? "comment" === i3 ? (a3 = r3[e4 - 1] ? r3[e4 - 1][0] : "empty", o3 = r3[e4 + 1] ? r3[e4 + 1][0] : "empty", c[a3] || c[o3] || "," === u.slice(-1) ? p = false : u += s3[1]) : u += s3[1] : p = false;
      if (!p) {
        let n4 = r3.reduce((e4, t4) => e4 + t4[1], "");
        e3.raws[t3] = { raw: n4, value: u };
      }
      e3[t3] = u;
    }
    rule(e3) {
      e3.pop();
      let t3 = new l();
      this.init(t3, e3[0][2]), t3.raws.between = this.spacesAndCommentsFromEnd(e3), this.raw(t3, "selector", e3), this.current = t3;
    }
    spacesAndCommentsFromEnd(e3) {
      let t3, r3 = "";
      for (; e3.length && (t3 = e3[e3.length - 1][0], "space" === t3 || "comment" === t3); ) r3 = e3.pop()[1] + r3;
      return r3;
    }
    spacesAndCommentsFromStart(e3) {
      let t3, r3 = "";
      for (; e3.length && (t3 = e3[0][0], "space" === t3 || "comment" === t3); ) r3 += e3.shift()[1];
      return r3;
    }
    spacesFromEnd(e3) {
      let t3, r3 = "";
      for (; e3.length && (t3 = e3[e3.length - 1][0], "space" === t3); ) r3 = e3.pop()[1] + r3;
      return r3;
    }
    stringFrom(e3, t3) {
      let r3 = "";
      for (let n3 = t3; n3 < e3.length; n3++) r3 += e3[n3][1];
      return e3.splice(t3, e3.length - t3), r3;
    }
    unclosedBlock() {
      let e3 = this.current.source.start;
      throw this.input.error("Unclosed block", e3.line, e3.column);
    }
    unclosedBracket(e3) {
      throw this.input.error("Unclosed bracket", { offset: e3[2] }, { offset: e3[2] + 1 });
    }
    unexpectedClose(e3) {
      throw this.input.error("Unexpected }", { offset: e3[2] }, { offset: e3[2] + 1 });
    }
    unknownWord(e3) {
      throw this.input.error("Unknown word", { offset: e3[0][2] }, { offset: e3[0][2] + e3[0][1].length });
    }
    unnamedAtrule(e3, t3) {
      throw this.input.error("At-rule without name", { offset: t3[2] }, { offset: t3[2] + t3[1].length });
    }
  };
}, (e2) => {
  const t2 = "'".charCodeAt(0), r2 = '"'.charCodeAt(0), n2 = "\\".charCodeAt(0), s2 = "/".charCodeAt(0), i2 = "\n".charCodeAt(0), o2 = " ".charCodeAt(0), a2 = "\f".charCodeAt(0), l = "	".charCodeAt(0), c = "\r".charCodeAt(0), u = "[".charCodeAt(0), p = "]".charCodeAt(0), d = "(".charCodeAt(0), f = ")".charCodeAt(0), h = "{".charCodeAt(0), m = "}".charCodeAt(0), y = ";".charCodeAt(0), g = "*".charCodeAt(0), b = ":".charCodeAt(0), v = "@".charCodeAt(0), E = /[\t\n\f\r "#'()/;[\\\]{}]/g, S = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, x = /.[\r\n"'(/\\]/, T = /[\da-f]/i;
  e2.exports = function(e3) {
    let w, P, A, C, O, I, _, k, N, D, j = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, L = e3.css.valueOf(), M = j.ignoreErrors, B = L.length, R = 0, F = [], U = [];
    function $(t3) {
      throw e3.error("Unclosed " + t3, R);
    }
    return { back: function(e4) {
      U.push(e4);
    }, endOfFile: function() {
      return 0 === U.length && R >= B;
    }, nextToken: function(e4) {
      if (U.length) return U.pop();
      if (R >= B) return;
      let j2 = !!e4 && e4.ignoreUnclosed;
      switch (w = L.charCodeAt(R), w) {
        case i2:
        case o2:
        case l:
        case c:
        case a2:
          P = R;
          do {
            P += 1, w = L.charCodeAt(P);
          } while (w === o2 || w === i2 || w === l || w === c || w === a2);
          D = ["space", L.slice(R, P)], R = P - 1;
          break;
        case u:
        case p:
        case h:
        case m:
        case b:
        case y:
        case f: {
          let e5 = String.fromCharCode(w);
          D = [e5, e5, R];
          break;
        }
        case d:
          if (k = F.length ? F.pop()[1] : "", N = L.charCodeAt(R + 1), "url" === k && N !== t2 && N !== r2 && N !== o2 && N !== i2 && N !== l && N !== a2 && N !== c) {
            P = R;
            do {
              if (I = false, P = L.indexOf(")", P + 1), -1 === P) {
                if (M || j2) {
                  P = R;
                  break;
                }
                $("bracket");
              }
              for (_ = P; L.charCodeAt(_ - 1) === n2; ) _ -= 1, I = !I;
            } while (I);
            D = ["brackets", L.slice(R, P + 1), R, P], R = P;
          } else P = L.indexOf(")", R + 1), C = L.slice(R, P + 1), -1 === P || x.test(C) ? D = ["(", "(", R] : (D = ["brackets", C, R, P], R = P);
          break;
        case t2:
        case r2:
          A = w === t2 ? "'" : '"', P = R;
          do {
            if (I = false, P = L.indexOf(A, P + 1), -1 === P) {
              if (M || j2) {
                P = R + 1;
                break;
              }
              $("string");
            }
            for (_ = P; L.charCodeAt(_ - 1) === n2; ) _ -= 1, I = !I;
          } while (I);
          D = ["string", L.slice(R, P + 1), R, P], R = P;
          break;
        case v:
          E.lastIndex = R + 1, E.test(L), P = 0 === E.lastIndex ? L.length - 1 : E.lastIndex - 2, D = ["at-word", L.slice(R, P + 1), R, P], R = P;
          break;
        case n2:
          for (P = R, O = true; L.charCodeAt(P + 1) === n2; ) P += 1, O = !O;
          if (w = L.charCodeAt(P + 1), O && w !== s2 && w !== o2 && w !== i2 && w !== l && w !== c && w !== a2 && (P += 1, T.test(L.charAt(P)))) {
            for (; T.test(L.charAt(P + 1)); ) P += 1;
            L.charCodeAt(P + 1) === o2 && (P += 1);
          }
          D = ["word", L.slice(R, P + 1), R, P], R = P;
          break;
        default:
          w === s2 && L.charCodeAt(R + 1) === g ? (P = L.indexOf("*/", R + 2) + 1, 0 === P && (M || j2 ? P = L.length : $("comment")), D = ["comment", L.slice(R, P + 1), R, P], R = P) : (S.lastIndex = R + 1, S.test(L), P = 0 === S.lastIndex ? L.length - 1 : S.lastIndex - 2, D = ["word", L.slice(R, P + 1), R, P], F.push(D), R = P);
      }
      return R++, D;
    }, position: function() {
      return R;
    } };
  };
}, (e2, t2, r2) => {
  let n2 = r2(323), s2 = r2(147), i2 = r2(88), o2 = r2(40);
  class a2 {
    constructor() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      this.version = "8.4.33", this.plugins = this.normalize(e3);
    }
    normalize(e3) {
      let t3 = [];
      for (let r3 of e3) if (true === r3.postcss ? r3 = r3() : r3.postcss && (r3 = r3.postcss), "object" == typeof r3 && Array.isArray(r3.plugins)) t3 = t3.concat(r3.plugins);
      else if ("object" == typeof r3 && r3.postcssPlugin) t3.push(r3);
      else if ("function" == typeof r3) t3.push(r3);
      else if ("object" != typeof r3 || !r3.parse && !r3.stringify) throw new Error(r3 + " is not a PostCSS plugin");
      return t3;
    }
    process(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return this.plugins.length || t3.parser || t3.stringifier || t3.syntax ? new s2(this, e3, t3) : new n2(this, e3, t3);
    }
    use(e3) {
      return this.plugins = this.plugins.concat(this.normalize([e3])), this;
    }
  }
  e2.exports = a2, a2.default = a2, o2.registerProcessor(a2), i2.registerProcessor(a2);
}, (e2, t2, r2) => {
  let n2 = r2(148), s2 = r2(54), i2 = (r2(152), r2(90));
  const o2 = r2(89);
  class a2 {
    constructor(e3, t3, r3) {
      let i3;
      t3 = t3.toString(), this.stringified = false, this._processor = e3, this._css = t3, this._opts = r3, this._map = void 0;
      let a3 = s2;
      this.result = new o2(this._processor, i3, this._opts), this.result.css = t3;
      let l = this;
      Object.defineProperty(this.result, "root", { get: () => l.root });
      let c = new n2(a3, i3, this._opts, t3);
      if (c.isMap()) {
        let [e4, t4] = c.generate();
        e4 && (this.result.css = e4), t4 && (this.result.map = t4);
      } else c.clearAnnotation(), this.result.css = c.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(e3) {
      return this.async().catch(e3);
    }
    finally(e3) {
      return this.async().then(e3, e3);
    }
    sync() {
      if (this.error) throw this.error;
      return this.result;
    }
    then(e3, t3) {
      return this.async().then(e3, t3);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root) return this._root;
      let e3, t3 = i2;
      try {
        e3 = t3(this._css, this._opts);
      } catch (e4) {
        this.error = e4;
      }
      if (this.error) throw this.error;
      return this._root = e3, e3;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
  }
  e2.exports = a2, a2.default = a2;
}, (e2, t2, r2) => {
  let n2 = r2(52), s2 = r2(151), i2 = r2(56), o2 = r2(91), a2 = r2(55), l = r2(40), c = r2(92);
  function u(e3, t3) {
    if (Array.isArray(e3)) return e3.map((e4) => u(e4));
    let { inputs: r3, ...p } = e3;
    if (r3) {
      t3 = [];
      for (let e4 of r3) {
        let r4 = { ...e4, __proto__: a2.prototype };
        r4.map && (r4.map = { ...r4.map, __proto__: s2.prototype }), t3.push(r4);
      }
    }
    if (p.nodes && (p.nodes = e3.nodes.map((e4) => u(e4, t3))), p.source) {
      let { inputId: e4, ...r4 } = p.source;
      p.source = r4, null != e4 && (p.source.input = t3[e4]);
    }
    if ("root" === p.type) return new l(p);
    if ("decl" === p.type) return new n2(p);
    if ("rule" === p.type) return new c(p);
    if ("comment" === p.type) return new i2(p);
    if ("atrule" === p.type) return new o2(p);
    throw new Error("Unknown node type: " + e3.type);
  }
  e2.exports = u, u.default = u;
}, (e2, t2, r2) => {
  var n2 = r2(31).a, s2 = r2(513);
  class i2 {
    constructor(e3) {
      this.bits = e3 instanceof i2 ? e3.bits.slice() : [];
    }
    add(e3) {
      this.bits[e3 >> 5] |= 1 << (31 & e3);
    }
    has(e3) {
      return !!(this.bits[e3 >> 5] & 1 << (31 & e3));
    }
  }
  class o2 {
    constructor(e3, t3, r3) {
      this.start = e3, this.end = t3, this.original = r3, this.intro = "", this.outro = "", this.content = r3, this.storeName = false, this.edited = false, this.previous = null, this.next = null;
    }
    appendLeft(e3) {
      this.outro += e3;
    }
    appendRight(e3) {
      this.intro = this.intro + e3;
    }
    clone() {
      const e3 = new o2(this.start, this.end, this.original);
      return e3.intro = this.intro, e3.outro = this.outro, e3.content = this.content, e3.storeName = this.storeName, e3.edited = this.edited, e3;
    }
    contains(e3) {
      return this.start < e3 && e3 < this.end;
    }
    eachNext(e3) {
      let t3 = this;
      for (; t3; ) e3(t3), t3 = t3.next;
    }
    eachPrevious(e3) {
      let t3 = this;
      for (; t3; ) e3(t3), t3 = t3.previous;
    }
    edit(e3, t3, r3) {
      return this.content = e3, r3 || (this.intro = "", this.outro = ""), this.storeName = t3, this.edited = true, this;
    }
    prependLeft(e3) {
      this.outro = e3 + this.outro;
    }
    prependRight(e3) {
      this.intro = e3 + this.intro;
    }
    split(e3) {
      const t3 = e3 - this.start, r3 = this.original.slice(0, t3), n3 = this.original.slice(t3);
      this.original = r3;
      const s3 = new o2(e3, this.end, n3);
      return s3.outro = this.outro, this.outro = "", this.end = e3, this.edited ? (s3.edit("", false), this.content = "") : this.content = r3, s3.next = this.next, s3.next && (s3.next.previous = s3), s3.previous = this, this.next = s3, s3;
    }
    toString() {
      return this.intro + this.content + this.outro;
    }
    trimEnd(e3) {
      if (this.outro = this.outro.replace(e3, ""), this.outro.length) return true;
      const t3 = this.content.replace(e3, "");
      return t3.length ? (t3 !== this.content && (this.split(this.start + t3.length).edit("", void 0, true), this.edited && this.edit(t3, this.storeName, true)), true) : (this.edit("", void 0, true), this.intro = this.intro.replace(e3, ""), !!this.intro.length || void 0);
    }
    trimStart(e3) {
      if (this.intro = this.intro.replace(e3, ""), this.intro.length) return true;
      const t3 = this.content.replace(e3, "");
      if (t3.length) {
        if (t3 !== this.content) {
          const e4 = this.split(this.end - t3.length);
          this.edited && e4.edit(t3, this.storeName, true), this.edit("", void 0, true);
        }
        return true;
      }
      return this.edit("", void 0, true), this.outro = this.outro.replace(e3, ""), !!this.outro.length || void 0;
    }
  }
  function a2() {
    return "undefined" != typeof window && "function" == typeof window.btoa ? (e3) => window.btoa(unescape(encodeURIComponent(e3))) : "function" == typeof n2 ? (e3) => n2.from(e3, "utf-8").toString("base64") : () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
  const l = a2();
  class c {
    constructor(e3) {
      this.version = 3, this.file = e3.file, this.sources = e3.sources, this.sourcesContent = e3.sourcesContent, this.names = e3.names, this.mappings = s2.encode(e3.mappings), void 0 !== e3.x_google_ignoreList && (this.x_google_ignoreList = e3.x_google_ignoreList);
    }
    toString() {
      return JSON.stringify(this);
    }
    toUrl() {
      return "data:application/json;charset=utf-8;base64," + l(this.toString());
    }
  }
  function u(e3, t3) {
    const r3 = e3.split(/[/\\]/), n3 = t3.split(/[/\\]/);
    for (r3.pop(); r3[0] === n3[0]; ) r3.shift(), n3.shift();
    if (r3.length) {
      let e4 = r3.length;
      for (; e4--; ) r3[e4] = "..";
    }
    return r3.concat(n3).join("/");
  }
  const p = Object.prototype.toString;
  function d(e3) {
    return "[object Object]" === p.call(e3);
  }
  function f(e3) {
    const t3 = e3.split("\n"), r3 = [];
    for (let e4 = 0, n3 = 0; e4 < t3.length; e4++) r3.push(n3), n3 += t3[e4].length + 1;
    return function(e4) {
      let t4 = 0, n3 = r3.length;
      for (; t4 < n3; ) {
        const s4 = t4 + n3 >> 1;
        e4 < r3[s4] ? n3 = s4 : t4 = s4 + 1;
      }
      const s3 = t4 - 1;
      return { line: s3, column: e4 - r3[s3] };
    };
  }
  const h = /\w/;
  class m {
    constructor(e3) {
      this.hires = e3, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] = [], this.pending = null;
    }
    addEdit(e3, t3, r3, n3) {
      if (t3.length) {
        let s3 = t3.indexOf("\n", 0), i3 = -1;
        for (; s3 >= 0; ) {
          const o4 = [this.generatedCodeColumn, e3, r3.line, r3.column];
          n3 >= 0 && o4.push(n3), this.rawSegments.push(o4), this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, i3 = s3, s3 = t3.indexOf("\n", s3 + 1);
        }
        const o3 = [this.generatedCodeColumn, e3, r3.line, r3.column];
        n3 >= 0 && o3.push(n3), this.rawSegments.push(o3), this.advance(t3.slice(i3 + 1));
      } else this.pending && (this.rawSegments.push(this.pending), this.advance(t3));
      this.pending = null;
    }
    addUneditedChunk(e3, t3, r3, n3, s3) {
      let i3 = t3.start, o3 = true, a3 = false;
      for (; i3 < t3.end; ) {
        if (this.hires || o3 || s3.has(i3)) {
          const t4 = [this.generatedCodeColumn, e3, n3.line, n3.column];
          "boundary" === this.hires ? h.test(r3[i3]) ? a3 || (this.rawSegments.push(t4), a3 = true) : (this.rawSegments.push(t4), a3 = false) : this.rawSegments.push(t4);
        }
        "\n" === r3[i3] ? (n3.line += 1, n3.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, o3 = true) : (n3.column += 1, this.generatedCodeColumn += 1, o3 = false), i3 += 1;
      }
      this.pending = null;
    }
    advance(e3) {
      if (!e3) return;
      const t3 = e3.split("\n");
      if (t3.length > 1) {
        for (let e4 = 0; e4 < t3.length - 1; e4++) this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
      }
      this.generatedCodeColumn += t3[t3.length - 1].length;
    }
  }
  const y = "\n", g = { insertLeft: false, insertRight: false, storeName: false };
  class b {
    constructor(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const r3 = new o2(0, e3.length, e3);
      Object.defineProperties(this, { original: { writable: true, value: e3 }, outro: { writable: true, value: "" }, intro: { writable: true, value: "" }, firstChunk: { writable: true, value: r3 }, lastChunk: { writable: true, value: r3 }, lastSearchedChunk: { writable: true, value: r3 }, byStart: { writable: true, value: {} }, byEnd: { writable: true, value: {} }, filename: { writable: true, value: t3.filename }, indentExclusionRanges: { writable: true, value: t3.indentExclusionRanges }, sourcemapLocations: { writable: true, value: new i2() }, storedNames: { writable: true, value: {} }, indentStr: { writable: true, value: void 0 }, ignoreList: { writable: true, value: t3.ignoreList } }), this.byStart[0] = r3, this.byEnd[e3.length] = r3;
    }
    addSourcemapLocation(e3) {
      this.sourcemapLocations.add(e3);
    }
    append(e3) {
      if ("string" != typeof e3) throw new TypeError("outro content must be a string");
      return this.outro += e3, this;
    }
    appendLeft(e3, t3) {
      if ("string" != typeof t3) throw new TypeError("inserted content must be a string");
      this._split(e3);
      const r3 = this.byEnd[e3];
      return r3 ? r3.appendLeft(t3) : this.intro += t3, this;
    }
    appendRight(e3, t3) {
      if ("string" != typeof t3) throw new TypeError("inserted content must be a string");
      this._split(e3);
      const r3 = this.byStart[e3];
      return r3 ? r3.appendRight(t3) : this.outro += t3, this;
    }
    clone() {
      const e3 = new b(this.original, { filename: this.filename });
      let t3 = this.firstChunk, r3 = e3.firstChunk = e3.lastSearchedChunk = t3.clone();
      for (; t3; ) {
        e3.byStart[r3.start] = r3, e3.byEnd[r3.end] = r3;
        const n3 = t3.next, s3 = n3 && n3.clone();
        s3 && (r3.next = s3, s3.previous = r3, r3 = s3), t3 = n3;
      }
      return e3.lastChunk = r3, this.indentExclusionRanges && (e3.indentExclusionRanges = this.indentExclusionRanges.slice()), e3.sourcemapLocations = new i2(this.sourcemapLocations), e3.intro = this.intro, e3.outro = this.outro, e3;
    }
    generateDecodedMap(e3) {
      e3 = e3 || {};
      const t3 = Object.keys(this.storedNames), r3 = new m(e3.hires), n3 = f(this.original);
      return this.intro && r3.advance(this.intro), this.firstChunk.eachNext((e4) => {
        const s3 = n3(e4.start);
        e4.intro.length && r3.advance(e4.intro), e4.edited ? r3.addEdit(0, e4.content, s3, e4.storeName ? t3.indexOf(e4.original) : -1) : r3.addUneditedChunk(0, e4, this.original, s3, this.sourcemapLocations), e4.outro.length && r3.advance(e4.outro);
      }), { file: e3.file ? e3.file.split(/[/\\]/).pop() : void 0, sources: [e3.source ? u(e3.file || "", e3.source) : e3.file || ""], sourcesContent: e3.includeContent ? [this.original] : void 0, names: t3, mappings: r3.raw, x_google_ignoreList: this.ignoreList ? [0] : void 0 };
    }
    generateMap(e3) {
      return new c(this.generateDecodedMap(e3));
    }
    _ensureindentStr() {
      void 0 === this.indentStr && (this.indentStr = function(e3) {
        const t3 = e3.split("\n"), r3 = t3.filter((e4) => /^\t+/.test(e4)), n3 = t3.filter((e4) => /^ {2,}/.test(e4));
        if (0 === r3.length && 0 === n3.length) return null;
        if (r3.length >= n3.length) return "	";
        const s3 = n3.reduce((e4, t4) => {
          const r4 = /^ +/.exec(t4)[0].length;
          return Math.min(r4, e4);
        }, 1 / 0);
        return new Array(s3 + 1).join(" ");
      }(this.original));
    }
    _getRawIndentString() {
      return this._ensureindentStr(), this.indentStr;
    }
    getIndentString() {
      return this._ensureindentStr(), null === this.indentStr ? "	" : this.indentStr;
    }
    indent(e3, t3) {
      const r3 = /^[^\r\n]/gm;
      if (d(e3) && (t3 = e3, e3 = void 0), void 0 === e3 && (this._ensureindentStr(), e3 = this.indentStr || "	"), "" === e3) return this;
      const n3 = {};
      (t3 = t3 || {}).exclude && ("number" == typeof t3.exclude[0] ? [t3.exclude] : t3.exclude).forEach((e4) => {
        for (let t4 = e4[0]; t4 < e4[1]; t4 += 1) n3[t4] = true;
      });
      let s3 = false !== t3.indentStart;
      const i3 = (t4) => s3 ? `${e3}${t4}` : (s3 = true, t4);
      this.intro = this.intro.replace(r3, i3);
      let o3 = 0, a3 = this.firstChunk;
      for (; a3; ) {
        const t4 = a3.end;
        if (a3.edited) n3[o3] || (a3.content = a3.content.replace(r3, i3), a3.content.length && (s3 = "\n" === a3.content[a3.content.length - 1]));
        else for (o3 = a3.start; o3 < t4; ) {
          if (!n3[o3]) {
            const t5 = this.original[o3];
            "\n" === t5 ? s3 = true : "\r" !== t5 && s3 && (s3 = false, o3 === a3.start || (this._splitChunk(a3, o3), a3 = a3.next), a3.prependRight(e3));
          }
          o3 += 1;
        }
        o3 = a3.end, a3 = a3.next;
      }
      return this.outro = this.outro.replace(r3, i3), this;
    }
    insert() {
      throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
    }
    insertLeft(e3, t3) {
      return g.insertLeft || (g.insertLeft = true), this.appendLeft(e3, t3);
    }
    insertRight(e3, t3) {
      return g.insertRight || (g.insertRight = true), this.prependRight(e3, t3);
    }
    move(e3, t3, r3) {
      if (r3 >= e3 && r3 <= t3) throw new Error("Cannot move a selection inside itself");
      this._split(e3), this._split(t3), this._split(r3);
      const n3 = this.byStart[e3], s3 = this.byEnd[t3], i3 = n3.previous, o3 = s3.next, a3 = this.byStart[r3];
      if (!a3 && s3 === this.lastChunk) return this;
      const l2 = a3 ? a3.previous : this.lastChunk;
      return i3 && (i3.next = o3), o3 && (o3.previous = i3), l2 && (l2.next = n3), a3 && (a3.previous = s3), n3.previous || (this.firstChunk = s3.next), s3.next || (this.lastChunk = n3.previous, this.lastChunk.next = null), n3.previous = l2, s3.next = a3 || null, l2 || (this.firstChunk = n3), a3 || (this.lastChunk = s3), this;
    }
    overwrite(e3, t3, r3, n3) {
      return n3 = n3 || {}, this.update(e3, t3, r3, { ...n3, overwrite: !n3.contentOnly });
    }
    update(e3, t3, r3, n3) {
      if ("string" != typeof r3) throw new TypeError("replacement content must be a string");
      for (; e3 < 0; ) e3 += this.original.length;
      for (; t3 < 0; ) t3 += this.original.length;
      if (t3 > this.original.length) throw new Error("end is out of bounds");
      if (e3 === t3) throw new Error("Cannot overwrite a zero-length range  use appendLeft or prependRight instead");
      this._split(e3), this._split(t3), true === n3 && (g.storeName || (g.storeName = true), n3 = { storeName: true });
      const s3 = void 0 !== n3 && n3.storeName, i3 = void 0 !== n3 && n3.overwrite;
      if (s3) {
        const r4 = this.original.slice(e3, t3);
        Object.defineProperty(this.storedNames, r4, { writable: true, value: true, enumerable: true });
      }
      const a3 = this.byStart[e3], l2 = this.byEnd[t3];
      if (a3) {
        let e4 = a3;
        for (; e4 !== l2; ) {
          if (e4.next !== this.byStart[e4.end]) throw new Error("Cannot overwrite across a split point");
          e4 = e4.next, e4.edit("", false);
        }
        a3.edit(r3, s3, !i3);
      } else {
        const n4 = new o2(e3, t3, "").edit(r3, s3);
        l2.next = n4, n4.previous = l2;
      }
      return this;
    }
    prepend(e3) {
      if ("string" != typeof e3) throw new TypeError("outro content must be a string");
      return this.intro = e3 + this.intro, this;
    }
    prependLeft(e3, t3) {
      if ("string" != typeof t3) throw new TypeError("inserted content must be a string");
      this._split(e3);
      const r3 = this.byEnd[e3];
      return r3 ? r3.prependLeft(t3) : this.intro = t3 + this.intro, this;
    }
    prependRight(e3, t3) {
      if ("string" != typeof t3) throw new TypeError("inserted content must be a string");
      this._split(e3);
      const r3 = this.byStart[e3];
      return r3 ? r3.prependRight(t3) : this.outro = t3 + this.outro, this;
    }
    remove(e3, t3) {
      for (; e3 < 0; ) e3 += this.original.length;
      for (; t3 < 0; ) t3 += this.original.length;
      if (e3 === t3) return this;
      if (e3 < 0 || t3 > this.original.length) throw new Error("Character is out of bounds");
      if (e3 > t3) throw new Error("end must be greater than start");
      this._split(e3), this._split(t3);
      let r3 = this.byStart[e3];
      for (; r3; ) r3.intro = "", r3.outro = "", r3.edit(""), r3 = t3 > r3.end ? this.byStart[r3.end] : null;
      return this;
    }
    lastChar() {
      if (this.outro.length) return this.outro[this.outro.length - 1];
      let e3 = this.lastChunk;
      do {
        if (e3.outro.length) return e3.outro[e3.outro.length - 1];
        if (e3.content.length) return e3.content[e3.content.length - 1];
        if (e3.intro.length) return e3.intro[e3.intro.length - 1];
      } while (e3 = e3.previous);
      return this.intro.length ? this.intro[this.intro.length - 1] : "";
    }
    lastLine() {
      let e3 = this.outro.lastIndexOf(y);
      if (-1 !== e3) return this.outro.substr(e3 + 1);
      let t3 = this.outro, r3 = this.lastChunk;
      do {
        if (r3.outro.length > 0) {
          if (e3 = r3.outro.lastIndexOf(y), -1 !== e3) return r3.outro.substr(e3 + 1) + t3;
          t3 = r3.outro + t3;
        }
        if (r3.content.length > 0) {
          if (e3 = r3.content.lastIndexOf(y), -1 !== e3) return r3.content.substr(e3 + 1) + t3;
          t3 = r3.content + t3;
        }
        if (r3.intro.length > 0) {
          if (e3 = r3.intro.lastIndexOf(y), -1 !== e3) return r3.intro.substr(e3 + 1) + t3;
          t3 = r3.intro + t3;
        }
      } while (r3 = r3.previous);
      return e3 = this.intro.lastIndexOf(y), -1 !== e3 ? this.intro.substr(e3 + 1) + t3 : this.intro + t3;
    }
    slice() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.original.length;
      for (; e3 < 0; ) e3 += this.original.length;
      for (; t3 < 0; ) t3 += this.original.length;
      let r3 = "", n3 = this.firstChunk;
      for (; n3 && (n3.start > e3 || n3.end <= e3); ) {
        if (n3.start < t3 && n3.end >= t3) return r3;
        n3 = n3.next;
      }
      if (n3 && n3.edited && n3.start !== e3) throw new Error(`Cannot use replaced character ${e3} as slice start anchor.`);
      const s3 = n3;
      for (; n3; ) {
        !n3.intro || s3 === n3 && n3.start !== e3 || (r3 += n3.intro);
        const i3 = n3.start < t3 && n3.end >= t3;
        if (i3 && n3.edited && n3.end !== t3) throw new Error(`Cannot use replaced character ${t3} as slice end anchor.`);
        const o3 = s3 === n3 ? e3 - n3.start : 0, a3 = i3 ? n3.content.length + t3 - n3.end : n3.content.length;
        if (r3 += n3.content.slice(o3, a3), !n3.outro || i3 && n3.end !== t3 || (r3 += n3.outro), i3) break;
        n3 = n3.next;
      }
      return r3;
    }
    snip(e3, t3) {
      const r3 = this.clone();
      return r3.remove(0, e3), r3.remove(t3, r3.original.length), r3;
    }
    _split(e3) {
      if (this.byStart[e3] || this.byEnd[e3]) return;
      let t3 = this.lastSearchedChunk;
      const r3 = e3 > t3.end;
      for (; t3; ) {
        if (t3.contains(e3)) return this._splitChunk(t3, e3);
        t3 = r3 ? this.byStart[t3.end] : this.byEnd[t3.start];
      }
    }
    _splitChunk(e3, t3) {
      if (e3.edited && e3.content.length) {
        const r4 = f(this.original)(t3);
        throw new Error(`Cannot split a chunk that has already been edited (${r4.line}:${r4.column}  "${e3.original}")`);
      }
      const r3 = e3.split(t3);
      return this.byEnd[t3] = e3, this.byStart[t3] = r3, this.byEnd[r3.end] = r3, e3 === this.lastChunk && (this.lastChunk = r3), this.lastSearchedChunk = e3, true;
    }
    toString() {
      let e3 = this.intro, t3 = this.firstChunk;
      for (; t3; ) e3 += t3.toString(), t3 = t3.next;
      return e3 + this.outro;
    }
    isEmpty() {
      let e3 = this.firstChunk;
      do {
        if (e3.intro.length && e3.intro.trim() || e3.content.length && e3.content.trim() || e3.outro.length && e3.outro.trim()) return false;
      } while (e3 = e3.next);
      return true;
    }
    length() {
      let e3 = this.firstChunk, t3 = 0;
      do {
        t3 += e3.intro.length + e3.content.length + e3.outro.length;
      } while (e3 = e3.next);
      return t3;
    }
    trimLines() {
      return this.trim("[\\r\\n]");
    }
    trim(e3) {
      return this.trimStart(e3).trimEnd(e3);
    }
    trimEndAborted(e3) {
      const t3 = new RegExp((e3 || "\\s") + "+$");
      if (this.outro = this.outro.replace(t3, ""), this.outro.length) return true;
      let r3 = this.lastChunk;
      do {
        const e4 = r3.end, n3 = r3.trimEnd(t3);
        if (r3.end !== e4 && (this.lastChunk === r3 && (this.lastChunk = r3.next), this.byEnd[r3.end] = r3, this.byStart[r3.next.start] = r3.next, this.byEnd[r3.next.end] = r3.next), n3) return true;
        r3 = r3.previous;
      } while (r3);
      return false;
    }
    trimEnd(e3) {
      return this.trimEndAborted(e3), this;
    }
    trimStartAborted(e3) {
      const t3 = new RegExp("^" + (e3 || "\\s") + "+");
      if (this.intro = this.intro.replace(t3, ""), this.intro.length) return true;
      let r3 = this.firstChunk;
      do {
        const e4 = r3.end, n3 = r3.trimStart(t3);
        if (r3.end !== e4 && (r3 === this.lastChunk && (this.lastChunk = r3.next), this.byEnd[r3.end] = r3, this.byStart[r3.next.start] = r3.next, this.byEnd[r3.next.end] = r3.next), n3) return true;
        r3 = r3.next;
      } while (r3);
      return false;
    }
    trimStart(e3) {
      return this.trimStartAborted(e3), this;
    }
    hasChanged() {
      return this.original !== this.toString();
    }
    _replaceRegexp(e3, t3) {
      function r3(e4, r4) {
        return "string" == typeof t3 ? t3.replace(/\$(\$|&|\d+)/g, (t4, r5) => "$" === r5 ? "$" : "&" === r5 ? e4[0] : +r5 < e4.length ? e4[+r5] : `$${r5}`) : t3(...e4, e4.index, r4, e4.groups);
      }
      if (e3.global) (function(e4, t4) {
        let r4;
        const n3 = [];
        for (; r4 = e4.exec(t4); ) n3.push(r4);
        return n3;
      })(e3, this.original).forEach((e4) => {
        null != e4.index && this.overwrite(e4.index, e4.index + e4[0].length, r3(e4, this.original));
      });
      else {
        const t4 = this.original.match(e3);
        t4 && null != t4.index && this.overwrite(t4.index, t4.index + t4[0].length, r3(t4, this.original));
      }
      return this;
    }
    _replaceString(e3, t3) {
      const { original: r3 } = this, n3 = r3.indexOf(e3);
      return -1 !== n3 && this.overwrite(n3, n3 + e3.length, t3), this;
    }
    replace(e3, t3) {
      return "string" == typeof e3 ? this._replaceString(e3, t3) : this._replaceRegexp(e3, t3);
    }
    _replaceAllString(e3, t3) {
      const { original: r3 } = this, n3 = e3.length;
      for (let s3 = r3.indexOf(e3); -1 !== s3; s3 = r3.indexOf(e3, s3 + n3)) this.overwrite(s3, s3 + n3, t3);
      return this;
    }
    replaceAll(e3, t3) {
      if ("string" == typeof e3) return this._replaceAllString(e3, t3);
      if (!e3.global) throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");
      return this._replaceRegexp(e3, t3);
    }
  }
  const v = Object.prototype.hasOwnProperty;
  class E {
    constructor() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.intro = e3.intro || "", this.separator = void 0 !== e3.separator ? e3.separator : "\n", this.sources = [], this.uniqueSources = [], this.uniqueSourceIndexByFilename = {};
    }
    addSource(e3) {
      if (e3 instanceof b) return this.addSource({ content: e3, filename: e3.filename, separator: this.separator });
      if (!d(e3) || !e3.content) throw new Error("bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`");
      if (["filename", "ignoreList", "indentExclusionRanges", "separator"].forEach((t3) => {
        v.call(e3, t3) || (e3[t3] = e3.content[t3]);
      }), void 0 === e3.separator && (e3.separator = this.separator), e3.filename) if (v.call(this.uniqueSourceIndexByFilename, e3.filename)) {
        const t3 = this.uniqueSources[this.uniqueSourceIndexByFilename[e3.filename]];
        if (e3.content.original !== t3.content) throw new Error(`Illegal source: same filename (${e3.filename}), different contents`);
      } else this.uniqueSourceIndexByFilename[e3.filename] = this.uniqueSources.length, this.uniqueSources.push({ filename: e3.filename, content: e3.content.original });
      return this.sources.push(e3), this;
    }
    append(e3, t3) {
      return this.addSource({ content: new b(e3), separator: t3 && t3.separator || "" }), this;
    }
    clone() {
      const e3 = new E({ intro: this.intro, separator: this.separator });
      return this.sources.forEach((t3) => {
        e3.addSource({ filename: t3.filename, content: t3.content.clone(), separator: t3.separator });
      }), e3;
    }
    generateDecodedMap() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      const t3 = [];
      let r3;
      this.sources.forEach((e4) => {
        Object.keys(e4.content.storedNames).forEach((e5) => {
          ~t3.indexOf(e5) || t3.push(e5);
        });
      });
      const n3 = new m(e3.hires);
      return this.intro && n3.advance(this.intro), this.sources.forEach((e4, s3) => {
        s3 > 0 && n3.advance(this.separator);
        const i3 = e4.filename ? this.uniqueSourceIndexByFilename[e4.filename] : -1, o3 = e4.content, a3 = f(o3.original);
        o3.intro && n3.advance(o3.intro), o3.firstChunk.eachNext((r4) => {
          const s4 = a3(r4.start);
          r4.intro.length && n3.advance(r4.intro), e4.filename ? r4.edited ? n3.addEdit(i3, r4.content, s4, r4.storeName ? t3.indexOf(r4.original) : -1) : n3.addUneditedChunk(i3, r4, o3.original, s4, o3.sourcemapLocations) : n3.advance(r4.content), r4.outro.length && n3.advance(r4.outro);
        }), o3.outro && n3.advance(o3.outro), e4.ignoreList && -1 !== i3 && (void 0 === r3 && (r3 = []), r3.push(i3));
      }), { file: e3.file ? e3.file.split(/[/\\]/).pop() : void 0, sources: this.uniqueSources.map((t4) => e3.file ? u(e3.file, t4.filename) : t4.filename), sourcesContent: this.uniqueSources.map((t4) => e3.includeContent ? t4.content : null), names: t3, mappings: n3.raw, x_google_ignoreList: r3 };
    }
    generateMap(e3) {
      return new c(this.generateDecodedMap(e3));
    }
    getIndentString() {
      const e3 = {};
      return this.sources.forEach((t3) => {
        const r3 = t3.content._getRawIndentString();
        null !== r3 && (e3[r3] || (e3[r3] = 0), e3[r3] += 1);
      }), Object.keys(e3).sort((t3, r3) => e3[t3] - e3[r3])[0] || "	";
    }
    indent(e3) {
      if (arguments.length || (e3 = this.getIndentString()), "" === e3) return this;
      let t3 = !this.intro || "\n" === this.intro.slice(-1);
      return this.sources.forEach((r3, n3) => {
        const s3 = void 0 !== r3.separator ? r3.separator : this.separator, i3 = t3 || n3 > 0 && /\r?\n$/.test(s3);
        r3.content.indent(e3, { exclude: r3.indentExclusionRanges, indentStart: i3 }), t3 = "\n" === r3.content.lastChar();
      }), this.intro && (this.intro = e3 + this.intro.replace(/^[^\n]/gm, (t4, r3) => r3 > 0 ? e3 + t4 : t4)), this;
    }
    prepend(e3) {
      return this.intro = e3 + this.intro, this;
    }
    toString() {
      const e3 = this.sources.map((e4, t3) => {
        const r3 = void 0 !== e4.separator ? e4.separator : this.separator;
        return (t3 > 0 ? r3 : "") + e4.content.toString();
      }).join("");
      return this.intro + e3;
    }
    isEmpty() {
      return !(this.intro.length && this.intro.trim() || this.sources.some((e3) => !e3.content.isEmpty()));
    }
    length() {
      return this.sources.reduce((e3, t3) => e3 + t3.content.length(), this.intro.length);
    }
    trimLines() {
      return this.trim("[\\r\\n]");
    }
    trim(e3) {
      return this.trimStart(e3).trimEnd(e3);
    }
    trimStart(e3) {
      const t3 = new RegExp("^" + (e3 || "\\s") + "+");
      if (this.intro = this.intro.replace(t3, ""), !this.intro) {
        let t4, r3 = 0;
        do {
          if (t4 = this.sources[r3++], !t4) break;
        } while (!t4.content.trimStartAborted(e3));
      }
      return this;
    }
    trimEnd(e3) {
      const t3 = new RegExp((e3 || "\\s") + "+$");
      let r3, n3 = this.sources.length - 1;
      do {
        if (r3 = this.sources[n3--], !r3) {
          this.intro = this.intro.replace(t3, "");
          break;
        }
      } while (!r3.content.trimEndAborted(e3));
      return this;
    }
  }
  b.Bundle = E, b.SourceMap = c, b.default = b, e2.exports = b;
}, (e2, t2, r2) => {
  var n2, s2 = Object.defineProperty, i2 = Object.getOwnPropertyDescriptor, o2 = Object.getOwnPropertyNames, a2 = Object.prototype.hasOwnProperty, l = {};
  ((e3, t3) => {
    for (var r3 in t3) s2(e3, r3, { get: t3[r3], enumerable: true });
  })(l, { default: () => f }), e2.exports = (n2 = l, ((e3, t3, r3, n3) => {
    if (t3 && "object" == typeof t3 || "function" == typeof t3) for (let r4 of o2(t3)) a2.call(e3, r4) || void 0 === r4 || s2(e3, r4, { get: () => t3[r4], enumerable: !(n3 = i2(t3, r4)) || n3.enumerable });
    return e3;
  })(s2({}, "__esModule", { value: true }), n2));
  var c = r2(21), u = r2(308), p = r2(36), d = r2(93), f = (0, r2(16).declare)((e3, t3) => {
    let r3, n3, { types: s3 } = e3;
    return { name: "babel-plugin-resolve-type", pre(e4) {
      const s4 = e4.opts.filename || "unknown.js";
      n3 = /* @__PURE__ */ new Set(), r3 = { filename: s4, source: e4.code, options: t3, ast: e4.ast.program.body, isCE: false, error(t4, r4) {
        throw new Error(`[@vue/babel-plugin-resolve-type] ${t4}

${s4}
${(0, p.codeFrameColumns)(e4.code, { start: { line: r4.loc.start.line, column: r4.loc.start.column + 1 }, end: { line: r4.loc.end.line, column: r4.loc.end.column + 1 } })}`);
      }, helper: (e5) => (n3.add(e5), `_${e5}`), getString: (t4) => e4.code.slice(t4.start, t4.end), propsTypeDecl: void 0, propsRuntimeDefaults: void 0, propsDestructuredBindings: {}, emitsTypeDecl: void 0 };
    }, visitor: { CallExpression(e4) {
      if (!r3) throw new Error("[@vue/babel-plugin-resolve-type] context is not loaded.");
      const { node: t4 } = e4;
      if (!s3.isIdentifier(t4.callee, { name: "defineComponent" })) return;
      if (!m(e4)) return;
      const n4 = t4.arguments[0];
      if (!n4 || !s3.isFunction(n4)) return;
      let i3 = t4.arguments[1];
      i3 || (i3 = s3.objectExpression([]), t4.arguments.push(i3)), t4.arguments[1] = function(e5, t5) {
        const n5 = e5.params[0];
        if (!n5) return;
        if ("AssignmentPattern" === n5.type ? (r3.propsTypeDecl = h(n5.left), r3.propsRuntimeDefaults = n5.right) : r3.propsTypeDecl = h(n5), !r3.propsTypeDecl) return;
        const i4 = (0, u.extractRuntimeProps)(r3);
        if (!i4) return;
        const o3 = (0, c.parseExpression)(i4);
        return y(s3, t5, s3.objectProperty(s3.identifier("props"), o3));
      }(n4, i3) || i3, t4.arguments[1] = function(e5, t5) {
        var n5;
        const i4 = e5.params[1] && h(e5.params[1]);
        if (!i4 || !s3.isTSTypeReference(i4) || !s3.isIdentifier(i4.typeName, { name: "SetupContext" })) return;
        const o3 = null == (n5 = i4.typeParameters) ? void 0 : n5.params[0];
        if (!o3) return;
        r3.emitsTypeDecl = o3;
        const a3 = (0, u.extractRuntimeEmits)(r3), l2 = s3.arrayExpression(Array.from(a3).map((e6) => s3.stringLiteral(e6)));
        return y(s3, t5, s3.objectProperty(s3.identifier("emits"), l2));
      }(n4, t4.arguments[1]) || i3;
    }, VariableDeclarator(e4) {
      !function(e5) {
        var t4;
        const r4 = e5.get("id"), n4 = e5.get("init");
        if (!(r4 && r4.isIdentifier() && n4 && n4.isCallExpression())) return;
        if (!(null == (t4 = n4.get("callee")) ? void 0 : t4.isIdentifier({ name: "defineComponent" }))) return;
        if (!m(n4)) return;
        const i3 = s3.objectProperty(s3.identifier("name"), s3.stringLiteral(r4.node.name)), { arguments: o3 } = n4.node;
        0 !== o3.length && (1 === o3.length && n4.node.arguments.push(s3.objectExpression([])), o3[1] = y(s3, o3[1], i3));
      }(e4);
    } }, post(e4) {
      for (const t4 of n3) (0, d.addNamed)(e4.path, `_${t4}`, "vue");
    } };
  });
  function h(e3) {
    if ("typeAnnotation" in e3 && e3.typeAnnotation && "TSTypeAnnotation" === e3.typeAnnotation.type) return e3.typeAnnotation.typeAnnotation;
  }
  function m(e3) {
    var t3;
    const r3 = null == (t3 = e3.scope.getBinding("defineComponent")) ? void 0 : t3.path.parent;
    return !r3 || "ImportDeclaration" === r3.type && /^@?vue(\/|$)/.test(r3.source.value);
  }
  function y(e3, t3, r3) {
    if (e3.isObjectExpression(t3)) t3.properties.unshift(r3);
    else if (e3.isExpression(t3)) return e3.objectExpression([r3, e3.spreadElement(t3)]);
    return t3;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.buildScopeIIFE = function(e3, t3) {
    const r3 = [], s2 = [];
    for (const t4 of e3) r3.push(n2.types.identifier(t4)), s2.push(n2.types.identifier(t4));
    return n2.types.returnStatement(n2.types.callExpression(n2.types.arrowFunctionExpression(s2, t3), r3));
  }, t2.collectShadowedParamsNames = function(e3, t3, r3) {
    for (const s2 of Object.keys(e3.getBindingIdentifiers())) {
      var n3;
      const e4 = null == (n3 = t3.bindings[s2]) ? void 0 : n3.constantViolations;
      if (e4) for (const t4 of e4) {
        const e5 = t4.node;
        switch (e5.type) {
          case "VariableDeclarator":
            if (null === e5.init) {
              const e6 = t4.parentPath;
              if (!e6.parentPath.isFor() || e6.parentPath.get("body") === e6) {
                t4.remove();
                break;
              }
            }
            r3.add(s2);
            break;
          case "FunctionDeclaration":
            r3.add(s2);
        }
      }
    }
  }, t2.iifeVisitor = void 0;
  var n2 = r2(1);
  t2.iifeVisitor = { "ReferencedIdentifier|BindingIdentifier"(e3, t3) {
    const { scope: r3, node: n3 } = e3, { name: s2 } = n3;
    ("eval" === s2 || r3.getBinding(s2) === t3.scope.parent.getBinding(s2) && t3.scope.hasOwnBinding(s2)) && (t3.needsOuterBinding = true, e3.stop());
  }, "TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration": (e3) => e3.skip() };
}, (e2, t2, r2) => {
  e2.exports = r2(143);
}, (e2) => {
  function t2(e3) {
    var t3 = new Error("Cannot find module '" + e3 + "'");
    throw t3.code = "MODULE_NOT_FOUND", t3;
  }
  t2.keys = () => [], t2.resolve = t2, t2.id = 329, e2.exports = t2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.buildDynamicImport = function(e3, t3, r3, s2) {
    const i2 = n2.types.isCallExpression(e3) ? e3.arguments[0] : e3.source;
    if (n2.types.isStringLiteral(i2) || n2.types.isTemplateLiteral(i2) && 0 === i2.quasis.length) return t3 ? n2.template.expression.ast`
        Promise.resolve().then(() => ${s2(i2)})
      ` : s2(i2);
    const o2 = n2.types.isTemplateLiteral(i2) ? n2.types.identifier("specifier") : n2.types.templateLiteral([n2.types.templateElement({ raw: "" }), n2.types.templateElement({ raw: "" })], [n2.types.identifier("specifier")]);
    return t3 ? n2.template.expression.ast`
      (specifier =>
        new Promise(r => r(${o2}))
          .then(s => ${s2(n2.types.identifier("s"))})
      )(${i2})
    ` : r3 ? n2.template.expression.ast`
      (specifier =>
        new Promise(r => r(${s2(o2)}))
      )(${i2})
    ` : n2.template.expression.ast`
      (specifier => ${s2(o2)})(${i2})
    `;
  };
  var n2 = r2(1);
  t2.getDynamicImportSource = function(e3) {
    const [t3] = e3.arguments;
    return n2.types.isStringLiteral(t3) || n2.types.isTemplateLiteral(t3) ? t3 : n2.template.expression.ast`\`\${${t3}}\``;
  };
}, (e2, t2, r2) => {
  t2.a = void 0;
  var n2 = r2(16), s2 = r2(495), i2 = r2(298), o2 = r2(500), a2 = r2(305), l = r2(306), c = r2(501);
  function u(e3) {
    switch (e3.parent.type) {
      case "TSTypeReference":
      case "TSExpressionWithTypeArguments":
      case "TSTypeQuery":
        return true;
      case "TSQualifiedName":
        return "TSImportEqualsDeclaration" !== e3.parentPath.findParent((e4) => "TSQualifiedName" !== e4.type).type;
      case "ExportSpecifier":
        return "type" === e3.parent.exportKind || "type" === e3.parentPath.parent.exportKind;
      default:
        return false;
    }
  }
  const p = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakSet();
  function f(e3) {
    const t3 = e3.getBindingIdentifiers();
    for (const r3 of Object.keys(t3)) {
      const n3 = e3.scope.getBinding(r3);
      n3 && n3.identifier === t3[r3] && n3.scope.removeBinding(r3);
    }
    e3.opts.noScope = true, e3.remove(), e3.opts.noScope = false;
  }
  function h(e3, t3, r3, n3) {
    let s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "";
    if ("commonjs" !== t3.file.get("@babel/plugin-transform-modules-*")) throw e3.buildCodeFrameError(`\`${r3}\` is only supported when compiling modules to CommonJS.
Please consider using \`${n3}\`${s3}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`);
  }
  t2.a = (0, n2.declare)((e3, t3) => {
    const { types: r3, template: n3 } = e3;
    e3.assertVersion(7);
    const m = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/, { allowNamespaces: y = true, jsxPragma: g = "React.createElement", jsxPragmaFrag: b = "React.Fragment", onlyRemoveTypeImports: v = false, optimizeConstEnums: E = false } = t3;
    var { allowDeclareFields: S = false } = t3;
    const x = { field(e4) {
      const { node: t4 } = e4;
      if (!S && t4.declare) throw e4.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
      if (t4.declare) {
        if (t4.value) throw e4.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
        t4.decorators || e4.remove();
      } else if (t4.definite) {
        if (t4.value) throw e4.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
        S || t4.decorators || r3.isClassPrivateProperty(t4) || e4.remove();
      } else t4.abstract ? e4.remove() : S || t4.value || t4.decorators || r3.isClassPrivateProperty(t4) || e4.remove();
      t4.accessibility && (t4.accessibility = null), t4.abstract && (t4.abstract = null), t4.readonly && (t4.readonly = null), t4.optional && (t4.optional = null), t4.typeAnnotation && (t4.typeAnnotation = null), t4.definite && (t4.definite = null), t4.declare && (t4.declare = null), t4.override && (t4.override = null);
    }, method(e4) {
      let { node: t4 } = e4;
      t4.accessibility && (t4.accessibility = null), t4.abstract && (t4.abstract = null), t4.optional && (t4.optional = null), t4.override && (t4.override = null);
    }, constructor(e4, t4) {
      e4.node.accessibility && (e4.node.accessibility = null);
      const s3 = [], { scope: o3 } = e4;
      for (const t5 of e4.get("params")) {
        const e5 = t5.node;
        if ("TSParameterProperty" === e5.type) {
          const i3 = e5.parameter;
          if (d.has(i3)) continue;
          let a3;
          if (d.add(i3), r3.isIdentifier(i3)) a3 = i3;
          else {
            if (!r3.isAssignmentPattern(i3) || !r3.isIdentifier(i3.left)) throw t5.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
            a3 = i3.left;
          }
          s3.push(n3.statement.ast`
              this.${r3.cloneNode(a3)} = ${r3.cloneNode(a3)}
            `), t5.replaceWith(t5.get("parameter")), o3.registerBinding("param", t5);
        }
      }
      (0, i2.injectInitialization)(t4, e4, s3);
    } };
    return { name: "transform-typescript", inherits: s2.default, visitor: { Pattern: w, Identifier: w, RestElement: w, Program: { enter(e4, t4) {
      const { file: r4 } = t4;
      let n4 = null, s3 = null;
      const i3 = e4.scope;
      if (l.GLOBAL_TYPES.has(i3) || l.GLOBAL_TYPES.set(i3, /* @__PURE__ */ new Set()), r4.ast.comments) for (const e5 of r4.ast.comments) {
        const t5 = m.exec(e5.value);
        t5 && (t5[1] ? s3 = t5[2] : n4 = t5[2]);
      }
      let o3 = n4 || g;
      o3 && ([o3] = o3.split("."));
      let a3 = s3 || b;
      a3 && ([a3] = a3.split("."));
      for (let r5 of e4.get("body")) if (r5.isImportDeclaration()) {
        if (p.has(t4.file.ast.program) || p.set(t4.file.ast.program, true), "type" === r5.node.importKind) {
          for (const e5 of r5.node.specifiers) (0, l.registerGlobalType)(i3, e5.local.name);
          r5.remove();
          continue;
        }
        const n5 = /* @__PURE__ */ new Set(), s4 = r5.node.specifiers.length, c2 = () => s4 > 0 && s4 === n5.size;
        for (const e5 of r5.node.specifiers) if ("ImportSpecifier" === e5.type && "type" === e5.importKind) {
          (0, l.registerGlobalType)(i3, e5.local.name);
          const t5 = r5.scope.getBinding(e5.local.name);
          t5 && n5.add(t5.path);
        }
        if (v) p.set(e4.node, false);
        else {
          if (0 === r5.node.specifiers.length) {
            p.set(e4.node, false);
            continue;
          }
          for (const t5 of r5.node.specifiers) {
            const s5 = r5.scope.getBinding(t5.local.name);
            s5 && !n5.has(s5.path) && (P({ binding: s5, programPath: e4, pragmaImportName: o3, pragmaFragImportName: a3 }) ? n5.add(s5.path) : p.set(e4.node, false));
          }
        }
        if (c2() && !v) r5.remove();
        else for (const e5 of n5) e5.remove();
      } else if (r5.isExportDeclaration() && (r5 = r5.get("declaration")), r5.isVariableDeclaration({ declare: true })) for (const e5 of Object.keys(r5.getBindingIdentifiers())) (0, l.registerGlobalType)(i3, e5);
      else (r5.isTSTypeAliasDeclaration() || r5.isTSDeclareFunction() && r5.get("id").isIdentifier() || r5.isTSInterfaceDeclaration() || r5.isClassDeclaration({ declare: true }) || r5.isTSEnumDeclaration({ declare: true }) || r5.isTSModuleDeclaration({ declare: true }) && r5.get("id").isIdentifier()) && (0, l.registerGlobalType)(i3, r5.node.id.name);
    }, exit(e4) {
      "module" === e4.node.sourceType && p.get(e4.node) && e4.pushContainer("body", r3.exportNamedDeclaration());
    } }, ExportNamedDeclaration(e4, t4) {
      if (p.has(t4.file.ast.program) || p.set(t4.file.ast.program, true), "type" !== e4.node.exportKind) if (e4.node.source && e4.node.specifiers.length > 0 && e4.node.specifiers.every((e5) => "ExportSpecifier" === e5.type && "type" === e5.exportKind)) e4.remove();
      else if (!e4.node.source && e4.node.specifiers.length > 0 && e4.node.specifiers.every((t5) => r3.isExportSpecifier(t5) && (0, l.isGlobalType)(e4, t5.local.name))) e4.remove();
      else {
        if (r3.isTSModuleDeclaration(e4.node.declaration)) {
          const t5 = e4.node.declaration, { id: n4 } = t5;
          if (r3.isIdentifier(n4)) if (e4.scope.hasOwnBinding(n4.name)) e4.replaceWith(t5);
          else {
            const [s3] = e4.replaceWithMultiple([r3.exportNamedDeclaration(r3.variableDeclaration("let", [r3.variableDeclarator(r3.cloneNode(n4))])), t5]);
            e4.scope.registerDeclaration(s3);
          }
        }
        p.set(t4.file.ast.program, false);
      }
      else e4.remove();
    }, ExportAllDeclaration(e4) {
      "type" === e4.node.exportKind && e4.remove();
    }, ExportSpecifier(e4) {
      (!e4.parent.source && (0, l.isGlobalType)(e4, e4.node.local.name) || "type" === e4.node.exportKind) && e4.remove();
    }, ExportDefaultDeclaration(e4, t4) {
      p.has(t4.file.ast.program) || p.set(t4.file.ast.program, true), r3.isIdentifier(e4.node.declaration) && (0, l.isGlobalType)(e4, e4.node.declaration.name) ? e4.remove() : p.set(t4.file.ast.program, false);
    }, TSDeclareFunction(e4) {
      f(e4);
    }, TSDeclareMethod(e4) {
      f(e4);
    }, VariableDeclaration(e4) {
      e4.node.declare && f(e4);
    }, VariableDeclarator(e4) {
      let { node: t4 } = e4;
      t4.definite && (t4.definite = null);
    }, TSIndexSignature(e4) {
      e4.remove();
    }, ClassDeclaration(e4) {
      const { node: t4 } = e4;
      t4.declare && f(e4);
    }, Class(e4) {
      const { node: t4 } = e4;
      t4.typeParameters && (t4.typeParameters = null), t4.superTypeParameters && (t4.superTypeParameters = null), t4.implements && (t4.implements = null), t4.abstract && (t4.abstract = null), e4.get("body.body").forEach((t5) => {
        t5.isClassMethod() || t5.isClassPrivateMethod() ? "constructor" === t5.node.kind ? x.constructor(t5, e4) : x.method(t5) : (t5.isClassProperty() || t5.isClassPrivateProperty() || t5.isClassAccessorProperty()) && x.field(t5);
      });
    }, Function(e4) {
      const { node: t4 } = e4;
      t4.typeParameters && (t4.typeParameters = null), t4.returnType && (t4.returnType = null);
      const n4 = t4.params;
      n4.length > 0 && r3.isIdentifier(n4[0], { name: "this" }) && n4.shift();
    }, TSModuleDeclaration(e4) {
      (0, c.default)(e4, y);
    }, TSInterfaceDeclaration(e4) {
      e4.remove();
    }, TSTypeAliasDeclaration(e4) {
      e4.remove();
    }, TSEnumDeclaration(e4) {
      E && e4.node.const ? (0, o2.default)(e4, r3) : (0, a2.default)(e4, r3);
    }, TSImportEqualsDeclaration(e4, t4) {
      const { id: n4, moduleReference: s3 } = e4.node;
      let i3, o3;
      r3.isTSExternalModuleReference(s3) ? (h(e4, t4, `import ${n4.name} = require(...);`, `import ${n4.name} from '...';`, " alongside Typescript's --allowSyntheticDefaultImports option"), i3 = r3.callExpression(r3.identifier("require"), [s3.expression]), o3 = "const") : (i3 = T(s3), o3 = "var"), e4.replaceWith(r3.variableDeclaration(o3, [r3.variableDeclarator(n4, i3)])), e4.scope.registerDeclaration(e4);
    }, TSExportAssignment(e4, t4) {
      h(e4, t4, "export = <value>;", "export default <value>;"), e4.replaceWith(n3.statement.ast`module.exports = ${e4.node.expression}`);
    }, TSTypeAssertion(e4) {
      e4.replaceWith(e4.node.expression);
    }, ["TSAsExpression" + (r3.tsSatisfiesExpression ? "|TSSatisfiesExpression" : "")](e4) {
      let { node: t4 } = e4;
      do {
        t4 = t4.expression;
      } while (r3.isTSAsExpression(t4) || null != r3.isTSSatisfiesExpression && r3.isTSSatisfiesExpression(t4));
      e4.replaceWith(t4);
    }, [e3.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](e4) {
      e4.replaceWith(e4.node.expression);
    }, CallExpression(e4) {
      e4.node.typeParameters = null;
    }, OptionalCallExpression(e4) {
      e4.node.typeParameters = null;
    }, NewExpression(e4) {
      e4.node.typeParameters = null;
    }, JSXOpeningElement(e4) {
      e4.node.typeParameters = null;
    }, TaggedTemplateExpression(e4) {
      e4.node.typeParameters = null;
    } } };
    function T(e4) {
      return r3.isTSQualifiedName(e4) ? r3.memberExpression(T(e4.left), e4.right) : e4;
    }
    function w(e4) {
      let { node: t4 } = e4;
      t4.typeAnnotation && (t4.typeAnnotation = null), r3.isIdentifier(t4) && t4.optional && (t4.optional = null);
    }
    function P(e4) {
      let { binding: t4, programPath: r4, pragmaImportName: n4, pragmaFragImportName: s3 } = e4;
      for (const e5 of t4.referencePaths) if (!u(e5)) return false;
      if (t4.identifier.name !== n4 && t4.identifier.name !== s3) return true;
      let i3 = false;
      return r4.traverse({ "JSXElement|JSXFragment"(e5) {
        i3 = true, e5.stop();
      } }), !i3;
    }
  });
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(16), s2 = r2(298);
  function i2(e3, t3) {
    let r3, n3 = 1;
    do {
      r3 = e3._generateUid("", n3), n3++;
    } while (t3.has(r3));
    return r3;
  }
  t2.default = (0, n2.declare)((e3) => {
    let { types: t3, template: n3, assertVersion: o2 } = e3;
    return o2("^7.12.0"), { name: "transform-class-static-block", inherits: r2(562).a, pre() {
      (0, s2.enableFeature)(this.file, s2.FEATURES.staticBlocks, false);
    }, visitor: { ClassBody(e4) {
      const { scope: r3 } = e4, s3 = /* @__PURE__ */ new Set(), o3 = e4.get("body");
      for (const e5 of o3) e5.isPrivate() && s3.add(e5.get("key.id").node.name);
      for (const e5 of o3) {
        if (!e5.isStaticBlock()) continue;
        const o4 = i2(r3, s3);
        s3.add(o4);
        const a2 = t3.privateName(t3.identifier(o4));
        let l;
        const c = e5.node.body;
        l = 1 === c.length && t3.isExpressionStatement(c[0]) ? t3.inheritsComments(c[0].expression, c[0]) : n3.expression.ast`(() => { ${c} })()`, e5.replaceWith(t3.classPrivateProperty(a2, l, [], true));
      }
    } } };
  });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "convertFunctionParams", { enumerable: true, get: function() {
    return s2.default;
  } }), t2.default = void 0;
  var n2 = r2(16), s2 = r2(563), i2 = r2(564);
  t2.default = (0, n2.declare)((e3, t3) => {
    var r3, n3;
    e3.assertVersion(7);
    const o2 = null != (r3 = e3.assumption("ignoreFunctionLength")) ? r3 : t3.loose, a2 = null == (n3 = e3.assumption("noNewArrows")) || n3;
    return { name: "transform-parameters", visitor: { Function(e4) {
      if (e4.isArrowFunctionExpression() && e4.get("params").some((e5) => e5.isRestElement() || e5.isAssignmentPattern()) && (e4.arrowFunctionToExpression({ allowInsertArrowWithRest: false, noNewArrows: a2 }), !e4.isFunctionExpression())) return;
      const t4 = (0, i2.default)(e4), r4 = (0, s2.default)(e4, o2);
      (t4 || r4) && e4.scope.crawl();
    } } };
  });
}, () => {
}, (e2, t2, r2) => {
  r2.d(t2, { a: () => Ae, b: () => Pe, c: () => ve, d: () => Ee });
  var n2 = r2(10), s2 = r2(1), i2 = r2(21), o2 = r2(36), a2 = r2(491), l = r2(331), c = r2(307), u = r2.n(c), p = r2(308), d = r2(328), f = r2(143), h = r2(0), m = r2(37), y = r2(557), g = r2(93), b = r2(326), v = r2(16), E = r2(558), S = r2(560), x = Object.defineProperty, T = Object.defineProperties, w = Object.getOwnPropertyDescriptors, P = Object.getOwnPropertySymbols, A = Object.prototype.hasOwnProperty, C = Object.prototype.propertyIsEnumerable, O = (e3, t3, r3) => t3 in e3 ? x(e3, t3, { enumerable: true, configurable: true, writable: true, value: r3 }) : e3[t3] = r3, I = (e3, t3) => {
    for (var r3 in t3 || (t3 = {})) A.call(t3, r3) && O(e3, r3, t3[r3]);
    if (P) for (var r3 of P(t3)) C.call(t3, r3) && O(e3, r3, t3[r3]);
    return e3;
  }, _ = (e3, t3) => T(e3, w(t3)), k = ((e3) => (e3[e3.STABLE = 1] = "STABLE", e3[e3.DYNAMIC = 2] = "DYNAMIC", e3[e3.FORWARDED = 3] = "FORWARDED", e3))(k || {}), N = k, D = "Fragment", j = (e3, t3) => e3.get(t3)(), L = (e3) => e3.startsWith("v-") || e3.startsWith("v") && e3.length >= 2 && e3[1] >= "A" && e3[1] <= "Z", M = (e3) => !(e3.match(RegExp(`^_?${D}\\d*$`)) || "KeepAlive" === e3), B = (e3) => {
    const t3 = e3.node.object, r3 = e3.node.property, n3 = h.isJSXMemberExpression(t3) ? B(e3.get("object")) : h.isJSXIdentifier(t3) ? h.identifier(t3.name) : h.nullLiteral(), s3 = h.identifier(r3.name);
    return h.memberExpression(n3, s3);
  }, R = (e3) => {
    const t3 = e3.split(/\r\n|\n|\r/);
    let r3 = 0;
    for (let e4 = 0; e4 < t3.length; e4++) t3[e4].match(/[^ \t]/) && (r3 = e4);
    let n3 = "";
    for (let e4 = 0; e4 < t3.length; e4++) {
      const s3 = t3[e4], i3 = 0 === e4, o3 = e4 === t3.length - 1, a3 = e4 === r3;
      let l2 = s3.replace(/\t/g, " ");
      i3 || (l2 = l2.replace(/^[ ]+/, "")), o3 || (l2 = l2.replace(/[ ]+$/, "")), l2 && (a3 || (l2 += " "), n3 += l2);
    }
    return n3;
  }, F = (e3) => e3.get("expression").node, U = (e3, t3, r3) => {
    e3.scope.hasBinding(t3) && e3.parentPath && (h.isJSXElement(e3.parentPath.node) && e3.parentPath.setData("slotFlag", r3), U(e3.parentPath, t3, r3));
  }, $ = (e3, t3) => {
    const { parentPath: r3 } = e3;
    if (r3.isAssignmentExpression()) {
      const { left: n3 } = r3.node;
      if (h.isIdentifier(n3)) return t3.map((t4) => {
        if (h.isIdentifier(t4) && t4.name === n3.name) {
          const n4 = e3.scope.generateUidIdentifier(t4.name);
          return r3.insertBefore(h.variableDeclaration("const", [h.variableDeclarator(n4, h.callExpression(h.functionExpression(null, [], h.blockStatement([h.returnStatement(t4)])), []))])), n4;
        }
        return t4;
      });
    }
    return t3;
  }, V = /^on[^a-z]/, q = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    if (!(arguments.length > 1 ? arguments[1] : void 0)) return e3;
    const t3 = /* @__PURE__ */ new Map(), r3 = [];
    return e3.forEach((e4) => {
      if (h.isStringLiteral(e4.key)) {
        const { value: n3 } = e4.key, s3 = t3.get(n3);
        s3 ? ("style" === n3 || "class" === n3 || n3.startsWith("on")) && ((e5, t4) => {
          h.isArrayExpression(e5.value) ? e5.value.elements.push(t4.value) : e5.value = h.arrayExpression([e5.value, t4.value]);
        })(s3, e4) : (t3.set(n3, e4), r3.push(e4));
      } else r3.push(e4);
    }), r3;
  }, W = (e3) => {
    if (h.isIdentifier(e3)) return "undefined" === e3.name;
    if (h.isArrayExpression(e3)) {
      const { elements: t3 } = e3;
      return t3.every((e4) => e4 && W(e4));
    }
    return h.isObjectExpression(e3) ? e3.properties.every((e4) => W(e4.value)) : !!h.isLiteral(e3);
  }, G = (e3) => h.isArrayExpression(e3) ? e3.elements.map((e4) => h.isStringLiteral(e4) ? e4.value : "").filter(Boolean) : [], H = (e3, t3, r3, n3) => {
    if ("show" === n3) return j(t3, "vShow");
    if ("model" === n3) {
      let n4;
      const s3 = ((e4) => {
        const t4 = e4.get("attributes").find((e5) => !!e5.isJSXAttribute() && e5.get("name").isJSXIdentifier() && "type" === e5.get("name").node.name);
        return t4 ? t4.get("value").node : null;
      })(e3.parentPath);
      switch (r3.value) {
        case "select":
          n4 = j(t3, "vModelSelect");
          break;
        case "textarea":
          n4 = j(t3, "vModelText");
          break;
        default:
          if (h.isStringLiteral(s3) || !s3) switch (null == s3 ? void 0 : s3.value) {
            case "checkbox":
              n4 = j(t3, "vModelCheckbox");
              break;
            case "radio":
              n4 = j(t3, "vModelRadio");
              break;
            default:
              n4 = j(t3, "vModelText");
          }
          else n4 = j(t3, "vModelDynamic");
      }
      return n4;
    }
    return h.callExpression(j(t3, "resolveDirective"), [h.stringLiteral(n3)]);
  }, z = /^xlink([A-Z])/, K = (e3, t3) => {
    const r3 = ((e4, t4) => {
      var r4, n4;
      const s4 = e4.get("openingElement").get("name");
      if (s4.isJSXIdentifier()) {
        const { name: i4 } = s4.node;
        return E.includes(i4) || S.includes(i4) ? h.stringLiteral(i4) : i4 === D ? j(t4, D) : e4.scope.hasBinding(i4) ? h.identifier(i4) : (null == (n4 = (r4 = t4.opts).isCustomElement) ? void 0 : n4.call(r4, i4)) ? h.stringLiteral(i4) : h.callExpression(j(t4, "resolveComponent"), [h.stringLiteral(i4)]);
      }
      if (s4.isJSXMemberExpression()) return B(s4);
      throw new Error(`getTag: ${s4.type} is not supported`);
    })(e3, t3), n3 = ((e4, t4) => {
      var r4, n4;
      const s4 = e4.get("name");
      if (s4.isJSXMemberExpression()) return M(s4.node.property.name);
      const i4 = s4.node.name;
      return !(null == (n4 = (r4 = t4.opts).isCustomElement) ? void 0 : n4.call(r4, i4)) && M(i4) && !E.includes(i4) && !S.includes(i4);
    })(e3.get("openingElement"), t3), s3 = e3.get("openingElement").get("attributes"), i3 = [], o3 = /* @__PURE__ */ new Set();
    let a3 = null, l2 = 0;
    if (0 === s3.length) return { tag: r3, isComponent: n3, slots: a3, props: h.nullLiteral(), directives: i3, patchFlag: l2, dynamicPropNames: o3 };
    let c2 = [], u2 = false, p2 = false, d2 = false, f2 = false, m2 = false;
    const y2 = [], { mergeProps: b2 = true } = t3.opts;
    s3.forEach((s4) => {
      if (s4.isJSXAttribute()) {
        let b3 = ((e4) => {
          const t4 = e4.node.name;
          return h.isJSXIdentifier(t4) ? t4.name : `${t4.namespace.name}:${t4.name.name}`;
        })(s4);
        const v3 = ((e4, t4) => {
          const r4 = e4.get("value");
          return r4.isJSXElement() ? X(r4, t4) : r4.isStringLiteral() ? h.stringLiteral(R(r4.node.value)) : r4.isJSXExpressionContainer() ? F(r4) : null;
        })(s4, t3);
        if (W(v3) && "ref" !== b3 || (!n3 && (l3 = b3, V.test(l3)) && "onclick" !== b3.toLowerCase() && "onUpdate:modelValue" !== b3 && (f2 = true), "ref" === b3 ? u2 = true : "class" !== b3 || n3 ? "style" !== b3 || n3 ? "key" === b3 || L(b3) || "on" === b3 || o3.add(b3) : d2 = true : p2 = true), t3.opts.transformOn && ("on" === b3 || "nativeOn" === b3)) return t3.get("transformOn") || t3.set("transformOn", (0, g.addDefault)(e3, "@vue/babel-helper-vue-transform-on", { nameHint: "_transformOn" })), void y2.push(h.callExpression(t3.get("transformOn"), [v3 || h.booleanLiteral(true)]));
        if (L(b3)) {
          const { directive: e4, modifiers: l4, values: u3, args: p3, directiveName: d3 } = ((e5) => {
            var t4, r4;
            const { path: n4, value: s5, state: i4, tag: o4, isComponent: a4 } = e5, l5 = [], c3 = [], u4 = [];
            let p4, d4, f3;
            if ("namespace" in n4.node.name) [p4, d4] = e5.name.split(":"), p4 = n4.node.name.namespace.name, d4 = n4.node.name.name.name, f3 = d4.split("_").slice(1);
            else {
              const t5 = e5.name.split("_");
              p4 = t5.shift() || "", f3 = t5;
            }
            p4 = p4.replace(/^v/, "").replace(/^-/, "").replace(/^\S/, (e6) => e6.toLowerCase()), d4 && l5.push(h.stringLiteral(d4.split("_")[0]));
            const m3 = "models" === p4, y3 = "model" === p4;
            if (y3 && !n4.get("value").isJSXExpressionContainer()) throw new Error("You have to use JSX Expression inside your v-model");
            if (m3 && !a4) throw new Error("v-models can only use in custom components");
            const g2 = !["html", "text", "model", "models"].includes(p4) || y3 && !a4;
            let b4 = f3;
            return h.isArrayExpression(s5) ? (m3 ? s5.elements : [s5]).forEach((e6) => {
              if (m3 && !h.isArrayExpression(e6)) throw new Error("You should pass a Two-dimensional Arrays to v-models");
              const { elements: t5 } = e6, [r5, n5, s6] = t5;
              !n5 || h.isArrayExpression(n5) || h.isSpreadElement(n5) ? h.isArrayExpression(n5) ? (g2 || l5.push(h.nullLiteral()), b4 = G(n5)) : g2 || l5.push(h.nullLiteral()) : (l5.push(n5), b4 = G(s6)), u4.push(new Set(b4)), c3.push(r5);
            }) : y3 && !g2 ? (l5.push(h.nullLiteral()), u4.push(new Set(f3))) : u4.push(new Set(f3)), { directiveName: p4, modifiers: u4, values: c3.length ? c3 : [s5], args: l5, directive: g2 ? [H(n4, i4, o4, p4), c3[0] || s5, (null == (t4 = u4[0]) ? void 0 : t4.size) ? l5[0] || h.unaryExpression("void", h.numericLiteral(0), true) : l5[0], !!(null == (r4 = u4[0]) ? void 0 : r4.size) && h.objectExpression([...u4[0]].map((e6) => h.objectProperty(h.identifier(e6), h.booleanLiteral(true))))].filter(Boolean) : void 0 };
          })({ tag: r3, isComponent: n3, name: b3, path: s4, state: t3, value: v3 });
          if ("slots" === d3) return void (a3 = v3);
          e4 ? i3.push(h.arrayExpression(e4)) : "html" === d3 ? (c2.push(h.objectProperty(h.stringLiteral("innerHTML"), u3[0])), o3.add("innerHTML")) : "text" === d3 && (c2.push(h.objectProperty(h.stringLiteral("textContent"), u3[0])), o3.add("textContent")), ["models", "model"].includes(d3) && u3.forEach((t4, r4) => {
            var n4;
            const s5 = p3[r4], i4 = s5 && !h.isStringLiteral(s5) && !h.isNullLiteral(s5);
            e4 || (c2.push(h.objectProperty(h.isNullLiteral(s5) ? h.stringLiteral("modelValue") : s5, t4, i4)), i4 || o3.add((null == s5 ? void 0 : s5.value) || "modelValue"), (null == (n4 = l4[r4]) ? void 0 : n4.size) && c2.push(h.objectProperty(i4 ? h.binaryExpression("+", s5, h.stringLiteral("Modifiers")) : h.stringLiteral(`${(null == s5 ? void 0 : s5.value) || "model"}Modifiers`), h.objectExpression([...l4[r4]].map((e5) => h.objectProperty(h.stringLiteral(e5), h.booleanLiteral(true)))), i4)));
            const a4 = i4 ? h.binaryExpression("+", h.stringLiteral("onUpdate"), s5) : h.stringLiteral(`onUpdate:${(null == s5 ? void 0 : s5.value) || "modelValue"}`);
            c2.push(h.objectProperty(a4, h.arrowFunctionExpression([h.identifier("$event")], h.assignmentExpression("=", t4, h.identifier("$event"))), i4)), i4 ? m2 = true : o3.add(a4.value);
          });
        } else b3.match(z) && (b3 = b3.replace(z, (e4, t4) => `xlink:${t4.toLowerCase()}`)), c2.push(h.objectProperty(h.stringLiteral(b3), v3 || h.booleanLiteral(true)));
      } else c2.length && b2 && (y2.push(h.objectExpression(q(c2, b2))), c2 = []), m2 = true, ((e4, t4, r4, n4) => {
        const s5 = t4.get("argument"), i4 = h.isObjectExpression(s5.node) ? s5.node.properties : void 0;
        i4 ? r4 ? n4.push(h.objectExpression(i4)) : n4.push(...i4) : (s5.isIdentifier() && U(e4, s5.node.name, N.DYNAMIC), n4.push(r4 ? s5.node : h.spreadElement(s5.node)));
      })(e3, s4, b2, b2 ? y2 : c2);
      var l3;
    }), m2 ? l2 |= 16 : (p2 && (l2 |= 2), d2 && (l2 |= 4), o3.size && (l2 |= 8), f2 && (l2 |= 32)), 0 !== l2 && 32 !== l2 || !(u2 || i3.length > 0) || (l2 |= 512);
    let v2 = h.nullLiteral();
    return y2.length ? (c2.length && y2.push(h.objectExpression(q(c2, b2))), v2 = y2.length > 1 ? h.callExpression(j(t3, "mergeProps"), y2) : y2[0]) : c2.length && (v2 = 1 === c2.length && h.isSpreadElement(c2[0]) ? c2[0].argument : h.objectExpression(q(c2, b2))), { tag: r3, props: v2, isComponent: n3, slots: a3, directives: i3, patchFlag: l2, dynamicPropNames: o3 };
  }, X = (e3, t3) => {
    const r3 = ((e4, t4) => e4.map((e5) => {
      if (e5.isJSXText()) {
        const r4 = ((e6) => {
          const t5 = R(e6.node.value);
          return "" !== t5 ? h.stringLiteral(t5) : null;
        })(e5);
        return r4 ? h.callExpression(j(t4, "createTextVNode"), [r4]) : r4;
      }
      if (e5.isJSXExpressionContainer()) {
        const t5 = F(e5);
        if (h.isIdentifier(t5)) {
          const { name: r4 } = t5, { referencePaths: n4 = [] } = e5.scope.getBinding(r4) || {};
          n4.forEach((e6) => {
            U(e6, r4, N.DYNAMIC);
          });
        }
        return t5;
      }
      if (e5.isJSXSpreadChild()) return ((e6) => h.spreadElement(e6.get("expression").node))(e5);
      if (e5.isCallExpression()) return e5.node;
      if (e5.isJSXElement()) return X(e5, t4);
      throw new Error(`getChildren: ${e5.type} is not supported`);
    }).filter((e5) => null != e5 && !h.isJSXEmptyExpression(e5)))(e3.get("children"), t3), { tag: n3, props: s3, isComponent: i3, directives: o3, patchFlag: a3, dynamicPropNames: l2, slots: c2 } = K(e3, t3), { optimize: u2 = false } = t3.opts, p2 = e3.getData("slotFlag") || N.STABLE;
    let d2;
    if (r3.length > 1 || c2) d2 = i3 ? r3.length ? h.objectExpression([!!r3.length && h.objectProperty(h.identifier("default"), h.arrowFunctionExpression([], h.arrayExpression($(e3, r3)))), ...c2 ? h.isObjectExpression(c2) ? c2.properties : [h.spreadElement(c2)] : [], u2 && h.objectProperty(h.identifier("_"), h.numericLiteral(p2))].filter(Boolean)) : c2 : h.arrayExpression(r3);
    else if (1 === r3.length) {
      const { enableObjectSlots: n4 = true } = t3.opts, s4 = r3[0], o4 = h.objectExpression([h.objectProperty(h.identifier("default"), h.arrowFunctionExpression([], h.arrayExpression($(e3, [s4])))), u2 && h.objectProperty(h.identifier("_"), h.numericLiteral(p2))].filter(Boolean));
      if (h.isIdentifier(s4) && i3) d2 = n4 ? h.conditionalExpression(h.callExpression(t3.get("@vue/babel-plugin-jsx/runtimeIsSlot")(), [s4]), s4, o4) : o4;
      else if (h.isCallExpression(s4) && s4.loc && i3) if (n4) {
        const { scope: r4 } = e3, n5 = r4.generateUidIdentifier("slot");
        r4 && r4.push({ id: n5, kind: "let" });
        const i4 = h.objectExpression([h.objectProperty(h.identifier("default"), h.arrowFunctionExpression([], h.arrayExpression($(e3, [n5])))), u2 && h.objectProperty(h.identifier("_"), h.numericLiteral(p2))].filter(Boolean)), o5 = h.assignmentExpression("=", n5, s4), a4 = h.callExpression(t3.get("@vue/babel-plugin-jsx/runtimeIsSlot")(), [o5]);
        d2 = h.conditionalExpression(a4, n5, i4);
      } else d2 = o4;
      else d2 = h.isFunctionExpression(s4) || h.isArrowFunctionExpression(s4) ? h.objectExpression([h.objectProperty(h.identifier("default"), s4)]) : h.isObjectExpression(s4) ? h.objectExpression([...s4.properties, u2 && h.objectProperty(h.identifier("_"), h.numericLiteral(p2))].filter(Boolean)) : i3 ? h.objectExpression([h.objectProperty(h.identifier("default"), h.arrowFunctionExpression([], h.arrayExpression([s4])))]) : h.arrayExpression([s4]);
    }
    const f2 = h.callExpression(j(t3, "createVNode"), [n3, s3, d2 || h.nullLiteral(), !!a3 && u2 && h.numericLiteral(a3), !!l2.size && u2 && h.arrayExpression([...l2.keys()].map((e4) => h.stringLiteral(e4)))].filter(Boolean));
    return o3.length ? h.callExpression(j(t3, "withDirectives"), [f2, h.arrayExpression(o3)]) : f2;
  }, J = { JSXElement: { exit(e3, t3) {
    e3.replaceWith(X(e3, t3));
  } } }, Y = { JSXFragment: { enter(e3, t3) {
    const r3 = j(t3, D);
    e3.replaceWith(((e4, t4) => {
      const r4 = e4.get("children") || [];
      return h.jsxElement(h.jsxOpeningElement(t4, []), h.jsxClosingElement(t4), r4.map((e5) => {
        let { node: t5 } = e5;
        return t5;
      }), false);
    })(e3, h.isIdentifier(r3) ? h.jsxIdentifier(r3.name) : h.jsxMemberExpression(h.jsxIdentifier(r3.object.name), h.jsxIdentifier(r3.property.name))));
  } } }, Q = /\*?\s*@jsx\s+([^\s]+)/;
  function Z(e3) {
    return e3.default || e3;
  }
  var ee = Z(y), te = Z(m), re = (0, v.declare)((e3, t3, r3) => {
    const { types: n3 } = e3;
    let s3;
    return t3.resolveType && ("boolean" == typeof t3.resolveType && (t3.resolveType = {}), s3 = b(e3, t3.resolveType, r3)), _(I({}, s3 || {}), { name: "babel-plugin-jsx", inherits: Z(ee), visitor: _(I(I(I({}, null == s3 ? void 0 : s3.visitor), J), Y), { Program: { enter(e4, t4) {
      if (((e5) => {
        let t5 = false;
        return e5.traverse({ JSXElement(e6) {
          t5 = true, e6.stop();
        }, JSXFragment(e6) {
          t5 = true, e6.stop();
        } }), t5;
      })(e4)) {
        const r4 = ["createVNode", "Fragment", "resolveComponent", "withDirectives", "vShow", "vModelSelect", "vModelText", "vModelCheckbox", "vModelRadio", "vModelText", "vModelDynamic", "resolveDirective", "mergeProps", "createTextVNode", "isVNode"];
        if ((0, g.isModule)(e4)) {
          const s5 = {};
          r4.forEach((r5) => {
            t4.set(r5, () => {
              if (s5[r5]) return n3.cloneNode(s5[r5]);
              const t5 = (0, g.addNamed)(e4, r5, "vue", { ensureLiveReference: true });
              return s5[r5] = t5, t5;
            });
          });
          const { enableObjectSlots: i4 = true } = t4.opts;
          i4 && t4.set("@vue/babel-plugin-jsx/runtimeIsSlot", () => {
            if (s5.runtimeIsSlot) return s5.runtimeIsSlot;
            const { name: r5 } = t4.get("isVNode")(), n4 = e4.scope.generateUidIdentifier("isSlot"), i5 = te.ast`
                    function ${n4.name}(s) {
                      return typeof s === 'function' || (Object.prototype.toString.call(s) === '[object Object]' && !${r5}(s));
                    }
                  `, o3 = e4.get("body").filter((e5) => e5.isImportDeclaration()).pop();
            return o3 && o3.insertAfter(i5), s5.runtimeIsSlot = n4, n4;
          });
        } else {
          let n4;
          r4.forEach((r5) => {
            t4.set(r5, () => (n4 || (n4 = (0, g.addNamespace)(e4, "vue", { ensureLiveReference: true })), h.memberExpression(n4, h.identifier(r5))));
          });
          const s5 = {}, { enableObjectSlots: i4 = true } = t4.opts;
          i4 && t4.set("@vue/babel-plugin-jsx/runtimeIsSlot", () => {
            if (s5.runtimeIsSlot) return s5.runtimeIsSlot;
            const r5 = e4.scope.generateUidIdentifier("isSlot"), { object: i5 } = t4.get("isVNode")(), o3 = te.ast`
                    function ${r5.name}(s) {
                      return typeof s === 'function' || (Object.prototype.toString.call(s) === '[object Object]' && !${i5.name}.isVNode(s));
                    }
                  `, a3 = e4.get("body").filter((e5) => e5.isVariableDeclaration() && e5.node.declarations.some((e6) => {
              var t5;
              return (null == (t5 = e6.id) ? void 0 : t5.name) === n4.name;
            })).pop();
            return a3 && a3.insertAfter(o3), r5;
          });
        }
        const { opts: { pragma: s4 = "" }, file: i3 } = t4;
        if (s4 && t4.set("createVNode", () => h.identifier(s4)), i3.ast.comments) for (const e5 of i3.ast.comments) {
          const r5 = Q.exec(e5.value);
          r5 && t4.set("createVNode", () => h.identifier(r5[1]));
        }
      }
    }, exit(e4) {
      const t4 = e4.get("body"), r4 = /* @__PURE__ */ new Map();
      t4.filter((e5) => h.isImportDeclaration(e5.node) && "vue" === e5.node.source.value).forEach((e5) => {
        const { specifiers: t5 } = e5.node;
        let n5 = false;
        t5.forEach((e6) => {
          !e6.loc && h.isImportSpecifier(e6) && h.isIdentifier(e6.imported) && (r4.set(e6.imported.name, e6), n5 = true);
        }), n5 && e5.remove();
      });
      const n4 = [...r4.keys()].map((e5) => r4.get(e5));
      n4.length && e4.unshiftContainer("body", h.importDeclaration(n4, h.stringLiteral("vue")));
    } } }) });
  });
  const ne = ue(...Object.keys(Object.assign({}, { "@babel/plugin-transform-class-static-block": r2(344), "@babel/plugin-transform-parameters": r2(345) }))), se = false, ie = true, oe = false, ae = "0.9.5";
  function le(e3, t3, r3) {
    return t3 + "\n" + e3;
  }
  function ce(e3, t3, r3, n3, s3) {
    if (!n3) return le(e3, t3);
    const i3 = { start: { line: n3, column: s3 } };
    return le((0, o2.codeFrameColumns)(r3, i3, { message: e3 }), t3);
  }
  function ue() {
    for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++) t3[r3] = arguments[r3];
    return t3.reduce((e4, t4) => e4.append(String(t4)), new (u())()).end();
  }
  async function pe(e3, t3, r3) {
    let n3 = false;
    const s3 = { preventCache: () => n3 = true };
    if (void 0 === e3) return await r3(s3);
    const i3 = ue(...t3), o3 = await e3.get(i3);
    if (void 0 !== o3) return JSON.parse(o3);
    const a3 = await r3(s3);
    return false === n3 && await e3.set(i3, JSON.stringify(a3)), a3;
  }
  class de {
    constructor(e3) {
      this.promise = e3;
    }
  }
  const fe = Object.assign({}, { "@babel/plugin-transform-class-static-block": r2(344), "@babel/plugin-transform-parameters": r2(345) });
  async function he(e3, t3, r3, n3, o3, l2) {
    let c2, u2 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
    try {
      c2 = (0, i2.parse)(e3, { sourceType: t3 ? "module" : "script", sourceFilename: r3.toString(), plugins: [...void 0 !== n3 ? n3 : []] });
    } catch (t4) {
      throw null == l2 || l2("error", "parse script", ce(t4.message, r3.toString(), e3, t4.loc.line, t4.loc.column + 1)), t4;
    }
    var p2;
    p2 = c2, (0, s2.traverse)(p2, { CallExpression(e4) {
      s2.types.isImport(e4.node.callee) && e4.replaceWith(s2.types.callExpression(s2.types.identifier("__vsfcl_import__"), e4.node.arguments));
    } });
    const d2 = function(e4) {
      const t4 = [];
      return (0, s2.traverse)(e4, { ExportAllDeclaration(e5) {
        t4.push(e5.node.source.value);
      }, ImportDeclaration(e5) {
        t4.push(e5.node.source.value);
      }, CallExpression(e5) {
        "require" === e5.node.callee.name && 1 === e5.node.arguments.length && s2.types.isStringLiteral(e5.node.arguments[0]) && t4.push(e5.node.arguments[0].value);
      } }), t4;
    }(c2), f2 = await (0, s2.transformFromAstAsync)(c2, e3, { sourceMaps: oe, plugins: [...t3 ? [a2.a] : [], ...Object.values(fe), ...void 0 !== o3 ? Object.values(o3) : []], babelrc: false, configFile: false, highlightCode: false, compact: !u2, comments: u2, retainLines: u2, sourceType: t3 ? "module" : "script" });
    if (null === f2 || null == f2.code) {
      const e4 = `unable to transform script "${r3.toString()}"`;
      throw null == l2 || l2("error", e4), new Error(e4);
    }
    return [d2, f2.code];
  }
  async function me(e3, t3) {
    const { moduleCache: r3, loadModule: n3, handleModule: s3 } = t3, { id: i3, path: o3, getContent: a3 } = t3.getResource(e3, t3);
    return i3 in r3 ? r3[i3] instanceof de ? await r3[i3].promise : r3[i3] : (r3[i3] = new de((async () => {
      let e4;
      if (n3 && (e4 = await n3(i3, t3)), void 0 === e4) {
        const { getContentData: r4, type: n4 } = await a3();
        if (void 0 !== s3 && (e4 = await s3(n4, r4, o3, t3)), void 0 === e4 && (e4 = await async function(e5, t4, r5, n5) {
          var s4, i4;
          switch (e5) {
            case ".vue":
              return async function(e6, t5, r6) {
                var n6, s5, i5, o4, a4;
                const c2 = t5.toString(), u2 = {}, { delimiters: h2, whitespace: m2, isCustomElement: y2, moduleCache: g2, compiledCache: b2, getResource: v2, addStyle: E2, log: S2, additionalBabelParserPlugins: x2 = [], additionalBabelPlugins: T2 = {}, customBlockHandler: w2, devMode: P2 = false, createCJSModule: A2, processStyles: C2 } = r6, { descriptor: O2, errors: I2 } = (0, p.parse)(e6, { filename: c2, sourceMap: se }), _2 = void 0 !== w2 ? await Promise.all(O2.customBlocks.map((e7) => w2(e7, t5, r6))) : [], k2 = `data-v-${ue(c2)}`, N2 = O2.styles.some((e7) => e7.scoped);
                N2 && (u2.__scopeId = k2), O2.template && O2.template.lang && await me({ refPath: t5, relPath: O2.template.lang }, r6);
                const D2 = O2.template ? { compiler: Object.assign(Object.assign({}, d), { compile: (e7, t6) => f.compile(e7, Object.assign(Object.assign({}, t6), { sourceMap: se })) }), source: O2.template.src ? await (await v2({ refPath: t5, relPath: O2.template.src }, r6).getContent()).getContentData(false) : O2.template.content, filename: O2.filename, isProd: ie, scoped: N2, id: k2, slotted: O2.slotted, compilerOptions: { isCustomElement: y2, whitespace: m2, delimiters: h2, scopeId: N2 ? k2 : void 0, mode: "module" }, preprocessLang: O2.template.lang, preprocessCustomRequire: (e7) => g2[e7] } : void 0;
                if (O2.script || O2.scriptSetup) {
                  (null === (n6 = O2.script) || void 0 === n6 ? void 0 : n6.src) && (O2.script.content = await (await v2({ refPath: t5, relPath: O2.script.src }, r6).getContent()).getContentData(false));
                  const [e7, d2, f2] = await pe(b2, [Ee, ie, P2, null === (s5 = O2.script) || void 0 === s5 ? void 0 : s5.content, null === (i5 = O2.script) || void 0 === i5 ? void 0 : i5.lang, null === (o4 = O2.scriptSetup) || void 0 === o4 ? void 0 : o4.content, null === (a4 = O2.scriptSetup) || void 0 === a4 ? void 0 : a4.lang, x2, Object.keys(T2), ne], async (e8) => {
                    let { preventCache: t6 } = e8;
                    var r7, n7;
                    let s6 = ["jsx"], i6 = { jsx: re };
                    "ts" !== (null === (r7 = O2.script) || void 0 === r7 ? void 0 : r7.lang) && "ts" !== (null === (n7 = O2.scriptSetup) || void 0 === n7 ? void 0 : n7.lang) || (s6 = [...s6, "typescript"], i6 = Object.assign(Object.assign({}, i6), { typescript: l.a }));
                    const o5 = (0, p.compileScript)(O2, { isProd: ie, sourceMap: se, id: k2, babelParserPlugins: [...s6, ...x2], inlineTemplate: false, templateOptions: D2 });
                    return [o5.bindings, ...await he(o5.content, true, c2, [...s6, ...x2], Object.assign(Object.assign({}, i6), T2), S2, P2)];
                  });
                  void 0 !== (null == D2 ? void 0 : D2.compilerOptions) && (D2.compilerOptions.bindingMetadata = e7), await be(t5, d2, r6), Object.assign(u2, (j2 = A2(t5, f2, r6).exports, j2 && j2.__esModule ? j2 : { default: j2 }).default);
                }
                var j2;
                if (null !== O2.template) {
                  const [n7, s6] = await pe(b2, [Ee, P2, D2.source, D2.compilerOptions.delimiters, D2.compilerOptions.whitespace, D2.compilerOptions.scopeId, D2.compilerOptions.bindingMetadata ? Object.entries(D2.compilerOptions.bindingMetadata) : "", x2, Object.keys(T2), ne], async (t6) => {
                    let { preventCache: r7 } = t6;
                    const n8 = (0, p.compileTemplate)(D2);
                    if (n8.errors.length) {
                      r7();
                      for (const t7 of n8.errors) "object" == typeof t7 ? t7.loc ? null == S2 || S2("error", "SFC template", ce(t7.message, c2, e6, t7.loc.start.line + O2.template.loc.start.line - 1, t7.loc.start.column)) : null == S2 || S2("error", "SFC template", le(t7.message, c2)) : null == S2 || S2("error", "SFC template", le(t7, c2));
                    }
                    for (const e7 of n8.tips) null == S2 || S2("info", "SFC template", e7);
                    return await he(n8.code, true, O2.filename, x2, T2, S2, P2);
                  });
                  await be(t5, n7, r6), Object.assign(u2, A2(t5, s6, r6).exports);
                }
                for (const n7 of O2.styles) {
                  const s6 = n7.src ? await (await v2({ refPath: t5, relPath: n7.src }, r6).getContent()).getContentData(false) : n7.content;
                  E2(await pe(b2, [Ee, s6, n7.lang, k2, n7.scoped], async (i6) => {
                    let { preventCache: o5 } = i6;
                    const a5 = void 0 !== C2 ? await C2(s6, n7.lang, t5, r6) : s6;
                    void 0 === a5 && o5(), void 0 === C2 && void 0 !== n7.lang && await me({ refPath: t5, relPath: n7.lang }, r6);
                    const l2 = await (0, p.compileStyleAsync)(Object.assign({ filename: O2.filename, source: a5, isProd: ie, id: k2, scoped: n7.scoped, trim: true }, void 0 === C2 ? { preprocessLang: n7.lang, preprocessCustomRequire: (e7) => g2[e7] } : {}));
                    if (l2.errors.length) {
                      o5();
                      for (const r7 of l2.errors) null == S2 || S2("error", "SFC style", ce(r7.message, t5, e6, r7.line + n7.loc.start.line - 1, r7.column));
                    }
                    return l2.code;
                  }), n7.scoped ? k2 : void 0);
                }
                return void 0 !== w2 && await Promise.all(_2.map((e7) => null == e7 ? void 0 : e7(u2))), u2;
              }(await t4(false), r5, n5);
            case ".js":
              return ge(await t4(false), false, r5, n5);
            case ".mjs":
              return ge(await t4(false), true, r5, n5);
            case ".ts":
              return ge(await t4(false), true, r5, Object.assign(Object.assign({}, n5), { additionalBabelParserPlugins: ["typescript", ...null !== (s4 = n5.additionalBabelParserPlugins) && void 0 !== s4 ? s4 : []], additionalBabelPlugins: Object.assign({ typescript: l.a }, null !== (i4 = n5.additionalBabelPlugins) && void 0 !== i4 ? i4 : {}) }));
          }
        }(n4, r4, o3, t3)), void 0 === e4) throw new TypeError(`Unable to handle ${n4} files (${o3})`);
      }
      return r3[i3] = e4;
    })()), await r3[i3].promise);
  }
  function ye(e3, t3, r3) {
    const { moduleCache: n3, pathResolve: s3, getResource: i3 } = r3, o3 = { exports: {} };
    return Function("exports", "require", "module", "__filename", "__dirname", "__vsfcl_import__", t3).call(o3.exports, o3.exports, function(t4) {
      const { id: s4 } = i3({ refPath: e3, relPath: t4 }, r3);
      if (s4 in n3) return n3[s4];
      throw new Error(`require(${JSON.stringify(s4)}) failed. module not found in moduleCache`);
    }, o3, e3, s3({ refPath: e3, relPath: "." }, r3), async function(t4) {
      return await me({ refPath: e3, relPath: t4 }, r3);
    }), o3;
  }
  async function ge(e3, t3, r3, n3) {
    const { compiledCache: s3, additionalBabelParserPlugins: i3, additionalBabelPlugins: o3, createCJSModule: a3, log: l2 } = n3, [c2, u2] = await pe(s3, [ae, e3, r3, n3.devMode, i3 || "", o3 ? Object.keys(o3) : ""], async () => await he(e3, t3, r3, i3, o3, l2, n3.devMode));
    return await be(r3, c2, n3), a3(r3, u2, n3).exports;
  }
  async function be(e3, t3, r3) {
    await Promise.all(t3.map((t4) => me({ refPath: e3, relPath: t4 }, r3)));
  }
  const ve = "0.9.5", Ee = "3.4.15";
  function Se(e3) {
    throw new ReferenceError(`${e3} is not defined`);
  }
  const xe = (e3) => {
    const t3 = e3.indexOf("?");
    return -1 !== t3 ? e3.slice(0, t3) : e3;
  }, Te = (e3, t3) => {
    let { refPath: r3, relPath: s3 } = e3;
    const { getPathname: i3 } = t3;
    if (void 0 === r3) return s3;
    const o3 = s3.toString();
    return "." !== o3[0] ? s3 : n2.posix.normalize(n2.posix.join(n2.posix.dirname(i3(r3.toString())), o3));
  };
  function we(e3, t3) {
    const { pathResolve: r3, getPathname: s3, getFile: i3, log: o3 } = t3, a3 = r3(e3, t3), l2 = a3.toString();
    return { id: l2, path: a3, getContent: async () => {
      const e4 = await i3(a3);
      return "string" == typeof e4 || e4 instanceof ArrayBuffer ? { type: n2.posix.extname(s3(l2)), getContentData: async (t4) => (e4 instanceof ArrayBuffer !== t4 && (null == o3 || o3("warn", `unexpected data type. ${t4 ? "binary" : "string"} is expected for "${a3}"`)), e4) } : (e4 || null == o3 || o3("error", `There is no file avaialable such as "${a3}"`), { type: void 0 !== e4.type ? e4.type : n2.posix.extname(s3(l2)), getContentData: e4.getContentData });
    } };
  }
  async function Pe(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Se("options");
    var r3;
    const { moduleCache: n3 = Se("options.moduleCache"), getFile: s3 = Se("options.getFile()"), addStyle: i3 = Se("options.addStyle()"), pathResolve: o3 = Te, getResource: a3 = we, createCJSModule: l2 = ye, getPathname: c2 = xe } = t3;
    n3 instanceof Object && Object.setPrototypeOf(n3, null);
    const u2 = Object.assign({ moduleCache: n3, pathResolve: o3, getResource: a3, createCJSModule: l2, getPathname: c2 }, t3);
    return t3.devMode && void 0 === t3.compiledCache && (null === (r3 = t3.log) || void 0 === r3 || r3.call(t3, "info", "options.compiledCache is not defined, performance will be affected")), await me({ refPath: void 0, relPath: e3 }, u2);
  }
  function Ae(e3) {
    return { render: (t3, r3, n3) => {
      try {
        const s3 = e3(t3, r3);
        "string" == typeof s3 ? n3(null, s3) : (s3.then((e4) => {
          n3(null, e4);
        }), s3.catch((e4) => {
          n3(e4, null);
        }));
      } catch (e4) {
        n3(e4, null);
      }
    } };
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  const n2 = (0, r2(164).default)("React.Component");
  t2.default = n2;
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return !!e3 && /^[a-z]/.test(e3);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const t3 = [];
    for (let r3 = 0; r3 < e3.children.length; r3++) {
      let i2 = e3.children[r3];
      (0, n2.isJSXText)(i2) ? (0, s2.default)(i2, t3) : ((0, n2.isJSXExpressionContainer)(i2) && (i2 = i2.expression), (0, n2.isJSXEmptyExpression)(i2) || t3.push(i2));
    }
    return t3;
  };
  var n2 = r2(2), s2 = r2(351);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const r3 = e3.value.split(/\r\n|\n|\r/);
    let i2 = 0;
    for (let e4 = 0; e4 < r3.length; e4++) r3[e4].match(/[^ \t]/) && (i2 = e4);
    let o2 = "";
    for (let e4 = 0; e4 < r3.length; e4++) {
      const t4 = r3[e4], n3 = 0 === e4, s3 = e4 === r3.length - 1, a2 = e4 === i2;
      let l = t4.replace(/\t/g, " ");
      n3 || (l = l.replace(/^[ ]+/, "")), s3 || (l = l.replace(/[ ]+$/, "")), l && (a2 || (l += " "), o2 += l);
    }
    o2 && t3.push((0, s2.inherits)((0, n2.stringLiteral)(o2), e3));
  };
  var n2 = r2(4), s2 = r2(0);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const t3 = s2.BUILDER_KEYS[e3.type];
    for (const r3 of t3) (0, n2.default)(e3, r3, e3[r3]);
    return e3;
  };
  var n2 = r2(97), s2 = r2(0);
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isIdentifierChar = u, t2.isIdentifierName = function(e3) {
    let t3 = true;
    for (let r3 = 0; r3 < e3.length; r3++) {
      let n3 = e3.charCodeAt(r3);
      if (55296 == (64512 & n3) && r3 + 1 < e3.length) {
        const t4 = e3.charCodeAt(++r3);
        56320 == (64512 & t4) && (n3 = 65536 + ((1023 & n3) << 10) + (1023 & t4));
      }
      if (t3) {
        if (t3 = false, !c(n3)) return false;
      } else if (!u(n3)) return false;
    }
    return !t3;
  }, t2.isIdentifierStart = c;
  let r2 = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", n2 = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
  const s2 = new RegExp("[" + r2 + "]"), i2 = new RegExp("[" + r2 + n2 + "]");
  r2 = n2 = null;
  const o2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], a2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function l(e3, t3) {
    let r3 = 65536;
    for (let n3 = 0, s3 = t3.length; n3 < s3; n3 += 2) {
      if (r3 += t3[n3], r3 > e3) return false;
      if (r3 += t3[n3 + 1], r3 >= e3) return true;
    }
    return false;
  }
  function c(e3) {
    return e3 < 65 ? 36 === e3 : e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && s2.test(String.fromCharCode(e3)) : l(e3, o2)));
  }
  function u(e3) {
    return e3 < 48 ? 36 === e3 : e3 < 58 || !(e3 < 65) && (e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && i2.test(String.fromCharCode(e3)) : l(e3, o2) || l(e3, a2))));
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.isKeyword = function(e3) {
    return r2.has(e3);
  }, t2.isReservedWord = i2, t2.isStrictBindOnlyReservedWord = a2, t2.isStrictBindReservedWord = function(e3, t3) {
    return o2(e3, t3) || a2(e3);
  }, t2.isStrictReservedWord = o2;
  const r2 = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), n2 = /* @__PURE__ */ new Set(["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"]), s2 = /* @__PURE__ */ new Set(["eval", "arguments"]);
  function i2(e3, t3) {
    return t3 && "await" === e3 || "enum" === e3;
  }
  function o2(e3, t3) {
    return i2(e3, t3) || n2.has(e3);
  }
  function a2(e3) {
    return s2.has(e3);
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.readCodePoint = c, t2.readInt = l, t2.readStringContents = function(e3, t3, r3, n3, s3, a3) {
    const l2 = r3, c2 = n3, u = s3;
    let p = "", d = null, f = r3;
    const { length: h } = t3;
    for (; ; ) {
      if (r3 >= h) {
        a3.unterminated(l2, c2, u), p += t3.slice(f, r3);
        break;
      }
      const m = t3.charCodeAt(r3);
      if (i2(e3, m, t3, r3)) {
        p += t3.slice(f, r3);
        break;
      }
      if (92 === m) {
        p += t3.slice(f, r3);
        const i3 = o2(t3, r3, n3, s3, "template" === e3, a3);
        null !== i3.ch || d ? p += i3.ch : d = { pos: r3, lineStart: n3, curLine: s3 }, { pos: r3, lineStart: n3, curLine: s3 } = i3, f = r3;
      } else 8232 === m || 8233 === m ? (++s3, n3 = ++r3) : 10 === m || 13 === m ? "template" === e3 ? (p += t3.slice(f, r3) + "\n", ++r3, 13 === m && 10 === t3.charCodeAt(r3) && ++r3, ++s3, f = n3 = r3) : a3.unterminated(l2, c2, u) : ++r3;
    }
    return { pos: r3, str: p, firstInvalidLoc: d, lineStart: n3, curLine: s3, containsInvalid: !!d };
  };
  var r2 = function(e3) {
    return e3 >= 48 && e3 <= 57;
  };
  const n2 = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, s2 = { bin: (e3) => 48 === e3 || 49 === e3, oct: (e3) => e3 >= 48 && e3 <= 55, dec: (e3) => e3 >= 48 && e3 <= 57, hex: (e3) => e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102 };
  function i2(e3, t3, r3, n3) {
    return "template" === e3 ? 96 === t3 || 36 === t3 && 123 === r3.charCodeAt(n3 + 1) : t3 === ("double" === e3 ? 34 : 39);
  }
  function o2(e3, t3, r3, n3, s3, i3) {
    const o3 = !s3;
    t3++;
    const l2 = (e4) => ({ pos: t3, ch: e4, lineStart: r3, curLine: n3 }), u = e3.charCodeAt(t3++);
    switch (u) {
      case 110:
        return l2("\n");
      case 114:
        return l2("\r");
      case 120: {
        let s4;
        return { code: s4, pos: t3 } = a2(e3, t3, r3, n3, 2, false, o3, i3), l2(null === s4 ? null : String.fromCharCode(s4));
      }
      case 117: {
        let s4;
        return { code: s4, pos: t3 } = c(e3, t3, r3, n3, o3, i3), l2(null === s4 ? null : String.fromCodePoint(s4));
      }
      case 116:
        return l2("	");
      case 98:
        return l2("\b");
      case 118:
        return l2("\v");
      case 102:
        return l2("\f");
      case 13:
        10 === e3.charCodeAt(t3) && ++t3;
      case 10:
        r3 = t3, ++n3;
      case 8232:
      case 8233:
        return l2("");
      case 56:
      case 57:
        if (s3) return l2(null);
        i3.strictNumericEscape(t3 - 1, r3, n3);
      default:
        if (u >= 48 && u <= 55) {
          const o4 = t3 - 1;
          let a3 = e3.slice(o4, t3 + 2).match(/^[0-7]+/)[0], c2 = parseInt(a3, 8);
          c2 > 255 && (a3 = a3.slice(0, -1), c2 = parseInt(a3, 8)), t3 += a3.length - 1;
          const u2 = e3.charCodeAt(t3);
          if ("0" !== a3 || 56 === u2 || 57 === u2) {
            if (s3) return l2(null);
            i3.strictNumericEscape(o4, r3, n3);
          }
          return l2(String.fromCharCode(c2));
        }
        return l2(String.fromCharCode(u));
    }
  }
  function a2(e3, t3, r3, n3, s3, i3, o3, a3) {
    const c2 = t3;
    let u;
    return { n: u, pos: t3 } = l(e3, t3, r3, n3, 16, s3, i3, false, a3, !o3), null === u && (o3 ? a3.invalidEscapeSequence(c2, r3, n3) : t3 = c2 - 1), { code: u, pos: t3 };
  }
  function l(e3, t3, i3, o3, a3, l2, c2, u, p, d) {
    const f = t3, h = 16 === a3 ? n2.hex : n2.decBinOct, m = 16 === a3 ? s2.hex : 10 === a3 ? s2.dec : 8 === a3 ? s2.oct : s2.bin;
    let y = false, g = 0;
    for (let n3 = 0, s3 = null == l2 ? 1 / 0 : l2; n3 < s3; ++n3) {
      const n4 = e3.charCodeAt(t3);
      let s4;
      if (95 !== n4 || "bail" === u) {
        if (s4 = n4 >= 97 ? n4 - 97 + 10 : n4 >= 65 ? n4 - 65 + 10 : r2(n4) ? n4 - 48 : 1 / 0, s4 >= a3) {
          if (s4 <= 9 && d) return { n: null, pos: t3 };
          if (s4 <= 9 && p.invalidDigit(t3, i3, o3, a3)) s4 = 0;
          else {
            if (!c2) break;
            s4 = 0, y = true;
          }
        }
        ++t3, g = g * a3 + s4;
      } else {
        const r3 = e3.charCodeAt(t3 - 1), n5 = e3.charCodeAt(t3 + 1);
        if (u) {
          if (Number.isNaN(n5) || !m(n5) || h.has(r3) || h.has(n5)) {
            if (d) return { n: null, pos: t3 };
            p.unexpectedNumericSeparator(t3, i3, o3);
          }
        } else {
          if (d) return { n: null, pos: t3 };
          p.numericSeparatorInEscapeSequence(t3, i3, o3);
        }
        ++t3;
      }
    }
    return t3 === f || null != l2 && t3 - f !== l2 || y ? { n: null, pos: t3 } : { n: g, pos: t3 };
  }
  function c(e3, t3, r3, n3, s3, i3) {
    let o3;
    if (123 === e3.charCodeAt(t3)) {
      if (++t3, { code: o3, pos: t3 } = a2(e3, t3, r3, n3, e3.indexOf("}", t3) - t3, true, s3, i3), ++t3, null !== o3 && o3 > 1114111) {
        if (!s3) return { code: null, pos: t3 };
        i3.invalidCodePoint(t3, r3, n3);
      }
    } else ({ code: o3, pos: t3 } = a2(e3, t3, r3, n3, 4, false, s3, i3));
    return { code: o3, pos: t3 };
  }
}, (e2, t2, r2) => {
  var n2 = r2(18);
  const s2 = (0, n2.defineAliasedType)("Flow"), i2 = (e3) => {
    const t3 = "DeclareClass" === e3;
    s2(e3, { builder: ["id", "typeParameters", "extends", "body"], visitor: ["id", "typeParameters", "extends", ...t3 ? ["mixins", "implements"] : [], "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: Object.assign({ id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TypeParameterDeclaration"), extends: (0, n2.validateOptional)((0, n2.arrayOfType)("InterfaceExtends")) }, t3 ? { mixins: (0, n2.validateOptional)((0, n2.arrayOfType)("InterfaceExtends")), implements: (0, n2.validateOptional)((0, n2.arrayOfType)("ClassImplements")) } : {}, { body: (0, n2.validateType)("ObjectTypeAnnotation") }) });
  };
  s2("AnyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("ArrayTypeAnnotation", { visitor: ["elementType"], aliases: ["FlowType"], fields: { elementType: (0, n2.validateType)("FlowType") } }), s2("BooleanTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("BooleanLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("NullLiteralTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("ClassImplements", { visitor: ["id", "typeParameters"], fields: { id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TypeParameterInstantiation") } }), i2("DeclareClass"), s2("DeclareFunction", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)("Identifier"), predicate: (0, n2.validateOptionalType)("DeclaredPredicate") } }), i2("DeclareInterface"), s2("DeclareModule", { builder: ["id", "body", "kind"], visitor: ["id", "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)(["Identifier", "StringLiteral"]), body: (0, n2.validateType)("BlockStatement"), kind: (0, n2.validateOptional)((0, n2.assertOneOf)("CommonJS", "ES")) } }), s2("DeclareModuleExports", { visitor: ["typeAnnotation"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { typeAnnotation: (0, n2.validateType)("TypeAnnotation") } }), s2("DeclareTypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TypeParameterDeclaration"), right: (0, n2.validateType)("FlowType") } }), s2("DeclareOpaqueType", { visitor: ["id", "typeParameters", "supertype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, n2.validateOptionalType)("FlowType"), impltype: (0, n2.validateOptionalType)("FlowType") } }), s2("DeclareVariable", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)("Identifier") } }), s2("DeclareExportDeclaration", { visitor: ["declaration", "specifiers", "source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { declaration: (0, n2.validateOptionalType)("Flow"), specifiers: (0, n2.validateOptional)((0, n2.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])), source: (0, n2.validateOptionalType)("StringLiteral"), default: (0, n2.validateOptional)((0, n2.assertValueType)("boolean")) } }), s2("DeclareExportAllDeclaration", { visitor: ["source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { source: (0, n2.validateType)("StringLiteral"), exportKind: (0, n2.validateOptional)((0, n2.assertOneOf)("type", "value")) } }), s2("DeclaredPredicate", { visitor: ["value"], aliases: ["FlowPredicate"], fields: { value: (0, n2.validateType)("Flow") } }), s2("ExistsTypeAnnotation", { aliases: ["FlowType"] }), s2("FunctionTypeAnnotation", { visitor: ["typeParameters", "params", "rest", "returnType"], aliases: ["FlowType"], fields: { typeParameters: (0, n2.validateOptionalType)("TypeParameterDeclaration"), params: (0, n2.validate)((0, n2.arrayOfType)("FunctionTypeParam")), rest: (0, n2.validateOptionalType)("FunctionTypeParam"), this: (0, n2.validateOptionalType)("FunctionTypeParam"), returnType: (0, n2.validateType)("FlowType") } }), s2("FunctionTypeParam", { visitor: ["name", "typeAnnotation"], fields: { name: (0, n2.validateOptionalType)("Identifier"), typeAnnotation: (0, n2.validateType)("FlowType"), optional: (0, n2.validateOptional)((0, n2.assertValueType)("boolean")) } }), s2("GenericTypeAnnotation", { visitor: ["id", "typeParameters"], aliases: ["FlowType"], fields: { id: (0, n2.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, n2.validateOptionalType)("TypeParameterInstantiation") } }), s2("InferredPredicate", { aliases: ["FlowPredicate"] }), s2("InterfaceExtends", { visitor: ["id", "typeParameters"], fields: { id: (0, n2.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, n2.validateOptionalType)("TypeParameterInstantiation") } }), i2("InterfaceDeclaration"), s2("InterfaceTypeAnnotation", { visitor: ["extends", "body"], aliases: ["FlowType"], fields: { extends: (0, n2.validateOptional)((0, n2.arrayOfType)("InterfaceExtends")), body: (0, n2.validateType)("ObjectTypeAnnotation") } }), s2("IntersectionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, n2.validate)((0, n2.arrayOfType)("FlowType")) } }), s2("MixedTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("EmptyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("NullableTypeAnnotation", { visitor: ["typeAnnotation"], aliases: ["FlowType"], fields: { typeAnnotation: (0, n2.validateType)("FlowType") } }), s2("NumberLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, n2.validate)((0, n2.assertValueType)("number")) } }), s2("NumberTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("ObjectTypeAnnotation", { visitor: ["properties", "indexers", "callProperties", "internalSlots"], aliases: ["FlowType"], builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"], fields: { properties: (0, n2.validate)((0, n2.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])), indexers: { validate: (0, n2.arrayOfType)("ObjectTypeIndexer"), optional: true, default: [] }, callProperties: { validate: (0, n2.arrayOfType)("ObjectTypeCallProperty"), optional: true, default: [] }, internalSlots: { validate: (0, n2.arrayOfType)("ObjectTypeInternalSlot"), optional: true, default: [] }, exact: { validate: (0, n2.assertValueType)("boolean"), default: false }, inexact: (0, n2.validateOptional)((0, n2.assertValueType)("boolean")) } }), s2("ObjectTypeInternalSlot", { visitor: ["id", "value", "optional", "static", "method"], aliases: ["UserWhitespacable"], fields: { id: (0, n2.validateType)("Identifier"), value: (0, n2.validateType)("FlowType"), optional: (0, n2.validate)((0, n2.assertValueType)("boolean")), static: (0, n2.validate)((0, n2.assertValueType)("boolean")), method: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("ObjectTypeCallProperty", { visitor: ["value"], aliases: ["UserWhitespacable"], fields: { value: (0, n2.validateType)("FlowType"), static: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("ObjectTypeIndexer", { visitor: ["id", "key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { id: (0, n2.validateOptionalType)("Identifier"), key: (0, n2.validateType)("FlowType"), value: (0, n2.validateType)("FlowType"), static: (0, n2.validate)((0, n2.assertValueType)("boolean")), variance: (0, n2.validateOptionalType)("Variance") } }), s2("ObjectTypeProperty", { visitor: ["key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { key: (0, n2.validateType)(["Identifier", "StringLiteral"]), value: (0, n2.validateType)("FlowType"), kind: (0, n2.validate)((0, n2.assertOneOf)("init", "get", "set")), static: (0, n2.validate)((0, n2.assertValueType)("boolean")), proto: (0, n2.validate)((0, n2.assertValueType)("boolean")), optional: (0, n2.validate)((0, n2.assertValueType)("boolean")), variance: (0, n2.validateOptionalType)("Variance"), method: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("ObjectTypeSpreadProperty", { visitor: ["argument"], aliases: ["UserWhitespacable"], fields: { argument: (0, n2.validateType)("FlowType") } }), s2("OpaqueType", { visitor: ["id", "typeParameters", "supertype", "impltype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, n2.validateOptionalType)("FlowType"), impltype: (0, n2.validateType)("FlowType") } }), s2("QualifiedTypeIdentifier", { visitor: ["id", "qualification"], fields: { id: (0, n2.validateType)("Identifier"), qualification: (0, n2.validateType)(["Identifier", "QualifiedTypeIdentifier"]) } }), s2("StringLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, n2.validate)((0, n2.assertValueType)("string")) } }), s2("StringTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("SymbolTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("ThisTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("TupleTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, n2.validate)((0, n2.arrayOfType)("FlowType")) } }), s2("TypeofTypeAnnotation", { visitor: ["argument"], aliases: ["FlowType"], fields: { argument: (0, n2.validateType)("FlowType") } }), s2("TypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TypeParameterDeclaration"), right: (0, n2.validateType)("FlowType") } }), s2("TypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n2.validateType)("FlowType") } }), s2("TypeCastExpression", { visitor: ["expression", "typeAnnotation"], aliases: ["ExpressionWrapper", "Expression"], fields: { expression: (0, n2.validateType)("Expression"), typeAnnotation: (0, n2.validateType)("TypeAnnotation") } }), s2("TypeParameter", { visitor: ["bound", "default", "variance"], fields: { name: (0, n2.validate)((0, n2.assertValueType)("string")), bound: (0, n2.validateOptionalType)("TypeAnnotation"), default: (0, n2.validateOptionalType)("FlowType"), variance: (0, n2.validateOptionalType)("Variance") } }), s2("TypeParameterDeclaration", { visitor: ["params"], fields: { params: (0, n2.validate)((0, n2.arrayOfType)("TypeParameter")) } }), s2("TypeParameterInstantiation", { visitor: ["params"], fields: { params: (0, n2.validate)((0, n2.arrayOfType)("FlowType")) } }), s2("UnionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, n2.validate)((0, n2.arrayOfType)("FlowType")) } }), s2("Variance", { builder: ["kind"], fields: { kind: (0, n2.validate)((0, n2.assertOneOf)("minus", "plus")) } }), s2("VoidTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), s2("EnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { id: (0, n2.validateType)("Identifier"), body: (0, n2.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"]) } }), s2("EnumBooleanBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, n2.validate)((0, n2.assertValueType)("boolean")), members: (0, n2.validateArrayOfType)("EnumBooleanMember"), hasUnknownMembers: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("EnumNumberBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, n2.validate)((0, n2.assertValueType)("boolean")), members: (0, n2.validateArrayOfType)("EnumNumberMember"), hasUnknownMembers: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("EnumStringBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, n2.validate)((0, n2.assertValueType)("boolean")), members: (0, n2.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]), hasUnknownMembers: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("EnumSymbolBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { members: (0, n2.validateArrayOfType)("EnumDefaultedMember"), hasUnknownMembers: (0, n2.validate)((0, n2.assertValueType)("boolean")) } }), s2("EnumBooleanMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, n2.validateType)("Identifier"), init: (0, n2.validateType)("BooleanLiteral") } }), s2("EnumNumberMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, n2.validateType)("Identifier"), init: (0, n2.validateType)("NumericLiteral") } }), s2("EnumStringMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, n2.validateType)("Identifier"), init: (0, n2.validateType)("StringLiteral") } }), s2("EnumDefaultedMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, n2.validateType)("Identifier") } }), s2("IndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, n2.validateType)("FlowType"), indexType: (0, n2.validateType)("FlowType") } }), s2("OptionalIndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, n2.validateType)("FlowType"), indexType: (0, n2.validateType)("FlowType"), optional: (0, n2.validate)((0, n2.assertValueType)("boolean")) } });
}, (e2, t2, r2) => {
  var n2 = r2(18);
  const s2 = (0, n2.defineAliasedType)("JSX");
  s2("JSXAttribute", { visitor: ["name", "value"], aliases: ["Immutable"], fields: { name: { validate: (0, n2.assertNodeType)("JSXIdentifier", "JSXNamespacedName") }, value: { optional: true, validate: (0, n2.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer") } } }), s2("JSXClosingElement", { visitor: ["name"], aliases: ["Immutable"], fields: { name: { validate: (0, n2.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") } } }), s2("JSXElement", { builder: ["openingElement", "closingElement", "children", "selfClosing"], visitor: ["openingElement", "children", "closingElement"], aliases: ["Immutable", "Expression"], fields: Object.assign({ openingElement: { validate: (0, n2.assertNodeType)("JSXOpeningElement") }, closingElement: { optional: true, validate: (0, n2.assertNodeType)("JSXClosingElement") }, children: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } }, { selfClosing: { validate: (0, n2.assertValueType)("boolean"), optional: true } }) }), s2("JSXEmptyExpression", {}), s2("JSXExpressionContainer", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, n2.assertNodeType)("Expression", "JSXEmptyExpression") } } }), s2("JSXSpreadChild", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, n2.assertNodeType)("Expression") } } }), s2("JSXIdentifier", { builder: ["name"], fields: { name: { validate: (0, n2.assertValueType)("string") } } }), s2("JSXMemberExpression", { visitor: ["object", "property"], fields: { object: { validate: (0, n2.assertNodeType)("JSXMemberExpression", "JSXIdentifier") }, property: { validate: (0, n2.assertNodeType)("JSXIdentifier") } } }), s2("JSXNamespacedName", { visitor: ["namespace", "name"], fields: { namespace: { validate: (0, n2.assertNodeType)("JSXIdentifier") }, name: { validate: (0, n2.assertNodeType)("JSXIdentifier") } } }), s2("JSXOpeningElement", { builder: ["name", "attributes", "selfClosing"], visitor: ["name", "attributes"], aliases: ["Immutable"], fields: { name: { validate: (0, n2.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") }, selfClosing: { default: false }, attributes: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("JSXAttribute", "JSXSpreadAttribute"))) }, typeParameters: { validate: (0, n2.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), s2("JSXSpreadAttribute", { visitor: ["argument"], fields: { argument: { validate: (0, n2.assertNodeType)("Expression") } } }), s2("JSXText", { aliases: ["Immutable"], builder: ["value"], fields: { value: { validate: (0, n2.assertValueType)("string") } } }), s2("JSXFragment", { builder: ["openingFragment", "closingFragment", "children"], visitor: ["openingFragment", "children", "closingFragment"], aliases: ["Immutable", "Expression"], fields: { openingFragment: { validate: (0, n2.assertNodeType)("JSXOpeningFragment") }, closingFragment: { validate: (0, n2.assertNodeType)("JSXClosingFragment") }, children: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } } }), s2("JSXOpeningFragment", { aliases: ["Immutable"] }), s2("JSXClosingFragment", { aliases: ["Immutable"] });
}, (e2, t2, r2) => {
  var n2 = r2(18), s2 = r2(169);
  const i2 = (0, n2.defineAliasedType)("Miscellaneous");
  i2("Noop", { visitor: [] }), i2("Placeholder", { visitor: [], builder: ["expectedNode", "name"], fields: { name: { validate: (0, n2.assertNodeType)("Identifier") }, expectedNode: { validate: (0, n2.assertOneOf)(...s2.PLACEHOLDERS) } } }), i2("V8IntrinsicIdentifier", { builder: ["name"], fields: { name: { validate: (0, n2.assertValueType)("string") } } });
}, (e2, t2, r2) => {
  var n2 = r2(18);
  (0, n2.default)("ArgumentPlaceholder", {}), (0, n2.default)("BindExpression", { visitor: ["object", "callee"], aliases: ["Expression"], fields: { object: { validate: Object.assign(() => {
  }, { oneOfNodeTypes: ["Expression"] }) }, callee: { validate: Object.assign(() => {
  }, { oneOfNodeTypes: ["Expression"] }) } } }), (0, n2.default)("ImportAttribute", { visitor: ["key", "value"], fields: { key: { validate: (0, n2.assertNodeType)("Identifier", "StringLiteral") }, value: { validate: (0, n2.assertNodeType)("StringLiteral") } } }), (0, n2.default)("Decorator", { visitor: ["expression"], fields: { expression: { validate: (0, n2.assertNodeType)("Expression") } } }), (0, n2.default)("DoExpression", { visitor: ["body"], builder: ["body", "async"], aliases: ["Expression"], fields: { body: { validate: (0, n2.assertNodeType)("BlockStatement") }, async: { validate: (0, n2.assertValueType)("boolean"), default: false } } }), (0, n2.default)("ExportDefaultSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, n2.assertNodeType)("Identifier") } } }), (0, n2.default)("RecordExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("ObjectProperty", "SpreadElement"))) } } }), (0, n2.default)("TupleExpression", { fields: { elements: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("Expression", "SpreadElement"))), default: [] } }, visitor: ["elements"], aliases: ["Expression"] }), (0, n2.default)("DecimalLiteral", { builder: ["value"], fields: { value: { validate: (0, n2.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, n2.default)("ModuleExpression", { visitor: ["body"], fields: { body: { validate: (0, n2.assertNodeType)("Program") } }, aliases: ["Expression"] }), (0, n2.default)("TopicReference", { aliases: ["Expression"] }), (0, n2.default)("PipelineTopicExpression", { builder: ["expression"], visitor: ["expression"], fields: { expression: { validate: (0, n2.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, n2.default)("PipelineBareFunction", { builder: ["callee"], visitor: ["callee"], fields: { callee: { validate: (0, n2.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, n2.default)("PipelinePrimaryTopicReference", { aliases: ["Expression"] });
}, (e2, t2, r2) => {
  var n2 = r2(18), s2 = r2(167), i2 = r2(42);
  const o2 = (0, n2.defineAliasedType)("TypeScript"), a2 = (0, n2.assertValueType)("boolean"), l = () => ({ returnType: { validate: (0, n2.assertNodeType)("TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, n2.assertNodeType)("TSTypeParameterDeclaration", "Noop"), optional: true } });
  o2("TSParameterProperty", { aliases: ["LVal"], visitor: ["parameter"], fields: { accessibility: { validate: (0, n2.assertOneOf)("public", "private", "protected"), optional: true }, readonly: { validate: (0, n2.assertValueType)("boolean"), optional: true }, parameter: { validate: (0, n2.assertNodeType)("Identifier", "AssignmentPattern") }, override: { validate: (0, n2.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("Decorator"))), optional: true } } }), o2("TSDeclareFunction", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, s2.functionDeclarationCommon)(), l()) }), o2("TSDeclareMethod", { visitor: ["decorators", "key", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, s2.classMethodOrDeclareMethodCommon)(), l()) }), o2("TSQualifiedName", { aliases: ["TSEntityName"], visitor: ["left", "right"], fields: { left: (0, n2.validateType)("TSEntityName"), right: (0, n2.validateType)("Identifier") } });
  const c = () => ({ typeParameters: (0, n2.validateOptionalType)("TSTypeParameterDeclaration"), parameters: (0, n2.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]), typeAnnotation: (0, n2.validateOptionalType)("TSTypeAnnotation") }), u = { aliases: ["TSTypeElement"], visitor: ["typeParameters", "parameters", "typeAnnotation"], fields: c() };
  o2("TSCallSignatureDeclaration", u), o2("TSConstructSignatureDeclaration", u);
  const p = () => ({ key: (0, n2.validateType)("Expression"), computed: { default: false }, optional: (0, n2.validateOptional)(a2) });
  o2("TSPropertySignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeAnnotation"], fields: Object.assign({}, p(), { readonly: (0, n2.validateOptional)(a2), typeAnnotation: (0, n2.validateOptionalType)("TSTypeAnnotation"), kind: { validate: (0, n2.assertOneOf)("get", "set") } }) }), o2("TSMethodSignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeParameters", "parameters", "typeAnnotation"], fields: Object.assign({}, c(), p(), { kind: { validate: (0, n2.assertOneOf)("method", "get", "set") } }) }), o2("TSIndexSignature", { aliases: ["TSTypeElement"], visitor: ["parameters", "typeAnnotation"], fields: { readonly: (0, n2.validateOptional)(a2), static: (0, n2.validateOptional)(a2), parameters: (0, n2.validateArrayOfType)("Identifier"), typeAnnotation: (0, n2.validateOptionalType)("TSTypeAnnotation") } });
  const d = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (const e3 of d) o2(e3, { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
  o2("TSThisType", { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
  const f = { aliases: ["TSType"], visitor: ["typeParameters", "parameters", "typeAnnotation"] };
  o2("TSFunctionType", Object.assign({}, f, { fields: c() })), o2("TSConstructorType", Object.assign({}, f, { fields: Object.assign({}, c(), { abstract: (0, n2.validateOptional)(a2) }) })), o2("TSTypeReference", { aliases: ["TSType"], visitor: ["typeName", "typeParameters"], fields: { typeName: (0, n2.validateType)("TSEntityName"), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterInstantiation") } }), o2("TSTypePredicate", { aliases: ["TSType"], visitor: ["parameterName", "typeAnnotation"], builder: ["parameterName", "typeAnnotation", "asserts"], fields: { parameterName: (0, n2.validateType)(["Identifier", "TSThisType"]), typeAnnotation: (0, n2.validateOptionalType)("TSTypeAnnotation"), asserts: (0, n2.validateOptional)(a2) } }), o2("TSTypeQuery", { aliases: ["TSType"], visitor: ["exprName", "typeParameters"], fields: { exprName: (0, n2.validateType)(["TSEntityName", "TSImportType"]), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterInstantiation") } }), o2("TSTypeLiteral", { aliases: ["TSType"], visitor: ["members"], fields: { members: (0, n2.validateArrayOfType)("TSTypeElement") } }), o2("TSArrayType", { aliases: ["TSType"], visitor: ["elementType"], fields: { elementType: (0, n2.validateType)("TSType") } }), o2("TSTupleType", { aliases: ["TSType"], visitor: ["elementTypes"], fields: { elementTypes: (0, n2.validateArrayOfType)(["TSType", "TSNamedTupleMember"]) } }), o2("TSOptionalType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n2.validateType)("TSType") } }), o2("TSRestType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n2.validateType)("TSType") } }), o2("TSNamedTupleMember", { visitor: ["label", "elementType"], builder: ["label", "elementType", "optional"], fields: { label: (0, n2.validateType)("Identifier"), optional: { validate: a2, default: false }, elementType: (0, n2.validateType)("TSType") } });
  const h = { aliases: ["TSType"], visitor: ["types"], fields: { types: (0, n2.validateArrayOfType)("TSType") } };
  o2("TSUnionType", h), o2("TSIntersectionType", h), o2("TSConditionalType", { aliases: ["TSType"], visitor: ["checkType", "extendsType", "trueType", "falseType"], fields: { checkType: (0, n2.validateType)("TSType"), extendsType: (0, n2.validateType)("TSType"), trueType: (0, n2.validateType)("TSType"), falseType: (0, n2.validateType)("TSType") } }), o2("TSInferType", { aliases: ["TSType"], visitor: ["typeParameter"], fields: { typeParameter: (0, n2.validateType)("TSTypeParameter") } }), o2("TSParenthesizedType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n2.validateType)("TSType") } }), o2("TSTypeOperator", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { operator: (0, n2.validate)((0, n2.assertValueType)("string")), typeAnnotation: (0, n2.validateType)("TSType") } }), o2("TSIndexedAccessType", { aliases: ["TSType"], visitor: ["objectType", "indexType"], fields: { objectType: (0, n2.validateType)("TSType"), indexType: (0, n2.validateType)("TSType") } }), o2("TSMappedType", { aliases: ["TSType"], visitor: ["typeParameter", "typeAnnotation", "nameType"], fields: { readonly: (0, n2.validateOptional)((0, n2.assertOneOf)(true, false, "+", "-")), typeParameter: (0, n2.validateType)("TSTypeParameter"), optional: (0, n2.validateOptional)((0, n2.assertOneOf)(true, false, "+", "-")), typeAnnotation: (0, n2.validateOptionalType)("TSType"), nameType: (0, n2.validateOptionalType)("TSType") } }), o2("TSLiteralType", { aliases: ["TSType", "TSBaseType"], visitor: ["literal"], fields: { literal: { validate: function() {
    const e3 = (0, n2.assertNodeType)("NumericLiteral", "BigIntLiteral"), t3 = (0, n2.assertOneOf)("-"), r3 = (0, n2.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
    function s3(n3, s4, o3) {
      (0, i2.default)("UnaryExpression", o3) ? (t3(o3, "operator", o3.operator), e3(o3, "argument", o3.argument)) : r3(n3, s4, o3);
    }
    return s3.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], s3;
  }() } } }), o2("TSExpressionWithTypeArguments", { aliases: ["TSType"], visitor: ["expression", "typeParameters"], fields: { expression: (0, n2.validateType)("TSEntityName"), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterInstantiation") } }), o2("TSInterfaceDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "extends", "body"], fields: { declare: (0, n2.validateOptional)(a2), id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterDeclaration"), extends: (0, n2.validateOptional)((0, n2.arrayOfType)("TSExpressionWithTypeArguments")), body: (0, n2.validateType)("TSInterfaceBody") } }), o2("TSInterfaceBody", { visitor: ["body"], fields: { body: (0, n2.validateArrayOfType)("TSTypeElement") } }), o2("TSTypeAliasDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "typeAnnotation"], fields: { declare: (0, n2.validateOptional)(a2), id: (0, n2.validateType)("Identifier"), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterDeclaration"), typeAnnotation: (0, n2.validateType)("TSType") } }), o2("TSInstantiationExpression", { aliases: ["Expression"], visitor: ["expression", "typeParameters"], fields: { expression: (0, n2.validateType)("Expression"), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterInstantiation") } });
  const m = { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression", "typeAnnotation"], fields: { expression: (0, n2.validateType)("Expression"), typeAnnotation: (0, n2.validateType)("TSType") } };
  o2("TSAsExpression", m), o2("TSSatisfiesExpression", m), o2("TSTypeAssertion", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["typeAnnotation", "expression"], fields: { typeAnnotation: (0, n2.validateType)("TSType"), expression: (0, n2.validateType)("Expression") } }), o2("TSEnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "members"], fields: { declare: (0, n2.validateOptional)(a2), const: (0, n2.validateOptional)(a2), id: (0, n2.validateType)("Identifier"), members: (0, n2.validateArrayOfType)("TSEnumMember"), initializer: (0, n2.validateOptionalType)("Expression") } }), o2("TSEnumMember", { visitor: ["id", "initializer"], fields: { id: (0, n2.validateType)(["Identifier", "StringLiteral"]), initializer: (0, n2.validateOptionalType)("Expression") } }), o2("TSModuleDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { declare: (0, n2.validateOptional)(a2), global: (0, n2.validateOptional)(a2), id: (0, n2.validateType)(["Identifier", "StringLiteral"]), body: (0, n2.validateType)(["TSModuleBlock", "TSModuleDeclaration"]) } }), o2("TSModuleBlock", { aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"], visitor: ["body"], fields: { body: (0, n2.validateArrayOfType)("Statement") } }), o2("TSImportType", { aliases: ["TSType"], visitor: ["argument", "qualifier", "typeParameters"], fields: { argument: (0, n2.validateType)("StringLiteral"), qualifier: (0, n2.validateOptionalType)("TSEntityName"), typeParameters: (0, n2.validateOptionalType)("TSTypeParameterInstantiation") } }), o2("TSImportEqualsDeclaration", { aliases: ["Statement"], visitor: ["id", "moduleReference"], fields: { isExport: (0, n2.validate)(a2), id: (0, n2.validateType)("Identifier"), moduleReference: (0, n2.validateType)(["TSEntityName", "TSExternalModuleReference"]), importKind: { validate: (0, n2.assertOneOf)("type", "value"), optional: true } } }), o2("TSExternalModuleReference", { visitor: ["expression"], fields: { expression: (0, n2.validateType)("StringLiteral") } }), o2("TSNonNullExpression", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression"], fields: { expression: (0, n2.validateType)("Expression") } }), o2("TSExportAssignment", { aliases: ["Statement"], visitor: ["expression"], fields: { expression: (0, n2.validateType)("Expression") } }), o2("TSNamespaceExportDeclaration", { aliases: ["Statement"], visitor: ["id"], fields: { id: (0, n2.validateType)("Identifier") } }), o2("TSTypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: { validate: (0, n2.assertNodeType)("TSType") } } }), o2("TSTypeParameterInstantiation", { visitor: ["params"], fields: { params: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("TSType"))) } } }), o2("TSTypeParameterDeclaration", { visitor: ["params"], fields: { params: { validate: (0, n2.chain)((0, n2.assertValueType)("array"), (0, n2.assertEach)((0, n2.assertNodeType)("TSTypeParameter"))) } } }), o2("TSTypeParameter", { builder: ["constraint", "default", "name"], visitor: ["constraint", "default"], fields: { name: { validate: (0, n2.assertValueType)("string") }, in: { validate: (0, n2.assertValueType)("boolean"), optional: true }, out: { validate: (0, n2.assertValueType)("boolean"), optional: true }, const: { validate: (0, n2.assertValueType)("boolean"), optional: true }, constraint: { validate: (0, n2.assertNodeType)("TSType"), optional: true }, default: { validate: (0, n2.assertNodeType)("TSType"), optional: true } } });
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.DEPRECATED_ALIASES = void 0, t2.DEPRECATED_ALIASES = { ModuleDeclaration: "ImportOrExportDeclaration" };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    if (!(0, n2.default)(e3)) {
      var t3;
      const r3 = null != (t3 = null == e3 ? void 0 : e3.type) ? t3 : JSON.stringify(e3);
      throw new TypeError(`Not a valid node of type "${r3}"`);
    }
  };
  var n2 = r2(170);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.assertAccessor = function(e3, t3) {
    i2("Accessor", e3, t3);
  }, t2.assertAnyTypeAnnotation = function(e3, t3) {
    i2("AnyTypeAnnotation", e3, t3);
  }, t2.assertArgumentPlaceholder = function(e3, t3) {
    i2("ArgumentPlaceholder", e3, t3);
  }, t2.assertArrayExpression = function(e3, t3) {
    i2("ArrayExpression", e3, t3);
  }, t2.assertArrayPattern = function(e3, t3) {
    i2("ArrayPattern", e3, t3);
  }, t2.assertArrayTypeAnnotation = function(e3, t3) {
    i2("ArrayTypeAnnotation", e3, t3);
  }, t2.assertArrowFunctionExpression = function(e3, t3) {
    i2("ArrowFunctionExpression", e3, t3);
  }, t2.assertAssignmentExpression = function(e3, t3) {
    i2("AssignmentExpression", e3, t3);
  }, t2.assertAssignmentPattern = function(e3, t3) {
    i2("AssignmentPattern", e3, t3);
  }, t2.assertAwaitExpression = function(e3, t3) {
    i2("AwaitExpression", e3, t3);
  }, t2.assertBigIntLiteral = function(e3, t3) {
    i2("BigIntLiteral", e3, t3);
  }, t2.assertBinary = function(e3, t3) {
    i2("Binary", e3, t3);
  }, t2.assertBinaryExpression = function(e3, t3) {
    i2("BinaryExpression", e3, t3);
  }, t2.assertBindExpression = function(e3, t3) {
    i2("BindExpression", e3, t3);
  }, t2.assertBlock = function(e3, t3) {
    i2("Block", e3, t3);
  }, t2.assertBlockParent = function(e3, t3) {
    i2("BlockParent", e3, t3);
  }, t2.assertBlockStatement = function(e3, t3) {
    i2("BlockStatement", e3, t3);
  }, t2.assertBooleanLiteral = function(e3, t3) {
    i2("BooleanLiteral", e3, t3);
  }, t2.assertBooleanLiteralTypeAnnotation = function(e3, t3) {
    i2("BooleanLiteralTypeAnnotation", e3, t3);
  }, t2.assertBooleanTypeAnnotation = function(e3, t3) {
    i2("BooleanTypeAnnotation", e3, t3);
  }, t2.assertBreakStatement = function(e3, t3) {
    i2("BreakStatement", e3, t3);
  }, t2.assertCallExpression = function(e3, t3) {
    i2("CallExpression", e3, t3);
  }, t2.assertCatchClause = function(e3, t3) {
    i2("CatchClause", e3, t3);
  }, t2.assertClass = function(e3, t3) {
    i2("Class", e3, t3);
  }, t2.assertClassAccessorProperty = function(e3, t3) {
    i2("ClassAccessorProperty", e3, t3);
  }, t2.assertClassBody = function(e3, t3) {
    i2("ClassBody", e3, t3);
  }, t2.assertClassDeclaration = function(e3, t3) {
    i2("ClassDeclaration", e3, t3);
  }, t2.assertClassExpression = function(e3, t3) {
    i2("ClassExpression", e3, t3);
  }, t2.assertClassImplements = function(e3, t3) {
    i2("ClassImplements", e3, t3);
  }, t2.assertClassMethod = function(e3, t3) {
    i2("ClassMethod", e3, t3);
  }, t2.assertClassPrivateMethod = function(e3, t3) {
    i2("ClassPrivateMethod", e3, t3);
  }, t2.assertClassPrivateProperty = function(e3, t3) {
    i2("ClassPrivateProperty", e3, t3);
  }, t2.assertClassProperty = function(e3, t3) {
    i2("ClassProperty", e3, t3);
  }, t2.assertCompletionStatement = function(e3, t3) {
    i2("CompletionStatement", e3, t3);
  }, t2.assertConditional = function(e3, t3) {
    i2("Conditional", e3, t3);
  }, t2.assertConditionalExpression = function(e3, t3) {
    i2("ConditionalExpression", e3, t3);
  }, t2.assertContinueStatement = function(e3, t3) {
    i2("ContinueStatement", e3, t3);
  }, t2.assertDebuggerStatement = function(e3, t3) {
    i2("DebuggerStatement", e3, t3);
  }, t2.assertDecimalLiteral = function(e3, t3) {
    i2("DecimalLiteral", e3, t3);
  }, t2.assertDeclaration = function(e3, t3) {
    i2("Declaration", e3, t3);
  }, t2.assertDeclareClass = function(e3, t3) {
    i2("DeclareClass", e3, t3);
  }, t2.assertDeclareExportAllDeclaration = function(e3, t3) {
    i2("DeclareExportAllDeclaration", e3, t3);
  }, t2.assertDeclareExportDeclaration = function(e3, t3) {
    i2("DeclareExportDeclaration", e3, t3);
  }, t2.assertDeclareFunction = function(e3, t3) {
    i2("DeclareFunction", e3, t3);
  }, t2.assertDeclareInterface = function(e3, t3) {
    i2("DeclareInterface", e3, t3);
  }, t2.assertDeclareModule = function(e3, t3) {
    i2("DeclareModule", e3, t3);
  }, t2.assertDeclareModuleExports = function(e3, t3) {
    i2("DeclareModuleExports", e3, t3);
  }, t2.assertDeclareOpaqueType = function(e3, t3) {
    i2("DeclareOpaqueType", e3, t3);
  }, t2.assertDeclareTypeAlias = function(e3, t3) {
    i2("DeclareTypeAlias", e3, t3);
  }, t2.assertDeclareVariable = function(e3, t3) {
    i2("DeclareVariable", e3, t3);
  }, t2.assertDeclaredPredicate = function(e3, t3) {
    i2("DeclaredPredicate", e3, t3);
  }, t2.assertDecorator = function(e3, t3) {
    i2("Decorator", e3, t3);
  }, t2.assertDirective = function(e3, t3) {
    i2("Directive", e3, t3);
  }, t2.assertDirectiveLiteral = function(e3, t3) {
    i2("DirectiveLiteral", e3, t3);
  }, t2.assertDoExpression = function(e3, t3) {
    i2("DoExpression", e3, t3);
  }, t2.assertDoWhileStatement = function(e3, t3) {
    i2("DoWhileStatement", e3, t3);
  }, t2.assertEmptyStatement = function(e3, t3) {
    i2("EmptyStatement", e3, t3);
  }, t2.assertEmptyTypeAnnotation = function(e3, t3) {
    i2("EmptyTypeAnnotation", e3, t3);
  }, t2.assertEnumBody = function(e3, t3) {
    i2("EnumBody", e3, t3);
  }, t2.assertEnumBooleanBody = function(e3, t3) {
    i2("EnumBooleanBody", e3, t3);
  }, t2.assertEnumBooleanMember = function(e3, t3) {
    i2("EnumBooleanMember", e3, t3);
  }, t2.assertEnumDeclaration = function(e3, t3) {
    i2("EnumDeclaration", e3, t3);
  }, t2.assertEnumDefaultedMember = function(e3, t3) {
    i2("EnumDefaultedMember", e3, t3);
  }, t2.assertEnumMember = function(e3, t3) {
    i2("EnumMember", e3, t3);
  }, t2.assertEnumNumberBody = function(e3, t3) {
    i2("EnumNumberBody", e3, t3);
  }, t2.assertEnumNumberMember = function(e3, t3) {
    i2("EnumNumberMember", e3, t3);
  }, t2.assertEnumStringBody = function(e3, t3) {
    i2("EnumStringBody", e3, t3);
  }, t2.assertEnumStringMember = function(e3, t3) {
    i2("EnumStringMember", e3, t3);
  }, t2.assertEnumSymbolBody = function(e3, t3) {
    i2("EnumSymbolBody", e3, t3);
  }, t2.assertExistsTypeAnnotation = function(e3, t3) {
    i2("ExistsTypeAnnotation", e3, t3);
  }, t2.assertExportAllDeclaration = function(e3, t3) {
    i2("ExportAllDeclaration", e3, t3);
  }, t2.assertExportDeclaration = function(e3, t3) {
    i2("ExportDeclaration", e3, t3);
  }, t2.assertExportDefaultDeclaration = function(e3, t3) {
    i2("ExportDefaultDeclaration", e3, t3);
  }, t2.assertExportDefaultSpecifier = function(e3, t3) {
    i2("ExportDefaultSpecifier", e3, t3);
  }, t2.assertExportNamedDeclaration = function(e3, t3) {
    i2("ExportNamedDeclaration", e3, t3);
  }, t2.assertExportNamespaceSpecifier = function(e3, t3) {
    i2("ExportNamespaceSpecifier", e3, t3);
  }, t2.assertExportSpecifier = function(e3, t3) {
    i2("ExportSpecifier", e3, t3);
  }, t2.assertExpression = function(e3, t3) {
    i2("Expression", e3, t3);
  }, t2.assertExpressionStatement = function(e3, t3) {
    i2("ExpressionStatement", e3, t3);
  }, t2.assertExpressionWrapper = function(e3, t3) {
    i2("ExpressionWrapper", e3, t3);
  }, t2.assertFile = function(e3, t3) {
    i2("File", e3, t3);
  }, t2.assertFlow = function(e3, t3) {
    i2("Flow", e3, t3);
  }, t2.assertFlowBaseAnnotation = function(e3, t3) {
    i2("FlowBaseAnnotation", e3, t3);
  }, t2.assertFlowDeclaration = function(e3, t3) {
    i2("FlowDeclaration", e3, t3);
  }, t2.assertFlowPredicate = function(e3, t3) {
    i2("FlowPredicate", e3, t3);
  }, t2.assertFlowType = function(e3, t3) {
    i2("FlowType", e3, t3);
  }, t2.assertFor = function(e3, t3) {
    i2("For", e3, t3);
  }, t2.assertForInStatement = function(e3, t3) {
    i2("ForInStatement", e3, t3);
  }, t2.assertForOfStatement = function(e3, t3) {
    i2("ForOfStatement", e3, t3);
  }, t2.assertForStatement = function(e3, t3) {
    i2("ForStatement", e3, t3);
  }, t2.assertForXStatement = function(e3, t3) {
    i2("ForXStatement", e3, t3);
  }, t2.assertFunction = function(e3, t3) {
    i2("Function", e3, t3);
  }, t2.assertFunctionDeclaration = function(e3, t3) {
    i2("FunctionDeclaration", e3, t3);
  }, t2.assertFunctionExpression = function(e3, t3) {
    i2("FunctionExpression", e3, t3);
  }, t2.assertFunctionParent = function(e3, t3) {
    i2("FunctionParent", e3, t3);
  }, t2.assertFunctionTypeAnnotation = function(e3, t3) {
    i2("FunctionTypeAnnotation", e3, t3);
  }, t2.assertFunctionTypeParam = function(e3, t3) {
    i2("FunctionTypeParam", e3, t3);
  }, t2.assertGenericTypeAnnotation = function(e3, t3) {
    i2("GenericTypeAnnotation", e3, t3);
  }, t2.assertIdentifier = function(e3, t3) {
    i2("Identifier", e3, t3);
  }, t2.assertIfStatement = function(e3, t3) {
    i2("IfStatement", e3, t3);
  }, t2.assertImmutable = function(e3, t3) {
    i2("Immutable", e3, t3);
  }, t2.assertImport = function(e3, t3) {
    i2("Import", e3, t3);
  }, t2.assertImportAttribute = function(e3, t3) {
    i2("ImportAttribute", e3, t3);
  }, t2.assertImportDeclaration = function(e3, t3) {
    i2("ImportDeclaration", e3, t3);
  }, t2.assertImportDefaultSpecifier = function(e3, t3) {
    i2("ImportDefaultSpecifier", e3, t3);
  }, t2.assertImportExpression = function(e3, t3) {
    i2("ImportExpression", e3, t3);
  }, t2.assertImportNamespaceSpecifier = function(e3, t3) {
    i2("ImportNamespaceSpecifier", e3, t3);
  }, t2.assertImportOrExportDeclaration = function(e3, t3) {
    i2("ImportOrExportDeclaration", e3, t3);
  }, t2.assertImportSpecifier = function(e3, t3) {
    i2("ImportSpecifier", e3, t3);
  }, t2.assertIndexedAccessType = function(e3, t3) {
    i2("IndexedAccessType", e3, t3);
  }, t2.assertInferredPredicate = function(e3, t3) {
    i2("InferredPredicate", e3, t3);
  }, t2.assertInterfaceDeclaration = function(e3, t3) {
    i2("InterfaceDeclaration", e3, t3);
  }, t2.assertInterfaceExtends = function(e3, t3) {
    i2("InterfaceExtends", e3, t3);
  }, t2.assertInterfaceTypeAnnotation = function(e3, t3) {
    i2("InterfaceTypeAnnotation", e3, t3);
  }, t2.assertInterpreterDirective = function(e3, t3) {
    i2("InterpreterDirective", e3, t3);
  }, t2.assertIntersectionTypeAnnotation = function(e3, t3) {
    i2("IntersectionTypeAnnotation", e3, t3);
  }, t2.assertJSX = function(e3, t3) {
    i2("JSX", e3, t3);
  }, t2.assertJSXAttribute = function(e3, t3) {
    i2("JSXAttribute", e3, t3);
  }, t2.assertJSXClosingElement = function(e3, t3) {
    i2("JSXClosingElement", e3, t3);
  }, t2.assertJSXClosingFragment = function(e3, t3) {
    i2("JSXClosingFragment", e3, t3);
  }, t2.assertJSXElement = function(e3, t3) {
    i2("JSXElement", e3, t3);
  }, t2.assertJSXEmptyExpression = function(e3, t3) {
    i2("JSXEmptyExpression", e3, t3);
  }, t2.assertJSXExpressionContainer = function(e3, t3) {
    i2("JSXExpressionContainer", e3, t3);
  }, t2.assertJSXFragment = function(e3, t3) {
    i2("JSXFragment", e3, t3);
  }, t2.assertJSXIdentifier = function(e3, t3) {
    i2("JSXIdentifier", e3, t3);
  }, t2.assertJSXMemberExpression = function(e3, t3) {
    i2("JSXMemberExpression", e3, t3);
  }, t2.assertJSXNamespacedName = function(e3, t3) {
    i2("JSXNamespacedName", e3, t3);
  }, t2.assertJSXOpeningElement = function(e3, t3) {
    i2("JSXOpeningElement", e3, t3);
  }, t2.assertJSXOpeningFragment = function(e3, t3) {
    i2("JSXOpeningFragment", e3, t3);
  }, t2.assertJSXSpreadAttribute = function(e3, t3) {
    i2("JSXSpreadAttribute", e3, t3);
  }, t2.assertJSXSpreadChild = function(e3, t3) {
    i2("JSXSpreadChild", e3, t3);
  }, t2.assertJSXText = function(e3, t3) {
    i2("JSXText", e3, t3);
  }, t2.assertLVal = function(e3, t3) {
    i2("LVal", e3, t3);
  }, t2.assertLabeledStatement = function(e3, t3) {
    i2("LabeledStatement", e3, t3);
  }, t2.assertLiteral = function(e3, t3) {
    i2("Literal", e3, t3);
  }, t2.assertLogicalExpression = function(e3, t3) {
    i2("LogicalExpression", e3, t3);
  }, t2.assertLoop = function(e3, t3) {
    i2("Loop", e3, t3);
  }, t2.assertMemberExpression = function(e3, t3) {
    i2("MemberExpression", e3, t3);
  }, t2.assertMetaProperty = function(e3, t3) {
    i2("MetaProperty", e3, t3);
  }, t2.assertMethod = function(e3, t3) {
    i2("Method", e3, t3);
  }, t2.assertMiscellaneous = function(e3, t3) {
    i2("Miscellaneous", e3, t3);
  }, t2.assertMixedTypeAnnotation = function(e3, t3) {
    i2("MixedTypeAnnotation", e3, t3);
  }, t2.assertModuleDeclaration = function(e3, t3) {
    (0, s2.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), i2("ModuleDeclaration", e3, t3);
  }, t2.assertModuleExpression = function(e3, t3) {
    i2("ModuleExpression", e3, t3);
  }, t2.assertModuleSpecifier = function(e3, t3) {
    i2("ModuleSpecifier", e3, t3);
  }, t2.assertNewExpression = function(e3, t3) {
    i2("NewExpression", e3, t3);
  }, t2.assertNoop = function(e3, t3) {
    i2("Noop", e3, t3);
  }, t2.assertNullLiteral = function(e3, t3) {
    i2("NullLiteral", e3, t3);
  }, t2.assertNullLiteralTypeAnnotation = function(e3, t3) {
    i2("NullLiteralTypeAnnotation", e3, t3);
  }, t2.assertNullableTypeAnnotation = function(e3, t3) {
    i2("NullableTypeAnnotation", e3, t3);
  }, t2.assertNumberLiteral = function(e3, t3) {
    (0, s2.default)("assertNumberLiteral", "assertNumericLiteral"), i2("NumberLiteral", e3, t3);
  }, t2.assertNumberLiteralTypeAnnotation = function(e3, t3) {
    i2("NumberLiteralTypeAnnotation", e3, t3);
  }, t2.assertNumberTypeAnnotation = function(e3, t3) {
    i2("NumberTypeAnnotation", e3, t3);
  }, t2.assertNumericLiteral = function(e3, t3) {
    i2("NumericLiteral", e3, t3);
  }, t2.assertObjectExpression = function(e3, t3) {
    i2("ObjectExpression", e3, t3);
  }, t2.assertObjectMember = function(e3, t3) {
    i2("ObjectMember", e3, t3);
  }, t2.assertObjectMethod = function(e3, t3) {
    i2("ObjectMethod", e3, t3);
  }, t2.assertObjectPattern = function(e3, t3) {
    i2("ObjectPattern", e3, t3);
  }, t2.assertObjectProperty = function(e3, t3) {
    i2("ObjectProperty", e3, t3);
  }, t2.assertObjectTypeAnnotation = function(e3, t3) {
    i2("ObjectTypeAnnotation", e3, t3);
  }, t2.assertObjectTypeCallProperty = function(e3, t3) {
    i2("ObjectTypeCallProperty", e3, t3);
  }, t2.assertObjectTypeIndexer = function(e3, t3) {
    i2("ObjectTypeIndexer", e3, t3);
  }, t2.assertObjectTypeInternalSlot = function(e3, t3) {
    i2("ObjectTypeInternalSlot", e3, t3);
  }, t2.assertObjectTypeProperty = function(e3, t3) {
    i2("ObjectTypeProperty", e3, t3);
  }, t2.assertObjectTypeSpreadProperty = function(e3, t3) {
    i2("ObjectTypeSpreadProperty", e3, t3);
  }, t2.assertOpaqueType = function(e3, t3) {
    i2("OpaqueType", e3, t3);
  }, t2.assertOptionalCallExpression = function(e3, t3) {
    i2("OptionalCallExpression", e3, t3);
  }, t2.assertOptionalIndexedAccessType = function(e3, t3) {
    i2("OptionalIndexedAccessType", e3, t3);
  }, t2.assertOptionalMemberExpression = function(e3, t3) {
    i2("OptionalMemberExpression", e3, t3);
  }, t2.assertParenthesizedExpression = function(e3, t3) {
    i2("ParenthesizedExpression", e3, t3);
  }, t2.assertPattern = function(e3, t3) {
    i2("Pattern", e3, t3);
  }, t2.assertPatternLike = function(e3, t3) {
    i2("PatternLike", e3, t3);
  }, t2.assertPipelineBareFunction = function(e3, t3) {
    i2("PipelineBareFunction", e3, t3);
  }, t2.assertPipelinePrimaryTopicReference = function(e3, t3) {
    i2("PipelinePrimaryTopicReference", e3, t3);
  }, t2.assertPipelineTopicExpression = function(e3, t3) {
    i2("PipelineTopicExpression", e3, t3);
  }, t2.assertPlaceholder = function(e3, t3) {
    i2("Placeholder", e3, t3);
  }, t2.assertPrivate = function(e3, t3) {
    i2("Private", e3, t3);
  }, t2.assertPrivateName = function(e3, t3) {
    i2("PrivateName", e3, t3);
  }, t2.assertProgram = function(e3, t3) {
    i2("Program", e3, t3);
  }, t2.assertProperty = function(e3, t3) {
    i2("Property", e3, t3);
  }, t2.assertPureish = function(e3, t3) {
    i2("Pureish", e3, t3);
  }, t2.assertQualifiedTypeIdentifier = function(e3, t3) {
    i2("QualifiedTypeIdentifier", e3, t3);
  }, t2.assertRecordExpression = function(e3, t3) {
    i2("RecordExpression", e3, t3);
  }, t2.assertRegExpLiteral = function(e3, t3) {
    i2("RegExpLiteral", e3, t3);
  }, t2.assertRegexLiteral = function(e3, t3) {
    (0, s2.default)("assertRegexLiteral", "assertRegExpLiteral"), i2("RegexLiteral", e3, t3);
  }, t2.assertRestElement = function(e3, t3) {
    i2("RestElement", e3, t3);
  }, t2.assertRestProperty = function(e3, t3) {
    (0, s2.default)("assertRestProperty", "assertRestElement"), i2("RestProperty", e3, t3);
  }, t2.assertReturnStatement = function(e3, t3) {
    i2("ReturnStatement", e3, t3);
  }, t2.assertScopable = function(e3, t3) {
    i2("Scopable", e3, t3);
  }, t2.assertSequenceExpression = function(e3, t3) {
    i2("SequenceExpression", e3, t3);
  }, t2.assertSpreadElement = function(e3, t3) {
    i2("SpreadElement", e3, t3);
  }, t2.assertSpreadProperty = function(e3, t3) {
    (0, s2.default)("assertSpreadProperty", "assertSpreadElement"), i2("SpreadProperty", e3, t3);
  }, t2.assertStandardized = function(e3, t3) {
    i2("Standardized", e3, t3);
  }, t2.assertStatement = function(e3, t3) {
    i2("Statement", e3, t3);
  }, t2.assertStaticBlock = function(e3, t3) {
    i2("StaticBlock", e3, t3);
  }, t2.assertStringLiteral = function(e3, t3) {
    i2("StringLiteral", e3, t3);
  }, t2.assertStringLiteralTypeAnnotation = function(e3, t3) {
    i2("StringLiteralTypeAnnotation", e3, t3);
  }, t2.assertStringTypeAnnotation = function(e3, t3) {
    i2("StringTypeAnnotation", e3, t3);
  }, t2.assertSuper = function(e3, t3) {
    i2("Super", e3, t3);
  }, t2.assertSwitchCase = function(e3, t3) {
    i2("SwitchCase", e3, t3);
  }, t2.assertSwitchStatement = function(e3, t3) {
    i2("SwitchStatement", e3, t3);
  }, t2.assertSymbolTypeAnnotation = function(e3, t3) {
    i2("SymbolTypeAnnotation", e3, t3);
  }, t2.assertTSAnyKeyword = function(e3, t3) {
    i2("TSAnyKeyword", e3, t3);
  }, t2.assertTSArrayType = function(e3, t3) {
    i2("TSArrayType", e3, t3);
  }, t2.assertTSAsExpression = function(e3, t3) {
    i2("TSAsExpression", e3, t3);
  }, t2.assertTSBaseType = function(e3, t3) {
    i2("TSBaseType", e3, t3);
  }, t2.assertTSBigIntKeyword = function(e3, t3) {
    i2("TSBigIntKeyword", e3, t3);
  }, t2.assertTSBooleanKeyword = function(e3, t3) {
    i2("TSBooleanKeyword", e3, t3);
  }, t2.assertTSCallSignatureDeclaration = function(e3, t3) {
    i2("TSCallSignatureDeclaration", e3, t3);
  }, t2.assertTSConditionalType = function(e3, t3) {
    i2("TSConditionalType", e3, t3);
  }, t2.assertTSConstructSignatureDeclaration = function(e3, t3) {
    i2("TSConstructSignatureDeclaration", e3, t3);
  }, t2.assertTSConstructorType = function(e3, t3) {
    i2("TSConstructorType", e3, t3);
  }, t2.assertTSDeclareFunction = function(e3, t3) {
    i2("TSDeclareFunction", e3, t3);
  }, t2.assertTSDeclareMethod = function(e3, t3) {
    i2("TSDeclareMethod", e3, t3);
  }, t2.assertTSEntityName = function(e3, t3) {
    i2("TSEntityName", e3, t3);
  }, t2.assertTSEnumDeclaration = function(e3, t3) {
    i2("TSEnumDeclaration", e3, t3);
  }, t2.assertTSEnumMember = function(e3, t3) {
    i2("TSEnumMember", e3, t3);
  }, t2.assertTSExportAssignment = function(e3, t3) {
    i2("TSExportAssignment", e3, t3);
  }, t2.assertTSExpressionWithTypeArguments = function(e3, t3) {
    i2("TSExpressionWithTypeArguments", e3, t3);
  }, t2.assertTSExternalModuleReference = function(e3, t3) {
    i2("TSExternalModuleReference", e3, t3);
  }, t2.assertTSFunctionType = function(e3, t3) {
    i2("TSFunctionType", e3, t3);
  }, t2.assertTSImportEqualsDeclaration = function(e3, t3) {
    i2("TSImportEqualsDeclaration", e3, t3);
  }, t2.assertTSImportType = function(e3, t3) {
    i2("TSImportType", e3, t3);
  }, t2.assertTSIndexSignature = function(e3, t3) {
    i2("TSIndexSignature", e3, t3);
  }, t2.assertTSIndexedAccessType = function(e3, t3) {
    i2("TSIndexedAccessType", e3, t3);
  }, t2.assertTSInferType = function(e3, t3) {
    i2("TSInferType", e3, t3);
  }, t2.assertTSInstantiationExpression = function(e3, t3) {
    i2("TSInstantiationExpression", e3, t3);
  }, t2.assertTSInterfaceBody = function(e3, t3) {
    i2("TSInterfaceBody", e3, t3);
  }, t2.assertTSInterfaceDeclaration = function(e3, t3) {
    i2("TSInterfaceDeclaration", e3, t3);
  }, t2.assertTSIntersectionType = function(e3, t3) {
    i2("TSIntersectionType", e3, t3);
  }, t2.assertTSIntrinsicKeyword = function(e3, t3) {
    i2("TSIntrinsicKeyword", e3, t3);
  }, t2.assertTSLiteralType = function(e3, t3) {
    i2("TSLiteralType", e3, t3);
  }, t2.assertTSMappedType = function(e3, t3) {
    i2("TSMappedType", e3, t3);
  }, t2.assertTSMethodSignature = function(e3, t3) {
    i2("TSMethodSignature", e3, t3);
  }, t2.assertTSModuleBlock = function(e3, t3) {
    i2("TSModuleBlock", e3, t3);
  }, t2.assertTSModuleDeclaration = function(e3, t3) {
    i2("TSModuleDeclaration", e3, t3);
  }, t2.assertTSNamedTupleMember = function(e3, t3) {
    i2("TSNamedTupleMember", e3, t3);
  }, t2.assertTSNamespaceExportDeclaration = function(e3, t3) {
    i2("TSNamespaceExportDeclaration", e3, t3);
  }, t2.assertTSNeverKeyword = function(e3, t3) {
    i2("TSNeverKeyword", e3, t3);
  }, t2.assertTSNonNullExpression = function(e3, t3) {
    i2("TSNonNullExpression", e3, t3);
  }, t2.assertTSNullKeyword = function(e3, t3) {
    i2("TSNullKeyword", e3, t3);
  }, t2.assertTSNumberKeyword = function(e3, t3) {
    i2("TSNumberKeyword", e3, t3);
  }, t2.assertTSObjectKeyword = function(e3, t3) {
    i2("TSObjectKeyword", e3, t3);
  }, t2.assertTSOptionalType = function(e3, t3) {
    i2("TSOptionalType", e3, t3);
  }, t2.assertTSParameterProperty = function(e3, t3) {
    i2("TSParameterProperty", e3, t3);
  }, t2.assertTSParenthesizedType = function(e3, t3) {
    i2("TSParenthesizedType", e3, t3);
  }, t2.assertTSPropertySignature = function(e3, t3) {
    i2("TSPropertySignature", e3, t3);
  }, t2.assertTSQualifiedName = function(e3, t3) {
    i2("TSQualifiedName", e3, t3);
  }, t2.assertTSRestType = function(e3, t3) {
    i2("TSRestType", e3, t3);
  }, t2.assertTSSatisfiesExpression = function(e3, t3) {
    i2("TSSatisfiesExpression", e3, t3);
  }, t2.assertTSStringKeyword = function(e3, t3) {
    i2("TSStringKeyword", e3, t3);
  }, t2.assertTSSymbolKeyword = function(e3, t3) {
    i2("TSSymbolKeyword", e3, t3);
  }, t2.assertTSThisType = function(e3, t3) {
    i2("TSThisType", e3, t3);
  }, t2.assertTSTupleType = function(e3, t3) {
    i2("TSTupleType", e3, t3);
  }, t2.assertTSType = function(e3, t3) {
    i2("TSType", e3, t3);
  }, t2.assertTSTypeAliasDeclaration = function(e3, t3) {
    i2("TSTypeAliasDeclaration", e3, t3);
  }, t2.assertTSTypeAnnotation = function(e3, t3) {
    i2("TSTypeAnnotation", e3, t3);
  }, t2.assertTSTypeAssertion = function(e3, t3) {
    i2("TSTypeAssertion", e3, t3);
  }, t2.assertTSTypeElement = function(e3, t3) {
    i2("TSTypeElement", e3, t3);
  }, t2.assertTSTypeLiteral = function(e3, t3) {
    i2("TSTypeLiteral", e3, t3);
  }, t2.assertTSTypeOperator = function(e3, t3) {
    i2("TSTypeOperator", e3, t3);
  }, t2.assertTSTypeParameter = function(e3, t3) {
    i2("TSTypeParameter", e3, t3);
  }, t2.assertTSTypeParameterDeclaration = function(e3, t3) {
    i2("TSTypeParameterDeclaration", e3, t3);
  }, t2.assertTSTypeParameterInstantiation = function(e3, t3) {
    i2("TSTypeParameterInstantiation", e3, t3);
  }, t2.assertTSTypePredicate = function(e3, t3) {
    i2("TSTypePredicate", e3, t3);
  }, t2.assertTSTypeQuery = function(e3, t3) {
    i2("TSTypeQuery", e3, t3);
  }, t2.assertTSTypeReference = function(e3, t3) {
    i2("TSTypeReference", e3, t3);
  }, t2.assertTSUndefinedKeyword = function(e3, t3) {
    i2("TSUndefinedKeyword", e3, t3);
  }, t2.assertTSUnionType = function(e3, t3) {
    i2("TSUnionType", e3, t3);
  }, t2.assertTSUnknownKeyword = function(e3, t3) {
    i2("TSUnknownKeyword", e3, t3);
  }, t2.assertTSVoidKeyword = function(e3, t3) {
    i2("TSVoidKeyword", e3, t3);
  }, t2.assertTaggedTemplateExpression = function(e3, t3) {
    i2("TaggedTemplateExpression", e3, t3);
  }, t2.assertTemplateElement = function(e3, t3) {
    i2("TemplateElement", e3, t3);
  }, t2.assertTemplateLiteral = function(e3, t3) {
    i2("TemplateLiteral", e3, t3);
  }, t2.assertTerminatorless = function(e3, t3) {
    i2("Terminatorless", e3, t3);
  }, t2.assertThisExpression = function(e3, t3) {
    i2("ThisExpression", e3, t3);
  }, t2.assertThisTypeAnnotation = function(e3, t3) {
    i2("ThisTypeAnnotation", e3, t3);
  }, t2.assertThrowStatement = function(e3, t3) {
    i2("ThrowStatement", e3, t3);
  }, t2.assertTopicReference = function(e3, t3) {
    i2("TopicReference", e3, t3);
  }, t2.assertTryStatement = function(e3, t3) {
    i2("TryStatement", e3, t3);
  }, t2.assertTupleExpression = function(e3, t3) {
    i2("TupleExpression", e3, t3);
  }, t2.assertTupleTypeAnnotation = function(e3, t3) {
    i2("TupleTypeAnnotation", e3, t3);
  }, t2.assertTypeAlias = function(e3, t3) {
    i2("TypeAlias", e3, t3);
  }, t2.assertTypeAnnotation = function(e3, t3) {
    i2("TypeAnnotation", e3, t3);
  }, t2.assertTypeCastExpression = function(e3, t3) {
    i2("TypeCastExpression", e3, t3);
  }, t2.assertTypeParameter = function(e3, t3) {
    i2("TypeParameter", e3, t3);
  }, t2.assertTypeParameterDeclaration = function(e3, t3) {
    i2("TypeParameterDeclaration", e3, t3);
  }, t2.assertTypeParameterInstantiation = function(e3, t3) {
    i2("TypeParameterInstantiation", e3, t3);
  }, t2.assertTypeScript = function(e3, t3) {
    i2("TypeScript", e3, t3);
  }, t2.assertTypeofTypeAnnotation = function(e3, t3) {
    i2("TypeofTypeAnnotation", e3, t3);
  }, t2.assertUnaryExpression = function(e3, t3) {
    i2("UnaryExpression", e3, t3);
  }, t2.assertUnaryLike = function(e3, t3) {
    i2("UnaryLike", e3, t3);
  }, t2.assertUnionTypeAnnotation = function(e3, t3) {
    i2("UnionTypeAnnotation", e3, t3);
  }, t2.assertUpdateExpression = function(e3, t3) {
    i2("UpdateExpression", e3, t3);
  }, t2.assertUserWhitespacable = function(e3, t3) {
    i2("UserWhitespacable", e3, t3);
  }, t2.assertV8IntrinsicIdentifier = function(e3, t3) {
    i2("V8IntrinsicIdentifier", e3, t3);
  }, t2.assertVariableDeclaration = function(e3, t3) {
    i2("VariableDeclaration", e3, t3);
  }, t2.assertVariableDeclarator = function(e3, t3) {
    i2("VariableDeclarator", e3, t3);
  }, t2.assertVariance = function(e3, t3) {
    i2("Variance", e3, t3);
  }, t2.assertVoidTypeAnnotation = function(e3, t3) {
    i2("VoidTypeAnnotation", e3, t3);
  }, t2.assertWhile = function(e3, t3) {
    i2("While", e3, t3);
  }, t2.assertWhileStatement = function(e3, t3) {
    i2("WhileStatement", e3, t3);
  }, t2.assertWithStatement = function(e3, t3) {
    i2("WithStatement", e3, t3);
  }, t2.assertYieldExpression = function(e3, t3) {
    i2("YieldExpression", e3, t3);
  };
  var n2 = r2(42), s2 = r2(58);
  function i2(e3, t3, r3) {
    if (!(0, n2.default)(e3, t3, r3)) throw new Error(`Expected type "${e3}" with option ${JSON.stringify(r3)}, but instead got "${t3.type}".`);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(4);
  t2.default = function(e3) {
    switch (e3) {
      case "string":
        return (0, n2.stringTypeAnnotation)();
      case "number":
        return (0, n2.numberTypeAnnotation)();
      case "undefined":
        return (0, n2.voidTypeAnnotation)();
      case "boolean":
        return (0, n2.booleanTypeAnnotation)();
      case "function":
        return (0, n2.genericTypeAnnotation)((0, n2.identifier)("Function"));
      case "object":
        return (0, n2.genericTypeAnnotation)((0, n2.identifier)("Object"));
      case "symbol":
        return (0, n2.genericTypeAnnotation)((0, n2.identifier)("Symbol"));
      case "bigint":
        return (0, n2.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + e3);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const t3 = (0, s2.default)(e3);
    return 1 === t3.length ? t3[0] : (0, n2.unionTypeAnnotation)(t3);
  };
  var n2 = r2(4), s2 = r2(171);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const t3 = e3.map((e4) => (0, i2.isTSTypeAnnotation)(e4) ? e4.typeAnnotation : e4), r3 = (0, s2.default)(t3);
    return 1 === r3.length ? r3[0] : (0, n2.tsUnionType)(r3);
  };
  var n2 = r2(4), s2 = r2(367), i2 = r2(2);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3) {
    const r3 = Array.from(t3), i2 = /* @__PURE__ */ new Map(), o2 = /* @__PURE__ */ new Map(), a2 = /* @__PURE__ */ new Set(), l = [];
    for (let t4 = 0; t4 < r3.length; t4++) {
      const c = r3[t4];
      if (c && !(l.indexOf(c) >= 0)) {
        if ((0, n2.isTSAnyKeyword)(c)) return [c];
        if ((0, n2.isTSBaseType)(c)) o2.set(c.type, c);
        else if ((0, n2.isTSUnionType)(c)) a2.has(c.types) || (r3.push(...c.types), a2.add(c.types));
        else if ((0, n2.isTSTypeReference)(c) && c.typeParameters) {
          const t5 = s2(c.typeName);
          if (i2.has(t5)) {
            let r4 = i2.get(t5);
            r4.typeParameters ? c.typeParameters && (r4.typeParameters.params.push(...c.typeParameters.params), r4.typeParameters.params = e3(r4.typeParameters.params)) : r4 = c.typeParameters;
          } else i2.set(t5, c);
        } else l.push(c);
      }
    }
    for (const [, e4] of o2) l.push(e4);
    for (const [, e4] of i2) l.push(e4);
    return l;
  };
  var n2 = r2(2);
  function s2(e3) {
    return (0, n2.isIdentifier)(e3) ? e3.name : `${e3.right.name}.${s2(e3.left)}`;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "AnyTypeAnnotation", { enumerable: true, get: function() {
    return n2.anyTypeAnnotation;
  } }), Object.defineProperty(t2, "ArgumentPlaceholder", { enumerable: true, get: function() {
    return n2.argumentPlaceholder;
  } }), Object.defineProperty(t2, "ArrayExpression", { enumerable: true, get: function() {
    return n2.arrayExpression;
  } }), Object.defineProperty(t2, "ArrayPattern", { enumerable: true, get: function() {
    return n2.arrayPattern;
  } }), Object.defineProperty(t2, "ArrayTypeAnnotation", { enumerable: true, get: function() {
    return n2.arrayTypeAnnotation;
  } }), Object.defineProperty(t2, "ArrowFunctionExpression", { enumerable: true, get: function() {
    return n2.arrowFunctionExpression;
  } }), Object.defineProperty(t2, "AssignmentExpression", { enumerable: true, get: function() {
    return n2.assignmentExpression;
  } }), Object.defineProperty(t2, "AssignmentPattern", { enumerable: true, get: function() {
    return n2.assignmentPattern;
  } }), Object.defineProperty(t2, "AwaitExpression", { enumerable: true, get: function() {
    return n2.awaitExpression;
  } }), Object.defineProperty(t2, "BigIntLiteral", { enumerable: true, get: function() {
    return n2.bigIntLiteral;
  } }), Object.defineProperty(t2, "BinaryExpression", { enumerable: true, get: function() {
    return n2.binaryExpression;
  } }), Object.defineProperty(t2, "BindExpression", { enumerable: true, get: function() {
    return n2.bindExpression;
  } }), Object.defineProperty(t2, "BlockStatement", { enumerable: true, get: function() {
    return n2.blockStatement;
  } }), Object.defineProperty(t2, "BooleanLiteral", { enumerable: true, get: function() {
    return n2.booleanLiteral;
  } }), Object.defineProperty(t2, "BooleanLiteralTypeAnnotation", { enumerable: true, get: function() {
    return n2.booleanLiteralTypeAnnotation;
  } }), Object.defineProperty(t2, "BooleanTypeAnnotation", { enumerable: true, get: function() {
    return n2.booleanTypeAnnotation;
  } }), Object.defineProperty(t2, "BreakStatement", { enumerable: true, get: function() {
    return n2.breakStatement;
  } }), Object.defineProperty(t2, "CallExpression", { enumerable: true, get: function() {
    return n2.callExpression;
  } }), Object.defineProperty(t2, "CatchClause", { enumerable: true, get: function() {
    return n2.catchClause;
  } }), Object.defineProperty(t2, "ClassAccessorProperty", { enumerable: true, get: function() {
    return n2.classAccessorProperty;
  } }), Object.defineProperty(t2, "ClassBody", { enumerable: true, get: function() {
    return n2.classBody;
  } }), Object.defineProperty(t2, "ClassDeclaration", { enumerable: true, get: function() {
    return n2.classDeclaration;
  } }), Object.defineProperty(t2, "ClassExpression", { enumerable: true, get: function() {
    return n2.classExpression;
  } }), Object.defineProperty(t2, "ClassImplements", { enumerable: true, get: function() {
    return n2.classImplements;
  } }), Object.defineProperty(t2, "ClassMethod", { enumerable: true, get: function() {
    return n2.classMethod;
  } }), Object.defineProperty(t2, "ClassPrivateMethod", { enumerable: true, get: function() {
    return n2.classPrivateMethod;
  } }), Object.defineProperty(t2, "ClassPrivateProperty", { enumerable: true, get: function() {
    return n2.classPrivateProperty;
  } }), Object.defineProperty(t2, "ClassProperty", { enumerable: true, get: function() {
    return n2.classProperty;
  } }), Object.defineProperty(t2, "ConditionalExpression", { enumerable: true, get: function() {
    return n2.conditionalExpression;
  } }), Object.defineProperty(t2, "ContinueStatement", { enumerable: true, get: function() {
    return n2.continueStatement;
  } }), Object.defineProperty(t2, "DebuggerStatement", { enumerable: true, get: function() {
    return n2.debuggerStatement;
  } }), Object.defineProperty(t2, "DecimalLiteral", { enumerable: true, get: function() {
    return n2.decimalLiteral;
  } }), Object.defineProperty(t2, "DeclareClass", { enumerable: true, get: function() {
    return n2.declareClass;
  } }), Object.defineProperty(t2, "DeclareExportAllDeclaration", { enumerable: true, get: function() {
    return n2.declareExportAllDeclaration;
  } }), Object.defineProperty(t2, "DeclareExportDeclaration", { enumerable: true, get: function() {
    return n2.declareExportDeclaration;
  } }), Object.defineProperty(t2, "DeclareFunction", { enumerable: true, get: function() {
    return n2.declareFunction;
  } }), Object.defineProperty(t2, "DeclareInterface", { enumerable: true, get: function() {
    return n2.declareInterface;
  } }), Object.defineProperty(t2, "DeclareModule", { enumerable: true, get: function() {
    return n2.declareModule;
  } }), Object.defineProperty(t2, "DeclareModuleExports", { enumerable: true, get: function() {
    return n2.declareModuleExports;
  } }), Object.defineProperty(t2, "DeclareOpaqueType", { enumerable: true, get: function() {
    return n2.declareOpaqueType;
  } }), Object.defineProperty(t2, "DeclareTypeAlias", { enumerable: true, get: function() {
    return n2.declareTypeAlias;
  } }), Object.defineProperty(t2, "DeclareVariable", { enumerable: true, get: function() {
    return n2.declareVariable;
  } }), Object.defineProperty(t2, "DeclaredPredicate", { enumerable: true, get: function() {
    return n2.declaredPredicate;
  } }), Object.defineProperty(t2, "Decorator", { enumerable: true, get: function() {
    return n2.decorator;
  } }), Object.defineProperty(t2, "Directive", { enumerable: true, get: function() {
    return n2.directive;
  } }), Object.defineProperty(t2, "DirectiveLiteral", { enumerable: true, get: function() {
    return n2.directiveLiteral;
  } }), Object.defineProperty(t2, "DoExpression", { enumerable: true, get: function() {
    return n2.doExpression;
  } }), Object.defineProperty(t2, "DoWhileStatement", { enumerable: true, get: function() {
    return n2.doWhileStatement;
  } }), Object.defineProperty(t2, "EmptyStatement", { enumerable: true, get: function() {
    return n2.emptyStatement;
  } }), Object.defineProperty(t2, "EmptyTypeAnnotation", { enumerable: true, get: function() {
    return n2.emptyTypeAnnotation;
  } }), Object.defineProperty(t2, "EnumBooleanBody", { enumerable: true, get: function() {
    return n2.enumBooleanBody;
  } }), Object.defineProperty(t2, "EnumBooleanMember", { enumerable: true, get: function() {
    return n2.enumBooleanMember;
  } }), Object.defineProperty(t2, "EnumDeclaration", { enumerable: true, get: function() {
    return n2.enumDeclaration;
  } }), Object.defineProperty(t2, "EnumDefaultedMember", { enumerable: true, get: function() {
    return n2.enumDefaultedMember;
  } }), Object.defineProperty(t2, "EnumNumberBody", { enumerable: true, get: function() {
    return n2.enumNumberBody;
  } }), Object.defineProperty(t2, "EnumNumberMember", { enumerable: true, get: function() {
    return n2.enumNumberMember;
  } }), Object.defineProperty(t2, "EnumStringBody", { enumerable: true, get: function() {
    return n2.enumStringBody;
  } }), Object.defineProperty(t2, "EnumStringMember", { enumerable: true, get: function() {
    return n2.enumStringMember;
  } }), Object.defineProperty(t2, "EnumSymbolBody", { enumerable: true, get: function() {
    return n2.enumSymbolBody;
  } }), Object.defineProperty(t2, "ExistsTypeAnnotation", { enumerable: true, get: function() {
    return n2.existsTypeAnnotation;
  } }), Object.defineProperty(t2, "ExportAllDeclaration", { enumerable: true, get: function() {
    return n2.exportAllDeclaration;
  } }), Object.defineProperty(t2, "ExportDefaultDeclaration", { enumerable: true, get: function() {
    return n2.exportDefaultDeclaration;
  } }), Object.defineProperty(t2, "ExportDefaultSpecifier", { enumerable: true, get: function() {
    return n2.exportDefaultSpecifier;
  } }), Object.defineProperty(t2, "ExportNamedDeclaration", { enumerable: true, get: function() {
    return n2.exportNamedDeclaration;
  } }), Object.defineProperty(t2, "ExportNamespaceSpecifier", { enumerable: true, get: function() {
    return n2.exportNamespaceSpecifier;
  } }), Object.defineProperty(t2, "ExportSpecifier", { enumerable: true, get: function() {
    return n2.exportSpecifier;
  } }), Object.defineProperty(t2, "ExpressionStatement", { enumerable: true, get: function() {
    return n2.expressionStatement;
  } }), Object.defineProperty(t2, "File", { enumerable: true, get: function() {
    return n2.file;
  } }), Object.defineProperty(t2, "ForInStatement", { enumerable: true, get: function() {
    return n2.forInStatement;
  } }), Object.defineProperty(t2, "ForOfStatement", { enumerable: true, get: function() {
    return n2.forOfStatement;
  } }), Object.defineProperty(t2, "ForStatement", { enumerable: true, get: function() {
    return n2.forStatement;
  } }), Object.defineProperty(t2, "FunctionDeclaration", { enumerable: true, get: function() {
    return n2.functionDeclaration;
  } }), Object.defineProperty(t2, "FunctionExpression", { enumerable: true, get: function() {
    return n2.functionExpression;
  } }), Object.defineProperty(t2, "FunctionTypeAnnotation", { enumerable: true, get: function() {
    return n2.functionTypeAnnotation;
  } }), Object.defineProperty(t2, "FunctionTypeParam", { enumerable: true, get: function() {
    return n2.functionTypeParam;
  } }), Object.defineProperty(t2, "GenericTypeAnnotation", { enumerable: true, get: function() {
    return n2.genericTypeAnnotation;
  } }), Object.defineProperty(t2, "Identifier", { enumerable: true, get: function() {
    return n2.identifier;
  } }), Object.defineProperty(t2, "IfStatement", { enumerable: true, get: function() {
    return n2.ifStatement;
  } }), Object.defineProperty(t2, "Import", { enumerable: true, get: function() {
    return n2.import;
  } }), Object.defineProperty(t2, "ImportAttribute", { enumerable: true, get: function() {
    return n2.importAttribute;
  } }), Object.defineProperty(t2, "ImportDeclaration", { enumerable: true, get: function() {
    return n2.importDeclaration;
  } }), Object.defineProperty(t2, "ImportDefaultSpecifier", { enumerable: true, get: function() {
    return n2.importDefaultSpecifier;
  } }), Object.defineProperty(t2, "ImportExpression", { enumerable: true, get: function() {
    return n2.importExpression;
  } }), Object.defineProperty(t2, "ImportNamespaceSpecifier", { enumerable: true, get: function() {
    return n2.importNamespaceSpecifier;
  } }), Object.defineProperty(t2, "ImportSpecifier", { enumerable: true, get: function() {
    return n2.importSpecifier;
  } }), Object.defineProperty(t2, "IndexedAccessType", { enumerable: true, get: function() {
    return n2.indexedAccessType;
  } }), Object.defineProperty(t2, "InferredPredicate", { enumerable: true, get: function() {
    return n2.inferredPredicate;
  } }), Object.defineProperty(t2, "InterfaceDeclaration", { enumerable: true, get: function() {
    return n2.interfaceDeclaration;
  } }), Object.defineProperty(t2, "InterfaceExtends", { enumerable: true, get: function() {
    return n2.interfaceExtends;
  } }), Object.defineProperty(t2, "InterfaceTypeAnnotation", { enumerable: true, get: function() {
    return n2.interfaceTypeAnnotation;
  } }), Object.defineProperty(t2, "InterpreterDirective", { enumerable: true, get: function() {
    return n2.interpreterDirective;
  } }), Object.defineProperty(t2, "IntersectionTypeAnnotation", { enumerable: true, get: function() {
    return n2.intersectionTypeAnnotation;
  } }), Object.defineProperty(t2, "JSXAttribute", { enumerable: true, get: function() {
    return n2.jsxAttribute;
  } }), Object.defineProperty(t2, "JSXClosingElement", { enumerable: true, get: function() {
    return n2.jsxClosingElement;
  } }), Object.defineProperty(t2, "JSXClosingFragment", { enumerable: true, get: function() {
    return n2.jsxClosingFragment;
  } }), Object.defineProperty(t2, "JSXElement", { enumerable: true, get: function() {
    return n2.jsxElement;
  } }), Object.defineProperty(t2, "JSXEmptyExpression", { enumerable: true, get: function() {
    return n2.jsxEmptyExpression;
  } }), Object.defineProperty(t2, "JSXExpressionContainer", { enumerable: true, get: function() {
    return n2.jsxExpressionContainer;
  } }), Object.defineProperty(t2, "JSXFragment", { enumerable: true, get: function() {
    return n2.jsxFragment;
  } }), Object.defineProperty(t2, "JSXIdentifier", { enumerable: true, get: function() {
    return n2.jsxIdentifier;
  } }), Object.defineProperty(t2, "JSXMemberExpression", { enumerable: true, get: function() {
    return n2.jsxMemberExpression;
  } }), Object.defineProperty(t2, "JSXNamespacedName", { enumerable: true, get: function() {
    return n2.jsxNamespacedName;
  } }), Object.defineProperty(t2, "JSXOpeningElement", { enumerable: true, get: function() {
    return n2.jsxOpeningElement;
  } }), Object.defineProperty(t2, "JSXOpeningFragment", { enumerable: true, get: function() {
    return n2.jsxOpeningFragment;
  } }), Object.defineProperty(t2, "JSXSpreadAttribute", { enumerable: true, get: function() {
    return n2.jsxSpreadAttribute;
  } }), Object.defineProperty(t2, "JSXSpreadChild", { enumerable: true, get: function() {
    return n2.jsxSpreadChild;
  } }), Object.defineProperty(t2, "JSXText", { enumerable: true, get: function() {
    return n2.jsxText;
  } }), Object.defineProperty(t2, "LabeledStatement", { enumerable: true, get: function() {
    return n2.labeledStatement;
  } }), Object.defineProperty(t2, "LogicalExpression", { enumerable: true, get: function() {
    return n2.logicalExpression;
  } }), Object.defineProperty(t2, "MemberExpression", { enumerable: true, get: function() {
    return n2.memberExpression;
  } }), Object.defineProperty(t2, "MetaProperty", { enumerable: true, get: function() {
    return n2.metaProperty;
  } }), Object.defineProperty(t2, "MixedTypeAnnotation", { enumerable: true, get: function() {
    return n2.mixedTypeAnnotation;
  } }), Object.defineProperty(t2, "ModuleExpression", { enumerable: true, get: function() {
    return n2.moduleExpression;
  } }), Object.defineProperty(t2, "NewExpression", { enumerable: true, get: function() {
    return n2.newExpression;
  } }), Object.defineProperty(t2, "Noop", { enumerable: true, get: function() {
    return n2.noop;
  } }), Object.defineProperty(t2, "NullLiteral", { enumerable: true, get: function() {
    return n2.nullLiteral;
  } }), Object.defineProperty(t2, "NullLiteralTypeAnnotation", { enumerable: true, get: function() {
    return n2.nullLiteralTypeAnnotation;
  } }), Object.defineProperty(t2, "NullableTypeAnnotation", { enumerable: true, get: function() {
    return n2.nullableTypeAnnotation;
  } }), Object.defineProperty(t2, "NumberLiteral", { enumerable: true, get: function() {
    return n2.numberLiteral;
  } }), Object.defineProperty(t2, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
    return n2.numberLiteralTypeAnnotation;
  } }), Object.defineProperty(t2, "NumberTypeAnnotation", { enumerable: true, get: function() {
    return n2.numberTypeAnnotation;
  } }), Object.defineProperty(t2, "NumericLiteral", { enumerable: true, get: function() {
    return n2.numericLiteral;
  } }), Object.defineProperty(t2, "ObjectExpression", { enumerable: true, get: function() {
    return n2.objectExpression;
  } }), Object.defineProperty(t2, "ObjectMethod", { enumerable: true, get: function() {
    return n2.objectMethod;
  } }), Object.defineProperty(t2, "ObjectPattern", { enumerable: true, get: function() {
    return n2.objectPattern;
  } }), Object.defineProperty(t2, "ObjectProperty", { enumerable: true, get: function() {
    return n2.objectProperty;
  } }), Object.defineProperty(t2, "ObjectTypeAnnotation", { enumerable: true, get: function() {
    return n2.objectTypeAnnotation;
  } }), Object.defineProperty(t2, "ObjectTypeCallProperty", { enumerable: true, get: function() {
    return n2.objectTypeCallProperty;
  } }), Object.defineProperty(t2, "ObjectTypeIndexer", { enumerable: true, get: function() {
    return n2.objectTypeIndexer;
  } }), Object.defineProperty(t2, "ObjectTypeInternalSlot", { enumerable: true, get: function() {
    return n2.objectTypeInternalSlot;
  } }), Object.defineProperty(t2, "ObjectTypeProperty", { enumerable: true, get: function() {
    return n2.objectTypeProperty;
  } }), Object.defineProperty(t2, "ObjectTypeSpreadProperty", { enumerable: true, get: function() {
    return n2.objectTypeSpreadProperty;
  } }), Object.defineProperty(t2, "OpaqueType", { enumerable: true, get: function() {
    return n2.opaqueType;
  } }), Object.defineProperty(t2, "OptionalCallExpression", { enumerable: true, get: function() {
    return n2.optionalCallExpression;
  } }), Object.defineProperty(t2, "OptionalIndexedAccessType", { enumerable: true, get: function() {
    return n2.optionalIndexedAccessType;
  } }), Object.defineProperty(t2, "OptionalMemberExpression", { enumerable: true, get: function() {
    return n2.optionalMemberExpression;
  } }), Object.defineProperty(t2, "ParenthesizedExpression", { enumerable: true, get: function() {
    return n2.parenthesizedExpression;
  } }), Object.defineProperty(t2, "PipelineBareFunction", { enumerable: true, get: function() {
    return n2.pipelineBareFunction;
  } }), Object.defineProperty(t2, "PipelinePrimaryTopicReference", { enumerable: true, get: function() {
    return n2.pipelinePrimaryTopicReference;
  } }), Object.defineProperty(t2, "PipelineTopicExpression", { enumerable: true, get: function() {
    return n2.pipelineTopicExpression;
  } }), Object.defineProperty(t2, "Placeholder", { enumerable: true, get: function() {
    return n2.placeholder;
  } }), Object.defineProperty(t2, "PrivateName", { enumerable: true, get: function() {
    return n2.privateName;
  } }), Object.defineProperty(t2, "Program", { enumerable: true, get: function() {
    return n2.program;
  } }), Object.defineProperty(t2, "QualifiedTypeIdentifier", { enumerable: true, get: function() {
    return n2.qualifiedTypeIdentifier;
  } }), Object.defineProperty(t2, "RecordExpression", { enumerable: true, get: function() {
    return n2.recordExpression;
  } }), Object.defineProperty(t2, "RegExpLiteral", { enumerable: true, get: function() {
    return n2.regExpLiteral;
  } }), Object.defineProperty(t2, "RegexLiteral", { enumerable: true, get: function() {
    return n2.regexLiteral;
  } }), Object.defineProperty(t2, "RestElement", { enumerable: true, get: function() {
    return n2.restElement;
  } }), Object.defineProperty(t2, "RestProperty", { enumerable: true, get: function() {
    return n2.restProperty;
  } }), Object.defineProperty(t2, "ReturnStatement", { enumerable: true, get: function() {
    return n2.returnStatement;
  } }), Object.defineProperty(t2, "SequenceExpression", { enumerable: true, get: function() {
    return n2.sequenceExpression;
  } }), Object.defineProperty(t2, "SpreadElement", { enumerable: true, get: function() {
    return n2.spreadElement;
  } }), Object.defineProperty(t2, "SpreadProperty", { enumerable: true, get: function() {
    return n2.spreadProperty;
  } }), Object.defineProperty(t2, "StaticBlock", { enumerable: true, get: function() {
    return n2.staticBlock;
  } }), Object.defineProperty(t2, "StringLiteral", { enumerable: true, get: function() {
    return n2.stringLiteral;
  } }), Object.defineProperty(t2, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
    return n2.stringLiteralTypeAnnotation;
  } }), Object.defineProperty(t2, "StringTypeAnnotation", { enumerable: true, get: function() {
    return n2.stringTypeAnnotation;
  } }), Object.defineProperty(t2, "Super", { enumerable: true, get: function() {
    return n2.super;
  } }), Object.defineProperty(t2, "SwitchCase", { enumerable: true, get: function() {
    return n2.switchCase;
  } }), Object.defineProperty(t2, "SwitchStatement", { enumerable: true, get: function() {
    return n2.switchStatement;
  } }), Object.defineProperty(t2, "SymbolTypeAnnotation", { enumerable: true, get: function() {
    return n2.symbolTypeAnnotation;
  } }), Object.defineProperty(t2, "TSAnyKeyword", { enumerable: true, get: function() {
    return n2.tsAnyKeyword;
  } }), Object.defineProperty(t2, "TSArrayType", { enumerable: true, get: function() {
    return n2.tsArrayType;
  } }), Object.defineProperty(t2, "TSAsExpression", { enumerable: true, get: function() {
    return n2.tsAsExpression;
  } }), Object.defineProperty(t2, "TSBigIntKeyword", { enumerable: true, get: function() {
    return n2.tsBigIntKeyword;
  } }), Object.defineProperty(t2, "TSBooleanKeyword", { enumerable: true, get: function() {
    return n2.tsBooleanKeyword;
  } }), Object.defineProperty(t2, "TSCallSignatureDeclaration", { enumerable: true, get: function() {
    return n2.tsCallSignatureDeclaration;
  } }), Object.defineProperty(t2, "TSConditionalType", { enumerable: true, get: function() {
    return n2.tsConditionalType;
  } }), Object.defineProperty(t2, "TSConstructSignatureDeclaration", { enumerable: true, get: function() {
    return n2.tsConstructSignatureDeclaration;
  } }), Object.defineProperty(t2, "TSConstructorType", { enumerable: true, get: function() {
    return n2.tsConstructorType;
  } }), Object.defineProperty(t2, "TSDeclareFunction", { enumerable: true, get: function() {
    return n2.tsDeclareFunction;
  } }), Object.defineProperty(t2, "TSDeclareMethod", { enumerable: true, get: function() {
    return n2.tsDeclareMethod;
  } }), Object.defineProperty(t2, "TSEnumDeclaration", { enumerable: true, get: function() {
    return n2.tsEnumDeclaration;
  } }), Object.defineProperty(t2, "TSEnumMember", { enumerable: true, get: function() {
    return n2.tsEnumMember;
  } }), Object.defineProperty(t2, "TSExportAssignment", { enumerable: true, get: function() {
    return n2.tsExportAssignment;
  } }), Object.defineProperty(t2, "TSExpressionWithTypeArguments", { enumerable: true, get: function() {
    return n2.tsExpressionWithTypeArguments;
  } }), Object.defineProperty(t2, "TSExternalModuleReference", { enumerable: true, get: function() {
    return n2.tsExternalModuleReference;
  } }), Object.defineProperty(t2, "TSFunctionType", { enumerable: true, get: function() {
    return n2.tsFunctionType;
  } }), Object.defineProperty(t2, "TSImportEqualsDeclaration", { enumerable: true, get: function() {
    return n2.tsImportEqualsDeclaration;
  } }), Object.defineProperty(t2, "TSImportType", { enumerable: true, get: function() {
    return n2.tsImportType;
  } }), Object.defineProperty(t2, "TSIndexSignature", { enumerable: true, get: function() {
    return n2.tsIndexSignature;
  } }), Object.defineProperty(t2, "TSIndexedAccessType", { enumerable: true, get: function() {
    return n2.tsIndexedAccessType;
  } }), Object.defineProperty(t2, "TSInferType", { enumerable: true, get: function() {
    return n2.tsInferType;
  } }), Object.defineProperty(t2, "TSInstantiationExpression", { enumerable: true, get: function() {
    return n2.tsInstantiationExpression;
  } }), Object.defineProperty(t2, "TSInterfaceBody", { enumerable: true, get: function() {
    return n2.tsInterfaceBody;
  } }), Object.defineProperty(t2, "TSInterfaceDeclaration", { enumerable: true, get: function() {
    return n2.tsInterfaceDeclaration;
  } }), Object.defineProperty(t2, "TSIntersectionType", { enumerable: true, get: function() {
    return n2.tsIntersectionType;
  } }), Object.defineProperty(t2, "TSIntrinsicKeyword", { enumerable: true, get: function() {
    return n2.tsIntrinsicKeyword;
  } }), Object.defineProperty(t2, "TSLiteralType", { enumerable: true, get: function() {
    return n2.tsLiteralType;
  } }), Object.defineProperty(t2, "TSMappedType", { enumerable: true, get: function() {
    return n2.tsMappedType;
  } }), Object.defineProperty(t2, "TSMethodSignature", { enumerable: true, get: function() {
    return n2.tsMethodSignature;
  } }), Object.defineProperty(t2, "TSModuleBlock", { enumerable: true, get: function() {
    return n2.tsModuleBlock;
  } }), Object.defineProperty(t2, "TSModuleDeclaration", { enumerable: true, get: function() {
    return n2.tsModuleDeclaration;
  } }), Object.defineProperty(t2, "TSNamedTupleMember", { enumerable: true, get: function() {
    return n2.tsNamedTupleMember;
  } }), Object.defineProperty(t2, "TSNamespaceExportDeclaration", { enumerable: true, get: function() {
    return n2.tsNamespaceExportDeclaration;
  } }), Object.defineProperty(t2, "TSNeverKeyword", { enumerable: true, get: function() {
    return n2.tsNeverKeyword;
  } }), Object.defineProperty(t2, "TSNonNullExpression", { enumerable: true, get: function() {
    return n2.tsNonNullExpression;
  } }), Object.defineProperty(t2, "TSNullKeyword", { enumerable: true, get: function() {
    return n2.tsNullKeyword;
  } }), Object.defineProperty(t2, "TSNumberKeyword", { enumerable: true, get: function() {
    return n2.tsNumberKeyword;
  } }), Object.defineProperty(t2, "TSObjectKeyword", { enumerable: true, get: function() {
    return n2.tsObjectKeyword;
  } }), Object.defineProperty(t2, "TSOptionalType", { enumerable: true, get: function() {
    return n2.tsOptionalType;
  } }), Object.defineProperty(t2, "TSParameterProperty", { enumerable: true, get: function() {
    return n2.tsParameterProperty;
  } }), Object.defineProperty(t2, "TSParenthesizedType", { enumerable: true, get: function() {
    return n2.tsParenthesizedType;
  } }), Object.defineProperty(t2, "TSPropertySignature", { enumerable: true, get: function() {
    return n2.tsPropertySignature;
  } }), Object.defineProperty(t2, "TSQualifiedName", { enumerable: true, get: function() {
    return n2.tsQualifiedName;
  } }), Object.defineProperty(t2, "TSRestType", { enumerable: true, get: function() {
    return n2.tsRestType;
  } }), Object.defineProperty(t2, "TSSatisfiesExpression", { enumerable: true, get: function() {
    return n2.tsSatisfiesExpression;
  } }), Object.defineProperty(t2, "TSStringKeyword", { enumerable: true, get: function() {
    return n2.tsStringKeyword;
  } }), Object.defineProperty(t2, "TSSymbolKeyword", { enumerable: true, get: function() {
    return n2.tsSymbolKeyword;
  } }), Object.defineProperty(t2, "TSThisType", { enumerable: true, get: function() {
    return n2.tsThisType;
  } }), Object.defineProperty(t2, "TSTupleType", { enumerable: true, get: function() {
    return n2.tsTupleType;
  } }), Object.defineProperty(t2, "TSTypeAliasDeclaration", { enumerable: true, get: function() {
    return n2.tsTypeAliasDeclaration;
  } }), Object.defineProperty(t2, "TSTypeAnnotation", { enumerable: true, get: function() {
    return n2.tsTypeAnnotation;
  } }), Object.defineProperty(t2, "TSTypeAssertion", { enumerable: true, get: function() {
    return n2.tsTypeAssertion;
  } }), Object.defineProperty(t2, "TSTypeLiteral", { enumerable: true, get: function() {
    return n2.tsTypeLiteral;
  } }), Object.defineProperty(t2, "TSTypeOperator", { enumerable: true, get: function() {
    return n2.tsTypeOperator;
  } }), Object.defineProperty(t2, "TSTypeParameter", { enumerable: true, get: function() {
    return n2.tsTypeParameter;
  } }), Object.defineProperty(t2, "TSTypeParameterDeclaration", { enumerable: true, get: function() {
    return n2.tsTypeParameterDeclaration;
  } }), Object.defineProperty(t2, "TSTypeParameterInstantiation", { enumerable: true, get: function() {
    return n2.tsTypeParameterInstantiation;
  } }), Object.defineProperty(t2, "TSTypePredicate", { enumerable: true, get: function() {
    return n2.tsTypePredicate;
  } }), Object.defineProperty(t2, "TSTypeQuery", { enumerable: true, get: function() {
    return n2.tsTypeQuery;
  } }), Object.defineProperty(t2, "TSTypeReference", { enumerable: true, get: function() {
    return n2.tsTypeReference;
  } }), Object.defineProperty(t2, "TSUndefinedKeyword", { enumerable: true, get: function() {
    return n2.tsUndefinedKeyword;
  } }), Object.defineProperty(t2, "TSUnionType", { enumerable: true, get: function() {
    return n2.tsUnionType;
  } }), Object.defineProperty(t2, "TSUnknownKeyword", { enumerable: true, get: function() {
    return n2.tsUnknownKeyword;
  } }), Object.defineProperty(t2, "TSVoidKeyword", { enumerable: true, get: function() {
    return n2.tsVoidKeyword;
  } }), Object.defineProperty(t2, "TaggedTemplateExpression", { enumerable: true, get: function() {
    return n2.taggedTemplateExpression;
  } }), Object.defineProperty(t2, "TemplateElement", { enumerable: true, get: function() {
    return n2.templateElement;
  } }), Object.defineProperty(t2, "TemplateLiteral", { enumerable: true, get: function() {
    return n2.templateLiteral;
  } }), Object.defineProperty(t2, "ThisExpression", { enumerable: true, get: function() {
    return n2.thisExpression;
  } }), Object.defineProperty(t2, "ThisTypeAnnotation", { enumerable: true, get: function() {
    return n2.thisTypeAnnotation;
  } }), Object.defineProperty(t2, "ThrowStatement", { enumerable: true, get: function() {
    return n2.throwStatement;
  } }), Object.defineProperty(t2, "TopicReference", { enumerable: true, get: function() {
    return n2.topicReference;
  } }), Object.defineProperty(t2, "TryStatement", { enumerable: true, get: function() {
    return n2.tryStatement;
  } }), Object.defineProperty(t2, "TupleExpression", { enumerable: true, get: function() {
    return n2.tupleExpression;
  } }), Object.defineProperty(t2, "TupleTypeAnnotation", { enumerable: true, get: function() {
    return n2.tupleTypeAnnotation;
  } }), Object.defineProperty(t2, "TypeAlias", { enumerable: true, get: function() {
    return n2.typeAlias;
  } }), Object.defineProperty(t2, "TypeAnnotation", { enumerable: true, get: function() {
    return n2.typeAnnotation;
  } }), Object.defineProperty(t2, "TypeCastExpression", { enumerable: true, get: function() {
    return n2.typeCastExpression;
  } }), Object.defineProperty(t2, "TypeParameter", { enumerable: true, get: function() {
    return n2.typeParameter;
  } }), Object.defineProperty(t2, "TypeParameterDeclaration", { enumerable: true, get: function() {
    return n2.typeParameterDeclaration;
  } }), Object.defineProperty(t2, "TypeParameterInstantiation", { enumerable: true, get: function() {
    return n2.typeParameterInstantiation;
  } }), Object.defineProperty(t2, "TypeofTypeAnnotation", { enumerable: true, get: function() {
    return n2.typeofTypeAnnotation;
  } }), Object.defineProperty(t2, "UnaryExpression", { enumerable: true, get: function() {
    return n2.unaryExpression;
  } }), Object.defineProperty(t2, "UnionTypeAnnotation", { enumerable: true, get: function() {
    return n2.unionTypeAnnotation;
  } }), Object.defineProperty(t2, "UpdateExpression", { enumerable: true, get: function() {
    return n2.updateExpression;
  } }), Object.defineProperty(t2, "V8IntrinsicIdentifier", { enumerable: true, get: function() {
    return n2.v8IntrinsicIdentifier;
  } }), Object.defineProperty(t2, "VariableDeclaration", { enumerable: true, get: function() {
    return n2.variableDeclaration;
  } }), Object.defineProperty(t2, "VariableDeclarator", { enumerable: true, get: function() {
    return n2.variableDeclarator;
  } }), Object.defineProperty(t2, "Variance", { enumerable: true, get: function() {
    return n2.variance;
  } }), Object.defineProperty(t2, "VoidTypeAnnotation", { enumerable: true, get: function() {
    return n2.voidTypeAnnotation;
  } }), Object.defineProperty(t2, "WhileStatement", { enumerable: true, get: function() {
    return n2.whileStatement;
  } }), Object.defineProperty(t2, "WithStatement", { enumerable: true, get: function() {
    return n2.withStatement;
  } }), Object.defineProperty(t2, "YieldExpression", { enumerable: true, get: function() {
    return n2.yieldExpression;
  } });
  var n2 = r2(4);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.buildUndefinedNode = function() {
    return (0, n2.unaryExpression)("void", (0, n2.numericLiteral)(0), true);
  };
  var n2 = r2(4);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.default)(e3, false);
  };
  var n2 = r2(27);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.default)(e3);
  };
  var n2 = r2(27);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.default)(e3, true, true);
  };
  var n2 = r2(27);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.default)(e3, false, true);
  };
  var n2 = r2(27);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, s2) {
    return (0, n2.default)(e3, t3, [{ type: s2 ? "CommentLine" : "CommentBlock", value: r3 }]);
  };
  var n2 = r2(172);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return n2.COMMENT_KEYS.forEach((t3) => {
      e3[t3] = null;
    }), e3;
  };
  var n2 = r2(26);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.WHILE_TYPES = t2.USERWHITESPACABLE_TYPES = t2.UNARYLIKE_TYPES = t2.TYPESCRIPT_TYPES = t2.TSTYPE_TYPES = t2.TSTYPEELEMENT_TYPES = t2.TSENTITYNAME_TYPES = t2.TSBASETYPE_TYPES = t2.TERMINATORLESS_TYPES = t2.STATEMENT_TYPES = t2.STANDARDIZED_TYPES = t2.SCOPABLE_TYPES = t2.PUREISH_TYPES = t2.PROPERTY_TYPES = t2.PRIVATE_TYPES = t2.PATTERN_TYPES = t2.PATTERNLIKE_TYPES = t2.OBJECTMEMBER_TYPES = t2.MODULESPECIFIER_TYPES = t2.MODULEDECLARATION_TYPES = t2.MISCELLANEOUS_TYPES = t2.METHOD_TYPES = t2.LVAL_TYPES = t2.LOOP_TYPES = t2.LITERAL_TYPES = t2.JSX_TYPES = t2.IMPORTOREXPORTDECLARATION_TYPES = t2.IMMUTABLE_TYPES = t2.FUNCTION_TYPES = t2.FUNCTIONPARENT_TYPES = t2.FOR_TYPES = t2.FORXSTATEMENT_TYPES = t2.FLOW_TYPES = t2.FLOWTYPE_TYPES = t2.FLOWPREDICATE_TYPES = t2.FLOWDECLARATION_TYPES = t2.FLOWBASEANNOTATION_TYPES = t2.EXPRESSION_TYPES = t2.EXPRESSIONWRAPPER_TYPES = t2.EXPORTDECLARATION_TYPES = t2.ENUMMEMBER_TYPES = t2.ENUMBODY_TYPES = t2.DECLARATION_TYPES = t2.CONDITIONAL_TYPES = t2.COMPLETIONSTATEMENT_TYPES = t2.CLASS_TYPES = t2.BLOCK_TYPES = t2.BLOCKPARENT_TYPES = t2.BINARY_TYPES = t2.ACCESSOR_TYPES = void 0;
  var n2 = r2(9);
  t2.STANDARDIZED_TYPES = n2.FLIPPED_ALIAS_KEYS.Standardized, t2.EXPRESSION_TYPES = n2.FLIPPED_ALIAS_KEYS.Expression, t2.BINARY_TYPES = n2.FLIPPED_ALIAS_KEYS.Binary, t2.SCOPABLE_TYPES = n2.FLIPPED_ALIAS_KEYS.Scopable, t2.BLOCKPARENT_TYPES = n2.FLIPPED_ALIAS_KEYS.BlockParent, t2.BLOCK_TYPES = n2.FLIPPED_ALIAS_KEYS.Block, t2.STATEMENT_TYPES = n2.FLIPPED_ALIAS_KEYS.Statement, t2.TERMINATORLESS_TYPES = n2.FLIPPED_ALIAS_KEYS.Terminatorless, t2.COMPLETIONSTATEMENT_TYPES = n2.FLIPPED_ALIAS_KEYS.CompletionStatement, t2.CONDITIONAL_TYPES = n2.FLIPPED_ALIAS_KEYS.Conditional, t2.LOOP_TYPES = n2.FLIPPED_ALIAS_KEYS.Loop, t2.WHILE_TYPES = n2.FLIPPED_ALIAS_KEYS.While, t2.EXPRESSIONWRAPPER_TYPES = n2.FLIPPED_ALIAS_KEYS.ExpressionWrapper, t2.FOR_TYPES = n2.FLIPPED_ALIAS_KEYS.For, t2.FORXSTATEMENT_TYPES = n2.FLIPPED_ALIAS_KEYS.ForXStatement, t2.FUNCTION_TYPES = n2.FLIPPED_ALIAS_KEYS.Function, t2.FUNCTIONPARENT_TYPES = n2.FLIPPED_ALIAS_KEYS.FunctionParent, t2.PUREISH_TYPES = n2.FLIPPED_ALIAS_KEYS.Pureish, t2.DECLARATION_TYPES = n2.FLIPPED_ALIAS_KEYS.Declaration, t2.PATTERNLIKE_TYPES = n2.FLIPPED_ALIAS_KEYS.PatternLike, t2.LVAL_TYPES = n2.FLIPPED_ALIAS_KEYS.LVal, t2.TSENTITYNAME_TYPES = n2.FLIPPED_ALIAS_KEYS.TSEntityName, t2.LITERAL_TYPES = n2.FLIPPED_ALIAS_KEYS.Literal, t2.IMMUTABLE_TYPES = n2.FLIPPED_ALIAS_KEYS.Immutable, t2.USERWHITESPACABLE_TYPES = n2.FLIPPED_ALIAS_KEYS.UserWhitespacable, t2.METHOD_TYPES = n2.FLIPPED_ALIAS_KEYS.Method, t2.OBJECTMEMBER_TYPES = n2.FLIPPED_ALIAS_KEYS.ObjectMember, t2.PROPERTY_TYPES = n2.FLIPPED_ALIAS_KEYS.Property, t2.UNARYLIKE_TYPES = n2.FLIPPED_ALIAS_KEYS.UnaryLike, t2.PATTERN_TYPES = n2.FLIPPED_ALIAS_KEYS.Pattern, t2.CLASS_TYPES = n2.FLIPPED_ALIAS_KEYS.Class;
  const s2 = t2.IMPORTOREXPORTDECLARATION_TYPES = n2.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
  t2.EXPORTDECLARATION_TYPES = n2.FLIPPED_ALIAS_KEYS.ExportDeclaration, t2.MODULESPECIFIER_TYPES = n2.FLIPPED_ALIAS_KEYS.ModuleSpecifier, t2.ACCESSOR_TYPES = n2.FLIPPED_ALIAS_KEYS.Accessor, t2.PRIVATE_TYPES = n2.FLIPPED_ALIAS_KEYS.Private, t2.FLOW_TYPES = n2.FLIPPED_ALIAS_KEYS.Flow, t2.FLOWTYPE_TYPES = n2.FLIPPED_ALIAS_KEYS.FlowType, t2.FLOWBASEANNOTATION_TYPES = n2.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, t2.FLOWDECLARATION_TYPES = n2.FLIPPED_ALIAS_KEYS.FlowDeclaration, t2.FLOWPREDICATE_TYPES = n2.FLIPPED_ALIAS_KEYS.FlowPredicate, t2.ENUMBODY_TYPES = n2.FLIPPED_ALIAS_KEYS.EnumBody, t2.ENUMMEMBER_TYPES = n2.FLIPPED_ALIAS_KEYS.EnumMember, t2.JSX_TYPES = n2.FLIPPED_ALIAS_KEYS.JSX, t2.MISCELLANEOUS_TYPES = n2.FLIPPED_ALIAS_KEYS.Miscellaneous, t2.TYPESCRIPT_TYPES = n2.FLIPPED_ALIAS_KEYS.TypeScript, t2.TSTYPEELEMENT_TYPES = n2.FLIPPED_ALIAS_KEYS.TSTypeElement, t2.TSTYPE_TYPES = n2.FLIPPED_ALIAS_KEYS.TSType, t2.TSBASETYPE_TYPES = n2.FLIPPED_ALIAS_KEYS.TSBaseType, t2.MODULEDECLARATION_TYPES = s2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "body";
    const r3 = (0, n2.default)(e3[t3], e3);
    return e3[t3] = r3, r3;
  };
  var n2 = r2(177);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return "eval" !== (e3 = (0, n2.default)(e3)) && "arguments" !== e3 || (e3 = "_" + e3), e3;
  };
  var n2 = r2(178);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e3.key || e3.property;
    return !e3.computed && (0, n2.isIdentifier)(t3) && (t3 = (0, s2.stringLiteral)(t3.name)), t3;
  };
  var n2 = r2(2), s2 = r2(4);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(2);
  t2.default = function(e3) {
    if ((0, n2.isExpressionStatement)(e3) && (e3 = e3.expression), (0, n2.isExpression)(e3)) return e3;
    if ((0, n2.isClass)(e3) ? e3.type = "ClassExpression" : (0, n2.isFunction)(e3) && (e3.type = "FunctionExpression"), !(0, n2.isExpression)(e3)) throw new Error(`cannot turn ${e3.type} to an expression`);
    return e3;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = o2;
  var n2 = r2(2), s2 = r2(27), i2 = r2(179);
  function o2(e3) {
    let t3, r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e3.key;
    return "method" === e3.kind ? o2.increment() + "" : (t3 = (0, n2.isIdentifier)(r3) ? r3.name : (0, n2.isStringLiteral)(r3) ? JSON.stringify(r3.value) : JSON.stringify((0, i2.default)((0, s2.default)(r3))), e3.computed && (t3 = `[${t3}]`), e3.static && (t3 = `static:${t3}`), t3);
  }
  o2.uid = 0, o2.increment = function() {
    return o2.uid >= Number.MAX_SAFE_INTEGER ? o2.uid = 0 : o2.uid++;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(2), s2 = r2(4);
  t2.default = function(e3, t3) {
    if ((0, n2.isStatement)(e3)) return e3;
    let r3, i2 = false;
    if ((0, n2.isClass)(e3)) i2 = true, r3 = "ClassDeclaration";
    else if ((0, n2.isFunction)(e3)) i2 = true, r3 = "FunctionDeclaration";
    else if ((0, n2.isAssignmentExpression)(e3)) return (0, s2.expressionStatement)(e3);
    if (i2 && !e3.id && (r3 = false), !r3) {
      if (t3) return false;
      throw new Error(`cannot turn ${e3.type} to a statement`);
    }
    return e3.type = r3, e3;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(43), s2 = r2(4);
  t2.default = function e3(t3) {
    if (void 0 === t3) return (0, s2.identifier)("undefined");
    if (true === t3 || false === t3) return (0, s2.booleanLiteral)(t3);
    if (null === t3) return (0, s2.nullLiteral)();
    if ("string" == typeof t3) return (0, s2.stringLiteral)(t3);
    if ("number" == typeof t3) {
      let e4;
      if (Number.isFinite(t3)) e4 = (0, s2.numericLiteral)(Math.abs(t3));
      else {
        let r3;
        r3 = Number.isNaN(t3) ? (0, s2.numericLiteral)(0) : (0, s2.numericLiteral)(1), e4 = (0, s2.binaryExpression)("/", r3, (0, s2.numericLiteral)(0));
      }
      return (t3 < 0 || Object.is(t3, -0)) && (e4 = (0, s2.unaryExpression)("-", e4)), e4;
    }
    if (function(e4) {
      return "[object RegExp]" === i2(e4);
    }(t3)) {
      const e4 = t3.source, r3 = t3.toString().match(/\/([a-z]+|)$/)[1];
      return (0, s2.regExpLiteral)(e4, r3);
    }
    if (Array.isArray(t3)) return (0, s2.arrayExpression)(t3.map(e3));
    if (function(e4) {
      if ("object" != typeof e4 || null === e4 || "[object Object]" !== Object.prototype.toString.call(e4)) return false;
      const t4 = Object.getPrototypeOf(e4);
      return null === t4 || null === Object.getPrototypeOf(t4);
    }(t3)) {
      const r3 = [];
      for (const i3 of Object.keys(t3)) {
        let o2;
        o2 = (0, n2.default)(i3) ? (0, s2.identifier)(i3) : (0, s2.stringLiteral)(i3), r3.push((0, s2.objectProperty)(o2, e3(t3[i3])));
      }
      return (0, s2.objectExpression)(r3);
    }
    throw new Error("don't know how to turn this value into a node");
  };
  const i2 = Function.call.bind(Object.prototype.toString);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return e3.object = (0, n2.memberExpression)(e3.object, e3.property, e3.computed), e3.property = t3, e3.computed = !!r3, e3;
  };
  var n2 = r2(4);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if (!e3 || !t3) return e3;
    for (const r3 of n2.INHERIT_KEYS.optional) null == e3[r3] && (e3[r3] = t3[r3]);
    for (const r3 of Object.keys(t3)) "_" === r3[0] && "__clone" !== r3 && (e3[r3] = t3[r3]);
    for (const r3 of n2.INHERIT_KEYS.force) e3[r3] = t3[r3];
    return (0, s2.default)(e3, t3), e3;
  };
  var n2 = r2(26), s2 = r2(175);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if ((0, s2.isSuper)(e3.object)) throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return e3.object = (0, n2.memberExpression)(t3, e3.object), e3;
  };
  var n2 = r2(4), s2 = r2(0);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(60);
  t2.default = function(e3, t3) {
    return (0, n2.default)(e3, t3, true);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    "function" == typeof t3 && (t3 = { enter: t3 });
    const { enter: n3, exit: i2 } = t3;
    s2(e3, n3, i2, r3, []);
  };
  var n2 = r2(9);
  function s2(e3, t3, r3, i2, o2) {
    const a2 = n2.VISITOR_KEYS[e3.type];
    if (a2) {
      t3 && t3(e3, o2, i2);
      for (const n3 of a2) {
        const a3 = e3[n3];
        if (Array.isArray(a3)) for (let l = 0; l < a3.length; l++) {
          const c = a3[l];
          c && (o2.push({ node: e3, key: n3, index: l }), s2(c, t3, r3, i2, o2), o2.pop());
        }
        else a3 && (o2.push({ node: e3, key: n3 }), s2(a3, t3, r3, i2, o2), o2.pop());
      }
      r3 && r3(e3, o2, i2);
    }
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    if (r3 && "Identifier" === e3.type && "ObjectProperty" === t3.type && "ObjectExpression" === r3.type) return false;
    const s2 = n2.default.keys[t3.type];
    if (s2) for (let r4 = 0; r4 < s2.length; r4++) {
      const n3 = t3[s2[r4]];
      if (Array.isArray(n3)) {
        if (n3.indexOf(e3) >= 0) return true;
      } else if (n3 === e3) return true;
    }
    return false;
  };
  var n2 = r2(60);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.isFunctionDeclaration)(e3) || (0, n2.isClassDeclaration)(e3) || (0, s2.default)(e3);
  };
  var n2 = r2(2), s2 = r2(182);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return !!(0, n2.default)(e3.type, "Immutable") || !!(0, s2.isIdentifier)(e3) && "undefined" === e3.name;
  };
  var n2 = r2(98), s2 = r2(2);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, r3) {
    if ("object" != typeof t3 || "object" != typeof r3 || null == t3 || null == r3) return t3 === r3;
    if (t3.type !== r3.type) return false;
    const s2 = Object.keys(n2.NODE_FIELDS[t3.type] || t3.type), i2 = n2.VISITOR_KEYS[t3.type];
    for (const n3 of s2) {
      const s3 = t3[n3], o2 = r3[n3];
      if (typeof s3 != typeof o2) return false;
      if (null != s3 || null != o2) {
        if (null == s3 || null == o2) return false;
        if (Array.isArray(s3)) {
          if (!Array.isArray(o2)) return false;
          if (s3.length !== o2.length) return false;
          for (let t4 = 0; t4 < s3.length; t4++) if (!e3(s3[t4], o2[t4])) return false;
        } else if ("object" != typeof s3 || null != i2 && i2.includes(n3)) {
          if (!e3(s3, o2)) return false;
        } else for (const e4 of Object.keys(s3)) if (s3[e4] !== o2[e4]) return false;
      }
    }
    return true;
  };
  var n2 = r2(9);
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r2) {
    switch (t3.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return t3.property === e3 ? !!t3.computed : t3.object === e3;
      case "JSXMemberExpression":
        return t3.object === e3;
      case "VariableDeclarator":
        return t3.init === e3;
      case "ArrowFunctionExpression":
        return t3.body === e3;
      case "PrivateName":
      case "LabeledStatement":
      case "CatchClause":
      case "RestElement":
      case "BreakStatement":
      case "ContinueStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportAttribute":
      case "JSXAttribute":
      case "ObjectPattern":
      case "ArrayPattern":
      case "MetaProperty":
        return false;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return t3.key === e3 && !!t3.computed;
      case "ObjectProperty":
        return t3.key === e3 ? !!t3.computed : !r2 || "ObjectPattern" !== r2.type;
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "TSPropertySignature":
        return t3.key !== e3 || !!t3.computed;
      case "ClassPrivateProperty":
      case "ObjectTypeProperty":
        return t3.key !== e3;
      case "ClassDeclaration":
      case "ClassExpression":
        return t3.superClass === e3;
      case "AssignmentExpression":
      case "AssignmentPattern":
        return t3.right === e3;
      case "ExportSpecifier":
        return (null == r2 || !r2.source) && t3.local === e3;
      case "TSEnumMember":
        return t3.id !== e3;
    }
    return true;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    return (!(0, n2.isBlockStatement)(e3) || !(0, n2.isFunction)(t3) && !(0, n2.isCatchClause)(t3)) && (!(!(0, n2.isPattern)(e3) || !(0, n2.isFunction)(t3) && !(0, n2.isCatchClause)(t3)) || (0, n2.isScopable)(e3));
  };
  var n2 = r2(2);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.isImportDefaultSpecifier)(e3) || (0, n2.isIdentifier)(e3.imported || e3.exported, { name: "default" });
  };
  var n2 = r2(2);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.default)(e3) && !s2.has(e3);
  };
  var n2 = r2(43);
  const s2 = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return (0, n2.isVariableDeclaration)(e3, { kind: "var" }) && !e3[s2.BLOCK_SCOPED_SYMBOL];
  };
  var n2 = r2(2), s2 = r2(26);
}, (e2, t2, r2) => {
  t2.default = function(e3, t3) {
    if (null == e3 || !e3.length) return;
    const r3 = [], s2 = (0, n2.default)(e3, t3, r3);
    if (s2) {
      for (const e4 of r3) t3.push(e4);
      return s2;
    }
  };
  var n2 = r2(399);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, r3, a2) {
    const l = [];
    let c = true;
    for (const u of t3) if ((0, s2.isEmptyStatement)(u) || (c = false), (0, s2.isExpression)(u)) l.push(u);
    else if ((0, s2.isExpressionStatement)(u)) l.push(u.expression);
    else if ((0, s2.isVariableDeclaration)(u)) {
      if ("var" !== u.kind) return;
      for (const e4 of u.declarations) {
        const t4 = (0, n2.default)(e4);
        for (const e5 of Object.keys(t4)) a2.push({ kind: u.kind, id: (0, o2.default)(t4[e5]) });
        e4.init && l.push((0, i2.assignmentExpression)("=", e4.id, e4.init));
      }
      c = true;
    } else if ((0, s2.isIfStatement)(u)) {
      const t4 = u.consequent ? e3([u.consequent], r3, a2) : r3.buildUndefinedNode(), n3 = u.alternate ? e3([u.alternate], r3, a2) : r3.buildUndefinedNode();
      if (!t4 || !n3) return;
      l.push((0, i2.conditionalExpression)(u.test, t4, n3));
    } else if ((0, s2.isBlockStatement)(u)) {
      const t4 = e3(u.body, r3, a2);
      if (!t4) return;
      l.push(t4);
    } else {
      if (!(0, s2.isEmptyStatement)(u)) return;
      0 === t3.indexOf(u) && (c = true);
    }
    return c && l.push(r3.buildUndefinedNode()), 1 === l.length ? l[0] : (0, i2.sequenceExpression)(l);
  };
  var n2 = r2(60), s2 = r2(2), i2 = r2(4), o2 = r2(27);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(28), s2 = r2(0);
  const { VISITOR_KEYS: i2 } = s2;
  t2.default = class {
    constructor(e3, t3, r3, n3) {
      this.queue = null, this.priorityQueue = null, this.parentPath = n3, this.scope = e3, this.state = r3, this.opts = t3;
    }
    shouldVisit(e3) {
      const t3 = this.opts;
      if (t3.enter || t3.exit) return true;
      if (t3[e3.type]) return true;
      const r3 = i2[e3.type];
      if (null == r3 || !r3.length) return false;
      for (const t4 of r3) if (e3[t4]) return true;
      return false;
    }
    create(e3, t3, r3, s3) {
      return n2.default.get({ parentPath: this.parentPath, parent: e3, container: t3, key: r3, listKey: s3 });
    }
    maybeQueue(e3, t3) {
      this.queue && (t3 ? this.queue.push(e3) : this.priorityQueue.push(e3));
    }
    visitMultiple(e3, t3, r3) {
      if (0 === e3.length) return false;
      const n3 = [];
      for (let s3 = 0; s3 < e3.length; s3++) {
        const i3 = e3[s3];
        i3 && this.shouldVisit(i3) && n3.push(this.create(t3, e3, s3, r3));
      }
      return this.visitQueue(n3);
    }
    visitSingle(e3, t3) {
      return !!this.shouldVisit(e3[t3]) && this.visitQueue([this.create(e3, e3, t3)]);
    }
    visitQueue(e3) {
      this.queue = e3, this.priorityQueue = [];
      const t3 = /* @__PURE__ */ new WeakSet();
      let r3 = false;
      for (const n3 of e3) {
        if (n3.resync(), 0 !== n3.contexts.length && n3.contexts[n3.contexts.length - 1] === this || n3.pushContext(this), null === n3.key) continue;
        const { node: s3 } = n3;
        if (!t3.has(s3)) {
          if (s3 && t3.add(s3), n3.visit()) {
            r3 = true;
            break;
          }
          if (this.priorityQueue.length && (r3 = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = e3, r3)) break;
        }
      }
      for (const t4 of e3) t4.popContext();
      return this.queue = null, r3;
    }
    visit(e3, t3) {
      const r3 = e3[t3];
      return !!r3 && (Array.isArray(r3) ? this.visitMultiple(r3, e3, t3) : this.visitSingle(e3, t3));
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(62), s2 = r2(0), i2 = r2(33), o2 = r2(100), a2 = r2(57);
  const l = { ReferencedIdentifier(e3, t3) {
    let { node: r3 } = e3;
    r3.name === t3.oldName && (r3.name = t3.newName);
  }, Scope(e3, t3) {
    e3.scope.bindingIdentifierEquals(t3.oldName, t3.binding.identifier) || (e3.skip(), e3.isMethod() && (0, i2.requeueComputedKeyAndDecorators)(e3));
  }, ObjectProperty(e3, t3) {
    let { node: r3, scope: n3 } = e3;
    const { name: s3 } = r3.key;
    var i3;
    !r3.shorthand || s3 !== t3.oldName && s3 !== t3.newName || n3.getBindingIdentifier(s3) !== t3.binding.identifier || (r3.shorthand = false, null != (i3 = r3.extra) && i3.shorthand && (r3.extra.shorthand = false));
  }, "AssignmentExpression|Declaration|VariableDeclarator"(e3, t3) {
    if (e3.isVariableDeclaration()) return;
    const r3 = e3.getOuterBindingIdentifiers();
    for (const e4 in r3) e4 === t3.oldName && (r3[e4].name = t3.newName);
  } };
  t2.default = class {
    constructor(e3, t3, r3) {
      this.newName = r3, this.oldName = t3, this.binding = e3;
    }
    maybeConvertFromExportDeclaration(e3) {
      const t3 = e3.parentPath;
      if (t3.isExportDeclaration()) {
        if (t3.isExportDefaultDeclaration()) {
          const { declaration: e4 } = t3.node;
          if (s2.isDeclaration(e4) && !e4.id) return;
        }
        t3.isExportAllDeclaration() || (0, n2.default)(t3);
      }
    }
    maybeConvertFromClassFunctionDeclaration(e3) {
      return e3;
    }
    maybeConvertFromClassFunctionExpression(e3) {
      return e3;
    }
    rename() {
      const { binding: e3, oldName: t3, newName: r3 } = this, { scope: n3, path: s3 } = e3, i3 = s3.find((e4) => e4.isDeclaration() || e4.isFunctionExpression() || e4.isClassExpression());
      i3 && i3.getOuterBindingIdentifiers()[t3] === e3.identifier && this.maybeConvertFromExportDeclaration(i3);
      const c = arguments[0] || n3.block;
      (0, o2.traverseNode)(c, (0, a2.explode)(l), n3, this, n3.path, { discriminant: true }), arguments[0] || (n3.removeOwnBinding(t3), n3.bindings[r3] = e3, this.binding.identifier.name = r3), i3 && (this.maybeConvertFromClassFunctionDeclaration(s3), this.maybeConvertFromClassFunctionExpression(s3));
    }
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = class {
    constructor(e3) {
      let { identifier: t3, scope: r2, path: n2, kind: s2 } = e3;
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = true, this.referencePaths = [], this.referenced = false, this.references = 0, this.identifier = t3, this.scope = r2, this.path = n2, this.kind = s2, "var" !== s2 && "hoisted" !== s2 || !function(e4) {
        for (let { parentPath: t4, key: r3 } = e4; t4; { parentPath: t4, key: r3 } = t4) {
          if (t4.isFunctionParent()) return false;
          if (t4.isWhile() || t4.isForXStatement() || t4.isForStatement() && "body" === r3) return true;
        }
        return false;
      }(n2) || this.reassign(n2), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = true;
    }
    setValue(e3) {
      this.hasDeoptedValue || (this.hasValue = true, this.value = e3);
    }
    clearValue() {
      this.hasDeoptedValue = false, this.hasValue = false, this.value = null;
    }
    reassign(e3) {
      this.constant = false, -1 === this.constantViolations.indexOf(e3) && this.constantViolations.push(e3);
    }
    reference(e3) {
      -1 === this.referencePaths.indexOf(e3) && (this.referenced = true, this.references++, this.referencePaths.push(e3));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
}, (e2, t2, r2) => {
  e2.exports = r2(404);
}, (e2) => {
  e2.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(406), s2 = r2(407);
  t2.default = class {
    constructor(e3, t3) {
      var r3;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
      const i2 = this._map = new n2.GenMapping({ sourceRoot: e3.sourceRoot });
      if (this._sourceFileName = null == (r3 = e3.sourceFileName) ? void 0 : r3.replace(/\\/g, "/"), this._rawMappings = void 0, e3.inputSourceMap) {
        this._inputMap = new s2.TraceMap(e3.inputSourceMap);
        const t4 = this._inputMap.resolvedSources;
        if (t4.length) for (let e4 = 0; e4 < t4.length; e4++) {
          var o2;
          (0, n2.setSourceContent)(i2, t4[e4], null == (o2 = this._inputMap.sourcesContent) ? void 0 : o2[e4]);
        }
      }
      if ("string" != typeof t3 || e3.inputSourceMap) {
        if ("object" == typeof t3) for (const e4 of Object.keys(t3)) (0, n2.setSourceContent)(i2, e4.replace(/\\/g, "/"), t3[e4]);
      } else (0, n2.setSourceContent)(i2, this._sourceFileName, t3);
    }
    get() {
      return (0, n2.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, n2.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, n2.allMappings)(this._map));
    }
    mark(e3, t3, r3, i2, o2, a2) {
      var l;
      let c;
      if (this._rawMappings = void 0, null != t3) if (this._inputMap) {
        if (c = (0, s2.originalPositionFor)(this._inputMap, { line: t3, column: r3 }), !c.name && o2) {
          const e4 = (0, s2.originalPositionFor)(this._inputMap, o2);
          e4.name && (i2 = e4.name);
        }
      } else c = { source: (null == a2 ? void 0 : a2.replace(/\\/g, "/")) || this._sourceFileName, line: t3, column: r3 };
      (0, n2.maybeAddMapping)(this._map, { name: i2, generated: e3, source: null == (l = c) ? void 0 : l.source, original: c });
    }
  };
}, () => {
}, () => {
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(409), s2 = r2(184), i2 = r2(0), o2 = r2(155);
  const { isFunction: a2, isStatement: l, isClassBody: c, isTSInterfaceBody: u, isTSEnumDeclaration: p } = i2, d = /e/i, f = /\.0+$/, h = /[\n\r\u2028\u2029]/, m = /[\n\r\u2028\u2029]|\*\//, { needsParens: y } = s2;
  class g {
    constructor(e3, t3) {
      this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentRepeat = 0, this._insideAux = false, this._parenPushNewlineState = null, this._noLineTerminator = false, this._printAuxAfterOnNextUserNode = false, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = false, this._endsWithWord = false, this._lastCommentLine = 0, this._endsWithInnerRaw = false, this._indentInnerComments = true, this.format = e3, this._indentRepeat = e3.indent.style.length, this._inputMap = null == t3 ? void 0 : t3._inputMap, this._buf = new n2.default(t3, e3.indent.style[0]);
    }
    generate(e3) {
      return this.print(e3), this._maybeAddAuxComment(), this._buf.get();
    }
    indent() {
      this.format.compact || this.format.concise || this._indent++;
    }
    dedent() {
      this.format.compact || this.format.concise || this._indent--;
    }
    semicolon() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      this._maybeAddAuxComment(), e3 ? this._appendChar(59) : this._queue(59), this._noLineTerminator = false;
    }
    rightBrace(e3) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e3.loc, -1), this.tokenChar(125);
    }
    rightParens(e3) {
      this.sourceWithOffset("end", e3.loc, -1), this.tokenChar(41);
    }
    space() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (!this.format.compact) {
        if (e3) this._space();
        else if (this._buf.hasContent()) {
          const e4 = this.getLastChar();
          32 !== e4 && 10 !== e4 && this._space();
        }
      }
    }
    word(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      this._maybePrintInnerComments(), (this._endsWithWord || 47 === e3.charCodeAt(0) && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(), this._append(e3, false), this._endsWithWord = true, this._noLineTerminator = t3;
    }
    number(e3, t3) {
      this.word(e3), this._endsWithInteger = Number.isInteger(t3) && !function(e4) {
        if (e4.length > 2 && 48 === e4.charCodeAt(0)) {
          const t4 = e4.charCodeAt(1);
          return 98 === t4 || 111 === t4 || 120 === t4;
        }
        return false;
      }(e3) && !d.test(e3) && !f.test(e3) && 46 !== e3.charCodeAt(e3.length - 1);
    }
    token(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      this._maybePrintInnerComments();
      const r3 = this.getLastChar(), n3 = e3.charCodeAt(0);
      (33 === r3 && ("--" === e3 || 61 === n3) || 43 === n3 && 43 === r3 || 45 === n3 && 45 === r3 || 46 === n3 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(e3, t3), this._noLineTerminator = false;
    }
    tokenChar(e3) {
      this._maybePrintInnerComments();
      const t3 = this.getLastChar();
      (43 === e3 && 43 === t3 || 45 === e3 && 45 === t3 || 46 === e3 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._appendChar(e3), this._noLineTerminator = false;
    }
    newline() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
      if (!(e3 <= 0)) {
        if (!(arguments.length > 1 ? arguments[1] : void 0)) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) return void this.space();
        }
        e3 > 2 && (e3 = 2), e3 -= this._buf.getNewlineCount();
        for (let t3 = 0; t3 < e3; t3++) this._newline();
      }
    }
    endsWith(e3) {
      return this.getLastChar() === e3;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(e3, t3) {
      e3 ? (this._catchUp("start", e3), this._buf.exactSource(e3, t3)) : t3();
    }
    source(e3, t3) {
      t3 && (this._catchUp(e3, t3), this._buf.source(e3, t3));
    }
    sourceWithOffset(e3, t3, r3) {
      t3 && (this._catchUp(e3, t3), this._buf.sourceWithOffset(e3, t3, r3));
    }
    withSource(e3, t3, r3) {
      t3 ? (this._catchUp(e3, t3), this._buf.withSource(e3, t3, r3)) : r3();
    }
    sourceIdentifierName(e3, t3) {
      if (!this._buf._canMarkIdName) return;
      const r3 = this._buf._sourcePosition;
      r3.identifierNamePos = t3, r3.identifierName = e3;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _append(e3, t3) {
      this._maybeAddParen(e3), this._maybeIndent(e3.charCodeAt(0)), this._buf.append(e3, t3), this._endsWithWord = false, this._endsWithInteger = false;
    }
    _appendChar(e3) {
      this._maybeAddParenChar(e3), this._maybeIndent(e3), this._buf.appendChar(e3), this._endsWithWord = false, this._endsWithInteger = false;
    }
    _queue(e3) {
      this._maybeAddParenChar(e3), this._maybeIndent(e3), this._buf.queue(e3), this._endsWithWord = false, this._endsWithInteger = false;
    }
    _maybeIndent(e3) {
      this._indent && 10 !== e3 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(e3) {
      if (this._indent && 10 !== e3 && this.endsWith(10)) return true;
    }
    _maybeAddParenChar(e3) {
      const t3 = this._parenPushNewlineState;
      t3 && 32 !== e3 && (10 === e3 ? (this.tokenChar(40), this.indent(), t3.printed = true) : this._parenPushNewlineState = null);
    }
    _maybeAddParen(e3) {
      const t3 = this._parenPushNewlineState;
      if (!t3) return;
      const r3 = e3.length;
      let n3;
      for (n3 = 0; n3 < r3 && 32 === e3.charCodeAt(n3); n3++) continue;
      if (n3 === r3) return;
      const s3 = e3.charCodeAt(n3);
      if (10 !== s3) {
        if (47 !== s3 || n3 + 1 === r3) return void (this._parenPushNewlineState = null);
        const t4 = e3.charCodeAt(n3 + 1);
        if (42 === t4) return;
        if (47 !== t4) return void (this._parenPushNewlineState = null);
      }
      this.tokenChar(40), this.indent(), t3.printed = true;
    }
    catchUp(e3) {
      if (!this.format.retainLines) return;
      const t3 = e3 - this._buf.getCurrentLine();
      for (let e4 = 0; e4 < t3; e4++) this._newline();
    }
    _catchUp(e3, t3) {
      var r3;
      if (!this.format.retainLines) return;
      const n3 = null == t3 || null == (r3 = t3[e3]) ? void 0 : r3.line;
      if (null != n3) {
        const e4 = n3 - this._buf.getCurrentLine();
        for (let t4 = 0; t4 < e4; t4++) this._newline();
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(e3, t3, r3) {
      if (r3) this._noLineTerminator = true, this.print(e3, t3);
      else {
        const r4 = { printed: false };
        this._parenPushNewlineState = r4, this.print(e3, t3), r4.printed && (this.dedent(), this.newline(), this.tokenChar(41));
      }
    }
    print(e3, t3, r3, n3, s3) {
      var i3, o3;
      if (!e3) return;
      this._endsWithInnerRaw = false;
      const a3 = e3.type, l2 = this.format, c2 = l2.concise;
      e3._compact && (l2.concise = true);
      const u2 = this[a3];
      if (void 0 === u2) throw new ReferenceError(`unknown node of type ${JSON.stringify(a3)} with constructor ${JSON.stringify(e3.constructor.name)}`);
      this._printStack.push(e3);
      const p2 = this._insideAux;
      this._insideAux = null == e3.loc, this._maybeAddAuxComment(this._insideAux && !p2);
      const d2 = null == (i3 = e3.extra) ? void 0 : i3.parenthesized;
      let f2 = s3 || d2 && l2.retainFunctionParens && "FunctionExpression" === a3 || y(e3, t3, this._printStack);
      if (!f2 && d2 && null != (o3 = e3.leadingComments) && o3.length && "CommentBlock" === e3.leadingComments[0].type) switch (null == t3 ? void 0 : t3.type) {
        case "ExpressionStatement":
        case "VariableDeclarator":
        case "AssignmentExpression":
        case "ReturnStatement":
          break;
        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          if (t3.callee !== e3) break;
        default:
          f2 = true;
      }
      f2 && (this.tokenChar(40), this._endsWithInnerRaw = false), this._lastCommentLine = 0, this._printLeadingComments(e3, t3);
      const h2 = "Program" === a3 || "File" === a3 ? null : e3.loc;
      this.exactSource(h2, u2.bind(this, e3, t3)), f2 ? (this._printTrailingComments(e3, t3), this.tokenChar(41), this._noLineTerminator = r3) : r3 && !this._noLineTerminator ? (this._noLineTerminator = true, this._printTrailingComments(e3, t3)) : this._printTrailingComments(e3, t3, n3), this._printStack.pop(), l2.concise = c2, this._insideAux = p2, this._endsWithInnerRaw = false;
    }
    _maybeAddAuxComment(e3) {
      e3 && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = true;
      const e3 = this.format.auxiliaryCommentBefore;
      e3 && this._printComment({ type: "CommentBlock", value: e3 }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = false;
      const e3 = this.format.auxiliaryCommentAfter;
      e3 && this._printComment({ type: "CommentBlock", value: e3 }, 0);
    }
    getPossibleRaw(e3) {
      const t3 = e3.extra;
      if (null != (null == t3 ? void 0 : t3.raw) && null != t3.rawValue && e3.value === t3.rawValue) return t3.raw;
    }
    printJoin(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      if (null == e3 || !e3.length) return;
      let { indent: n3 } = r3;
      if (null == n3 && this.format.retainLines) {
        var s3;
        const t4 = null == (s3 = e3[0].loc) ? void 0 : s3.start.line;
        null != t4 && t4 !== this._buf.getCurrentLine() && (n3 = true);
      }
      n3 && this.indent();
      const i3 = { addNewlines: r3.addNewlines, nextNodeStartLine: 0 }, o3 = r3.separator ? r3.separator.bind(this) : null, a3 = e3.length;
      for (let n4 = 0; n4 < a3; n4++) {
        const s4 = e3[n4];
        var l2;
        if (s4 && (r3.statement && this._printNewline(0 === n4, i3), this.print(s4, t3, void 0, r3.trailingCommentsLineOffset || 0), null == r3.iterator || r3.iterator(s4, n4), n4 < a3 - 1 && (null == o3 || o3()), r3.statement)) if (null != (l2 = s4.trailingComments) && l2.length || (this._lastCommentLine = 0), n4 + 1 === a3) this.newline(1);
        else {
          var c2;
          const t4 = e3[n4 + 1];
          i3.nextNodeStartLine = (null == (c2 = t4.loc) ? void 0 : c2.start.line) || 0, this._printNewline(true, i3);
        }
      }
      n3 && this.dedent();
    }
    printAndIndentOnComments(e3, t3) {
      const r3 = e3.leadingComments && e3.leadingComments.length > 0;
      r3 && this.indent(), this.print(e3, t3), r3 && this.dedent();
    }
    printBlock(e3) {
      const t3 = e3.body;
      "EmptyStatement" !== t3.type && this.space(), this.print(t3, e3);
    }
    _printTrailingComments(e3, t3, r3) {
      const { innerComments: n3, trailingComments: s3 } = e3;
      null != n3 && n3.length && this._printComments(2, n3, e3, t3, r3), null != s3 && s3.length && this._printComments(2, s3, e3, t3, r3);
    }
    _printLeadingComments(e3, t3) {
      const r3 = e3.leadingComments;
      null != r3 && r3.length && this._printComments(0, r3, e3, t3);
    }
    _maybePrintInnerComments() {
      this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = true, this._indentInnerComments = true;
    }
    printInnerComments() {
      const e3 = this._printStack[this._printStack.length - 1], t3 = e3.innerComments;
      if (null == t3 || !t3.length) return;
      const r3 = this.endsWith(32), n3 = this._indentInnerComments, s3 = this._printedComments.size;
      n3 && this.indent(), this._printComments(1, t3, e3), r3 && s3 !== this._printedComments.size && this.space(), n3 && this.dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = false;
    }
    printSequence(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      r3.statement = true, null != r3.indent || (r3.indent = false), this.printJoin(e3, t3, r3);
    }
    printList(e3, t3) {
      let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      null == r3.separator && (r3.separator = b), this.printJoin(e3, t3, r3);
    }
    _printNewline(e3, t3) {
      const r3 = this.format;
      if (r3.retainLines || r3.compact) return;
      if (r3.concise) return void this.space();
      if (!e3) return;
      const n3 = t3.nextNodeStartLine, s3 = this._lastCommentLine;
      if (n3 > 0 && s3 > 0) {
        const e4 = n3 - s3;
        if (e4 >= 0) return void this.newline(e4 || 1);
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(e3) {
      return e3.ignore || this._printedComments.has(e3) ? 0 : this._noLineTerminator && m.test(e3.value) ? 2 : (this._printedComments.add(e3), this.format.shouldPrintComment(e3.value) ? 1 : 0);
    }
    _printComment(e3, t3) {
      const r3 = this._noLineTerminator, n3 = "CommentBlock" === e3.type, s3 = n3 && 1 !== t3 && !this._noLineTerminator;
      s3 && this._buf.hasContent() && 2 !== t3 && this.newline(1);
      const i3 = this.getLastChar();
      let o3;
      if (91 !== i3 && 123 !== i3 && this.space(), n3) {
        const { _parenPushNewlineState: t4 } = this;
        if (false === (null == t4 ? void 0 : t4.printed) && h.test(e3.value) && (this.tokenChar(40), this.indent(), t4.printed = true), o3 = `/*${e3.value}*/`, this.format.indent.adjustMultilineComment) {
          var a3;
          const t5 = null == (a3 = e3.loc) ? void 0 : a3.start.column;
          if (t5) {
            const e4 = new RegExp("\\n\\s{1," + t5 + "}", "g");
            o3 = o3.replace(e4, "\n");
          }
          if (this.format.concise) o3 = o3.replace(/\n(?!$)/g, "\n");
          else {
            let e4 = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (e4 += this._getIndent()), o3 = o3.replace(/\n(?!$)/g, `
${" ".repeat(e4)}`);
          }
        }
      } else o3 = r3 ? `/*${e3.value}*/` : `//${e3.value}`;
      this.endsWith(47) && this._space(), this.source("start", e3.loc), this._append(o3, n3), n3 || r3 || this.newline(1, true), s3 && 3 !== t3 && this.newline(1);
    }
    _printComments(e3, t3, r3, n3) {
      let s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
      const i3 = r3.loc, o3 = t3.length;
      let d2 = !!i3;
      const f2 = d2 ? i3.start.line : 0, m2 = d2 ? i3.end.line : 0;
      let y2 = 0, g2 = 0;
      const b2 = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let i4 = 0; i4 < o3; i4++) {
        const v = t3[i4], E = this._shouldPrintComment(v);
        if (2 === E) {
          d2 = false;
          break;
        }
        if (d2 && v.loc && 1 === E) {
          const t4 = v.loc.start.line, r4 = v.loc.end.line;
          if (0 === e3) {
            let e4 = 0;
            0 === i4 ? !this._buf.hasContent() || "CommentLine" !== v.type && t4 == r4 || (e4 = g2 = 1) : e4 = t4 - y2, y2 = r4, b2(e4), this._printComment(v, 1), i4 + 1 === o3 && (b2(Math.max(f2 - y2, g2)), y2 = f2);
          } else if (1 === e3) {
            const e4 = t4 - (0 === i4 ? f2 : y2);
            y2 = r4, b2(e4), this._printComment(v, 1), i4 + 1 === o3 && (b2(Math.min(1, m2 - y2)), y2 = m2);
          } else {
            const e4 = t4 - (0 === i4 ? m2 - s3 : y2);
            y2 = r4, b2(e4), this._printComment(v, 1);
          }
        } else {
          if (d2 = false, 1 !== E) continue;
          if (1 === o3) {
            const t4 = v.loc ? v.loc.start.line === v.loc.end.line : !h.test(v.value), s4 = t4 && !l(r3) && !c(n3) && !u(n3) && !p(n3);
            0 === e3 ? this._printComment(v, s4 && "ObjectExpression" !== r3.type || t4 && a2(n3, { body: r3 }) ? 1 : 0) : s4 && 2 === e3 ? this._printComment(v, 1) : this._printComment(v, 0);
          } else 1 !== e3 || "ObjectExpression" === r3.type && r3.properties.length > 1 || "ClassBody" === r3.type || "TSInterfaceBody" === r3.type ? this._printComment(v, 0) : this._printComment(v, 0 === i4 ? 2 : i4 === o3 - 1 ? 3 : 0);
        }
      }
      2 === e3 && d2 && y2 && (this._lastCommentLine = y2);
    }
  }
  function b() {
    this.tokenChar(44), this.space();
  }
  Object.assign(g.prototype, o2), g.prototype.Noop = function() {
  }, t2.default = g;
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = class {
    constructor(e3, t3) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = true, this._indentChar = "", this._fastIndentations = [], this._position = { line: 1, column: 0 }, this._sourcePosition = { identifierName: void 0, identifierNamePos: void 0, line: void 0, column: void 0, filename: void 0 }, this._map = e3, this._indentChar = t3;
      for (let e4 = 0; e4 < 64; e4++) this._fastIndentations.push(t3.repeat(e4));
      this._allocQueue();
    }
    _allocQueue() {
      const e3 = this._queue;
      for (let t3 = 0; t3 < 16; t3++) e3.push({ char: 0, repeat: 1, line: void 0, column: void 0, identifierName: void 0, identifierNamePos: void 0, filename: "" });
    }
    _pushQueue(e3, t3, r2, n2, s2) {
      const i2 = this._queueCursor;
      i2 === this._queue.length && this._allocQueue();
      const o2 = this._queue[i2];
      o2.char = e3, o2.repeat = t3, o2.line = r2, o2.column = n2, o2.filename = s2, this._queueCursor++;
    }
    _popQueue() {
      if (0 === this._queueCursor) throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      const e3 = this._map, t3 = { code: (this._buf + this._str).trimRight(), decodedMap: null == e3 ? void 0 : e3.getDecoded(), get __mergedMap() {
        return this.map;
      }, get map() {
        const r2 = e3 ? e3.get() : null;
        return t3.map = r2, r2;
      }, set map(e4) {
        Object.defineProperty(t3, "map", { value: e4, writable: true });
      }, get rawMappings() {
        const r2 = null == e3 ? void 0 : e3.getRawMappings();
        return t3.rawMappings = r2, r2;
      }, set rawMappings(e4) {
        Object.defineProperty(t3, "rawMappings", { value: e4, writable: true });
      } };
      return t3;
    }
    append(e3, t3) {
      this._flush(), this._append(e3, this._sourcePosition, t3);
    }
    appendChar(e3) {
      this._flush(), this._appendChar(e3, 1, this._sourcePosition);
    }
    queue(e3) {
      if (10 === e3) for (; 0 !== this._queueCursor; ) {
        const e4 = this._queue[this._queueCursor - 1].char;
        if (32 !== e4 && 9 !== e4) break;
        this._queueCursor--;
      }
      const t3 = this._sourcePosition;
      this._pushQueue(e3, 1, t3.line, t3.column, t3.filename);
    }
    queueIndentation(e3) {
      0 !== e3 && this._pushQueue(-1, e3, void 0, void 0, void 0);
    }
    _flush() {
      const e3 = this._queueCursor, t3 = this._queue;
      for (let r2 = 0; r2 < e3; r2++) {
        const e4 = t3[r2];
        this._appendChar(e4.char, e4.repeat, e4);
      }
      this._queueCursor = 0;
    }
    _appendChar(e3, t3, r2) {
      if (this._last = e3, -1 === e3) {
        const e4 = this._fastIndentations[t3];
        this._str += void 0 !== e4 ? e4 : t3 > 1 ? this._indentChar.repeat(t3) : this._indentChar;
      } else this._str += t3 > 1 ? String.fromCharCode(e3).repeat(t3) : String.fromCharCode(e3);
      10 !== e3 ? (this._mark(r2.line, r2.column, r2.identifierName, r2.identifierNamePos, r2.filename), this._position.column += t3) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (r2.identifierName = void 0, r2.identifierNamePos = void 0);
    }
    _append(e3, t3, r2) {
      const n2 = e3.length, s2 = this._position;
      if (this._last = e3.charCodeAt(n2 - 1), ++this._appendCount > 4096 ? (this._str, this._buf += this._str, this._str = e3, this._appendCount = 0) : this._str += e3, !r2 && !this._map) return void (s2.column += n2);
      const { column: i2, identifierName: o2, identifierNamePos: a2, filename: l } = t3;
      let c = t3.line;
      null == o2 && null == a2 || !this._canMarkIdName || (t3.identifierName = void 0, t3.identifierNamePos = void 0);
      let u = e3.indexOf("\n"), p = 0;
      for (0 !== u && this._mark(c, i2, o2, a2, l); -1 !== u; ) s2.line++, s2.column = 0, p = u + 1, p < n2 && void 0 !== c && this._mark(++c, 0, null, null, l), u = e3.indexOf("\n", p);
      s2.column += n2 - p;
    }
    _mark(e3, t3, r2, n2, s2) {
      var i2;
      null == (i2 = this._map) || i2.mark(this._position, e3, t3, r2, n2, s2);
    }
    removeTrailingNewline() {
      const e3 = this._queueCursor;
      0 !== e3 && 10 === this._queue[e3 - 1].char && this._queueCursor--;
    }
    removeLastSemicolon() {
      const e3 = this._queueCursor;
      0 !== e3 && 59 === this._queue[e3 - 1].char && this._queueCursor--;
    }
    getLastChar() {
      const e3 = this._queueCursor;
      return 0 !== e3 ? this._queue[e3 - 1].char : this._last;
    }
    getNewlineCount() {
      const e3 = this._queueCursor;
      let t3 = 0;
      if (0 === e3) return 10 === this._last ? 1 : 0;
      for (let r2 = e3 - 1; r2 >= 0 && 10 === this._queue[r2].char; r2--) t3++;
      return t3 === e3 && 10 === this._last ? t3 + 1 : t3;
    }
    endsWithCharAndNewline() {
      const e3 = this._queue, t3 = this._queueCursor;
      if (0 !== t3) {
        if (10 !== e3[t3 - 1].char) return;
        return t3 > 1 ? e3[t3 - 2].char : this._last;
      }
    }
    hasContent() {
      return 0 !== this._queueCursor || !!this._last;
    }
    exactSource(e3, t3) {
      if (!this._map) return void t3();
      this.source("start", e3);
      const r2 = e3.identifierName, n2 = this._sourcePosition;
      r2 && (this._canMarkIdName = false, n2.identifierName = r2), t3(), r2 && (this._canMarkIdName = true, n2.identifierName = void 0, n2.identifierNamePos = void 0), this.source("end", e3);
    }
    source(e3, t3) {
      this._map && this._normalizePosition(e3, t3, 0);
    }
    sourceWithOffset(e3, t3, r2) {
      this._map && this._normalizePosition(e3, t3, r2);
    }
    withSource(e3, t3, r2) {
      this._map && this.source(e3, t3), r2();
    }
    _normalizePosition(e3, t3, r2) {
      const n2 = t3[e3], s2 = this._sourcePosition;
      n2 && (s2.line = n2.line, s2.column = Math.max(n2.column + r2, 0), s2.filename = t3.filename);
    }
    getCurrentColumn() {
      const e3 = this._queue, t3 = this._queueCursor;
      let r2 = -1, n2 = 0;
      for (let s2 = 0; s2 < t3; s2++) {
        const t4 = e3[s2];
        10 === t4.char && (r2 = n2), n2 += t4.repeat;
      }
      return -1 === r2 ? this._position.column + n2 : n2 - 1 - r2;
    }
    getCurrentLine() {
      let e3 = 0;
      const t3 = this._queue;
      for (let r2 = 0; r2 < this._queueCursor; r2++) 10 === t3[r2].char && e3++;
      return this._position.line + e3;
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.nodes = void 0;
  var n2 = r2(0);
  const { FLIPPED_ALIAS_KEYS: s2, isArrayExpression: i2, isAssignmentExpression: o2, isBinary: a2, isBlockStatement: l, isCallExpression: c, isFunction: u, isIdentifier: p, isLiteral: d, isMemberExpression: f, isObjectExpression: h, isOptionalCallExpression: m, isOptionalMemberExpression: y, isStringLiteral: g } = n2;
  function b(e3, t3) {
    return e3 ? (f(e3) || y(e3) ? (b(e3.object, t3), e3.computed && b(e3.property, t3)) : a2(e3) || o2(e3) ? (b(e3.left, t3), b(e3.right, t3)) : c(e3) || m(e3) ? (t3.hasCall = true, b(e3.callee, t3)) : u(e3) ? t3.hasFunction = true : p(e3) && (t3.hasHelper = t3.hasHelper || e3.callee && E(e3.callee)), t3) : t3;
  }
  function v(e3) {
    return b(e3, { hasCall: false, hasFunction: false, hasHelper: false });
  }
  function E(e3) {
    return !!e3 && (f(e3) ? E(e3.object) || E(e3.property) : p(e3) ? "require" === e3.name || 95 === e3.name.charCodeAt(0) : c(e3) ? E(e3.callee) : !(!a2(e3) && !o2(e3)) && (p(e3.left) && E(e3.left) || E(e3.right)));
  }
  function S(e3) {
    return d(e3) || h(e3) || i2(e3) || p(e3) || f(e3);
  }
  const x = t2.nodes = { AssignmentExpression(e3) {
    const t3 = v(e3.right);
    if (t3.hasCall && t3.hasHelper || t3.hasFunction) return t3.hasFunction ? 3 : 2;
  }, SwitchCase: (e3, t3) => (e3.consequent.length || t3.cases[0] === e3 ? 1 : 0) | (e3.consequent.length || t3.cases[t3.cases.length - 1] !== e3 ? 0 : 2), LogicalExpression(e3) {
    if (u(e3.left) || u(e3.right)) return 2;
  }, Literal(e3) {
    if (g(e3) && "use strict" === e3.value) return 2;
  }, CallExpression(e3) {
    if (u(e3.callee) || E(e3)) return 3;
  }, OptionalCallExpression(e3) {
    if (u(e3.callee)) return 3;
  }, VariableDeclaration(e3) {
    for (let t3 = 0; t3 < e3.declarations.length; t3++) {
      const r3 = e3.declarations[t3];
      let n3 = E(r3.id) && !S(r3.init);
      if (!n3 && r3.init) {
        const e4 = v(r3.init);
        n3 = E(r3.init) && e4.hasCall || e4.hasFunction;
      }
      if (n3) return 3;
    }
  }, IfStatement(e3) {
    if (l(e3.consequent)) return 3;
  } };
  x.ObjectProperty = x.ObjectTypeProperty = x.ObjectMethod = function(e3, t3) {
    if (t3.properties[0] === e3) return 1;
  }, x.ObjectTypeCallProperty = function(e3, t3) {
    var r3;
    if (t3.callProperties[0] === e3 && (null == (r3 = t3.properties) || !r3.length)) return 1;
  }, x.ObjectTypeIndexer = function(e3, t3) {
    var r3, n3;
    if (!(t3.indexers[0] !== e3 || null != (r3 = t3.properties) && r3.length || null != (n3 = t3.callProperties) && n3.length)) return 1;
  }, x.ObjectTypeInternalSlot = function(e3, t3) {
    var r3, n3, s3;
    if (!(t3.internalSlots[0] !== e3 || null != (r3 = t3.properties) && r3.length || null != (n3 = t3.callProperties) && n3.length || null != (s3 = t3.indexers) && s3.length)) return 1;
  }, [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function(e3) {
    let [t3, r3] = e3;
    [t3].concat(s2[t3] || []).forEach(function(e4) {
      const t4 = r3 ? 3 : 0;
      x[e4] = () => t4;
    });
  });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrowFunctionExpression = function(e3, t3) {
    return l(t3) || E(e3, t3);
  }, t2.AssignmentExpression = function(e3, t3) {
    return !!d(e3.left) || E(e3, t3);
  }, t2.Binary = function(e3, t3) {
    const r3 = t3.type;
    if ("**" === e3.operator && "BinaryExpression" === r3 && "**" === t3.operator) return t3.left === e3;
    if (g(e3, t3)) return true;
    if (b(e3, t3) || "UnaryExpression" === r3 || "SpreadElement" === r3 || "AwaitExpression" === r3) return true;
    if ("BinaryExpression" === r3 || "LogicalExpression" === r3) {
      const n3 = m.get(t3.operator), s3 = m.get(e3.operator);
      if (n3 === s3 && t3.right === e3 && "LogicalExpression" !== r3 || n3 > s3) return true;
    }
  }, t2.BinaryExpression = function(e3, t3) {
    if ("in" === e3.operator) {
      const e4 = t3.type;
      return "VariableDeclarator" === e4 || "ForStatement" === e4 || "ForInStatement" === e4 || "ForOfStatement" === e4;
    }
    return false;
  }, t2.ClassExpression = function(e3, t3, r3) {
    return S(r3, 5);
  }, t2.ConditionalExpression = E, t2.DoExpression = function(e3, t3, r3) {
    return !e3.async && S(r3, 1);
  }, t2.FunctionExpression = function(e3, t3, r3) {
    return S(r3, 5);
  }, t2.FunctionTypeAnnotation = function(e3, t3, r3) {
    if (r3.length < 3) return;
    const n3 = t3.type;
    return "UnionTypeAnnotation" === n3 || "IntersectionTypeAnnotation" === n3 || "ArrayTypeAnnotation" === n3 || "TypeAnnotation" === n3 && i2(r3[r3.length - 3]);
  }, t2.Identifier = function(e3, t3, r3) {
    var n3;
    const s3 = t3.type;
    if (null != (n3 = e3.extra) && n3.parenthesized && "AssignmentExpression" === s3 && t3.left === e3) {
      const e4 = t3.right.type;
      if (("FunctionExpression" === e4 || "ClassExpression" === e4) && null == t3.right.id) return true;
    }
    return "let" === e3.name ? S(r3, p(t3, { object: e3, computed: true }) || f(t3, { object: e3, computed: true, optional: false }) ? 57 : 32) : "async" === e3.name && c(t3) && e3 === t3.left;
  }, t2.LogicalExpression = function(e3, t3) {
    const r3 = t3.type;
    if (y(r3)) return true;
    if ("LogicalExpression" !== r3) return false;
    switch (e3.operator) {
      case "||":
        return "??" === t3.operator || "&&" === t3.operator;
      case "&&":
        return "??" === t3.operator;
      case "??":
        return "??" !== t3.operator;
    }
  }, t2.NullableTypeAnnotation = function(e3, t3) {
    return s2(t3);
  }, t2.ObjectExpression = function(e3, t3, r3) {
    return S(r3, 3);
  }, t2.OptionalIndexedAccessType = function(e3, t3) {
    return u(t3) && t3.objectType === e3;
  }, t2.OptionalCallExpression = t2.OptionalMemberExpression = function(e3, t3) {
    return a2(t3) && t3.callee === e3 || p(t3) && t3.object === e3;
  }, t2.SequenceExpression = function(e3, t3) {
    const r3 = t3.type;
    return !("ForStatement" === r3 || "ThrowStatement" === r3 || "ReturnStatement" === r3 || "IfStatement" === r3 && t3.test === e3 || "WhileStatement" === r3 && t3.test === e3 || "ForInStatement" === r3 && t3.right === e3 || "SwitchStatement" === r3 && t3.discriminant === e3 || "ExpressionStatement" === r3 && t3.expression === e3);
  }, t2.TSTypeAssertion = t2.TSSatisfiesExpression = t2.TSAsExpression = function() {
    return true;
  }, t2.TSInferType = function(e3, t3) {
    const r3 = t3.type;
    return "TSArrayType" === r3 || "TSOptionalType" === r3;
  }, t2.TSInstantiationExpression = function(e3, t3) {
    const r3 = t3.type;
    return ("CallExpression" === r3 || "OptionalCallExpression" === r3 || "NewExpression" === r3 || "TSInstantiationExpression" === r3) && !!t3.typeParameters;
  }, t2.TSIntersectionType = t2.TSUnionType = function(e3, t3) {
    const r3 = t3.type;
    return "TSArrayType" === r3 || "TSOptionalType" === r3 || "TSIntersectionType" === r3 || "TSUnionType" === r3 || "TSRestType" === r3;
  }, t2.UnaryLike = v, t2.IntersectionTypeAnnotation = t2.UnionTypeAnnotation = function(e3, t3) {
    const r3 = t3.type;
    return "ArrayTypeAnnotation" === r3 || "NullableTypeAnnotation" === r3 || "IntersectionTypeAnnotation" === r3 || "UnionTypeAnnotation" === r3;
  }, t2.UpdateExpression = function(e3, t3) {
    return b(e3, t3) || g(e3, t3);
  }, t2.AwaitExpression = t2.YieldExpression = function(e3, t3) {
    const r3 = t3.type;
    return "BinaryExpression" === r3 || "LogicalExpression" === r3 || "UnaryExpression" === r3 || "SpreadElement" === r3 || b(e3, t3) || "AwaitExpression" === r3 && h(e3) || "ConditionalExpression" === r3 && e3 === t3.test || g(e3, t3);
  };
  var n2 = r2(0);
  const { isArrayTypeAnnotation: s2, isArrowFunctionExpression: i2, isBinaryExpression: o2, isCallExpression: a2, isExportDeclaration: l, isForOfStatement: c, isIndexedAccessType: u, isMemberExpression: p, isObjectPattern: d, isOptionalMemberExpression: f, isYieldExpression: h } = n2, m = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function y(e3) {
    return "TSAsExpression" === e3 || "TSSatisfiesExpression" === e3 || "TSTypeAssertion" === e3;
  }
  const g = (e3, t3) => {
    const r3 = t3.type;
    return ("ClassDeclaration" === r3 || "ClassExpression" === r3) && t3.superClass === e3;
  }, b = (e3, t3) => {
    const r3 = t3.type;
    return ("MemberExpression" === r3 || "OptionalMemberExpression" === r3) && t3.object === e3 || ("CallExpression" === r3 || "OptionalCallExpression" === r3 || "NewExpression" === r3) && t3.callee === e3 || "TaggedTemplateExpression" === r3 && t3.tag === e3 || "TSNonNullExpression" === r3;
  };
  function v(e3, t3) {
    return b(e3, t3) || o2(t3) && "**" === t3.operator && t3.left === e3 || g(e3, t3);
  }
  function E(e3, t3) {
    const r3 = t3.type;
    return !!("UnaryExpression" === r3 || "SpreadElement" === r3 || "BinaryExpression" === r3 || "LogicalExpression" === r3 || "ConditionalExpression" === r3 && t3.test === e3 || "AwaitExpression" === r3 || y(r3)) || v(e3, t3);
  }
  function S(e3, t3) {
    const r3 = 1 & t3, n3 = 2 & t3, s3 = 4 & t3, i3 = 8 & t3, o3 = 16 & t3, a3 = 32 & t3;
    let l2 = e3.length - 1;
    if (l2 <= 0) return;
    let c2 = e3[l2];
    l2--;
    let u2 = e3[l2];
    for (; l2 >= 0; ) {
      const t4 = u2.type;
      if (r3 && "ExpressionStatement" === t4 && u2.expression === c2 || s3 && "ExportDefaultDeclaration" === t4 && c2 === u2.declaration || n3 && "ArrowFunctionExpression" === t4 && u2.body === c2 || i3 && "ForStatement" === t4 && u2.init === c2 || o3 && "ForInStatement" === t4 && u2.left === c2 || a3 && "ForOfStatement" === t4 && u2.left === c2) return true;
      if (!(l2 > 0 && (b(c2, u2) && "NewExpression" !== t4 || "SequenceExpression" === t4 && u2.expressions[0] === c2 || "UpdateExpression" === t4 && !u2.prefix || "ConditionalExpression" === t4 && u2.test === c2 || ("BinaryExpression" === t4 || "LogicalExpression" === t4) && u2.left === c2 || "AssignmentExpression" === t4 && u2.left === c2))) return false;
      c2 = u2, l2--, u2 = e3[l2];
    }
    return false;
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.TaggedTemplateExpression = function(e3) {
    this.print(e3.tag, e3), this.print(e3.typeParameters, e3), this.print(e3.quasi, e3);
  }, t2.TemplateElement = function(e3, t3) {
    const r2 = t3.quasis[0] === e3, n2 = t3.quasis[t3.quasis.length - 1] === e3, s2 = (r2 ? "`" : "}") + e3.value.raw + (n2 ? "`" : "${");
    this.token(s2, true);
  }, t2.TemplateLiteral = function(e3) {
    const t3 = e3.quasis;
    for (let r2 = 0; r2 < t3.length; r2++) this.print(t3[r2], e3), r2 + 1 < t3.length && this.print(e3.expressions[r2], e3);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.LogicalExpression = t2.BinaryExpression = t2.AssignmentExpression = function(e3, t3) {
    const r3 = this.inForStatementInitCounter && "in" === e3.operator && !s2.needsParens(e3, t3);
    r3 && this.tokenChar(40), this.print(e3.left, e3), this.space(), "in" === e3.operator || "instanceof" === e3.operator ? this.word(e3.operator) : this.token(e3.operator), this.space(), this.print(e3.right, e3), r3 && this.tokenChar(41);
  }, t2.AssignmentPattern = function(e3) {
    this.print(e3.left, e3), e3.left.optional && this.tokenChar(63), this.print(e3.left.typeAnnotation, e3), this.space(), this.tokenChar(61), this.space(), this.print(e3.right, e3);
  }, t2.AwaitExpression = function(e3) {
    this.word("await"), e3.argument && (this.space(), this.printTerminatorless(e3.argument, e3, false));
  }, t2.BindExpression = function(e3) {
    this.print(e3.object, e3), this.token("::"), this.print(e3.callee, e3);
  }, t2.CallExpression = function(e3) {
    this.print(e3.callee, e3), this.print(e3.typeArguments, e3), this.print(e3.typeParameters, e3), this.tokenChar(40), this.printList(e3.arguments, e3), this.rightParens(e3);
  }, t2.ConditionalExpression = function(e3) {
    this.print(e3.test, e3), this.space(), this.tokenChar(63), this.space(), this.print(e3.consequent, e3), this.space(), this.tokenChar(58), this.space(), this.print(e3.alternate, e3);
  }, t2.Decorator = function(e3) {
    this.tokenChar(64);
    const { expression: t3 } = e3;
    !function(e4) {
      return "ParenthesizedExpression" !== e4.type && !c("CallExpression" === e4.type ? e4.callee : e4);
    }(t3) ? this.print(t3, e3) : (this.tokenChar(40), this.print(t3, e3), this.tokenChar(41)), this.newline();
  }, t2.DoExpression = function(e3) {
    e3.async && (this.word("async", true), this.space()), this.word("do"), this.space(), this.print(e3.body, e3);
  }, t2.EmptyStatement = function() {
    this.semicolon(true);
  }, t2.ExpressionStatement = function(e3) {
    this.print(e3.expression, e3), this.semicolon();
  }, t2.Import = function() {
    this.word("import");
  }, t2.MemberExpression = function(e3) {
    if (this.print(e3.object, e3), !e3.computed && a2(e3.property)) throw new TypeError("Got a MemberExpression for MemberExpression property");
    let t3 = e3.computed;
    o2(e3.property) && "number" == typeof e3.property.value && (t3 = true), t3 ? (this.tokenChar(91), this.print(e3.property, e3), this.tokenChar(93)) : (this.tokenChar(46), this.print(e3.property, e3));
  }, t2.MetaProperty = function(e3) {
    this.print(e3.meta, e3), this.tokenChar(46), this.print(e3.property, e3);
  }, t2.ModuleExpression = function(e3) {
    this.word("module", true), this.space(), this.tokenChar(123), this.indent();
    const { body: t3 } = e3;
    (t3.body.length || t3.directives.length) && this.newline(), this.print(t3, e3), this.dedent(), this.rightBrace(e3);
  }, t2.NewExpression = function(e3, t3) {
    this.word("new"), this.space(), this.print(e3.callee, e3), (!this.format.minified || 0 !== e3.arguments.length || e3.optional || i2(t3, { callee: e3 }) || a2(t3) || l(t3)) && (this.print(e3.typeArguments, e3), this.print(e3.typeParameters, e3), e3.optional && this.token("?."), this.tokenChar(40), this.printList(e3.arguments, e3), this.rightParens(e3));
  }, t2.OptionalCallExpression = function(e3) {
    this.print(e3.callee, e3), this.print(e3.typeParameters, e3), e3.optional && this.token("?."), this.print(e3.typeArguments, e3), this.tokenChar(40), this.printList(e3.arguments, e3), this.rightParens(e3);
  }, t2.OptionalMemberExpression = function(e3) {
    let { computed: t3 } = e3;
    const { optional: r3, property: n3 } = e3;
    if (this.print(e3.object, e3), !t3 && a2(n3)) throw new TypeError("Got a MemberExpression for MemberExpression property");
    o2(n3) && "number" == typeof n3.value && (t3 = true), r3 && this.token("?."), t3 ? (this.tokenChar(91), this.print(n3, e3), this.tokenChar(93)) : (r3 || this.tokenChar(46), this.print(n3, e3));
  }, t2.ParenthesizedExpression = function(e3) {
    this.tokenChar(40), this.print(e3.expression, e3), this.rightParens(e3);
  }, t2.PrivateName = function(e3) {
    this.tokenChar(35), this.print(e3.id, e3);
  }, t2.SequenceExpression = function(e3) {
    this.printList(e3.expressions, e3);
  }, t2.Super = function() {
    this.word("super");
  }, t2.ThisExpression = function() {
    this.word("this");
  }, t2.UnaryExpression = function(e3) {
    const { operator: t3 } = e3;
    "void" === t3 || "delete" === t3 || "typeof" === t3 || "throw" === t3 ? (this.word(t3), this.space()) : this.token(t3), this.print(e3.argument, e3);
  }, t2.UpdateExpression = function(e3) {
    e3.prefix ? (this.token(e3.operator), this.print(e3.argument, e3)) : (this.printTerminatorless(e3.argument, e3, true), this.token(e3.operator));
  }, t2.V8IntrinsicIdentifier = function(e3) {
    this.tokenChar(37), this.word(e3.name);
  }, t2.YieldExpression = function(e3) {
    this.word("yield", true), e3.delegate ? (this.tokenChar(42), e3.argument && (this.space(), this.print(e3.argument, e3))) : e3.argument && (this.space(), this.printTerminatorless(e3.argument, e3, false));
  }, t2._shouldPrintDecoratorsBeforeExport = function(e3) {
    return "boolean" == typeof this.format.decoratorsBeforeExport ? this.format.decoratorsBeforeExport : "number" == typeof e3.start && e3.start === e3.declaration.start;
  };
  var n2 = r2(0), s2 = r2(184);
  const { isCallExpression: i2, isLiteral: o2, isMemberExpression: a2, isNewExpression: l } = n2;
  function c(e3) {
    switch (e3.type) {
      case "Identifier":
        return true;
      case "MemberExpression":
        return !e3.computed && "Identifier" === e3.property.type && c(e3.object);
      default:
        return false;
    }
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.BreakStatement = function(e3) {
    this.word("break"), u(this, e3.label, e3, true);
  }, t2.CatchClause = function(e3) {
    this.word("catch"), this.space(), e3.param && (this.tokenChar(40), this.print(e3.param, e3), this.print(e3.param.typeAnnotation, e3), this.tokenChar(41), this.space()), this.print(e3.body, e3);
  }, t2.ContinueStatement = function(e3) {
    this.word("continue"), u(this, e3.label, e3, true);
  }, t2.DebuggerStatement = function() {
    this.word("debugger"), this.semicolon();
  }, t2.DoWhileStatement = function(e3) {
    this.word("do"), this.space(), this.print(e3.body, e3), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e3.test, e3), this.tokenChar(41), this.semicolon();
  }, t2.ForOfStatement = t2.ForInStatement = void 0, t2.ForStatement = function(e3) {
    this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(e3.init, e3), this.inForStatementInitCounter--, this.tokenChar(59), e3.test && (this.space(), this.print(e3.test, e3)), this.tokenChar(59), e3.update && (this.space(), this.print(e3.update, e3)), this.tokenChar(41), this.printBlock(e3);
  }, t2.IfStatement = function(e3) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(e3.test, e3), this.tokenChar(41), this.space();
    const t3 = e3.alternate && o2(l(e3.consequent));
    t3 && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e3.consequent, e3), t3 && (this.dedent(), this.newline(), this.tokenChar(125)), e3.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(e3.alternate, e3));
  }, t2.LabeledStatement = function(e3) {
    this.print(e3.label, e3), this.tokenChar(58), this.space(), this.print(e3.body, e3);
  }, t2.ReturnStatement = function(e3) {
    this.word("return"), u(this, e3.argument, e3, false);
  }, t2.SwitchCase = function(e3) {
    e3.test ? (this.word("case"), this.space(), this.print(e3.test, e3), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e3.consequent.length && (this.newline(), this.printSequence(e3.consequent, e3, { indent: true }));
  }, t2.SwitchStatement = function(e3) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(e3.discriminant, e3), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(e3.cases, e3, { indent: true, addNewlines(t3, r3) {
      if (!t3 && e3.cases[e3.cases.length - 1] === r3) return -1;
    } }), this.rightBrace(e3);
  }, t2.ThrowStatement = function(e3) {
    this.word("throw"), u(this, e3.argument, e3, false);
  }, t2.TryStatement = function(e3) {
    this.word("try"), this.space(), this.print(e3.block, e3), this.space(), e3.handlers ? this.print(e3.handlers[0], e3) : this.print(e3.handler, e3), e3.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e3.finalizer, e3));
  }, t2.VariableDeclaration = function(e3, t3) {
    e3.declare && (this.word("declare"), this.space());
    const { kind: r3 } = e3;
    this.word(r3, "using" === r3 || "await using" === r3), this.space();
    let n3 = false;
    if (!s2(t3)) for (const t4 of e3.declarations) t4.init && (n3 = true);
    if (this.printList(e3.declarations, e3, { separator: n3 ? function() {
      this.tokenChar(44), this.newline();
    } : void 0, indent: e3.declarations.length > 1 }), s2(t3)) {
      if (i2(t3)) {
        if (t3.init === e3) return;
      } else if (t3.left === e3) return;
    }
    this.semicolon();
  }, t2.VariableDeclarator = function(e3) {
    this.print(e3.id, e3), e3.definite && this.tokenChar(33), this.print(e3.id.typeAnnotation, e3), e3.init && (this.space(), this.tokenChar(61), this.space(), this.print(e3.init, e3));
  }, t2.WhileStatement = function(e3) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(e3.test, e3), this.tokenChar(41), this.printBlock(e3);
  }, t2.WithStatement = function(e3) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(e3.object, e3), this.tokenChar(41), this.printBlock(e3);
  };
  var n2 = r2(0);
  const { isFor: s2, isForStatement: i2, isIfStatement: o2, isStatement: a2 } = n2;
  function l(e3) {
    const { body: t3 } = e3;
    return false === a2(t3) ? e3 : l(t3);
  }
  function c(e3) {
    this.word("for"), this.space();
    const t3 = "ForOfStatement" === e3.type;
    t3 && e3.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(e3.left, e3), this.space(), this.word(t3 ? "of" : "in"), this.space(), this.print(e3.right, e3), this.tokenChar(41), this.printBlock(e3);
  }
  function u(e3, t3, r3, n3) {
    t3 && (e3.space(), e3.printTerminatorless(t3, r3, n3)), e3.semicolon();
  }
  t2.ForInStatement = c, t2.ForOfStatement = c;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ClassAccessorProperty = function(e3) {
    var t3;
    this.printJoin(e3.decorators, e3);
    const r3 = null == (t3 = e3.key.loc) || null == (t3 = t3.end) ? void 0 : t3.line;
    r3 && this.catchUp(r3), this.tsPrintClassMemberModifiers(e3), this.word("accessor", true), this.space(), e3.computed ? (this.tokenChar(91), this.print(e3.key, e3), this.tokenChar(93)) : (this._variance(e3), this.print(e3.key, e3)), e3.optional && this.tokenChar(63), e3.definite && this.tokenChar(33), this.print(e3.typeAnnotation, e3), e3.value && (this.space(), this.tokenChar(61), this.space(), this.print(e3.value, e3)), this.semicolon();
  }, t2.ClassBody = function(e3) {
    this.tokenChar(123), 0 === e3.body.length ? this.tokenChar(125) : (this.newline(), this.printSequence(e3.body, e3, { indent: true }), this.endsWith(10) || this.newline(), this.rightBrace(e3));
  }, t2.ClassExpression = t2.ClassDeclaration = function(e3, t3) {
    (s2(t3) || i2(t3)) && this._shouldPrintDecoratorsBeforeExport(t3) || this.printJoin(e3.decorators, e3), e3.declare && (this.word("declare"), this.space()), e3.abstract && (this.word("abstract"), this.space()), this.word("class"), e3.id && (this.space(), this.print(e3.id, e3)), this.print(e3.typeParameters, e3), e3.superClass && (this.space(), this.word("extends"), this.space(), this.print(e3.superClass, e3), this.print(e3.superTypeParameters, e3)), e3.implements && (this.space(), this.word("implements"), this.space(), this.printList(e3.implements, e3)), this.space(), this.print(e3.body, e3);
  }, t2.ClassMethod = function(e3) {
    this._classMethodHead(e3), this.space(), this.print(e3.body, e3);
  }, t2.ClassPrivateMethod = function(e3) {
    this._classMethodHead(e3), this.space(), this.print(e3.body, e3);
  }, t2.ClassPrivateProperty = function(e3) {
    this.printJoin(e3.decorators, e3), e3.static && (this.word("static"), this.space()), this.print(e3.key, e3), this.print(e3.typeAnnotation, e3), e3.value && (this.space(), this.tokenChar(61), this.space(), this.print(e3.value, e3)), this.semicolon();
  }, t2.ClassProperty = function(e3) {
    var t3;
    this.printJoin(e3.decorators, e3);
    const r3 = null == (t3 = e3.key.loc) || null == (t3 = t3.end) ? void 0 : t3.line;
    r3 && this.catchUp(r3), this.tsPrintClassMemberModifiers(e3), e3.computed ? (this.tokenChar(91), this.print(e3.key, e3), this.tokenChar(93)) : (this._variance(e3), this.print(e3.key, e3)), e3.optional && this.tokenChar(63), e3.definite && this.tokenChar(33), this.print(e3.typeAnnotation, e3), e3.value && (this.space(), this.tokenChar(61), this.space(), this.print(e3.value, e3)), this.semicolon();
  }, t2.StaticBlock = function(e3) {
    this.word("static"), this.space(), this.tokenChar(123), 0 === e3.body.length ? this.tokenChar(125) : (this.newline(), this.printSequence(e3.body, e3, { indent: true }), this.rightBrace(e3));
  }, t2._classMethodHead = function(e3) {
    var t3;
    this.printJoin(e3.decorators, e3);
    const r3 = null == (t3 = e3.key.loc) || null == (t3 = t3.end) ? void 0 : t3.line;
    r3 && this.catchUp(r3), this.tsPrintClassMemberModifiers(e3), this._methodHead(e3);
  };
  var n2 = r2(0);
  const { isExportDefaultDeclaration: s2, isExportNamedDeclaration: i2 } = n2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrowFunctionExpression = function(e3, t3) {
    let r3;
    e3.async && (this.word("async", true), this.space()), this.format.retainLines || 1 !== e3.params.length || !s2(r3 = e3.params[0]) || function(e4, t4) {
      var r4, n3;
      return !!(e4.typeParameters || e4.returnType || e4.predicate || t4.typeAnnotation || t4.optional || null != (r4 = t4.leadingComments) && r4.length || null != (n3 = t4.trailingComments) && n3.length);
    }(e3, r3) ? this._params(e3, void 0, t3) : this.print(r3, e3, true), this._predicate(e3, true), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(e3.body, e3);
  }, t2.FunctionDeclaration = t2.FunctionExpression = function(e3, t3) {
    this._functionHead(e3, t3), this.space(), this.print(e3.body, e3);
  }, t2._functionHead = function(e3, t3) {
    e3.async && (this.word("async"), this._endsWithInnerRaw = false, this.space()), this.word("function"), e3.generator && (this._endsWithInnerRaw = false, this.tokenChar(42)), this.space(), e3.id && this.print(e3.id, e3), this._params(e3, e3.id, t3), "TSDeclareFunction" !== e3.type && this._predicate(e3);
  }, t2._methodHead = function(e3) {
    const t3 = e3.kind, r3 = e3.key;
    "get" !== t3 && "set" !== t3 || (this.word(t3), this.space()), e3.async && (this.word("async", true), this.space()), "method" !== t3 && "init" !== t3 || e3.generator && this.tokenChar(42), e3.computed ? (this.tokenChar(91), this.print(r3, e3), this.tokenChar(93)) : this.print(r3, e3), e3.optional && this.tokenChar(63), this._params(e3, e3.computed && "StringLiteral" !== e3.key.type ? void 0 : e3.key, void 0);
  }, t2._param = function(e3, t3) {
    this.printJoin(e3.decorators, e3), this.print(e3, t3), e3.optional && this.tokenChar(63), this.print(e3.typeAnnotation, e3);
  }, t2._parameters = function(e3, t3) {
    const r3 = e3.length;
    for (let n3 = 0; n3 < r3; n3++) this._param(e3[n3], t3), n3 < e3.length - 1 && (this.tokenChar(44), this.space());
  }, t2._params = function(e3, t3, r3) {
    this.print(e3.typeParameters, e3);
    const n3 = i2.call(this, t3, r3);
    n3 && this.sourceIdentifierName(n3.name, n3.pos), this.tokenChar(40), this._parameters(e3.params, e3), this.tokenChar(41);
    const s3 = "ArrowFunctionExpression" === e3.type;
    this.print(e3.returnType, e3, s3), this._noLineTerminator = s3;
  }, t2._predicate = function(e3, t3) {
    e3.predicate && (e3.returnType || this.tokenChar(58), this.space(), this.print(e3.predicate, e3, t3));
  };
  var n2 = r2(0);
  const { isIdentifier: s2 } = n2;
  function i2(e3, t3) {
    let r3, n3 = e3;
    if (!n3 && t3) {
      const e4 = t3.type;
      "VariableDeclarator" === e4 ? n3 = t3.id : "AssignmentExpression" === e4 || "AssignmentPattern" === e4 ? n3 = t3.left : "ObjectProperty" === e4 || "ClassProperty" === e4 ? t3.computed && "StringLiteral" !== t3.key.type || (n3 = t3.key) : "ClassPrivateProperty" !== e4 && "ClassAccessorProperty" !== e4 || (n3 = t3.key);
    }
    if (n3) {
      var s3, i3;
      if ("Identifier" === n3.type) r3 = { pos: null == (s3 = n3.loc) ? void 0 : s3.start, name: (null == (i3 = n3.loc) ? void 0 : i3.identifierName) || n3.name };
      else if ("PrivateName" === n3.type) {
        var o2;
        r3 = { pos: null == (o2 = n3.loc) ? void 0 : o2.start, name: "#" + n3.id.name };
      } else if ("StringLiteral" === n3.type) {
        var a2;
        r3 = { pos: null == (a2 = n3.loc) ? void 0 : a2.start, name: n3.value };
      }
      return r3;
    }
  }
}, (e2, t2, r2) => {
  r2(12), t2.byteLength = function(e3) {
    var t3 = l(e3), r3 = t3[0], n3 = t3[1];
    return 3 * (r3 + n3) / 4 - n3;
  }, t2.toByteArray = function(e3) {
    var t3, r3, n3 = l(e3), o3 = n3[0], a3 = n3[1], c2 = new i2(function(e4, t4, r4) {
      return 3 * (t4 + r4) / 4 - r4;
    }(0, o3, a3)), u = 0, p = a3 > 0 ? o3 - 4 : o3;
    for (r3 = 0; r3 < p; r3 += 4) t3 = s2[e3.charCodeAt(r3)] << 18 | s2[e3.charCodeAt(r3 + 1)] << 12 | s2[e3.charCodeAt(r3 + 2)] << 6 | s2[e3.charCodeAt(r3 + 3)], c2[u++] = t3 >> 16 & 255, c2[u++] = t3 >> 8 & 255, c2[u++] = 255 & t3;
    return 2 === a3 && (t3 = s2[e3.charCodeAt(r3)] << 2 | s2[e3.charCodeAt(r3 + 1)] >> 4, c2[u++] = 255 & t3), 1 === a3 && (t3 = s2[e3.charCodeAt(r3)] << 10 | s2[e3.charCodeAt(r3 + 1)] << 4 | s2[e3.charCodeAt(r3 + 2)] >> 2, c2[u++] = t3 >> 8 & 255, c2[u++] = 255 & t3), c2;
  }, t2.fromByteArray = function(e3) {
    for (var t3, r3 = e3.length, s3 = r3 % 3, i3 = [], o3 = 16383, a3 = 0, l2 = r3 - s3; a3 < l2; a3 += o3) i3.push(c(e3, a3, a3 + o3 > l2 ? l2 : a3 + o3));
    return 1 === s3 ? (t3 = e3[r3 - 1], i3.push(n2[t3 >> 2] + n2[t3 << 4 & 63] + "==")) : 2 === s3 && (t3 = (e3[r3 - 2] << 8) + e3[r3 - 1], i3.push(n2[t3 >> 10] + n2[t3 >> 4 & 63] + n2[t3 << 2 & 63] + "=")), i3.join("");
  };
  for (var n2 = [], s2 = [], i2 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a2 = 0; a2 < 64; ++a2) n2[a2] = o2[a2], s2[o2.charCodeAt(a2)] = a2;
  function l(e3) {
    var t3 = e3.length;
    if (t3 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var r3 = e3.indexOf("=");
    return -1 === r3 && (r3 = t3), [r3, r3 === t3 ? 0 : 4 - r3 % 4];
  }
  function c(e3, t3, r3) {
    for (var s3, i3, o3 = [], a3 = t3; a3 < r3; a3 += 3) s3 = (e3[a3] << 16 & 16711680) + (e3[a3 + 1] << 8 & 65280) + (255 & e3[a3 + 2]), o3.push(n2[(i3 = s3) >> 18 & 63] + n2[i3 >> 12 & 63] + n2[i3 >> 6 & 63] + n2[63 & i3]);
    return o3.join("");
  }
  s2["-".charCodeAt(0)] = 62, s2["_".charCodeAt(0)] = 63;
}, (e2, t2) => {
  t2.read = function(e3, t3, r2, n2, s2) {
    var i2, o2, a2 = 8 * s2 - n2 - 1, l = (1 << a2) - 1, c = l >> 1, u = -7, p = r2 ? s2 - 1 : 0, d = r2 ? -1 : 1, f = e3[t3 + p];
    for (p += d, i2 = f & (1 << -u) - 1, f >>= -u, u += a2; u > 0; i2 = 256 * i2 + e3[t3 + p], p += d, u -= 8) ;
    for (o2 = i2 & (1 << -u) - 1, i2 >>= -u, u += n2; u > 0; o2 = 256 * o2 + e3[t3 + p], p += d, u -= 8) ;
    if (0 === i2) i2 = 1 - c;
    else {
      if (i2 === l) return o2 ? NaN : 1 / 0 * (f ? -1 : 1);
      o2 += Math.pow(2, n2), i2 -= c;
    }
    return (f ? -1 : 1) * o2 * Math.pow(2, i2 - n2);
  }, t2.write = function(e3, t3, r2, n2, s2, i2) {
    var o2, a2, l, c = 8 * i2 - s2 - 1, u = (1 << c) - 1, p = u >> 1, d = 23 === s2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n2 ? 0 : i2 - 1, h = n2 ? 1 : -1, m = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
    for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a2 = isNaN(t3) ? 1 : 0, o2 = u) : (o2 = Math.floor(Math.log(t3) / Math.LN2), t3 * (l = Math.pow(2, -o2)) < 1 && (o2--, l *= 2), (t3 += o2 + p >= 1 ? d / l : d * Math.pow(2, 1 - p)) * l >= 2 && (o2++, l /= 2), o2 + p >= u ? (a2 = 0, o2 = u) : o2 + p >= 1 ? (a2 = (t3 * l - 1) * Math.pow(2, s2), o2 += p) : (a2 = t3 * Math.pow(2, p - 1) * Math.pow(2, s2), o2 = 0)); s2 >= 8; e3[r2 + f] = 255 & a2, f += h, a2 /= 256, s2 -= 8) ;
    for (o2 = o2 << s2 | a2, c += s2; c > 0; e3[r2 + f] = 255 & o2, f += h, o2 /= 256, c -= 8) ;
    e3[r2 + f - h] |= 128 * m;
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.AnyTypeAnnotation = function() {
    this.word("any");
  }, t2.ArrayTypeAnnotation = function(e3) {
    this.print(e3.elementType, e3, true), this.tokenChar(91), this.tokenChar(93);
  }, t2.BooleanLiteralTypeAnnotation = function(e3) {
    this.word(e3.value ? "true" : "false");
  }, t2.BooleanTypeAnnotation = function() {
    this.word("boolean");
  }, t2.DeclareClass = function(e3, t3) {
    o2(t3) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(e3);
  }, t2.DeclareExportAllDeclaration = function(e3) {
    this.word("declare"), this.space(), s2.ExportAllDeclaration.call(this, e3);
  }, t2.DeclareExportDeclaration = function(e3) {
    this.word("declare"), this.space(), this.word("export"), this.space(), e3.default && (this.word("default"), this.space()), p.call(this, e3);
  }, t2.DeclareFunction = function(e3, t3) {
    o2(t3) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(e3.id, e3), this.print(e3.id.typeAnnotation.typeAnnotation, e3), e3.predicate && (this.space(), this.print(e3.predicate, e3)), this.semicolon();
  }, t2.DeclareInterface = function(e3) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(e3);
  }, t2.DeclareModule = function(e3) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e3.id, e3), this.space(), this.print(e3.body, e3);
  }, t2.DeclareModuleExports = function(e3) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(e3.typeAnnotation, e3);
  }, t2.DeclareOpaqueType = function(e3, t3) {
    o2(t3) || (this.word("declare"), this.space()), this.OpaqueType(e3);
  }, t2.DeclareTypeAlias = function(e3) {
    this.word("declare"), this.space(), this.TypeAlias(e3);
  }, t2.DeclareVariable = function(e3, t3) {
    o2(t3) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(e3.id, e3), this.print(e3.id.typeAnnotation, e3), this.semicolon();
  }, t2.DeclaredPredicate = function(e3) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(e3.value, e3), this.tokenChar(41);
  }, t2.EmptyTypeAnnotation = function() {
    this.word("empty");
  }, t2.EnumBooleanBody = function(e3) {
    const { explicitType: t3 } = e3;
    l(this, "boolean", t3), c(this, e3);
  }, t2.EnumBooleanMember = function(e3) {
    u(this, e3);
  }, t2.EnumDeclaration = function(e3) {
    const { id: t3, body: r3 } = e3;
    this.word("enum"), this.space(), this.print(t3, e3), this.print(r3, e3);
  }, t2.EnumDefaultedMember = function(e3) {
    const { id: t3 } = e3;
    this.print(t3, e3), this.tokenChar(44);
  }, t2.EnumNumberBody = function(e3) {
    const { explicitType: t3 } = e3;
    l(this, "number", t3), c(this, e3);
  }, t2.EnumNumberMember = function(e3) {
    u(this, e3);
  }, t2.EnumStringBody = function(e3) {
    const { explicitType: t3 } = e3;
    l(this, "string", t3), c(this, e3);
  }, t2.EnumStringMember = function(e3) {
    u(this, e3);
  }, t2.EnumSymbolBody = function(e3) {
    l(this, "symbol", true), c(this, e3);
  }, t2.ExistsTypeAnnotation = function() {
    this.tokenChar(42);
  }, t2.FunctionTypeAnnotation = function(e3, t3) {
    this.print(e3.typeParameters, e3), this.tokenChar(40), e3.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(e3.this.typeAnnotation, e3), (e3.params.length || e3.rest) && (this.tokenChar(44), this.space())), this.printList(e3.params, e3), e3.rest && (e3.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(e3.rest, e3)), this.tokenChar(41);
    const r3 = null == t3 ? void 0 : t3.type;
    null != r3 && ("ObjectTypeCallProperty" === r3 || "ObjectTypeInternalSlot" === r3 || "DeclareFunction" === r3 || "ObjectTypeProperty" === r3 && t3.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(e3.returnType, e3);
  }, t2.FunctionTypeParam = function(e3) {
    this.print(e3.name, e3), e3.optional && this.tokenChar(63), e3.name && (this.tokenChar(58), this.space()), this.print(e3.typeAnnotation, e3);
  }, t2.IndexedAccessType = function(e3) {
    this.print(e3.objectType, e3, true), this.tokenChar(91), this.print(e3.indexType, e3), this.tokenChar(93);
  }, t2.InferredPredicate = function() {
    this.tokenChar(37), this.word("checks");
  }, t2.InterfaceDeclaration = function(e3) {
    this.word("interface"), this.space(), this._interfaceish(e3);
  }, t2.GenericTypeAnnotation = t2.ClassImplements = t2.InterfaceExtends = function(e3) {
    this.print(e3.id, e3), this.print(e3.typeParameters, e3, true);
  }, t2.InterfaceTypeAnnotation = function(e3) {
    var t3;
    this.word("interface"), null != (t3 = e3.extends) && t3.length && (this.space(), this.word("extends"), this.space(), this.printList(e3.extends, e3)), this.space(), this.print(e3.body, e3);
  }, t2.IntersectionTypeAnnotation = function(e3) {
    this.printJoin(e3.types, e3, { separator: d });
  }, t2.MixedTypeAnnotation = function() {
    this.word("mixed");
  }, t2.NullLiteralTypeAnnotation = function() {
    this.word("null");
  }, t2.NullableTypeAnnotation = function(e3) {
    this.tokenChar(63), this.print(e3.typeAnnotation, e3);
  }, Object.defineProperty(t2, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
    return i2.NumericLiteral;
  } }), t2.NumberTypeAnnotation = function() {
    this.word("number");
  }, t2.ObjectTypeAnnotation = function(e3) {
    e3.exact ? this.token("{|") : this.tokenChar(123);
    const t3 = [...e3.properties, ...e3.callProperties || [], ...e3.indexers || [], ...e3.internalSlots || []];
    t3.length && (this.newline(), this.space(), this.printJoin(t3, e3, { addNewlines(e4) {
      if (e4 && !t3[0]) return 1;
    }, indent: true, statement: true, iterator: () => {
      (1 !== t3.length || e3.inexact) && (this.tokenChar(44), this.space());
    } }), this.space()), e3.inexact && (this.indent(), this.token("..."), t3.length && this.newline(), this.dedent()), e3.exact ? this.token("|}") : this.tokenChar(125);
  }, t2.ObjectTypeCallProperty = function(e3) {
    e3.static && (this.word("static"), this.space()), this.print(e3.value, e3);
  }, t2.ObjectTypeIndexer = function(e3) {
    e3.static && (this.word("static"), this.space()), this._variance(e3), this.tokenChar(91), e3.id && (this.print(e3.id, e3), this.tokenChar(58), this.space()), this.print(e3.key, e3), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(e3.value, e3);
  }, t2.ObjectTypeInternalSlot = function(e3) {
    e3.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(e3.id, e3), this.tokenChar(93), this.tokenChar(93), e3.optional && this.tokenChar(63), e3.method || (this.tokenChar(58), this.space()), this.print(e3.value, e3);
  }, t2.ObjectTypeProperty = function(e3) {
    e3.proto && (this.word("proto"), this.space()), e3.static && (this.word("static"), this.space()), "get" !== e3.kind && "set" !== e3.kind || (this.word(e3.kind), this.space()), this._variance(e3), this.print(e3.key, e3), e3.optional && this.tokenChar(63), e3.method || (this.tokenChar(58), this.space()), this.print(e3.value, e3);
  }, t2.ObjectTypeSpreadProperty = function(e3) {
    this.token("..."), this.print(e3.argument, e3);
  }, t2.OpaqueType = function(e3) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e3.id, e3), this.print(e3.typeParameters, e3), e3.supertype && (this.tokenChar(58), this.space(), this.print(e3.supertype, e3)), e3.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(e3.impltype, e3)), this.semicolon();
  }, t2.OptionalIndexedAccessType = function(e3) {
    this.print(e3.objectType, e3), e3.optional && this.token("?."), this.tokenChar(91), this.print(e3.indexType, e3), this.tokenChar(93);
  }, t2.QualifiedTypeIdentifier = function(e3) {
    this.print(e3.qualification, e3), this.tokenChar(46), this.print(e3.id, e3);
  }, Object.defineProperty(t2, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
    return i2.StringLiteral;
  } }), t2.StringTypeAnnotation = function() {
    this.word("string");
  }, t2.SymbolTypeAnnotation = function() {
    this.word("symbol");
  }, t2.ThisTypeAnnotation = function() {
    this.word("this");
  }, t2.TupleTypeAnnotation = function(e3) {
    this.tokenChar(91), this.printList(e3.types, e3), this.tokenChar(93);
  }, t2.TypeAlias = function(e3) {
    this.word("type"), this.space(), this.print(e3.id, e3), this.print(e3.typeParameters, e3), this.space(), this.tokenChar(61), this.space(), this.print(e3.right, e3), this.semicolon();
  }, t2.TypeAnnotation = function(e3) {
    this.tokenChar(58), this.space(), e3.optional && this.tokenChar(63), this.print(e3.typeAnnotation, e3);
  }, t2.TypeCastExpression = function(e3) {
    this.tokenChar(40), this.print(e3.expression, e3), this.print(e3.typeAnnotation, e3), this.tokenChar(41);
  }, t2.TypeParameter = function(e3) {
    this._variance(e3), this.word(e3.name), e3.bound && this.print(e3.bound, e3), e3.default && (this.space(), this.tokenChar(61), this.space(), this.print(e3.default, e3));
  }, t2.TypeParameterDeclaration = t2.TypeParameterInstantiation = function(e3) {
    this.tokenChar(60), this.printList(e3.params, e3, {}), this.tokenChar(62);
  }, t2.TypeofTypeAnnotation = function(e3) {
    this.word("typeof"), this.space(), this.print(e3.argument, e3);
  }, t2.UnionTypeAnnotation = function(e3) {
    this.printJoin(e3.types, e3, { separator: f });
  }, t2.Variance = function(e3) {
    "plus" === e3.kind ? this.tokenChar(43) : this.tokenChar(45);
  }, t2.VoidTypeAnnotation = function() {
    this.word("void");
  }, t2._interfaceish = function(e3) {
    var t3, r3, n3;
    (this.print(e3.id, e3), this.print(e3.typeParameters, e3), null != (t3 = e3.extends) && t3.length && (this.space(), this.word("extends"), this.space(), this.printList(e3.extends, e3)), "DeclareClass" === e3.type) && (null != (r3 = e3.mixins) && r3.length && (this.space(), this.word("mixins"), this.space(), this.printList(e3.mixins, e3)), null != (n3 = e3.implements) && n3.length && (this.space(), this.word("implements"), this.space(), this.printList(e3.implements, e3)));
    this.space(), this.print(e3.body, e3);
  }, t2._variance = function(e3) {
    var t3;
    const r3 = null == (t3 = e3.variance) ? void 0 : t3.kind;
    null != r3 && ("plus" === r3 ? this.tokenChar(43) : "minus" === r3 && this.tokenChar(45));
  };
  var n2 = r2(0), s2 = r2(185), i2 = r2(186);
  const { isDeclareExportDeclaration: o2, isStatement: a2 } = n2;
  function l(e3, t3, r3) {
    r3 && (e3.space(), e3.word("of"), e3.space(), e3.word(t3)), e3.space();
  }
  function c(e3, t3) {
    const { members: r3 } = t3;
    e3.token("{"), e3.indent(), e3.newline();
    for (const n3 of r3) e3.print(n3, t3), e3.newline();
    t3.hasUnknownMembers && (e3.token("..."), e3.newline()), e3.dedent(), e3.token("}");
  }
  function u(e3, t3) {
    const { id: r3, init: n3 } = t3;
    e3.print(r3, t3), e3.space(), e3.token("="), e3.space(), e3.print(n3, t3), e3.token(",");
  }
  function p(e3) {
    if (e3.declaration) {
      const t3 = e3.declaration;
      this.print(t3, e3), a2(t3) || this.semicolon();
    } else this.tokenChar(123), e3.specifiers.length && (this.space(), this.printList(e3.specifiers, e3), this.space()), this.tokenChar(125), e3.source && (this.space(), this.word("from"), this.space(), this.print(e3.source, e3)), this.semicolon();
  }
  function d() {
    this.space(), this.tokenChar(38), this.space();
  }
  function f() {
    this.space(), this.tokenChar(124), this.space();
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.BlockStatement = function(e3) {
    var t3;
    this.tokenChar(123);
    const r3 = null == (t3 = e3.directives) ? void 0 : t3.length;
    if (r3) {
      var n3;
      const t4 = e3.body.length ? 2 : 1;
      this.printSequence(e3.directives, e3, { indent: true, trailingCommentsLineOffset: t4 }), null != (n3 = e3.directives[r3 - 1].trailingComments) && n3.length || this.newline(t4);
    }
    this.printSequence(e3.body, e3, { indent: true }), this.rightBrace(e3);
  }, t2.Directive = function(e3) {
    this.print(e3.value, e3), this.semicolon();
  }, t2.DirectiveLiteral = function(e3) {
    const t3 = this.getPossibleRaw(e3);
    if (!this.format.minified && void 0 !== t3) return void this.token(t3);
    const { value: s2 } = e3;
    if (n2.test(s2)) {
      if (r2.test(s2)) throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
      this.token(`'${s2}'`);
    } else this.token(`"${s2}"`);
  }, t2.File = function(e3) {
    e3.program && this.print(e3.program.interpreter, e3), this.print(e3.program, e3);
  }, t2.InterpreterDirective = function(e3) {
    this.token(`#!${e3.value}`), this.newline(1, true);
  }, t2.Placeholder = function(e3) {
    this.token("%%"), this.print(e3.name), this.token("%%"), "Statement" === e3.expectedNode && this.semicolon();
  }, t2.Program = function(e3) {
    var t3;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    const r3 = null == (t3 = e3.directives) ? void 0 : t3.length;
    if (r3) {
      var n3;
      const t4 = e3.body.length ? 2 : 1;
      this.printSequence(e3.directives, e3, { trailingCommentsLineOffset: t4 }), null != (n3 = e3.directives[r3 - 1].trailingComments) && n3.length || this.newline(t4);
    }
    this.printSequence(e3.body, e3);
  };
  const r2 = /(?:^|[^\\])(?:\\\\)*'/, n2 = /(?:^|[^\\])(?:\\\\)*"/;
}, (e2, t2) => {
  function r2() {
    this.space();
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.JSXAttribute = function(e3) {
    this.print(e3.name, e3), e3.value && (this.tokenChar(61), this.print(e3.value, e3));
  }, t2.JSXClosingElement = function(e3) {
    this.token("</"), this.print(e3.name, e3), this.tokenChar(62);
  }, t2.JSXClosingFragment = function() {
    this.token("</"), this.tokenChar(62);
  }, t2.JSXElement = function(e3) {
    const t3 = e3.openingElement;
    if (this.print(t3, e3), !t3.selfClosing) {
      this.indent();
      for (const t4 of e3.children) this.print(t4, e3);
      this.dedent(), this.print(e3.closingElement, e3);
    }
  }, t2.JSXEmptyExpression = function() {
    this.printInnerComments();
  }, t2.JSXExpressionContainer = function(e3) {
    this.tokenChar(123), this.print(e3.expression, e3), this.tokenChar(125);
  }, t2.JSXFragment = function(e3) {
    this.print(e3.openingFragment, e3), this.indent();
    for (const t3 of e3.children) this.print(t3, e3);
    this.dedent(), this.print(e3.closingFragment, e3);
  }, t2.JSXIdentifier = function(e3) {
    this.word(e3.name);
  }, t2.JSXMemberExpression = function(e3) {
    this.print(e3.object, e3), this.tokenChar(46), this.print(e3.property, e3);
  }, t2.JSXNamespacedName = function(e3) {
    this.print(e3.namespace, e3), this.tokenChar(58), this.print(e3.name, e3);
  }, t2.JSXOpeningElement = function(e3) {
    this.tokenChar(60), this.print(e3.name, e3), this.print(e3.typeParameters, e3), e3.attributes.length > 0 && (this.space(), this.printJoin(e3.attributes, e3, { separator: r2 })), e3.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
  }, t2.JSXOpeningFragment = function() {
    this.tokenChar(60), this.tokenChar(62);
  }, t2.JSXSpreadAttribute = function(e3) {
    this.tokenChar(123), this.token("..."), this.print(e3.argument, e3), this.tokenChar(125);
  }, t2.JSXSpreadChild = function(e3) {
    this.tokenChar(123), this.token("..."), this.print(e3.expression, e3), this.tokenChar(125);
  }, t2.JSXText = function(e3) {
    const t3 = this.getPossibleRaw(e3);
    void 0 !== t3 ? this.token(t3, true) : this.token(e3.value, true);
  };
}, (e2, t2) => {
  function r2(e3, t3, r3) {
    if (e3.token("{"), t3.length) {
      e3.indent(), e3.newline();
      for (const n3 of t3) e3.print(n3, r3), e3.newline();
      e3.dedent();
    }
    e3.rightBrace(r3);
  }
  function n2(e3, t3, r3) {
    e3.printJoin(t3.types, t3, { separator() {
      this.space(), this.token(r3), this.space();
    } });
  }
  function s2(e3, t3) {
    true !== t3 && e3.token(t3);
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.TSAnyKeyword = function() {
    this.word("any");
  }, t2.TSArrayType = function(e3) {
    this.print(e3.elementType, e3, true), this.token("[]");
  }, t2.TSSatisfiesExpression = t2.TSAsExpression = function(e3) {
    var t3;
    const { type: r3, expression: n3, typeAnnotation: s3 } = e3, i2 = !(null == (t3 = n3.trailingComments) || !t3.length);
    this.print(n3, e3, true, void 0, i2), this.space(), this.word("TSAsExpression" === r3 ? "as" : "satisfies"), this.space(), this.print(s3, e3);
  }, t2.TSBigIntKeyword = function() {
    this.word("bigint");
  }, t2.TSBooleanKeyword = function() {
    this.word("boolean");
  }, t2.TSCallSignatureDeclaration = function(e3) {
    this.tsPrintSignatureDeclarationBase(e3), this.tokenChar(59);
  }, t2.TSConditionalType = function(e3) {
    this.print(e3.checkType), this.space(), this.word("extends"), this.space(), this.print(e3.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(e3.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e3.falseType);
  }, t2.TSConstructSignatureDeclaration = function(e3) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e3), this.tokenChar(59);
  }, t2.TSConstructorType = function(e3) {
    e3.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e3);
  }, t2.TSDeclareFunction = function(e3, t3) {
    e3.declare && (this.word("declare"), this.space()), this._functionHead(e3, t3), this.tokenChar(59);
  }, t2.TSDeclareMethod = function(e3) {
    this._classMethodHead(e3), this.tokenChar(59);
  }, t2.TSEnumDeclaration = function(e3) {
    const { declare: t3, const: n3, id: s3, members: i2 } = e3;
    t3 && (this.word("declare"), this.space()), n3 && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(s3, e3), this.space(), r2(this, i2, e3);
  }, t2.TSEnumMember = function(e3) {
    const { id: t3, initializer: r3 } = e3;
    this.print(t3, e3), r3 && (this.space(), this.tokenChar(61), this.space(), this.print(r3, e3)), this.tokenChar(44);
  }, t2.TSExportAssignment = function(e3) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e3.expression, e3), this.tokenChar(59);
  }, t2.TSExpressionWithTypeArguments = function(e3) {
    this.print(e3.expression, e3), this.print(e3.typeParameters, e3);
  }, t2.TSExternalModuleReference = function(e3) {
    this.token("require("), this.print(e3.expression, e3), this.tokenChar(41);
  }, t2.TSFunctionType = function(e3) {
    this.tsPrintFunctionOrConstructorType(e3);
  }, t2.TSImportEqualsDeclaration = function(e3) {
    const { isExport: t3, id: r3, moduleReference: n3 } = e3;
    t3 && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r3, e3), this.space(), this.tokenChar(61), this.space(), this.print(n3, e3), this.tokenChar(59);
  }, t2.TSImportType = function(e3) {
    const { argument: t3, qualifier: r3, typeParameters: n3 } = e3;
    this.word("import"), this.tokenChar(40), this.print(t3, e3), this.tokenChar(41), r3 && (this.tokenChar(46), this.print(r3, e3)), n3 && this.print(n3, e3);
  }, t2.TSIndexSignature = function(e3) {
    const { readonly: t3, static: r3 } = e3;
    r3 && (this.word("static"), this.space()), t3 && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e3.parameters, e3), this.tokenChar(93), this.print(e3.typeAnnotation, e3), this.tokenChar(59);
  }, t2.TSIndexedAccessType = function(e3) {
    this.print(e3.objectType, e3, true), this.tokenChar(91), this.print(e3.indexType, e3), this.tokenChar(93);
  }, t2.TSInferType = function(e3) {
    this.token("infer"), this.space(), this.print(e3.typeParameter);
  }, t2.TSInstantiationExpression = function(e3) {
    this.print(e3.expression, e3), this.print(e3.typeParameters, e3);
  }, t2.TSInterfaceBody = function(e3) {
    this.tsPrintTypeLiteralOrInterfaceBody(e3.body, e3);
  }, t2.TSInterfaceDeclaration = function(e3) {
    const { declare: t3, id: r3, typeParameters: n3, extends: s3, body: i2 } = e3;
    t3 && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r3, e3), this.print(n3, e3), null != s3 && s3.length && (this.space(), this.word("extends"), this.space(), this.printList(s3, e3)), this.space(), this.print(i2, e3);
  }, t2.TSIntersectionType = function(e3) {
    n2(this, e3, "&");
  }, t2.TSIntrinsicKeyword = function() {
    this.word("intrinsic");
  }, t2.TSLiteralType = function(e3) {
    this.print(e3.literal, e3);
  }, t2.TSMappedType = function(e3) {
    const { nameType: t3, optional: r3, readonly: n3, typeParameter: i2 } = e3;
    this.tokenChar(123), this.space(), n3 && (s2(this, n3), this.word("readonly"), this.space()), this.tokenChar(91), this.word(i2.name), this.space(), this.word("in"), this.space(), this.print(i2.constraint, i2), t3 && (this.space(), this.word("as"), this.space(), this.print(t3, e3)), this.tokenChar(93), r3 && (s2(this, r3), this.tokenChar(63)), this.tokenChar(58), this.space(), this.print(e3.typeAnnotation, e3), this.space(), this.tokenChar(125);
  }, t2.TSMethodSignature = function(e3) {
    const { kind: t3 } = e3;
    "set" !== t3 && "get" !== t3 || (this.word(t3), this.space()), this.tsPrintPropertyOrMethodName(e3), this.tsPrintSignatureDeclarationBase(e3), this.tokenChar(59);
  }, t2.TSModuleBlock = function(e3) {
    r2(this, e3.body, e3);
  }, t2.TSModuleDeclaration = function(e3) {
    const { declare: t3, id: r3 } = e3;
    if (t3 && (this.word("declare"), this.space()), e3.global || (this.word("Identifier" === r3.type ? "namespace" : "module"), this.space()), this.print(r3, e3), !e3.body) return void this.tokenChar(59);
    let n3 = e3.body;
    for (; "TSModuleDeclaration" === n3.type; ) this.tokenChar(46), this.print(n3.id, n3), n3 = n3.body;
    this.space(), this.print(n3, e3);
  }, t2.TSNamedTupleMember = function(e3) {
    this.print(e3.label, e3), e3.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e3.elementType, e3);
  }, t2.TSNamespaceExportDeclaration = function(e3) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e3.id, e3);
  }, t2.TSNeverKeyword = function() {
    this.word("never");
  }, t2.TSNonNullExpression = function(e3) {
    this.print(e3.expression, e3), this.tokenChar(33);
  }, t2.TSNullKeyword = function() {
    this.word("null");
  }, t2.TSNumberKeyword = function() {
    this.word("number");
  }, t2.TSObjectKeyword = function() {
    this.word("object");
  }, t2.TSOptionalType = function(e3) {
    this.print(e3.typeAnnotation, e3), this.tokenChar(63);
  }, t2.TSParameterProperty = function(e3) {
    e3.accessibility && (this.word(e3.accessibility), this.space()), e3.readonly && (this.word("readonly"), this.space()), this._param(e3.parameter);
  }, t2.TSParenthesizedType = function(e3) {
    this.tokenChar(40), this.print(e3.typeAnnotation, e3), this.tokenChar(41);
  }, t2.TSPropertySignature = function(e3) {
    const { readonly: t3 } = e3;
    t3 && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e3), this.print(e3.typeAnnotation, e3), this.tokenChar(59);
  }, t2.TSQualifiedName = function(e3) {
    this.print(e3.left, e3), this.tokenChar(46), this.print(e3.right, e3);
  }, t2.TSRestType = function(e3) {
    this.token("..."), this.print(e3.typeAnnotation, e3);
  }, t2.TSStringKeyword = function() {
    this.word("string");
  }, t2.TSSymbolKeyword = function() {
    this.word("symbol");
  }, t2.TSThisType = function() {
    this.word("this");
  }, t2.TSTupleType = function(e3) {
    this.tokenChar(91), this.printList(e3.elementTypes, e3), this.tokenChar(93);
  }, t2.TSTypeAliasDeclaration = function(e3) {
    const { declare: t3, id: r3, typeParameters: n3, typeAnnotation: s3 } = e3;
    t3 && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r3, e3), this.print(n3, e3), this.space(), this.tokenChar(61), this.space(), this.print(s3, e3), this.tokenChar(59);
  }, t2.TSTypeAnnotation = function(e3) {
    this.tokenChar(58), this.space(), e3.optional && this.tokenChar(63), this.print(e3.typeAnnotation, e3);
  }, t2.TSTypeAssertion = function(e3) {
    const { typeAnnotation: t3, expression: r3 } = e3;
    this.tokenChar(60), this.print(t3, e3), this.tokenChar(62), this.space(), this.print(r3, e3);
  }, t2.TSTypeLiteral = function(e3) {
    this.tsPrintTypeLiteralOrInterfaceBody(e3.members, e3);
  }, t2.TSTypeOperator = function(e3) {
    this.word(e3.operator), this.space(), this.print(e3.typeAnnotation, e3);
  }, t2.TSTypeParameter = function(e3) {
    e3.in && (this.word("in"), this.space()), e3.out && (this.word("out"), this.space()), this.word(e3.name), e3.constraint && (this.space(), this.word("extends"), this.space(), this.print(e3.constraint, e3)), e3.default && (this.space(), this.tokenChar(61), this.space(), this.print(e3.default, e3));
  }, t2.TSTypeParameterDeclaration = t2.TSTypeParameterInstantiation = function(e3, t3) {
    this.tokenChar(60), this.printList(e3.params, e3, {}), "ArrowFunctionExpression" === t3.type && 1 === e3.params.length && this.tokenChar(44), this.tokenChar(62);
  }, t2.TSTypePredicate = function(e3) {
    e3.asserts && (this.word("asserts"), this.space()), this.print(e3.parameterName), e3.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(e3.typeAnnotation.typeAnnotation));
  }, t2.TSTypeQuery = function(e3) {
    this.word("typeof"), this.space(), this.print(e3.exprName), e3.typeParameters && this.print(e3.typeParameters, e3);
  }, t2.TSTypeReference = function(e3) {
    this.print(e3.typeName, e3, true), this.print(e3.typeParameters, e3, true);
  }, t2.TSUndefinedKeyword = function() {
    this.word("undefined");
  }, t2.TSUnionType = function(e3) {
    n2(this, e3, "|");
  }, t2.TSUnknownKeyword = function() {
    this.word("unknown");
  }, t2.TSVoidKeyword = function() {
    this.word("void");
  }, t2.tsPrintClassMemberModifiers = function(e3) {
    const t3 = "ClassAccessorProperty" === e3.type || "ClassProperty" === e3.type;
    t3 && e3.declare && (this.word("declare"), this.space()), e3.accessibility && (this.word(e3.accessibility), this.space()), e3.static && (this.word("static"), this.space()), e3.override && (this.word("override"), this.space()), e3.abstract && (this.word("abstract"), this.space()), t3 && e3.readonly && (this.word("readonly"), this.space());
  }, t2.tsPrintFunctionOrConstructorType = function(e3) {
    const { typeParameters: t3 } = e3, r3 = e3.parameters;
    this.print(t3, e3), this.tokenChar(40), this._parameters(r3, e3), this.tokenChar(41), this.space(), this.token("=>"), this.space();
    const n3 = e3.typeAnnotation;
    this.print(n3.typeAnnotation, e3);
  }, t2.tsPrintPropertyOrMethodName = function(e3) {
    e3.computed && this.tokenChar(91), this.print(e3.key, e3), e3.computed && this.tokenChar(93), e3.optional && this.tokenChar(63);
  }, t2.tsPrintSignatureDeclarationBase = function(e3) {
    const { typeParameters: t3 } = e3, r3 = e3.parameters;
    this.print(t3, e3), this.tokenChar(40), this._parameters(r3, e3), this.tokenChar(41);
    const n3 = e3.typeAnnotation;
    this.print(n3, e3);
  }, t2.tsPrintTypeLiteralOrInterfaceBody = function(e3, t3) {
    r2(this, e3, t3);
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.find = function(e3) {
    let t3 = this;
    do {
      if (e3(t3)) return t3;
    } while (t3 = t3.parentPath);
    return null;
  }, t2.findParent = function(e3) {
    let t3 = this;
    for (; t3 = t3.parentPath; ) if (e3(t3)) return t3;
    return null;
  }, t2.getAncestry = function() {
    let e3 = this;
    const t3 = [];
    do {
      t3.push(e3);
    } while (e3 = e3.parentPath);
    return t3;
  }, t2.getDeepestCommonAncestorFrom = function(e3, t3) {
    if (!e3.length) return this;
    if (1 === e3.length) return e3[0];
    let r3, n3, s3 = 1 / 0;
    const i2 = e3.map((e4) => {
      const t4 = [];
      do {
        t4.unshift(e4);
      } while ((e4 = e4.parentPath) && e4 !== this);
      return t4.length < s3 && (s3 = t4.length), t4;
    }), o2 = i2[0];
    e: for (let e4 = 0; e4 < s3; e4++) {
      const t4 = o2[e4];
      for (const r4 of i2) if (r4[e4] !== t4) break e;
      r3 = e4, n3 = t4;
    }
    if (n3) return t3 ? t3(n3, r3, i2) : n3;
    throw new Error("Couldn't find intersection");
  }, t2.getEarliestCommonAncestorFrom = function(e3) {
    return this.getDeepestCommonAncestorFrom(e3, function(e4, t3, r3) {
      let n3;
      const i2 = s2[e4.type];
      for (const e5 of r3) {
        const r4 = e5[t3 + 1];
        n3 ? (r4.listKey && n3.listKey === r4.listKey && r4.key < n3.key || i2.indexOf(n3.parentKey) > i2.indexOf(r4.parentKey)) && (n3 = r4) : n3 = r4;
      }
      return n3;
    });
  }, t2.getFunctionParent = function() {
    return this.findParent((e3) => e3.isFunction());
  }, t2.getStatementParent = function() {
    let e3 = this;
    do {
      if (!e3.parentPath || Array.isArray(e3.container) && e3.isStatement()) break;
      e3 = e3.parentPath;
    } while (e3);
    if (e3 && (e3.isProgram() || e3.isFile())) throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return e3;
  }, t2.inType = function() {
    let e3 = this;
    for (var t3 = arguments.length, r3 = new Array(t3), n3 = 0; n3 < t3; n3++) r3[n3] = arguments[n3];
    for (; e3; ) {
      for (const t4 of r3) if (e3.node.type === t4) return true;
      e3 = e3.parentPath;
    }
    return false;
  }, t2.isAncestor = function(e3) {
    return e3.isDescendant(this);
  }, t2.isDescendant = function(e3) {
    return !!this.findParent((t3) => t3 === e3);
  };
  var n2 = r2(0);
  const { VISITOR_KEYS: s2 } = n2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._getTypeAnnotation = function() {
    const e3 = this.node;
    if (e3) {
      if (e3.typeAnnotation) return e3.typeAnnotation;
      if (!P.has(e3)) {
        P.add(e3);
        try {
          var t3;
          let r3 = n2[e3.type];
          if (r3) return r3.call(this, e3);
          if (r3 = n2[this.parentPath.type], null != (t3 = r3) && t3.validParent) return this.parentPath.getTypeAnnotation();
        } finally {
          P.delete(e3);
        }
      }
    } else if ("init" === this.key && this.parentPath.isVariableDeclarator()) {
      const e4 = this.parentPath.parentPath, t4 = e4.parentPath;
      return "left" === e4.key && t4.isForInStatement() ? T() : "left" === e4.key && t4.isForOfStatement() ? i2() : w();
    }
  }, t2.baseTypeStrictlyMatches = function(e3) {
    const t3 = this.getTypeAnnotation(), r3 = e3.getTypeAnnotation();
    return !(o2(t3) || !u(t3)) && r3.type === t3.type;
  }, t2.couldBeBaseType = function(e3) {
    const t3 = this.getTypeAnnotation();
    if (o2(t3)) return true;
    if (S(t3)) {
      for (const r3 of t3.types) if (o2(r3) || A(e3, r3, true)) return true;
      return false;
    }
    return A(e3, t3, true);
  }, t2.getTypeAnnotation = function() {
    let e3 = this.getData("typeAnnotation");
    return null != e3 || (e3 = this._getTypeAnnotation() || i2(), (E(e3) || g(e3)) && (e3 = e3.typeAnnotation), this.setData("typeAnnotation", e3)), e3;
  }, t2.isBaseType = function(e3, t3) {
    return A(e3, this.getTypeAnnotation(), t3);
  }, t2.isGenericType = function(e3) {
    const t3 = this.getTypeAnnotation();
    return !("Array" !== e3 || !(y(t3) || a2(t3) || v(t3))) || (p(t3) && d(t3.id, { name: e3 }) || b(t3) && d(t3.typeName, { name: e3 }));
  };
  var n2 = r2(425), s2 = r2(0);
  const { anyTypeAnnotation: i2, isAnyTypeAnnotation: o2, isArrayTypeAnnotation: a2, isBooleanTypeAnnotation: l, isEmptyTypeAnnotation: c, isFlowBaseAnnotation: u, isGenericTypeAnnotation: p, isIdentifier: d, isMixedTypeAnnotation: f, isNumberTypeAnnotation: h, isStringTypeAnnotation: m, isTSArrayType: y, isTSTypeAnnotation: g, isTSTypeReference: b, isTupleTypeAnnotation: v, isTypeAnnotation: E, isUnionTypeAnnotation: S, isVoidTypeAnnotation: x, stringTypeAnnotation: T, voidTypeAnnotation: w } = s2, P = /* @__PURE__ */ new WeakSet();
  function A(e3, t3, r3) {
    if ("string" === e3) return m(t3);
    if ("number" === e3) return h(t3);
    if ("boolean" === e3) return l(t3);
    if ("any" === e3) return o2(t3);
    if ("mixed" === e3) return f(t3);
    if ("empty" === e3) return c(t3);
    if ("void" === e3) return x(t3);
    if (r3) return false;
    throw new Error(`Unknown base type ${e3}`);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrayExpression = A, t2.AssignmentExpression = function() {
    return this.get("right").getTypeAnnotation();
  }, t2.BinaryExpression = function(e3) {
    const t3 = e3.operator;
    if (l.indexOf(t3) >= 0) return b();
    if (o2.indexOf(t3) >= 0) return f();
    if ("+" === t3) {
      const e4 = this.get("right"), t4 = this.get("left");
      return t4.isBaseType("number") && e4.isBaseType("number") ? b() : t4.isBaseType("string") || e4.isBaseType("string") ? v() : S([v(), b()]);
    }
  }, t2.BooleanLiteral = function() {
    return f();
  }, t2.CallExpression = function() {
    const { callee: e3 } = this.node;
    return I(e3) ? d(v()) : O(e3) || _(e3) || T(e3, { name: "Array" }) ? d(p()) : k(e3) ? d(E([v(), p()])) : N(this.get("callee"));
  }, t2.ConditionalExpression = function() {
    const e3 = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, i2.createUnionType)(e3);
  }, t2.ClassDeclaration = t2.ClassExpression = t2.FunctionDeclaration = t2.ArrowFunctionExpression = t2.FunctionExpression = function() {
    return m(y("Function"));
  }, Object.defineProperty(t2, "Identifier", { enumerable: true, get: function() {
    return s2.default;
  } }), t2.LogicalExpression = function() {
    const e3 = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, i2.createUnionType)(e3);
  }, t2.NewExpression = function(e3) {
    if ("Identifier" === e3.callee.type) return m(e3.callee);
  }, t2.NullLiteral = function() {
    return g();
  }, t2.NumericLiteral = function() {
    return b();
  }, t2.ObjectExpression = function() {
    return m(y("Object"));
  }, t2.ParenthesizedExpression = function() {
    return this.get("expression").getTypeAnnotation();
  }, t2.RegExpLiteral = function() {
    return m(y("RegExp"));
  }, t2.RestElement = C, t2.SequenceExpression = function() {
    return this.get("expressions").pop().getTypeAnnotation();
  }, t2.StringLiteral = function() {
    return v();
  }, t2.TSAsExpression = P, t2.TSNonNullExpression = function() {
    return this.get("expression").getTypeAnnotation();
  }, t2.TaggedTemplateExpression = function() {
    return N(this.get("tag"));
  }, t2.TemplateLiteral = function() {
    return v();
  }, t2.TypeCastExpression = w, t2.UnaryExpression = function(e3) {
    const t3 = e3.operator;
    return "void" === t3 ? x() : c.indexOf(t3) >= 0 ? b() : u.indexOf(t3) >= 0 ? v() : a2.indexOf(t3) >= 0 ? f() : void 0;
  }, t2.UpdateExpression = function(e3) {
    const t3 = e3.operator;
    if ("++" === t3 || "--" === t3) return b();
  }, t2.VariableDeclarator = function() {
    if (this.get("id").isIdentifier()) return this.get("init").getTypeAnnotation();
  };
  var n2 = r2(0), s2 = r2(426), i2 = r2(223);
  const { BOOLEAN_BINARY_OPERATORS: o2, BOOLEAN_UNARY_OPERATORS: a2, NUMBER_BINARY_OPERATORS: l, NUMBER_UNARY_OPERATORS: c, STRING_UNARY_OPERATORS: u, anyTypeAnnotation: p, arrayTypeAnnotation: d, booleanTypeAnnotation: f, buildMatchMemberExpression: h, genericTypeAnnotation: m, identifier: y, nullLiteralTypeAnnotation: g, numberTypeAnnotation: b, stringTypeAnnotation: v, tupleTypeAnnotation: E, unionTypeAnnotation: S, voidTypeAnnotation: x, isIdentifier: T } = n2;
  function w(e3) {
    return e3.typeAnnotation;
  }
  function P(e3) {
    return e3.typeAnnotation;
  }
  function A() {
    return m(y("Array"));
  }
  function C() {
    return A();
  }
  w.validParent = true, P.validParent = true, C.validParent = true;
  const O = h("Array.from"), I = h("Object.keys"), _ = h("Object.values"), k = h("Object.entries");
  function N(e3) {
    if ((e3 = e3.resolve()).isFunction()) {
      const { node: t3 } = e3;
      if (t3.async) return t3.generator ? m(y("AsyncIterator")) : m(y("Promise"));
      if (t3.generator) return m(y("Iterator"));
      if (e3.node.returnType) return e3.node.returnType;
    }
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    if (!this.isReferenced()) return;
    const t3 = this.scope.getBinding(e3.name);
    return t3 ? t3.identifier.typeAnnotation ? t3.identifier.typeAnnotation : function(e4, t4, r3) {
      const n3 = [], i3 = [];
      let o3 = c(e4, t4, i3);
      const a3 = p(e4, t4, r3);
      if (a3) {
        const t5 = c(e4, a3.ifStatement);
        o3 = o3.filter((e5) => t5.indexOf(e5) < 0), n3.push(a3.typeAnnotation);
      }
      if (o3.length) {
        o3.push(...i3);
        for (const e5 of o3) n3.push(e5.getTypeAnnotation());
      }
      if (n3.length) return (0, s2.createUnionType)(n3);
    }(t3, this, e3.name) : "undefined" === e3.name ? l() : "NaN" === e3.name || "Infinity" === e3.name ? a2() : void e3.name;
  };
  var n2 = r2(0), s2 = r2(223);
  const { BOOLEAN_NUMBER_BINARY_OPERATORS: i2, createTypeAnnotationBasedOnTypeof: o2, numberTypeAnnotation: a2, voidTypeAnnotation: l } = n2;
  function c(e3, t3, r3) {
    const n3 = e3.constantViolations.slice();
    return n3.unshift(e3.path), n3.filter((e4) => {
      const n4 = (e4 = e4.resolve())._guessExecutionStatusRelativeTo(t3);
      return r3 && "unknown" === n4 && r3.push(e4), "before" === n4;
    });
  }
  function u(e3, t3) {
    const r3 = t3.node.operator, n3 = t3.get("right").resolve(), s3 = t3.get("left").resolve();
    let l2, c2, u2;
    if (s3.isIdentifier({ name: e3 }) ? l2 = n3 : n3.isIdentifier({ name: e3 }) && (l2 = s3), l2) return "===" === r3 ? l2.getTypeAnnotation() : i2.indexOf(r3) >= 0 ? a2() : void 0;
    if ("===" !== r3 && "==" !== r3) return;
    if (s3.isUnaryExpression({ operator: "typeof" }) ? (c2 = s3, u2 = n3) : n3.isUnaryExpression({ operator: "typeof" }) && (c2 = n3, u2 = s3), !c2) return;
    if (!c2.get("argument").isIdentifier({ name: e3 })) return;
    if (u2 = u2.resolve(), !u2.isLiteral()) return;
    const p2 = u2.node.value;
    return "string" == typeof p2 ? o2(p2) : void 0;
  }
  function p(e3, t3, r3) {
    const n3 = function(e4, t4, r4) {
      let n4;
      for (; n4 = t4.parentPath; ) {
        if (n4.isIfStatement() || n4.isConditionalExpression()) {
          if ("test" === t4.key) return;
          return n4;
        }
        if (n4.isFunction() && n4.parentPath.scope.getBinding(r4) !== e4) return;
        t4 = n4;
      }
    }(e3, t3, r3);
    if (!n3) return;
    const i3 = [n3.get("test")], o3 = [];
    for (let e4 = 0; e4 < i3.length; e4++) {
      const t4 = i3[e4];
      if (t4.isLogicalExpression()) "&&" === t4.node.operator && (i3.push(t4.get("left")), i3.push(t4.get("right")));
      else if (t4.isBinaryExpression()) {
        const e5 = u(r3, t4);
        e5 && o3.push(e5);
      }
    }
    return o3.length ? { typeAnnotation: (0, s2.createUnionType)(o3), ifStatement: n3 } : p(e3, n3, r3);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._replaceWith = function(e3) {
    var t3;
    if (!this.container) throw new ReferenceError("Container is falsy");
    this.inList ? M(this.parent, this.key, [e3]) : M(this.parent, this.key, e3), this.debug(`Replace with ${null == e3 ? void 0 : e3.type}`), null == (t3 = (0, o2.getCachedPaths)(this.hub, this.parent)) || t3.set(e3, this).delete(this.node), this.node = this.container[this.key] = e3;
  }, t2.replaceExpressionWithStatements = function(e3) {
    this.resync();
    const t3 = [], r3 = R(e3, t3);
    if (r3) {
      for (const e4 of t3) this.scope.push({ id: e4 });
      return this.replaceWith(r3)[0].get("expressions");
    }
    const n3 = this.getFunctionParent(), i3 = null == n3 ? void 0 : n3.is("async"), o3 = null == n3 ? void 0 : n3.is("generator"), a3 = p([], h(e3));
    this.replaceWith(y(a3, []));
    const l2 = this.get("callee");
    (0, c.default)(l2.get("body"), (e4) => {
      this.scope.push({ id: e4 });
    }, "var");
    const m2 = this.get("callee").getCompletionRecords();
    for (const e4 of m2) {
      if (!e4.isExpressionStatement()) continue;
      const t4 = e4.findParent((e5) => e5.isLoop());
      if (t4) {
        let r4 = t4.getData("expressionReplacementReturnUid");
        r4 ? r4 = S(r4.name) : (r4 = l2.scope.generateDeclaredUidIdentifier("ret"), l2.get("body").pushContainer("body", j(g(r4))), t4.setData("expressionReplacementReturnUid", r4)), e4.get("expression").replaceWith(d("=", g(r4), e4.node.expression));
      } else e4.replaceWith(j(e4.node.expression));
    }
    l2.arrowFunctionToExpression();
    const b2 = l2, v2 = i3 && s2.default.hasType(this.get("callee.body").node, "AwaitExpression", u), E2 = o3 && s2.default.hasType(this.get("callee.body").node, "YieldExpression", u);
    return v2 && (b2.set("async", true), E2 || this.replaceWith(f(this.node))), E2 && (b2.set("generator", true), this.replaceWith(B(this.node, true))), b2.get("body.body");
  }, t2.replaceInline = function(e3) {
    if (this.resync(), Array.isArray(e3)) {
      if (Array.isArray(this.container)) {
        e3 = this._verifyNodeList(e3);
        const t3 = this._containerInsertAfter(e3);
        return this.remove(), t3;
      }
      return this.replaceWithMultiple(e3);
    }
    return this.replaceWith(e3);
  }, t2.replaceWith = function(e3) {
    if (this.resync(), this.removed) throw new Error("You can't replace this node, we've already removed it");
    let t3 = e3 instanceof i2.default ? e3.node : e3;
    if (!t3) throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === t3) return [this];
    if (this.isProgram() && !_(t3)) throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(t3)) throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if ("string" == typeof t3) throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let r3 = "";
    if (this.isNodeType("Statement") && C(t3) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(t3) || this.parentPath.isExportDefaultDeclaration() || (t3 = v(t3), r3 = "expression")), this.isNodeType("Expression") && k(t3) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t3)) return this.replaceExpressionWithStatements([t3]);
    const n3 = this.node;
    return n3 && (w(t3, n3), D(n3)), this._replaceWith(t3), this.type = t3.type, this.setScope(), this.requeue(), [r3 ? this.get(r3) : this];
  }, t2.replaceWithMultiple = function(e3) {
    var t3;
    this.resync(), e3 = this._verifyNodeList(e3), x(e3[0], this.node), T(e3[e3.length - 1], this.node), null == (t3 = (0, o2.getCachedPaths)(this.hub, this.parent)) || t3.delete(this.node), this.node = this.container[this.key] = null;
    const r3 = this.insertAfter(e3);
    return this.node ? this.requeue() : this.remove(), r3;
  }, t2.replaceWithSourceString = function(e3) {
    let t3;
    this.resync();
    try {
      e3 = `(${e3})`, t3 = (0, a2.parse)(e3);
    } catch (t4) {
      const r4 = t4.loc;
      throw r4 && (t4.message += " - make sure this is an expression.\n" + (0, n2.codeFrameColumns)(e3, { start: { line: r4.line, column: r4.column + 1 } }), t4.code = "BABEL_REPLACE_SOURCE_ERROR"), t4;
    }
    const r3 = t3.program.body[0].expression;
    return s2.default.removeProperties(r3), this.replaceWith(r3);
  };
  var n2 = r2(36), s2 = r2(14), i2 = r2(28), o2 = r2(35), a2 = r2(21), l = r2(0), c = r2(429);
  const { FUNCTION_TYPES: u, arrowFunctionExpression: p, assignmentExpression: d, awaitExpression: f, blockStatement: h, buildUndefinedNode: m, callExpression: y, cloneNode: g, conditionalExpression: b, expressionStatement: v, getBindingIdentifiers: E, identifier: S, inheritLeadingComments: x, inheritTrailingComments: T, inheritsComments: w, isBlockStatement: P, isEmptyStatement: A, isExpression: C, isExpressionStatement: O, isIfStatement: I, isProgram: _, isStatement: k, isVariableDeclaration: N, removeComments: D, returnStatement: j, sequenceExpression: L, validate: M, yieldExpression: B } = l;
  function R(e3, t3) {
    const r3 = [];
    let n3 = true;
    for (const s3 of e3) if (A(s3) || (n3 = false), C(s3)) r3.push(s3);
    else if (O(s3)) r3.push(s3.expression);
    else if (N(s3)) {
      if ("var" !== s3.kind) return;
      for (const e4 of s3.declarations) {
        const n4 = E(e4);
        for (const e5 of Object.keys(n4)) t3.push(g(n4[e5]));
        e4.init && r3.push(d("=", e4.id, e4.init));
      }
      n3 = true;
    } else if (I(s3)) {
      const e4 = s3.consequent ? R([s3.consequent], t3) : m(), n4 = s3.alternate ? R([s3.alternate], t3) : m();
      if (!e4 || !n4) return;
      r3.push(b(s3.test, e4, n4));
    } else if (P(s3)) {
      const e4 = R(s3.body, t3);
      if (!e4) return;
      r3.push(e4);
    } else {
      if (!A(s3)) return;
      0 === e3.indexOf(s3) && (n3 = true);
    }
    return n3 && r3.push(m()), 1 === r3.length ? r3[0] : L(r3);
  }
}, () => {
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "var";
    e3.traverse(a2, { kind: r3, emit: t3 });
  };
  var n2 = r2(0);
  const { assignmentExpression: s2, expressionStatement: i2, identifier: o2 } = n2, a2 = { Scope(e3, t3) {
    "let" === t3.kind && e3.skip();
  }, FunctionParent(e3) {
    e3.skip();
  }, VariableDeclaration(e3, t3) {
    if (t3.kind && e3.node.kind !== t3.kind) return;
    const r3 = [], n3 = e3.get("declarations");
    let a3;
    for (const e4 of n3) {
      a3 = e4.node.id, e4.node.init && r3.push(i2(s2("=", e4.node.id, e4.node.init)));
      for (const r4 of Object.keys(e4.getBindingIdentifiers())) t3.emit(o2(r4), r4, null !== e4.node.init);
    }
    e3.parentPath.isFor({ left: e3.node }) ? e3.replaceWith(a3) : e3.replaceWithMultiple(r3);
  } };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.evaluate = function() {
    const e3 = { confident: true, deoptPath: null, seen: /* @__PURE__ */ new Map() };
    let t3 = c(this, e3);
    return e3.confident || (t3 = void 0), { confident: e3.confident, deopt: e3.deoptPath, value: t3 };
  }, t2.evaluateTruthy = function() {
    const e3 = this.evaluate();
    if (e3.confident) return !!e3.value;
  };
  const n2 = ["Number", "String", "Math"], s2 = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null], i2 = ["random"];
  function o2(e3) {
    return n2.includes(e3);
  }
  function a2(e3, t3) {
    t3.confident && (t3.deoptPath = e3, t3.confident = false);
  }
  const l = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
  function c(e3, t3) {
    const { node: n3 } = e3, { seen: p } = t3;
    if (p.has(n3)) {
      const r3 = p.get(n3);
      return r3.resolved ? r3.value : void a2(e3, t3);
    }
    {
      const d = { resolved: false };
      p.set(n3, d);
      const f = function(e4, t4) {
        if (t4.confident) {
          if (e4.isSequenceExpression()) {
            const r3 = e4.get("expressions");
            return c(r3[r3.length - 1], t4);
          }
          if (e4.isStringLiteral() || e4.isNumericLiteral() || e4.isBooleanLiteral()) return e4.node.value;
          if (e4.isNullLiteral()) return null;
          if (e4.isTemplateLiteral()) return u(e4, e4.node.quasis, t4);
          if (e4.isTaggedTemplateExpression() && e4.get("tag").isMemberExpression()) {
            const r3 = e4.get("tag.object"), { node: { name: n4 } } = r3, s3 = e4.get("tag.property");
            if (r3.isIdentifier() && "String" === n4 && !e4.scope.getBinding(n4) && s3.isIdentifier() && "raw" === s3.node.name) return u(e4, e4.node.quasi.quasis, t4, true);
          }
          if (e4.isConditionalExpression()) {
            const r3 = c(e4.get("test"), t4);
            if (!t4.confident) return;
            return c(r3 ? e4.get("consequent") : e4.get("alternate"), t4);
          }
          if (e4.isExpressionWrapper()) return c(e4.get("expression"), t4);
          if (e4.isMemberExpression() && !e4.parentPath.isCallExpression({ callee: e4.node })) {
            const r3 = e4.get("property"), n4 = e4.get("object");
            if (n4.isLiteral()) {
              const s3 = n4.node.value, i3 = typeof s3;
              let o3 = null;
              if (e4.node.computed) {
                if (o3 = c(r3, t4), !t4.confident) return;
              } else r3.isIdentifier() && (o3 = r3.node.name);
              if (!("number" !== i3 && "string" !== i3 || null == o3 || "number" != typeof o3 && "string" != typeof o3)) return s3[o3];
            }
          }
          if (e4.isReferencedIdentifier()) {
            const r3 = e4.scope.getBinding(e4.node.name);
            if (r3) {
              if (r3.constantViolations.length > 0 || e4.node.start < r3.path.node.end) return void a2(r3.path, t4);
              if (r3.hasValue) return r3.value;
            }
            const n4 = e4.node.name;
            if (l.has(n4)) return r3 ? void a2(r3.path, t4) : l.get(n4);
            const s3 = e4.resolve();
            return s3 === e4 ? void a2(e4, t4) : c(s3, t4);
          }
          if (e4.isUnaryExpression({ prefix: true })) {
            if ("void" === e4.node.operator) return;
            const r3 = e4.get("argument");
            if ("typeof" === e4.node.operator && (r3.isFunction() || r3.isClass())) return "function";
            const n4 = c(r3, t4);
            if (!t4.confident) return;
            switch (e4.node.operator) {
              case "!":
                return !n4;
              case "+":
                return +n4;
              case "-":
                return -n4;
              case "~":
                return ~n4;
              case "typeof":
                return typeof n4;
            }
          }
          if (e4.isArrayExpression()) {
            const r3 = [], n4 = e4.get("elements");
            for (const e5 of n4) {
              const n5 = e5.evaluate();
              if (!n5.confident) return void a2(n5.deopt, t4);
              r3.push(n5.value);
            }
            return r3;
          }
          if (e4.isObjectExpression()) {
            const r3 = {}, n4 = e4.get("properties");
            for (const e5 of n4) {
              if (e5.isObjectMethod() || e5.isSpreadElement()) return void a2(e5, t4);
              const n5 = e5.get("key");
              let s3;
              if (e5.node.computed) {
                if (s3 = n5.evaluate(), !s3.confident) return void a2(s3.deopt, t4);
                s3 = s3.value;
              } else s3 = n5.isIdentifier() ? n5.node.name : n5.node.value;
              let i3 = e5.get("value").evaluate();
              if (!i3.confident) return void a2(i3.deopt, t4);
              i3 = i3.value, r3[s3] = i3;
            }
            return r3;
          }
          if (e4.isLogicalExpression()) {
            const r3 = t4.confident, n4 = c(e4.get("left"), t4), s3 = t4.confident;
            t4.confident = r3;
            const i3 = c(e4.get("right"), t4), o3 = t4.confident;
            switch (e4.node.operator) {
              case "||":
                if (t4.confident = s3 && (!!n4 || o3), !t4.confident) return;
                return n4 || i3;
              case "&&":
                if (t4.confident = s3 && (!n4 || o3), !t4.confident) return;
                return n4 && i3;
              case "??":
                if (t4.confident = s3 && (null != n4 || o3), !t4.confident) return;
                return null != n4 ? n4 : i3;
            }
          }
          if (e4.isBinaryExpression()) {
            const r3 = c(e4.get("left"), t4);
            if (!t4.confident) return;
            const n4 = c(e4.get("right"), t4);
            if (!t4.confident) return;
            switch (e4.node.operator) {
              case "-":
                return r3 - n4;
              case "+":
                return r3 + n4;
              case "/":
                return r3 / n4;
              case "*":
                return r3 * n4;
              case "%":
                return r3 % n4;
              case "**":
                return Math.pow(r3, n4);
              case "<":
                return r3 < n4;
              case ">":
                return r3 > n4;
              case "<=":
                return r3 <= n4;
              case ">=":
                return r3 >= n4;
              case "==":
                return r3 == n4;
              case "!=":
                return r3 != n4;
              case "===":
                return r3 === n4;
              case "!==":
                return r3 !== n4;
              case "|":
                return r3 | n4;
              case "&":
                return r3 & n4;
              case "^":
                return r3 ^ n4;
              case "<<":
                return r3 << n4;
              case ">>":
                return r3 >> n4;
              case ">>>":
                return r3 >>> n4;
            }
          }
          if (e4.isCallExpression()) {
            const n4 = e4.get("callee");
            let a3, l2;
            if (n4.isIdentifier() && !e4.scope.getBinding(n4.node.name) && (o2(n4.node.name) || function(e5) {
              return s2.includes(e5);
            }(n4.node.name)) && (l2 = r2.g[n4.node.name]), n4.isMemberExpression()) {
              const e5 = n4.get("object"), t5 = n4.get("property");
              if (e5.isIdentifier() && t5.isIdentifier() && o2(e5.node.name) && !function(e6) {
                return i2.includes(e6);
              }(t5.node.name)) {
                a3 = r2.g[e5.node.name];
                const n5 = t5.node.name;
                Object.hasOwnProperty.call(a3, n5) && (l2 = a3[n5]);
              }
              if (e5.isLiteral() && t5.isIdentifier()) {
                const r3 = typeof e5.node.value;
                "string" !== r3 && "number" !== r3 || (a3 = e5.node.value, l2 = a3[t5.node.name]);
              }
            }
            if (l2) {
              const r3 = e4.get("arguments").map((e5) => c(e5, t4));
              if (!t4.confident) return;
              return l2.apply(a3, r3);
            }
          }
          a2(e4, t4);
        }
      }(e3, t3);
      return t3.confident && (d.resolved = true, d.value = f), f;
    }
  }
  function u(e3, t3, r3) {
    let n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], s3 = "", i3 = 0;
    const o3 = e3.isTemplateLiteral() ? e3.get("expressions") : e3.get("quasi.expressions");
    for (const e4 of t3) {
      if (!r3.confident) break;
      s3 += n3 ? e4.value.raw : e4.value.cooked;
      const t4 = o3[i3++];
      t4 && (s3 += String(c(t4, r3)));
    }
    if (r3.confident) return s3;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.arrowFunctionToExpression = function() {
    let { allowInsertArrow: e3 = true, allowInsertArrowWithRest: t3 = e3, noNewArrows: r3 = !((e4) => null == (e4 = arguments[0]) ? void 0 : e4.specCompliant)() } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (!this.isArrowFunctionExpression()) throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    const { thisBinding: n3, fnPath: s3 } = D(this, r3, e3, t3);
    if (s3.ensureBlock(), s3.node.type = "FunctionExpression", !r3) {
      const e4 = n3 ? null : s3.scope.generateUidIdentifier("arrowCheckId");
      return e4 && s3.parentPath.scope.push({ id: e4, init: x([]) }), s3.get("body").unshiftContainer("body", f(p(this.hub.addHelper("newArrowCheck"), [I(), h(e4 ? e4.name : n3)]))), s3.replaceWith(p(v((0, i2.default)(this, true) || s3.node, h("bind")), [e4 ? h(e4.name) : I()])), s3.get("callee.object");
    }
    return s3;
  }, t2.ensureBlock = function() {
    const e3 = this.get("body"), t3 = e3.node;
    if (Array.isArray(e3)) throw new Error("Can't convert array path to a block statement");
    if (!t3) throw new Error("Can't convert node without a body");
    if (e3.isBlockStatement()) return t3;
    const r3 = [];
    let n3, s3, i3 = "body";
    e3.isStatement() ? (s3 = "body", n3 = 0, r3.push(e3.node)) : (i3 += ".body.0", this.isFunction() ? (n3 = "argument", r3.push(w(e3.node))) : (n3 = "expression", r3.push(f(e3.node)))), this.node.body = u(r3);
    const o3 = this.get(i3);
    return e3.setup(o3, s3 ? o3.node[s3] : o3.node, s3, n3), this.node;
  }, t2.toComputedKey = function() {
    let e3;
    if (this.isMemberExpression()) e3 = this.node.property;
    else {
      if (!this.isProperty() && !this.isMethod()) throw new ReferenceError("todo");
      e3 = this.node.key;
    }
    return this.node.computed || m(e3) && (e3 = C(e3.name)), e3;
  }, t2.unwrapFunctionEnvironment = function() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    D(this);
  };
  var n2 = r2(0), s2 = r2(33), i2 = r2(119), o2 = r2(57);
  const { arrowFunctionExpression: a2, assignmentExpression: l, binaryExpression: c, blockStatement: u, callExpression: p, conditionalExpression: d, expressionStatement: f, identifier: h, isIdentifier: m, jsxIdentifier: y, logicalExpression: g, LOGICAL_OPERATORS: b, memberExpression: v, metaProperty: E, numericLiteral: S, objectExpression: x, restElement: T, returnStatement: w, sequenceExpression: P, spreadElement: A, stringLiteral: C, super: O, thisExpression: I, toExpression: _, unaryExpression: k } = n2;
  t2.arrowFunctionToShadowed = function() {
    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
  };
  const N = (0, o2.merge)([{ CallExpression(e3, t3) {
    let { allSuperCalls: r3 } = t3;
    e3.get("callee").isSuper() && r3.push(e3);
  } }, s2.default]);
  function D(e3) {
    let t3, r3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], i3 = e3.findParent((e4) => e4.isArrowFunctionExpression() ? (null != t3 || (t3 = e4), false) : e4.isFunction() || e4.isProgram() || e4.isClassProperty({ static: false }) || e4.isClassPrivateProperty({ static: false }));
    const o3 = i3.isClassMethod({ kind: "constructor" });
    if (i3.isClassProperty() || i3.isClassPrivateProperty()) if (t3) i3 = t3;
    else {
      if (!n3) throw e3.buildCodeFrameError("Unable to transform arrow inside class property");
      e3.replaceWith(p(a2([], _(e3.node)), [])), i3 = e3.get("callee"), e3 = i3.get("body");
    }
    const { thisPaths: u2, argumentsPaths: f2, newTargetPaths: m2, superProps: x2, superCalls: w2 } = function(e4) {
      const t4 = [], r4 = [], n4 = [], s4 = [], i4 = [];
      return e4.traverse(B, { thisPaths: t4, argumentsPaths: r4, newTargetPaths: n4, superProps: s4, superCalls: i4 }), { thisPaths: t4, argumentsPaths: r4, newTargetPaths: n4, superProps: s4, superCalls: i4 };
    }(e3);
    if (o3 && w2.length > 0) {
      if (!n3) throw w2[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      if (!s3) throw w2[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      const e4 = [];
      i3.traverse(N, { allSuperCalls: e4 });
      const t4 = function(e5) {
        return M(e5, "supercall", () => {
          const t5 = e5.scope.generateUidIdentifier("args");
          return a2([T(t5)], p(O(), [A(h(t5.name))]));
        });
      }(i3);
      e4.forEach((e5) => {
        const r4 = h(t4);
        r4.loc = e5.node.callee.loc, e5.get("callee").replaceWith(r4);
      });
    }
    if (f2.length > 0) {
      const e4 = M(i3, "arguments", () => {
        const e5 = () => h("arguments");
        return i3.scope.path.isProgram() ? d(c("===", k("typeof", e5()), C("undefined")), i3.scope.buildUndefinedNode(), e5()) : e5();
      });
      f2.forEach((t4) => {
        const r4 = h(e4);
        r4.loc = t4.node.loc, t4.replaceWith(r4);
      });
    }
    if (m2.length > 0) {
      const e4 = M(i3, "newtarget", () => E(h("new"), h("target")));
      m2.forEach((t4) => {
        const r4 = h(e4);
        r4.loc = t4.node.loc, t4.replaceWith(r4);
      });
    }
    if (x2.length > 0) {
      if (!n3) throw x2[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      x2.reduce((e4, t4) => e4.concat(function(e5) {
        if (e5.parentPath.isAssignmentExpression() && "=" !== e5.parentPath.node.operator) {
          const r4 = e5.parentPath, n4 = r4.node.operator.slice(0, -1), s4 = r4.node.right, i4 = function(e6) {
            return b.includes(e6);
          }(n4);
          if (e5.node.computed) {
            const o4 = e5.scope.generateDeclaredUidIdentifier("tmp"), a3 = e5.node.object, c2 = e5.node.property;
            r4.get("left").replaceWith(v(a3, l("=", o4, c2), true)), r4.get("right").replaceWith(t5(i4 ? "=" : n4, v(a3, h(o4.name), true), s4));
          } else {
            const o4 = e5.node.object, a3 = e5.node.property;
            r4.get("left").replaceWith(v(o4, a3)), r4.get("right").replaceWith(t5(i4 ? "=" : n4, v(o4, h(a3.name)), s4));
          }
          return i4 ? r4.replaceWith(g(n4, r4.node.left, r4.node.right)) : r4.node.operator = "=", [r4.get("left"), r4.get("right").get("left")];
        }
        if (e5.parentPath.isUpdateExpression()) {
          const t6 = e5.parentPath, r4 = e5.scope.generateDeclaredUidIdentifier("tmp"), n4 = e5.node.computed ? e5.scope.generateDeclaredUidIdentifier("prop") : null, s4 = [l("=", r4, v(e5.node.object, n4 ? l("=", n4, e5.node.property) : e5.node.property, e5.node.computed)), l("=", v(e5.node.object, n4 ? h(n4.name) : e5.node.property, e5.node.computed), c(e5.parentPath.node.operator[0], h(r4.name), S(1)))];
          return e5.parentPath.node.prefix || s4.push(h(r4.name)), t6.replaceWith(P(s4)), [t6.get("expressions.0.right"), t6.get("expressions.1.left")];
        }
        return [e5];
        function t5(e6, t6, r4) {
          return "=" === e6 ? l("=", t6, r4) : c(e6, t6, r4);
        }
      }(t4)), []).forEach((e4) => {
        const t4 = e4.node.computed ? "" : e4.get("property").node.name, r4 = e4.parentPath, n4 = r4.isAssignmentExpression({ left: e4.node }), s4 = r4.isCallExpression({ callee: e4.node }), o4 = r4.isTaggedTemplateExpression({ tag: e4.node }), c2 = function(e5, t5, r5) {
          return M(e5, `superprop_${t5 ? "set" : "get"}:${r5 || ""}`, () => {
            const n5 = [];
            let s5;
            if (r5) s5 = v(O(), h(r5));
            else {
              const t6 = e5.scope.generateUidIdentifier("prop");
              n5.unshift(t6), s5 = v(O(), h(t6.name), true);
            }
            if (t5) {
              const t6 = e5.scope.generateUidIdentifier("value");
              n5.push(t6), s5 = l("=", s5, h(t6.name));
            }
            return a2(n5, s5);
          });
        }(i3, n4, t4), d2 = [];
        if (e4.node.computed && d2.push(e4.get("property").node), n4) {
          const e5 = r4.node.right;
          d2.push(e5);
        }
        const f3 = p(h(c2), d2);
        s4 ? (r4.unshiftContainer("arguments", I()), e4.replaceWith(v(f3, h("call"))), u2.push(r4.get("arguments.0"))) : n4 ? r4.replaceWith(f3) : o4 ? (e4.replaceWith(p(v(f3, h("bind"), false), [I()])), u2.push(e4.get("arguments.0"))) : e4.replaceWith(f3);
      });
    }
    let D2;
    return (u2.length > 0 || !r3) && (D2 = function(e4, t4) {
      return M(e4, "this", (r4) => {
        if (!t4 || !j(e4)) return I();
        e4.traverse(L, { supers: /* @__PURE__ */ new WeakSet(), thisBinding: r4 });
      });
    }(i3, o3), (r3 || o3 && j(i3)) && (u2.forEach((e4) => {
      const t4 = e4.isJSX() ? y(D2) : h(D2);
      t4.loc = e4.node.loc, e4.replaceWith(t4);
    }), r3 || (D2 = null))), { thisBinding: D2, fnPath: e3 };
  }
  function j(e3) {
    return e3.isClassMethod() && !!e3.parentPath.parentPath.node.superClass;
  }
  const L = (0, o2.merge)([{ CallExpression(e3, t3) {
    let { supers: r3, thisBinding: n3 } = t3;
    e3.get("callee").isSuper() && (r3.has(e3.node) || (r3.add(e3.node), e3.replaceWithMultiple([e3.node, l("=", h(n3), h("this"))])));
  } }, s2.default]);
  function M(e3, t3, r3) {
    const n3 = "binding:" + t3;
    let s3 = e3.getData(n3);
    if (!s3) {
      const i3 = e3.scope.generateUidIdentifier(t3);
      s3 = i3.name, e3.setData(n3, s3), e3.scope.push({ id: i3, init: r3(s3) });
    }
    return s3;
  }
  const B = (0, o2.merge)([{ ThisExpression(e3, t3) {
    let { thisPaths: r3 } = t3;
    r3.push(e3);
  }, JSXIdentifier(e3, t3) {
    let { thisPaths: r3 } = t3;
    "this" === e3.node.name && (e3.parentPath.isJSXMemberExpression({ object: e3.node }) || e3.parentPath.isJSXOpeningElement({ name: e3.node })) && r3.push(e3);
  }, CallExpression(e3, t3) {
    let { superCalls: r3 } = t3;
    e3.get("callee").isSuper() && r3.push(e3);
  }, MemberExpression(e3, t3) {
    let { superProps: r3 } = t3;
    e3.get("object").isSuper() && r3.push(e3);
  }, Identifier(e3, t3) {
    let { argumentsPaths: r3 } = t3;
    if (!e3.isReferencedIdentifier({ name: "arguments" })) return;
    let n3 = e3.scope;
    do {
      if (n3.hasOwnBinding("arguments")) return void n3.rename("arguments");
      if (n3.path.isFunction() && !n3.path.isArrowFunctionExpression()) break;
    } while (n3 = n3.parent);
    r3.push(e3);
  }, MetaProperty(e3, t3) {
    let { newTargetPaths: r3 } = t3;
    e3.get("meta").isIdentifier({ name: "new" }) && e3.get("property").isIdentifier({ name: "target" }) && r3.push(e3);
  } }, s2.default]);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.statements = t2.statement = t2.smart = t2.program = t2.expression = void 0;
  var n2 = r2(0);
  const { assertExpressionStatement: s2 } = n2;
  function i2(e3) {
    return { code: (e4) => `/* @babel/template */;
${e4}`, validate: () => {
    }, unwrap: (t3) => e3(t3.program.body.slice(1)) };
  }
  const o2 = i2((e3) => e3.length > 1 ? e3 : e3[0]);
  t2.smart = o2;
  const a2 = i2((e3) => e3);
  t2.statements = a2;
  const l = i2((e3) => {
    if (0 === e3.length) throw new Error("Found nothing to return.");
    if (e3.length > 1) throw new Error("Found multiple statements but wanted one");
    return e3[0];
  });
  t2.statement = l;
  const c = { code: (e3) => `(
${e3}
)`, validate: (e3) => {
    if (e3.program.body.length > 1) throw new Error("Found multiple statements but wanted one");
    if (0 === c.unwrap(e3).start) throw new Error("Parse result included parens.");
  }, unwrap: (e3) => {
    let { program: t3 } = e3;
    const [r3] = t3.body;
    return s2(r3), r3.expression;
  } };
  t2.expression = c, t2.program = { code: (e3) => e3, validate: () => {
  }, unwrap: (e3) => e3.program };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, r3) {
    const l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap(), u = r3 || (0, n2.validate)(null);
    return Object.assign(function(r4) {
      for (var o3 = arguments.length, c2 = new Array(o3 > 1 ? o3 - 1 : 0), p = 1; p < o3; p++) c2[p - 1] = arguments[p];
      if ("string" == typeof r4) {
        if (c2.length > 1) throw new Error("Unexpected extra params.");
        return a2((0, s2.default)(t3, r4, (0, n2.merge)(u, (0, n2.validate)(c2[0]))));
      }
      if (Array.isArray(r4)) {
        let e4 = l.get(r4);
        return e4 || (e4 = (0, i2.default)(t3, r4, u), l.set(r4, e4)), a2(e4(c2));
      }
      if ("object" == typeof r4 && r4) {
        if (c2.length > 0) throw new Error("Unexpected extra params.");
        return e3(t3, (0, n2.merge)(u, (0, n2.validate)(r4)));
      }
      throw new Error("Unexpected template param " + typeof r4);
    }, { ast: function(e4) {
      for (var r4 = arguments.length, a3 = new Array(r4 > 1 ? r4 - 1 : 0), l2 = 1; l2 < r4; l2++) a3[l2 - 1] = arguments[l2];
      if ("string" == typeof e4) {
        if (a3.length > 1) throw new Error("Unexpected extra params.");
        return (0, s2.default)(t3, e4, (0, n2.merge)((0, n2.merge)(u, (0, n2.validate)(a3[0])), o2))();
      }
      if (Array.isArray(e4)) {
        let r5 = c.get(e4);
        return r5 || (r5 = (0, i2.default)(t3, e4, (0, n2.merge)(u, o2)), c.set(e4, r5)), r5(a3)();
      }
      throw new Error("Unexpected template param " + typeof e4);
    } });
  };
  var n2 = r2(120), s2 = r2(434), i2 = r2(435);
  const o2 = (0, n2.validate)({ placeholderPattern: false });
  function a2(e3) {
    let t3 = "";
    try {
      throw new Error();
    } catch (e4) {
      e4.stack && (t3 = e4.stack.split("\n").slice(3).join("\n"));
    }
    return (r3) => {
      try {
        return e3(r3);
      } catch (e4) {
        throw e4.stack += `
    =============
${t3}`, e4;
      }
    };
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    let o2;
    return t3 = e3.code(t3), (a2) => {
      const l = (0, n2.normalizeReplacements)(a2);
      return o2 || (o2 = (0, s2.default)(e3, t3, r3)), e3.unwrap((0, i2.default)(o2, l));
    };
  };
  var n2 = r2(120), s2 = r2(225), i2 = r2(226);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    const { metadata: o2, names: a2 } = function(e4, t4, r4) {
      let n3 = "BABEL_TPL$";
      const i3 = t4.join("");
      do {
        n3 = "$$" + n3;
      } while (i3.includes(n3));
      const { names: o3, code: a3 } = function(e5, t5) {
        const r5 = [];
        let n4 = e5[0];
        for (let s3 = 1; s3 < e5.length; s3++) {
          const i4 = `${t5}${s3 - 1}`;
          r5.push(i4), n4 += i4 + e5[s3];
        }
        return { names: r5, code: n4 };
      }(t4, n3);
      return { metadata: (0, s2.default)(e4, e4.code(a3), { parser: r4.parser, placeholderWhitelist: new Set(o3.concat(r4.placeholderWhitelist ? Array.from(r4.placeholderWhitelist) : [])), placeholderPattern: r4.placeholderPattern, preserveComments: r4.preserveComments, syntacticPlaceholders: r4.syntacticPlaceholders }), names: o3 };
    }(e3, t3, r3);
    return (t4) => {
      const r4 = {};
      return t4.forEach((e4, t5) => {
        r4[a2[t5]] = e4;
      }), (t5) => {
        const s3 = (0, n2.normalizeReplacements)(t5);
        return s3 && Object.keys(s3).forEach((e4) => {
          if (Object.prototype.hasOwnProperty.call(r4, e4)) throw new Error("Unexpected replacement overlap.");
        }), e3.unwrap((0, i2.default)(o2, s3 ? Object.assign(s3, r4) : r4));
      };
    };
  };
  var n2 = r2(120), s2 = r2(225), i2 = r2(226);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._guessExecutionStatusRelativeTo = function(e3) {
    return b(this, e3, /* @__PURE__ */ new Map());
  }, t2._resolve = function(e3, t3) {
    if (!(t3 && t3.indexOf(this) >= 0)) if ((t3 = t3 || []).push(this), this.isVariableDeclarator()) {
      if (this.get("id").isIdentifier()) return this.get("init").resolve(e3, t3);
    } else if (this.isReferencedIdentifier()) {
      const r3 = this.scope.getBinding(this.node.name);
      if (!r3) return;
      if (!r3.constant) return;
      if ("module" === r3.kind) return;
      if (r3.path !== this) {
        const n3 = r3.path.resolve(e3, t3);
        if (this.find((e4) => e4.node === n3.node)) return;
        return n3;
      }
    } else {
      if (this.isTypeCastExpression()) return this.get("expression").resolve(e3, t3);
      if (e3 && this.isMemberExpression()) {
        const r3 = this.toComputedKey();
        if (!c(r3)) return;
        const n3 = r3.value, s3 = this.get("object").resolve(e3, t3);
        if (s3.isObjectExpression()) {
          const r4 = s3.get("properties");
          for (const s4 of r4) {
            if (!s4.isProperty()) continue;
            const r5 = s4.get("key");
            let i3 = s4.isnt("computed") && r5.isIdentifier({ name: n3 });
            if (i3 = i3 || r5.isLiteral({ value: n3 }), i3) return s4.get("value").resolve(e3, t3);
          }
        } else if (s3.isArrayExpression() && !isNaN(+n3)) {
          const r4 = s3.get("elements")[n3];
          if (r4) return r4.resolve(e3, t3);
        }
      }
    }
  }, t2.canHaveVariableDeclarationOrExpression = function() {
    return ("init" === this.key || "left" === this.key) && this.parentPath.isFor();
  }, t2.canSwapBetweenExpressionAndStatement = function(e3) {
    return !("body" !== this.key || !this.parentPath.isArrowFunctionExpression()) && (this.isExpression() ? o2(e3) : !!this.isBlockStatement() && a2(e3));
  }, t2.equals = function(e3, t3) {
    return this.node[e3] === t3;
  }, t2.getSource = function() {
    const e3 = this.node;
    if (e3.end) {
      const t3 = this.hub.getCode();
      if (t3) return t3.slice(e3.start, e3.end);
    }
    return "";
  }, t2.has = f, t2.is = void 0, t2.isCompletionRecord = function(e3) {
    let t3 = this, r3 = true;
    do {
      const { type: n3, container: s3 } = t3;
      if (!r3 && (t3.isFunction() || "StaticBlock" === n3)) return !!e3;
      if (r3 = false, Array.isArray(s3) && t3.key !== s3.length - 1) return false;
    } while ((t3 = t3.parentPath) && !t3.isProgram() && !t3.isDoExpression());
    return true;
  }, t2.isConstantExpression = function() {
    if (this.isIdentifier()) {
      const e3 = this.scope.getBinding(this.node.name);
      return !!e3 && e3.constant;
    }
    if (this.isLiteral()) return !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every((e3) => e3.isConstantExpression()));
    if (this.isUnaryExpression()) return "void" === this.node.operator && this.get("argument").isConstantExpression();
    if (this.isBinaryExpression()) {
      const { operator: e3 } = this.node;
      return "in" !== e3 && "instanceof" !== e3 && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    return false;
  }, t2.isInStrictMode = function() {
    return !!(this.isProgram() ? this : this.parentPath).find((e3) => {
      if (e3.isProgram({ sourceType: "module" })) return true;
      if (e3.isClass()) return true;
      if (e3.isArrowFunctionExpression() && !e3.get("body").isBlockStatement()) return false;
      let t3;
      if (e3.isFunction()) t3 = e3.node.body;
      else {
        if (!e3.isProgram()) return false;
        t3 = e3.node;
      }
      for (const e4 of t3.directives) if ("use strict" === e4.value.value) return true;
    });
  }, t2.isNodeType = function(e3) {
    return p(this.type, e3);
  }, t2.isStatementOrBlock = function() {
    return !this.parentPath.isLabeledStatement() && !o2(this.container) && s2.includes(this.key);
  }, t2.isStatic = function() {
    return this.scope.isStatic(this.node);
  }, t2.isnt = function(e3) {
    return !this.has(e3);
  }, t2.matchesPattern = function(e3, t3) {
    return d(this.node, e3, t3);
  }, t2.referencesImport = function(e3, t3) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === t3 || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? u(this.node.property, { value: t3 }) : this.node.property.name === t3)) {
        const t4 = this.get("object");
        return t4.isReferencedIdentifier() && t4.referencesImport(e3, "*");
      }
      return false;
    }
    const r3 = this.scope.getBinding(this.node.name);
    if (!r3 || "module" !== r3.kind) return false;
    const n3 = r3.path, s3 = n3.parentPath;
    return !!s3.isImportDeclaration() && (s3.node.source.value === e3 && (!t3 || (!(!n3.isImportDefaultSpecifier() || "default" !== t3) || (!(!n3.isImportNamespaceSpecifier() || "*" !== t3) || !(!n3.isImportSpecifier() || !l(n3.node.imported, { name: t3 }))))));
  }, t2.resolve = function(e3, t3) {
    return this._resolve(e3, t3) || this;
  }, t2.willIMaybeExecuteBefore = function(e3) {
    return "after" !== this._guessExecutionStatusRelativeTo(e3);
  };
  var n2 = r2(0);
  const { STATEMENT_OR_BLOCK_KEYS: s2, VISITOR_KEYS: i2, isBlockStatement: o2, isExpression: a2, isIdentifier: l, isLiteral: c, isStringLiteral: u, isType: p, matchesPattern: d } = n2;
  function f(e3) {
    const t3 = this.node && this.node[e3];
    return t3 && Array.isArray(t3) ? !!t3.length : !!t3;
  }
  function h(e3) {
    return e3.isProgram() ? e3 : (e3.parentPath.scope.getFunctionParent() || e3.parentPath.scope.getProgramParent()).path;
  }
  function m(e3, t3) {
    switch (e3) {
      case "LogicalExpression":
      case "AssignmentPattern":
        return "right" === t3;
      case "ConditionalExpression":
      case "IfStatement":
        return "consequent" === t3 || "alternate" === t3;
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return "body" === t3;
      case "ForStatement":
        return "body" === t3 || "update" === t3;
      case "SwitchStatement":
        return "cases" === t3;
      case "TryStatement":
        return "handler" === t3;
      case "OptionalMemberExpression":
        return "property" === t3;
      case "OptionalCallExpression":
        return "arguments" === t3;
      default:
        return false;
    }
  }
  function y(e3, t3) {
    for (let r3 = 0; r3 < t3; r3++) {
      const t4 = e3[r3];
      if (m(t4.parent.type, t4.parentKey)) return true;
    }
    return false;
  }
  t2.is = f;
  const g = Symbol();
  function b(e3, t3, r3) {
    const n3 = { this: h(e3), target: h(t3) };
    if (n3.target.node !== n3.this.node) return function(e4, t4, r4) {
      let n4, s4 = r4.get(e4.node);
      if (s4) {
        if (n4 = s4.get(t4.node)) return n4 === g ? "unknown" : n4;
      } else r4.set(e4.node, s4 = /* @__PURE__ */ new Map());
      s4.set(t4.node, g);
      const i3 = function(e5, t5, r5) {
        if (!t5.isFunctionDeclaration()) return "before" === b(e5, t5, r5) ? "before" : "unknown";
        if (t5.parentPath.isExportDeclaration()) return "unknown";
        const n5 = t5.scope.getBinding(t5.node.id.name);
        if (!n5.references) return "before";
        const s5 = n5.referencePaths;
        let i4;
        for (const n6 of s5) {
          if (n6.find((e6) => e6.node === t5.node)) continue;
          if ("callee" !== n6.key || !n6.parentPath.isCallExpression()) return "unknown";
          const s6 = b(e5, n6, r5);
          if (i4 && i4 !== s6) return "unknown";
          i4 = s6;
        }
        return i4;
      }(e4, t4, r4);
      return s4.set(t4.node, i3), i3;
    }(e3, n3.target, r3);
    const s3 = { target: t3.getAncestry(), this: e3.getAncestry() };
    if (s3.target.indexOf(e3) >= 0) return "after";
    if (s3.this.indexOf(t3) >= 0) return "before";
    let o3;
    const a3 = { target: 0, this: 0 };
    for (; !o3 && a3.this < s3.this.length; ) {
      const e4 = s3.this[a3.this];
      a3.target = s3.target.indexOf(e4), a3.target >= 0 ? o3 = e4 : a3.this++;
    }
    if (!o3) throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (y(s3.this, a3.this - 1) || y(s3.target, a3.target - 1)) return "unknown";
    const l2 = { this: s3.this[a3.this - 1], target: s3.target[a3.target - 1] };
    if (l2.target.listKey && l2.this.listKey && l2.target.container === l2.this.container) return l2.target.key > l2.this.key ? "before" : "after";
    const c2 = i2[o3.type], u2 = c2.indexOf(l2.this.parentKey);
    return c2.indexOf(l2.target.parentKey) > u2 ? "before" : "after";
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._call = function(e3) {
    if (!e3) return false;
    for (const t3 of e3) {
      if (!t3) continue;
      const e4 = this.node;
      if (!e4) return true;
      const r3 = t3.call(this.state, this, this.state);
      if (r3 && "object" == typeof r3 && "function" == typeof r3.then) throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (r3) throw new Error(`Unexpected return value from visitor method ${t3}`);
      if (this.node !== e4) return true;
      if (this._traverseFlags > 0) return true;
    }
    return false;
  }, t2._getQueueContexts = function() {
    let e3 = this, t3 = this.contexts;
    for (; !t3.length && (e3 = e3.parentPath, e3); ) t3 = e3.contexts;
    return t3;
  }, t2._resyncKey = function() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let e3 = 0; e3 < this.container.length; e3++) if (this.container[e3] === this.node) return void this.setKey(e3);
      } else for (const e3 of Object.keys(this.container)) if (this.container[e3] === this.node) return void this.setKey(e3);
      this.key = null;
    }
  }, t2._resyncList = function() {
    if (!this.parent || !this.inList) return;
    const e3 = this.parent[this.listKey];
    this.container !== e3 && (this.container = e3 || null);
  }, t2._resyncParent = function() {
    this.parentPath && (this.parent = this.parentPath.node);
  }, t2._resyncRemoved = function() {
    null != this.key && this.container && this.container[this.key] === this.node || this._markRemoved();
  }, t2.call = function(e3) {
    const t3 = this.opts;
    return this.debug(e3), !(!this.node || !this._call(t3[e3])) || !!this.node && this._call(null == (r3 = t3[this.node.type]) ? void 0 : r3[e3]);
    var r3;
  }, t2.isBlacklisted = t2.isDenylisted = function() {
    var e3;
    const t3 = null != (e3 = this.opts.denylist) ? e3 : this.opts.blacklist;
    return t3 && t3.indexOf(this.node.type) > -1;
  }, t2.popContext = function() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }, t2.pushContext = function(e3) {
    this.contexts.push(e3), this.setContext(e3);
  }, t2.requeue = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this;
    if (e3.removed) return;
    const t3 = this.contexts;
    for (const r3 of t3) r3.maybeQueue(e3);
  }, t2.resync = function() {
    this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
  }, t2.setContext = function(e3) {
    return null != this.skipKeys && (this.skipKeys = {}), this._traverseFlags = 0, e3 && (this.context = e3, this.state = e3.state, this.opts = e3.opts), this.setScope(), this;
  }, t2.setKey = function(e3) {
    var t3;
    this.key = e3, this.node = this.container[this.key], this.type = null == (t3 = this.node) ? void 0 : t3.type;
  }, t2.setScope = function() {
    var e3, t3;
    if (null != (e3 = this.opts) && e3.noScope) return;
    let r3, n3 = this.parentPath;
    for ((("key" === this.key || "decorators" === this.listKey) && n3.isMethod() || "discriminant" === this.key && n3.isSwitchStatement()) && (n3 = n3.parentPath); n3 && !r3; ) {
      var s3;
      if (null != (s3 = n3.opts) && s3.noScope) return;
      r3 = n3.scope, n3 = n3.parentPath;
    }
    this.scope = this.getScope(r3), null == (t3 = this.scope) || t3.init();
  }, t2.setup = function(e3, t3, r3, n3) {
    this.listKey = r3, this.container = t3, this.parentPath = e3 || this.parentPath, this.setKey(n3);
  }, t2.skip = function() {
    this.shouldSkip = true;
  }, t2.skipKey = function(e3) {
    null == this.skipKeys && (this.skipKeys = {}), this.skipKeys[e3] = true;
  }, t2.stop = function() {
    this._traverseFlags |= s2.SHOULD_SKIP | s2.SHOULD_STOP;
  }, t2.visit = function() {
    var e3, t3;
    if (!this.node) return false;
    if (this.isDenylisted()) return false;
    if (null != (e3 = (t3 = this.opts).shouldSkip) && e3.call(t3, this)) return false;
    const r3 = this.context;
    return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (i2(this, r3), this.debug("Recursing into..."), this.shouldStop = (0, n2.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), i2(this, r3), this.call("exit"), this.shouldStop);
  };
  var n2 = r2(100), s2 = r2(28);
  function i2(e3, t3) {
    e3.context !== t3 && (e3.context = t3, e3.state = t3.state, e3.opts = t3.opts);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._assertUnremoved = function() {
    if (this.removed) throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }, t2._callRemovalHooks = function() {
    if (this.parentPath) {
      for (const e3 of n2.hooks) if (e3(this, this.parentPath)) return true;
    }
  }, t2._markRemoved = function() {
    this._traverseFlags |= i2.SHOULD_SKIP | i2.REMOVED, this.parent && (0, s2.getCachedPaths)(this.hub, this.parent).delete(this.node), this.node = null;
  }, t2._remove = function() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
  }, t2._removeFromScope = function() {
    const e3 = a2(this.node, false, false, true);
    Object.keys(e3).forEach((e4) => this.scope.removeBinding(e4));
  }, t2.remove = function() {
    var e3;
    this._assertUnremoved(), this.resync(), null != (e3 = this.opts) && e3.noScope || this._removeFromScope(), this._callRemovalHooks() || (this.shareCommentsWithSiblings(), this._remove()), this._markRemoved();
  };
  var n2 = r2(439), s2 = r2(35), i2 = r2(28), o2 = r2(0);
  const { getBindingIdentifiers: a2 } = o2;
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.hooks = void 0, t2.hooks = [function(e3, t3) {
    if ("test" === e3.key && (t3.isWhile() || t3.isSwitchCase()) || "declaration" === e3.key && t3.isExportDeclaration() || "body" === e3.key && t3.isLabeledStatement() || "declarations" === e3.listKey && t3.isVariableDeclaration() && 1 === t3.node.declarations.length || "expression" === e3.key && t3.isExpressionStatement()) return t3.remove(), true;
  }, function(e3, t3) {
    if (t3.isSequenceExpression() && 1 === t3.node.expressions.length) return t3.replaceWith(t3.node.expressions[0]), true;
  }, function(e3, t3) {
    if (t3.isBinary()) return "left" === e3.key ? t3.replaceWith(t3.node.right) : t3.replaceWith(t3.node.left), true;
  }, function(e3, t3) {
    if (t3.isIfStatement() && "consequent" === e3.key || "body" === e3.key && (t3.isLoop() || t3.isArrowFunctionExpression())) return e3.replaceWith({ type: "BlockStatement", body: [] }), true;
  }];
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._containerInsert = function(e3, t3) {
    this.updateSiblingKeys(e3, t3.length);
    const r3 = [];
    this.container.splice(e3, 0, ...t3);
    for (let s4 = 0; s4 < t3.length; s4++) {
      var n3;
      const t4 = e3 + s4, i3 = this.getSibling(t4);
      r3.push(i3), null != (n3 = this.context) && n3.queue && i3.pushContext(this.context);
    }
    const s3 = this._getQueueContexts();
    for (const e4 of r3) {
      e4.setScope(), e4.debug("Inserted.");
      for (const t4 of s3) t4.maybeQueue(e4, true);
    }
    return r3;
  }, t2._containerInsertAfter = function(e3) {
    return this._containerInsert(this.key + 1, e3);
  }, t2._containerInsertBefore = function(e3) {
    return this._containerInsert(this.key, e3);
  }, t2._verifyNodeList = function(e3) {
    if (!e3) return [];
    Array.isArray(e3) || (e3 = [e3]);
    for (let t3 = 0; t3 < e3.length; t3++) {
      const r3 = e3[t3];
      let n3;
      if (r3 ? "object" != typeof r3 ? n3 = "contains a non-object node" : r3.type ? r3 instanceof i2.default && (n3 = "has a NodePath when it expected a raw object") : n3 = "without a type" : n3 = "has falsy node", n3) {
        const e4 = Array.isArray(r3) ? "array" : typeof r3;
        throw new Error(`Node list ${n3} with the index of ${t3} and type of ${e4}`);
      }
    }
    return e3;
  }, t2.hoist = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.scope;
    return new s2.default(this, e3).run();
  }, t2.insertAfter = function(e3) {
    if (this._assertUnremoved(), this.isSequenceExpression()) return x(this.get("expressions")).insertAfter(e3);
    const t3 = this._verifyNodeList(e3), { parentPath: r3, parent: n3 } = this;
    if (r3.isExpressionStatement() || r3.isLabeledStatement() || y(n3) || r3.isExportDefaultDeclaration() && this.isDeclaration()) return r3.insertAfter(t3.map((e4) => g(e4) ? f(e4) : e4));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !r3.isJSXElement() || r3.isForStatement() && "init" === this.key) {
      if (this.node) {
        const e4 = this.node;
        let { scope: n4 } = this;
        if (n4.path.isPattern()) return l(e4), this.replaceWith(p(a2([], e4), [])), this.get("callee.body").insertAfter(t3), [this];
        if (T(this)) t3.unshift(e4);
        else if (m(e4) && E(e4.callee)) t3.unshift(e4), t3.push(S());
        else if (function(e5, t4) {
          if (!h(e5) || !b(e5.left)) return false;
          const r4 = t4.getBlockParent();
          return r4.hasOwnBinding(e5.left.name) && r4.getOwnBinding(e5.left.name).constantViolations.length <= 1;
        }(e4, n4)) t3.unshift(e4), t3.push(d(e4.left));
        else if (n4.isPure(e4, true)) t3.push(e4);
        else {
          r3.isMethod({ computed: true, key: e4 }) && (n4 = n4.parent);
          const s3 = n4.generateDeclaredUidIdentifier();
          t3.unshift(f(c("=", d(s3), e4))), t3.push(f(d(s3)));
        }
      }
      return this.replaceExpressionWithStatements(t3);
    }
    if (Array.isArray(this.container)) return this._containerInsertAfter(t3);
    if (this.isStatementOrBlock()) {
      const e4 = this.node, r4 = e4 && (!this.isExpressionStatement() || null != e4.expression);
      return this.replaceWith(u(r4 ? [e4] : [])), this.pushContainer("body", t3);
    }
    throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }, t2.insertBefore = function(e3) {
    this._assertUnremoved();
    const t3 = this._verifyNodeList(e3), { parentPath: r3, parent: n3 } = this;
    if (r3.isExpressionStatement() || r3.isLabeledStatement() || y(n3) || r3.isExportDefaultDeclaration() && this.isDeclaration()) return r3.insertBefore(t3);
    if (this.isNodeType("Expression") && !this.isJSXElement() || r3.isForStatement() && "init" === this.key) return this.node && t3.push(this.node), this.replaceExpressionWithStatements(t3);
    if (Array.isArray(this.container)) return this._containerInsertBefore(t3);
    if (this.isStatementOrBlock()) {
      const e4 = this.node, r4 = e4 && (!this.isExpressionStatement() || null != e4.expression);
      return this.replaceWith(u(r4 ? [e4] : [])), this.unshiftContainer("body", t3);
    }
    throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }, t2.pushContainer = function(e3, t3) {
    this._assertUnremoved();
    const r3 = this._verifyNodeList(t3), n3 = this.node[e3];
    return i2.default.get({ parentPath: this, parent: this.node, container: n3, listKey: e3, key: n3.length }).setContext(this.context).replaceWithMultiple(r3);
  }, t2.unshiftContainer = function(e3, t3) {
    return this._assertUnremoved(), t3 = this._verifyNodeList(t3), i2.default.get({ parentPath: this, parent: this.node, container: this.node[e3], listKey: e3, key: 0 }).setContext(this.context)._containerInsertBefore(t3);
  }, t2.updateSiblingKeys = function(e3, t3) {
    if (!this.parent) return;
    const r3 = (0, n2.getCachedPaths)(this.hub, this.parent) || [];
    for (const [, n3] of r3) "number" == typeof n3.key && n3.key >= e3 && (n3.key += t3);
  };
  var n2 = r2(35), s2 = r2(441), i2 = r2(28), o2 = r2(0);
  const { arrowFunctionExpression: a2, assertExpression: l, assignmentExpression: c, blockStatement: u, callExpression: p, cloneNode: d, expressionStatement: f, isAssignmentExpression: h, isCallExpression: m, isExportNamedDeclaration: y, isExpression: g, isIdentifier: b, isSequenceExpression: v, isSuper: E, thisExpression: S } = o2, x = (e3) => e3[e3.length - 1];
  function T(e3) {
    return v(e3.parent) && (x(e3.parent.expressions) !== e3.node || T(e3.parentPath));
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(0), s2 = n2;
  const { react: i2 } = n2, { cloneNode: o2, jsxExpressionContainer: a2, variableDeclaration: l, variableDeclarator: c } = s2, u = { ReferencedIdentifier(e3, t3) {
    if (e3.isJSXIdentifier() && i2.isCompatTag(e3.node.name) && !e3.parentPath.isJSXMemberExpression()) return;
    if ("this" === e3.node.name) {
      let r4 = e3.scope;
      do {
        if (r4.path.isFunction() && !r4.path.isArrowFunctionExpression()) break;
      } while (r4 = r4.parent);
      r4 && t3.breakOnScopePaths.push(r4.path);
    }
    const r3 = e3.scope.getBinding(e3.node.name);
    if (r3) {
      for (const n3 of r3.constantViolations) if (n3.scope !== r3.path.scope) return t3.mutableBinding = true, void e3.stop();
      r3 === t3.scope.getBinding(e3.node.name) && (t3.bindings[e3.node.name] = r3);
    }
  } };
  t2.default = class {
    constructor(e3, t3) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = false, this.scopes = [], this.scope = t3, this.path = e3, this.attachAfter = false;
    }
    isCompatibleScope(e3) {
      for (const t3 of Object.keys(this.bindings)) {
        const r3 = this.bindings[t3];
        if (!e3.bindingIdentifierEquals(t3, r3.identifier)) return false;
      }
      return true;
    }
    getCompatibleScopes() {
      let e3 = this.path.scope;
      do {
        if (!this.isCompatibleScope(e3)) break;
        if (this.scopes.push(e3), this.breakOnScopePaths.indexOf(e3.path) >= 0) break;
      } while (e3 = e3.parent);
    }
    getAttachmentPath() {
      let e3 = this._getAttachmentPath();
      if (!e3) return;
      let t3 = e3.scope;
      if (t3.path === e3 && (t3 = e3.scope.parent), t3.path.isProgram() || t3.path.isFunction()) for (const r3 of Object.keys(this.bindings)) {
        if (!t3.hasOwnBinding(r3)) continue;
        const n3 = this.bindings[r3];
        if ("param" !== n3.kind && "params" !== n3.path.parentKey && this.getAttachmentParentForPath(n3.path).key >= e3.key) {
          this.attachAfter = true, e3 = n3.path;
          for (const t4 of n3.constantViolations) this.getAttachmentParentForPath(t4).key > e3.key && (e3 = t4);
        }
      }
      return e3;
    }
    _getAttachmentPath() {
      const e3 = this.scopes.pop();
      if (e3) {
        if (e3.path.isFunction()) {
          if (!this.hasOwnParamBindings(e3)) return this.getNextScopeAttachmentParent();
          {
            if (this.scope === e3) return;
            const t3 = e3.path.get("body").get("body");
            for (let e4 = 0; e4 < t3.length; e4++) if (!t3[e4].node._blockHoist) return t3[e4];
          }
        } else if (e3.path.isProgram()) return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      const e3 = this.scopes.pop();
      if (e3) return this.getAttachmentParentForPath(e3.path);
    }
    getAttachmentParentForPath(e3) {
      do {
        if (!e3.parentPath || Array.isArray(e3.container) && e3.isStatement()) return e3;
      } while (e3 = e3.parentPath);
    }
    hasOwnParamBindings(e3) {
      for (const t3 of Object.keys(this.bindings)) {
        if (!e3.hasOwnBinding(t3)) continue;
        const r3 = this.bindings[t3];
        if ("param" === r3.kind && r3.constant) return true;
      }
      return false;
    }
    run() {
      if (this.path.traverse(u, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      const e3 = this.getAttachmentPath();
      if (!e3) return;
      if (e3.getFunctionParent() === this.path.getFunctionParent()) return;
      let t3 = e3.scope.generateUidIdentifier("ref");
      const r3 = c(t3, this.path.node), n3 = this.attachAfter ? "insertAfter" : "insertBefore", [s3] = e3[n3]([e3.isVariableDeclarator() ? r3 : l("var", [r3])]), i3 = this.path.parentPath;
      return i3.isJSXElement() && this.path.container === i3.node.children && (t3 = a2(t3)), this.path.replaceWith(o2(t3)), e3.isVariableDeclarator() ? s3.get("init") : s3.get("declarations.0.init");
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2._getKey = function(e3, t3) {
    const r3 = this.node, s3 = r3[e3];
    return Array.isArray(s3) ? s3.map((i3, o3) => n2.default.get({ listKey: e3, parentPath: this, parent: r3, container: s3, key: o3 }).setContext(t3)) : n2.default.get({ parentPath: this, parent: r3, container: r3, key: e3 }).setContext(t3);
  }, t2._getPattern = function(e3, t3) {
    let r3 = this;
    for (const n3 of e3) r3 = "." === n3 ? r3.parentPath : Array.isArray(r3) ? r3[n3] : r3.get(n3, t3);
    return r3;
  }, t2.get = function(e3) {
    let t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    true === t3 && (t3 = this.context);
    const r3 = e3.split(".");
    return 1 === r3.length ? this._getKey(e3, t3) : this._getPattern(r3, t3);
  }, t2.getAllNextSiblings = function() {
    let e3 = this.key, t3 = this.getSibling(++e3);
    const r3 = [];
    for (; t3.node; ) r3.push(t3), t3 = this.getSibling(++e3);
    return r3;
  }, t2.getAllPrevSiblings = function() {
    let e3 = this.key, t3 = this.getSibling(--e3);
    const r3 = [];
    for (; t3.node; ) r3.push(t3), t3 = this.getSibling(--e3);
    return r3;
  }, t2.getBindingIdentifierPaths = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    const r3 = [this], n3 = /* @__PURE__ */ Object.create(null);
    for (; r3.length; ) {
      const s3 = r3.shift();
      if (!s3) continue;
      if (!s3.node) continue;
      const o3 = i2.keys[s3.node.type];
      if (s3.isIdentifier()) e3 ? (n3[s3.node.name] = n3[s3.node.name] || []).push(s3) : n3[s3.node.name] = s3;
      else if (s3.isExportDeclaration()) {
        const e4 = s3.get("declaration");
        a2(e4) && r3.push(e4);
      } else {
        if (t3) {
          if (s3.isFunctionDeclaration()) {
            r3.push(s3.get("id"));
            continue;
          }
          if (s3.isFunctionExpression()) continue;
        }
        if (o3) for (let e4 = 0; e4 < o3.length; e4++) {
          const t4 = o3[e4], n4 = s3.get(t4);
          Array.isArray(n4) ? r3.push(...n4) : n4.node && r3.push(n4);
        }
      }
    }
    return n3;
  }, t2.getBindingIdentifiers = function(e3) {
    return i2(this.node, e3);
  }, t2.getCompletionRecords = function() {
    return y(this, { canHaveBreak: false, shouldPopulateBreak: false, inCaseClause: false }).map((e3) => e3.path);
  }, t2.getNextSibling = function() {
    return this.getSibling(this.key + 1);
  }, t2.getOpposite = function() {
    return "left" === this.key ? this.getSibling("right") : "right" === this.key ? this.getSibling("left") : null;
  }, t2.getOuterBindingIdentifierPaths = function() {
    let e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    return this.getBindingIdentifierPaths(e3, true);
  }, t2.getOuterBindingIdentifiers = function(e3) {
    return o2(this.node, e3);
  }, t2.getPrevSibling = function() {
    return this.getSibling(this.key - 1);
  }, t2.getSibling = function(e3) {
    return n2.default.get({ parentPath: this.parentPath, parent: this.parent, container: this.container, listKey: this.listKey, key: e3 }).setContext(this.context);
  };
  var n2 = r2(28), s2 = r2(0);
  const { getBindingIdentifiers: i2, getOuterBindingIdentifiers: o2, isDeclaration: a2, numericLiteral: l, unaryExpression: c } = s2, u = 0, p = 1;
  function d(e3, t3, r3) {
    return e3 && t3.push(...y(e3, r3)), t3;
  }
  function f(e3) {
    e3.forEach((e4) => {
      e4.type = p;
    });
  }
  function h(e3, t3) {
    e3.forEach((e4) => {
      e4.path.isBreakStatement({ label: null }) && (t3 ? e4.path.replaceWith(c("void", l(0))) : e4.path.remove());
    });
  }
  function m(e3, t3) {
    const r3 = [];
    if (t3.canHaveBreak) {
      let n3 = [];
      for (let s3 = 0; s3 < e3.length; s3++) {
        const i3 = e3[s3], o3 = Object.assign({}, t3, { inCaseClause: false });
        i3.isBlockStatement() && (t3.inCaseClause || t3.shouldPopulateBreak) ? o3.shouldPopulateBreak = true : o3.shouldPopulateBreak = false;
        const a3 = y(i3, o3);
        if (a3.length > 0 && a3.every((e4) => e4.type === p)) {
          n3.length > 0 && a3.every((e4) => e4.path.isBreakStatement({ label: null })) ? (f(n3), r3.push(...n3), n3.some((e4) => e4.path.isDeclaration()) && (r3.push(...a3), h(a3, true)), h(a3, false)) : (r3.push(...a3), t3.shouldPopulateBreak || h(a3, true));
          break;
        }
        if (s3 === e3.length - 1) r3.push(...a3);
        else {
          n3 = [];
          for (let e4 = 0; e4 < a3.length; e4++) {
            const t4 = a3[e4];
            t4.type === p && r3.push(t4), t4.type === u && n3.push(t4);
          }
        }
      }
    } else if (e3.length) for (let n3 = e3.length - 1; n3 >= 0; n3--) {
      const s3 = y(e3[n3], t3);
      if (s3.length > 1 || 1 === s3.length && !s3[0].path.isVariableDeclaration()) {
        r3.push(...s3);
        break;
      }
    }
    return r3;
  }
  function y(e3, t3) {
    let r3 = [];
    if (e3.isIfStatement()) r3 = d(e3.get("consequent"), r3, t3), r3 = d(e3.get("alternate"), r3, t3);
    else {
      if (e3.isDoExpression() || e3.isFor() || e3.isWhile() || e3.isLabeledStatement()) return d(e3.get("body"), r3, t3);
      if (e3.isProgram() || e3.isBlockStatement()) return m(e3.get("body"), t3);
      if (e3.isFunction()) return y(e3.get("body"), t3);
      if (e3.isTryStatement()) r3 = d(e3.get("block"), r3, t3), r3 = d(e3.get("handler"), r3, t3);
      else {
        if (e3.isCatchClause()) return d(e3.get("body"), r3, t3);
        if (e3.isSwitchStatement()) return function(e4, t4, r4) {
          let n3 = [];
          for (let s3 = 0; s3 < e4.length; s3++) {
            const i3 = y(e4[s3], r4), o3 = [], a3 = [];
            for (const e5 of i3) e5.type === u && o3.push(e5), e5.type === p && a3.push(e5);
            o3.length && (n3 = o3), t4.push(...a3);
          }
          return t4.push(...n3), t4;
        }(e3.get("cases"), r3, t3);
        if (e3.isSwitchCase()) return m(e3.get("consequent"), { canHaveBreak: true, shouldPopulateBreak: false, inCaseClause: true });
        e3.isBreakStatement() ? r3.push(/* @__PURE__ */ function(e4) {
          return { type: p, path: e4 };
        }(e3)) : r3.push(/* @__PURE__ */ function(e4) {
          return { type: u, path: e4 };
        }(e3));
      }
    }
    return r3;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.addComment = function(e3, t3, r3) {
    s2(this.node, e3, t3, r3);
  }, t2.addComments = function(e3, t3) {
    i2(this.node, e3, t3);
  }, t2.shareCommentsWithSiblings = function() {
    if ("string" == typeof this.key) return;
    const e3 = this.node;
    if (!e3) return;
    const t3 = e3.trailingComments, r3 = e3.leadingComments;
    if (!t3 && !r3) return;
    const n3 = this.getSibling(this.key - 1), s3 = this.getSibling(this.key + 1), i3 = Boolean(n3.node), a2 = Boolean(s3.node);
    i3 && (r3 && n3.addComments("trailing", o2(r3, n3.node.trailingComments)), t3 && !a2 && n3.addComments("trailing", t3)), a2 && (t3 && s3.addComments("leading", o2(t3, s3.node.leadingComments)), r3 && !i3 && s3.addComments("leading", r3));
  };
  var n2 = r2(0);
  const { addComment: s2, addComments: i2 } = n2;
  function o2(e3, t3) {
    if (null == t3 || !t3.length) return e3;
    const r3 = new Set(t3);
    return e3.filter((e4) => !r3.has(e4));
  }
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = class {
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(e3, t3) {
      return new (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : TypeError)(t3);
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(37), s2 = r2(446);
  const i2 = Object.assign({ __proto__: null }, s2.default);
  t2.default = i2;
  const o2 = (e3) => (t3) => ({ minVersion: e3, ast: () => n2.default.program.ast(t3) });
  i2.AwaitValue = o2("7.0.0-beta.0")`
    export default function _AwaitValue(value) {
      this.wrapped = value;
    }
  `, i2.wrapAsyncGenerator = o2("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`, i2.asyncToGenerator = o2("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }
`, i2.classCallCheck = o2("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`, i2.createClass = o2("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
`, i2.defineEnumerableProperties = o2("7.0.0-beta.0")`
    export default function _defineEnumerableProperties(obj, descs) {
      for (var key in descs) {
        var desc = descs[key];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, key, desc);
      }

      // Symbols are not enumerated over by for-in loops. If native
      // Symbols are available, fetch all of the descs object's own
      // symbol properties and define them on our target object too.
      if (Object.getOwnPropertySymbols) {
        var objectSymbols = Object.getOwnPropertySymbols(descs);
        for (var i = 0; i < objectSymbols.length; i++) {
          var sym = objectSymbols[i];
          var desc = descs[sym];
          desc.configurable = desc.enumerable = true;
          if ("value" in desc) desc.writable = true;
          Object.defineProperty(obj, sym, desc);
        }
      }
      return obj;
    }
`, i2.defaults = o2("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`, i2.defineProperty = o2("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  export default function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`, i2.extends = o2("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`, i2.objectSpread = o2("7.0.0-beta.0")`
    import defineProperty from "defineProperty";

    export default function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = (arguments[i] != null) ? Object(arguments[i]) : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
  `, i2.inherits = o2("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    // We can't use defineProperty to set the prototype in a single step because it
    // doesn't work in Chrome <= 36. https://github.com/babel/babel/issues/14056
    // V8 bug: https://bugs.chromium.org/p/v8/issues/detail?id=3334
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`, i2.inheritsLoose = o2("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`, i2.getPrototypeOf = o2("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`, i2.setPrototypeOf = o2("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
    return _setPrototypeOf(o, p);
  }
`, i2.isNativeFunction = o2("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    try {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    } catch (e) {
      // Firefox 31 throws when "toString" is applied to an HTMLElement
      return typeof fn === "function";
    }
  }
`, i2.wrapNativeSuper = o2("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`, i2.instanceof = o2("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`, i2.interopRequireDefault = o2("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`, i2.newArrowCheck = o2("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`, i2.objectDestructuringEmpty = o2("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure " + obj);
  }
`, i2.objectWithoutPropertiesLoose = o2("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`, i2.objectWithoutProperties = o2("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`, i2.assertThisInitialized = o2("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`, i2.possibleConstructorReturn = o2("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return assertThisInitialized(self);
  }
`, i2.createSuper = o2("7.9.0")`
    import getPrototypeOf from "getPrototypeOf";
    import isNativeReflectConstruct from "isNativeReflectConstruct";
    import possibleConstructorReturn from "possibleConstructorReturn";

    export default function _createSuper(Derived) {
      var hasNativeReflectConstruct = isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          // NOTE: This doesn't work if this.__proto__.constructor has been modified.
          var NewTarget = getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return possibleConstructorReturn(this, result);
      }
    }
`, i2.superPropBase = o2("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`, i2.get = o2("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          // STEP 3. If receiver is not present, then set receiver to target.
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
`, i2.set = o2("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new TypeError('failed to set property');
    }

    return value;
  }
`, i2.taggedTemplateLiteral = o2("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`, i2.taggedTemplateLiteralLoose = o2("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`, i2.readOnlyError = o2("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is read-only");
  }
`, i2.writeOnlyError = o2("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is write-only");
  }
`, i2.classNameTDZError = o2("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new ReferenceError("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`, i2.temporalUndefined = o2("7.0.0-beta.0")`
  // This function isn't mean to be called, but to be used as a reference.
  // We can't use a normal object because it isn't hoisted.
  export default function _temporalUndefined() {}
`, i2.tdz = o2("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`, i2.temporalRef = o2("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`, i2.slicedToArray = o2("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`, i2.slicedToArrayLoose = o2("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`, i2.toArray = o2("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`, i2.toConsumableArray = o2("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`, i2.arrayWithoutHoles = o2("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`, i2.arrayWithHoles = o2("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`, i2.maybeArrayLike = o2("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`, i2.iterableToArray = o2("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
`, i2.unsupportedIterableToArray = o2("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`, i2.arrayLikeToArray = o2("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`, i2.nonIterableSpread = o2("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`, i2.nonIterableRest = o2("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`, i2.createForOfIteratorHelper = o2("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`, i2.createForOfIteratorHelperLoose = o2("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length === "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
`, i2.skipFirstGeneratorNext = o2("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`, i2.initializerWarningHelper = o2("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'transform-class-properties is enabled and runs after the decorators transform.'
        );
    }
`, i2.initializerDefineProperty = o2("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`, i2.applyDecoratedDescriptor = o2("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`, i2.classPrivateFieldLooseKey = o2("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`, i2.classPrivateFieldLooseBase = o2("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`, i2.classPrivateFieldGet = o2("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`, i2.classPrivateFieldSet = o2("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`, i2.classPrivateFieldDestructureSet = o2("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`, i2.classExtractFieldDescriptor = o2("7.13.10")`
  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
  }
`, i2.classStaticPrivateFieldSpecGet = o2("7.0.2")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`, i2.classStaticPrivateFieldSpecSet = o2("7.0.2")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`, i2.classStaticPrivateMethodGet = o2("7.3.2")`
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    return method;
  }
`, i2.classStaticPrivateMethodSet = o2("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`, i2.classApplyDescriptorGet = o2("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`, i2.classApplyDescriptorSet = o2("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
`, i2.classApplyDescriptorDestructureSet = o2("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }
`, i2.classStaticPrivateFieldDestructureSet = o2("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`, i2.classCheckPrivateStaticAccess = o2("7.13.10")`
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
  }
`, i2.classCheckPrivateStaticFieldDescriptor = o2("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
  }
`, i2.decorate = o2("7.1.5")`
  import toArray from "toArray";
  import toPropertyKey from "toPropertyKey";

  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () => any,
        set?: (v: any) => void,
        configurable: boolean,
        enumerable: boolean,
      };

  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };

  type Placement = "static" | "prototype" | "own";
  type Key = string | symbol; // PrivateName is not supported yet.

  type ElementDescriptor =
    | {
        kind: "method",
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: "field",
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () => any,
      };

  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
  };

  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: "Descriptor",
    kind: "class",
    elements: ElementDescriptor[],
  };

  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;

  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: "method",
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: "field",
        value: () => any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };

  declare function ClassFactory<C>(initialize: (instance: C) => void): {
    F: Class<C>,
    d: ElementDefinition[]
  }

  */

  /*::
  // Various combinations with/without extras and with one or many finishers

  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };

  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };

  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };

  */

  /*::

  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };

  */

  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
    mixins /*: ?Array<Function> */,
  ) /*: Class<*> */ {
    var api = _getDecoratorsApi();
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],

      // InitializeInstanceElements
      initializeInstanceElements: function(
        /*::<C>*/ O /*: C */,
        elements /*: ElementDescriptor[] */,
      ) {
        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },

      // InitializeClassElements
      initializeClassElements: function(
        /*::<C>*/ F /*: Class<C> */,
        elements /*: ElementDescriptor[] */,
      ) {
        var proto = F.prototype;

        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            var placement = element.placement;
            if (
              element.kind === kind &&
              (placement === "static" || placement === "prototype")
            ) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      // DefineClassElement
      defineClassElement: function(
        /*::<C>*/ receiver /*: C | Class<C> */,
        element /*: ElementDescriptor */,
      ) {
        var descriptor /*: PropertyDescriptor */ = element.descriptor;
        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver),
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      // DecorateClass
      decorateClass: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var newElements /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];
        var placements /*: Placements */ = {
          static: [],
          prototype: [],
          own: [],
        };

        elements.forEach(function(element /*: ElementDescriptor */) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element /*: ElementDescriptor */) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
            element,
            placements,
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return { elements: newElements, finishers: finishers };
        }

        var result /*: ElementsFinishers */ = this.decorateConstructor(
          newElements,
          decorators,
        );
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      // AddElementPlacement
      addElementPlacement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
        silent /*: boolean */,
      ) {
        var keys = placements[element.placement];
        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }
        keys.push(element.key);
      },

      // DecorateElement
      decorateElement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
      ) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i >= 0;
          i--
        ) {
          // (inlined) RemoveElementPlacement
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
            element,
          );
          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
              elementObject,
          );

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras /*: ElementDescriptor[] | void */ =
            elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }
            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      // DecorateConstructor
      decorateConstructor: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var finishers /*: ClassFinisher[] */ = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
            (0, decorators[i])(obj) /*: ClassObject */ || obj,
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &&
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    "Duplicated element (" + elements[j].key + ")",
                  );
                }
              }
            }
          }
        }

        return { elements: elements, finishers: finishers };
      },

      // FromElementDescriptor
      fromElementDescriptor: function(
        element /*: ElementDescriptor */,
      ) /*: ElementObject */ {
        var obj /*: ElementObject */ = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor,
        };

        var desc = {
          value: "Descriptor",
          configurable: true,
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        if (element.kind === "field") obj.initializer = element.initializer;

        return obj;
      },

      // ToElementDescriptors
      toElementDescriptors: function(
        elementObjects /*: ElementObject[] */,
      ) /*: ElementDescriptor[] */ {
        if (elementObjects === undefined) return;
        return toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },

      // ToElementDescriptor
      toElementDescriptor: function(
        elementObject /*: ElementObject */,
      ) /*: ElementDescriptor */ {
        var kind = String(elementObject.kind);
        if (kind !== "method" && kind !== "field") {
          throw new TypeError(
            'An element descriptor\\'s .kind property must be either "method" or' +
              ' "field", but a decorator created an element descriptor with' +
              ' .kind "' +
              kind +
              '"',
          );
        }

        var key = toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);
        if (
          placement !== "static" &&
          placement !== "prototype" &&
          placement !== "own"
        ) {
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"',
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(
            descriptor,
            "get",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "set",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "value",
            "The property descriptor of a field descriptor",
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          "finisher",
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: "Descriptor", configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class") {
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"',
          );
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class<*> */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static
        ? "static"
        : def.kind === "field"
        ? "own"
        : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }

`, i2.classPrivateMethodGet = o2("7.1.6")`
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
  }
`, i2.checkPrivateRedeclaration = o2("7.14.1")`
  export default function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
`, i2.classPrivateFieldInitSpec = o2("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
    checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
`, i2.classPrivateMethodInitSpec = o2("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateMethodInitSpec(obj, privateSet) {
    checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }
`, i2.classPrivateMethodSet = o2("7.1.6")`
    export default function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }
  `, i2.identity = o2("7.17.0")`
  export default function _identity(x) {
    return x;
  }
`, i2.nullishReceiverError = o2("7.22.6")`
  export default function _nullishReceiverError(r) {
    throw new TypeError("Cannot set property of null or undefined.");
  }
`;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(37);
  function s2(e3, t3) {
    return Object.freeze({ minVersion: e3, ast: () => n2.default.program.ast(t3, { preserveComments: true }) });
  }
  t2.default = Object.freeze({ AsyncGenerator: s2("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};'), OverloadYield: s2("7.18.14", "export default function _OverloadYield(t,e){this.v=t,this.k=e}"), applyDecs: s2("7.17.8", 'import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&"undefined"!=typeof console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===o?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}export default function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}'), applyDecs2203: s2("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;export default function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}'), applyDecs2203R: s2("7.20.0", 'import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}'), applyDecs2301: s2("7.21.0", 'import checkInRHS from"checkInRHS";import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((function(e,t){return p.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}'), applyDecs2305: s2("7.21.0", 'import checkInRHS from"checkInRHS";import setFunctionName from"setFunctionName";import toPropertyKey from"toPropertyKey";export default function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}function c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeError(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName((function(){return g(this)}),n,"get"),set:function(e){t[4](this,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,t){if(e.v)throw new Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(e,t);return t})),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}'), asyncGeneratorDelegate: s2("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}'), asyncIterator: s2("7.15.9", 'export default function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}'), awaitAsyncGenerator: s2("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}'), callSuper: s2("7.23.8", 'import getPrototypeOf from"getPrototypeOf";import isNativeReflectConstruct from"isNativeReflectConstruct";import possibleConstructorReturn from"possibleConstructorReturn";export default function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Reflect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}'), checkInRHS: s2("7.20.5", `export default function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(null!==e?typeof e:"null"));return e}`), construct: s2("7.0.0-beta.0", 'import setPrototypeOf from"setPrototypeOf";import isNativeReflectConstruct from"isNativeReflectConstruct";export default function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}'), defineAccessor: s2("7.20.7", "export default function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}"), dispose: s2("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=(new Error).stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}export default function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}'), importDeferProxy: s2("7.23.0", "export default function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}"), interopRequireWildcard: s2("7.14.0", 'function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}export default function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&Object.prototype.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.default=e,t&&t.set(e,n),n}'), isNativeReflectConstruct: s2("7.9.0", "export default function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}"), iterableToArrayLimit: s2("7.0.0-beta.0", 'export default function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}'), iterableToArrayLimitLoose: s2("7.0.0-beta.0", 'export default function _iterableToArrayLimitLoose(e,r){var t=e&&("undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"]);if(null!=t){var o,l=[];for(t=t.call(e);e.length<r&&!(o=t.next()).done;)l.push(o.value);return l}}'), jsx: s2("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=new Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}'), objectSpread2: s2("7.5.0", 'import defineProperty from"defineProperty";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}export default function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}'), regeneratorRuntime: s2("7.18.0", `export default function _regeneratorRuntime(){"use strict";
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:function(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw new Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}`), setFunctionName: s2("7.23.6", 'export default function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineProperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}'), toPrimitive: s2("7.1.5", 'export default function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}'), toPropertyKey: s2("7.1.5", 'import toPrimitive from"toPrimitive";export default function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:String(i)}'), typeof: s2("7.0.0-beta.0", 'export default function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}'), using: s2("7.22.0", 'export default function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:n,d:r,a:e}),n}'), usingCtx: s2("7.23.9", 'export default function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,n){var e=new Error;return e.name="SuppressedError",e.suppressed=n,e.error=r,e},n={},e=[];function using(r,n){if(null!=n){if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(r)var o=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==o&&(o=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof o)throw new TypeError("Property [Symbol.dispose] is not a function.");e.push({v:n,d:o,a:r})}return n}return{e:n,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o=this.e;function next(){for(;r=e.pop();)try{var r,t=r.d.call(r.v);if(r.a)return Promise.resolve(t).then(next,err)}catch(r){return err(r)}if(o!==n)throw o}function err(e){return o=o!==n?new r(o,e):e,next()}return next()}}}'), wrapRegExp: s2("7.19.0", 'import setPrototypeOf from"setPrototypeOf";import inherits from"inherits";export default function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=new RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)>/g,(function(e,r){var t=o[r];return"$"+(Array.isArray(t)?t.join("$"):t)})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}') });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(25), s2 = r2(0), i2 = r2(448), o2 = r2(250);
  const { numericLiteral: a2, sequenceExpression: l } = s2;
  t2.default = class {
    constructor(e3, t3, r3) {
      this._defaultOpts = { importedSource: null, importedType: "commonjs", importedInterop: "babel", importingInterop: "babel", ensureLiveReference: false, ensureNoContext: false, importPosition: "before" };
      const n3 = e3.find((e4) => e4.isProgram());
      this._programPath = n3, this._programScope = n3.scope, this._hub = n3.hub, this._defaultOpts = this._applyDefaults(t3, r3, true);
    }
    addDefault(e3, t3) {
      return this.addNamed("default", e3, t3);
    }
    addNamed(e3, t3, r3) {
      return n2("string" == typeof e3), this._generateImport(this._applyDefaults(t3, r3), e3);
    }
    addNamespace(e3, t3) {
      return this._generateImport(this._applyDefaults(e3, t3), null);
    }
    addSideEffect(e3, t3) {
      return this._generateImport(this._applyDefaults(e3, t3), void 0);
    }
    _applyDefaults(e3, t3) {
      let r3, s3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      return "string" == typeof e3 ? r3 = Object.assign({}, this._defaultOpts, { importedSource: e3 }, t3) : (n2(!t3, "Unexpected secondary arguments."), r3 = Object.assign({}, this._defaultOpts, e3)), !s3 && t3 && (void 0 !== t3.nameHint && (r3.nameHint = t3.nameHint), void 0 !== t3.blockHoist && (r3.blockHoist = t3.blockHoist)), r3;
    }
    _generateImport(e3, t3) {
      const r3 = "default" === t3, n3 = !!t3 && !r3, s3 = null === t3, { importedSource: c, importedType: u, importedInterop: p, importingInterop: d, ensureLiveReference: f, ensureNoContext: h, nameHint: m, importPosition: y, blockHoist: g } = e3;
      let b = m || t3;
      const v = (0, o2.default)(this._programPath), E = v && "node" === d, S = v && "babel" === d;
      if ("after" === y && !v) throw new Error('"importPosition": "after" is only supported in modules');
      const x = new i2.default(c, this._programScope, this._hub);
      if ("es6" === u) {
        if (!E && !S) throw new Error("Cannot import an ES6 module from CommonJS");
        x.import(), s3 ? x.namespace(m || c) : (r3 || n3) && x.named(b, t3);
      } else {
        if ("commonjs" !== u) throw new Error(`Unexpected interopType "${u}"`);
        if ("babel" === p) if (E) {
          b = "default" !== b ? b : c;
          const e4 = `${c}$es6Default`;
          x.import(), s3 ? x.default(e4).var(b || c).wildcardInterop() : r3 ? f ? x.default(e4).var(b || c).defaultInterop().read("default") : x.default(e4).var(b).defaultInterop().prop(t3) : n3 && x.default(e4).read(t3);
        } else S ? (x.import(), s3 ? x.namespace(b || c) : (r3 || n3) && x.named(b, t3)) : (x.require(), s3 ? x.var(b || c).wildcardInterop() : (r3 || n3) && f ? r3 ? (b = "default" !== b ? b : c, x.var(b).read(t3), x.defaultInterop()) : x.var(c).read(t3) : r3 ? x.var(b).defaultInterop().prop(t3) : n3 && x.var(b).prop(t3));
        else if ("compiled" === p) E ? (x.import(), s3 ? x.default(b || c) : (r3 || n3) && x.default(c).read(b)) : S ? (x.import(), s3 ? x.namespace(b || c) : (r3 || n3) && x.named(b, t3)) : (x.require(), s3 ? x.var(b || c) : (r3 || n3) && (f ? x.var(c).read(b) : x.prop(t3).var(b)));
        else {
          if ("uncompiled" !== p) throw new Error(`Unknown importedInterop "${p}".`);
          if (r3 && f) throw new Error("No live reference for commonjs default");
          E ? (x.import(), s3 ? x.default(b || c) : r3 ? x.default(b) : n3 && x.default(c).read(b)) : S ? (x.import(), s3 ? x.default(b || c) : r3 ? x.default(b) : n3 && x.named(b, t3)) : (x.require(), s3 ? x.var(b || c) : r3 ? x.var(b) : n3 && (f ? x.var(c).read(b) : x.var(b).prop(t3)));
        }
      }
      const { statements: T, resultName: w } = x.done();
      return this._insertStatements(T, y, g), (r3 || n3) && h && "Identifier" !== w.type ? l([a2(0), w]) : w;
    }
    _insertStatements(e3) {
      let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "before", r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3;
      const n3 = this._programPath.get("body");
      if ("after" === t3) {
        for (let t4 = n3.length - 1; t4 >= 0; t4--) if (n3[t4].isImportDeclaration()) return void n3[t4].insertAfter(e3);
      } else {
        e3.forEach((e4) => {
          e4._blockHoist = r3;
        });
        const t4 = n3.find((e4) => {
          const t5 = e4.node._blockHoist;
          return Number.isFinite(t5) && t5 < 4;
        });
        if (t4) return void t4.insertBefore(e3);
      }
      this._programPath.unshiftContainer("body", e3);
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(25), s2 = r2(0);
  const { callExpression: i2, cloneNode: o2, expressionStatement: a2, identifier: l, importDeclaration: c, importDefaultSpecifier: u, importNamespaceSpecifier: p, importSpecifier: d, memberExpression: f, stringLiteral: h, variableDeclaration: m, variableDeclarator: y } = s2;
  t2.default = class {
    constructor(e3, t3, r3) {
      this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = t3, this._hub = r3, this._importedSource = e3;
    }
    done() {
      return { statements: this._statements, resultName: this._resultName };
    }
    import() {
      return this._statements.push(c([], h(this._importedSource))), this;
    }
    require() {
      return this._statements.push(a2(i2(l("require"), [h(this._importedSource)]))), this;
    }
    namespace() {
      let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "namespace";
      const t3 = this._scope.generateUidIdentifier(e3), r3 = this._statements[this._statements.length - 1];
      return n2("ImportDeclaration" === r3.type), n2(0 === r3.specifiers.length), r3.specifiers = [p(t3)], this._resultName = o2(t3), this;
    }
    default(e3) {
      const t3 = this._scope.generateUidIdentifier(e3), r3 = this._statements[this._statements.length - 1];
      return n2("ImportDeclaration" === r3.type), n2(0 === r3.specifiers.length), r3.specifiers = [u(t3)], this._resultName = o2(t3), this;
    }
    named(e3, t3) {
      if ("default" === t3) return this.default(e3);
      const r3 = this._scope.generateUidIdentifier(e3), s3 = this._statements[this._statements.length - 1];
      return n2("ImportDeclaration" === s3.type), n2(0 === s3.specifiers.length), s3.specifiers = [d(r3, l(t3))], this._resultName = o2(r3), this;
    }
    var(e3) {
      const t3 = this._scope.generateUidIdentifier(e3);
      let r3 = this._statements[this._statements.length - 1];
      return "ExpressionStatement" !== r3.type && (n2(this._resultName), r3 = a2(this._resultName), this._statements.push(r3)), this._statements[this._statements.length - 1] = m("var", [y(t3, r3.expression)]), this._resultName = o2(t3), this;
    }
    defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    }
    wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    }
    _interop(e3) {
      const t3 = this._statements[this._statements.length - 1];
      return "ExpressionStatement" === t3.type ? t3.expression = i2(e3, [t3.expression]) : "VariableDeclaration" === t3.type ? (n2(1 === t3.declarations.length), t3.declarations[0].init = i2(e3, [t3.declarations[0].init])) : n2.fail("Unexpected type."), this;
    }
    prop(e3) {
      const t3 = this._statements[this._statements.length - 1];
      return "ExpressionStatement" === t3.type ? t3.expression = f(t3.expression, l(e3)) : "VariableDeclaration" === t3.type ? (n2(1 === t3.declarations.length), t3.declarations[0].init = f(t3.declarations[0].init, l(e3))) : n2.fail("Unexpected type:" + t3.type), this;
    }
    read(e3) {
      this._resultName = f(this._resultName, l(e3));
    }
  };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    (0, s2.traverse)(e3.node, Object.assign({}, a2, { noScope: true }));
  };
  var n2 = r2(33), s2 = r2(1);
  const { numericLiteral: i2, unaryExpression: o2 } = s2.types, a2 = s2.traverse.visitors.merge([n2.default, { ThisExpression(e3) {
    e3.replaceWith(o2("void", i2(0), true));
  } }]);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    const n3 = /* @__PURE__ */ new Map(), s3 = /* @__PURE__ */ new Map(), o3 = (t4) => {
      e3.requeue(t4);
    };
    for (const [e4, r4] of t3.source) {
      for (const [t4, s4] of r4.imports) n3.set(t4, [e4, s4, null]);
      for (const t4 of r4.importsNamespace) n3.set(t4, [e4, null, t4]);
    }
    for (const [e4, r4] of t3.local) {
      let t4 = s3.get(e4);
      t4 || (t4 = [], s3.set(e4, t4)), t4.push(...r4.names);
    }
    const a3 = { metadata: t3, requeueInParent: o3, scope: e3.scope, exported: s3 };
    e3.traverse(P, a3);
    const l2 = /* @__PURE__ */ new Set([...Array.from(n3.keys()), ...Array.from(s3.keys())]);
    (0, i2.default)(e3, l2, false);
    const c2 = { seen: /* @__PURE__ */ new WeakSet(), metadata: t3, requeueInParent: o3, scope: e3.scope, imported: n3, exported: s3, buildImportReference(e4, n4) {
      let [s4, i3, o4] = e4;
      const a4 = t3.source.get(s4);
      var l3;
      if (a4.referenced = true, o4) return a4.wrap && (n4 = null != (l3 = r3(n4, a4.wrap)) ? l3 : n4), n4;
      let c3 = u(a4.name);
      var p2;
      if (a4.wrap && (c3 = null != (p2 = r3(c3, a4.wrap)) ? p2 : c3), "default" === i3 && "node-default" === a4.interop) return c3;
      const d2 = t3.stringSpecifiers.has(i3);
      return v(c3, d2 ? x(i3) : u(i3), d2);
    } };
    e3.traverse(O, c2);
  };
  var n2 = r2(25), s2 = r2(1), i2 = r2(251);
  const { assignmentExpression: o2, cloneNode: a2, expressionStatement: l, getOuterBindingIdentifiers: c, identifier: u, isArrowFunctionExpression: p, isClassExpression: d, isFunctionExpression: f, isIdentifier: h, isMemberExpression: m, isVariableDeclaration: y, jsxIdentifier: g, jsxMemberExpression: b, memberExpression: v, numericLiteral: E, sequenceExpression: S, stringLiteral: x, variableDeclaration: T, variableDeclarator: w } = s2.types, P = { Scope(e3) {
    e3.skip();
  }, ClassDeclaration(e3) {
    const { requeueInParent: t3, exported: r3, metadata: n3 } = this, { id: s3 } = e3.node;
    if (!s3) throw new Error("Expected class to have a name");
    const i3 = s3.name, o3 = r3.get(i3) || [];
    if (o3.length > 0) {
      const r4 = l(A(n3, o3, u(i3), e3.scope));
      r4._blockHoist = e3.node._blockHoist, t3(e3.insertAfter(r4)[0]);
    }
  }, VariableDeclaration(e3) {
    const { requeueInParent: t3, exported: r3, metadata: n3 } = this, s3 = "var" === e3.node.kind;
    for (const i3 of e3.get("declarations")) {
      const { id: o3 } = i3.node;
      let { init: a3 } = i3.node;
      if (!h(o3) || !r3.has(o3.name) || p(a3) || f(a3) && !a3.id || d(a3) && !a3.id) {
        for (const s4 of Object.keys(i3.getOuterBindingIdentifiers())) if (r3.has(s4)) {
          const i4 = l(A(n3, r3.get(s4), u(s4), e3.scope));
          i4._blockHoist = e3.node._blockHoist, t3(e3.insertAfter(i4)[0]);
        }
      } else {
        if (!a3) {
          if (s3) continue;
          a3 = e3.scope.buildUndefinedNode();
        }
        i3.node.init = A(n3, r3.get(o3.name), a3, e3.scope), t3(i3.get("init"));
      }
    }
  } }, A = (e3, t3, r3, n3) => {
    const s3 = e3.exportName;
    for (let e4 = n3; null != e4; e4 = e4.parent) e4.hasOwnBinding(s3) && e4.rename(s3);
    return (t3 || []).reduce((t4, r4) => {
      const { stringSpecifiers: n4 } = e3, i3 = n4.has(r4);
      return o2("=", v(u(s3), i3 ? x(r4) : u(r4), i3), t4);
    }, r3);
  }, C = (e3) => s2.template.expression.ast`
    (function() {
      throw new Error('"' + '${e3}' + '" is read-only.');
    })()
  `, O = { ReferencedIdentifier(e3) {
    const { seen: t3, buildImportReference: r3, scope: n3, imported: s3, requeueInParent: i3 } = this;
    if (t3.has(e3.node)) return;
    t3.add(e3.node);
    const o3 = e3.node.name, a3 = s3.get(o3);
    if (a3) {
      if (function(e4) {
        do {
          switch (e4.parent.type) {
            case "TSTypeAnnotation":
            case "TSTypeAliasDeclaration":
            case "TSTypeReference":
            case "TypeAnnotation":
            case "TypeAlias":
              return true;
            case "ExportSpecifier":
              return "type" === e4.parentPath.parent.exportKind;
            default:
              if (e4.parentPath.isStatement() || e4.parentPath.isExpression()) return false;
          }
        } while (e4 = e4.parentPath);
      }(e3)) throw e3.buildCodeFrameError(`Cannot transform the imported binding "${o3}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
      const t4 = e3.scope.getBinding(o3);
      if (n3.getBinding(o3) !== t4) return;
      const s4 = r3(a3, e3.node);
      if (s4.loc = e3.node.loc, (e3.parentPath.isCallExpression({ callee: e3.node }) || e3.parentPath.isOptionalCallExpression({ callee: e3.node }) || e3.parentPath.isTaggedTemplateExpression({ tag: e3.node })) && m(s4)) e3.replaceWith(S([E(0), s4]));
      else if (e3.isJSXIdentifier() && m(s4)) {
        const { object: t5, property: r4 } = s4;
        e3.replaceWith(b(g(t5.name), g(r4.name)));
      } else e3.replaceWith(s4);
      i3(e3), e3.skip();
    }
  }, UpdateExpression(e3) {
    const { scope: t3, seen: r3, imported: n3, exported: s3, requeueInParent: i3, buildImportReference: l2 } = this;
    if (r3.has(e3.node)) return;
    r3.add(e3.node);
    const c2 = e3.get("argument");
    if (c2.isMemberExpression()) return;
    const p2 = e3.node;
    if (c2.isIdentifier()) {
      const r4 = c2.node.name;
      if (t3.getBinding(r4) !== e3.scope.getBinding(r4)) return;
      const i4 = s3.get(r4), d2 = n3.get(r4);
      if ((null == i4 ? void 0 : i4.length) > 0 || d2) if (d2) e3.replaceWith(o2(p2.operator[0] + "=", l2(d2, c2.node), C(r4)));
      else if (p2.prefix) e3.replaceWith(A(this.metadata, i4, a2(p2), e3.scope));
      else {
        const n4 = t3.generateDeclaredUidIdentifier(r4);
        e3.replaceWith(S([o2("=", a2(n4), a2(p2)), A(this.metadata, i4, u(r4), e3.scope), a2(n4)]));
      }
    }
    i3(e3), e3.skip();
  }, AssignmentExpression: { exit(e3) {
    const { scope: t3, seen: r3, imported: s3, exported: i3, requeueInParent: o3, buildImportReference: a3 } = this;
    if (r3.has(e3.node)) return;
    r3.add(e3.node);
    const c2 = e3.get("left");
    if (!c2.isMemberExpression()) if (c2.isIdentifier()) {
      const r4 = c2.node.name;
      if (t3.getBinding(r4) !== e3.scope.getBinding(r4)) return;
      const l2 = i3.get(r4), u2 = s3.get(r4);
      if ((null == l2 ? void 0 : l2.length) > 0 || u2) {
        n2("=" === e3.node.operator, "Path was not simplified");
        const t4 = e3.node;
        u2 && (t4.left = a3(u2, c2.node), t4.right = S([t4.right, C(r4)])), e3.replaceWith(A(this.metadata, l2, t4, e3.scope)), o3(e3);
      }
    } else {
      const r4 = c2.getOuterBindingIdentifiers(), n3 = Object.keys(r4).filter((r5) => t3.getBinding(r5) === e3.scope.getBinding(r5)), a4 = n3.find((e4) => s3.has(e4));
      a4 && (e3.node.right = S([e3.node.right, C(a4)]));
      const p2 = [];
      if (n3.forEach((t4) => {
        const r5 = i3.get(t4) || [];
        r5.length > 0 && p2.push(A(this.metadata, r5, u(t4), e3.scope));
      }), p2.length > 0) {
        let t4 = S(p2);
        e3.parentPath.isExpressionStatement() && (t4 = l(t4), t4._blockHoist = e3.parentPath.node._blockHoist), o3(e3.insertAfter(t4)[0]);
      }
    }
  } }, "ForOfStatement|ForInStatement"(e3) {
    const { scope: t3, node: r3 } = e3, { left: n3 } = r3, { exported: s3, imported: i3, scope: u2 } = this;
    if (!y(n3)) {
      let r4, p2 = false;
      const d2 = e3.get("body").scope;
      for (const e4 of Object.keys(c(n3))) u2.getBinding(e4) === t3.getBinding(e4) && (s3.has(e4) && (p2 = true, d2.hasOwnBinding(e4) && d2.rename(e4)), i3.has(e4) && !r4 && (r4 = e4));
      if (!p2 && !r4) return;
      e3.ensureBlock();
      const f2 = e3.get("body"), h2 = t3.generateUidIdentifierBasedOnNode(n3);
      e3.get("left").replaceWith(T("let", [w(a2(h2))])), t3.registerDeclaration(e3.get("left")), p2 && f2.unshiftContainer("body", l(o2("=", n3, h2))), r4 && f2.unshiftContainer("body", l(C(r4)));
    }
  } };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.toGetWrapperPayload = function(e3) {
    return (t3, r3) => {
      if (false === e3) return null;
      if ((0, s2.isSideEffectImport)(r3) || r3.reexportAll) return null;
      if (true === e3) return /\./.test(t3) ? null : "lazy";
      if (Array.isArray(e3)) return -1 === e3.indexOf(t3) ? null : "lazy";
      if ("function" == typeof e3) return e3(t3) ? "lazy" : null;
      throw new Error(".lazy must be a boolean, string array, or function");
    };
  }, t2.wrapReference = function(e3, t3) {
    return "lazy" === t3 ? n2.types.callExpression(e3, []) : null;
  };
  var n2 = r2(1), s2 = r2(252);
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = r2;
  {
    const e3 = r2;
    t2.default = r2 = function(t3, r3) {
      var n2, s2, i2, o2;
      return e3(t3, { moduleId: null != (n2 = r3.moduleId) ? n2 : t3.moduleId, moduleIds: null != (s2 = r3.moduleIds) ? s2 : t3.moduleIds, getModuleId: null != (i2 = r3.getModuleId) ? i2 : t3.getModuleId, moduleRoot: null != (o2 = r3.moduleRoot) ? o2 : t3.moduleRoot });
    };
  }
  function r2(e3, t3) {
    const { filename: r3, filenameRelative: n2 = r3, sourceRoot: s2 = t3.moduleRoot } = e3, { moduleId: i2, moduleIds: o2 = !!i2, getModuleId: a2, moduleRoot: l = s2 } = t3;
    if (!o2) return null;
    if (null != i2 && !a2) return i2;
    let c = null != l ? l + "/" : "";
    if (n2) {
      const e4 = null != s2 ? new RegExp("^" + s2 + "/?") : "";
      c += n2.replace(e4, "").replace(/\.(\w*?)$/, "");
    }
    return c = c.replace(/\\/g, "/"), a2 && a2(c) || c;
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(161);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2() {
    const e3 = r2(101);
    return s2 = function() {
      return e3;
    }, e3;
  }
  function i2() {
    const e3 = r2(37);
    return i2 = function() {
      return e3;
    }, e3;
  }
  function o2() {
    const e3 = r2(0);
    return o2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    let t3, r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "global";
    const n3 = { global: O, module: I, umd: _, var: k }[r3];
    if (!n3) throw new Error(`Unsupported output type ${r3}`);
    return t3 = n3(e3), (0, s2().default)(t3).code;
  };
  var a2 = r2(95);
  const { arrayExpression: l, assignmentExpression: c, binaryExpression: u, blockStatement: p, callExpression: d, cloneNode: f, conditionalExpression: h, exportNamedDeclaration: m, exportSpecifier: y, expressionStatement: g, functionExpression: b, identifier: v, memberExpression: E, objectExpression: S, program: x, stringLiteral: T, unaryExpression: w, variableDeclaration: P, variableDeclarator: A } = o2(), C = (e3) => i2().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(e3);
  function O(e3) {
    const t3 = v("babelHelpers"), r3 = [], n3 = b(null, [v("global")], p(r3)), s3 = x([g(d(n3, [h(u("===", w("typeof", v("global")), T("undefined")), v("self"), v("global"))]))]);
    return r3.push(P("var", [A(t3, c("=", E(v("global"), t3), S([])))])), N(r3, t3, e3), s3;
  }
  function I(e3) {
    const t3 = [], r3 = N(t3, null, e3);
    return t3.unshift(m(null, Object.keys(r3).map((e4) => y(f(r3[e4]), v(e4))))), x(t3, [], "module");
  }
  function _(e3) {
    const t3 = v("babelHelpers"), r3 = [];
    return r3.push(P("var", [A(t3, v("global"))])), N(r3, t3, e3), x([C({ FACTORY_PARAMETERS: v("global"), BROWSER_ARGUMENTS: c("=", E(v("root"), t3), S([])), COMMON_ARGUMENTS: v("exports"), AMD_ARGUMENTS: l([T("exports")]), FACTORY_BODY: r3, UMD_ROOT: v("this") })]);
  }
  function k(e3) {
    const t3 = v("babelHelpers"), r3 = [];
    r3.push(P("var", [A(t3, S([]))]));
    const n3 = x(r3);
    return N(r3, t3, e3), r3.push(g(t3)), n3;
  }
  function N(e3, t3, r3) {
    const s3 = (e4) => t3 ? E(t3, v(e4)) : v(`_${e4}`), i3 = {};
    return n2().list.forEach(function(t4) {
      if (r3 && r3.indexOf(t4) < 0) return;
      const o3 = i3[t4] = s3(t4);
      n2().ensure(t4, a2.default);
      const { nodes: l2 } = n2().get(t4, s3, o3);
      e3.push(...l2);
    }), i3;
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var s2 = r2(133), i2 = r2(134), o2 = r2(1), a2 = r2(135), l = r2(83), c = r2(292), u = r2(136);
  function p() {
    const e3 = r2(14);
    return p = function() {
      return e3;
    }, e3;
  }
  var d = r2(84), f = r2(85), h = r2(473), m = r2(474), y = r2(294), g = r2(140);
  function b(e3, t3) {
    return function* (r3, n3) {
      try {
        return yield* t3(r3, n3);
      } catch (t4) {
        var s3;
        throw /^\[BABEL\]/.test(t4.message) || (t4.message = `[BABEL] ${null != (s3 = e3.filename) ? s3 : "unknown file"}: ${t4.message}`), t4;
      }
    };
  }
  t2.default = n2()(function* (e3) {
    var t3;
    const r3 = yield* (0, y.default)(e3);
    if (!r3) return null;
    const { options: n3, context: s3, fileHandling: o3 } = r3;
    if ("ignored" === o3) return null;
    const a3 = {}, { plugins: c2, presets: p2 } = n3;
    if (!c2 || !p2) throw new Error("Assertion failure - plugins and presets exist");
    const d2 = Object.assign({}, s3, { targets: n3.targets }), h2 = (e4) => {
      const t4 = (0, l.getItemDescriptor)(e4);
      if (!t4) throw new Error("Assertion failure - must be config item");
      return t4;
    }, m2 = p2.map(h2), g2 = c2.map(h2), v2 = [[]], E2 = [], S2 = [], x2 = yield* b(s3, function* e4(t4, r4) {
      const n4 = [];
      for (let e5 = 0; e5 < t4.length; e5++) {
        const i3 = t4[e5];
        if (false !== i3.options) {
          try {
            var s4 = yield* O(i3, d2);
          } catch (r5) {
            throw "BABEL_UNKNOWN_OPTION" === r5.code && (0, f.checkNoUnwrappedItemOptionPairs)(t4, e5, "preset", r5), r5;
          }
          S2.push(s4.externalDependencies), i3.ownPass ? n4.push({ preset: s4.chain, pass: [] }) : n4.unshift({ preset: s4.chain, pass: r4 });
        }
      }
      if (n4.length > 0) {
        v2.splice(1, 0, ...n4.map((e5) => e5.pass).filter((e5) => e5 !== r4));
        for (const { preset: t5, pass: r5 } of n4) {
          if (!t5) return true;
          if (r5.push(...t5.plugins), yield* e4(t5.presets, r5)) return true;
          t5.options.forEach((e5) => {
            (0, i2.mergeOptions)(a3, e5);
          });
        }
      }
    })(m2, v2[0]);
    if (x2) return null;
    const w2 = a3;
    (0, i2.mergeOptions)(w2, n3);
    const P2 = Object.assign({}, d2, { assumptions: null != (t3 = w2.assumptions) ? t3 : {} });
    return yield* b(s3, function* () {
      v2[0].unshift(...g2);
      for (const t4 of v2) {
        const r4 = [];
        E2.push(r4);
        for (let n4 = 0; n4 < t4.length; n4++) {
          const s4 = t4[n4];
          if (false !== s4.options) {
            try {
              var e4 = yield* T(s4, P2);
            } catch (e5) {
              throw "BABEL_UNKNOWN_PLUGIN_PROPERTY" === e5.code && (0, f.checkNoUnwrappedItemOptionPairs)(t4, n4, "plugin", e5), e5;
            }
            r4.push(e4), S2.push(e4.externalDependencies);
          }
        }
      }
    })(), w2.plugins = E2[0], w2.presets = E2.slice(1).filter((e4) => e4.length > 0).map((e4) => ({ plugins: e4 })), w2.passPerPreset = w2.presets.length > 0, { options: w2, passes: E2, externalDependencies: (0, u.finalize)(S2) };
  });
  const v = (e3) => (0, d.makeWeakCache)(function(t3, r3) {
    let { value: n3, options: i3, dirname: a3, alias: l2 } = t3;
    return function* () {
      if (false === i3) throw new Error("Assertion failure");
      i3 = i3 || {};
      const t4 = [];
      let c2 = n3;
      if ("function" == typeof n3) {
        const u2 = (0, s2.maybeAsync)(n3, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), p2 = Object.assign({}, o2, e3(r3, t4));
        try {
          c2 = yield* u2(p2, i3, a3);
        } catch (e4) {
          throw l2 && (e4.message += ` (While processing: ${JSON.stringify(l2)})`), e4;
        }
      }
      if (!c2 || "object" != typeof c2) throw new Error("Plugin/Preset did not return an object.");
      if ((0, s2.isThenable)(c2)) throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(l2)})`);
      if (t4.length > 0 && (!r3.configured() || "forever" === r3.mode())) {
        let e4 = `A plugin/preset has external untracked dependencies (${t4[0]}), but the cache `;
        throw r3.configured() ? e4 += " has been configured to never be invalidated. " : e4 += "has not been configured to be invalidated when the external dependencies change. ", e4 += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(l2)})`, new Error(e4);
      }
      return { value: c2, options: i3, dirname: a3, alias: l2, externalDependencies: (0, u.finalize)(t4) };
    }();
  }), E = v(m.makePluginAPI), S = v(m.makePresetAPI), x = (0, d.makeWeakCache)(function(e3, t3) {
    let { value: r3, options: n3, dirname: i3, alias: o3, externalDependencies: l2 } = e3;
    return function* () {
      const e4 = (0, h.validatePluginObject)(r3), c2 = Object.assign({}, e4);
      if (c2.visitor && (c2.visitor = p().default.explode(Object.assign({}, c2.visitor))), c2.inherits) {
        const e5 = { name: void 0, alias: `${o3}$inherits`, value: c2.inherits, options: n3, dirname: i3 }, r4 = yield* (0, s2.forwardAsync)(T, (r5) => t3.invalidate((t4) => r5(e5, t4)));
        c2.pre = I(r4.pre, c2.pre), c2.post = I(r4.post, c2.post), c2.manipulateOptions = I(r4.manipulateOptions, c2.manipulateOptions), c2.visitor = p().default.visitors.merge([r4.visitor || {}, c2.visitor || {}]), r4.externalDependencies.length > 0 && (l2 = 0 === l2.length ? r4.externalDependencies : (0, u.finalize)([l2, r4.externalDependencies]));
      }
      return new a2.default(c2, n3, o3, l2);
    }();
  });
  function* T(e3, t3) {
    if (e3.value instanceof a2.default) {
      if (e3.options) throw new Error("Passed options to an existing Plugin instance will not work.");
      return e3.value;
    }
    return yield* x(yield* E(e3, t3), t3);
  }
  const w = (e3) => e3 && "function" != typeof e3, P = (e3, t3) => {
    if (w(e3.test) || w(e3.include) || w(e3.exclude)) {
      const e4 = t3.name ? `"${t3.name}"` : "/* your preset */";
      throw new g.default([`Preset ${e4} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, { filename: 'file.ts', presets: [${e4}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join("\n"));
    }
  }, A = (e3, t3, r3) => {
    if (!t3.filename) {
      var n3;
      const { options: t4 } = e3;
      P(t4, r3), null == (n3 = t4.overrides) || n3.forEach((e4) => P(e4, r3));
    }
  }, C = (0, d.makeWeakCacheSync)((e3) => {
    let { value: t3, dirname: r3, alias: n3, externalDependencies: s3 } = e3;
    return { options: (0, f.validate)("preset", t3), alias: n3, dirname: r3, externalDependencies: s3 };
  });
  function* O(e3, t3) {
    const r3 = C(yield* S(e3, t3));
    return A(r3, t3, e3), { chain: yield* (0, c.buildPresetChain)(r3, t3), externalDependencies: r3.externalDependencies };
  }
  function I(e3, t3) {
    const r3 = [e3, t3].filter(Boolean);
    return r3.length <= 1 ? r3[0] : function() {
      for (var e4 = arguments.length, t4 = new Array(e4), n3 = 0; n3 < e4; n3++) t4[n3] = arguments[n3];
      for (const e5 of r3) e5.apply(this, t4);
    };
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.once = function(e3) {
    let t3, r3, s2 = false;
    return function* () {
      if (!t3) {
        if (r3) return s2 = true, yield* (0, n2.waitFor)(r3);
        if (yield* (0, n2.isAsync)()) {
          let n3, i2;
          r3 = new Promise((e4, t4) => {
            n3 = e4, i2 = t4;
          });
          try {
            t3 = { ok: true, value: yield* e3() }, r3 = null, s2 && n3(t3.value);
          } catch (e4) {
            t3 = { ok: false, value: e4 }, r3 = null, s2 && i2(e4);
          }
        } else try {
          t3 = { ok: true, value: yield* e3() };
        } catch (e4) {
          t3 = { ok: false, value: e4 };
        }
      }
      if (t3.ok) return t3.value;
      throw t3.value;
    };
  };
  var n2 = r2(133);
}, (e2) => {
  e2.exports = JSON.parse('[{"name":"nodejs","version":"0.2.0","date":"2011-08-26","lts":false,"security":false,"v8":"2.3.8.0"},{"name":"nodejs","version":"0.3.0","date":"2011-08-26","lts":false,"security":false,"v8":"2.5.1.0"},{"name":"nodejs","version":"0.4.0","date":"2011-08-26","lts":false,"security":false,"v8":"3.1.2.0"},{"name":"nodejs","version":"0.5.0","date":"2011-08-26","lts":false,"security":false,"v8":"3.1.8.25"},{"name":"nodejs","version":"0.6.0","date":"2011-11-04","lts":false,"security":false,"v8":"3.6.6.6"},{"name":"nodejs","version":"0.7.0","date":"2012-01-17","lts":false,"security":false,"v8":"3.8.6.0"},{"name":"nodejs","version":"0.8.0","date":"2012-06-22","lts":false,"security":false,"v8":"3.11.10.10"},{"name":"nodejs","version":"0.9.0","date":"2012-07-20","lts":false,"security":false,"v8":"3.11.10.15"},{"name":"nodejs","version":"0.10.0","date":"2013-03-11","lts":false,"security":false,"v8":"3.14.5.8"},{"name":"nodejs","version":"0.11.0","date":"2013-03-28","lts":false,"security":false,"v8":"3.17.13.0"},{"name":"nodejs","version":"0.12.0","date":"2015-02-06","lts":false,"security":false,"v8":"3.28.73.0"},{"name":"nodejs","version":"4.0.0","date":"2015-09-08","lts":false,"security":false,"v8":"4.5.103.30"},{"name":"nodejs","version":"4.1.0","date":"2015-09-17","lts":false,"security":false,"v8":"4.5.103.33"},{"name":"nodejs","version":"4.2.0","date":"2015-10-12","lts":"Argon","security":false,"v8":"4.5.103.35"},{"name":"nodejs","version":"4.3.0","date":"2016-02-09","lts":"Argon","security":false,"v8":"4.5.103.35"},{"name":"nodejs","version":"4.4.0","date":"2016-03-08","lts":"Argon","security":false,"v8":"4.5.103.35"},{"name":"nodejs","version":"4.5.0","date":"2016-08-16","lts":"Argon","security":false,"v8":"4.5.103.37"},{"name":"nodejs","version":"4.6.0","date":"2016-09-27","lts":"Argon","security":true,"v8":"4.5.103.37"},{"name":"nodejs","version":"4.7.0","date":"2016-12-06","lts":"Argon","security":false,"v8":"4.5.103.43"},{"name":"nodejs","version":"4.8.0","date":"2017-02-21","lts":"Argon","security":false,"v8":"4.5.103.45"},{"name":"nodejs","version":"4.9.0","date":"2018-03-28","lts":"Argon","security":true,"v8":"4.5.103.53"},{"name":"nodejs","version":"5.0.0","date":"2015-10-29","lts":false,"security":false,"v8":"4.6.85.28"},{"name":"nodejs","version":"5.1.0","date":"2015-11-17","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.2.0","date":"2015-12-09","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.3.0","date":"2015-12-15","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.4.0","date":"2016-01-06","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.5.0","date":"2016-01-21","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.6.0","date":"2016-02-09","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.7.0","date":"2016-02-23","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.8.0","date":"2016-03-09","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.9.0","date":"2016-03-16","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.10.0","date":"2016-04-01","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.11.0","date":"2016-04-21","lts":false,"security":false,"v8":"4.6.85.31"},{"name":"nodejs","version":"5.12.0","date":"2016-06-23","lts":false,"security":false,"v8":"4.6.85.32"},{"name":"nodejs","version":"6.0.0","date":"2016-04-26","lts":false,"security":false,"v8":"5.0.71.35"},{"name":"nodejs","version":"6.1.0","date":"2016-05-05","lts":false,"security":false,"v8":"5.0.71.35"},{"name":"nodejs","version":"6.2.0","date":"2016-05-17","lts":false,"security":false,"v8":"5.0.71.47"},{"name":"nodejs","version":"6.3.0","date":"2016-07-06","lts":false,"security":false,"v8":"5.0.71.52"},{"name":"nodejs","version":"6.4.0","date":"2016-08-12","lts":false,"security":false,"v8":"5.0.71.60"},{"name":"nodejs","version":"6.5.0","date":"2016-08-26","lts":false,"security":false,"v8":"5.1.281.81"},{"name":"nodejs","version":"6.6.0","date":"2016-09-14","lts":false,"security":false,"v8":"5.1.281.83"},{"name":"nodejs","version":"6.7.0","date":"2016-09-27","lts":false,"security":true,"v8":"5.1.281.83"},{"name":"nodejs","version":"6.8.0","date":"2016-10-12","lts":false,"security":false,"v8":"5.1.281.84"},{"name":"nodejs","version":"6.9.0","date":"2016-10-18","lts":"Boron","security":false,"v8":"5.1.281.84"},{"name":"nodejs","version":"6.10.0","date":"2017-02-21","lts":"Boron","security":false,"v8":"5.1.281.93"},{"name":"nodejs","version":"6.11.0","date":"2017-06-06","lts":"Boron","security":false,"v8":"5.1.281.102"},{"name":"nodejs","version":"6.12.0","date":"2017-11-06","lts":"Boron","security":false,"v8":"5.1.281.108"},{"name":"nodejs","version":"6.13.0","date":"2018-02-10","lts":"Boron","security":false,"v8":"5.1.281.111"},{"name":"nodejs","version":"6.14.0","date":"2018-03-28","lts":"Boron","security":true,"v8":"5.1.281.111"},{"name":"nodejs","version":"6.15.0","date":"2018-11-27","lts":"Boron","security":true,"v8":"5.1.281.111"},{"name":"nodejs","version":"6.16.0","date":"2018-12-26","lts":"Boron","security":false,"v8":"5.1.281.111"},{"name":"nodejs","version":"6.17.0","date":"2019-02-28","lts":"Boron","security":true,"v8":"5.1.281.111"},{"name":"nodejs","version":"7.0.0","date":"2016-10-25","lts":false,"security":false,"v8":"5.4.500.36"},{"name":"nodejs","version":"7.1.0","date":"2016-11-08","lts":false,"security":false,"v8":"5.4.500.36"},{"name":"nodejs","version":"7.2.0","date":"2016-11-22","lts":false,"security":false,"v8":"5.4.500.43"},{"name":"nodejs","version":"7.3.0","date":"2016-12-20","lts":false,"security":false,"v8":"5.4.500.45"},{"name":"nodejs","version":"7.4.0","date":"2017-01-04","lts":false,"security":false,"v8":"5.4.500.45"},{"name":"nodejs","version":"7.5.0","date":"2017-01-31","lts":false,"security":false,"v8":"5.4.500.48"},{"name":"nodejs","version":"7.6.0","date":"2017-02-21","lts":false,"security":false,"v8":"5.5.372.40"},{"name":"nodejs","version":"7.7.0","date":"2017-02-28","lts":false,"security":false,"v8":"5.5.372.41"},{"name":"nodejs","version":"7.8.0","date":"2017-03-29","lts":false,"security":false,"v8":"5.5.372.43"},{"name":"nodejs","version":"7.9.0","date":"2017-04-11","lts":false,"security":false,"v8":"5.5.372.43"},{"name":"nodejs","version":"7.10.0","date":"2017-05-02","lts":false,"security":false,"v8":"5.5.372.43"},{"name":"nodejs","version":"8.0.0","date":"2017-05-30","lts":false,"security":false,"v8":"5.8.283.41"},{"name":"nodejs","version":"8.1.0","date":"2017-06-08","lts":false,"security":false,"v8":"5.8.283.41"},{"name":"nodejs","version":"8.2.0","date":"2017-07-19","lts":false,"security":false,"v8":"5.8.283.41"},{"name":"nodejs","version":"8.3.0","date":"2017-08-08","lts":false,"security":false,"v8":"6.0.286.52"},{"name":"nodejs","version":"8.4.0","date":"2017-08-15","lts":false,"security":false,"v8":"6.0.286.52"},{"name":"nodejs","version":"8.5.0","date":"2017-09-12","lts":false,"security":false,"v8":"6.0.287.53"},{"name":"nodejs","version":"8.6.0","date":"2017-09-26","lts":false,"security":false,"v8":"6.0.287.53"},{"name":"nodejs","version":"8.7.0","date":"2017-10-11","lts":false,"security":false,"v8":"6.1.534.42"},{"name":"nodejs","version":"8.8.0","date":"2017-10-24","lts":false,"security":false,"v8":"6.1.534.42"},{"name":"nodejs","version":"8.9.0","date":"2017-10-31","lts":"Carbon","security":false,"v8":"6.1.534.46"},{"name":"nodejs","version":"8.10.0","date":"2018-03-06","lts":"Carbon","security":false,"v8":"6.2.414.50"},{"name":"nodejs","version":"8.11.0","date":"2018-03-28","lts":"Carbon","security":true,"v8":"6.2.414.50"},{"name":"nodejs","version":"8.12.0","date":"2018-09-10","lts":"Carbon","security":false,"v8":"6.2.414.66"},{"name":"nodejs","version":"8.13.0","date":"2018-11-20","lts":"Carbon","security":false,"v8":"6.2.414.72"},{"name":"nodejs","version":"8.14.0","date":"2018-11-27","lts":"Carbon","security":true,"v8":"6.2.414.72"},{"name":"nodejs","version":"8.15.0","date":"2018-12-26","lts":"Carbon","security":false,"v8":"6.2.414.75"},{"name":"nodejs","version":"8.16.0","date":"2019-04-16","lts":"Carbon","security":false,"v8":"6.2.414.77"},{"name":"nodejs","version":"8.17.0","date":"2019-12-17","lts":"Carbon","security":true,"v8":"6.2.414.78"},{"name":"nodejs","version":"9.0.0","date":"2017-10-31","lts":false,"security":false,"v8":"6.2.414.32"},{"name":"nodejs","version":"9.1.0","date":"2017-11-07","lts":false,"security":false,"v8":"6.2.414.32"},{"name":"nodejs","version":"9.2.0","date":"2017-11-14","lts":false,"security":false,"v8":"6.2.414.44"},{"name":"nodejs","version":"9.3.0","date":"2017-12-12","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.4.0","date":"2018-01-10","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.5.0","date":"2018-01-31","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.6.0","date":"2018-02-21","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.7.0","date":"2018-03-01","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.8.0","date":"2018-03-07","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.9.0","date":"2018-03-21","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.10.0","date":"2018-03-28","lts":false,"security":true,"v8":"6.2.414.46"},{"name":"nodejs","version":"9.11.0","date":"2018-04-04","lts":false,"security":false,"v8":"6.2.414.46"},{"name":"nodejs","version":"10.0.0","date":"2018-04-24","lts":false,"security":false,"v8":"6.6.346.24"},{"name":"nodejs","version":"10.1.0","date":"2018-05-08","lts":false,"security":false,"v8":"6.6.346.27"},{"name":"nodejs","version":"10.2.0","date":"2018-05-23","lts":false,"security":false,"v8":"6.6.346.32"},{"name":"nodejs","version":"10.3.0","date":"2018-05-29","lts":false,"security":false,"v8":"6.6.346.32"},{"name":"nodejs","version":"10.4.0","date":"2018-06-06","lts":false,"security":false,"v8":"6.7.288.43"},{"name":"nodejs","version":"10.5.0","date":"2018-06-20","lts":false,"security":false,"v8":"6.7.288.46"},{"name":"nodejs","version":"10.6.0","date":"2018-07-04","lts":false,"security":false,"v8":"6.7.288.46"},{"name":"nodejs","version":"10.7.0","date":"2018-07-18","lts":false,"security":false,"v8":"6.7.288.49"},{"name":"nodejs","version":"10.8.0","date":"2018-08-01","lts":false,"security":false,"v8":"6.7.288.49"},{"name":"nodejs","version":"10.9.0","date":"2018-08-15","lts":false,"security":false,"v8":"6.8.275.24"},{"name":"nodejs","version":"10.10.0","date":"2018-09-06","lts":false,"security":false,"v8":"6.8.275.30"},{"name":"nodejs","version":"10.11.0","date":"2018-09-19","lts":false,"security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.12.0","date":"2018-10-10","lts":false,"security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.13.0","date":"2018-10-30","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.14.0","date":"2018-11-27","lts":"Dubnium","security":true,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.15.0","date":"2018-12-26","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.16.0","date":"2019-05-28","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.17.0","date":"2019-10-22","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.18.0","date":"2019-12-17","lts":"Dubnium","security":true,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.19.0","date":"2020-02-05","lts":"Dubnium","security":true,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.20.0","date":"2020-03-26","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.21.0","date":"2020-06-02","lts":"Dubnium","security":true,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.22.0","date":"2020-07-21","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.23.0","date":"2020-10-27","lts":"Dubnium","security":false,"v8":"6.8.275.32"},{"name":"nodejs","version":"10.24.0","date":"2021-02-23","lts":"Dubnium","security":true,"v8":"6.8.275.32"},{"name":"nodejs","version":"11.0.0","date":"2018-10-23","lts":false,"security":false,"v8":"7.0.276.28"},{"name":"nodejs","version":"11.1.0","date":"2018-10-30","lts":false,"security":false,"v8":"7.0.276.32"},{"name":"nodejs","version":"11.2.0","date":"2018-11-15","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.3.0","date":"2018-11-27","lts":false,"security":true,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.4.0","date":"2018-12-07","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.5.0","date":"2018-12-18","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.6.0","date":"2018-12-26","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.7.0","date":"2019-01-17","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.8.0","date":"2019-01-24","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.9.0","date":"2019-01-30","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.10.0","date":"2019-02-14","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.11.0","date":"2019-03-05","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.12.0","date":"2019-03-14","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.13.0","date":"2019-03-28","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.14.0","date":"2019-04-10","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"11.15.0","date":"2019-04-30","lts":false,"security":false,"v8":"7.0.276.38"},{"name":"nodejs","version":"12.0.0","date":"2019-04-23","lts":false,"security":false,"v8":"7.4.288.21"},{"name":"nodejs","version":"12.1.0","date":"2019-04-29","lts":false,"security":false,"v8":"7.4.288.21"},{"name":"nodejs","version":"12.2.0","date":"2019-05-07","lts":false,"security":false,"v8":"7.4.288.21"},{"name":"nodejs","version":"12.3.0","date":"2019-05-21","lts":false,"security":false,"v8":"7.4.288.27"},{"name":"nodejs","version":"12.4.0","date":"2019-06-04","lts":false,"security":false,"v8":"7.4.288.27"},{"name":"nodejs","version":"12.5.0","date":"2019-06-26","lts":false,"security":false,"v8":"7.5.288.22"},{"name":"nodejs","version":"12.6.0","date":"2019-07-03","lts":false,"security":false,"v8":"7.5.288.22"},{"name":"nodejs","version":"12.7.0","date":"2019-07-23","lts":false,"security":false,"v8":"7.5.288.22"},{"name":"nodejs","version":"12.8.0","date":"2019-08-06","lts":false,"security":false,"v8":"7.5.288.22"},{"name":"nodejs","version":"12.9.0","date":"2019-08-20","lts":false,"security":false,"v8":"7.6.303.29"},{"name":"nodejs","version":"12.10.0","date":"2019-09-04","lts":false,"security":false,"v8":"7.6.303.29"},{"name":"nodejs","version":"12.11.0","date":"2019-09-25","lts":false,"security":false,"v8":"7.7.299.11"},{"name":"nodejs","version":"12.12.0","date":"2019-10-11","lts":false,"security":false,"v8":"7.7.299.13"},{"name":"nodejs","version":"12.13.0","date":"2019-10-21","lts":"Erbium","security":false,"v8":"7.7.299.13"},{"name":"nodejs","version":"12.14.0","date":"2019-12-17","lts":"Erbium","security":true,"v8":"7.7.299.13"},{"name":"nodejs","version":"12.15.0","date":"2020-02-05","lts":"Erbium","security":true,"v8":"7.7.299.13"},{"name":"nodejs","version":"12.16.0","date":"2020-02-11","lts":"Erbium","security":false,"v8":"7.8.279.23"},{"name":"nodejs","version":"12.17.0","date":"2020-05-26","lts":"Erbium","security":false,"v8":"7.8.279.23"},{"name":"nodejs","version":"12.18.0","date":"2020-06-02","lts":"Erbium","security":true,"v8":"7.8.279.23"},{"name":"nodejs","version":"12.19.0","date":"2020-10-06","lts":"Erbium","security":false,"v8":"7.8.279.23"},{"name":"nodejs","version":"12.20.0","date":"2020-11-24","lts":"Erbium","security":false,"v8":"7.8.279.23"},{"name":"nodejs","version":"12.21.0","date":"2021-02-23","lts":"Erbium","security":true,"v8":"7.8.279.23"},{"name":"nodejs","version":"12.22.0","date":"2021-03-30","lts":"Erbium","security":false,"v8":"7.8.279.23"},{"name":"nodejs","version":"13.0.0","date":"2019-10-22","lts":false,"security":false,"v8":"7.8.279.17"},{"name":"nodejs","version":"13.1.0","date":"2019-11-05","lts":false,"security":false,"v8":"7.8.279.17"},{"name":"nodejs","version":"13.2.0","date":"2019-11-21","lts":false,"security":false,"v8":"7.9.317.23"},{"name":"nodejs","version":"13.3.0","date":"2019-12-03","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.4.0","date":"2019-12-17","lts":false,"security":true,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.5.0","date":"2019-12-18","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.6.0","date":"2020-01-07","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.7.0","date":"2020-01-21","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.8.0","date":"2020-02-05","lts":false,"security":true,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.9.0","date":"2020-02-18","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.10.0","date":"2020-03-04","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.11.0","date":"2020-03-12","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.12.0","date":"2020-03-26","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.13.0","date":"2020-04-14","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"13.14.0","date":"2020-04-29","lts":false,"security":false,"v8":"7.9.317.25"},{"name":"nodejs","version":"14.0.0","date":"2020-04-21","lts":false,"security":false,"v8":"8.1.307.30"},{"name":"nodejs","version":"14.1.0","date":"2020-04-29","lts":false,"security":false,"v8":"8.1.307.31"},{"name":"nodejs","version":"14.2.0","date":"2020-05-05","lts":false,"security":false,"v8":"8.1.307.31"},{"name":"nodejs","version":"14.3.0","date":"2020-05-19","lts":false,"security":false,"v8":"8.1.307.31"},{"name":"nodejs","version":"14.4.0","date":"2020-06-02","lts":false,"security":true,"v8":"8.1.307.31"},{"name":"nodejs","version":"14.5.0","date":"2020-06-30","lts":false,"security":false,"v8":"8.3.110.9"},{"name":"nodejs","version":"14.6.0","date":"2020-07-20","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.7.0","date":"2020-07-29","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.8.0","date":"2020-08-11","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.9.0","date":"2020-08-27","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.10.0","date":"2020-09-08","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.11.0","date":"2020-09-15","lts":false,"security":true,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.12.0","date":"2020-09-22","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.13.0","date":"2020-09-29","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.14.0","date":"2020-10-15","lts":false,"security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.15.0","date":"2020-10-27","lts":"Fermium","security":false,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.16.0","date":"2021-02-23","lts":"Fermium","security":true,"v8":"8.4.371.19"},{"name":"nodejs","version":"14.17.0","date":"2021-05-11","lts":"Fermium","security":false,"v8":"8.4.371.23"},{"name":"nodejs","version":"14.18.0","date":"2021-09-28","lts":"Fermium","security":false,"v8":"8.4.371.23"},{"name":"nodejs","version":"14.19.0","date":"2022-02-01","lts":"Fermium","security":false,"v8":"8.4.371.23"},{"name":"nodejs","version":"14.20.0","date":"2022-07-07","lts":"Fermium","security":true,"v8":"8.4.371.23"},{"name":"nodejs","version":"14.21.0","date":"2022-11-01","lts":"Fermium","security":false,"v8":"8.4.371.23"},{"name":"nodejs","version":"15.0.0","date":"2020-10-20","lts":false,"security":false,"v8":"8.6.395.16"},{"name":"nodejs","version":"15.1.0","date":"2020-11-04","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.2.0","date":"2020-11-10","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.3.0","date":"2020-11-24","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.4.0","date":"2020-12-09","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.5.0","date":"2020-12-22","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.6.0","date":"2021-01-14","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.7.0","date":"2021-01-25","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.8.0","date":"2021-02-02","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.9.0","date":"2021-02-18","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.10.0","date":"2021-02-23","lts":false,"security":true,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.11.0","date":"2021-03-03","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.12.0","date":"2021-03-17","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.13.0","date":"2021-03-31","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"15.14.0","date":"2021-04-06","lts":false,"security":false,"v8":"8.6.395.17"},{"name":"nodejs","version":"16.0.0","date":"2021-04-20","lts":false,"security":false,"v8":"9.0.257.17"},{"name":"nodejs","version":"16.1.0","date":"2021-05-04","lts":false,"security":false,"v8":"9.0.257.24"},{"name":"nodejs","version":"16.2.0","date":"2021-05-19","lts":false,"security":false,"v8":"9.0.257.25"},{"name":"nodejs","version":"16.3.0","date":"2021-06-03","lts":false,"security":false,"v8":"9.0.257.25"},{"name":"nodejs","version":"16.4.0","date":"2021-06-23","lts":false,"security":false,"v8":"9.1.269.36"},{"name":"nodejs","version":"16.5.0","date":"2021-07-14","lts":false,"security":false,"v8":"9.1.269.38"},{"name":"nodejs","version":"16.6.0","date":"2021-07-29","lts":false,"security":true,"v8":"9.2.230.21"},{"name":"nodejs","version":"16.7.0","date":"2021-08-18","lts":false,"security":false,"v8":"9.2.230.21"},{"name":"nodejs","version":"16.8.0","date":"2021-08-25","lts":false,"security":false,"v8":"9.2.230.21"},{"name":"nodejs","version":"16.9.0","date":"2021-09-07","lts":false,"security":false,"v8":"9.3.345.16"},{"name":"nodejs","version":"16.10.0","date":"2021-09-22","lts":false,"security":false,"v8":"9.3.345.19"},{"name":"nodejs","version":"16.11.0","date":"2021-10-08","lts":false,"security":false,"v8":"9.4.146.19"},{"name":"nodejs","version":"16.12.0","date":"2021-10-20","lts":false,"security":false,"v8":"9.4.146.19"},{"name":"nodejs","version":"16.13.0","date":"2021-10-26","lts":"Gallium","security":false,"v8":"9.4.146.19"},{"name":"nodejs","version":"16.14.0","date":"2022-02-08","lts":"Gallium","security":false,"v8":"9.4.146.24"},{"name":"nodejs","version":"16.15.0","date":"2022-04-26","lts":"Gallium","security":false,"v8":"9.4.146.24"},{"name":"nodejs","version":"16.16.0","date":"2022-07-07","lts":"Gallium","security":true,"v8":"9.4.146.24"},{"name":"nodejs","version":"16.17.0","date":"2022-08-16","lts":"Gallium","security":false,"v8":"9.4.146.26"},{"name":"nodejs","version":"16.18.0","date":"2022-10-12","lts":"Gallium","security":false,"v8":"9.4.146.26"},{"name":"nodejs","version":"16.19.0","date":"2022-12-13","lts":"Gallium","security":false,"v8":"9.4.146.26"},{"name":"nodejs","version":"16.20.0","date":"2023-03-28","lts":"Gallium","security":false,"v8":"9.4.146.26"},{"name":"nodejs","version":"17.0.0","date":"2021-10-19","lts":false,"security":false,"v8":"9.5.172.21"},{"name":"nodejs","version":"17.1.0","date":"2021-11-09","lts":false,"security":false,"v8":"9.5.172.25"},{"name":"nodejs","version":"17.2.0","date":"2021-11-30","lts":false,"security":false,"v8":"9.6.180.14"},{"name":"nodejs","version":"17.3.0","date":"2021-12-17","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"17.4.0","date":"2022-01-18","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"17.5.0","date":"2022-02-10","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"17.6.0","date":"2022-02-22","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"17.7.0","date":"2022-03-09","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"17.8.0","date":"2022-03-22","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"17.9.0","date":"2022-04-07","lts":false,"security":false,"v8":"9.6.180.15"},{"name":"nodejs","version":"18.0.0","date":"2022-04-18","lts":false,"security":false,"v8":"10.1.124.8"},{"name":"nodejs","version":"18.1.0","date":"2022-05-03","lts":false,"security":false,"v8":"10.1.124.8"},{"name":"nodejs","version":"18.2.0","date":"2022-05-17","lts":false,"security":false,"v8":"10.1.124.8"},{"name":"nodejs","version":"18.3.0","date":"2022-06-02","lts":false,"security":false,"v8":"10.2.154.4"},{"name":"nodejs","version":"18.4.0","date":"2022-06-16","lts":false,"security":false,"v8":"10.2.154.4"},{"name":"nodejs","version":"18.5.0","date":"2022-07-06","lts":false,"security":true,"v8":"10.2.154.4"},{"name":"nodejs","version":"18.6.0","date":"2022-07-13","lts":false,"security":false,"v8":"10.2.154.13"},{"name":"nodejs","version":"18.7.0","date":"2022-07-26","lts":false,"security":false,"v8":"10.2.154.13"},{"name":"nodejs","version":"18.8.0","date":"2022-08-24","lts":false,"security":false,"v8":"10.2.154.13"},{"name":"nodejs","version":"18.9.0","date":"2022-09-07","lts":false,"security":false,"v8":"10.2.154.15"},{"name":"nodejs","version":"18.10.0","date":"2022-09-28","lts":false,"security":false,"v8":"10.2.154.15"},{"name":"nodejs","version":"18.11.0","date":"2022-10-13","lts":false,"security":false,"v8":"10.2.154.15"},{"name":"nodejs","version":"18.12.0","date":"2022-10-25","lts":"Hydrogen","security":false,"v8":"10.2.154.15"},{"name":"nodejs","version":"18.13.0","date":"2023-01-05","lts":"Hydrogen","security":false,"v8":"10.2.154.23"},{"name":"nodejs","version":"18.14.0","date":"2023-02-01","lts":"Hydrogen","security":false,"v8":"10.2.154.23"},{"name":"nodejs","version":"18.15.0","date":"2023-03-05","lts":"Hydrogen","security":false,"v8":"10.2.154.26"},{"name":"nodejs","version":"18.16.0","date":"2023-04-12","lts":"Hydrogen","security":false,"v8":"10.2.154.26"},{"name":"nodejs","version":"18.17.0","date":"2023-07-18","lts":"Hydrogen","security":false,"v8":"10.2.154.26"},{"name":"nodejs","version":"18.18.0","date":"2023-09-18","lts":"Hydrogen","security":false,"v8":"10.2.154.26"},{"name":"nodejs","version":"18.19.0","date":"2023-11-29","lts":"Hydrogen","security":false,"v8":"10.2.154.26"},{"name":"nodejs","version":"19.0.0","date":"2022-10-17","lts":false,"security":false,"v8":"10.7.193.13"},{"name":"nodejs","version":"19.1.0","date":"2022-11-14","lts":false,"security":false,"v8":"10.7.193.20"},{"name":"nodejs","version":"19.2.0","date":"2022-11-29","lts":false,"security":false,"v8":"10.8.168.20"},{"name":"nodejs","version":"19.3.0","date":"2022-12-14","lts":false,"security":false,"v8":"10.8.168.21"},{"name":"nodejs","version":"19.4.0","date":"2023-01-05","lts":false,"security":false,"v8":"10.8.168.25"},{"name":"nodejs","version":"19.5.0","date":"2023-01-24","lts":false,"security":false,"v8":"10.8.168.25"},{"name":"nodejs","version":"19.6.0","date":"2023-02-01","lts":false,"security":false,"v8":"10.8.168.25"},{"name":"nodejs","version":"19.7.0","date":"2023-02-21","lts":false,"security":false,"v8":"10.8.168.25"},{"name":"nodejs","version":"19.8.0","date":"2023-03-14","lts":false,"security":false,"v8":"10.8.168.25"},{"name":"nodejs","version":"19.9.0","date":"2023-04-10","lts":false,"security":false,"v8":"10.8.168.25"},{"name":"nodejs","version":"20.0.0","date":"2023-04-17","lts":false,"security":false,"v8":"11.3.244.4"},{"name":"nodejs","version":"20.1.0","date":"2023-05-03","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.2.0","date":"2023-05-16","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.3.0","date":"2023-06-08","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.4.0","date":"2023-07-04","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.5.0","date":"2023-07-19","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.6.0","date":"2023-08-23","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.7.0","date":"2023-09-18","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.8.0","date":"2023-09-28","lts":false,"security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.9.0","date":"2023-10-24","lts":"Iron","security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"20.10.0","date":"2023-11-22","lts":"Iron","security":false,"v8":"11.3.244.8"},{"name":"nodejs","version":"21.0.0","date":"2023-10-17","lts":false,"security":false,"v8":"11.8.172.13"},{"name":"nodejs","version":"21.1.0","date":"2023-10-24","lts":false,"security":false,"v8":"11.8.172.15"},{"name":"nodejs","version":"21.2.0","date":"2023-11-14","lts":false,"security":false,"v8":"11.8.172.17"},{"name":"nodejs","version":"21.3.0","date":"2023-11-30","lts":false,"security":false,"v8":"11.8.172.17"}]');
}, (e2, t2, r2) => {
  const n2 = r2(458).browsers, s2 = r2(459).browserVersions, i2 = r2(285);
  function o2(e3) {
    return Object.keys(e3).reduce((t3, r3) => (t3[s2[r3]] = e3[r3], t3), {});
  }
  e2.exports.a = Object.keys(i2).reduce((e3, t3) => {
    let r3 = i2[t3];
    return e3[n2[t3]] = Object.keys(r3).reduce((e4, t4) => ("A" === t4 ? e4.usage_global = o2(r3[t4]) : "C" === t4 ? e4.versions = r3[t4].reduce((e5, t5) => ("" === t5 ? e5.push(null) : e5.push(s2[t5]), e5), []) : "D" === t4 ? e4.prefix_exceptions = o2(r3[t4]) : "E" === t4 ? e4.browser = r3[t4] : "F" === t4 ? e4.release_date = Object.keys(r3[t4]).reduce((e5, n3) => (e5[s2[n3]] = r3[t4][n3], e5), {}) : e4.prefix = r3[t4], e4), {}), e3;
  }, {});
}, (e2, t2, r2) => {
  e2.exports.browsers = r2(283);
}, (e2, t2, r2) => {
  e2.exports.browserVersions = r2(284);
}, (e2) => {
  e2.exports = JSON.parse('{"v0.8":{"start":"2012-06-25","end":"2014-07-31"},"v0.10":{"start":"2013-03-11","end":"2016-10-31"},"v0.12":{"start":"2015-02-06","end":"2016-12-31"},"v4":{"start":"2015-09-08","lts":"2015-10-12","maintenance":"2017-04-01","end":"2018-04-30","codename":"Argon"},"v5":{"start":"2015-10-29","maintenance":"2016-04-30","end":"2016-06-30"},"v6":{"start":"2016-04-26","lts":"2016-10-18","maintenance":"2018-04-30","end":"2019-04-30","codename":"Boron"},"v7":{"start":"2016-10-25","maintenance":"2017-04-30","end":"2017-06-30"},"v8":{"start":"2017-05-30","lts":"2017-10-31","maintenance":"2019-01-01","end":"2019-12-31","codename":"Carbon"},"v9":{"start":"2017-10-01","maintenance":"2018-04-01","end":"2018-06-30"},"v10":{"start":"2018-04-24","lts":"2018-10-30","maintenance":"2020-05-19","end":"2021-04-30","codename":"Dubnium"},"v11":{"start":"2018-10-23","maintenance":"2019-04-22","end":"2019-06-01"},"v12":{"start":"2019-04-23","lts":"2019-10-21","maintenance":"2020-11-30","end":"2022-04-30","codename":"Erbium"},"v13":{"start":"2019-10-22","maintenance":"2020-04-01","end":"2020-06-01"},"v14":{"start":"2020-04-21","lts":"2020-10-27","maintenance":"2021-10-19","end":"2023-04-30","codename":"Fermium"},"v15":{"start":"2020-10-20","maintenance":"2021-04-01","end":"2021-06-01"},"v16":{"start":"2021-04-20","lts":"2021-10-26","maintenance":"2022-10-18","end":"2023-09-11","codename":"Gallium"},"v17":{"start":"2021-10-19","maintenance":"2022-04-01","end":"2022-06-01"},"v18":{"start":"2022-04-19","lts":"2022-10-25","maintenance":"2023-10-18","end":"2025-04-30","codename":"Hydrogen"},"v19":{"start":"2022-10-18","maintenance":"2023-04-01","end":"2023-06-01"},"v20":{"start":"2023-04-18","lts":"2023-10-24","maintenance":"2024-10-22","end":"2026-04-30","codename":"Iron"},"v21":{"start":"2023-10-17","maintenance":"2024-04-01","end":"2024-06-01"},"v22":{"start":"2024-04-23","lts":"2024-10-29","maintenance":"2025-10-21","end":"2027-04-30","codename":""},"v23":{"start":"2024-10-15","maintenance":"2025-04-01","end":"2025-06-01"},"v24":{"start":"2025-04-22","lts":"2025-10-28","maintenance":"2026-10-20","end":"2028-04-30","codename":""}}');
}, () => {
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.OptionValidator = void 0;
  var n2 = r2(290);
  t2.OptionValidator = class {
    constructor(e3) {
      this.descriptor = e3;
    }
    validateTopLevelOptions(e3, t3) {
      const r3 = Object.keys(t3);
      for (const t4 of Object.keys(e3)) if (!r3.includes(t4)) throw new Error(this.formatMessage(`'${t4}' is not a valid top-level option.
- Did you mean '${(0, n2.findSuggestion)(t4, r3)}'?`));
    }
    validateBooleanOption(e3, t3, r3) {
      return void 0 === t3 ? r3 : (this.invariant("boolean" == typeof t3, `'${e3}' option must be a boolean.`), t3);
    }
    validateStringOption(e3, t3, r3) {
      return void 0 === t3 ? r3 : (this.invariant("string" == typeof t3, `'${e3}' option must be a string.`), t3);
    }
    invariant(e3, t3) {
      if (!e3) throw new Error(this.formatMessage(t3));
    }
    formatMessage(e3) {
      return `${this.descriptor}: ${e3}`;
    }
  };
}, (e2, t2, r2) => {
  e2.exports = r2(464);
}, (e2) => {
  e2.exports = JSON.parse('{"es6.module":{"chrome":"61","and_chr":"61","edge":"16","firefox":"60","and_ff":"60","node":"13.2.0","opera":"48","op_mob":"45","safari":"10.1","ios":"10.3","samsung":"8.2","android":"61","electron":"2.0","ios_saf":"10.3"}}');
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.TargetNames = void 0, t2.TargetNames = { node: "node", deno: "deno", chrome: "chrome", opera: "opera", edge: "edge", firefox: "firefox", safari: "safari", ie: "ie", ios: "ios", android: "android", electron: "electron", samsung: "samsung", rhino: "rhino", opera_mobile: "opera_mobile" };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.getInclusionReasons = function(e3, t3, r3) {
    const o2 = r3[e3] || {};
    return Object.keys(t3).reduce((e4, r4) => {
      const a2 = (0, i2.getLowestImplementedVersion)(o2, r4), l = t3[r4];
      if (a2) {
        const t4 = (0, i2.isUnreleasedVersion)(a2, r4);
        (0, i2.isUnreleasedVersion)(l, r4) || !t4 && !n2.lt(l.toString(), (0, i2.semverify)(a2)) || (e4[r4] = (0, s2.prettifyVersion)(l));
      } else e4[r4] = (0, s2.prettifyVersion)(l);
      return e4;
    }, {});
  };
  var n2 = r2(23), s2 = r2(291), i2 = r2(138);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, n3, s3, i3, o3) {
    const l = /* @__PURE__ */ new Set(), c = { compatData: e3, includes: t3, excludes: r3 };
    for (const t4 in e3) if (a2(t4, n3, c)) l.add(t4);
    else if (o3) {
      const e4 = o3.get(t4);
      e4 && l.add(e4);
    }
    return null == s3 || s3.forEach((e4) => !r3.has(e4) && l.add(e4)), null == i3 || i3.forEach((e4) => !t3.has(e4) && l.delete(e4)), l;
  }, t2.isRequired = a2, t2.targetsSupported = o2;
  var n2 = r2(23), s2 = r2(468), i2 = r2(138);
  function o2(e3, t3) {
    const r3 = Object.keys(e3);
    return 0 !== r3.length && 0 === r3.filter((r4) => {
      const s3 = (0, i2.getLowestImplementedVersion)(t3, r4);
      if (!s3) return true;
      const o3 = e3[r4];
      if ((0, i2.isUnreleasedVersion)(o3, r4)) return false;
      if ((0, i2.isUnreleasedVersion)(s3, r4)) return true;
      if (!n2.valid(o3.toString())) throw new Error(`Invalid version passed for target "${r4}": "${o3}". Versions must be in semver format (major.minor.patch)`);
      return n2.gt((0, i2.semverify)(s3), o3.toString());
    }).length;
  }
  function a2(e3, t3) {
    let { compatData: r3 = s2, includes: n3, excludes: i3 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    return !(null != i3 && i3.has(e3) || (null == n3 || !n3.has(e3)) && o2(t3, r3[e3]));
  }
}, (e2, t2, r2) => {
  e2.exports = r2(469);
}, (e2) => {
  e2.exports = JSON.parse('{"transform-unicode-sets-regex":{"chrome":"112","opera":"98","edge":"112","firefox":"116","safari":"tp","node":"20","deno":"1.32","opera_mobile":"75","electron":"24.0"},"bugfix/transform-v8-static-class-fields-redefine-readonly":{"chrome":"98","opera":"84","edge":"98","firefox":"95","safari":"15","node":"12","deno":"1.18","ios":"15","samsung":"11","opera_mobile":"52","electron":"17.0"},"transform-class-static-block":{"chrome":"94","opera":"80","edge":"94","firefox":"93","safari":"16.4","node":"16.11","deno":"1.14","ios":"16.4","samsung":"17","opera_mobile":"66","electron":"15.0"},"proposal-class-static-block":{"chrome":"94","opera":"80","edge":"94","firefox":"93","safari":"16.4","node":"16.11","deno":"1.14","ios":"16.4","samsung":"17","opera_mobile":"66","electron":"15.0"},"transform-private-property-in-object":{"chrome":"91","opera":"77","edge":"91","firefox":"90","safari":"15","node":"16.9","deno":"1.9","ios":"15","samsung":"16","opera_mobile":"64","electron":"13.0"},"proposal-private-property-in-object":{"chrome":"91","opera":"77","edge":"91","firefox":"90","safari":"15","node":"16.9","deno":"1.9","ios":"15","samsung":"16","opera_mobile":"64","electron":"13.0"},"transform-class-properties":{"chrome":"74","opera":"62","edge":"79","firefox":"90","safari":"14.1","node":"12","deno":"1","ios":"14.5","samsung":"11","opera_mobile":"53","electron":"6.0"},"proposal-class-properties":{"chrome":"74","opera":"62","edge":"79","firefox":"90","safari":"14.1","node":"12","deno":"1","ios":"14.5","samsung":"11","opera_mobile":"53","electron":"6.0"},"transform-private-methods":{"chrome":"84","opera":"70","edge":"84","firefox":"90","safari":"15","node":"14.6","deno":"1","ios":"15","samsung":"14","opera_mobile":"60","electron":"10.0"},"proposal-private-methods":{"chrome":"84","opera":"70","edge":"84","firefox":"90","safari":"15","node":"14.6","deno":"1","ios":"15","samsung":"14","opera_mobile":"60","electron":"10.0"},"transform-numeric-separator":{"chrome":"75","opera":"62","edge":"79","firefox":"70","safari":"13","node":"12.5","deno":"1","ios":"13","samsung":"11","rhino":"1.7.14","opera_mobile":"54","electron":"6.0"},"proposal-numeric-separator":{"chrome":"75","opera":"62","edge":"79","firefox":"70","safari":"13","node":"12.5","deno":"1","ios":"13","samsung":"11","rhino":"1.7.14","opera_mobile":"54","electron":"6.0"},"transform-logical-assignment-operators":{"chrome":"85","opera":"71","edge":"85","firefox":"79","safari":"14","node":"15","deno":"1.2","ios":"14","samsung":"14","opera_mobile":"60","electron":"10.0"},"proposal-logical-assignment-operators":{"chrome":"85","opera":"71","edge":"85","firefox":"79","safari":"14","node":"15","deno":"1.2","ios":"14","samsung":"14","opera_mobile":"60","electron":"10.0"},"transform-nullish-coalescing-operator":{"chrome":"80","opera":"67","edge":"80","firefox":"72","safari":"13.1","node":"14","deno":"1","ios":"13.4","samsung":"13","opera_mobile":"57","electron":"8.0"},"proposal-nullish-coalescing-operator":{"chrome":"80","opera":"67","edge":"80","firefox":"72","safari":"13.1","node":"14","deno":"1","ios":"13.4","samsung":"13","opera_mobile":"57","electron":"8.0"},"transform-optional-chaining":{"chrome":"91","opera":"77","edge":"91","firefox":"74","safari":"13.1","node":"16.9","deno":"1.9","ios":"13.4","samsung":"16","opera_mobile":"64","electron":"13.0"},"proposal-optional-chaining":{"chrome":"91","opera":"77","edge":"91","firefox":"74","safari":"13.1","node":"16.9","deno":"1.9","ios":"13.4","samsung":"16","opera_mobile":"64","electron":"13.0"},"transform-json-strings":{"chrome":"66","opera":"53","edge":"79","firefox":"62","safari":"12","node":"10","deno":"1","ios":"12","samsung":"9","rhino":"1.7.14","opera_mobile":"47","electron":"3.0"},"proposal-json-strings":{"chrome":"66","opera":"53","edge":"79","firefox":"62","safari":"12","node":"10","deno":"1","ios":"12","samsung":"9","rhino":"1.7.14","opera_mobile":"47","electron":"3.0"},"transform-optional-catch-binding":{"chrome":"66","opera":"53","edge":"79","firefox":"58","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"proposal-optional-catch-binding":{"chrome":"66","opera":"53","edge":"79","firefox":"58","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"transform-parameters":{"chrome":"49","opera":"36","edge":"18","firefox":"53","safari":"16.3","node":"6","deno":"1","ios":"16.3","samsung":"5","opera_mobile":"36","electron":"0.37"},"transform-async-generator-functions":{"chrome":"63","opera":"50","edge":"79","firefox":"57","safari":"12","node":"10","deno":"1","ios":"12","samsung":"8","opera_mobile":"46","electron":"3.0"},"proposal-async-generator-functions":{"chrome":"63","opera":"50","edge":"79","firefox":"57","safari":"12","node":"10","deno":"1","ios":"12","samsung":"8","opera_mobile":"46","electron":"3.0"},"transform-object-rest-spread":{"chrome":"60","opera":"47","edge":"79","firefox":"55","safari":"11.1","node":"8.3","deno":"1","ios":"11.3","samsung":"8","opera_mobile":"44","electron":"2.0"},"proposal-object-rest-spread":{"chrome":"60","opera":"47","edge":"79","firefox":"55","safari":"11.1","node":"8.3","deno":"1","ios":"11.3","samsung":"8","opera_mobile":"44","electron":"2.0"},"transform-dotall-regex":{"chrome":"62","opera":"49","edge":"79","firefox":"78","safari":"11.1","node":"8.10","deno":"1","ios":"11.3","samsung":"8","opera_mobile":"46","electron":"3.0"},"transform-unicode-property-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"proposal-unicode-property-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"transform-named-capturing-groups-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"transform-async-to-generator":{"chrome":"55","opera":"42","edge":"15","firefox":"52","safari":"11","node":"7.6","deno":"1","ios":"11","samsung":"6","opera_mobile":"42","electron":"1.6"},"transform-exponentiation-operator":{"chrome":"52","opera":"39","edge":"14","firefox":"52","safari":"10.1","node":"7","deno":"1","ios":"10.3","samsung":"6","rhino":"1.7.14","opera_mobile":"41","electron":"1.3"},"transform-template-literals":{"chrome":"41","opera":"28","edge":"13","firefox":"34","safari":"13","node":"4","deno":"1","ios":"13","samsung":"3.4","opera_mobile":"28","electron":"0.21"},"transform-literals":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","deno":"1","ios":"9","samsung":"4","opera_mobile":"32","electron":"0.30"},"transform-function-name":{"chrome":"51","opera":"38","edge":"79","firefox":"53","safari":"10","node":"6.5","deno":"1","ios":"10","samsung":"5","opera_mobile":"41","electron":"1.2"},"transform-arrow-functions":{"chrome":"47","opera":"34","edge":"13","firefox":"43","safari":"10","node":"6","deno":"1","ios":"10","samsung":"5","rhino":"1.7.13","opera_mobile":"34","electron":"0.36"},"transform-block-scoped-functions":{"chrome":"41","opera":"28","edge":"12","firefox":"46","safari":"10","node":"4","deno":"1","ie":"11","ios":"10","samsung":"3.4","opera_mobile":"28","electron":"0.21"},"transform-classes":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-object-super":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-shorthand-properties":{"chrome":"43","opera":"30","edge":"12","firefox":"33","safari":"9","node":"4","deno":"1","ios":"9","samsung":"4","rhino":"1.7.14","opera_mobile":"30","electron":"0.27"},"transform-duplicate-keys":{"chrome":"42","opera":"29","edge":"12","firefox":"34","safari":"9","node":"4","deno":"1","ios":"9","samsung":"3.4","opera_mobile":"29","electron":"0.25"},"transform-computed-properties":{"chrome":"44","opera":"31","edge":"12","firefox":"34","safari":"7.1","node":"4","deno":"1","ios":"8","samsung":"4","opera_mobile":"32","electron":"0.30"},"transform-for-of":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","deno":"1","ios":"10","samsung":"5","opera_mobile":"41","electron":"1.2"},"transform-sticky-regex":{"chrome":"49","opera":"36","edge":"13","firefox":"3","safari":"10","node":"6","deno":"1","ios":"10","samsung":"5","opera_mobile":"36","electron":"0.37"},"transform-unicode-escapes":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","deno":"1","ios":"9","samsung":"4","opera_mobile":"32","electron":"0.30"},"transform-unicode-regex":{"chrome":"50","opera":"37","edge":"13","firefox":"46","safari":"12","node":"6","deno":"1","ios":"12","samsung":"5","opera_mobile":"37","electron":"1.1"},"transform-spread":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-destructuring":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","deno":"1","ios":"10","samsung":"5","opera_mobile":"41","electron":"1.2"},"transform-block-scoping":{"chrome":"50","opera":"37","edge":"14","firefox":"53","safari":"11","node":"6","deno":"1","ios":"11","samsung":"5","opera_mobile":"37","electron":"1.1"},"transform-typeof-symbol":{"chrome":"38","opera":"25","edge":"12","firefox":"36","safari":"9","node":"0.12","deno":"1","ios":"9","samsung":"3","rhino":"1.7.13","opera_mobile":"25","electron":"0.20"},"transform-new-target":{"chrome":"46","opera":"33","edge":"14","firefox":"41","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-regenerator":{"chrome":"50","opera":"37","edge":"13","firefox":"53","safari":"10","node":"6","deno":"1","ios":"10","samsung":"5","opera_mobile":"37","electron":"1.1"},"transform-member-expression-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.4","deno":"1","ie":"9","android":"4","ios":"6","phantom":"1.9","samsung":"1","rhino":"1.7.13","opera_mobile":"12","electron":"0.20"},"transform-property-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.4","deno":"1","ie":"9","android":"4","ios":"6","phantom":"1.9","samsung":"1","rhino":"1.7.13","opera_mobile":"12","electron":"0.20"},"transform-reserved-words":{"chrome":"13","opera":"10.50","edge":"12","firefox":"2","safari":"3.1","node":"0.6","deno":"1","ie":"9","android":"4.4","ios":"6","phantom":"1.9","samsung":"1","rhino":"1.7.13","opera_mobile":"10.1","electron":"0.20"},"transform-export-namespace-from":{"chrome":"72","deno":"1.0","edge":"79","firefox":"80","node":"13.2","opera":"60","opera_mobile":"51","safari":"14.1","ios":"14.5","samsung":"11.0","android":"72","electron":"5.0"},"proposal-export-namespace-from":{"chrome":"72","deno":"1.0","edge":"79","firefox":"80","node":"13.2","opera":"60","opera_mobile":"51","safari":"14.1","ios":"14.5","samsung":"11.0","android":"72","electron":"5.0"}}');
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = { auxiliaryComment: { message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`" }, blacklist: { message: "Put the specific transforms you want in the `plugins` option" }, breakConfig: { message: "This is not a necessary option in Babel 6" }, experimental: { message: "Put the specific transforms you want in the `plugins` option" }, externalHelpers: { message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/" }, extra: { message: "" }, jsxPragma: { message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/" }, loose: { message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option." }, metadataUsedHelpers: { message: "Not required anymore as this is enabled by default" }, modules: { message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules" }, nonStandard: { message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/" }, optional: { message: "Put the specific transforms you want in the `plugins` option" }, sourceMapName: { message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." }, stage: { message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets" }, whitelist: { message: "Put the specific transforms you want in the `plugins` option" }, resolveModuleSource: { version: 6, message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options" }, metadata: { version: 6, message: "Generated plugin metadata is always included in the output result" }, sourceMapTarget: { version: 6, message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." } };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(10);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const r3 = n2().resolve(t3, e3).split(n2().sep);
    return new RegExp(["^", ...r3.map((e4, t4) => {
      const n3 = t4 === r3.length - 1;
      return "**" === e4 ? n3 ? u : c : "*" === e4 ? n3 ? l : a2 : 0 === e4.indexOf("*.") ? o2 + p(e4.slice(1)) + (n3 ? i2 : s2) : p(e4) + (n3 ? i2 : s2);
    })].join(""));
  };
  const s2 = `\\${n2().sep}`, i2 = `(?:${s2}|$)`, o2 = `[^${s2}]+`, a2 = `(?:${o2}${s2})`, l = `(?:${o2}${i2})`, c = `${a2}*?`, u = `${a2}*?${l}?`;
  function p(e3) {
    return e3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.ConfigPrinter = t2.ChainFormatter = void 0;
  const s2 = t2.ChainFormatter = { Programmatic: 0, Config: 1 }, i2 = { title(e3, t3, r3) {
    let n3 = "";
    return e3 === s2.Programmatic ? (n3 = "programmatic options", t3 && (n3 += " from " + t3)) : n3 = "config " + r3, n3;
  }, loc(e3, t3) {
    let r3 = "";
    return null != e3 && (r3 += `.overrides[${e3}]`), null != t3 && (r3 += `.env["${t3}"]`), r3;
  }, *optionsAndDescriptors(e3) {
    const t3 = Object.assign({}, e3.options);
    delete t3.overrides, delete t3.env;
    const r3 = [...yield* e3.plugins()];
    r3.length && (t3.plugins = r3.map((e4) => o2(e4)));
    const n3 = [...yield* e3.presets()];
    return n3.length && (t3.presets = [...n3].map((e4) => o2(e4))), JSON.stringify(t3, void 0, 2);
  } };
  function o2(e3) {
    var t3;
    let r3 = null == (t3 = e3.file) ? void 0 : t3.request;
    return null == r3 && ("object" == typeof e3.value ? r3 = e3.value : "function" == typeof e3.value && (r3 = `[Function: ${e3.value.toString().slice(0, 50)} ... ]`)), null == r3 && (r3 = "[Unknown]"), void 0 === e3.options ? r3 : null == e3.name ? [r3, e3.options] : [r3, e3.options, e3.name];
  }
  class a2 {
    constructor() {
      this._stack = [];
    }
    configure(e3, t3, r3) {
      let { callerName: n3, filepath: s3 } = r3;
      return e3 ? (e4, r4, i3) => {
        this._stack.push({ type: t3, callerName: n3, filepath: s3, content: e4, index: r4, envName: i3 });
      } : () => {
      };
    }
    static *format(e3) {
      let t3 = i2.title(e3.type, e3.callerName, e3.filepath);
      const r3 = i2.loc(e3.index, e3.envName);
      return r3 && (t3 += ` ${r3}`), `${t3}
${yield* i2.optionsAndDescriptors(e3.content)}`;
    }
    *output() {
      return 0 === this._stack.length ? "" : (yield* n2().all(this._stack.map((e3) => a2.format(e3)))).join("\n\n");
    }
  }
  t2.ConfigPrinter = a2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.validatePluginObject = function(e3) {
    const t3 = { type: "root", source: "plugin" };
    return Object.keys(e3).forEach((r3) => {
      const n3 = s2[r3];
      if (!n3) {
        const e4 = new Error(`.${r3} is not a valid Plugin property`);
        throw e4.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", e4;
      }
      n3({ type: "option", name: r3, parent: t3 }, e3[r3]);
    }), e3;
  };
  var n2 = r2(293);
  const s2 = { name: n2.assertString, manipulateOptions: n2.assertFunction, pre: n2.assertFunction, post: n2.assertFunction, inherits: n2.assertFunction, visitor: function(e3, t3) {
    const r3 = (0, n2.assertObject)(e3, t3);
    if (r3 && (Object.keys(r3).forEach((e4) => {
      "_exploded" !== e4 && "_verified" !== e4 && function(e5, t4) {
        if (t4 && "object" == typeof t4) Object.keys(t4).forEach((t5) => {
          if ("enter" !== t5 && "exit" !== t5) throw new Error(`.visitor["${e5}"] may only have .enter and/or .exit handlers.`);
        });
        else if ("function" != typeof t4) throw new Error(`.visitor["${e5}"] must be a function`);
      }(e4, r3[e4]);
    }), r3.enter || r3.exit)) throw new Error(`${(0, n2.msg)(e3)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
    return r3;
  }, parserOverride: n2.assertFunction, generatorOverride: n2.assertFunction };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(23);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.makeConfigAPI = o2, t2.makePluginAPI = function(e3, t3) {
    return Object.assign({}, a2(e3, t3), { assumption: (t4) => e3.using((e4) => e4.assumptions[t4]) });
  }, t2.makePresetAPI = a2;
  var s2 = r2(1), i2 = r2(84);
  function o2(e3) {
    return { version: s2.version, cache: e3.simple(), env: (t3) => e3.using((e4) => void 0 === t3 ? e4.envName : "function" == typeof t3 ? (0, i2.assertSimpleType)(t3(e4.envName)) : (Array.isArray(t3) ? t3 : [t3]).some((t4) => {
      if ("string" != typeof t4) throw new Error("Unexpected non-string value");
      return t4 === e4.envName;
    })), async: () => false, caller: (t3) => e3.using((e4) => (0, i2.assertSimpleType)(t3(e4.caller))), assertVersion: l };
  }
  function a2(e3, t3) {
    return Object.assign({}, o2(e3), { targets: () => JSON.parse(e3.using((e4) => JSON.stringify(e4.targets))), addExternalDependency: (e4) => {
      t3.push(e4);
    } });
  }
  function l(e3) {
    if ("number" == typeof e3) {
      if (!Number.isInteger(e3)) throw new Error("Expected string or integer value.");
      e3 = `^${e3}.0.0-0`;
    }
    if ("string" != typeof e3) throw new Error("Expected string or integer value.");
    if (n2().satisfies(s2.version, e3)) return;
    const t3 = Error.stackTraceLimit;
    "number" == typeof t3 && t3 < 25 && (Error.stackTraceLimit = 25);
    const r3 = new Error(`Requires Babel "${e3}", but was loaded with "${s2.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
    throw "number" == typeof t3 && (Error.stackTraceLimit = t3), Object.assign(r3, { code: "BABEL_VERSION_UNSUPPORTED", version: s2.version, range: e3 });
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.transform = void 0, t2.transformAsync = function() {
    return (0, o2.beginHiddenCallStack)(a2.async)(...arguments);
  }, t2.transformSync = function() {
    return (0, o2.beginHiddenCallStack)(a2.sync)(...arguments);
  };
  var s2 = r2(82), i2 = r2(295), o2 = r2(39);
  const a2 = n2()(function* (e3, t3) {
    const r3 = yield* (0, s2.default)(t3);
    return null === r3 ? null : yield* (0, i2.run)(r3, e3);
  });
  t2.transform = function(e3, t3, r3) {
    let n3, s3;
    if ("function" == typeof t3 ? (s3 = t3, n3 = void 0) : (n3 = t3, s3 = r3), void 0 === s3) return (0, o2.beginHiddenCallStack)(a2.sync)(e3, n3);
    (0, o2.beginHiddenCallStack)(a2.errback)(e3, n3, s3);
  };
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  class r2 {
    constructor(e3, t3, r3) {
      this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0, this.key = t3, this.file = e3, this.opts = r3 || {}, this.cwd = e3.opts.cwd, this.filename = e3.opts.filename;
    }
    set(e3, t3) {
      this._map.set(e3, t3);
    }
    get(e3) {
      return this._map.get(e3);
    }
    availableHelper(e3, t3) {
      return this.file.availableHelper(e3, t3);
    }
    addHelper(e3) {
      return this.file.addHelper(e3);
    }
    buildCodeFrameError(e3, t3, r3) {
      return this.file.buildCodeFrameError(e3, t3, r3);
    }
  }
  t2.default = r2, r2.prototype.getModuleName = function() {
    return this.file.getModuleName();
  }, r2.prototype.addImport = function() {
    this.file.addImport();
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(14);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function() {
    return i2 || (i2 = new s2.default(Object.assign({}, o2, { visitor: n2().default.explode(o2.visitor) }), {})), i2;
  };
  var s2 = r2(135);
  let i2;
  const o2 = { name: "internal.blockHoist", visitor: { Block: { exit(e3) {
    let { node: t3 } = e3;
    const { body: r3 } = t3;
    let n3 = Math.pow(2, 30) - 1, s3 = false;
    for (let e4 = 0; e4 < r3.length; e4++) {
      const t4 = a2(r3[e4]);
      if (t4 > n3) {
        s3 = true;
        break;
      }
      n3 = t4;
    }
    s3 && (t3.body = function(e4) {
      const t4 = /* @__PURE__ */ Object.create(null);
      for (let r5 = 0; r5 < e4.length; r5++) {
        const n5 = e4[r5], s4 = a2(n5);
        (t4[s4] || (t4[s4] = [])).push(n5);
      }
      const r4 = Object.keys(t4).map((e5) => +e5).sort((e5, t5) => t5 - e5);
      let n4 = 0;
      for (const s4 of r4) {
        const r5 = t4[s4];
        for (const t5 of r5) e4[n4++] = t5;
      }
      return e4;
    }(r3.slice()));
  } } } };
  function a2(e3) {
    const t3 = null == e3 ? void 0 : e3._blockHoist;
    return null == t3 ? 1 : true === t3 ? 2 : t3;
  }
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(479);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2() {
    const e3 = r2(10);
    return s2 = function() {
      return e3;
    }, e3;
  }
  function i2() {
    const e3 = r2(61);
    return i2 = function() {
      return e3;
    }, e3;
  }
  function o2() {
    const e3 = r2(0);
    return o2 = function() {
      return e3;
    }, e3;
  }
  function a2() {
    const e3 = r2(480);
    return a2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function* (e3, t3, r3, i3) {
    if (r3 = `${r3 || ""}`, i3) {
      if ("Program" === i3.type) i3 = p(i3, [], []);
      else if ("File" !== i3.type) throw new Error("AST root must be a Program or File node");
      t3.cloneInputAst && (i3 = (0, u.default)(i3));
    } else i3 = yield* (0, c.default)(e3, t3, r3);
    let o3 = null;
    if (false !== t3.inputSourceMap) {
      if ("object" == typeof t3.inputSourceMap && (o3 = a2().fromObject(t3.inputSourceMap)), !o3) {
        const e4 = g(h, i3);
        if (e4) try {
          o3 = a2().fromComment("//" + e4);
        } catch (e5) {
          f("discarding unknown inline input sourcemap");
        }
      }
      if (!o3) {
        const e4 = g(m, i3);
        if ("string" == typeof t3.filename && e4) try {
          const r4 = m.exec(e4), i4 = n2().readFileSync(s2().resolve(s2().dirname(t3.filename), r4[1]), "utf8");
          o3 = a2().fromJSON(i4);
        } catch (e5) {
          f("discarding unknown file input sourcemap", e5);
        }
        else e4 && f("discarding un-loadable file input sourcemap");
      }
    }
    return new l.default(t3, { code: r3, ast: i3, inputMap: o3 });
  };
  var l = r2(95), c = r2(297), u = r2(482);
  const { file: p, traverseFast: d } = o2(), f = i2()("babel:transform:file"), h = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/, m = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
  function y(e3, t3, r3) {
    return t3 && (t3 = t3.filter((t4) => {
      let { value: n3 } = t4;
      return !e3.test(n3) || (r3 = n3, false);
    })), [t3, r3];
  }
  function g(e3, t3) {
    let r3 = null;
    return d(t3, (t4) => {
      [t4.leadingComments, r3] = y(e3, t4.leadingComments, r3), [t4.innerComments, r3] = y(e3, t4.innerComments, r3), [t4.trailingComments, r3] = y(e3, t4.trailingComments, r3);
    }), r3;
  }
}, () => {
}, () => {
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, s2) {
    let i2 = `Support for the experimental syntax '${e3}' isn't currently enabled (${t3.line}:${t3.column + 1}):

` + s2;
    const o2 = r2[e3];
    if (o2) {
      const { syntax: e4, transform: t4 } = o2;
      if (e4) {
        const r3 = n2(e4);
        i2 += t4 ? `

Add ${n2(t4)} to the '${t4.name.startsWith("@babel/plugin") ? "plugins" : "presets"}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${r3} to the 'plugins' section to enable parsing.` : `

Add ${r3} to the 'plugins' section of your Babel config to enable parsing.`;
      }
    }
    return i2;
  };
  const r2 = { asyncDoExpressions: { syntax: { name: "@babel/plugin-syntax-async-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions" } }, decimal: { syntax: { name: "@babel/plugin-syntax-decimal", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal" } }, decorators: { syntax: { name: "@babel/plugin-syntax-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators" }, transform: { name: "@babel/plugin-proposal-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators" } }, doExpressions: { syntax: { name: "@babel/plugin-syntax-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions" }, transform: { name: "@babel/plugin-proposal-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions" } }, exportDefaultFrom: { syntax: { name: "@babel/plugin-syntax-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from" }, transform: { name: "@babel/plugin-proposal-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from" } }, flow: { syntax: { name: "@babel/plugin-syntax-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow" }, transform: { name: "@babel/preset-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow" } }, functionBind: { syntax: { name: "@babel/plugin-syntax-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind" }, transform: { name: "@babel/plugin-proposal-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind" } }, functionSent: { syntax: { name: "@babel/plugin-syntax-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent" }, transform: { name: "@babel/plugin-proposal-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent" } }, jsx: { syntax: { name: "@babel/plugin-syntax-jsx", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx" }, transform: { name: "@babel/preset-react", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react" } }, importAttributes: { syntax: { name: "@babel/plugin-syntax-import-attributes", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes" } }, pipelineOperator: { syntax: { name: "@babel/plugin-syntax-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator" }, transform: { name: "@babel/plugin-proposal-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator" } }, recordAndTuple: { syntax: { name: "@babel/plugin-syntax-record-and-tuple", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple" } }, throwExpressions: { syntax: { name: "@babel/plugin-syntax-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions" }, transform: { name: "@babel/plugin-proposal-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions" } }, typescript: { syntax: { name: "@babel/plugin-syntax-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript" }, transform: { name: "@babel/preset-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript" } } };
  Object.assign(r2, { asyncGenerators: { syntax: { name: "@babel/plugin-syntax-async-generators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators" }, transform: { name: "@babel/plugin-transform-async-generator-functions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions" } }, classProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateMethods: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-private-methods", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods" } }, classStaticBlock: { syntax: { name: "@babel/plugin-syntax-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block" }, transform: { name: "@babel/plugin-transform-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block" } }, dynamicImport: { syntax: { name: "@babel/plugin-syntax-dynamic-import", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import" } }, exportNamespaceFrom: { syntax: { name: "@babel/plugin-syntax-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from" }, transform: { name: "@babel/plugin-transform-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from" } }, importAssertions: { syntax: { name: "@babel/plugin-syntax-import-assertions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions" } }, importMeta: { syntax: { name: "@babel/plugin-syntax-import-meta", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta" } }, logicalAssignment: { syntax: { name: "@babel/plugin-syntax-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators" }, transform: { name: "@babel/plugin-transform-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators" } }, moduleStringNames: { syntax: { name: "@babel/plugin-syntax-module-string-names", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names" } }, numericSeparator: { syntax: { name: "@babel/plugin-syntax-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator" }, transform: { name: "@babel/plugin-transform-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator" } }, nullishCoalescingOperator: { syntax: { name: "@babel/plugin-syntax-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator" }, transform: { name: "@babel/plugin-transform-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator" } }, objectRestSpread: { syntax: { name: "@babel/plugin-syntax-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread" }, transform: { name: "@babel/plugin-transform-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread" } }, optionalCatchBinding: { syntax: { name: "@babel/plugin-syntax-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding" }, transform: { name: "@babel/plugin-transform-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding" } }, optionalChaining: { syntax: { name: "@babel/plugin-syntax-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining" }, transform: { name: "@babel/plugin-transform-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining" } }, privateIn: { syntax: { name: "@babel/plugin-syntax-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object" }, transform: { name: "@babel/plugin-transform-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object" } }, regexpUnicodeSets: { syntax: { name: "@babel/plugin-syntax-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md" }, transform: { name: "@babel/plugin-transform-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md" } } });
  const n2 = (e3) => {
    let { name: t3, url: r3 } = e3;
    return `${t3} (${r3})`;
  };
}, (e2, t2) => {
  function r2(e3, t3) {
    if (null !== e3) {
      if (t3.has(e3)) return t3.get(e3);
      let n2;
      if (Array.isArray(e3)) {
        n2 = new Array(e3.length), t3.set(e3, n2);
        for (let s2 = 0; s2 < e3.length; s2++) n2[s2] = "object" != typeof e3[s2] ? e3[s2] : r2(e3[s2], t3);
      } else {
        n2 = {}, t3.set(e3, n2);
        const s2 = Object.keys(e3);
        for (let i2 = 0; i2 < s2.length; i2++) {
          const o2 = s2[i2];
          n2[o2] = "object" != typeof e3[o2] ? e3[o2] : r2(e3[o2], t3);
        }
      }
      return n2;
    }
    return e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    return "object" != typeof e3 ? e3 : r2(e3, /* @__PURE__ */ new Map());
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(484);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2() {
    const e3 = r2(101);
    return s2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const { opts: r3, ast: o2, code: a2, inputMap: l } = t3, { generatorOpts: c } = r3;
    c.inputSourceMap = null == l ? void 0 : l.toObject();
    const u = [];
    for (const t4 of e3) for (const e4 of t4) {
      const { generatorOverride: t5 } = e4;
      if (t5) {
        const e5 = t5(o2, c, a2, s2().default);
        void 0 !== e5 && u.push(e5);
      }
    }
    let p;
    if (0 === u.length) p = (0, s2().default)(o2, c, a2);
    else {
      if (1 !== u.length) throw new Error("More than one plugin attempted to override codegen.");
      if (p = u[0], "function" == typeof p.then) throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
    }
    let { code: d, decodedMap: f = p.map } = p;
    return p.__mergedMap ? f = Object.assign({}, p.map) : f && (f = l ? (0, i2.default)(l.toObject(), f, c.sourceFileName) : p.map), "inline" !== r3.sourceMaps && "both" !== r3.sourceMaps || (d += "\n" + n2().fromObject(f).toComment()), "inline" === r3.sourceMaps && (f = null), { outputCode: d, outputMap: f };
  };
  var i2 = r2(485);
}, () => {
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(159);
    return n2 = function() {
      return e3;
    }, e3;
  }
  function s2(e3) {
    return Object.assign({}, e3, { sourceRoot: null });
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
    const i2 = r3.replace(/\\/g, "/");
    let o2 = false;
    const a2 = n2()(s2(t3), (t4, r4) => t4 !== i2 || o2 ? null : (o2 = true, r4.source = "", s2(e3)));
    return "string" == typeof e3.sourceRoot && (a2.sourceRoot = e3.sourceRoot), Object.assign({}, a2);
  };
}, () => {
}, () => {
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.transformFile = void 0, t2.transformFileAsync = function() {
    return Promise.reject(new Error("Transforming files is not supported in browsers"));
  }, t2.transformFileSync = function() {
    throw new Error("Transforming files is not supported in browsers");
  }, t2.transformFile = function(e3, t3, r2) {
    "function" == typeof t3 && (r2 = t3), r2(new Error("Transforming files is not supported in browsers"), null);
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.transformFromAst = void 0, t2.transformFromAstAsync = function() {
    return (0, o2.beginHiddenCallStack)(a2.async)(...arguments);
  }, t2.transformFromAstSync = function() {
    return (0, o2.beginHiddenCallStack)(a2.sync)(...arguments);
  };
  var s2 = r2(82), i2 = r2(295), o2 = r2(39);
  const a2 = n2()(function* (e3, t3, r3) {
    const n3 = yield* (0, s2.default)(r3);
    if (null === n3) return null;
    if (!e3) throw new Error("No AST given");
    return yield* (0, i2.run)(n3, t3, e3);
  });
  t2.transformFromAst = function(e3, t3, r3, n3) {
    let s3, i3;
    if ("function" == typeof r3 ? (i3 = r3, s3 = void 0) : (s3 = r3, i3 = n3), void 0 === i3) return (0, o2.beginHiddenCallStack)(a2.sync)(e3, t3, s3);
    (0, o2.beginHiddenCallStack)(a2.errback)(e3, t3, s3, i3);
  };
}, (e2, t2, r2) => {
  function n2() {
    const e3 = r2(13);
    return n2 = function() {
      return e3;
    }, e3;
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.parse = void 0, t2.parseAsync = function() {
    return (0, a2.beginHiddenCallStack)(l.async)(...arguments);
  }, t2.parseSync = function() {
    return (0, a2.beginHiddenCallStack)(l.sync)(...arguments);
  };
  var s2 = r2(82), i2 = r2(297), o2 = r2(296), a2 = r2(39);
  const l = n2()(function* (e3, t3) {
    const r3 = yield* (0, s2.default)(t3);
    return null === r3 ? null : yield* (0, i2.default)(r3.passes, (0, o2.default)(r3), e3);
  });
  t2.parse = function(e3, t3, r3) {
    if ("function" == typeof t3 && (r3 = t3, t3 = void 0), void 0 === r3) return (0, a2.beginHiddenCallStack)(l.sync)(e3, t3);
    (0, a2.beginHiddenCallStack)(l.errback)(e3, t3, r3);
  };
}, (e2, t2, r2) => {
  t2.a = void 0;
  var n2 = r2(16), s2 = r2(68), i2 = r2(251), o2 = r2(1), a2 = r2(492), l = r2(493), c = r2(494);
  t2.a = (0, n2.declare)((e3, t3) => {
    var r3, n3, u;
    e3.assertVersion(7);
    const { strictNamespace: p = false, mjsStrictNamespace: d = p, allowTopLevelThis: f, strict: h, strictMode: m, noInterop: y, importInterop: g, lazy: b = false, allowCommonJSExports: v = true, loose: E = false } = t3, S = null != (r3 = e3.assumption("constantReexports")) ? r3 : E, x = null != (n3 = e3.assumption("enumerableModuleMeta")) ? n3 : E, T = null != (u = e3.assumption("noIncompleteNsImportDetection")) && u;
    if (!("boolean" == typeof b || "function" == typeof b || Array.isArray(b) && b.every((e4) => "string" == typeof e4))) throw new Error(".lazy must be a boolean, array of strings, or a function");
    if ("boolean" != typeof p) throw new Error(".strictNamespace must be a boolean, or undefined");
    if ("boolean" != typeof d) throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
    const w = (e4) => o2.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${e4}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, P = { ReferencedIdentifier(e4) {
      const t4 = e4.node.name;
      if ("module" !== t4 && "exports" !== t4) return;
      const r4 = e4.scope.getBinding(t4);
      this.scope.getBinding(t4) !== r4 || e4.parentPath.isObjectProperty({ value: e4.node }) && e4.parentPath.parentPath.isObjectPattern() || e4.parentPath.isAssignmentExpression({ left: e4.node }) || e4.isAssignmentExpression({ left: e4.node }) || e4.replaceWith(w(t4));
    }, UpdateExpression(e4) {
      const t4 = e4.get("argument");
      if (!t4.isIdentifier()) return;
      const r4 = t4.node.name;
      if ("module" !== r4 && "exports" !== r4) return;
      const n4 = e4.scope.getBinding(r4);
      this.scope.getBinding(r4) === n4 && e4.replaceWith(o2.types.assignmentExpression(e4.node.operator[0] + "=", t4.node, w(r4)));
    }, AssignmentExpression(e4) {
      const t4 = e4.get("left");
      if (t4.isIdentifier()) {
        const r4 = t4.node.name;
        if ("module" !== r4 && "exports" !== r4) return;
        const n4 = e4.scope.getBinding(r4);
        if (this.scope.getBinding(r4) !== n4) return;
        const s3 = e4.get("right");
        s3.replaceWith(o2.types.sequenceExpression([s3.node, w(r4)]));
      } else if (t4.isPattern()) {
        const r4 = t4.getOuterBindingIdentifiers(), n4 = Object.keys(r4).filter((t5) => ("module" === t5 || "exports" === t5) && this.scope.getBinding(t5) === e4.scope.getBinding(t5))[0];
        if (n4) {
          const t5 = e4.get("right");
          t5.replaceWith(o2.types.sequenceExpression([t5.node, w(n4)]));
        }
      }
    } };
    return { name: "transform-modules-commonjs", pre() {
      this.file.set("@babel/plugin-transform-modules-*", "commonjs"), b && (0, c.defineCommonJSHook)(this.file, (0, l.lazyImportsHook)(b));
    }, visitor: { ["CallExpression" + (e3.types.importExpression ? "|ImportExpression" : "")](e4) {
      if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
      if (e4.isCallExpression() && !o2.types.isImport(e4.node.callee)) return;
      let { scope: t4 } = e4;
      do {
        t4.rename("require");
      } while (t4 = t4.parent);
      (0, a2.transformDynamicImport)(e4, y, this.file);
    }, Program: { exit(e4, r4) {
      if (!(0, s2.isModule)(e4)) return;
      e4.scope.rename("exports"), e4.scope.rename("module"), e4.scope.rename("require"), e4.scope.rename("__filename"), e4.scope.rename("__dirname"), v || ((0, i2.default)(e4, /* @__PURE__ */ new Set(["module", "exports"]), false), e4.traverse(P, { scope: e4.scope }));
      let n4 = (0, s2.getModuleName)(this.file.opts, t3);
      n4 && (n4 = o2.types.stringLiteral(n4));
      const a3 = (0, c.makeInvokers)(this.file), { meta: l2, headers: u2 } = (0, s2.rewriteModuleStatementsAndPrepareHeader)(e4, { exportName: "exports", constantReexports: S, enumerableModuleMeta: x, strict: h, strictMode: m, allowTopLevelThis: f, noInterop: y, importInterop: g, wrapReference: a3.wrapReference, getWrapperPayload: a3.getWrapperPayload, esNamespaceOnly: "string" == typeof r4.filename && /\.mjs$/.test(r4.filename) ? d : p, noIncompleteNsImportDetection: T, filename: this.file.opts.filename });
      for (const [t4, r5] of l2.source) {
        const n5 = o2.types.callExpression(o2.types.identifier("require"), [o2.types.stringLiteral(t4)]);
        let i3;
        if ((0, s2.isSideEffectImport)(r5)) {
          if (b && "function" === r5.wrap) throw new Error("Assertion failure");
          i3 = o2.types.expressionStatement(n5);
        } else {
          const t5 = (0, s2.wrapInterop)(e4, n5, r5.interop) || n5;
          if (r5.wrap) {
            const e5 = a3.buildRequireWrapper(r5.name, t5, r5.wrap, r5.referenced);
            if (false === e5) continue;
            i3 = e5;
          }
          null != i3 || (i3 = o2.template.statement.ast`
                var ${r5.name} = ${t5};
              `);
        }
        i3.loc = r5.loc, u2.push(i3), u2.push(...(0, s2.buildNamespaceInitStatements)(l2, r5, S, a3.wrapReference));
      }
      (0, s2.ensureStatementsHoisted)(u2), e4.unshiftContainer("body", u2), e4.get("body").forEach((e5) => {
        -1 !== u2.indexOf(e5.node) && e5.isVariableDeclaration() && e5.scope.registerDeclaration(e5);
      });
    } } } };
  });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.transformDynamicImport = function(e3, t3, r3) {
    const n3 = t3 ? i2 : o2;
    e3.replaceWith((0, s2.buildDynamicImport)(e3.node, true, false, (e4) => n3(e4, r3)));
  };
  var n2 = r2(1), s2 = r2(68);
  const i2 = (e3) => n2.template.expression.ast`require(${e3})`, o2 = (e3, t3) => n2.types.callExpression(t3.addHelper("interopRequireWildcard"), [i2(e3)]);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.lazyImportsHook = void 0;
  var n2 = r2(1), s2 = r2(68);
  t2.lazyImportsHook = (e3) => ({ name: "@babel/plugin-transform-modules-commonjs/lazy", version: "7.23.3", getWrapperPayload: (t3, r3) => (0, s2.isSideEffectImport)(r3) || r3.reexportAll ? null : true === e3 ? /\./.test(t3) ? null : "lazy/function" : Array.isArray(e3) ? -1 === e3.indexOf(t3) ? null : "lazy/function" : "function" == typeof e3 ? e3(t3) ? "lazy/function" : null : void 0, buildRequireWrapper(e4, t3, r3, s3) {
    if ("lazy/function" === r3) return !!s3 && n2.template.statement.ast`
        function ${e4}() {
          const data = ${t3};
          ${e4} = function(){ return data; };
          return data;
        }
      `;
  }, wrapReference(e4, t3) {
    if ("lazy/function" === t3) return n2.types.callExpression(e4, []);
  } });
}, (e2, t2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.defineCommonJSHook = function(e3, t3) {
    let n3 = e3.get(r2);
    n3 || e3.set(r2, n3 = []), n3.push(t3);
  }, t2.makeInvokers = function(e3) {
    const t3 = e3.get(r2);
    return { getWrapperPayload() {
      for (var e4 = arguments.length, r3 = new Array(e4), s2 = 0; s2 < e4; s2++) r3[s2] = arguments[s2];
      return n2(t3, (e5) => null == e5.getWrapperPayload ? void 0 : e5.getWrapperPayload(...r3));
    }, wrapReference() {
      for (var e4 = arguments.length, r3 = new Array(e4), s2 = 0; s2 < e4; s2++) r3[s2] = arguments[s2];
      return n2(t3, (e5) => null == e5.wrapReference ? void 0 : e5.wrapReference(...r3));
    }, buildRequireWrapper() {
      for (var e4 = arguments.length, r3 = new Array(e4), s2 = 0; s2 < e4; s2++) r3[s2] = arguments[s2];
      return n2(t3, (e5) => null == e5.buildRequireWrapper ? void 0 : e5.buildRequireWrapper(...r3));
    } };
  };
  const r2 = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
  function n2(e3, t3) {
    if (e3) for (const r3 of e3) {
      const e4 = t3(r3);
      if (null != e4) return e4;
    }
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(16), s2 = function(e3, t3) {
    const r3 = [];
    e3.forEach((e4, n3) => {
      (Array.isArray(e4) ? e4[0] : e4) === t3 && r3.unshift(n3);
    });
    for (const t4 of r3) e3.splice(t4, 1);
  };
  t2.default = (0, n2.declare)((e3, t3) => {
    e3.assertVersion(7);
    const { disallowAmbiguousJSXLike: r3, dts: n3 } = t3;
    var { isTSX: i2 } = t3;
    return { name: "syntax-typescript", manipulateOptions(e4, t4) {
      {
        const { plugins: e5 } = t4;
        s2(e5, "flow"), s2(e5, "jsx"), e5.push("objectRestSpread", "classProperties"), i2 && e5.push("jsx");
      }
      t4.plugins.push(["typescript", { disallowAmbiguousJSXLike: r3, dts: n3 }]);
    } };
  });
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, f2) {
    let { assertVersion: E2, assumption: O2 } = e3, { loose: D2 } = t3;
    var L;
    E2("2023-05" === r3 || "2023-01" === r3 ? "^7.21.0" : "2021-12" === r3 ? "^7.16.0" : "^7.19.0");
    const M = /* @__PURE__ */ new WeakSet(), B = null != (L = O2("constantSuper")) ? L : D2, R = /* @__PURE__ */ function(e4, t4) {
      function r4(e5, t5, r5) {
        switch (t5.type) {
          case "StringLiteral":
            return n2.types.stringLiteral(t5.value);
          case "NumericLiteral":
          case "BigIntLiteral": {
            const r6 = t5.value + "";
            return e5.get("key").replaceWith(n2.types.stringLiteral(r6)), n2.types.stringLiteral(r6);
          }
          default: {
            const s3 = e5.scope.maybeGenerateMemoised(t5);
            return e5.get("key").replaceWith(n2.types.assignmentExpression("=", s3, I(r5, t5))), n2.types.cloneNode(s3);
          }
        }
      }
      return { VariableDeclarator(r5, n3) {
        const s3 = r5.node.id;
        if ("Identifier" === s3.type) {
          const i3 = (0, o2.skipTransparentExprWrappers)(r5.get("init"));
          if (e4(i3)) {
            const e5 = s3.name;
            t4(i3, n3, e5);
          }
        }
      }, AssignmentExpression(r5, n3) {
        const s3 = r5.node.left;
        if ("Identifier" === s3.type) {
          const i3 = (0, o2.skipTransparentExprWrappers)(r5.get("right"));
          if (e4(i3)) switch (r5.node.operator) {
            case "=":
            case "&&=":
            case "||=":
            case "??=":
              t4(i3, n3, s3.name);
          }
        }
      }, AssignmentPattern(r5, n3) {
        const s3 = r5.node.left;
        if ("Identifier" === s3.type) {
          const i3 = (0, o2.skipTransparentExprWrappers)(r5.get("right"));
          if (e4(i3)) {
            const e5 = s3.name;
            t4(i3, n3, e5);
          }
        }
      }, ObjectExpression(s3, i3) {
        for (const a3 of s3.get("properties")) {
          const { node: s4 } = a3;
          if ("ObjectProperty" !== s4.type) continue;
          const l2 = s4.key, c2 = (0, o2.skipTransparentExprWrappers)(a3.get("value"));
          if (e4(c2)) {
            if (s4.computed) {
              const e5 = r4(a3, l2, i3);
              t4(c2, i3, e5);
            } else if (!k(l2)) if ("Identifier" === l2.type) t4(c2, i3, l2.name);
            else {
              const e5 = n2.types.stringLiteral(l2.value + "");
              t4(c2, i3, e5);
            }
          }
        }
      }, ClassPrivateProperty(r5, s3) {
        const { node: i3 } = r5, a3 = (0, o2.skipTransparentExprWrappers)(r5.get("value"));
        if (e4(a3)) {
          const e5 = n2.types.stringLiteral("#" + i3.key.id.name);
          t4(a3, s3, e5);
        }
      }, ClassAccessorProperty(s3, i3) {
        const { node: a3 } = s3, l2 = a3.key, c2 = (0, o2.skipTransparentExprWrappers)(s3.get("value"));
        if (e4(c2)) if (a3.computed) {
          const e5 = r4(s3, l2, i3);
          t4(c2, i3, e5);
        } else if ("Identifier" === l2.type) t4(c2, i3, l2.name);
        else if ("PrivateName" === l2.type) {
          const e5 = n2.types.stringLiteral("#" + l2.id.name);
          t4(c2, i3, e5);
        } else {
          const e5 = n2.types.stringLiteral(l2.value + "");
          t4(c2, i3, e5);
        }
      }, ClassProperty(s3, i3) {
        const { node: a3 } = s3, l2 = a3.key, c2 = (0, o2.skipTransparentExprWrappers)(s3.get("value"));
        if (e4(c2)) if (a3.computed) {
          const e5 = r4(s3, l2, i3);
          t4(c2, i3, e5);
        } else if ("Identifier" === l2.type) t4(c2, i3, l2.name);
        else {
          const e5 = n2.types.stringLiteral(l2.value + "");
          t4(c2, i3, e5);
        }
      } };
    }(j, F);
    function F(e4, t4, i3) {
      var o3;
      if (M.has(e4)) return;
      const { node: f3 } = e4;
      null != i3 || (i3 = null == (o3 = f3.id) ? void 0 : o3.name);
      const E3 = function(e5, t5, r4, i4, o4, f4) {
        const E4 = e5.get("body.body"), O3 = e5.node.decorators;
        let k2 = false;
        const N2 = /* @__PURE__ */ function(e6) {
          let t6;
          return () => (t6 || (t6 = function(e7) {
            const t7 = [], r5 = /* @__PURE__ */ new Set();
            return e7.traverse({ PrivateName(e8) {
              r5.add(e8.node.id.name);
            } }), () => {
              let e8;
              do {
                a2(t7), e8 = String.fromCharCode(...t7);
              } while (r5.has(e8));
              return n2.types.privateName(n2.types.identifier(e8));
            };
          }(e6)), t6());
        }(e5), D3 = [], j2 = e5.scope.parent, L2 = (e6, t6) => {
          const r5 = j2.generateDeclaredUidIdentifier(t6);
          return D3.push(n2.types.assignmentExpression("=", r5, e6)), n2.types.cloneNode(r5);
        };
        for (const r5 of E4) if (A(r5)) {
          if (r5.node.decorators && r5.node.decorators.length > 0) {
            switch (r5.node.type) {
              case "ClassProperty":
                f4.ClassProperty(r5, t5);
                break;
              case "ClassPrivateProperty":
                f4.ClassPrivateProperty(r5, t5);
                break;
              case "ClassAccessorProperty":
                f4.ClassAccessorProperty(r5, t5);
            }
            k2 = true;
          } else if ("ClassAccessorProperty" === r5.node.type) {
            f4.ClassAccessorProperty(r5, t5);
            const { key: n3, value: s3, static: o5, computed: a3 } = r5.node, u2 = N2(), p2 = l(u2, s3, o5), d2 = r5.get("key"), [h2] = r5.replaceWith(p2);
            c(e5.node.id, h2, a3 && !d2.isConstantExpression() ? L2(I(t5, n3), "computedKey") : n3, u2, i4, a3);
          }
        }
        if (!O3 && !k2) return void (D3.length > 0 && (e5.insertBefore(D3.map((e6) => n2.types.expressionStatement(e6))), e5.scope.crawl()));
        const M2 = [];
        let B2, R2, F2 = false, U = false;
        const $ = /* @__PURE__ */ new Set();
        let V, q, W, G;
        const H = /* @__PURE__ */ new Map(), z = (e6) => {
          const { expression: t6 } = e6;
          if ("2023-05" === i4 && n2.types.isMemberExpression(t6)) {
            let r5;
            n2.types.isSuper(t6.object) || n2.types.isThisExpression(t6.object) ? r5 = L2(n2.types.thisExpression(), "obj") : j2.isStatic(t6.object) ? r5 = t6.object : (r5 = L2(t6.object, "obj"), t6.object = r5), H.set(e6, n2.types.cloneNode(r5));
          }
          j2.isStatic(t6) || (e6.expression = L2(t6, "dec"));
        };
        let K, X = false;
        if (O3) {
          W = j2.generateDeclaredUidIdentifier("initClass"), X = e5.isClassDeclaration(), { id: G, path: e5 } = function(e6, t6) {
            if ("ClassDeclaration" === e6.type) {
              const t7 = e6.node.id, r5 = t7.name, s3 = e6.scope.generateUidIdentifierBasedOnNode(t7), i5 = n2.types.identifier(r5);
              return e6.scope.rename(r5, s3.name), e6.get("id").replaceWith(i5), { id: n2.types.cloneNode(s3), path: e6 };
            }
            {
              let r5;
              e6.node.id ? (t6 = e6.node.id.name, r5 = e6.scope.parent.generateDeclaredUidIdentifier(t6), e6.scope.rename(t6, r5.name)) : r5 = e6.scope.parent.generateDeclaredUidIdentifier("string" == typeof t6 ? t6 : "decorated_class");
              const s3 = n2.types.classExpression("string" == typeof t6 ? n2.types.identifier(t6) : null, e6.node.superClass, e6.node.body), [i5] = e6.replaceWith(n2.types.sequenceExpression([s3, r5]));
              return { id: n2.types.cloneNode(r5), path: i5.get("expressions.0") };
            }
          }(e5, o4), e5.node.decorators = null;
          for (const e6 of O3) z(e6);
        } else e5.node.id || (e5.node.id = e5.scope.generateUidIdentifier("Class")), G = n2.types.cloneNode(e5.node.id);
        let J = false;
        if (k2) for (const o5 of E4) {
          if (!A(o5)) continue;
          const { node: a3 } = o5, f5 = o5.get("decorators"), y2 = Array.isArray(f5) && f5.length > 0;
          if (y2) for (const e6 of f5) z(e6.node);
          const g2 = "computed" in o5.node && true === o5.node.computed;
          g2 && (o5.get("key").isConstantExpression() || (a3.key = L2(I(t5, a3.key), "computedKey")));
          const b2 = v(o5), { key: E5 } = a3, S2 = "PrivateName" === E5.type, x2 = !!o5.node.static;
          let C2 = "computedKey";
          if (S2 ? C2 = E5.id.name : g2 || "Identifier" !== E5.type || (C2 = E5.name), S2 && !x2 && (y2 && (J = true), !n2.types.isClassPrivateProperty(a3) && K || (K = E5)), o5.isClassMethod({ kind: "constructor" }) && (R2 = o5), y2) {
            let a4, y3, v2;
            if (b2 === d) {
              const { value: t6 } = o5.node, r5 = [n2.types.thisExpression()];
              t6 && r5.push(n2.types.cloneNode(t6));
              const s3 = N2(), p2 = o5.scope.parent.generateDeclaredUidIdentifier(`init_${C2}`), d2 = l(s3, n2.types.callExpression(n2.types.cloneNode(p2), r5), x2), [f6] = o5.replaceWith(d2);
              if (S2) {
                y3 = u(s3, i4);
                const e6 = f6.scope.parent.generateDeclaredUidIdentifier(`get_${C2}`), t7 = f6.scope.parent.generateDeclaredUidIdentifier(`set_${C2}`);
                T(f6, E5, e6, t7), a4 = [p2, e6, t7];
              } else c(e5.node.id, f6, E5, s3, i4, g2), a4 = p2;
            } else if (b2 === p) {
              const e6 = o5.scope.parent.generateDeclaredUidIdentifier(`init_${C2}`), t6 = o5.get("value");
              t6.replaceWith(n2.types.callExpression(n2.types.cloneNode(e6), [n2.types.thisExpression(), t6.node].filter((e7) => e7))), a4 = e6, S2 && (y3 = u(E5, i4));
            } else if (S2) {
              a4 = o5.scope.parent.generateDeclaredUidIdentifier(`call_${C2}`), new s2.default({ constantSuper: r4, methodPath: o5, objectRef: G, superRef: e5.node.superClass, file: t5.file, refToPreserve: G }).replace();
              const { params: i5, body: l2, async: c2 } = o5.node;
              if (y3 = [n2.types.functionExpression(void 0, i5.filter(w), l2, c2)], b2 === h || b2 === m) P(o5, n2.types.cloneNode(E5), n2.types.cloneNode(a4), x2);
              else {
                const t6 = o5.node;
                e5.node.body.body.unshift(n2.types.classPrivateProperty(E5, n2.types.cloneNode(a4), [], t6.static)), $.add(E5.id.name), o5.remove();
              }
            }
            v2 = g2 ? n2.types.cloneNode(E5) : "PrivateName" === E5.type ? n2.types.stringLiteral(E5.id.name) : "Identifier" === E5.type ? n2.types.stringLiteral(E5.name) : n2.types.cloneNode(E5), M2.push({ kind: b2, decorators: f5.map((e6) => e6.node.expression), decoratorsThis: f5.map((e6) => H.get(e6.node)), name: v2, isStatic: x2, privateMethods: y3, locals: a4 }), b2 !== p && (x2 ? U = true : F2 = true), o5.node && (o5.node.decorators = null), B2 || x2 || b2 !== p && b2 !== d || (B2 = o5);
          }
        }
        const Y = function(e6, t6) {
          return n2.types.arrayExpression(S(e6).map((e7) => {
            const { decs: r5, hasThis: s3 } = x(e7.decorators, e7.decoratorsThis, t6);
            let i5 = e7.kind;
            return e7.isStatic && (i5 += "2023-05" === t6 ? g : y), s3 && (i5 += b), n2.types.arrayExpression([1 === r5.length ? r5[0] : n2.types.arrayExpression(r5), n2.types.numericLiteral(i5), e7.name, ...e7.privateMethods || []]);
          }));
        }(M2, i4);
        let Q = 0, Z = [];
        if (O3) {
          const { hasThis: e6, decs: t6 } = x(O3.map((e7) => e7.expression), O3.map((e7) => H.get(e7)), i4);
          Q = e6 ? 1 : 0, Z = t6;
        }
        const ee = function(e6) {
          const t6 = [];
          for (const r5 of S(e6)) {
            const { locals: e7 } = r5;
            Array.isArray(e7) ? t6.push(...e7) : void 0 !== e7 && t6.push(e7);
          }
          return t6;
        }(M2);
        if (F2) {
          V = j2.generateDeclaredUidIdentifier("initProto"), ee.push(V);
          const t6 = n2.types.callExpression(n2.types.cloneNode(V), [n2.types.thisExpression()]);
          if (B2) {
            const e6 = B2.get("value"), r5 = [t6];
            e6.node && r5.push(e6.node), e6.replaceWith(n2.types.sequenceExpression(r5));
          } else if (R2) e5.node.superClass ? R2.traverse({ CallExpression: { exit(e6) {
            e6.get("callee").isSuper() && (e6.replaceWith(n2.types.callExpression(n2.types.cloneNode(V), [e6.node])), e6.skip());
          } }, ClassMethod(e6) {
            "constructor" === e6.node.kind && e6.skip();
          } }) : R2.node.body.body.unshift(n2.types.expressionStatement(t6));
          else {
            const r5 = [n2.types.expressionStatement(t6)];
            e5.node.superClass && r5.unshift(n2.types.expressionStatement(n2.types.callExpression(n2.types.super(), [n2.types.spreadElement(n2.types.identifier("args"))]))), e5.node.body.body.unshift(n2.types.classMethod("constructor", n2.types.identifier("constructor"), [n2.types.restElement(n2.types.identifier("args"))], n2.types.blockStatement(r5)));
          }
        }
        U && (q = j2.generateDeclaredUidIdentifier("initStatic"), ee.push(q)), $.size > 0 && e5.traverse({ PrivateName(e6) {
          if (!$.has(e6.node.id.name)) return;
          const t6 = e6.parentPath, r5 = t6.parentPath;
          if ("AssignmentExpression" === r5.node.type && r5.node.left === t6.node || "UpdateExpression" === r5.node.type || "RestElement" === r5.node.type || "ArrayPattern" === r5.node.type || "ObjectProperty" === r5.node.type && r5.node.value === t6.node && "ObjectPattern" === r5.parentPath.type || "ForOfStatement" === r5.node.type && r5.node.left === t6.node) throw e6.buildCodeFrameError(`Decorated private methods are not updatable, but "#${e6.node.id.name}" is updated via this expression.`);
        } });
        const te = [];
        let re = false;
        const ne = W && n2.types.callExpression(n2.types.cloneNode(W), []), se = e5.node;
        if (O3) {
          te.push(G, W);
          const r5 = [];
          let s3 = [];
          if (e5.get("body.body").forEach((e6) => {
            if (e6.isStaticBlock()) return s3.push(e6.node), void e6.remove();
            const t6 = e6.isClassProperty() || e6.isClassPrivateProperty();
            if ((t6 || e6.isClassPrivateMethod()) && e6.node.static) {
              if (t6 && s3.length > 0) {
                const t7 = s3.map(C);
                e6.node.value && t7.push(e6.node.value), e6.node.value = 0 === (i5 = t7).length ? n2.types.unaryExpression("void", n2.types.numericLiteral(0)) : 1 === i5.length ? i5[0] : n2.types.sequenceExpression(i5), s3 = [];
              }
              e6.node.static = false, r5.push(e6.node), e6.remove();
            }
            var i5;
          }), r5.length > 0 || s3.length > 0) {
            const i5 = n2.template.expression.ast`
        class extends ${t5.addHelper("identity")} {}
      `;
            i5.body.body = [n2.types.staticBlock([n2.types.toStatement(se, true) || n2.types.expressionStatement(se)]), ...r5];
            const o5 = [], a3 = n2.types.newExpression(i5, []);
            s3.length > 0 && o5.push(...s3.map(C)), ne && (re = true, o5.push(ne)), o5.length > 0 ? (o5.unshift(n2.types.callExpression(n2.types.super(), [n2.types.cloneNode(G)])), i5.body.body.push(n2.types.classMethod("constructor", n2.types.identifier("constructor"), [], n2.types.blockStatement([n2.types.expressionStatement(n2.types.sequenceExpression(o5))])))) : a3.arguments.push(n2.types.cloneNode(G)), e5.replaceWith(a3);
          }
        }
        !re && ne && e5.node.body.body.push(n2.types.staticBlock([n2.types.expressionStatement(ne)]));
        let { superClass: ie } = se;
        if (ie && "2023-05" === i4) {
          const t6 = e5.scope.maybeGenerateMemoised(ie);
          t6 && (se.superClass = n2.types.assignmentExpression("=", t6, ie), ie = t6);
        }
        return se.body.body.unshift(n2.types.staticBlock([n2.types.expressionStatement(_(ee, te, Y, n2.types.arrayExpression(Z), n2.types.numericLiteral(Q), J ? K : null, "object" == typeof o4 ? o4 : void 0, n2.types.cloneNode(ie), t5, i4)), U && n2.types.expressionStatement(n2.types.callExpression(n2.types.cloneNode(q), [n2.types.thisExpression()]))].filter(Boolean))), e5.insertBefore(D3.map((e6) => n2.types.expressionStatement(e6))), X && e5.insertBefore(n2.types.variableDeclaration("let", [n2.types.variableDeclarator(n2.types.cloneNode(G))])), e5.scope.crawl(), e5;
      }(e4, t4, B, r3, i3, R);
      E3 ? M.add(E3) : M.add(e4);
    }
    return { name: "proposal-decorators", inherits: f2, visitor: Object.assign({ ExportDefaultDeclaration(e4, t4) {
      const { declaration: r4 } = e4.node;
      if ("ClassDeclaration" === (null == r4 ? void 0 : r4.type) && N(r4)) {
        const s3 = !r4.id, o3 = (0, i2.default)(e4);
        s3 && F(o3, t4, n2.types.stringLiteral("default"));
      }
    }, ExportNamedDeclaration(e4) {
      const { declaration: t4 } = e4.node;
      "ClassDeclaration" === (null == t4 ? void 0 : t4.type) && N(t4) && (0, i2.default)(e4);
    }, Class(e4, t4) {
      F(e4, t4, void 0);
    } }, R) };
  };
  var n2 = r2(1), s2 = r2(141), i2 = r2(62), o2 = r2(301);
  function a2(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e3.length - 1;
    if (-1 === t3) return void e3.unshift(65);
    const r3 = e3[t3];
    90 === r3 ? e3[t3] = 97 : 122 === r3 ? (e3[t3] = 65, a2(e3, t3 - 1)) : e3[t3] = r3 + 1;
  }
  function l(e3, t3, r3) {
    return "PrivateName" === e3.type ? n2.types.classPrivateProperty(e3, t3, void 0, r3) : n2.types.classProperty(e3, t3, void 0, void 0, r3);
  }
  function c(e3, t3, r3, s3, i3) {
    let o3 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
    const { static: a3 } = t3.node, l2 = "2023-05" === i3 && a3 ? e3 : n2.types.thisExpression(), c2 = n2.types.blockStatement([n2.types.returnStatement(n2.types.memberExpression(n2.types.cloneNode(l2), n2.types.cloneNode(s3)))]), u2 = n2.types.blockStatement([n2.types.expressionStatement(n2.types.assignmentExpression("=", n2.types.memberExpression(n2.types.cloneNode(l2), n2.types.cloneNode(s3)), n2.types.identifier("v")))]);
    let p2, d2;
    "PrivateName" === r3.type ? (p2 = n2.types.classPrivateMethod("get", n2.types.cloneNode(r3), [], c2, a3), d2 = n2.types.classPrivateMethod("set", n2.types.cloneNode(r3), [n2.types.identifier("v")], u2, a3)) : (p2 = n2.types.classMethod("get", n2.types.cloneNode(r3), [], c2, o3, a3), d2 = n2.types.classMethod("set", n2.types.cloneNode(r3), [n2.types.identifier("v")], u2, o3, a3)), t3.insertAfter(d2), t3.insertAfter(p2);
  }
  function u(e3, t3) {
    return "2023-05" !== t3 && "2023-01" !== t3 ? [n2.template.expression.ast`
        function () {
          return this.${n2.types.cloneNode(e3)};
        }
      `, n2.template.expression.ast`
        function (value) {
          this.${n2.types.cloneNode(e3)} = value;
        }
      `] : [n2.template.expression.ast`
      o => o.${n2.types.cloneNode(e3)}
    `, n2.template.expression.ast`
      (o, v) => o.${n2.types.cloneNode(e3)} = v
    `];
  }
  const p = 0, d = 1, f = 2, h = 3, m = 4, y = 5, g = 8, b = 16;
  function v(e3) {
    switch (e3.node.type) {
      case "ClassProperty":
      case "ClassPrivateProperty":
        return p;
      case "ClassAccessorProperty":
        return d;
      case "ClassMethod":
      case "ClassPrivateMethod":
        return "get" === e3.node.kind ? h : "set" === e3.node.kind ? m : f;
    }
  }
  function E(e3) {
    return "decorators" in e3;
  }
  function S(e3) {
    const t3 = e3.filter(E);
    return [...t3.filter((e4) => e4.isStatic && e4.kind >= d && e4.kind <= m), ...t3.filter((e4) => !e4.isStatic && e4.kind >= d && e4.kind <= m), ...t3.filter((e4) => e4.isStatic && e4.kind === p), ...t3.filter((e4) => !e4.isStatic && e4.kind === p)];
  }
  function x(e3, t3, r3) {
    const s3 = e3.length, i3 = t3.some(Boolean), o3 = [];
    for (let a3 = 0; a3 < s3; a3++) "2023-05" === r3 && i3 && o3.push(t3[a3] || n2.types.unaryExpression("void", n2.types.numericLiteral(0))), o3.push(e3[a3]);
    return { hasThis: i3, decs: o3 };
  }
  function T(e3, t3, r3, s3) {
    e3.insertAfter(n2.types.classPrivateMethod("get", n2.types.cloneNode(t3), [], n2.types.blockStatement([n2.types.returnStatement(n2.types.callExpression(n2.types.cloneNode(r3), [n2.types.thisExpression()]))]))), e3.insertAfter(n2.types.classPrivateMethod("set", n2.types.cloneNode(t3), [n2.types.identifier("v")], n2.types.blockStatement([n2.types.expressionStatement(n2.types.callExpression(n2.types.cloneNode(s3), [n2.types.thisExpression(), n2.types.identifier("v")]))])));
  }
  function w(e3) {
    return "TSParameterProperty" !== e3.type;
  }
  function P(e3, t3, r3, s3) {
    let i3, o3;
    "set" === e3.node.kind ? (i3 = [n2.types.identifier("v")], o3 = [n2.types.expressionStatement(n2.types.callExpression(r3, [n2.types.thisExpression(), n2.types.identifier("v")]))]) : (i3 = [], o3 = [n2.types.returnStatement(n2.types.callExpression(r3, [n2.types.thisExpression()]))]), e3.replaceWith(n2.types.classPrivateMethod(e3.node.kind, n2.types.cloneNode(t3), i3, n2.types.blockStatement(o3), s3));
  }
  function A(e3) {
    const { type: t3 } = e3;
    return "TSDeclareMethod" !== t3 && "TSIndexSignature" !== t3 && "StaticBlock" !== t3;
  }
  function C(e3) {
    return n2.types.callExpression(n2.types.arrowFunctionExpression([], n2.types.blockStatement(e3.body)), []);
  }
  function O(e3, t3) {
    return n2.types.callExpression(e3.addHelper("setFunctionName"), [n2.types.thisExpression(), t3]);
  }
  function I(e3, t3) {
    return n2.types.callExpression(e3.addHelper("toPropertyKey"), [t3]);
  }
  function _(e3, t3, r3, s3, i3, o3, a3, l2, c2, u2) {
    let p2, d2;
    const f2 = [a3 ? O(c2, a3) : n2.types.thisExpression(), r3, s3];
    if ("2021-12" === u2 || "2022-03" === u2 && !c2.availableHelper("applyDecs2203R")) {
      const r4 = n2.types.arrayPattern([...e3, ...t3]), s4 = n2.types.callExpression(c2.addHelper("2021-12" === u2 ? "applyDecs" : "applyDecs2203"), f2);
      return n2.types.assignmentExpression("=", r4, s4);
    }
    return "2023-05" === u2 ? ((o3 || l2 || 0 !== i3.value) && f2.push(i3), o3 ? f2.push(n2.template.expression.ast`
            _ => ${n2.types.cloneNode(o3)} in _
          `) : l2 && f2.push(n2.types.unaryExpression("void", n2.types.numericLiteral(0))), l2 && f2.push(l2), d2 = n2.types.callExpression(c2.addHelper("applyDecs2305"), f2)) : "2023-01" === u2 ? (o3 && f2.push(n2.template.expression.ast`
            _ => ${n2.types.cloneNode(o3)} in _
          `), d2 = n2.types.callExpression(c2.addHelper("applyDecs2301"), f2)) : d2 = n2.types.callExpression(c2.addHelper("applyDecs2203R"), f2), e3.length > 0 ? t3.length > 0 ? p2 = n2.types.objectPattern([n2.types.objectProperty(n2.types.identifier("e"), n2.types.arrayPattern(e3)), n2.types.objectProperty(n2.types.identifier("c"), n2.types.arrayPattern(t3))]) : (p2 = n2.types.arrayPattern(e3), d2 = n2.types.memberExpression(d2, n2.types.identifier("e"), false, false)) : (p2 = n2.types.arrayPattern(t3), d2 = n2.types.memberExpression(d2, n2.types.identifier("c"), false, false)), n2.types.assignmentExpression("=", p2, d2);
  }
  function k(e3) {
    return "Identifier" === e3.type ? "__proto__" === e3.name : "__proto__" === e3.value;
  }
  function N(e3) {
    return e3.decorators && e3.decorators.length > 0;
  }
  function D(e3) {
    switch (e3.type) {
      case "ClassAccessorProperty":
        return true;
      case "ClassMethod":
      case "ClassProperty":
      case "ClassPrivateMethod":
      case "ClassPrivateProperty":
        return N(e3);
      default:
        return false;
    }
  }
  function j(e3) {
    return e3.isClassExpression({ id: null }) && (N(t3 = e3.node) || t3.body.body.some(D));
    var t3;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.buildCheckInRHS = h, t2.buildFieldsInitNodes = function(e3, t3, r3, i3, o3, a3, l2, c2, p2) {
    var d2;
    let f2, h2 = 0;
    const m2 = [], y2 = [];
    let g2 = false;
    const C2 = [];
    let O2 = null;
    const N = n2.types.isIdentifier(t3) ? () => t3 : () => (null != f2 || (f2 = r3[0].scope.generateUidIdentifierBasedOnNode(t3)), f2), D = null != (d2 = e3) ? d2 : r3[0].scope.generateUidIdentifier("class");
    null != e3 || (e3 = n2.types.cloneNode(p2));
    for (const t4 of r3) {
      t4.isClassProperty() && u.assertFieldTransformed(t4);
      const r4 = !(null != n2.types.isStaticBlock && n2.types.isStaticBlock(t4.node)) && t4.node.static, d3 = !r4, f3 = t4.isPrivate(), O3 = !f3, j = t4.isProperty(), L = !j, M = null == t4.isStaticBlock ? void 0 : t4.isStaticBlock();
      switch (r4 && (h2 |= 1), (r4 || L && f3 || M) && (new s2.default({ methodPath: t4, constantSuper: c2, file: o3, refToPreserve: p2, getSuperRef: N, getObjectRef: () => (h2 |= 2, r4 || M ? D : n2.types.memberExpression(D, n2.types.identifier("prototype"))) }).replace(), I(t4, D, p2) && (h2 |= 2)), g2 = false, true) {
        case M: {
          const e4 = t4.node.body;
          1 === e4.length && n2.types.isExpressionStatement(e4[0]) ? m2.push(k(e4[0], t4)) : m2.push(n2.types.inheritsComments(n2.template.statement.ast`(() => { ${e4} })()`, t4.node));
          break;
        }
        case (r4 && f3 && j && l2):
          m2.push(b(n2.types.cloneNode(e3), t4, i3));
          break;
        case (r4 && f3 && j && !l2):
          m2.push(E(t4, i3));
          break;
        case (r4 && O3 && j && a3):
          if (!_(t4.node)) {
            m2.push(T(n2.types.cloneNode(e3), t4));
            break;
          }
        case (r4 && O3 && j && !a3):
          m2.push(w(n2.types.cloneNode(e3), t4, o3));
          break;
        case (d3 && f3 && j && l2):
          y2.push(b(n2.types.thisExpression(), t4, i3));
          break;
        case (d3 && f3 && j && !l2):
          y2.push(v(n2.types.thisExpression(), t4, i3, o3));
          break;
        case (d3 && f3 && L && l2):
          y2.unshift(S(n2.types.thisExpression(), t4, i3)), C2.push(A(t4, i3, l2));
          break;
        case (d3 && f3 && L && !l2):
          y2.unshift(x(n2.types.thisExpression(), t4, i3, o3)), C2.push(A(t4, i3, l2));
          break;
        case (r4 && f3 && L && !l2):
          m2.unshift(E(t4, i3)), C2.push(A(t4, i3, l2));
          break;
        case (r4 && f3 && L && l2):
          m2.unshift(P(n2.types.cloneNode(e3), t4, 0, i3)), C2.push(A(t4, i3, l2));
          break;
        case (d3 && O3 && j && a3):
          y2.push(T(n2.types.thisExpression(), t4));
          break;
        case (d3 && O3 && j && !a3):
          g2 = true, y2.push(w(n2.types.thisExpression(), t4, o3));
          break;
        default:
          throw new Error("Unreachable.");
      }
    }
    return 2 & h2 && null != p2 && (O2 = n2.types.expressionStatement(n2.types.assignmentExpression("=", n2.types.cloneNode(D), n2.types.cloneNode(p2)))), { staticNodes: m2.filter(Boolean), instanceNodes: y2.filter(Boolean), lastInstanceNodeReturnsThis: g2, pureStaticNodes: C2.filter(Boolean), classBindingNode: O2, wrapClass(t4) {
      for (const e4 of r3) e4.node.leadingComments = null, e4.remove();
      return f2 && (t4.scope.push({ id: n2.types.cloneNode(f2) }), t4.set("superClass", n2.types.assignmentExpression("=", f2, t4.node.superClass))), 0 !== h2 && (t4.isClassExpression() ? (t4.scope.push({ id: e3 }), t4.replaceWith(n2.types.assignmentExpression("=", n2.types.cloneNode(e3), t4.node))) : (null == p2 && (t4.node.id = e3), null != O2 && t4.scope.push({ id: D }))), t4;
    } };
  }, t2.buildPrivateNamesMap = function(e3) {
    const t3 = /* @__PURE__ */ new Map();
    for (const r3 of e3) if (r3.isPrivate()) {
      const { name: e4 } = r3.node.key.id, n3 = t3.has(e4) ? t3.get(e4) : { id: r3.scope.generateUidIdentifier(e4), static: r3.node.static, method: !r3.isProperty() };
      r3.isClassPrivateMethod() && ("get" === r3.node.kind ? n3.getId = r3.scope.generateUidIdentifier(`get_${e4}`) : "set" === r3.node.kind ? n3.setId = r3.scope.generateUidIdentifier(`set_${e4}`) : "method" === r3.node.kind && (n3.methodId = r3.scope.generateUidIdentifier(e4))), t3.set(e4, n3);
    }
    return t3;
  }, t2.buildPrivateNamesNodes = function(e3, t3, r3, s3) {
    const i3 = [];
    for (const [o3, a3] of e3) {
      const { static: e4, method: c2, getId: u2, setId: p2 } = a3, d2 = u2 || p2, f2 = n2.types.cloneNode(a3.id);
      let h2;
      t3 ? h2 = n2.types.callExpression(s3.addHelper("classPrivateFieldLooseKey"), [n2.types.stringLiteral(o3)]) : r3 ? h2 = n2.types.callExpression(n2.types.identifier("Symbol"), [n2.types.stringLiteral(o3)]) : e4 || (h2 = n2.types.newExpression(n2.types.identifier(!c2 || d2 ? "WeakMap" : "WeakSet"), [])), h2 && ((0, l.default)(h2), i3.push(n2.template.statement.ast`var ${f2} = ${h2}`));
    }
    return i3;
  }, t2.transformPrivateNamesUsage = function(e3, t3, r3, n3, s3) {
    let { privateFieldsAsProperties: i3, noDocumentAll: a3, innerBinding: l2 } = n3;
    if (!r3.size) return;
    const c2 = t3.get("body"), u2 = i3 ? g : y;
    (0, o2.default)(c2, d, Object.assign({ privateNamesMap: r3, classRef: e3, file: s3 }, u2, { noDocumentAll: a3, innerBinding: l2 })), c2.traverse(m, { privateNamesMap: r3, classRef: e3, file: s3, privateFieldsAsProperties: i3, innerBinding: l2 });
  };
  var n2 = r2(1), s2 = r2(141), i2 = r2(33), o2 = r2(299), a2 = r2(300), l = r2(302), c = r2(301), u = r2(303);
  function p(e3) {
    const t3 = n2.traverse.visitors.merge([Object.assign({}, e3), i2.default]), r3 = Object.assign({}, e3, { Class(e4) {
      const { privateNamesMap: n3 } = this, s3 = e4.get("body.body"), i3 = new Map(n3), o3 = [];
      for (const e5 of s3) {
        if (!e5.isPrivate()) continue;
        const { name: t4 } = e5.node.key.id;
        i3.delete(t4), o3.push(t4);
      }
      o3.length && (e4.get("body").traverse(t3, Object.assign({}, this, { redeclared: o3 })), e4.traverse(r3, Object.assign({}, this, { privateNamesMap: i3 })), e4.skipKey("body"));
    } });
    return r3;
  }
  const d = p({ PrivateName(e3, t3) {
    let { noDocumentAll: r3 } = t3;
    const { privateNamesMap: n3, redeclared: s3 } = this, { node: i3, parentPath: o3 } = e3;
    if (!o3.isMemberExpression({ property: i3 }) && !o3.isOptionalMemberExpression({ property: i3 })) return;
    const { name: a3 } = i3.id;
    n3.has(a3) && (s3 && s3.includes(a3) || this.handle(o3, r3));
  } });
  function f(e3, t3, r3) {
    for (; null != (n3 = t3) && n3.hasBinding(e3) && !t3.bindingIdentifierEquals(e3, r3); ) {
      var n3;
      t3.rename(e3), t3 = t3.parent;
    }
  }
  function h(e3, t3, r3) {
    return r3 || null == t3.availableHelper || !t3.availableHelper("checkInRHS") ? e3 : n2.types.callExpression(t3.addHelper("checkInRHS"), [e3]);
  }
  const m = p({ BinaryExpression(e3, t3) {
    let { file: r3 } = t3;
    const { operator: s3, left: i3, right: o3 } = e3.node;
    if ("in" !== s3) return;
    if (!n2.types.isPrivateName(i3)) return;
    const { privateFieldsAsProperties: a3, privateNamesMap: l2, redeclared: c2 } = this, { name: u2 } = i3.id;
    if (!l2.has(u2)) return;
    if (c2 && c2.includes(u2)) return;
    if (f(this.classRef.name, e3.scope, this.innerBinding), a3) {
      const { id: t4 } = l2.get(u2);
      return void e3.replaceWith(n2.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${h(o3, r3)}, ${n2.types.cloneNode(t4)})
      `);
    }
    const { id: p2, static: d2 } = l2.get(u2);
    d2 ? e3.replaceWith(n2.template.expression.ast`${h(o3, r3)} === ${n2.types.cloneNode(this.classRef)}`) : e3.replaceWith(n2.template.expression.ast`${n2.types.cloneNode(p2)}.has(${h(o3, r3)})`);
  } }), y = { memoise(e3, t3) {
    const { scope: r3 } = e3, { object: n3 } = e3.node, s3 = r3.maybeGenerateMemoised(n3);
    s3 && this.memoiser.set(n3, s3, t3);
  }, receiver(e3) {
    const { object: t3 } = e3.node;
    return this.memoiser.has(t3) ? n2.types.cloneNode(this.memoiser.get(t3)) : n2.types.cloneNode(t3);
  }, get(e3) {
    const { classRef: t3, privateNamesMap: r3, file: s3, innerBinding: i3 } = this, { name: o3 } = e3.node.property.id, { id: a3, static: l2, method: c2, methodId: u2, getId: p2, setId: d2 } = r3.get(o3), h2 = p2 || d2;
    if (l2) {
      const r4 = c2 && !h2 ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
      return f(t3.name, e3.scope, i3), n2.types.callExpression(s3.addHelper(r4), [this.receiver(e3), n2.types.cloneNode(t3), n2.types.cloneNode(a3)]);
    }
    return c2 ? h2 ? !p2 && d2 && s3.availableHelper("writeOnlyError") ? n2.types.sequenceExpression([this.receiver(e3), n2.types.callExpression(s3.addHelper("writeOnlyError"), [n2.types.stringLiteral(`#${o3}`)])]) : n2.types.callExpression(s3.addHelper("classPrivateFieldGet"), [this.receiver(e3), n2.types.cloneNode(a3)]) : n2.types.callExpression(s3.addHelper("classPrivateMethodGet"), [this.receiver(e3), n2.types.cloneNode(a3), n2.types.cloneNode(u2)]) : n2.types.callExpression(s3.addHelper("classPrivateFieldGet"), [this.receiver(e3), n2.types.cloneNode(a3)]);
  }, boundGet(e3) {
    return this.memoise(e3, 1), n2.types.callExpression(n2.types.memberExpression(this.get(e3), n2.types.identifier("bind")), [this.receiver(e3)]);
  }, set(e3, t3) {
    const { classRef: r3, privateNamesMap: s3, file: i3 } = this, { name: o3 } = e3.node.property.id, { id: a3, static: l2, method: c2, setId: u2, getId: p2 } = s3.get(o3);
    if (l2) {
      const s4 = !c2 || p2 || u2 ? "classStaticPrivateFieldSpecSet" : "classStaticPrivateMethodSet";
      return n2.types.callExpression(i3.addHelper(s4), [this.receiver(e3), n2.types.cloneNode(r3), n2.types.cloneNode(a3), t3]);
    }
    return c2 ? u2 ? n2.types.callExpression(i3.addHelper("classPrivateFieldSet"), [this.receiver(e3), n2.types.cloneNode(a3), t3]) : n2.types.sequenceExpression([this.receiver(e3), t3, n2.types.callExpression(i3.addHelper("readOnlyError"), [n2.types.stringLiteral(`#${o3}`)])]) : n2.types.callExpression(i3.addHelper("classPrivateFieldSet"), [this.receiver(e3), n2.types.cloneNode(a3), t3]);
  }, destructureSet(e3) {
    const { classRef: t3, privateNamesMap: r3, file: s3 } = this, { name: i3 } = e3.node.property.id, { id: o3, static: a3 } = r3.get(i3);
    if (a3) {
      try {
        var l2 = s3.addHelper("classStaticPrivateFieldDestructureSet");
      } catch (e4) {
        throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
      }
      return n2.types.memberExpression(n2.types.callExpression(l2, [this.receiver(e3), n2.types.cloneNode(t3), n2.types.cloneNode(o3)]), n2.types.identifier("value"));
    }
    return n2.types.memberExpression(n2.types.callExpression(s3.addHelper("classPrivateFieldDestructureSet"), [this.receiver(e3), n2.types.cloneNode(o3)]), n2.types.identifier("value"));
  }, call(e3, t3) {
    return this.memoise(e3, 1), (0, a2.default)(this.get(e3), this.receiver(e3), t3, false);
  }, optionalCall(e3, t3) {
    return this.memoise(e3, 1), (0, a2.default)(this.get(e3), this.receiver(e3), t3, true);
  }, delete() {
    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
  } }, g = { get(e3) {
    const { privateNamesMap: t3, file: r3 } = this, { object: s3 } = e3.node, { name: i3 } = e3.node.property.id;
    return n2.template.expression`BASE(REF, PROP)[PROP]`({ BASE: r3.addHelper("classPrivateFieldLooseBase"), REF: n2.types.cloneNode(s3), PROP: n2.types.cloneNode(t3.get(i3).id) });
  }, set() {
    throw new Error("private name handler with loose = true don't need set()");
  }, boundGet(e3) {
    return n2.types.callExpression(n2.types.memberExpression(this.get(e3), n2.types.identifier("bind")), [n2.types.cloneNode(e3.node.object)]);
  }, simpleSet(e3) {
    return this.get(e3);
  }, destructureSet(e3) {
    return this.get(e3);
  }, call(e3, t3) {
    return n2.types.callExpression(this.get(e3), t3);
  }, optionalCall(e3, t3) {
    return n2.types.optionalCallExpression(this.get(e3), t3, true);
  }, delete() {
    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
  } };
  function b(e3, t3, r3) {
    const { id: s3 } = r3.get(t3.node.key.id.name), i3 = t3.node.value || t3.scope.buildUndefinedNode();
    return k(n2.template.statement.ast`
      Object.defineProperty(${e3}, ${n2.types.cloneNode(s3)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${i3}
      });
    `, t3);
  }
  function v(e3, t3, r3, s3) {
    const { id: i3 } = r3.get(t3.node.key.id.name), o3 = t3.node.value || t3.scope.buildUndefinedNode();
    if (!s3.availableHelper("classPrivateFieldInitSpec")) return k(n2.template.statement.ast`${n2.types.cloneNode(i3)}.set(${e3}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${o3},
        })`, t3);
    const a3 = s3.addHelper("classPrivateFieldInitSpec");
    return k(n2.template.statement.ast`${a3}(
      ${n2.types.thisExpression()},
      ${n2.types.cloneNode(i3)},
      {
        writable: true,
        value: ${o3}
      },
    )`, t3);
  }
  function E(e3, t3) {
    const r3 = t3.get(e3.node.key.id.name), { id: s3, getId: i3, setId: o3, initAdded: a3 } = r3, l2 = i3 || o3;
    if (!e3.isProperty() && (a3 || !l2)) return;
    if (l2) return t3.set(e3.node.key.id.name, Object.assign({}, r3, { initAdded: true })), k(n2.template.statement.ast`
        var ${n2.types.cloneNode(s3)} = {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${i3 ? i3.name : e3.scope.buildUndefinedNode()},
          set: ${o3 ? o3.name : e3.scope.buildUndefinedNode()}
        }
      `, e3);
    const c2 = e3.node.value || e3.scope.buildUndefinedNode();
    return k(n2.template.statement.ast`
      var ${n2.types.cloneNode(s3)} = {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${c2}
      };
    `, e3);
  }
  function S(e3, t3, r3) {
    const s3 = r3.get(t3.node.key.id.name), { methodId: i3, id: o3, getId: a3, setId: l2, initAdded: c2 } = s3;
    if (!c2) return i3 ? k(n2.template.statement.ast`
        Object.defineProperty(${e3}, ${o3}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${i3.name}
        });
      `, t3) : a3 || l2 ? (r3.set(t3.node.key.id.name, Object.assign({}, s3, { initAdded: true })), k(n2.template.statement.ast`
        Object.defineProperty(${e3}, ${o3}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${a3 ? a3.name : t3.scope.buildUndefinedNode()},
          set: ${l2 ? l2.name : t3.scope.buildUndefinedNode()}
        });
      `, t3)) : void 0;
  }
  function x(e3, t3, r3, s3) {
    const i3 = r3.get(t3.node.key.id.name), { getId: o3, setId: a3, initAdded: l2 } = i3;
    if (!l2) return o3 || a3 ? function(e4, t4, r4, s4) {
      const i4 = r4.get(t4.node.key.id.name), { id: o4, getId: a4, setId: l3 } = i4;
      if (r4.set(t4.node.key.id.name, Object.assign({}, i4, { initAdded: true })), !s4.availableHelper("classPrivateFieldInitSpec")) return k(n2.template.statement.ast`
          ${o4}.set(${e4}, {
            get: ${a4 ? a4.name : t4.scope.buildUndefinedNode()},
            set: ${l3 ? l3.name : t4.scope.buildUndefinedNode()}
          });
        `, t4);
      const c2 = s4.addHelper("classPrivateFieldInitSpec");
      return k(n2.template.statement.ast`${c2}(
      ${n2.types.thisExpression()},
      ${n2.types.cloneNode(o4)},
      {
        get: ${a4 ? a4.name : t4.scope.buildUndefinedNode()},
        set: ${l3 ? l3.name : t4.scope.buildUndefinedNode()}
      },
    )`, t4);
    }(e3, t3, r3, s3) : function(e4, t4, r4, s4) {
      const i4 = r4.get(t4.node.key.id.name), { id: o4 } = i4;
      if (!s4.availableHelper("classPrivateMethodInitSpec")) return k(n2.template.statement.ast`${o4}.add(${e4})`, t4);
      const a4 = s4.addHelper("classPrivateMethodInitSpec");
      return k(n2.template.statement.ast`${a4}(
      ${n2.types.thisExpression()},
      ${n2.types.cloneNode(o4)}
    )`, t4);
    }(e3, t3, r3, s3);
  }
  function T(e3, t3) {
    const { key: r3, computed: s3 } = t3.node, i3 = t3.node.value || t3.scope.buildUndefinedNode();
    return k(n2.types.expressionStatement(n2.types.assignmentExpression("=", n2.types.memberExpression(e3, r3, s3 || n2.types.isLiteral(r3)), i3)), t3);
  }
  function w(e3, t3, r3) {
    const { key: s3, computed: i3 } = t3.node, o3 = t3.node.value || t3.scope.buildUndefinedNode();
    return k(n2.types.expressionStatement(n2.types.callExpression(r3.addHelper("defineProperty"), [e3, i3 || n2.types.isLiteral(s3) ? s3 : n2.types.stringLiteral(s3.name), o3])), t3);
  }
  function P(e3, t3, r3, s3) {
    const i3 = s3.get(t3.node.key.id.name), { id: o3, methodId: a3, getId: l2, setId: c2, initAdded: u2 } = i3;
    if (!u2) return l2 || c2 ? (s3.set(t3.node.key.id.name, Object.assign({}, i3, { initAdded: true })), k(n2.template.statement.ast`
        Object.defineProperty(${e3}, ${o3}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${l2 ? l2.name : t3.scope.buildUndefinedNode()},
          set: ${c2 ? c2.name : t3.scope.buildUndefinedNode()}
        })
      `, t3)) : k(n2.template.statement.ast`
      Object.defineProperty(${e3}, ${o3}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${a3.name}
      });
    `, t3);
  }
  function A(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    const s3 = t3.get(e3.node.key.id.name), { id: i3, methodId: o3, getId: a3, setId: l2, getterDeclared: c2, setterDeclared: u2, static: p2 } = s3, { params: d2, body: f2, generator: h2, async: m2 } = e3.node, y2 = a3 && !c2 && 0 === d2.length, g2 = l2 && !u2 && d2.length > 0;
    let b2 = o3;
    return y2 ? (t3.set(e3.node.key.id.name, Object.assign({}, s3, { getterDeclared: true })), b2 = a3) : g2 ? (t3.set(e3.node.key.id.name, Object.assign({}, s3, { setterDeclared: true })), b2 = l2) : p2 && !r3 && (b2 = i3), k(n2.types.functionDeclaration(n2.types.cloneNode(b2), d2, f2, h2, m2), e3);
  }
  const C = n2.traverse.visitors.merge([{ UnaryExpression(e3) {
    const { node: t3 } = e3;
    if ("delete" === t3.operator) {
      const r3 = (0, c.skipTransparentExprWrapperNodes)(t3.argument);
      n2.types.isThisExpression(r3) && e3.replaceWith(n2.types.booleanLiteral(true));
    }
  }, ThisExpression(e3, t3) {
    t3.needsClassRef = true, e3.replaceWith(n2.types.cloneNode(t3.classRef));
  }, MetaProperty(e3) {
    const { node: t3, scope: r3 } = e3;
    "new" === t3.meta.name && "target" === t3.property.name && e3.replaceWith(r3.buildUndefinedNode());
  } }, i2.default]), O = { ReferencedIdentifier(e3, t3) {
    e3.scope.bindingIdentifierEquals(e3.node.name, t3.innerBinding) && (t3.needsClassRef = true, e3.node.name = t3.classRef.name);
  } };
  function I(e3, t3, r3) {
    var n3;
    const s3 = { classRef: t3, needsClassRef: false, innerBinding: r3 };
    return e3.isMethod() || e3.traverse(C, s3), null != r3 && null != (n3 = s3.classRef) && n3.name && s3.classRef.name !== r3.name && e3.traverse(O, s3), s3.needsClassRef;
  }
  function _(e3) {
    let { key: t3, computed: r3 } = e3;
    return "Identifier" === t3.type ? !r3 && ("name" === t3.name || "length" === t3.name) : "StringLiteral" === t3.type && ("name" === t3.value || "length" === t3.value);
  }
  function k(e3, t3) {
    return n2.types.inheritLeadingComments(e3, t3.node), n2.types.inheritInnerComments(e3, t3.node), e3;
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.extractComputedKeys = function(e3, t3, r3) {
    const s3 = [], i3 = { classBinding: e3.node.id && e3.scope.getBinding(e3.node.id.name), file: r3 };
    for (const r4 of t3) {
      const t4 = r4.get("key");
      t4.isReferencedIdentifier() ? a2(t4, i3) : t4.traverse(l, i3);
      const o3 = r4.node;
      if (!t4.isConstantExpression()) {
        const r5 = e3.scope, i4 = n2.types.isIdentifier(t4.node) && r5.hasUid(t4.node.name), a3 = t4.isAssignmentExpression({ operator: "=" }) && n2.types.isIdentifier(t4.node.left) && r5.hasUid(t4.node.left.name);
        if (i4) continue;
        if (a3) s3.push(n2.types.expressionStatement(n2.types.cloneNode(o3.key))), o3.key = n2.types.cloneNode(o3.key.left);
        else {
          const t5 = e3.scope.generateUidIdentifierBasedOnNode(o3.key);
          r5.push({ id: t5, kind: "let" }), s3.push(n2.types.expressionStatement(n2.types.assignmentExpression("=", n2.types.cloneNode(t5), o3.key))), o3.key = n2.types.cloneNode(t5);
        }
      }
    }
    return s3;
  }, t2.injectInitialization = function(e3, t3, r3, s3, a3) {
    if (!r3.length) return;
    const l2 = !!e3.node.superClass;
    if (!t3) {
      const r4 = n2.types.classMethod("constructor", n2.types.identifier("constructor"), [], n2.types.blockStatement([]));
      l2 && (r4.params = [n2.types.restElement(n2.types.identifier("args"))], r4.body.body.push(n2.template.statement.ast`super(...args)`)), [t3] = e3.get("body").unshiftContainer("body", r4);
    }
    if (s3 && s3(o2, { scope: t3.scope }), l2) {
      const e4 = [];
      t3.traverse(i2, e4);
      let s4 = true;
      for (const t4 of e4) if (s4 ? s4 = false : r3 = r3.map((e5) => n2.types.cloneNode(e5)), t4.parentPath.isExpressionStatement()) t4.insertAfter(r3);
      else {
        const e5 = [t4.node, ...r3.map((e6) => n2.types.toExpression(e6))];
        a3 || e5.push(n2.types.thisExpression()), t4.replaceWith(n2.types.sequenceExpression(e5));
      }
    } else t3.get("body").unshiftContainer("body", r3);
  };
  var n2 = r2(1), s2 = r2(33);
  const i2 = n2.traverse.visitors.merge([{ Super(e3) {
    const { node: t3, parentPath: r3 } = e3;
    r3.isCallExpression({ callee: t3 }) && this.push(r3);
  } }, s2.default]), o2 = { "TSTypeAnnotation|TypeAnnotation"(e3) {
    e3.skip();
  }, ReferencedIdentifier(e3, t3) {
    let { scope: r3 } = t3;
    r3.hasOwnBinding(e3.node.name) && (r3.rename(e3.node.name), e3.skip());
  } };
  function a2(e3, t3) {
    if (t3.classBinding && t3.classBinding === e3.scope.getBinding(e3.node.name)) {
      const r3 = t3.file.addHelper("classNameTDZError"), s3 = n2.types.callExpression(r3, [n2.types.stringLiteral(e3.node.name)]);
      e3.replaceWith(n2.types.sequenceExpression([s3, e3.node])), e3.skip();
    }
  }
  const l = { ReferencedIdentifier: a2 };
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.FEATURES = void 0, t2.enableFeature = function(e3, t3, r3) {
    let n3;
    u(e3, t3) && !c(e3, t3) || (e3.set(o2, e3.get(o2) | t3), "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" === r3 ? (d(e3, t3, true), e3.set(l, e3.get(l) | t3)) : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" === r3 ? (d(e3, t3, false), e3.set(l, e3.get(l) | t3)) : d(e3, t3, r3));
    for (const [t4, r4] of i2) {
      if (!u(e3, t4)) continue;
      if (c(e3, t4)) continue;
      const r5 = p(e3, t4);
      if (n3 === !r5) throw new Error("'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).");
      n3 = r5;
    }
    if (void 0 !== n3) for (const [t4, r4] of i2) u(e3, t4) && p(e3, t4) !== n3 && d(e3, t4, n3);
  }, t2.isLoose = p, t2.shouldTransform = function(e3, t3) {
    let r3 = null, i3 = null, o3 = null, a3 = null, l2 = null;
    (0, n2.hasOwnDecorators)(e3.node) && (r3 = e3.get("decorators.0"));
    for (const t4 of e3.get("body.body")) !r3 && (0, n2.hasOwnDecorators)(t4.node) && (r3 = t4.get("decorators.0")), !i3 && t4.isClassProperty() && (i3 = t4), !o3 && t4.isClassPrivateProperty() && (o3 = t4), !a3 && null != t4.isClassPrivateMethod && t4.isClassPrivateMethod() && (a3 = t4), !l2 && null != t4.isStaticBlock && t4.isStaticBlock() && (l2 = t4);
    if (r3 && o3) throw o3.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
    if (r3 && a3) throw a3.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
    if (r3 && !u(t3, s2.decorators)) throw e3.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:\n	["@babel/plugin-proposal-decorators", { "version": "legacy" }]\n	["@babel/plugin-transform-class-properties", { "loose": true }]');
    if (a3 && !u(t3, s2.privateMethods)) throw a3.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");
    if ((i3 || o3) && !u(t3, s2.fields) && !u(t3, s2.privateMethods)) throw e3.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");
    if (l2 && !u(t3, s2.staticBlocks)) throw e3.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");
    return !!(r3 || a3 || l2) || !(!i3 && !o3 || !u(t3, s2.fields));
  };
  var n2 = r2(304);
  const s2 = t2.FEATURES = Object.freeze({ fields: 2, privateMethods: 4, decorators: 8, privateIn: 16, staticBlocks: 32 }), i2 = /* @__PURE__ */ new Map([[s2.fields, "@babel/plugin-transform-class-properties"], [s2.privateMethods, "@babel/plugin-transform-private-methods"], [s2.privateIn, "@babel/plugin-transform-private-property-in-object"]]), o2 = "@babel/plugin-class-features/featuresKey", a2 = "@babel/plugin-class-features/looseKey";
  var l = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing", c = function(e3, t3) {
    return !!(e3.get(l) & t3);
  };
  function u(e3, t3) {
    return !!(e3.get(o2) & t3);
  }
  function p(e3, t3) {
    return !!(e3.get(a2) & t3);
  }
  function d(e3, t3, r3) {
    r3 ? e3.set(a2, e3.get(a2) | t3) : e3.set(a2, e3.get(a2) & ~t3), e3.set(l, e3.get(l) & ~t3);
  }
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    const { name: r3 } = e3.node.id, s2 = e3.parentPath.isExportNamedDeclaration();
    let i2 = s2;
    !i2 && t3.isProgram(e3.parent) && (i2 = e3.parent.body.some((e4) => t3.isExportNamedDeclaration(e4) && "type" !== e4.exportKind && !e4.source && e4.specifiers.some((e5) => t3.isExportSpecifier(e5) && "type" !== e5.exportKind && e5.local.name === r3)));
    const { enumValues: o2 } = (0, n2.translateEnumValues)(e3, t3);
    if (i2) {
      const n3 = t3.objectExpression(o2.map((e4) => {
        let [r4, n4] = e4;
        return t3.objectProperty(t3.isValidIdentifier(r4) ? t3.identifier(r4) : t3.stringLiteral(r4), n4);
      }));
      return void (e3.scope.hasOwnBinding(r3) ? (s2 ? e3.parentPath : e3).replaceWith(t3.expressionStatement(t3.callExpression(t3.memberExpression(t3.identifier("Object"), t3.identifier("assign")), [e3.node.id, n3]))) : (e3.replaceWith(t3.variableDeclaration("var", [t3.variableDeclarator(e3.node.id, n3)])), e3.scope.registerDeclaration(e3)));
    }
    const a2 = new Map(o2);
    e3.scope.path.traverse({ Scope(e4) {
      e4.scope.hasOwnBinding(r3) && e4.skip();
    }, MemberExpression(e4) {
      if (!t3.isIdentifier(e4.node.object, { name: r3 })) return;
      let n3;
      if (e4.node.computed) {
        if (!t3.isStringLiteral(e4.node.property)) return;
        n3 = e4.node.property.value;
      } else {
        if (!t3.isIdentifier(e4.node.property)) return;
        n3 = e4.node.property.name;
      }
      a2.has(n3) && e4.replaceWith(t3.cloneNode(a2.get(n3)));
    } }), e3.remove();
  };
  var n2 = r2(305);
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
    if (e3.node.declare || "StringLiteral" === e3.node.id.type) return void e3.remove();
    if (!t3) throw e3.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    const r3 = e3.node.id.name, o3 = c(e3, n2.types.cloneNode(e3.node, true));
    if (null === o3) {
      const t4 = e3.findParent((e4) => e4.isProgram());
      (0, s2.registerGlobalType)(t4.scope, r3), e3.remove();
    } else e3.scope.hasOwnBinding(r3) ? e3.replaceWith(o3) : e3.scope.registerDeclaration(e3.replaceWithMultiple([i2(r3), o3])[0]);
  };
  var n2 = r2(1), s2 = r2(306);
  function i2(e3) {
    return n2.types.variableDeclaration("let", [n2.types.variableDeclarator(n2.types.identifier(e3))]);
  }
  function o2(e3, t3) {
    return n2.types.memberExpression(n2.types.identifier(e3), n2.types.identifier(t3));
  }
  function a2(e3, t3, r3) {
    if ("const" !== e3.kind) throw r3.file.buildCodeFrameError(e3, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    const { declarations: s3 } = e3;
    if (s3.every((e4) => n2.types.isIdentifier(e4.id))) {
      for (const e4 of s3) e4.init = n2.types.assignmentExpression("=", o2(t3, e4.id.name), e4.init);
      return [e3];
    }
    const i3 = n2.types.getBindingIdentifiers(e3), a3 = [];
    for (const e4 in i3) a3.push(n2.types.assignmentExpression("=", o2(t3, e4), n2.types.cloneNode(i3[e4])));
    return [e3, n2.types.expressionStatement(n2.types.sequenceExpression(a3))];
  }
  function l(e3, t3) {
    return e3.hub.buildError(t3, "Ambient modules cannot be nested in other modules or namespaces.", Error);
  }
  function c(e3, t3, r3) {
    const s3 = /* @__PURE__ */ new Set(), u = t3.id;
    n2.types.assertIdentifier(u);
    const p = e3.scope.generateUid(u.name), d = n2.types.isTSModuleBlock(t3.body) ? t3.body.body : [n2.types.exportNamedDeclaration(t3.body)];
    let f = true;
    for (let t4 = 0; t4 < d.length; t4++) {
      const r4 = d[t4];
      switch (r4.type) {
        case "TSModuleDeclaration": {
          if (!n2.types.isIdentifier(r4.id)) throw l(e3, r4);
          const o3 = c(e3, r4);
          if (null !== o3) {
            f = false;
            const e4 = r4.id.name;
            s3.has(e4) ? d[t4] = o3 : (s3.add(e4), d.splice(t4++, 1, i2(e4), o3));
          }
          continue;
        }
        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration":
          f = false, s3.add(r4.id.name);
          continue;
        case "VariableDeclaration":
          f = false;
          for (const e4 in n2.types.getBindingIdentifiers(r4)) s3.add(e4);
          continue;
        default:
          f && (f = n2.types.isTypeScript(r4));
          continue;
        case "ExportNamedDeclaration":
      }
      if (!("declare" in r4.declaration) || !r4.declaration.declare) switch (r4.declaration.type) {
        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration": {
          f = false;
          const e4 = r4.declaration.id.name;
          s3.add(e4), d.splice(t4++, 1, r4.declaration, n2.types.expressionStatement(n2.types.assignmentExpression("=", o2(p, e4), n2.types.identifier(e4))));
          break;
        }
        case "VariableDeclaration": {
          f = false;
          const n3 = a2(r4.declaration, p, e3.hub);
          d.splice(t4, n3.length, ...n3), t4 += n3.length - 1;
          break;
        }
        case "TSModuleDeclaration": {
          if (!n2.types.isIdentifier(r4.declaration.id)) throw l(e3, r4.declaration);
          const o3 = c(e3, r4.declaration, n2.types.identifier(p));
          if (null !== o3) {
            f = false;
            const e4 = r4.declaration.id.name;
            s3.has(e4) ? d[t4] = o3 : (s3.add(e4), d.splice(t4++, 1, i2(e4), o3));
          } else d.splice(t4, 1), t4--;
        }
      }
    }
    if (f) return null;
    let h = n2.types.objectExpression([]);
    if (r3) {
      const e4 = n2.types.memberExpression(r3, u);
      h = n2.template.expression.ast`
      ${n2.types.cloneNode(e4)} ||
        (${n2.types.cloneNode(e4)} = ${h})
    `;
    }
    return n2.template.statement.ast`
    (function (${n2.types.identifier(p)}) {
      ${d}
    })(${u} || (${n2.types.cloneNode(u)} = ${h}));
  `;
  }
}, (e2, t2, r2) => {
  r2(12), Object.defineProperty(t2, "__esModule", { value: true });
  var n2 = r2(142), s2 = r2(156), i2 = r2(21), o2 = r2(94), a2 = r2(506);
  const l = Symbol(""), c = Symbol(""), u = Symbol(""), p = Symbol(""), d = Symbol(""), f = Symbol(""), h = Symbol(""), m = Symbol(""), y = Symbol(""), g = Symbol(""), b = Symbol(""), v = Symbol(""), E = Symbol(""), S = Symbol(""), x = Symbol(""), T = Symbol(""), w = Symbol(""), P = Symbol(""), A = Symbol(""), C = Symbol(""), O = Symbol(""), I = Symbol(""), _ = Symbol(""), k = Symbol(""), N = Symbol(""), D = Symbol(""), j = Symbol(""), L = Symbol(""), M = Symbol(""), B = Symbol(""), R = Symbol(""), F = Symbol(""), U = Symbol(""), $ = Symbol(""), V = Symbol(""), q = Symbol(""), W = Symbol(""), G = Symbol(""), H = Symbol(""), z = { [l]: "Fragment", [c]: "Teleport", [u]: "Suspense", [p]: "KeepAlive", [d]: "BaseTransition", [f]: "openBlock", [h]: "createBlock", [m]: "createElementBlock", [y]: "createVNode", [g]: "createElementVNode", [b]: "createCommentVNode", [v]: "createTextVNode", [E]: "createStaticVNode", [S]: "resolveComponent", [x]: "resolveDynamicComponent", [T]: "resolveDirective", [w]: "resolveFilter", [P]: "withDirectives", [A]: "renderList", [C]: "renderSlot", [O]: "createSlots", [I]: "toDisplayString", [_]: "mergeProps", [k]: "normalizeClass", [N]: "normalizeStyle", [D]: "normalizeProps", [j]: "guardReactiveProps", [L]: "toHandlers", [M]: "camelize", [B]: "capitalize", [R]: "toHandlerKey", [F]: "setBlockTracking", [U]: "pushScopeId", [$]: "popScopeId", [V]: "withCtx", [q]: "unref", [W]: "isRef", [G]: "withMemo", [H]: "isMemoSame" }, K = { start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 }, source: "" };
  function X(e3) {
    return { type: 0, source: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", children: e3, helpers: /* @__PURE__ */ new Set(), components: [], directives: [], hoists: [], imports: [], cached: 0, temps: 0, codegenNode: void 0, loc: K };
  }
  function J(e3, t3, r3, n3, s3, i3, o3) {
    let a3 = arguments.length > 7 && void 0 !== arguments[7] && arguments[7], l2 = arguments.length > 8 && void 0 !== arguments[8] && arguments[8], c2 = arguments.length > 9 && void 0 !== arguments[9] && arguments[9], u2 = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : K;
    return e3 && (a3 ? (e3.helper(f), e3.helper(le(e3.inSSR, c2))) : e3.helper(ae(e3.inSSR, c2)), o3 && e3.helper(P)), { type: 13, tag: t3, props: r3, children: n3, patchFlag: s3, dynamicProps: i3, directives: o3, isBlock: a3, disableTracking: l2, isComponent: c2, loc: u2 };
  }
  function Y(e3) {
    return { type: 17, loc: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : K, elements: e3 };
  }
  function Q(e3) {
    return { type: 15, loc: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : K, properties: e3 };
  }
  function Z(e3, t3) {
    return { type: 16, loc: K, key: n2.isString(e3) ? ee(e3, true) : e3, value: t3 };
  }
  function ee(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return { type: 4, loc: arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : K, content: e3, isStatic: t3, constType: t3 ? 3 : arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0 };
  }
  function te(e3) {
    return { type: 8, loc: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : K, children: e3 };
  }
  function re(e3) {
    return { type: 14, loc: arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : K, callee: e3, arguments: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [] };
  }
  function ne(e3) {
    return { type: 18, params: e3, returns: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, newline: arguments.length > 2 && void 0 !== arguments[2] && arguments[2], isSlot: arguments.length > 3 && void 0 !== arguments[3] && arguments[3], loc: arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : K };
  }
  function se(e3, t3, r3) {
    return { type: 19, test: e3, consequent: t3, alternate: r3, newline: !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], loc: K };
  }
  function ie(e3, t3) {
    return { type: 20, index: e3, value: t3, isVNode: arguments.length > 2 && void 0 !== arguments[2] && arguments[2], loc: K };
  }
  function oe(e3) {
    return { type: 21, body: e3, loc: K };
  }
  function ae(e3, t3) {
    return e3 || t3 ? y : g;
  }
  function le(e3, t3) {
    return e3 || t3 ? h : m;
  }
  function ce(e3, t3) {
    let { helper: r3, removeHelper: n3, inSSR: s3 } = t3;
    e3.isBlock || (e3.isBlock = true, n3(ae(s3, e3.isComponent)), r3(f), r3(le(s3, e3.isComponent)));
  }
  const ue = new Uint8Array([123, 123]), pe = new Uint8Array([125, 125]);
  function de(e3) {
    return e3 >= 97 && e3 <= 122 || e3 >= 65 && e3 <= 90;
  }
  function fe(e3) {
    return 32 === e3 || 10 === e3 || 9 === e3 || 12 === e3 || 13 === e3;
  }
  function he(e3) {
    return 47 === e3 || 62 === e3 || fe(e3);
  }
  function me(e3) {
    const t3 = new Uint8Array(e3.length);
    for (let r3 = 0; r3 < e3.length; r3++) t3[r3] = e3.charCodeAt(r3);
    return t3;
  }
  const ye = { Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]), CdataEnd: new Uint8Array([93, 93, 62]), CommentEnd: new Uint8Array([45, 45, 62]), ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]), StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]), TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]), TextareaEnd: new Uint8Array([60, 47, 116, 101, 120, 116, 97, 114, 101, 97]) }, ge = { COMPILER_IS_ON_ELEMENT: { message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".', link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html" }, COMPILER_V_BIND_SYNC: { message: (e3) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${e3}.sync\` should be changed to \`v-model:${e3}\`.`, link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html" }, COMPILER_V_BIND_OBJECT_ORDER: { message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.', link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html" }, COMPILER_V_ON_NATIVE: { message: ".native modifier for v-on has been removed as is no longer necessary.", link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html" }, COMPILER_V_IF_V_FOR_PRECEDENCE: { message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.", link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html" }, COMPILER_NATIVE_TEMPLATE: { message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3." }, COMPILER_INLINE_TEMPLATE: { message: '"inline-template" has been removed in Vue 3.', link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html" }, COMPILER_FILTERS: { message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.', link: "https://v3-migration.vuejs.org/breaking-changes/filters.html" } };
  function be(e3, t3) {
    let { compatConfig: r3 } = t3;
    const n3 = r3 && r3[e3];
    return "MODE" === e3 ? n3 || 3 : n3;
  }
  function ve(e3, t3) {
    const r3 = be("MODE", t3), n3 = be(e3, t3);
    return 3 === r3 ? true === n3 : false !== n3;
  }
  function Ee(e3, t3, r3) {
    return ve(e3, t3);
  }
  function Se(e3) {
    throw e3;
  }
  function xe(e3) {
  }
  function Te(e3, t3, r3, n3) {
    const s3 = (r3 || we)[e3] + (n3 || ""), i3 = new SyntaxError(String(s3));
    return i3.code = e3, i3.loc = t3, i3;
  }
  const we = { 0: "Illegal comment.", 1: "CDATA section is allowed only in XML context.", 2: "Duplicate attribute.", 3: "End tag cannot have attributes.", 4: "Illegal '/' in tags.", 5: "Unexpected EOF in tag.", 6: "Unexpected EOF in CDATA section.", 7: "Unexpected EOF in comment.", 8: "Unexpected EOF in script.", 9: "Unexpected EOF in tag.", 10: "Incorrectly closed comment.", 11: "Incorrectly opened comment.", 12: "Illegal tag name. Use '&lt;' to print '<'.", 13: "Attribute value was expected.", 14: "End tag name was expected.", 15: "Whitespace was expected.", 16: "Unexpected '<!--' in comment.", 17: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`, 18: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).", 19: "Attribute name cannot start with '='.", 21: "'<?' is allowed only in XML context.", 20: "Unexpected null character.", 22: "Illegal '/' in tags.", 23: "Invalid end tag.", 24: "Element is missing end tag.", 25: "Interpolation end sign was not found.", 27: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.", 26: "Legal directive name was expected.", 28: "v-if/v-else-if is missing expression.", 29: "v-if/else branches must use unique keys.", 30: "v-else/v-else-if has no adjacent v-if or v-else-if.", 31: "v-for is missing expression.", 32: "v-for has invalid expression.", 33: "<template v-for> key should be placed on the <template> tag.", 34: "v-bind is missing expression.", 35: "v-on is missing expression.", 36: "Unexpected custom directive on <slot> outlet.", 37: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.", 38: "Duplicate slot names found. ", 39: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.", 40: "v-slot can only be used on components or <template> tags.", 41: "v-model is missing expression.", 42: "v-model value must be a valid JavaScript member expression.", 43: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.", 44: "v-model cannot be used on a prop, because local prop bindings are not writable.\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.", 45: "Error parsing JavaScript expression: ", 46: "<KeepAlive> expects exactly one child component.", 51: "@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.", 47: '"prefixIdentifiers" option is not supported in this build of compiler.', 48: "ES module mode is not supported in this build of compiler.", 49: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.', 50: '"scopeId" option is only supported in module mode.', 52: "" };
  function Pe(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], s3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : /* @__PURE__ */ Object.create(null);
    const i3 = "Program" === e3.type ? "ExpressionStatement" === e3.body[0].type && e3.body[0].expression : e3;
    o2.walk(e3, { enter(e4, i4) {
      if (i4 && n3.push(i4), i4 && i4.type.startsWith("TS") && !Be.includes(i4.type)) return this.skip();
      if ("Identifier" === e4.type) {
        const o3 = !!s3[e4.name], a3 = Ae(e4, i4, n3);
        (r3 || a3 && !o3) && t3(e4, i4, n3, a3, o3);
      } else "ObjectProperty" === e4.type && "ObjectPattern" === (null == i4 ? void 0 : i4.type) ? e4.inPattern = true : je(e4) ? e4.scopeIds ? e4.scopeIds.forEach((e5) => Ne(e5, s3)) : Ie(e4, (t4) => De(e4, t4, s3)) : "BlockStatement" === e4.type && (e4.scopeIds ? e4.scopeIds.forEach((e5) => Ne(e5, s3)) : _e(e4, (t4) => De(e4, t4, s3)));
    }, leave(e4, t4) {
      if (t4 && n3.pop(), e4 !== i3 && e4.scopeIds) for (const t5 of e4.scopeIds) s3[t5]--, 0 === s3[t5] && delete s3[t5];
    } });
  }
  function Ae(e3, t3, r3) {
    if (!t3) return true;
    if ("arguments" === e3.name) return false;
    if (function(e4, t4, r4) {
      switch (t4.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          return t4.property === e4 ? !!t4.computed : t4.object === e4;
        case "JSXMemberExpression":
          return t4.object === e4;
        case "VariableDeclarator":
          return t4.init === e4;
        case "ArrowFunctionExpression":
          return t4.body === e4;
        case "PrivateName":
        case "LabeledStatement":
        case "CatchClause":
        case "RestElement":
        case "BreakStatement":
        case "ContinueStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ImportAttribute":
        case "JSXAttribute":
        case "ObjectPattern":
        case "ArrayPattern":
        case "MetaProperty":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          return t4.key === e4 && !!t4.computed;
        case "ObjectProperty":
        case "ClassProperty":
        case "TSPropertySignature":
          return t4.key !== e4 || !!t4.computed;
        case "ClassPrivateProperty":
        case "ObjectTypeProperty":
          return t4.key !== e4;
        case "ClassDeclaration":
        case "ClassExpression":
          return t4.superClass === e4;
        case "AssignmentExpression":
        case "AssignmentPattern":
          return t4.right === e4;
        case "ExportSpecifier":
          return t4.local === e4;
        case "TSEnumMember":
          return t4.id !== e4;
      }
      return true;
    }(e3, t3)) return true;
    switch (t3.type) {
      case "AssignmentExpression":
      case "AssignmentPattern":
        return true;
      case "ObjectPattern":
      case "ArrayPattern":
        return Ce(t3, r3);
    }
    return false;
  }
  function Ce(e3, t3) {
    if (e3 && ("ObjectProperty" === e3.type || "ArrayPattern" === e3.type)) {
      let e4 = t3.length;
      for (; e4--; ) {
        const r3 = t3[e4];
        if ("AssignmentExpression" === r3.type) return true;
        if ("ObjectProperty" !== r3.type && !r3.type.endsWith("Pattern")) break;
      }
    }
    return false;
  }
  function Oe(e3) {
    let t3 = e3.length;
    for (; t3--; ) {
      const r3 = e3[t3];
      if ("NewExpression" === r3.type) return true;
      if ("MemberExpression" !== r3.type) break;
    }
    return false;
  }
  function Ie(e3, t3) {
    for (const r3 of e3.params) for (const e4 of ke(r3)) t3(e4);
  }
  function _e(e3, t3) {
    for (const r3 of e3.body) if ("VariableDeclaration" === r3.type) {
      if (r3.declare) continue;
      for (const e4 of r3.declarations) for (const r4 of ke(e4.id)) t3(r4);
    } else if ("FunctionDeclaration" === r3.type || "ClassDeclaration" === r3.type) {
      if (r3.declare || !r3.id) continue;
      t3(r3.id);
    } else if ("ForOfStatement" === r3.type || "ForInStatement" === r3.type || "ForStatement" === r3.type) {
      const e4 = "ForStatement" === r3.type ? r3.init : r3.left;
      if (e4 && "VariableDeclaration" === e4.type) for (const r4 of e4.declarations) for (const e5 of ke(r4.id)) t3(e5);
    }
  }
  function ke(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    switch (e3.type) {
      case "Identifier":
        t3.push(e3);
        break;
      case "MemberExpression":
        let r3 = e3;
        for (; "MemberExpression" === r3.type; ) r3 = r3.object;
        t3.push(r3);
        break;
      case "ObjectPattern":
        for (const r4 of e3.properties) "RestElement" === r4.type ? ke(r4.argument, t3) : ke(r4.value, t3);
        break;
      case "ArrayPattern":
        e3.elements.forEach((e4) => {
          e4 && ke(e4, t3);
        });
        break;
      case "RestElement":
        ke(e3.argument, t3);
        break;
      case "AssignmentPattern":
        ke(e3.left, t3);
    }
    return t3;
  }
  function Ne(e3, t3) {
    e3 in t3 ? t3[e3]++ : t3[e3] = 1;
  }
  function De(e3, t3, r3) {
    const { name: n3 } = t3;
    e3.scopeIds && e3.scopeIds.has(n3) || (Ne(n3, r3), (e3.scopeIds || (e3.scopeIds = /* @__PURE__ */ new Set())).add(n3));
  }
  const je = (e3) => /Function(?:Expression|Declaration)$|Method$/.test(e3.type), Le = (e3) => e3 && ("ObjectProperty" === e3.type || "ObjectMethod" === e3.type) && !e3.computed, Me = (e3, t3) => Le(t3) && t3.key === e3, Be = ["TSAsExpression", "TSTypeAssertion", "TSNonNullExpression", "TSInstantiationExpression", "TSSatisfiesExpression"];
  function Re(e3) {
    return Be.includes(e3.type) ? Re(e3.expression) : e3;
  }
  const Fe = (e3) => 4 === e3.type && e3.isStatic;
  function Ue(e3) {
    switch (e3) {
      case "Teleport":
      case "teleport":
        return c;
      case "Suspense":
      case "suspense":
        return u;
      case "KeepAlive":
      case "keep-alive":
        return p;
      case "BaseTransition":
      case "base-transition":
        return d;
    }
  }
  const $e = /^\d|[^\$\w]/, Ve = (e3) => !$e.test(e3), qe = /[A-Za-z_$\xA0-\uFFFF]/, We = /[\.\?\w$\xA0-\uFFFF]/, Ge = /\s+[.[]\s*|\s*[.[]\s+/g, He = (e3, t3) => {
    try {
      let r3 = i2.parseExpression(e3, { plugins: t3.expressionPlugins });
      return r3 = Re(r3), "MemberExpression" === r3.type || "OptionalMemberExpression" === r3.type || "Identifier" === r3.type && "undefined" !== r3.name;
    } catch (e4) {
      return false;
    }
  }, ze = He;
  function Ke(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t3.length;
    return Xe({ offset: e3.offset, line: e3.line, column: e3.column }, t3, r3);
  }
  function Xe(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t3.length, n3 = 0, s3 = -1;
    for (let e4 = 0; e4 < r3; e4++) 10 === t3.charCodeAt(e4) && (n3++, s3 = e4);
    return e3.offset += r3, e3.line += n3, e3.column = -1 === s3 ? e3.column + r3 : r3 - s3, e3;
  }
  function Je(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    for (let s3 = 0; s3 < e3.props.length; s3++) {
      const i3 = e3.props[s3];
      if (7 === i3.type && (r3 || i3.exp) && (n2.isString(t3) ? i3.name === t3 : t3.test(i3.name))) return i3;
    }
  }
  function Ye(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    for (let s3 = 0; s3 < e3.props.length; s3++) {
      const i3 = e3.props[s3];
      if (6 === i3.type) {
        if (r3) continue;
        if (i3.name === t3 && (i3.value || n3)) return i3;
      } else if ("bind" === i3.name && (i3.exp || n3) && Qe(i3.arg, t3)) return i3;
    }
  }
  function Qe(e3, t3) {
    return !(!e3 || !Fe(e3) || e3.content !== t3);
  }
  function Ze(e3) {
    return 5 === e3.type || 2 === e3.type;
  }
  function et(e3) {
    return 7 === e3.type && "slot" === e3.name;
  }
  function tt(e3) {
    return 1 === e3.type && 3 === e3.tagType;
  }
  function rt(e3) {
    return 1 === e3.type && 2 === e3.tagType;
  }
  const nt = /* @__PURE__ */ new Set([D, j]);
  function st(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    if (e3 && !n2.isString(e3) && 14 === e3.type) {
      const r3 = e3.callee;
      if (!n2.isString(r3) && nt.has(r3)) return st(e3.arguments[0], t3.concat(e3));
    }
    return [e3, t3];
  }
  function it(e3, t3, r3) {
    let s3, i3, o3 = 13 === e3.type ? e3.props : e3.arguments[2], a3 = [];
    if (o3 && !n2.isString(o3) && 14 === o3.type) {
      const e4 = st(o3);
      o3 = e4[0], a3 = e4[1], i3 = a3[a3.length - 1];
    }
    if (null == o3 || n2.isString(o3)) s3 = Q([t3]);
    else if (14 === o3.type) {
      const e4 = o3.arguments[0];
      n2.isString(e4) || 15 !== e4.type ? o3.callee === L ? s3 = re(r3.helper(_), [Q([t3]), o3]) : o3.arguments.unshift(Q([t3])) : ot(t3, e4) || e4.properties.unshift(t3), !s3 && (s3 = o3);
    } else 15 === o3.type ? (ot(t3, o3) || o3.properties.unshift(t3), s3 = o3) : (s3 = re(r3.helper(_), [Q([t3]), o3]), i3 && i3.callee === j && (i3 = a3[a3.length - 2]));
    13 === e3.type ? i3 ? i3.arguments[0] = s3 : e3.props = s3 : i3 ? i3.arguments[0] = s3 : e3.arguments[2] = s3;
  }
  function ot(e3, t3) {
    let r3 = false;
    if (4 === e3.key.type) {
      const n3 = e3.key.content;
      r3 = t3.properties.some((e4) => 4 === e4.key.type && e4.key.content === n3);
    }
    return r3;
  }
  function at(e3, t3) {
    return `_${t3}_${e3.replace(/[^\w]/g, (t4, r3) => "-" === t4 ? "_" : e3.charCodeAt(r3).toString())}`;
  }
  function lt(e3, t3) {
    if (!e3 || 0 === Object.keys(t3).length) return false;
    switch (e3.type) {
      case 1:
        for (let r3 = 0; r3 < e3.props.length; r3++) {
          const n3 = e3.props[r3];
          if (7 === n3.type && (lt(n3.arg, t3) || lt(n3.exp, t3))) return true;
        }
        return e3.children.some((e4) => lt(e4, t3));
      case 11:
        return !!lt(e3.source, t3) || e3.children.some((e4) => lt(e4, t3));
      case 9:
        return e3.branches.some((e4) => lt(e4, t3));
      case 10:
        return !!lt(e3.condition, t3) || e3.children.some((e4) => lt(e4, t3));
      case 4:
        return !e3.isStatic && Ve(e3.content) && !!t3[e3.content];
      case 8:
        return e3.children.some((e4) => n2.isObject(e4) && lt(e4, t3));
      case 5:
      case 12:
        return lt(e3.content, t3);
      default:
        return false;
    }
  }
  function ct(e3) {
    return 14 === e3.type && e3.callee === G ? e3.arguments[1].returns : e3;
  }
  const ut = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, pt = { parseMode: "base", ns: 0, delimiters: ["{{", "}}"], getNamespace: () => 0, isVoidTag: n2.NO, isPreTag: n2.NO, isCustomElement: n2.NO, onError: Se, onWarn: xe, comments: false, prefixIdentifiers: false };
  let dt = pt, ft = null, ht = "", mt = null, yt = null, gt = "", bt = -1, vt = -1, Et = 0, St = false, xt = null;
  const Tt = [], wt = new class {
    constructor(e3, t3) {
      this.stack = e3, this.cbs = t3, this.state = 1, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = 1, this.inRCDATA = false, this.inXML = false, this.inVPre = false, this.newlines = [], this.mode = 0, this.delimiterOpen = ue, this.delimiterClose = pe, this.delimiterIndex = -1, this.currentSequence = void 0, this.sequenceIndex = 0, this.entityDecoder = new s2.EntityDecoder(s2.htmlDecodeTree, (e4, t4) => this.emitCodePoint(e4, t4));
    }
    get inSFCRoot() {
      return 2 === this.mode && 0 === this.stack.length;
    }
    reset() {
      this.state = 1, this.mode = 0, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = 1, this.inRCDATA = false, this.currentSequence = void 0, this.newlines.length = 0, this.delimiterOpen = ue, this.delimiterClose = pe;
    }
    getPos(e3) {
      let t3 = 1, r3 = e3 + 1;
      for (let n3 = this.newlines.length - 1; n3 >= 0; n3--) {
        const s3 = this.newlines[n3];
        if (e3 > s3) {
          t3 = n3 + 2, r3 = e3 - s3;
          break;
        }
      }
      return { column: r3, line: t3, offset: e3 };
    }
    peek() {
      return this.buffer.charCodeAt(this.index + 1);
    }
    stateText(e3) {
      60 === e3 ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = 5, this.sectionStart = this.index) : 38 === e3 ? this.startEntity() : this.inVPre || e3 !== this.delimiterOpen[0] || (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e3));
    }
    stateInterpolationOpen(e3) {
      if (e3 === this.delimiterOpen[this.delimiterIndex]) if (this.delimiterIndex === this.delimiterOpen.length - 1) {
        const e4 = this.index + 1 - this.delimiterOpen.length;
        e4 > this.sectionStart && this.cbs.ontext(this.sectionStart, e4), this.state = 3, this.sectionStart = e4;
      } else this.delimiterIndex++;
      else this.inRCDATA ? (this.state = 32, this.stateInRCDATA(e3)) : (this.state = 1, this.stateText(e3));
    }
    stateInterpolation(e3) {
      e3 === this.delimiterClose[0] && (this.state = 4, this.delimiterIndex = 0, this.stateInterpolationClose(e3));
    }
    stateInterpolationClose(e3) {
      e3 === this.delimiterClose[this.delimiterIndex] ? this.delimiterIndex === this.delimiterClose.length - 1 ? (this.cbs.oninterpolation(this.sectionStart, this.index + 1), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : this.delimiterIndex++ : (this.state = 3, this.stateInterpolation(e3));
    }
    stateSpecialStartSequence(e3) {
      const t3 = this.sequenceIndex === this.currentSequence.length;
      if (t3 ? he(e3) : (32 | e3) === this.currentSequence[this.sequenceIndex]) {
        if (!t3) return void this.sequenceIndex++;
      } else this.inRCDATA = false;
      this.sequenceIndex = 0, this.state = 6, this.stateInTagName(e3);
    }
    stateInRCDATA(e3) {
      if (this.sequenceIndex === this.currentSequence.length) {
        if (62 === e3 || fe(e3)) {
          const t3 = this.index - this.currentSequence.length;
          if (this.sectionStart < t3) {
            const e4 = this.index;
            this.index = t3, this.cbs.ontext(this.sectionStart, t3), this.index = e4;
          }
          return this.sectionStart = t3 + 2, this.stateInClosingTagName(e3), void (this.inRCDATA = false);
        }
        this.sequenceIndex = 0;
      }
      (32 | e3) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : 0 === this.sequenceIndex ? this.currentSequence === ye.TitleEnd || this.currentSequence === ye.TextareaEnd && !this.inSFCRoot ? 38 === e3 ? this.startEntity() : e3 === this.delimiterOpen[0] && (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e3)) : this.fastForwardTo(60) && (this.sequenceIndex = 1) : this.sequenceIndex = Number(60 === e3);
    }
    stateCDATASequence(e3) {
      e3 === ye.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === ye.Cdata.length && (this.state = 28, this.currentSequence = ye.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = 23, this.stateInDeclaration(e3));
    }
    fastForwardTo(e3) {
      for (; ++this.index < this.buffer.length; ) {
        const t3 = this.buffer.charCodeAt(this.index);
        if (10 === t3 && this.newlines.push(this.index), t3 === e3) return true;
      }
      return this.index = this.buffer.length - 1, false;
    }
    stateInCommentLike(e3) {
      e3 === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === ye.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index - 2) : this.cbs.oncomment(this.sectionStart, this.index - 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = 1) : 0 === this.sequenceIndex ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : e3 !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
    }
    startSpecial(e3, t3) {
      this.enterRCDATA(e3, t3), this.state = 31;
    }
    enterRCDATA(e3, t3) {
      this.inRCDATA = true, this.currentSequence = e3, this.sequenceIndex = t3;
    }
    stateBeforeTagName(e3) {
      if (33 === e3) this.state = 22, this.sectionStart = this.index + 1;
      else if (63 === e3) this.state = 24, this.sectionStart = this.index + 1;
      else if (de(e3)) if (this.sectionStart = this.index, 0 === this.mode) this.state = 6;
      else if (this.inSFCRoot) this.state = 34;
      else if (this.inXML) this.state = 6;
      else {
        const t3 = 32 | e3;
        this.state = 116 === t3 ? 30 : 115 === t3 ? 29 : 6;
      }
      else 47 === e3 ? this.state = 8 : (this.state = 1, this.stateText(e3));
    }
    stateInTagName(e3) {
      he(e3) && this.handleTagName(e3);
    }
    stateInSFCRootTagName(e3) {
      if (he(e3)) {
        const t3 = this.buffer.slice(this.sectionStart, this.index);
        "template" !== t3 && this.enterRCDATA(me("</" + t3), 0), this.handleTagName(e3);
      }
    }
    handleTagName(e3) {
      this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e3);
    }
    stateBeforeClosingTagName(e3) {
      fe(e3) || (62 === e3 ? (this.cbs.onerr(14, this.index), this.state = 1, this.sectionStart = this.index + 1) : (this.state = de(e3) ? 9 : 27, this.sectionStart = this.index));
    }
    stateInClosingTagName(e3) {
      (62 === e3 || fe(e3)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = 10, this.stateAfterClosingTagName(e3));
    }
    stateAfterClosingTagName(e3) {
      62 === e3 && (this.state = 1, this.sectionStart = this.index + 1);
    }
    stateBeforeAttrName(e3) {
      62 === e3 ? (this.cbs.onopentagend(this.index), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : 47 === e3 ? (this.state = 7, 62 !== this.peek() && this.cbs.onerr(22, this.index)) : 60 === e3 && 47 === this.peek() ? (this.cbs.onopentagend(this.index), this.state = 5, this.sectionStart = this.index) : fe(e3) || (61 === e3 && this.cbs.onerr(19, this.index), this.handleAttrStart(e3));
    }
    handleAttrStart(e3) {
      118 === e3 && 45 === this.peek() ? (this.state = 13, this.sectionStart = this.index) : 46 === e3 || 58 === e3 || 64 === e3 || 35 === e3 ? (this.cbs.ondirname(this.index, this.index + 1), this.state = 14, this.sectionStart = this.index + 1) : (this.state = 12, this.sectionStart = this.index);
    }
    stateInSelfClosingTag(e3) {
      62 === e3 ? (this.cbs.onselfclosingtag(this.index), this.state = 1, this.sectionStart = this.index + 1, this.inRCDATA = false) : fe(e3) || (this.state = 11, this.stateBeforeAttrName(e3));
    }
    stateInAttrName(e3) {
      61 === e3 || he(e3) ? (this.cbs.onattribname(this.sectionStart, this.index), this.handleAttrNameEnd(e3)) : 34 !== e3 && 39 !== e3 && 60 !== e3 || this.cbs.onerr(17, this.index);
    }
    stateInDirName(e3) {
      61 === e3 || he(e3) ? (this.cbs.ondirname(this.sectionStart, this.index), this.handleAttrNameEnd(e3)) : 58 === e3 ? (this.cbs.ondirname(this.sectionStart, this.index), this.state = 14, this.sectionStart = this.index + 1) : 46 === e3 && (this.cbs.ondirname(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
    }
    stateInDirArg(e3) {
      61 === e3 || he(e3) ? (this.cbs.ondirarg(this.sectionStart, this.index), this.handleAttrNameEnd(e3)) : 91 === e3 ? this.state = 15 : 46 === e3 && (this.cbs.ondirarg(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);
    }
    stateInDynamicDirArg(e3) {
      93 === e3 ? this.state = 14 : (61 === e3 || he(e3)) && (this.cbs.ondirarg(this.sectionStart, this.index + 1), this.handleAttrNameEnd(e3), this.cbs.onerr(27, this.index));
    }
    stateInDirModifier(e3) {
      61 === e3 || he(e3) ? (this.cbs.ondirmodifier(this.sectionStart, this.index), this.handleAttrNameEnd(e3)) : 46 === e3 && (this.cbs.ondirmodifier(this.sectionStart, this.index), this.sectionStart = this.index + 1);
    }
    handleAttrNameEnd(e3) {
      this.sectionStart = this.index, this.state = 17, this.cbs.onattribnameend(this.index), this.stateAfterAttrName(e3);
    }
    stateAfterAttrName(e3) {
      61 === e3 ? this.state = 18 : 47 === e3 || 62 === e3 ? (this.cbs.onattribend(0, this.sectionStart), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e3)) : fe(e3) || (this.cbs.onattribend(0, this.sectionStart), this.handleAttrStart(e3));
    }
    stateBeforeAttrValue(e3) {
      34 === e3 ? (this.state = 19, this.sectionStart = this.index + 1) : 39 === e3 ? (this.state = 20, this.sectionStart = this.index + 1) : fe(e3) || (this.sectionStart = this.index, this.state = 21, this.stateInAttrValueNoQuotes(e3));
    }
    handleInAttrValue(e3, t3) {
      e3 === t3 ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(34 === t3 ? 3 : 2, this.index + 1), this.state = 11) : 38 === e3 && this.startEntity();
    }
    stateInAttrValueDoubleQuotes(e3) {
      this.handleInAttrValue(e3, 34);
    }
    stateInAttrValueSingleQuotes(e3) {
      this.handleInAttrValue(e3, 39);
    }
    stateInAttrValueNoQuotes(e3) {
      fe(e3) || 62 === e3 ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(1, this.index), this.state = 11, this.stateBeforeAttrName(e3)) : 34 === e3 || 39 === e3 || 60 === e3 || 61 === e3 || 96 === e3 ? this.cbs.onerr(18, this.index) : 38 === e3 && this.startEntity();
    }
    stateBeforeDeclaration(e3) {
      91 === e3 ? (this.state = 26, this.sequenceIndex = 0) : this.state = 45 === e3 ? 25 : 23;
    }
    stateInDeclaration(e3) {
      (62 === e3 || this.fastForwardTo(62)) && (this.state = 1, this.sectionStart = this.index + 1);
    }
    stateInProcessingInstruction(e3) {
      (62 === e3 || this.fastForwardTo(62)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
    }
    stateBeforeComment(e3) {
      45 === e3 ? (this.state = 28, this.currentSequence = ye.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = 23;
    }
    stateInSpecialComment(e3) {
      (62 === e3 || this.fastForwardTo(62)) && (this.cbs.oncomment(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);
    }
    stateBeforeSpecialS(e3) {
      const t3 = 32 | e3;
      t3 === ye.ScriptEnd[3] ? this.startSpecial(ye.ScriptEnd, 4) : t3 === ye.StyleEnd[3] ? this.startSpecial(ye.StyleEnd, 4) : (this.state = 6, this.stateInTagName(e3));
    }
    stateBeforeSpecialT(e3) {
      const t3 = 32 | e3;
      t3 === ye.TitleEnd[3] ? this.startSpecial(ye.TitleEnd, 4) : t3 === ye.TextareaEnd[3] ? this.startSpecial(ye.TextareaEnd, 4) : (this.state = 6, this.stateInTagName(e3));
    }
    startEntity() {
      this.baseState = this.state, this.state = 33, this.entityStart = this.index, this.entityDecoder.startEntity(1 === this.baseState || 32 === this.baseState ? s2.DecodingMode.Legacy : s2.DecodingMode.Attribute);
    }
    stateInEntity() {
      {
        const e3 = this.entityDecoder.write(this.buffer, this.index);
        e3 >= 0 ? (this.state = this.baseState, 0 === e3 && (this.index = this.entityStart)) : this.index = this.buffer.length - 1;
      }
    }
    parse(e3) {
      for (this.buffer = e3; this.index < this.buffer.length; ) {
        const e4 = this.buffer.charCodeAt(this.index);
        switch (10 === e4 && this.newlines.push(this.index), this.state) {
          case 1:
            this.stateText(e4);
            break;
          case 2:
            this.stateInterpolationOpen(e4);
            break;
          case 3:
            this.stateInterpolation(e4);
            break;
          case 4:
            this.stateInterpolationClose(e4);
            break;
          case 31:
            this.stateSpecialStartSequence(e4);
            break;
          case 32:
            this.stateInRCDATA(e4);
            break;
          case 26:
            this.stateCDATASequence(e4);
            break;
          case 19:
            this.stateInAttrValueDoubleQuotes(e4);
            break;
          case 12:
            this.stateInAttrName(e4);
            break;
          case 13:
            this.stateInDirName(e4);
            break;
          case 14:
            this.stateInDirArg(e4);
            break;
          case 15:
            this.stateInDynamicDirArg(e4);
            break;
          case 16:
            this.stateInDirModifier(e4);
            break;
          case 28:
            this.stateInCommentLike(e4);
            break;
          case 27:
            this.stateInSpecialComment(e4);
            break;
          case 11:
            this.stateBeforeAttrName(e4);
            break;
          case 6:
            this.stateInTagName(e4);
            break;
          case 34:
            this.stateInSFCRootTagName(e4);
            break;
          case 9:
            this.stateInClosingTagName(e4);
            break;
          case 5:
            this.stateBeforeTagName(e4);
            break;
          case 17:
            this.stateAfterAttrName(e4);
            break;
          case 20:
            this.stateInAttrValueSingleQuotes(e4);
            break;
          case 18:
            this.stateBeforeAttrValue(e4);
            break;
          case 8:
            this.stateBeforeClosingTagName(e4);
            break;
          case 10:
            this.stateAfterClosingTagName(e4);
            break;
          case 29:
            this.stateBeforeSpecialS(e4);
            break;
          case 30:
            this.stateBeforeSpecialT(e4);
            break;
          case 21:
            this.stateInAttrValueNoQuotes(e4);
            break;
          case 7:
            this.stateInSelfClosingTag(e4);
            break;
          case 23:
            this.stateInDeclaration(e4);
            break;
          case 22:
            this.stateBeforeDeclaration(e4);
            break;
          case 25:
            this.stateBeforeComment(e4);
            break;
          case 24:
            this.stateInProcessingInstruction(e4);
            break;
          case 33:
            this.stateInEntity();
        }
        this.index++;
      }
      this.cleanup(), this.finish();
    }
    cleanup() {
      this.sectionStart !== this.index && (1 === this.state || 32 === this.state && 0 === this.sequenceIndex ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : 19 !== this.state && 20 !== this.state && 21 !== this.state || (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
    }
    finish() {
      33 === this.state && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
    }
    handleTrailingData() {
      const e3 = this.buffer.length;
      this.sectionStart >= e3 || (28 === this.state ? this.currentSequence === ye.CdataEnd ? this.cbs.oncdata(this.sectionStart, e3) : this.cbs.oncomment(this.sectionStart, e3) : 6 === this.state || 11 === this.state || 18 === this.state || 17 === this.state || 12 === this.state || 13 === this.state || 14 === this.state || 15 === this.state || 16 === this.state || 20 === this.state || 19 === this.state || 21 === this.state || 9 === this.state || this.cbs.ontext(this.sectionStart, e3));
    }
    emitCodePoint(e3, t3) {
      1 !== this.baseState && 32 !== this.baseState ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + t3, this.index = this.sectionStart - 1, this.cbs.onattribentity(s2.fromCodePoint(e3), this.entityStart, this.sectionStart)) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + t3, this.index = this.sectionStart - 1, this.cbs.ontextentity(s2.fromCodePoint(e3), this.entityStart, this.sectionStart));
    }
  }(Tt, { onerr: Wt, ontext(e3, t3) {
    It(Ct(e3, t3), e3, t3);
  }, ontextentity(e3, t3, r3) {
    It(e3, t3, r3);
  }, oninterpolation(e3, t3) {
    if (St) return It(Ct(e3, t3), e3, t3);
    let r3 = e3 + wt.delimiterOpen.length, n3 = t3 - wt.delimiterClose.length;
    for (; fe(ht.charCodeAt(r3)); ) r3++;
    for (; fe(ht.charCodeAt(n3 - 1)); ) n3--;
    let i3 = Ct(r3, n3);
    i3.includes("&") && (i3 = s2.decodeHTML(i3)), Ft({ type: 5, content: qt(i3, false, Ut(r3, n3)), loc: Ut(e3, t3) });
  }, onopentagname(e3, t3) {
    const r3 = Ct(e3, t3);
    mt = { type: 1, tag: r3, ns: dt.getNamespace(r3, Tt[0], dt.ns), tagType: 0, props: [], children: [], loc: Ut(e3 - 1, t3), codegenNode: void 0 };
  }, onopentagend(e3) {
    Ot(e3);
  }, onclosetag(e3, t3) {
    const r3 = Ct(e3, t3);
    if (!dt.isVoidTag(r3)) {
      let n3 = false;
      for (let e4 = 0; e4 < Tt.length; e4++) if (Tt[e4].tag.toLowerCase() === r3.toLowerCase()) {
        n3 = true, e4 > 0 && Wt(24, Tt[0].loc.start.offset);
        for (let r4 = 0; r4 <= e4; r4++) _t(Tt.shift(), t3, r4 < e4);
        break;
      }
      n3 || Wt(23, kt(e3, 60));
    }
  }, onselfclosingtag(e3) {
    var t3;
    const r3 = mt.tag;
    mt.isSelfClosing = true, Ot(e3), (null == (t3 = Tt[0]) ? void 0 : t3.tag) === r3 && _t(Tt.shift(), e3);
  }, onattribname(e3, t3) {
    yt = { type: 6, name: Ct(e3, t3), nameLoc: Ut(e3, t3), value: void 0, loc: Ut(e3) };
  }, ondirname(e3, t3) {
    const r3 = Ct(e3, t3), n3 = "." === r3 || ":" === r3 ? "bind" : "@" === r3 ? "on" : "#" === r3 ? "slot" : r3.slice(2);
    if (St || "" !== n3 || Wt(26, e3), St || "" === n3) yt = { type: 6, name: r3, nameLoc: Ut(e3, t3), value: void 0, loc: Ut(e3) };
    else if (yt = { type: 7, name: n3, rawName: r3, exp: void 0, arg: void 0, modifiers: "." === r3 ? ["prop"] : [], loc: Ut(e3) }, "pre" === n3) {
      St = wt.inVPre = true, xt = mt;
      const e4 = mt.props;
      for (let t4 = 0; t4 < e4.length; t4++) 7 === e4[t4].type && (e4[t4] = Vt(e4[t4]));
    }
  }, ondirarg(e3, t3) {
    if (e3 === t3) return;
    const r3 = Ct(e3, t3);
    if (St) yt.name += r3, $t(yt.nameLoc, t3);
    else {
      const n3 = "[" !== r3[0];
      yt.arg = qt(n3 ? r3 : r3.slice(1, -1), n3, Ut(e3, t3), n3 ? 3 : 0);
    }
  }, ondirmodifier(e3, t3) {
    const r3 = Ct(e3, t3);
    if (St) yt.name += "." + r3, $t(yt.nameLoc, t3);
    else if ("slot" === yt.name) {
      const e4 = yt.arg;
      e4 && (e4.content += "." + r3, $t(e4.loc, t3));
    } else yt.modifiers.push(r3);
  }, onattribdata(e3, t3) {
    gt += Ct(e3, t3), bt < 0 && (bt = e3), vt = t3;
  }, onattribentity(e3, t3, r3) {
    gt += e3, bt < 0 && (bt = t3), vt = r3;
  }, onattribnameend(e3) {
    const t3 = yt.loc.start.offset, r3 = Ct(t3, e3);
    7 === yt.type && (yt.rawName = r3), mt.props.some((e4) => (7 === e4.type ? e4.rawName : e4.name) === r3) && Wt(2, t3);
  }, onattribend(e3, t3) {
    if (mt && yt) {
      if ($t(yt.loc, t3), 0 !== e3) if (6 === yt.type) "class" === yt.name && (gt = Rt(gt).trim()), 1 !== e3 || gt || Wt(13, t3), yt.value = { type: 2, content: gt, loc: 1 === e3 ? Ut(bt, vt) : Ut(bt - 1, vt + 1) }, wt.inSFCRoot && "template" === mt.tag && "lang" === yt.name && gt && "html" !== gt && wt.enterRCDATA(me("</template"), 0);
      else {
        let e4 = 0;
        "for" === yt.name ? e4 = 3 : "slot" === yt.name ? e4 = 1 : "on" === yt.name && gt.includes(";") && (e4 = 2), yt.exp = qt(gt, false, Ut(bt, vt), 0, e4), "for" === yt.name && (yt.forParseResult = function(e5) {
          const t5 = e5.loc, r3 = e5.content, n3 = r3.match(ut);
          if (!n3) return;
          const [, s3, i3] = n3, o3 = function(e6, r4) {
            let n4 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            const s4 = t5.start.offset + r4;
            return qt(e6, false, Ut(s4, s4 + e6.length), 0, n4 ? 1 : 0);
          }, a3 = { source: o3(i3.trim(), r3.indexOf(i3, s3.length)), value: void 0, key: void 0, index: void 0, finalized: false };
          let l2 = s3.trim().replace(At, "").trim();
          const c2 = s3.indexOf(l2), u2 = l2.match(Pt);
          if (u2) {
            l2 = l2.replace(Pt, "").trim();
            const e6 = u2[1].trim();
            let t6;
            if (e6 && (t6 = r3.indexOf(e6, c2 + l2.length), a3.key = o3(e6, t6, true)), u2[2]) {
              const n4 = u2[2].trim();
              n4 && (a3.index = o3(n4, r3.indexOf(n4, a3.key ? t6 + e6.length : c2 + l2.length), true));
            }
          }
          return l2 && (a3.value = o3(l2, c2, true)), a3;
        }(yt.exp));
        let t4 = -1;
        "bind" === yt.name && (t4 = yt.modifiers.indexOf("sync")) > -1 && Ee("COMPILER_V_BIND_SYNC", dt, yt.loc, yt.rawName) && (yt.name = "model", yt.modifiers.splice(t4, 1));
      }
      7 === yt.type && "pre" === yt.name || mt.props.push(yt);
    }
    gt = "", bt = vt = -1;
  }, oncomment(e3, t3) {
    dt.comments && Ft({ type: 3, content: Ct(e3, t3), loc: Ut(e3 - 4, t3 + 3) });
  }, onend() {
    const e3 = ht.length;
    if (1 !== wt.state) switch (wt.state) {
      case 5:
      case 8:
        Wt(5, e3);
        break;
      case 3:
      case 4:
        Wt(25, wt.sectionStart);
        break;
      case 28:
        wt.currentSequence === ye.CdataEnd ? Wt(6, e3) : Wt(7, e3);
        break;
      case 6:
      case 7:
      case 9:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
        Wt(9, e3);
    }
    for (let t3 = 0; t3 < Tt.length; t3++) _t(Tt[t3], e3 - 1), Wt(24, Tt[t3].loc.start.offset);
  }, oncdata(e3, t3) {
    0 !== Tt[0].ns ? It(Ct(e3, t3), e3, t3) : Wt(1, e3 - 9);
  }, onprocessinginstruction(e3) {
    0 === (Tt[0] ? Tt[0].ns : dt.ns) && Wt(21, e3 - 1);
  } }), Pt = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, At = /^\(|\)$/g;
  function Ct(e3, t3) {
    return ht.slice(e3, t3);
  }
  function Ot(e3) {
    wt.inSFCRoot && (mt.innerLoc = Ut(e3 + 1, e3 + 1)), Ft(mt);
    const { tag: t3, ns: r3 } = mt;
    0 === r3 && dt.isPreTag(t3) && Et++, dt.isVoidTag(t3) ? _t(mt, e3) : (Tt.unshift(mt), 1 !== r3 && 2 !== r3 || (wt.inXML = true)), mt = null;
  }
  function It(e3, t3, r3) {
    const n3 = Tt[0] || ft, s3 = n3.children[n3.children.length - 1];
    2 === (null == s3 ? void 0 : s3.type) ? (s3.content += e3, $t(s3.loc, r3)) : n3.children.push({ type: 2, content: e3, loc: Ut(t3, r3) });
  }
  function _t(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    $t(e3.loc, r3 ? kt(t3, 60) : t3 + 1), wt.inSFCRoot && (e3.children.length ? e3.innerLoc.end = n2.extend({}, e3.children[e3.children.length - 1].loc.end) : e3.innerLoc.end = n2.extend({}, e3.innerLoc.start), e3.innerLoc.source = Ct(e3.innerLoc.start.offset, e3.innerLoc.end.offset));
    const { tag: s3, ns: i3 } = e3;
    St || ("slot" === s3 ? e3.tagType = 2 : Dt(e3) ? e3.tagType = 3 : function(e4) {
      let { tag: t4, props: r4 } = e4;
      var n3, s4;
      if (dt.isCustomElement(t4)) return false;
      if ("component" === t4 || (s4 = t4.charCodeAt(0)) > 64 && s4 < 91 || Ue(t4) || (null == (n3 = dt.isBuiltInComponent) ? void 0 : n3.call(dt, t4)) || dt.isNativeTag && !dt.isNativeTag(t4)) return true;
      for (let e5 = 0; e5 < r4.length; e5++) {
        const t5 = r4[e5];
        if (6 === t5.type) {
          if ("is" === t5.name && t5.value) {
            if (t5.value.content.startsWith("vue:")) return true;
            if (Ee("COMPILER_IS_ON_ELEMENT", dt, t5.loc)) return true;
          }
        } else if ("bind" === t5.name && Qe(t5.arg, "is") && Ee("COMPILER_IS_ON_ELEMENT", dt, t5.loc)) return true;
      }
      return false;
    }(e3) && (e3.tagType = 1)), wt.inRCDATA || (e3.children = Lt(e3.children, e3.tag)), 0 === i3 && dt.isPreTag(s3) && Et--, xt === e3 && (St = wt.inVPre = false, xt = null), wt.inXML && 0 === (Tt[0] ? Tt[0].ns : dt.ns) && (wt.inXML = false);
    {
      const t4 = e3.props;
      if (!wt.inSFCRoot && ve("COMPILER_NATIVE_TEMPLATE", dt) && "template" === e3.tag && !Dt(e3)) {
        const t5 = Tt[0] || ft, r5 = t5.children.indexOf(e3);
        t5.children.splice(r5, 1, ...e3.children);
      }
      const r4 = t4.find((e4) => 6 === e4.type && "inline-template" === e4.name);
      r4 && Ee("COMPILER_INLINE_TEMPLATE", dt, r4.loc) && e3.children.length && (r4.value = { type: 2, content: Ct(e3.children[0].loc.start.offset, e3.children[e3.children.length - 1].loc.end.offset), loc: r4.loc });
    }
  }
  function kt(e3, t3) {
    let r3 = e3;
    for (; ht.charCodeAt(r3) !== t3 && r3 >= 0; ) r3--;
    return r3;
  }
  const Nt = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
  function Dt(e3) {
    let { tag: t3, props: r3 } = e3;
    if ("template" === t3) {
      for (let e4 = 0; e4 < r3.length; e4++) if (7 === r3[e4].type && Nt.has(r3[e4].name)) return true;
    }
    return false;
  }
  const jt = /\r\n/g;
  function Lt(e3, t3) {
    var r3, n3;
    const s3 = "preserve" !== dt.whitespace;
    let i3 = false;
    for (let t4 = 0; t4 < e3.length; t4++) {
      const o3 = e3[t4];
      if (2 === o3.type) if (Et) o3.content = o3.content.replace(jt, "\n");
      else if (Mt(o3.content)) {
        const a3 = null == (r3 = e3[t4 - 1]) ? void 0 : r3.type, l2 = null == (n3 = e3[t4 + 1]) ? void 0 : n3.type;
        !a3 || !l2 || s3 && (3 === a3 && (3 === l2 || 1 === l2) || 1 === a3 && (3 === l2 || 1 === l2 && Bt(o3.content))) ? (i3 = true, e3[t4] = null) : o3.content = " ";
      } else s3 && (o3.content = Rt(o3.content));
    }
    if (Et && t3 && dt.isPreTag(t3)) {
      const t4 = e3[0];
      t4 && 2 === t4.type && (t4.content = t4.content.replace(/^\r?\n/, ""));
    }
    return i3 ? e3.filter(Boolean) : e3;
  }
  function Mt(e3) {
    for (let t3 = 0; t3 < e3.length; t3++) if (!fe(e3.charCodeAt(t3))) return false;
    return true;
  }
  function Bt(e3) {
    for (let t3 = 0; t3 < e3.length; t3++) {
      const r3 = e3.charCodeAt(t3);
      if (10 === r3 || 13 === r3) return true;
    }
    return false;
  }
  function Rt(e3) {
    let t3 = "", r3 = false;
    for (let n3 = 0; n3 < e3.length; n3++) fe(e3.charCodeAt(n3)) ? r3 || (t3 += " ", r3 = true) : (t3 += e3[n3], r3 = false);
    return t3;
  }
  function Ft(e3) {
    (Tt[0] || ft).children.push(e3);
  }
  function Ut(e3, t3) {
    return { start: wt.getPos(e3), end: null == t3 ? t3 : wt.getPos(t3), source: null == t3 ? t3 : Ct(e3, t3) };
  }
  function $t(e3, t3) {
    e3.end = wt.getPos(t3), e3.source = Ct(e3.start.offset, t3);
  }
  function Vt(e3) {
    const t3 = { type: 6, name: e3.rawName, nameLoc: Ut(e3.loc.start.offset, e3.loc.start.offset + e3.rawName.length), value: void 0, loc: e3.loc };
    if (e3.exp) {
      const r3 = e3.exp.loc;
      r3.end.offset < e3.loc.end.offset && (r3.start.offset--, r3.start.column--, r3.end.offset++, r3.end.column++), t3.value = { type: 2, content: e3.exp.content, loc: r3 };
    }
    return t3;
  }
  function qt(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r3 = arguments.length > 2 ? arguments[2] : void 0, n3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
    const s3 = ee(e3, t3, r3, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0);
    if (!t3 && dt.prefixIdentifiers && 3 !== n3 && e3.trim()) {
      if (Ve(e3)) return s3.ast = null, s3;
      try {
        const t4 = dt.expressionPlugins, r4 = { plugins: t4 ? [...t4, "typescript"] : ["typescript"] };
        s3.ast = 2 === n3 ? i2.parse(` ${e3} `, r4).program : 1 === n3 ? i2.parseExpression(`(${e3})=>{}`, r4) : i2.parseExpression(`(${e3})`, r4);
      } catch (e4) {
        s3.ast = false, Wt(45, r3.start.offset, e4.message);
      }
    }
    return s3;
  }
  function Wt(e3, t3, r3) {
    dt.onError(Te(e3, Ut(t3, t3), void 0, r3));
  }
  function Gt(e3, t3) {
    if (wt.reset(), mt = null, yt = null, gt = "", bt = -1, vt = -1, Tt.length = 0, ht = e3, dt = n2.extend({}, pt), t3) {
      let e4;
      for (e4 in t3) null != t3[e4] && (dt[e4] = t3[e4]);
    }
    wt.mode = "html" === dt.parseMode ? 1 : "sfc" === dt.parseMode ? 2 : 0, wt.inXML = 1 === dt.ns || 2 === dt.ns;
    const r3 = null == t3 ? void 0 : t3.delimiters;
    r3 && (wt.delimiterOpen = me(r3[0]), wt.delimiterClose = me(r3[1]));
    const s3 = ft = X([], e3);
    return wt.parse(ht), s3.loc = Ut(0, e3.length), s3.children = Lt(s3.children), ft = null, s3;
  }
  function Ht(e3, t3) {
    Kt(e3, t3, zt(e3, e3.children[0]));
  }
  function zt(e3, t3) {
    const { children: r3 } = e3;
    return 1 === r3.length && 1 === t3.type && !rt(t3);
  }
  function Kt(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    const { children: s3 } = e3, i3 = s3.length;
    let o3 = 0;
    for (let e4 = 0; e4 < s3.length; e4++) {
      const n3 = s3[e4];
      if (1 === n3.type && 0 === n3.tagType) {
        const e5 = r3 ? 0 : Xt(n3, t3);
        if (e5 > 0) {
          if (e5 >= 2) {
            n3.codegenNode.patchFlag = "-1", n3.codegenNode = t3.hoist(n3.codegenNode), o3++;
            continue;
          }
        } else {
          const e6 = n3.codegenNode;
          if (13 === e6.type) {
            const r4 = er(e6);
            if ((!r4 || 512 === r4 || 1 === r4) && Qt(n3, t3) >= 2) {
              const r5 = Zt(n3);
              r5 && (e6.props = t3.hoist(r5));
            }
            e6.dynamicProps && (e6.dynamicProps = t3.hoist(e6.dynamicProps));
          }
        }
      }
      if (1 === n3.type) {
        const e5 = 1 === n3.tagType;
        e5 && t3.scopes.vSlot++, Kt(n3, t3), e5 && t3.scopes.vSlot--;
      } else if (11 === n3.type) Kt(n3, t3, 1 === n3.children.length);
      else if (9 === n3.type) for (let e5 = 0; e5 < n3.branches.length; e5++) Kt(n3.branches[e5], t3, 1 === n3.branches[e5].children.length);
    }
    if (o3 && t3.transformHoist && t3.transformHoist(s3, t3, e3), o3 && o3 === i3 && 1 === e3.type && 0 === e3.tagType && e3.codegenNode && 13 === e3.codegenNode.type && n2.isArray(e3.codegenNode.children)) {
      const r4 = t3.hoist(Y(e3.codegenNode.children));
      t3.hmr && (r4.content = `[...${r4.content}]`), e3.codegenNode.children = r4;
    }
  }
  function Xt(e3, t3) {
    const { constantCache: r3 } = t3;
    switch (e3.type) {
      case 1:
        if (0 !== e3.tagType) return 0;
        const s3 = r3.get(e3);
        if (void 0 !== s3) return s3;
        const i3 = e3.codegenNode;
        if (13 !== i3.type) return 0;
        if (i3.isBlock && "svg" !== e3.tag && "foreignObject" !== e3.tag) return 0;
        if (er(i3)) return r3.set(e3, 0), 0;
        {
          let n3 = 3;
          const s4 = Qt(e3, t3);
          if (0 === s4) return r3.set(e3, 0), 0;
          s4 < n3 && (n3 = s4);
          for (let s5 = 0; s5 < e3.children.length; s5++) {
            const i4 = Xt(e3.children[s5], t3);
            if (0 === i4) return r3.set(e3, 0), 0;
            i4 < n3 && (n3 = i4);
          }
          if (n3 > 1) for (let s5 = 0; s5 < e3.props.length; s5++) {
            const i4 = e3.props[s5];
            if (7 === i4.type && "bind" === i4.name && i4.exp) {
              const s6 = Xt(i4.exp, t3);
              if (0 === s6) return r3.set(e3, 0), 0;
              s6 < n3 && (n3 = s6);
            }
          }
          if (i3.isBlock) {
            for (let t4 = 0; t4 < e3.props.length; t4++) if (7 === e3.props[t4].type) return r3.set(e3, 0), 0;
            t3.removeHelper(f), t3.removeHelper(le(t3.inSSR, i3.isComponent)), i3.isBlock = false, t3.helper(ae(t3.inSSR, i3.isComponent));
          }
          return r3.set(e3, n3), n3;
        }
      case 2:
      case 3:
        return 3;
      case 9:
      case 11:
      case 10:
      default:
        return 0;
      case 5:
      case 12:
        return Xt(e3.content, t3);
      case 4:
        return e3.constType;
      case 8:
        let o3 = 3;
        for (let r4 = 0; r4 < e3.children.length; r4++) {
          const s4 = e3.children[r4];
          if (n2.isString(s4) || n2.isSymbol(s4)) continue;
          const i4 = Xt(s4, t3);
          if (0 === i4) return 0;
          i4 < o3 && (o3 = i4);
        }
        return o3;
    }
  }
  const Jt = /* @__PURE__ */ new Set([k, N, D, j]);
  function Yt(e3, t3) {
    if (14 === e3.type && !n2.isString(e3.callee) && Jt.has(e3.callee)) {
      const r3 = e3.arguments[0];
      if (4 === r3.type) return Xt(r3, t3);
      if (14 === r3.type) return Yt(r3, t3);
    }
    return 0;
  }
  function Qt(e3, t3) {
    let r3 = 3;
    const n3 = Zt(e3);
    if (n3 && 15 === n3.type) {
      const { properties: e4 } = n3;
      for (let n4 = 0; n4 < e4.length; n4++) {
        const { key: s3, value: i3 } = e4[n4], o3 = Xt(s3, t3);
        if (0 === o3) return o3;
        let a3;
        if (o3 < r3 && (r3 = o3), a3 = 4 === i3.type ? Xt(i3, t3) : 14 === i3.type ? Yt(i3, t3) : 0, 0 === a3) return a3;
        a3 < r3 && (r3 = a3);
      }
    }
    return r3;
  }
  function Zt(e3) {
    const t3 = e3.codegenNode;
    if (13 === t3.type) return t3.props;
  }
  function er(e3) {
    const t3 = e3.patchFlag;
    return t3 ? parseInt(t3, 10) : void 0;
  }
  function tr(e3, t3) {
    let { filename: r3 = "", prefixIdentifiers: s3 = false, hoistStatic: i3 = false, hmr: o3 = false, cacheHandlers: a3 = false, nodeTransforms: l2 = [], directiveTransforms: c2 = {}, transformHoist: u2 = null, isBuiltInComponent: p2 = n2.NOOP, isCustomElement: d2 = n2.NOOP, expressionPlugins: f2 = [], scopeId: h2 = null, slotted: m2 = true, ssr: y2 = false, inSSR: g2 = false, ssrCssVars: b2 = "", bindingMetadata: v2 = n2.EMPTY_OBJ, inline: E2 = false, isTS: S2 = false, onError: x2 = Se, onWarn: T2 = xe, compatConfig: w2 } = t3;
    const P2 = r3.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), A2 = { filename: r3, selfName: P2 && n2.capitalize(n2.camelize(P2[1])), prefixIdentifiers: s3, hoistStatic: i3, hmr: o3, cacheHandlers: a3, nodeTransforms: l2, directiveTransforms: c2, transformHoist: u2, isBuiltInComponent: p2, isCustomElement: d2, expressionPlugins: f2, scopeId: h2, slotted: m2, ssr: y2, inSSR: g2, ssrCssVars: b2, bindingMetadata: v2, inline: E2, isTS: S2, onError: x2, onWarn: T2, compatConfig: w2, root: e3, helpers: /* @__PURE__ */ new Map(), components: /* @__PURE__ */ new Set(), directives: /* @__PURE__ */ new Set(), hoists: [], imports: [], constantCache: /* @__PURE__ */ new WeakMap(), temps: 0, cached: 0, identifiers: /* @__PURE__ */ Object.create(null), scopes: { vFor: 0, vSlot: 0, vPre: 0, vOnce: 0 }, parent: null, currentNode: e3, childIndex: 0, inVOnce: false, helper(e4) {
      const t4 = A2.helpers.get(e4) || 0;
      return A2.helpers.set(e4, t4 + 1), e4;
    }, removeHelper(e4) {
      const t4 = A2.helpers.get(e4);
      if (t4) {
        const r4 = t4 - 1;
        r4 ? A2.helpers.set(e4, r4) : A2.helpers.delete(e4);
      }
    }, helperString: (e4) => `_${z[A2.helper(e4)]}`, replaceNode(e4) {
      A2.parent.children[A2.childIndex] = A2.currentNode = e4;
    }, removeNode(e4) {
      const t4 = A2.parent.children, r4 = e4 ? t4.indexOf(e4) : A2.currentNode ? A2.childIndex : -1;
      e4 && e4 !== A2.currentNode ? A2.childIndex > r4 && (A2.childIndex--, A2.onNodeRemoved()) : (A2.currentNode = null, A2.onNodeRemoved()), A2.parent.children.splice(r4, 1);
    }, onNodeRemoved: n2.NOOP, addIdentifiers(e4) {
      n2.isString(e4) ? C2(e4) : e4.identifiers ? e4.identifiers.forEach(C2) : 4 === e4.type && C2(e4.content);
    }, removeIdentifiers(e4) {
      n2.isString(e4) ? O2(e4) : e4.identifiers ? e4.identifiers.forEach(O2) : 4 === e4.type && O2(e4.content);
    }, hoist(e4) {
      n2.isString(e4) && (e4 = ee(e4)), A2.hoists.push(e4);
      const t4 = ee(`_hoisted_${A2.hoists.length}`, false, e4.loc, 2);
      return t4.hoisted = e4, t4;
    }, cache(e4) {
      let t4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      return ie(A2.cached++, e4, t4);
    } };
    function C2(e4) {
      const { identifiers: t4 } = A2;
      void 0 === t4[e4] && (t4[e4] = 0), t4[e4]++;
    }
    function O2(e4) {
      A2.identifiers[e4]--;
    }
    return A2.filters = /* @__PURE__ */ new Set(), A2;
  }
  function rr(e3, t3) {
    const r3 = tr(e3, t3);
    nr(e3, r3), t3.hoistStatic && Ht(e3, r3), t3.ssr || function(e4, t4) {
      const { helper: r4 } = t4, { children: s3 } = e4;
      if (1 === s3.length) {
        const r5 = s3[0];
        if (zt(e4, r5) && r5.codegenNode) {
          const n3 = r5.codegenNode;
          13 === n3.type && ce(n3, t4), e4.codegenNode = n3;
        } else e4.codegenNode = r5;
      } else if (s3.length > 1) {
        let s4 = 64;
        n2.PatchFlagNames[64], e4.codegenNode = J(t4, r4(l), void 0, e4.children, s4 + "", void 0, void 0, true, void 0, false);
      }
    }(e3, r3), e3.helpers = /* @__PURE__ */ new Set([...r3.helpers.keys()]), e3.components = [...r3.components], e3.directives = [...r3.directives], e3.imports = r3.imports, e3.hoists = r3.hoists, e3.temps = r3.temps, e3.cached = r3.cached, e3.transformed = true, e3.filters = [...r3.filters];
  }
  function nr(e3, t3) {
    t3.currentNode = e3;
    const { nodeTransforms: r3 } = t3, s3 = [];
    for (let i4 = 0; i4 < r3.length; i4++) {
      const o3 = r3[i4](e3, t3);
      if (o3 && (n2.isArray(o3) ? s3.push(...o3) : s3.push(o3)), !t3.currentNode) return;
      e3 = t3.currentNode;
    }
    switch (e3.type) {
      case 3:
        t3.ssr || t3.helper(b);
        break;
      case 5:
        t3.ssr || t3.helper(I);
        break;
      case 9:
        for (let r4 = 0; r4 < e3.branches.length; r4++) nr(e3.branches[r4], t3);
        break;
      case 10:
      case 11:
      case 1:
      case 0:
        !function(e4, t4) {
          let r4 = 0;
          const s4 = () => {
            r4--;
          };
          for (; r4 < e4.children.length; r4++) {
            const i4 = e4.children[r4];
            n2.isString(i4) || (t4.parent = e4, t4.childIndex = r4, t4.onNodeRemoved = s4, nr(i4, t4));
          }
        }(e3, t3);
    }
    t3.currentNode = e3;
    let i3 = s3.length;
    for (; i3--; ) s3[i3]();
  }
  function sr(e3, t3) {
    const r3 = n2.isString(e3) ? (t4) => t4 === e3 : (t4) => e3.test(t4);
    return (e4, n3) => {
      if (1 === e4.type) {
        const { props: s3 } = e4;
        if (3 === e4.tagType && s3.some(et)) return;
        const i3 = [];
        for (let o3 = 0; o3 < s3.length; o3++) {
          const a3 = s3[o3];
          if (7 === a3.type && r3(a3.name)) {
            s3.splice(o3, 1), o3--;
            const r4 = t3(e4, a3, n3);
            r4 && i3.push(r4);
          }
        }
        return i3;
      }
    };
  }
  const ir = "/*#__PURE__*/", or = (e3) => `${z[e3]}: _${z[e3]}`;
  function ar(e3, t3) {
    let { mode: r3 = "function", prefixIdentifiers: n3 = "module" === r3, sourceMap: s3 = false, filename: i3 = "template.vue.html", scopeId: o3 = null, optimizeImports: l2 = false, runtimeGlobalName: c2 = "Vue", runtimeModuleName: u2 = "vue", ssrRuntimeModuleName: p2 = "vue/server-renderer", ssr: d2 = false, isTS: f2 = false, inSSR: h2 = false } = t3;
    const m2 = { mode: r3, prefixIdentifiers: n3, sourceMap: s3, filename: i3, scopeId: o3, optimizeImports: l2, runtimeGlobalName: c2, runtimeModuleName: u2, ssrRuntimeModuleName: p2, ssr: d2, isTS: f2, inSSR: h2, source: e3.source, code: "", column: 1, line: 1, offset: 0, indentLevel: 0, pure: false, map: void 0, helper: (e4) => `_${z[e4]}`, push(e4) {
      let t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -2, r4 = arguments.length > 2 ? arguments[2] : void 0;
      if (m2.code += e4, m2.map) {
        if (r4) {
          let e5;
          if (4 === r4.type && !r4.isStatic) {
            const t5 = r4.content.replace(/^_ctx\./, "");
            t5 !== r4.content && Ve(t5) && (e5 = t5);
          }
          g2(r4.loc.start, e5);
        }
        -3 === t4 ? Xe(m2, e4) : (m2.offset += e4.length, -2 === t4 ? m2.column += e4.length : (-1 === t4 && (t4 = e4.length - 1), m2.line++, m2.column = e4.length - t4)), r4 && r4.loc !== K && g2(r4.loc.end);
      }
    }, indent() {
      y2(++m2.indentLevel);
    }, deindent() {
      arguments.length > 0 && void 0 !== arguments[0] && arguments[0] ? --m2.indentLevel : y2(--m2.indentLevel);
    }, newline() {
      y2(m2.indentLevel);
    } };
    function y2(e4) {
      m2.push("\n" + "  ".repeat(e4), 0);
    }
    function g2(e4) {
      let t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
      const { _names: r4, _mappings: n4 } = m2.map;
      null === t4 || r4.has(t4) || r4.add(t4), n4.add({ originalLine: e4.line, originalColumn: e4.column - 1, generatedLine: m2.line, generatedColumn: m2.column - 1, source: i3, name: t4 });
    }
    return s3 && (m2.map = new a2.SourceMapGenerator(), m2.map.setSourceContent(i3, m2.source), m2.map._sources.add(i3)), m2;
  }
  function lr(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const r3 = ar(e3, t3);
    t3.onContextCreated && t3.onContextCreated(r3);
    const { mode: n3, push: s3, prefixIdentifiers: i3, indent: o3, deindent: a3, newline: l2, scopeId: c2, ssr: u2 } = r3, p2 = Array.from(e3.helpers), d2 = p2.length > 0, f2 = !i3 && "module" !== n3, h2 = null != c2 && "module" === n3, m2 = !!t3.inline, S2 = m2 ? ar(e3, t3) : r3;
    "module" === n3 ? function(e4, t4, r4, n4) {
      const { push: s4, newline: i4, optimizeImports: o4, runtimeModuleName: a4, ssrRuntimeModuleName: l3 } = t4;
      if (r4 && e4.hoists.length && (e4.helpers.add(U), e4.helpers.add($)), e4.helpers.size) {
        const t5 = Array.from(e4.helpers);
        o4 ? (s4(`import { ${t5.map((e5) => z[e5]).join(", ")} } from ${JSON.stringify(a4)}
`, -1), s4(`
// Binding optimization for webpack code-split
const ${t5.map((e5) => `_${z[e5]} = ${z[e5]}`).join(", ")}
`, -1)) : s4(`import { ${t5.map((e5) => `${z[e5]} as _${z[e5]}`).join(", ")} } from ${JSON.stringify(a4)}
`, -1);
      }
      e4.ssrHelpers && e4.ssrHelpers.length && s4(`import { ${e4.ssrHelpers.map((e5) => `${z[e5]} as _${z[e5]}`).join(", ")} } from "${l3}"
`, -1), e4.imports.length && (function(e5, t5) {
        e5.length && e5.forEach((e6) => {
          t5.push("import "), fr(e6.exp, t5), t5.push(` from '${e6.path}'`), t5.newline();
        });
      }(e4.imports, t4), i4()), ur(e4.hoists, t4), i4(), n4 || s4("export ");
    }(e3, S2, h2, m2) : function(e4, t4) {
      const { ssr: r4, prefixIdentifiers: n4, push: s4, newline: i4, runtimeModuleName: o4, runtimeGlobalName: a4, ssrRuntimeModuleName: l3 } = t4, c3 = r4 ? `require(${JSON.stringify(o4)})` : a4, u3 = Array.from(e4.helpers);
      u3.length > 0 && (n4 ? s4(`const { ${u3.map(or).join(", ")} } = ${c3}
`, -1) : (s4(`const _Vue = ${c3}
`, -1), e4.hoists.length && s4(`const { ${[y, g, b, v, E].filter((e5) => u3.includes(e5)).map(or).join(", ")} } = _Vue
`, -1))), e4.ssrHelpers && e4.ssrHelpers.length && s4(`const { ${e4.ssrHelpers.map(or).join(", ")} } = require("${l3}")
`, -1), ur(e4.hoists, t4), i4(), s4("return ");
    }(e3, S2);
    const x2 = u2 ? "ssrRender" : "render", T2 = u2 ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
    t3.bindingMetadata && !t3.inline && T2.push("$props", "$setup", "$data", "$options");
    const w2 = t3.isTS ? T2.map((e4) => `${e4}: any`).join(",") : T2.join(", ");
    if (s3(m2 ? `(${w2}) => {` : `function ${x2}(${w2}) {`), o3(), f2 && (s3("with (_ctx) {"), o3(), d2 && (s3(`const { ${p2.map(or).join(", ")} } = _Vue
`, -1), l2())), e3.components.length && (cr(e3.components, "component", r3), (e3.directives.length || e3.temps > 0) && l2()), e3.directives.length && (cr(e3.directives, "directive", r3), e3.temps > 0 && l2()), e3.filters && e3.filters.length && (l2(), cr(e3.filters, "filter", r3), l2()), e3.temps > 0) {
      s3("let ");
      for (let t4 = 0; t4 < e3.temps; t4++) s3(`${t4 > 0 ? ", " : ""}_temp${t4}`);
    }
    return (e3.components.length || e3.directives.length || e3.temps) && (s3("\n", 0), l2()), u2 || s3("return "), e3.codegenNode ? fr(e3.codegenNode, r3) : s3("null"), f2 && (a3(), s3("}")), a3(), s3("}"), { ast: e3, code: r3.code, preamble: m2 ? S2.code : "", map: r3.map ? r3.map.toJSON() : void 0 };
  }
  function cr(e3, t3, r3) {
    let { helper: n3, push: s3, newline: i3, isTS: o3 } = r3;
    const a3 = n3("filter" === t3 ? w : "component" === t3 ? S : T);
    for (let r4 = 0; r4 < e3.length; r4++) {
      let n4 = e3[r4];
      const l2 = n4.endsWith("__self");
      l2 && (n4 = n4.slice(0, -6)), s3(`const ${at(n4, t3)} = ${a3}(${JSON.stringify(n4)}${l2 ? ", true" : ""})${o3 ? "!" : ""}`), r4 < e3.length - 1 && i3();
    }
  }
  function ur(e3, t3) {
    if (!e3.length) return;
    t3.pure = true;
    const { push: r3, newline: n3, helper: s3, scopeId: i3, mode: o3 } = t3, a3 = null != i3 && "function" !== o3;
    n3(), a3 && (r3(`const _withScopeId = n => (${s3(U)}("${i3}"),n=n(),${s3($)}(),n)`), n3());
    for (let s4 = 0; s4 < e3.length; s4++) {
      const i4 = e3[s4];
      if (i4) {
        const e4 = a3 && 13 === i4.type;
        r3(`const _hoisted_${s4 + 1} = ${e4 ? `${ir} _withScopeId(() => ` : ""}`), fr(i4, t3), e4 && r3(")"), n3();
      }
    }
    t3.pure = false;
  }
  function pr(e3, t3) {
    const r3 = e3.length > 3 || e3.some((e4) => n2.isArray(e4) || !function(e5) {
      return n2.isString(e5) || 4 === e5.type || 2 === e5.type || 5 === e5.type || 8 === e5.type;
    }(e4));
    t3.push("["), r3 && t3.indent(), dr(e3, t3, r3), r3 && t3.deindent(), t3.push("]");
  }
  function dr(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
    const { push: i3, newline: o3 } = t3;
    for (let a3 = 0; a3 < e3.length; a3++) {
      const l2 = e3[a3];
      n2.isString(l2) ? i3(l2, -3) : n2.isArray(l2) ? pr(l2, t3) : fr(l2, t3), a3 < e3.length - 1 && (r3 ? (s3 && i3(","), o3()) : s3 && i3(", "));
    }
  }
  function fr(e3, t3) {
    if (n2.isString(e3)) t3.push(e3, -3);
    else if (n2.isSymbol(e3)) t3.push(t3.helper(e3));
    else switch (e3.type) {
      case 1:
      case 9:
      case 11:
      case 12:
        fr(e3.codegenNode, t3);
        break;
      case 2:
        !function(e4, t4) {
          t4.push(JSON.stringify(e4.content), -3, e4);
        }(e3, t3);
        break;
      case 4:
        hr(e3, t3);
        break;
      case 5:
        !function(e4, t4) {
          const { push: r3, helper: n3, pure: s3 } = t4;
          s3 && r3(ir), r3(`${n3(I)}(`), fr(e4.content, t4), r3(")");
        }(e3, t3);
        break;
      case 8:
        mr(e3, t3);
        break;
      case 3:
        !function(e4, t4) {
          const { push: r3, helper: n3, pure: s3 } = t4;
          s3 && r3(ir), r3(`${n3(b)}(${JSON.stringify(e4.content)})`, -3, e4);
        }(e3, t3);
        break;
      case 13:
        !function(e4, t4) {
          const { push: r3, helper: n3, pure: s3 } = t4, { tag: i3, props: o3, children: a3, patchFlag: l2, dynamicProps: c2, directives: u2, isBlock: p2, disableTracking: d2, isComponent: h2 } = e4;
          u2 && r3(n3(P) + "("), p2 && r3(`(${n3(f)}(${d2 ? "true" : ""}), `), s3 && r3(ir);
          r3(n3(p2 ? le(t4.inSSR, h2) : ae(t4.inSSR, h2)) + "(", -2, e4), dr(function(e5) {
            let t5 = e5.length;
            for (; t5-- && null == e5[t5]; ) ;
            return e5.slice(0, t5 + 1).map((e6) => e6 || "null");
          }([i3, o3, a3, l2, c2]), t4), r3(")"), p2 && r3(")"), u2 && (r3(", "), fr(u2, t4), r3(")"));
        }(e3, t3);
        break;
      case 14:
        !function(e4, t4) {
          const { push: r3, helper: s3, pure: i3 } = t4, o3 = n2.isString(e4.callee) ? e4.callee : s3(e4.callee);
          i3 && r3(ir), r3(o3 + "(", -2, e4), dr(e4.arguments, t4), r3(")");
        }(e3, t3);
        break;
      case 15:
        !function(e4, t4) {
          const { push: r3, indent: n3, deindent: s3, newline: i3 } = t4, { properties: o3 } = e4;
          if (!o3.length) return void r3("{}", -2, e4);
          const a3 = o3.length > 1 || o3.some((e5) => 4 !== e5.value.type);
          r3(a3 ? "{" : "{ "), a3 && n3();
          for (let e5 = 0; e5 < o3.length; e5++) {
            const { key: n4, value: s4 } = o3[e5];
            yr(n4, t4), r3(": "), fr(s4, t4), e5 < o3.length - 1 && (r3(","), i3());
          }
          a3 && s3(), r3(a3 ? "}" : " }");
        }(e3, t3);
        break;
      case 17:
        !function(e4, t4) {
          pr(e4.elements, t4);
        }(e3, t3);
        break;
      case 18:
        !function(e4, t4) {
          const { push: r3, indent: s3, deindent: i3 } = t4, { params: o3, returns: a3, body: l2, newline: c2, isSlot: u2 } = e4;
          u2 && r3(`_${z[V]}(`), r3("(", -2, e4), n2.isArray(o3) ? dr(o3, t4) : o3 && fr(o3, t4), r3(") => "), (c2 || l2) && (r3("{"), s3()), a3 ? (c2 && r3("return "), n2.isArray(a3) ? pr(a3, t4) : fr(a3, t4)) : l2 && fr(l2, t4), (c2 || l2) && (i3(), r3("}")), u2 && (e4.isNonScopedSlot && r3(", undefined, true"), r3(")"));
        }(e3, t3);
        break;
      case 19:
        !function(e4, t4) {
          const { test: r3, consequent: n3, alternate: s3, newline: i3 } = e4, { push: o3, indent: a3, deindent: l2, newline: c2 } = t4;
          if (4 === r3.type) {
            const e5 = !Ve(r3.content);
            e5 && o3("("), hr(r3, t4), e5 && o3(")");
          } else o3("("), fr(r3, t4), o3(")");
          i3 && a3(), t4.indentLevel++, i3 || o3(" "), o3("? "), fr(n3, t4), t4.indentLevel--, i3 && c2(), i3 || o3(" "), o3(": ");
          const u2 = 19 === s3.type;
          u2 || t4.indentLevel++, fr(s3, t4), u2 || t4.indentLevel--, i3 && l2(true);
        }(e3, t3);
        break;
      case 20:
        !function(e4, t4) {
          const { push: r3, helper: n3, indent: s3, deindent: i3, newline: o3 } = t4;
          r3(`_cache[${e4.index}] || (`), e4.isVNode && (s3(), r3(`${n3(F)}(-1),`), o3()), r3(`_cache[${e4.index}] = `), fr(e4.value, t4), e4.isVNode && (r3(","), o3(), r3(`${n3(F)}(1),`), o3(), r3(`_cache[${e4.index}]`), i3()), r3(")");
        }(e3, t3);
        break;
      case 21:
        dr(e3.body, t3, true, false);
        break;
      case 22:
        !function(e4, t4) {
          const { push: r3, indent: s3, deindent: i3 } = t4;
          r3("`");
          const o3 = e4.elements.length, a3 = o3 > 3;
          for (let l2 = 0; l2 < o3; l2++) {
            const o4 = e4.elements[l2];
            n2.isString(o4) ? r3(o4.replace(/(`|\$|\\)/g, "\\$1"), -3) : (r3("${"), a3 && s3(), fr(o4, t4), a3 && i3(), r3("}"));
          }
          r3("`");
        }(e3, t3);
        break;
      case 23:
        gr(e3, t3);
        break;
      case 24:
        !function(e4, t4) {
          fr(e4.left, t4), t4.push(" = "), fr(e4.right, t4);
        }(e3, t3);
        break;
      case 25:
        !function(e4, t4) {
          t4.push("("), dr(e4.expressions, t4), t4.push(")");
        }(e3, t3);
        break;
      case 26:
        !function(e4, t4) {
          let { returns: r3 } = e4;
          t4.push("return "), n2.isArray(r3) ? pr(r3, t4) : fr(r3, t4);
        }(e3, t3);
    }
  }
  function hr(e3, t3) {
    const { content: r3, isStatic: n3 } = e3;
    t3.push(n3 ? JSON.stringify(r3) : r3, -3, e3);
  }
  function mr(e3, t3) {
    for (let r3 = 0; r3 < e3.children.length; r3++) {
      const s3 = e3.children[r3];
      n2.isString(s3) ? t3.push(s3, -3) : fr(s3, t3);
    }
  }
  function yr(e3, t3) {
    const { push: r3 } = t3;
    8 === e3.type ? (r3("["), mr(e3, t3), r3("]")) : e3.isStatic ? r3(Ve(e3.content) ? e3.content : JSON.stringify(e3.content), -2, e3) : r3(`[${e3.content}]`, -3, e3);
  }
  function gr(e3, t3) {
    const { push: r3, indent: n3, deindent: s3 } = t3, { test: i3, consequent: o3, alternate: a3 } = e3;
    r3("if ("), fr(i3, t3), r3(") {"), n3(), fr(o3, t3), s3(), r3("}"), a3 && (r3(" else "), 23 === a3.type ? gr(a3, t3) : (r3("{"), n3(), fr(a3, t3), s3(), r3("}")));
  }
  const br = n2.makeMap("true,false,null,this"), vr = /\w\s*\(|\.[^\d]/, Er = (e3, t3) => {
    if (5 === e3.type) e3.content = Sr(e3.content, t3);
    else if (1 === e3.type) for (let r3 = 0; r3 < e3.props.length; r3++) {
      const n3 = e3.props[r3];
      if (7 === n3.type && "for" !== n3.name) {
        const e4 = n3.exp, r4 = n3.arg;
        !e4 || 4 !== e4.type || "on" === n3.name && r4 || (n3.exp = Sr(e4, t3, "slot" === n3.name)), r4 && 4 === r4.type && !r4.isStatic && (n3.arg = Sr(r4, t3));
      }
    }
  };
  function Sr(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], o3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Object.create(t3.identifiers);
    if (!t3.prefixIdentifiers || !e3.content.trim()) return e3;
    const { inline: a3, bindingMetadata: l2 } = t3, c2 = (e4, r4, s4) => {
      const i3 = n2.hasOwn(l2, e4) && l2[e4];
      if (a3) {
        const a4 = r4 && "AssignmentExpression" === r4.type && r4.left === s4, c3 = r4 && "UpdateExpression" === r4.type && r4.argument === s4, p3 = r4 && Ce(r4, h2), d3 = r4 && Oe(h2), f3 = (e5) => {
          const r5 = `${t3.helperString(q)}(${e5})`;
          return d3 ? `(${r5})` : r5;
        };
        if (Tr(i3) || "setup-reactive-const" === i3 || o3[e4]) return e4;
        if ("setup-ref" === i3) return `${e4}.value`;
        if ("setup-maybe-ref" === i3) return a4 || c3 || p3 ? `${e4}.value` : f3(e4);
        if ("setup-let" === i3) {
          if (a4) {
            const { right: n3, operator: s5 } = r4, i4 = xr(Sr(ee(u2.slice(n3.start - 1, n3.end - 1), false), t3, false, false, m2));
            return `${t3.helperString(W)}(${e4})${t3.isTS ? " //@ts-ignore\n" : ""} ? ${e4}.value ${s5} ${i4} : ${e4}`;
          }
          if (c3) {
            s4.start = r4.start, s4.end = r4.end;
            const { prefix: n3, operator: i4 } = r4, o4 = n3 ? i4 : "", a5 = n3 ? "" : i4;
            return `${t3.helperString(W)}(${e4})${t3.isTS ? " //@ts-ignore\n" : ""} ? ${o4}${e4}.value${a5} : ${o4}${e4}${a5}`;
          }
          return p3 ? e4 : f3(e4);
        }
        if ("props" === i3) return n2.genPropsAccessExp(e4);
        if ("props-aliased" === i3) return n2.genPropsAccessExp(l2.__propsAliases[e4]);
      } else {
        if (i3 && i3.startsWith("setup") || "literal-const" === i3) return `$setup.${e4}`;
        if ("props-aliased" === i3) return `$props['${l2.__propsAliases[e4]}']`;
        if (i3) return `$${i3}.${e4}`;
      }
      return `_ctx.${e4}`;
    }, u2 = e3.content, p2 = vr.test(u2);
    let d2 = e3.ast;
    if (false === d2) return e3;
    if (null === d2 || !d2 && Ve(u2)) {
      const s4 = t3.identifiers[u2], i3 = n2.isGloballyAllowed(u2), o4 = br(u2);
      return r3 || s4 || o4 || i3 && !l2[u2] ? s4 || (e3.constType = o4 ? 3 : 2) : (Tr(l2[u2]) && (e3.constType = 1), e3.content = c2(u2)), e3;
    }
    if (!d2) {
      const n3 = s3 ? ` ${u2} ` : `(${u2})${r3 ? "=>{}" : ""}`;
      try {
        d2 = i2.parse(n3, { plugins: t3.expressionPlugins }).program;
      } catch (r4) {
        return t3.onError(Te(45, e3.loc, void 0, r4.message)), e3;
      }
    }
    const f2 = [], h2 = [], m2 = Object.create(t3.identifiers);
    Pe(d2, (e4, t4, r4, s4, i3) => {
      if (Me(e4, t4)) return;
      if (e4.name.startsWith("_filter_")) return;
      const o4 = s4 && (a4 = e4, !n2.isGloballyAllowed(a4.name) && "require" !== a4.name);
      var a4;
      o4 && !i3 ? (Le(t4) && t4.shorthand && (e4.prefix = `${e4.name}: `), e4.name = c2(e4.name, t4, e4), f2.push(e4)) : (o4 && i3 || p2 || (e4.isConstant = true), f2.push(e4));
    }, true, h2, m2);
    const y2 = [];
    let g2;
    return f2.sort((e4, t4) => e4.start - t4.start), f2.forEach((t4, r4) => {
      const n3 = t4.start - 1, s4 = t4.end - 1, i3 = f2[r4 - 1], o4 = u2.slice(i3 ? i3.end - 1 : 0, n3);
      (o4.length || t4.prefix) && y2.push(o4 + (t4.prefix || ""));
      const a4 = u2.slice(n3, s4);
      y2.push(ee(t4.name, false, { start: Ke(e3.loc.start, a4, n3), end: Ke(e3.loc.start, a4, s4), source: a4 }, t4.isConstant ? 3 : 0)), r4 === f2.length - 1 && s4 < u2.length && y2.push(u2.slice(s4));
    }), y2.length ? (g2 = te(y2, e3.loc), g2.ast = d2) : (g2 = e3, g2.constType = p2 ? 0 : 3), g2.identifiers = Object.keys(m2), g2;
  }
  function xr(e3) {
    return n2.isString(e3) ? e3 : 4 === e3.type ? e3.content : e3.children.map(xr).join("");
  }
  function Tr(e3) {
    return "setup-const" === e3 || "literal-const" === e3;
  }
  const wr = sr(/^(if|else|else-if)$/, (e3, t3, r3) => Pr(e3, t3, r3, (e4, t4, n3) => {
    const s3 = r3.parent.children;
    let i3 = s3.indexOf(e4), o3 = 0;
    for (; i3-- >= 0; ) {
      const e5 = s3[i3];
      e5 && 9 === e5.type && (o3 += e5.branches.length);
    }
    return () => {
      if (n3) e4.codegenNode = Cr(t4, o3, r3);
      else {
        const n4 = function(e5) {
          for (; ; ) if (19 === e5.type) {
            if (19 !== e5.alternate.type) return e5;
            e5 = e5.alternate;
          } else 20 === e5.type && (e5 = e5.value);
        }(e4.codegenNode);
        n4.alternate = Cr(t4, o3 + e4.branches.length - 1, r3);
      }
    };
  }));
  function Pr(e3, t3, r3, n3) {
    if (!("else" === t3.name || t3.exp && t3.exp.content.trim())) {
      const n4 = t3.exp ? t3.exp.loc : e3.loc;
      r3.onError(Te(28, t3.loc)), t3.exp = ee("true", false, n4);
    }
    if (r3.prefixIdentifiers && t3.exp && (t3.exp = Sr(t3.exp, r3)), "if" === t3.name) {
      const s3 = Ar(e3, t3), i3 = { type: 9, loc: e3.loc, branches: [s3] };
      if (r3.replaceNode(i3), n3) return n3(i3, s3, true);
    } else {
      const s3 = r3.parent.children;
      let i3 = s3.indexOf(e3);
      for (; i3-- >= -1; ) {
        const o3 = s3[i3];
        if (o3 && 3 === o3.type) r3.removeNode(o3);
        else {
          if (!o3 || 2 !== o3.type || o3.content.trim().length) {
            if (o3 && 9 === o3.type) {
              "else-if" === t3.name && void 0 === o3.branches[o3.branches.length - 1].condition && r3.onError(Te(30, e3.loc)), r3.removeNode();
              const s4 = Ar(e3, t3);
              {
                const e4 = s4.userKey;
                e4 && o3.branches.forEach((t4) => {
                  let { userKey: n4 } = t4;
                  Ir(n4, e4) && r3.onError(Te(29, s4.userKey.loc));
                });
              }
              o3.branches.push(s4);
              const i4 = n3 && n3(o3, s4, false);
              nr(s4, r3), i4 && i4(), r3.currentNode = null;
            } else r3.onError(Te(30, e3.loc));
            break;
          }
          r3.removeNode(o3);
        }
      }
    }
  }
  function Ar(e3, t3) {
    const r3 = 3 === e3.tagType;
    return { type: 10, loc: e3.loc, condition: "else" === t3.name ? void 0 : t3.exp, children: r3 && !Je(e3, "for") ? e3.children : [e3], userKey: Ye(e3, "key"), isTemplateIf: r3 };
  }
  function Cr(e3, t3, r3) {
    return e3.condition ? se(e3.condition, Or(e3, t3, r3), re(r3.helper(b), ['""', "true"])) : Or(e3, t3, r3);
  }
  function Or(e3, t3, r3) {
    const { helper: s3 } = r3, i3 = Z("key", ee(`${t3}`, false, K, 2)), { children: o3 } = e3, a3 = o3[0];
    if (1 !== o3.length || 1 !== a3.type) {
      if (1 === o3.length && 11 === a3.type) {
        const e4 = a3.codegenNode;
        return it(e4, i3, r3), e4;
      }
      {
        let t4 = 64;
        return n2.PatchFlagNames[64], J(r3, s3(l), Q([i3]), o3, t4 + "", void 0, void 0, true, false, false, e3.loc);
      }
    }
    {
      const e4 = a3.codegenNode, t4 = ct(e4);
      return 13 === t4.type && ce(t4, r3), it(t4, i3, r3), e4;
    }
  }
  function Ir(e3, t3) {
    if (!e3 || e3.type !== t3.type) return false;
    if (6 === e3.type) {
      if (e3.value.content !== t3.value.content) return false;
    } else {
      const r3 = e3.exp, n3 = t3.exp;
      if (r3.type !== n3.type) return false;
      if (4 !== r3.type || r3.isStatic !== n3.isStatic || r3.content !== n3.content) return false;
    }
    return true;
  }
  const _r = sr("for", (e3, t3, r3) => {
    const { helper: n3, removeHelper: s3 } = r3;
    return kr(e3, t3, r3, (t4) => {
      const i3 = re(n3(A), [t4.source]), o3 = tt(e3), a3 = Je(e3, "memo"), c2 = Ye(e3, "key"), u2 = c2 && (6 === c2.type ? ee(c2.value.content, true) : c2.exp), p2 = c2 ? Z("key", u2) : null;
      o3 && (a3 && (a3.exp = Sr(a3.exp, r3)), p2 && 6 !== c2.type && (p2.value = Sr(p2.value, r3)));
      const d2 = 4 === t4.source.type && t4.source.constType > 0, h2 = d2 ? 64 : c2 ? 128 : 256;
      return t4.codegenNode = J(r3, n3(l), void 0, i3, h2 + "", void 0, void 0, true, !d2, false, e3.loc), () => {
        let c3;
        const { children: h3 } = t4;
        o3 && e3.children.some((e4) => {
          if (1 === e4.type) {
            const t5 = Ye(e4, "key");
            if (t5) return r3.onError(Te(33, t5.loc)), true;
          }
        });
        const m2 = 1 !== h3.length || 1 !== h3[0].type, y2 = rt(e3) ? e3 : o3 && 1 === e3.children.length && rt(e3.children[0]) ? e3.children[0] : null;
        if (y2 ? (c3 = y2.codegenNode, o3 && p2 && it(c3, p2, r3)) : m2 ? c3 = J(r3, n3(l), p2 ? Q([p2]) : void 0, e3.children, "64", void 0, void 0, true, void 0, false) : (c3 = h3[0].codegenNode, o3 && p2 && it(c3, p2, r3), c3.isBlock !== !d2 && (c3.isBlock ? (s3(f), s3(le(r3.inSSR, c3.isComponent))) : s3(ae(r3.inSSR, c3.isComponent))), c3.isBlock = !d2, c3.isBlock ? (n3(f), n3(le(r3.inSSR, c3.isComponent))) : n3(ae(r3.inSSR, c3.isComponent))), a3) {
          const e4 = ne(Dr(t4.parseResult, [ee("_cached")]));
          e4.body = oe([te(["const _memo = (", a3.exp, ")"]), te(["if (_cached", ...u2 ? [" && _cached.key === ", u2] : [], ` && ${r3.helperString(H)}(_cached, _memo)) return _cached`]), te(["const _item = ", c3]), ee("_item.memo = _memo"), ee("return _item")]), i3.arguments.push(e4, ee("_cache"), ee(String(r3.cached++)));
        } else i3.arguments.push(ne(Dr(t4.parseResult), c3, true));
      };
    });
  });
  function kr(e3, t3, r3, n3) {
    if (!t3.exp) return void r3.onError(Te(31, t3.loc));
    const s3 = t3.forParseResult;
    if (!s3) return void r3.onError(Te(32, t3.loc));
    Nr(s3, r3);
    const { addIdentifiers: i3, removeIdentifiers: o3, scopes: a3 } = r3, { source: l2, value: c2, key: u2, index: p2 } = s3, d2 = { type: 11, loc: t3.loc, source: l2, valueAlias: c2, keyAlias: u2, objectIndexAlias: p2, parseResult: s3, children: tt(e3) ? e3.children : [e3] };
    r3.replaceNode(d2), a3.vFor++, r3.prefixIdentifiers && (c2 && i3(c2), u2 && i3(u2), p2 && i3(p2));
    const f2 = n3 && n3(d2);
    return () => {
      a3.vFor--, r3.prefixIdentifiers && (c2 && o3(c2), u2 && o3(u2), p2 && o3(p2)), f2 && f2();
    };
  }
  function Nr(e3, t3) {
    e3.finalized || (t3.prefixIdentifiers && (e3.source = Sr(e3.source, t3), e3.key && (e3.key = Sr(e3.key, t3, true)), e3.index && (e3.index = Sr(e3.index, t3, true)), e3.value && (e3.value = Sr(e3.value, t3, true))), e3.finalized = true);
  }
  function Dr(e3) {
    let { value: t3, key: r3, index: n3 } = e3;
    return function(e4) {
      let t4 = e4.length;
      for (; t4-- && !e4[t4]; ) ;
      return e4.slice(0, t4 + 1).map((e5, t5) => e5 || ee("_".repeat(t5 + 1), false));
    }([t3, r3, n3, ...arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []]);
  }
  const jr = ee("undefined", false), Lr = (e3, t3) => {
    if (1 === e3.type && (1 === e3.tagType || 3 === e3.tagType)) {
      const r3 = Je(e3, "slot");
      if (r3) {
        const e4 = r3.exp;
        return t3.prefixIdentifiers && e4 && t3.addIdentifiers(e4), t3.scopes.vSlot++, () => {
          t3.prefixIdentifiers && e4 && t3.removeIdentifiers(e4), t3.scopes.vSlot--;
        };
      }
    }
  }, Mr = (e3, t3) => {
    let r3;
    if (tt(e3) && e3.props.some(et) && (r3 = Je(e3, "for"))) {
      const e4 = r3.forParseResult;
      if (e4) {
        Nr(e4, t3);
        const { value: r4, key: n3, index: s3 } = e4, { addIdentifiers: i3, removeIdentifiers: o3 } = t3;
        return r4 && i3(r4), n3 && i3(n3), s3 && i3(s3), () => {
          r4 && o3(r4), n3 && o3(n3), s3 && o3(s3);
        };
      }
    }
  }, Br = (e3, t3, r3, n3) => ne(e3, r3, false, true, r3.length ? r3[0].loc : n3);
  function Rr(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Br;
    t3.helper(V);
    const { children: n3, loc: s3 } = e3, i3 = [], o3 = [];
    let a3 = t3.scopes.vSlot > 0 || t3.scopes.vFor > 0;
    !t3.ssr && t3.prefixIdentifiers && (a3 = lt(e3, t3.identifiers));
    const l2 = Je(e3, "slot", true);
    if (l2) {
      const { arg: e4, exp: t4 } = l2;
      e4 && !Fe(e4) && (a3 = true), i3.push(Z(e4 || ee("default", true), r3(t4, void 0, n3, s3)));
    }
    let c2 = false, u2 = false;
    const p2 = [], d2 = /* @__PURE__ */ new Set();
    let f2 = 0;
    for (let e4 = 0; e4 < n3.length; e4++) {
      const s4 = n3[e4];
      let h3;
      if (!tt(s4) || !(h3 = Je(s4, "slot", true))) {
        3 !== s4.type && p2.push(s4);
        continue;
      }
      if (l2) {
        t3.onError(Te(37, h3.loc));
        break;
      }
      c2 = true;
      const { children: m3, loc: y2 } = s4, { arg: g2 = ee("default", true), exp: b2, loc: v2 } = h3;
      let E2;
      Fe(g2) ? E2 = g2 ? g2.content : "default" : a3 = true;
      const S2 = Je(s4, "for"), x2 = r3(b2, S2, m3, y2);
      let T2, w2;
      if (T2 = Je(s4, "if")) a3 = true, o3.push(se(T2.exp, Fr(g2, x2, f2++), jr));
      else if (w2 = Je(s4, /^else(-if)?$/, true)) {
        let r4, s5 = e4;
        for (; s5-- && (r4 = n3[s5], 3 === r4.type); ) ;
        if (r4 && tt(r4) && Je(r4, "if")) {
          n3.splice(e4, 1), e4--;
          let t4 = o3[o3.length - 1];
          for (; 19 === t4.alternate.type; ) t4 = t4.alternate;
          t4.alternate = w2.exp ? se(w2.exp, Fr(g2, x2, f2++), jr) : Fr(g2, x2, f2++);
        } else t3.onError(Te(30, w2.loc));
      } else if (S2) {
        a3 = true;
        const e5 = S2.forParseResult;
        e5 ? (Nr(e5, t3), o3.push(re(t3.helper(A), [e5.source, ne(Dr(e5), Fr(g2, x2), true)]))) : t3.onError(Te(32, S2.loc));
      } else {
        if (E2) {
          if (d2.has(E2)) {
            t3.onError(Te(38, v2));
            continue;
          }
          d2.add(E2), "default" === E2 && (u2 = true);
        }
        i3.push(Z(g2, x2));
      }
    }
    if (!l2) {
      const e4 = (e5, n4) => {
        const i4 = r3(e5, void 0, n4, s3);
        return t3.compatConfig && (i4.isNonScopedSlot = true), Z("default", i4);
      };
      c2 ? p2.length && p2.some((e5) => $r(e5)) && (u2 ? t3.onError(Te(39, p2[0].loc)) : i3.push(e4(void 0, p2))) : i3.push(e4(void 0, n3));
    }
    const h2 = a3 ? 2 : Ur(e3.children) ? 3 : 1;
    let m2 = Q(i3.concat(Z("_", ee(h2 + "", false))), s3);
    return o3.length && (m2 = re(t3.helper(O), [m2, Y(o3)])), { slots: m2, hasDynamicSlots: a3 };
  }
  function Fr(e3, t3, r3) {
    const n3 = [Z("name", e3), Z("fn", t3)];
    return null != r3 && n3.push(Z("key", ee(String(r3), true))), Q(n3);
  }
  function Ur(e3) {
    for (let t3 = 0; t3 < e3.length; t3++) {
      const r3 = e3[t3];
      switch (r3.type) {
        case 1:
          if (2 === r3.tagType || Ur(r3.children)) return true;
          break;
        case 9:
          if (Ur(r3.branches)) return true;
          break;
        case 10:
        case 11:
          if (Ur(r3.children)) return true;
      }
    }
    return false;
  }
  function $r(e3) {
    return 2 !== e3.type && 12 !== e3.type || (2 === e3.type ? !!e3.content.trim() : $r(e3.content));
  }
  const Vr = /* @__PURE__ */ new WeakMap(), qr = (e3, t3) => function() {
    if (1 !== (e3 = t3.currentNode).type || 0 !== e3.tagType && 1 !== e3.tagType) return;
    const { tag: r3, props: s3 } = e3, i3 = 1 === e3.tagType;
    let o3 = i3 ? Wr(e3, t3) : `"${r3}"`;
    const a3 = n2.isObject(o3) && o3.callee === x;
    let l2, d2, f2, h2, m2, y2, g2 = 0, b2 = a3 || o3 === c || o3 === u || !i3 && ("svg" === r3 || "foreignObject" === r3);
    if (s3.length > 0) {
      const r4 = Hr(e3, t3, void 0, i3, a3);
      l2 = r4.props, g2 = r4.patchFlag, m2 = r4.dynamicPropNames;
      const n3 = r4.directives;
      y2 = n3 && n3.length ? Y(n3.map((e4) => Xr(e4, t3))) : void 0, r4.shouldUseBlock && (b2 = true);
    }
    if (e3.children.length > 0) if (o3 === p && (b2 = true, g2 |= 1024), i3 && o3 !== c && o3 !== p) {
      const { slots: r4, hasDynamicSlots: n3 } = Rr(e3, t3);
      d2 = r4, n3 && (g2 |= 1024);
    } else if (1 === e3.children.length && o3 !== c) {
      const r4 = e3.children[0], n3 = r4.type, s4 = 5 === n3 || 8 === n3;
      s4 && 0 === Xt(r4, t3) && (g2 |= 1), d2 = s4 || 2 === n3 ? r4 : e3.children;
    } else d2 = e3.children;
    0 !== g2 && (f2 = String(g2), m2 && m2.length && (h2 = function(e4) {
      let t4 = "[";
      for (let r4 = 0, n3 = e4.length; r4 < n3; r4++) t4 += JSON.stringify(e4[r4]), r4 < n3 - 1 && (t4 += ", ");
      return t4 + "]";
    }(m2))), e3.codegenNode = J(t3, o3, l2, d2, f2, h2, y2, !!b2, false, i3, e3.loc);
  };
  function Wr(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], { tag: s3 } = e3;
    const i3 = Jr(s3), o3 = Ye(e3, "is");
    if (o3) if (i3 || ve("COMPILER_IS_ON_ELEMENT", t3)) {
      const e4 = 6 === o3.type ? o3.value && ee(o3.value.content, true) : o3.exp;
      if (e4) return re(t3.helper(x), [e4]);
    } else 6 === o3.type && o3.value.content.startsWith("vue:") && (s3 = o3.value.content.slice(4));
    const a3 = Ue(s3) || t3.isBuiltInComponent(s3);
    if (a3) return r3 || t3.helper(a3), a3;
    {
      const e4 = Gr(s3, t3);
      if (e4) return e4;
      const r4 = s3.indexOf(".");
      if (r4 > 0) {
        const e5 = Gr(s3.slice(0, r4), t3);
        if (e5) return e5 + s3.slice(r4);
      }
    }
    return t3.selfName && n2.capitalize(n2.camelize(s3)) === t3.selfName ? (t3.helper(S), t3.components.add(s3 + "__self"), at(s3, "component")) : (t3.helper(S), t3.components.add(s3), at(s3, "component"));
  }
  function Gr(e3, t3) {
    const r3 = t3.bindingMetadata;
    if (!r3 || false === r3.__isScriptSetup) return;
    const s3 = n2.camelize(e3), i3 = n2.capitalize(s3), o3 = (t4) => r3[e3] === t4 ? e3 : r3[s3] === t4 ? s3 : r3[i3] === t4 ? i3 : void 0, a3 = o3("setup-const") || o3("setup-reactive-const") || o3("literal-const");
    if (a3) return t3.inline ? a3 : `$setup[${JSON.stringify(a3)}]`;
    const l2 = o3("setup-let") || o3("setup-ref") || o3("setup-maybe-ref");
    if (l2) return t3.inline ? `${t3.helperString(q)}(${l2})` : `$setup[${JSON.stringify(l2)}]`;
    const c2 = o3("props");
    return c2 ? `${t3.helperString(q)}(${t3.inline ? "__props" : "$props"}[${JSON.stringify(c2)}])` : void 0;
  }
  function Hr(e3, t3) {
    let r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e3.props, s3 = arguments.length > 3 ? arguments[3] : void 0, i3 = arguments.length > 4 ? arguments[4] : void 0, o3 = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
    const { tag: a3, loc: l2, children: c2 } = e3;
    let u2 = [];
    const p2 = [], d2 = [], f2 = c2.length > 0;
    let h2 = false, m2 = 0, y2 = false, g2 = false, b2 = false, v2 = false, E2 = false, S2 = false;
    const x2 = [], T2 = (e4) => {
      u2.length && (p2.push(Q(zr(u2), l2)), u2 = []), e4 && p2.push(e4);
    }, w2 = (e4) => {
      let { key: r4, value: o4 } = e4;
      if (Fe(r4)) {
        const e5 = r4.content, a4 = n2.isOn(e5);
        if (!a4 || s3 && !i3 || "onclick" === e5.toLowerCase() || "onUpdate:modelValue" === e5 || n2.isReservedProp(e5) || (v2 = true), a4 && n2.isReservedProp(e5) && (S2 = true), a4 && 14 === o4.type && (o4 = o4.arguments[0]), 20 === o4.type || (4 === o4.type || 8 === o4.type) && Xt(o4, t3) > 0) return;
        "ref" === e5 ? y2 = true : "class" === e5 ? g2 = true : "style" === e5 ? b2 = true : "key" === e5 || x2.includes(e5) || x2.push(e5), !s3 || "class" !== e5 && "style" !== e5 || x2.includes(e5) || x2.push(e5);
      } else E2 = true;
    };
    for (let i4 = 0; i4 < r3.length; i4++) {
      const c3 = r3[i4];
      if (6 === c3.type) {
        const { loc: e4, name: r4, nameLoc: n3, value: s4 } = c3;
        let i5 = true;
        if ("ref" === r4 && (y2 = true, t3.scopes.vFor > 0 && u2.push(Z(ee("ref_for", true), ee("true"))), s4 && t3.inline)) {
          const e5 = t3.bindingMetadata[s4.content];
          "setup-let" !== e5 && "setup-ref" !== e5 && "setup-maybe-ref" !== e5 || (i5 = false, u2.push(Z(ee("ref_key", true), ee(s4.content, true, s4.loc))));
        }
        if ("is" === r4 && (Jr(a3) || s4 && s4.content.startsWith("vue:") || ve("COMPILER_IS_ON_ELEMENT", t3))) continue;
        u2.push(Z(ee(r4, true, n3), ee(s4 ? s4.content : "", i5, s4 ? s4.loc : e4)));
      } else {
        const { name: r4, arg: i5, exp: y3, loc: g3, modifiers: b3 } = c3, v3 = "bind" === r4, S3 = "on" === r4;
        if ("slot" === r4) {
          s3 || t3.onError(Te(40, g3));
          continue;
        }
        if ("once" === r4 || "memo" === r4) continue;
        if ("is" === r4 || v3 && Qe(i5, "is") && (Jr(a3) || ve("COMPILER_IS_ON_ELEMENT", t3))) continue;
        if (S3 && o3) continue;
        if ((v3 && Qe(i5, "key") || S3 && f2 && Qe(i5, "vue:before-update")) && (h2 = true), v3 && Qe(i5, "ref") && t3.scopes.vFor > 0 && u2.push(Z(ee("ref_for", true), ee("true"))), !i5 && (v3 || S3)) {
          if (E2 = true, y3) if (v3) {
            if (T2(), ve("COMPILER_V_BIND_OBJECT_ORDER", t3)) {
              p2.unshift(y3);
              continue;
            }
            p2.push(y3);
          } else T2({ type: 14, loc: g3, callee: t3.helper(L), arguments: s3 ? [y3] : [y3, "true"] });
          else t3.onError(Te(v3 ? 34 : 35, g3));
          continue;
        }
        v3 && b3.includes("prop") && (m2 |= 32);
        const x3 = t3.directiveTransforms[r4];
        if (x3) {
          const { props: r5, needRuntime: s4 } = x3(c3, e3, t3);
          !o3 && r5.forEach(w2), S3 && i5 && !Fe(i5) ? T2(Q(r5, l2)) : u2.push(...r5), s4 && (d2.push(c3), n2.isSymbol(s4) && Vr.set(c3, s4));
        } else n2.isBuiltInDirective(r4) || (d2.push(c3), f2 && (h2 = true));
      }
    }
    let P2;
    if (p2.length ? (T2(), P2 = p2.length > 1 ? re(t3.helper(_), p2, l2) : p2[0]) : u2.length && (P2 = Q(zr(u2), l2)), E2 ? m2 |= 16 : (g2 && !s3 && (m2 |= 2), b2 && !s3 && (m2 |= 4), x2.length && (m2 |= 8), v2 && (m2 |= 32)), h2 || 0 !== m2 && 32 !== m2 || !(y2 || S2 || d2.length > 0) || (m2 |= 512), !t3.inSSR && P2) switch (P2.type) {
      case 15:
        let e4 = -1, r4 = -1, n3 = false;
        for (let t4 = 0; t4 < P2.properties.length; t4++) {
          const s5 = P2.properties[t4].key;
          Fe(s5) ? "class" === s5.content ? e4 = t4 : "style" === s5.content && (r4 = t4) : s5.isHandlerKey || (n3 = true);
        }
        const s4 = P2.properties[e4], i4 = P2.properties[r4];
        n3 ? P2 = re(t3.helper(D), [P2]) : (s4 && !Fe(s4.value) && (s4.value = re(t3.helper(k), [s4.value])), i4 && (b2 || 4 === i4.value.type && "[" === i4.value.content.trim()[0] || 17 === i4.value.type) && (i4.value = re(t3.helper(N), [i4.value])));
        break;
      case 14:
        break;
      default:
        P2 = re(t3.helper(D), [re(t3.helper(j), [P2])]);
    }
    return { props: P2, directives: d2, patchFlag: m2, dynamicPropNames: x2, shouldUseBlock: h2 };
  }
  function zr(e3) {
    const t3 = /* @__PURE__ */ new Map(), r3 = [];
    for (let s3 = 0; s3 < e3.length; s3++) {
      const i3 = e3[s3];
      if (8 === i3.key.type || !i3.key.isStatic) {
        r3.push(i3);
        continue;
      }
      const o3 = i3.key.content, a3 = t3.get(o3);
      a3 ? ("style" === o3 || "class" === o3 || n2.isOn(o3)) && Kr(a3, i3) : (t3.set(o3, i3), r3.push(i3));
    }
    return r3;
  }
  function Kr(e3, t3) {
    17 === e3.value.type ? e3.value.elements.push(t3.value) : e3.value = Y([e3.value, t3.value], e3.loc);
  }
  function Xr(e3, t3) {
    const r3 = [], n3 = Vr.get(e3);
    if (n3) r3.push(t3.helperString(n3));
    else {
      const n4 = Gr("v-" + e3.name, t3);
      n4 ? r3.push(n4) : (t3.helper(T), t3.directives.add(e3.name), r3.push(at(e3.name, "directive")));
    }
    const { loc: s3 } = e3;
    if (e3.exp && r3.push(e3.exp), e3.arg && (e3.exp || r3.push("void 0"), r3.push(e3.arg)), Object.keys(e3.modifiers).length) {
      e3.arg || (e3.exp || r3.push("void 0"), r3.push("void 0"));
      const t4 = ee("true", false, s3);
      r3.push(Q(e3.modifiers.map((e4) => Z(e4, t4)), s3));
    }
    return Y(r3, e3.loc);
  }
  function Jr(e3) {
    return "component" === e3 || "Component" === e3;
  }
  const Yr = (e3, t3) => {
    if (rt(e3)) {
      const { children: r3, loc: n3 } = e3, { slotName: s3, slotProps: i3 } = Qr(e3, t3), o3 = [t3.prefixIdentifiers ? "_ctx.$slots" : "$slots", s3, "{}", "undefined", "true"];
      let a3 = 2;
      i3 && (o3[2] = i3, a3 = 3), r3.length && (o3[3] = ne([], r3, false, false, n3), a3 = 4), t3.scopeId && !t3.slotted && (a3 = 5), o3.splice(a3), e3.codegenNode = re(t3.helper(C), o3, n3);
    }
  };
  function Qr(e3, t3) {
    let r3, s3 = '"default"';
    const i3 = [];
    for (let t4 = 0; t4 < e3.props.length; t4++) {
      const r4 = e3.props[t4];
      6 === r4.type ? r4.value && ("name" === r4.name ? s3 = JSON.stringify(r4.value.content) : (r4.name = n2.camelize(r4.name), i3.push(r4))) : "bind" === r4.name && Qe(r4.arg, "name") ? r4.exp && (s3 = r4.exp) : ("bind" === r4.name && r4.arg && Fe(r4.arg) && (r4.arg.content = n2.camelize(r4.arg.content)), i3.push(r4));
    }
    if (i3.length > 0) {
      const { props: n3, directives: s4 } = Hr(e3, t3, i3, false, false);
      r3 = n3, s4.length && t3.onError(Te(36, s4[0].loc));
    }
    return { slotName: s3, slotProps: r3 };
  }
  const Zr = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/, en = (e3, t3, r3, s3) => {
    const { loc: i3, modifiers: o3, arg: a3 } = e3;
    let l2;
    if (e3.exp || o3.length || r3.onError(Te(35, i3)), 4 === a3.type) if (a3.isStatic) {
      let e4 = a3.content;
      e4.startsWith("vue:") && (e4 = `vnode-${e4.slice(4)}`), l2 = ee(0 !== t3.tagType || e4.startsWith("vnode") || !/[A-Z]/.test(e4) ? n2.toHandlerKey(n2.camelize(e4)) : `on:${e4}`, true, a3.loc);
    } else l2 = te([`${r3.helperString(R)}(`, a3, ")"]);
    else l2 = a3, l2.children.unshift(`${r3.helperString(R)}(`), l2.children.push(")");
    let c2 = e3.exp;
    c2 && !c2.content.trim() && (c2 = void 0);
    let u2 = r3.cacheHandlers && !c2 && !r3.inVOnce;
    if (c2) {
      const n3 = ze(c2.content, r3), s4 = !(n3 || Zr.test(c2.content)), i4 = c2.content.includes(";");
      r3.prefixIdentifiers && (s4 && r3.addIdentifiers("$event"), c2 = e3.exp = Sr(c2, r3, false, i4), s4 && r3.removeIdentifiers("$event"), u2 = r3.cacheHandlers && !r3.inVOnce && !(4 === c2.type && c2.constType > 0) && !(n3 && 1 === t3.tagType) && !lt(c2, r3.identifiers), u2 && n3 && (4 === c2.type ? c2.content = `${c2.content} && ${c2.content}(...args)` : c2.children = [...c2.children, " && ", ...c2.children, "(...args)"])), (s4 || u2 && n3) && (c2 = te([`${s4 ? r3.isTS ? "($event: any)" : "$event" : (r3.isTS ? "\n//@ts-ignore\n" : "") + "(...args)"} => ${i4 ? "{" : "("}`, c2, i4 ? "}" : ")"]));
    }
    let p2 = { props: [Z(l2, c2 || ee("() => {}", false, i3))] };
    return s3 && (p2 = s3(p2)), u2 && (p2.props[0].value = r3.cache(p2.props[0].value)), p2.props.forEach((e4) => e4.key.isHandlerKey = true), p2;
  }, tn = (e3, t3, r3) => {
    const { modifiers: s3, loc: i3 } = e3, o3 = e3.arg;
    let { exp: a3 } = e3;
    if (!a3 && 4 === o3.type) {
      const t4 = n2.camelize(o3.content);
      a3 = e3.exp = ee(t4, false, o3.loc), a3 = e3.exp = Sr(a3, r3);
    }
    return 4 !== o3.type ? (o3.children.unshift("("), o3.children.push(') || ""')) : o3.isStatic || (o3.content = `${o3.content} || ""`), s3.includes("camel") && (4 === o3.type ? o3.isStatic ? o3.content = n2.camelize(o3.content) : o3.content = `${r3.helperString(M)}(${o3.content})` : (o3.children.unshift(`${r3.helperString(M)}(`), o3.children.push(")"))), r3.inSSR || (s3.includes("prop") && rn(o3, "."), s3.includes("attr") && rn(o3, "^")), !a3 || 4 === a3.type && !a3.content.trim() ? (r3.onError(Te(34, i3)), { props: [Z(o3, ee("", true, i3))] }) : { props: [Z(o3, a3)] };
  }, rn = (e3, t3) => {
    4 === e3.type ? e3.isStatic ? e3.content = t3 + e3.content : e3.content = `\`${t3}\${${e3.content}}\`` : (e3.children.unshift(`'${t3}' + (`), e3.children.push(")"));
  }, nn = (e3, t3) => {
    if (0 === e3.type || 1 === e3.type || 11 === e3.type || 10 === e3.type) return () => {
      const r3 = e3.children;
      let n3, s3 = false;
      for (let e4 = 0; e4 < r3.length; e4++) {
        const t4 = r3[e4];
        if (Ze(t4)) {
          s3 = true;
          for (let s4 = e4 + 1; s4 < r3.length; s4++) {
            const i3 = r3[s4];
            if (!Ze(i3)) {
              n3 = void 0;
              break;
            }
            n3 || (n3 = r3[e4] = te([t4], t4.loc)), n3.children.push(" + ", i3), r3.splice(s4, 1), s4--;
          }
        }
      }
      if (s3 && (1 !== r3.length || 0 !== e3.type && (1 !== e3.type || 0 !== e3.tagType || e3.props.find((e4) => 7 === e4.type && !t3.directiveTransforms[e4.name]) || "template" === e3.tag))) for (let e4 = 0; e4 < r3.length; e4++) {
        const n4 = r3[e4];
        if (Ze(n4) || 8 === n4.type) {
          const s4 = [];
          2 === n4.type && " " === n4.content || s4.push(n4), t3.ssr || 0 !== Xt(n4, t3) || s4.push("1"), r3[e4] = { type: 12, content: n4, loc: n4.loc, codegenNode: re(t3.helper(v), s4) };
        }
      }
    };
  }, sn = /* @__PURE__ */ new WeakSet(), on = (e3, t3) => {
    if (1 === e3.type && Je(e3, "once", true)) {
      if (sn.has(e3) || t3.inVOnce || t3.inSSR) return;
      return sn.add(e3), t3.inVOnce = true, t3.helper(F), () => {
        t3.inVOnce = false;
        const e4 = t3.currentNode;
        e4.codegenNode && (e4.codegenNode = t3.cache(e4.codegenNode, true));
      };
    }
  }, an = (e3, t3, r3) => {
    const { exp: s3, arg: i3 } = e3;
    if (!s3) return r3.onError(Te(41, e3.loc)), ln();
    const o3 = s3.loc.source, a3 = 4 === s3.type ? s3.content : o3, l2 = r3.bindingMetadata[o3];
    if ("props" === l2 || "props-aliased" === l2) return r3.onError(Te(44, s3.loc)), ln();
    const c2 = r3.inline && ("setup-let" === l2 || "setup-ref" === l2 || "setup-maybe-ref" === l2);
    if (!a3.trim() || !ze(a3, r3) && !c2) return r3.onError(Te(42, s3.loc)), ln();
    if (r3.prefixIdentifiers && Ve(a3) && r3.identifiers[a3]) return r3.onError(Te(43, s3.loc)), ln();
    const u2 = i3 || ee("modelValue", true), p2 = i3 ? Fe(i3) ? `onUpdate:${n2.camelize(i3.content)}` : te(['"onUpdate:" + ', i3]) : "onUpdate:modelValue";
    let d2;
    const f2 = r3.isTS ? "($event: any)" : "$event";
    if (c2) if ("setup-ref" === l2) d2 = te([`${f2} => ((`, ee(o3, false, s3.loc), ").value = $event)"]);
    else {
      const e4 = "setup-let" === l2 ? `${o3} = $event` : "null";
      d2 = te([`${f2} => (${r3.helperString(W)}(${o3}) ? (`, ee(o3, false, s3.loc), `).value = $event : ${e4})`]);
    }
    else d2 = te([`${f2} => ((`, s3, ") = $event)"]);
    const h2 = [Z(u2, e3.exp), Z(p2, d2)];
    if (r3.prefixIdentifiers && !r3.inVOnce && r3.cacheHandlers && !lt(s3, r3.identifiers) && (h2[1].value = r3.cache(h2[1].value)), e3.modifiers.length && 1 === t3.tagType) {
      const t4 = e3.modifiers.map((e4) => (Ve(e4) ? e4 : JSON.stringify(e4)) + ": true").join(", "), r4 = i3 ? Fe(i3) ? `${i3.content}Modifiers` : te([i3, ' + "Modifiers"']) : "modelModifiers";
      h2.push(Z(r4, ee(`{ ${t4} }`, false, e3.loc, 2)));
    }
    return ln(h2);
  };
  function ln() {
    return { props: arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [] };
  }
  const cn = /[\w).+\-_$\]]/, un = (e3, t3) => {
    ve("COMPILER_FILTERS", t3) && (5 === e3.type && pn(e3.content, t3), 1 === e3.type && e3.props.forEach((e4) => {
      7 === e4.type && "for" !== e4.name && e4.exp && pn(e4.exp, t3);
    }));
  };
  function pn(e3, t3) {
    if (4 === e3.type) dn(e3, t3);
    else for (let r3 = 0; r3 < e3.children.length; r3++) {
      const n3 = e3.children[r3];
      "object" == typeof n3 && (4 === n3.type ? dn(n3, t3) : 8 === n3.type ? pn(e3, t3) : 5 === n3.type && pn(n3.content, t3));
    }
  }
  function dn(e3, t3) {
    const r3 = e3.content;
    let n3, s3, i3, o3, a3 = false, l2 = false, c2 = false, u2 = false, p2 = 0, d2 = 0, f2 = 0, h2 = 0, m2 = [];
    for (i3 = 0; i3 < r3.length; i3++) if (s3 = n3, n3 = r3.charCodeAt(i3), a3) 39 === n3 && 92 !== s3 && (a3 = false);
    else if (l2) 34 === n3 && 92 !== s3 && (l2 = false);
    else if (c2) 96 === n3 && 92 !== s3 && (c2 = false);
    else if (u2) 47 === n3 && 92 !== s3 && (u2 = false);
    else if (124 !== n3 || 124 === r3.charCodeAt(i3 + 1) || 124 === r3.charCodeAt(i3 - 1) || p2 || d2 || f2) {
      switch (n3) {
        case 34:
          l2 = true;
          break;
        case 39:
          a3 = true;
          break;
        case 96:
          c2 = true;
          break;
        case 40:
          f2++;
          break;
        case 41:
          f2--;
          break;
        case 91:
          d2++;
          break;
        case 93:
          d2--;
          break;
        case 123:
          p2++;
          break;
        case 125:
          p2--;
      }
      if (47 === n3) {
        let e4, t4 = i3 - 1;
        for (; t4 >= 0 && (e4 = r3.charAt(t4), " " === e4); t4--) ;
        e4 && cn.test(e4) || (u2 = true);
      }
    } else void 0 === o3 ? (h2 = i3 + 1, o3 = r3.slice(0, i3).trim()) : y2();
    function y2() {
      m2.push(r3.slice(h2, i3).trim()), h2 = i3 + 1;
    }
    if (void 0 === o3 ? o3 = r3.slice(0, i3).trim() : 0 !== h2 && y2(), m2.length) {
      for (i3 = 0; i3 < m2.length; i3++) o3 = fn(o3, m2[i3], t3);
      e3.content = o3;
    }
  }
  function fn(e3, t3, r3) {
    r3.helper(w);
    const n3 = t3.indexOf("(");
    if (n3 < 0) return r3.filters.add(t3), `${at(t3, "filter")}(${e3})`;
    {
      const s3 = t3.slice(0, n3), i3 = t3.slice(n3 + 1);
      return r3.filters.add(s3), `${at(s3, "filter")}(${e3}${")" !== i3 ? "," + i3 : i3}`;
    }
  }
  const hn = /* @__PURE__ */ new WeakSet(), mn = (e3, t3) => {
    if (1 === e3.type) {
      const r3 = Je(e3, "memo");
      if (!r3 || hn.has(e3)) return;
      return hn.add(e3), () => {
        const n3 = e3.codegenNode || t3.currentNode.codegenNode;
        n3 && 13 === n3.type && (1 !== e3.tagType && ce(n3, t3), e3.codegenNode = re(t3.helper(G), [r3.exp, ne(void 0, n3), "_cache", String(t3.cached++)]));
      };
    }
  };
  function yn(e3) {
    return [[on, wr, mn, _r, un, ...e3 ? [Mr, Er] : [], Yr, qr, Lr, nn], { on: en, bind: tn, model: an }];
  }
  t2.generateCodeFrame = n2.generateCodeFrame, t2.BASE_TRANSITION = d, t2.BindingTypes = { DATA: "data", PROPS: "props", PROPS_ALIASED: "props-aliased", SETUP_LET: "setup-let", SETUP_CONST: "setup-const", SETUP_REACTIVE_CONST: "setup-reactive-const", SETUP_MAYBE_REF: "setup-maybe-ref", SETUP_REF: "setup-ref", OPTIONS: "options", LITERAL_CONST: "literal-const" }, t2.CAMELIZE = M, t2.CAPITALIZE = B, t2.CREATE_BLOCK = h, t2.CREATE_COMMENT = b, t2.CREATE_ELEMENT_BLOCK = m, t2.CREATE_ELEMENT_VNODE = g, t2.CREATE_SLOTS = O, t2.CREATE_STATIC = E, t2.CREATE_TEXT = v, t2.CREATE_VNODE = y, t2.CompilerDeprecationTypes = { COMPILER_IS_ON_ELEMENT: "COMPILER_IS_ON_ELEMENT", COMPILER_V_BIND_SYNC: "COMPILER_V_BIND_SYNC", COMPILER_V_BIND_OBJECT_ORDER: "COMPILER_V_BIND_OBJECT_ORDER", COMPILER_V_ON_NATIVE: "COMPILER_V_ON_NATIVE", COMPILER_V_IF_V_FOR_PRECEDENCE: "COMPILER_V_IF_V_FOR_PRECEDENCE", COMPILER_NATIVE_TEMPLATE: "COMPILER_NATIVE_TEMPLATE", COMPILER_INLINE_TEMPLATE: "COMPILER_INLINE_TEMPLATE", COMPILER_FILTERS: "COMPILER_FILTERS" }, t2.ConstantTypes = { NOT_CONSTANT: 0, 0: "NOT_CONSTANT", CAN_SKIP_PATCH: 1, 1: "CAN_SKIP_PATCH", CAN_HOIST: 2, 2: "CAN_HOIST", CAN_STRINGIFY: 3, 3: "CAN_STRINGIFY" }, t2.ElementTypes = { ELEMENT: 0, 0: "ELEMENT", COMPONENT: 1, 1: "COMPONENT", SLOT: 2, 2: "SLOT", TEMPLATE: 3, 3: "TEMPLATE" }, t2.ErrorCodes = { ABRUPT_CLOSING_OF_EMPTY_COMMENT: 0, 0: "ABRUPT_CLOSING_OF_EMPTY_COMMENT", CDATA_IN_HTML_CONTENT: 1, 1: "CDATA_IN_HTML_CONTENT", DUPLICATE_ATTRIBUTE: 2, 2: "DUPLICATE_ATTRIBUTE", END_TAG_WITH_ATTRIBUTES: 3, 3: "END_TAG_WITH_ATTRIBUTES", END_TAG_WITH_TRAILING_SOLIDUS: 4, 4: "END_TAG_WITH_TRAILING_SOLIDUS", EOF_BEFORE_TAG_NAME: 5, 5: "EOF_BEFORE_TAG_NAME", EOF_IN_CDATA: 6, 6: "EOF_IN_CDATA", EOF_IN_COMMENT: 7, 7: "EOF_IN_COMMENT", EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT: 8, 8: "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT", EOF_IN_TAG: 9, 9: "EOF_IN_TAG", INCORRECTLY_CLOSED_COMMENT: 10, 10: "INCORRECTLY_CLOSED_COMMENT", INCORRECTLY_OPENED_COMMENT: 11, 11: "INCORRECTLY_OPENED_COMMENT", INVALID_FIRST_CHARACTER_OF_TAG_NAME: 12, 12: "INVALID_FIRST_CHARACTER_OF_TAG_NAME", MISSING_ATTRIBUTE_VALUE: 13, 13: "MISSING_ATTRIBUTE_VALUE", MISSING_END_TAG_NAME: 14, 14: "MISSING_END_TAG_NAME", MISSING_WHITESPACE_BETWEEN_ATTRIBUTES: 15, 15: "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES", NESTED_COMMENT: 16, 16: "NESTED_COMMENT", UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME: 17, 17: "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME", UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE: 18, 18: "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE", UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME: 19, 19: "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME", UNEXPECTED_NULL_CHARACTER: 20, 20: "UNEXPECTED_NULL_CHARACTER", UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME: 21, 21: "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME", UNEXPECTED_SOLIDUS_IN_TAG: 22, 22: "UNEXPECTED_SOLIDUS_IN_TAG", X_INVALID_END_TAG: 23, 23: "X_INVALID_END_TAG", X_MISSING_END_TAG: 24, 24: "X_MISSING_END_TAG", X_MISSING_INTERPOLATION_END: 25, 25: "X_MISSING_INTERPOLATION_END", X_MISSING_DIRECTIVE_NAME: 26, 26: "X_MISSING_DIRECTIVE_NAME", X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END: 27, 27: "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END", X_V_IF_NO_EXPRESSION: 28, 28: "X_V_IF_NO_EXPRESSION", X_V_IF_SAME_KEY: 29, 29: "X_V_IF_SAME_KEY", X_V_ELSE_NO_ADJACENT_IF: 30, 30: "X_V_ELSE_NO_ADJACENT_IF", X_V_FOR_NO_EXPRESSION: 31, 31: "X_V_FOR_NO_EXPRESSION", X_V_FOR_MALFORMED_EXPRESSION: 32, 32: "X_V_FOR_MALFORMED_EXPRESSION", X_V_FOR_TEMPLATE_KEY_PLACEMENT: 33, 33: "X_V_FOR_TEMPLATE_KEY_PLACEMENT", X_V_BIND_NO_EXPRESSION: 34, 34: "X_V_BIND_NO_EXPRESSION", X_V_ON_NO_EXPRESSION: 35, 35: "X_V_ON_NO_EXPRESSION", X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET: 36, 36: "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET", X_V_SLOT_MIXED_SLOT_USAGE: 37, 37: "X_V_SLOT_MIXED_SLOT_USAGE", X_V_SLOT_DUPLICATE_SLOT_NAMES: 38, 38: "X_V_SLOT_DUPLICATE_SLOT_NAMES", X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN: 39, 39: "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN", X_V_SLOT_MISPLACED: 40, 40: "X_V_SLOT_MISPLACED", X_V_MODEL_NO_EXPRESSION: 41, 41: "X_V_MODEL_NO_EXPRESSION", X_V_MODEL_MALFORMED_EXPRESSION: 42, 42: "X_V_MODEL_MALFORMED_EXPRESSION", X_V_MODEL_ON_SCOPE_VARIABLE: 43, 43: "X_V_MODEL_ON_SCOPE_VARIABLE", X_V_MODEL_ON_PROPS: 44, 44: "X_V_MODEL_ON_PROPS", X_INVALID_EXPRESSION: 45, 45: "X_INVALID_EXPRESSION", X_KEEP_ALIVE_INVALID_CHILDREN: 46, 46: "X_KEEP_ALIVE_INVALID_CHILDREN", X_PREFIX_ID_NOT_SUPPORTED: 47, 47: "X_PREFIX_ID_NOT_SUPPORTED", X_MODULE_MODE_NOT_SUPPORTED: 48, 48: "X_MODULE_MODE_NOT_SUPPORTED", X_CACHE_HANDLER_NOT_SUPPORTED: 49, 49: "X_CACHE_HANDLER_NOT_SUPPORTED", X_SCOPE_ID_NOT_SUPPORTED: 50, 50: "X_SCOPE_ID_NOT_SUPPORTED", X_VNODE_HOOKS: 51, 51: "X_VNODE_HOOKS", __EXTEND_POINT__: 52, 52: "__EXTEND_POINT__" }, t2.FRAGMENT = l, t2.GUARD_REACTIVE_PROPS = j, t2.IS_MEMO_SAME = H, t2.IS_REF = W, t2.KEEP_ALIVE = p, t2.MERGE_PROPS = _, t2.NORMALIZE_CLASS = k, t2.NORMALIZE_PROPS = D, t2.NORMALIZE_STYLE = N, t2.Namespaces = { HTML: 0, 0: "HTML", SVG: 1, 1: "SVG", MATH_ML: 2, 2: "MATH_ML" }, t2.NodeTypes = { ROOT: 0, 0: "ROOT", ELEMENT: 1, 1: "ELEMENT", TEXT: 2, 2: "TEXT", COMMENT: 3, 3: "COMMENT", SIMPLE_EXPRESSION: 4, 4: "SIMPLE_EXPRESSION", INTERPOLATION: 5, 5: "INTERPOLATION", ATTRIBUTE: 6, 6: "ATTRIBUTE", DIRECTIVE: 7, 7: "DIRECTIVE", COMPOUND_EXPRESSION: 8, 8: "COMPOUND_EXPRESSION", IF: 9, 9: "IF", IF_BRANCH: 10, 10: "IF_BRANCH", FOR: 11, 11: "FOR", TEXT_CALL: 12, 12: "TEXT_CALL", VNODE_CALL: 13, 13: "VNODE_CALL", JS_CALL_EXPRESSION: 14, 14: "JS_CALL_EXPRESSION", JS_OBJECT_EXPRESSION: 15, 15: "JS_OBJECT_EXPRESSION", JS_PROPERTY: 16, 16: "JS_PROPERTY", JS_ARRAY_EXPRESSION: 17, 17: "JS_ARRAY_EXPRESSION", JS_FUNCTION_EXPRESSION: 18, 18: "JS_FUNCTION_EXPRESSION", JS_CONDITIONAL_EXPRESSION: 19, 19: "JS_CONDITIONAL_EXPRESSION", JS_CACHE_EXPRESSION: 20, 20: "JS_CACHE_EXPRESSION", JS_BLOCK_STATEMENT: 21, 21: "JS_BLOCK_STATEMENT", JS_TEMPLATE_LITERAL: 22, 22: "JS_TEMPLATE_LITERAL", JS_IF_STATEMENT: 23, 23: "JS_IF_STATEMENT", JS_ASSIGNMENT_EXPRESSION: 24, 24: "JS_ASSIGNMENT_EXPRESSION", JS_SEQUENCE_EXPRESSION: 25, 25: "JS_SEQUENCE_EXPRESSION", JS_RETURN_STATEMENT: 26, 26: "JS_RETURN_STATEMENT" }, t2.OPEN_BLOCK = f, t2.POP_SCOPE_ID = $, t2.PUSH_SCOPE_ID = U, t2.RENDER_LIST = A, t2.RENDER_SLOT = C, t2.RESOLVE_COMPONENT = S, t2.RESOLVE_DIRECTIVE = T, t2.RESOLVE_DYNAMIC_COMPONENT = x, t2.RESOLVE_FILTER = w, t2.SET_BLOCK_TRACKING = F, t2.SUSPENSE = u, t2.TELEPORT = c, t2.TO_DISPLAY_STRING = I, t2.TO_HANDLERS = L, t2.TO_HANDLER_KEY = R, t2.TS_NODE_TYPES = Be, t2.UNREF = q, t2.WITH_CTX = V, t2.WITH_DIRECTIVES = P, t2.WITH_MEMO = G, t2.advancePositionWithClone = Ke, t2.advancePositionWithMutation = Xe, t2.assert = function(e3, t3) {
    if (!e3) throw new Error(t3 || "unexpected compiler condition");
  }, t2.baseCompile = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const r3 = t3.onError || Se, s3 = "module" === t3.mode, i3 = true === t3.prefixIdentifiers || s3;
    !i3 && t3.cacheHandlers && r3(Te(49)), t3.scopeId && !s3 && r3(Te(50));
    const o3 = n2.extend({}, t3, { prefixIdentifiers: i3 }), a3 = n2.isString(e3) ? Gt(e3, o3) : e3, [l2, c2] = yn(i3);
    if (t3.isTS) {
      const { expressionPlugins: e4 } = t3;
      e4 && e4.includes("typescript") || (t3.expressionPlugins = [...e4 || [], "typescript"]);
    }
    return rr(a3, n2.extend({}, o3, { nodeTransforms: [...l2, ...t3.nodeTransforms || []], directiveTransforms: n2.extend({}, c2, t3.directiveTransforms || {}) })), lr(a3, o3);
  }, t2.baseParse = Gt, t2.buildDirectiveArgs = Xr, t2.buildProps = Hr, t2.buildSlots = Rr, t2.checkCompatEnabled = Ee, t2.convertToBlock = ce, t2.createArrayExpression = Y, t2.createAssignmentExpression = function(e3, t3) {
    return { type: 24, left: e3, right: t3, loc: K };
  }, t2.createBlockStatement = oe, t2.createCacheExpression = ie, t2.createCallExpression = re, t2.createCompilerError = Te, t2.createCompoundExpression = te, t2.createConditionalExpression = se, t2.createForLoopParams = Dr, t2.createFunctionExpression = ne, t2.createIfStatement = function(e3, t3, r3) {
    return { type: 23, test: e3, consequent: t3, alternate: r3, loc: K };
  }, t2.createInterpolation = function(e3, t3) {
    return { type: 5, loc: t3, content: n2.isString(e3) ? ee(e3, false, t3) : e3 };
  }, t2.createObjectExpression = Q, t2.createObjectProperty = Z, t2.createReturnStatement = function(e3) {
    return { type: 26, returns: e3, loc: K };
  }, t2.createRoot = X, t2.createSequenceExpression = function(e3) {
    return { type: 25, expressions: e3, loc: K };
  }, t2.createSimpleExpression = ee, t2.createStructuralDirectiveTransform = sr, t2.createTemplateLiteral = function(e3) {
    return { type: 22, elements: e3, loc: K };
  }, t2.createTransformContext = tr, t2.createVNodeCall = J, t2.errorMessages = we, t2.extractIdentifiers = ke, t2.findDir = Je, t2.findProp = Ye, t2.forAliasRE = ut, t2.generate = lr, t2.getBaseTransformPreset = yn, t2.getConstantType = Xt, t2.getMemoedVNodeCall = ct, t2.getVNodeBlockHelper = le, t2.getVNodeHelper = ae, t2.hasDynamicKeyVBind = function(e3) {
    return e3.props.some((e4) => !(7 !== e4.type || "bind" !== e4.name || e4.arg && 4 === e4.arg.type && e4.arg.isStatic));
  }, t2.hasScopeRef = lt, t2.helperNameMap = z, t2.injectProp = it, t2.isCoreComponent = Ue, t2.isFunctionType = je, t2.isInDestructureAssignment = Ce, t2.isInNewExpression = Oe, t2.isMemberExpression = ze, t2.isMemberExpressionBrowser = (e3) => {
    e3 = e3.trim().replace(Ge, (e4) => e4.trim());
    let t3 = 0, r3 = [], n3 = 0, s3 = 0, i3 = null;
    for (let o3 = 0; o3 < e3.length; o3++) {
      const a3 = e3.charAt(o3);
      switch (t3) {
        case 0:
          if ("[" === a3) r3.push(t3), t3 = 1, n3++;
          else if ("(" === a3) r3.push(t3), t3 = 2, s3++;
          else if (!(0 === o3 ? qe : We).test(a3)) return false;
          break;
        case 1:
          "'" === a3 || '"' === a3 || "`" === a3 ? (r3.push(t3), t3 = 3, i3 = a3) : "[" === a3 ? n3++ : "]" === a3 && (--n3 || (t3 = r3.pop()));
          break;
        case 2:
          if ("'" === a3 || '"' === a3 || "`" === a3) r3.push(t3), t3 = 3, i3 = a3;
          else if ("(" === a3) s3++;
          else if (")" === a3) {
            if (o3 === e3.length - 1) return false;
            --s3 || (t3 = r3.pop());
          }
          break;
        case 3:
          a3 === i3 && (t3 = r3.pop(), i3 = null);
      }
    }
    return !n3 && !s3;
  }, t2.isMemberExpressionNode = He, t2.isReferencedIdentifier = Ae, t2.isSimpleIdentifier = Ve, t2.isSlotOutlet = rt, t2.isStaticArgOf = Qe, t2.isStaticExp = Fe, t2.isStaticProperty = Le, t2.isStaticPropertyKey = Me, t2.isTemplateNode = tt, t2.isText = Ze, t2.isVSlot = et, t2.locStub = K, t2.noopDirectiveTransform = () => ({ props: [] }), t2.processExpression = Sr, t2.processFor = kr, t2.processIf = Pr, t2.processSlotOutlet = Qr, t2.registerRuntimeHelpers = function(e3) {
    Object.getOwnPropertySymbols(e3).forEach((t3) => {
      z[t3] = e3[t3];
    });
  }, t2.resolveComponentType = Wr, t2.stringifyExpression = xr, t2.toValidAssetId = at, t2.trackSlotScopes = Lr, t2.trackVForSlotScopes = Mr, t2.transform = rr, t2.transformBind = tn, t2.transformElement = qr, t2.transformExpression = Er, t2.transformModel = an, t2.transformOn = en, t2.traverseNode = nr, t2.unwrapTSNode = Re, t2.walkBlockDeclarations = _e, t2.walkFunctionParams = Ie, t2.walkIdentifiers = Pe, t2.warnDeprecation = function(e3, t3, r3) {
    if ("suppress-warning" === be(e3, t3)) return;
    const { message: n3, link: s3 } = ge[e3];
    for (var i3 = arguments.length, o3 = new Array(i3 > 3 ? i3 - 3 : 0), a3 = 3; a3 < i3; a3++) o3[a3 - 3] = arguments[a3];
    const l2 = `(deprecation ${e3}) ${"function" == typeof n3 ? n3(...o3) : n3}${s3 ? `
  Details: ${s3}` : ""}`, c2 = new SyntaxError(l2);
    c2.code = e3, r3 && (c2.loc = r3), t3.onWarn(c2);
  };
}, (e2, t2, r2) => {
  function n2(e3, t3) {
    const r3 = new Set(e3.split(","));
    return t3 ? (e4) => r3.has(e4.toLowerCase()) : (e4) => r3.has(e4);
  }
  Object.defineProperty(t2, "__esModule", { value: true });
  const s2 = Object.assign, i2 = Object.prototype.hasOwnProperty, o2 = Array.isArray, a2 = (e3) => "[object Map]" === m(e3), l = (e3) => "[object Set]" === m(e3), c = (e3) => "[object Date]" === m(e3), u = (e3) => "function" == typeof e3, p = (e3) => "string" == typeof e3, d = (e3) => "symbol" == typeof e3, f = (e3) => null !== e3 && "object" == typeof e3, h = Object.prototype.toString, m = (e3) => h.call(e3), y = (e3) => "[object Object]" === m(e3), g = n2(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), b = n2("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"), v = (e3) => {
    const t3 = /* @__PURE__ */ Object.create(null);
    return (r3) => t3[r3] || (t3[r3] = e3(r3));
  }, E = /-(\w)/g, S = v((e3) => e3.replace(E, (e4, t3) => t3 ? t3.toUpperCase() : "")), x = /\B([A-Z])/g, T = v((e3) => e3.replace(x, "-$1").toLowerCase()), w = v((e3) => e3.charAt(0).toUpperCase() + e3.slice(1)), P = v((e3) => e3 ? `on${w(e3)}` : "");
  let A;
  const C = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/, O = { 1: "TEXT", 2: "CLASS", 4: "STYLE", 8: "PROPS", 16: "FULL_PROPS", 32: "NEED_HYDRATION", 64: "STABLE_FRAGMENT", 128: "KEYED_FRAGMENT", 256: "UNKEYED_FRAGMENT", 512: "NEED_PATCH", 1024: "DYNAMIC_SLOTS", 2048: "DEV_ROOT_FRAGMENT", [-1]: "HOISTED", [-2]: "BAIL" }, I = n2("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error"), _ = I;
  function k(e3) {
    if (o2(e3)) {
      const t3 = {};
      for (let r3 = 0; r3 < e3.length; r3++) {
        const n3 = e3[r3], s3 = p(n3) ? L(n3) : k(n3);
        if (s3) for (const e4 in s3) t3[e4] = s3[e4];
      }
      return t3;
    }
    if (p(e3) || f(e3)) return e3;
  }
  const N = /;(?![^(]*\))/g, D = /:([^]+)/, j = /\/\*[^]*?\*\//g;
  function L(e3) {
    const t3 = {};
    return e3.replace(j, "").split(N).forEach((e4) => {
      if (e4) {
        const r3 = e4.split(D);
        r3.length > 1 && (t3[r3[0].trim()] = r3[1].trim());
      }
    }), t3;
  }
  function M(e3) {
    let t3 = "";
    if (p(e3)) t3 = e3;
    else if (o2(e3)) for (let r3 = 0; r3 < e3.length; r3++) {
      const n3 = M(e3[r3]);
      n3 && (t3 += n3 + " ");
    }
    else if (f(e3)) for (const r3 in e3) e3[r3] && (t3 += r3 + " ");
    return t3.trim();
  }
  const B = n2("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot"), R = n2("svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view"), F = n2("annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics"), U = n2("area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr"), $ = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", V = n2($), q = n2($ + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"), W = /[>/="'\u0009\u000a\u000c\u0020]/, G = {}, H = n2("accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"), z = n2("xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan"), K = /["'&<>]/, X = /^-?>|<!--|-->|--!>|<!-$/g;
  function J(e3, t3) {
    if (e3 === t3) return true;
    let r3 = c(e3), n3 = c(t3);
    if (r3 || n3) return !(!r3 || !n3) && e3.getTime() === t3.getTime();
    if (r3 = d(e3), n3 = d(t3), r3 || n3) return e3 === t3;
    if (r3 = o2(e3), n3 = o2(t3), r3 || n3) return !(!r3 || !n3) && function(e4, t4) {
      if (e4.length !== t4.length) return false;
      let r4 = true;
      for (let n4 = 0; r4 && n4 < e4.length; n4++) r4 = J(e4[n4], t4[n4]);
      return r4;
    }(e3, t3);
    if (r3 = f(e3), n3 = f(t3), r3 || n3) {
      if (!r3 || !n3) return false;
      if (Object.keys(e3).length !== Object.keys(t3).length) return false;
      for (const r4 in e3) {
        const n4 = e3.hasOwnProperty(r4), s3 = t3.hasOwnProperty(r4);
        if (n4 && !s3 || !n4 && s3 || !J(e3[r4], t3[r4])) return false;
      }
    }
    return String(e3) === String(t3);
  }
  const Y = (e3, t3) => t3 && t3.__v_isRef ? Y(e3, t3.value) : a2(t3) ? { [`Map(${t3.size})`]: [...t3.entries()].reduce((e4, t4, r3) => {
    let [n3, s3] = t4;
    return e4[Q(n3, r3) + " =>"] = s3, e4;
  }, {}) } : l(t3) ? { [`Set(${t3.size})`]: [...t3.values()].map((e4) => Q(e4)) } : d(t3) ? Q(t3) : !f(t3) || o2(t3) || y(t3) ? t3 : String(t3), Q = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    var r3;
    return d(e3) ? `Symbol(${null != (r3 = e3.description) ? r3 : t3})` : e3;
  };
  t2.EMPTY_ARR = [], t2.EMPTY_OBJ = {}, t2.NO = () => false, t2.NOOP = () => {
  }, t2.PatchFlagNames = O, t2.PatchFlags = { TEXT: 1, 1: "TEXT", CLASS: 2, 2: "CLASS", STYLE: 4, 4: "STYLE", PROPS: 8, 8: "PROPS", FULL_PROPS: 16, 16: "FULL_PROPS", NEED_HYDRATION: 32, 32: "NEED_HYDRATION", STABLE_FRAGMENT: 64, 64: "STABLE_FRAGMENT", KEYED_FRAGMENT: 128, 128: "KEYED_FRAGMENT", UNKEYED_FRAGMENT: 256, 256: "UNKEYED_FRAGMENT", NEED_PATCH: 512, 512: "NEED_PATCH", DYNAMIC_SLOTS: 1024, 1024: "DYNAMIC_SLOTS", DEV_ROOT_FRAGMENT: 2048, 2048: "DEV_ROOT_FRAGMENT", HOISTED: -1, "-1": "HOISTED", BAIL: -2, "-2": "BAIL" }, t2.ShapeFlags = { ELEMENT: 1, 1: "ELEMENT", FUNCTIONAL_COMPONENT: 2, 2: "FUNCTIONAL_COMPONENT", STATEFUL_COMPONENT: 4, 4: "STATEFUL_COMPONENT", TEXT_CHILDREN: 8, 8: "TEXT_CHILDREN", ARRAY_CHILDREN: 16, 16: "ARRAY_CHILDREN", SLOTS_CHILDREN: 32, 32: "SLOTS_CHILDREN", TELEPORT: 64, 64: "TELEPORT", SUSPENSE: 128, 128: "SUSPENSE", COMPONENT_SHOULD_KEEP_ALIVE: 256, 256: "COMPONENT_SHOULD_KEEP_ALIVE", COMPONENT_KEPT_ALIVE: 512, 512: "COMPONENT_KEPT_ALIVE", COMPONENT: 6, 6: "COMPONENT" }, t2.SlotFlags = { STABLE: 1, 1: "STABLE", DYNAMIC: 2, 2: "DYNAMIC", FORWARDED: 3, 3: "FORWARDED" }, t2.camelize = S, t2.capitalize = w, t2.def = (e3, t3, r3) => {
    Object.defineProperty(e3, t3, { configurable: true, enumerable: false, value: r3 });
  }, t2.escapeHtml = function(e3) {
    const t3 = "" + e3, r3 = K.exec(t3);
    if (!r3) return t3;
    let n3, s3, i3 = "", o3 = 0;
    for (s3 = r3.index; s3 < t3.length; s3++) {
      switch (t3.charCodeAt(s3)) {
        case 34:
          n3 = "&quot;";
          break;
        case 38:
          n3 = "&amp;";
          break;
        case 39:
          n3 = "&#39;";
          break;
        case 60:
          n3 = "&lt;";
          break;
        case 62:
          n3 = "&gt;";
          break;
        default:
          continue;
      }
      o3 !== s3 && (i3 += t3.slice(o3, s3)), o3 = s3 + 1, i3 += n3;
    }
    return o3 !== s3 ? i3 + t3.slice(o3, s3) : i3;
  }, t2.escapeHtmlComment = function(e3) {
    return e3.replace(X, "");
  }, t2.extend = s2, t2.genPropsAccessExp = function(e3) {
    return C.test(e3) ? `__props.${e3}` : `__props[${JSON.stringify(e3)}]`;
  }, t2.generateCodeFrame = function(e3) {
    let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e3.length, n3 = e3.split(/(\r?\n)/);
    const s3 = n3.filter((e4, t4) => t4 % 2 == 1);
    n3 = n3.filter((e4, t4) => t4 % 2 == 0);
    let i3 = 0;
    const o3 = [];
    for (let e4 = 0; e4 < n3.length; e4++) if (i3 += n3[e4].length + (s3[e4] && s3[e4].length || 0), i3 >= t3) {
      for (let a3 = e4 - 2; a3 <= e4 + 2 || r3 > i3; a3++) {
        if (a3 < 0 || a3 >= n3.length) continue;
        const l2 = a3 + 1;
        o3.push(`${l2}${" ".repeat(Math.max(3 - String(l2).length, 0))}|  ${n3[a3]}`);
        const c2 = n3[a3].length, u2 = s3[a3] && s3[a3].length || 0;
        if (a3 === e4) {
          const e5 = t3 - (i3 - (c2 + u2)), n4 = Math.max(1, r3 > i3 ? c2 - e5 : r3 - t3);
          o3.push("   |  " + " ".repeat(e5) + "^".repeat(n4));
        } else if (a3 > e4) {
          if (r3 > i3) {
            const e5 = Math.max(Math.min(r3 - i3, c2), 1);
            o3.push("   |  " + "^".repeat(e5));
          }
          i3 += c2 + u2;
        }
      }
      break;
    }
    return o3.join("\n");
  }, t2.getGlobalThis = () => A || (A = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== r2.g ? r2.g : {}), t2.hasChanged = (e3, t3) => !Object.is(e3, t3), t2.hasOwn = (e3, t3) => i2.call(e3, t3), t2.hyphenate = T, t2.includeBooleanAttr = function(e3) {
    return !!e3 || "" === e3;
  }, t2.invokeArrayFns = (e3, t3) => {
    for (let r3 = 0; r3 < e3.length; r3++) e3[r3](t3);
  }, t2.isArray = o2, t2.isBooleanAttr = q, t2.isBuiltInDirective = b, t2.isDate = c, t2.isFunction = u, t2.isGloballyAllowed = I, t2.isGloballyWhitelisted = _, t2.isHTMLTag = B, t2.isIntegerKey = (e3) => p(e3) && "NaN" !== e3 && "-" !== e3[0] && "" + parseInt(e3, 10) === e3, t2.isKnownHtmlAttr = H, t2.isKnownSvgAttr = z, t2.isMap = a2, t2.isMathMLTag = F, t2.isModelListener = (e3) => e3.startsWith("onUpdate:"), t2.isObject = f, t2.isOn = (e3) => 111 === e3.charCodeAt(0) && 110 === e3.charCodeAt(1) && (e3.charCodeAt(2) > 122 || e3.charCodeAt(2) < 97), t2.isPlainObject = y, t2.isPromise = (e3) => (f(e3) || u(e3)) && u(e3.then) && u(e3.catch), t2.isRegExp = (e3) => "[object RegExp]" === m(e3), t2.isRenderableAttrValue = function(e3) {
    if (null == e3) return false;
    const t3 = typeof e3;
    return "string" === t3 || "number" === t3 || "boolean" === t3;
  }, t2.isReservedProp = g, t2.isSSRSafeAttrName = function(e3) {
    if (G.hasOwnProperty(e3)) return G[e3];
    const t3 = W.test(e3);
    return G[e3] = !t3;
  }, t2.isSVGTag = R, t2.isSet = l, t2.isSpecialBooleanAttr = V, t2.isString = p, t2.isSymbol = d, t2.isVoidTag = U, t2.looseEqual = J, t2.looseIndexOf = function(e3, t3) {
    return e3.findIndex((e4) => J(e4, t3));
  }, t2.looseToNumber = (e3) => {
    const t3 = parseFloat(e3);
    return isNaN(t3) ? e3 : t3;
  }, t2.makeMap = n2, t2.normalizeClass = M, t2.normalizeProps = function(e3) {
    if (!e3) return null;
    let { class: t3, style: r3 } = e3;
    return t3 && !p(t3) && (e3.class = M(t3)), r3 && (e3.style = k(r3)), e3;
  }, t2.normalizeStyle = k, t2.objectToString = h, t2.parseStringStyle = L, t2.propsToAttrMap = { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv" }, t2.remove = (e3, t3) => {
    const r3 = e3.indexOf(t3);
    r3 > -1 && e3.splice(r3, 1);
  }, t2.slotFlagsText = { 1: "STABLE", 2: "DYNAMIC", 3: "FORWARDED" }, t2.stringifyStyle = function(e3) {
    let t3 = "";
    if (!e3 || p(e3)) return t3;
    for (const r3 in e3) {
      const n3 = e3[r3], s3 = r3.startsWith("--") ? r3 : T(r3);
      (p(n3) || "number" == typeof n3) && (t3 += `${s3}:${n3};`);
    }
    return t3;
  }, t2.toDisplayString = (e3) => p(e3) ? e3 : null == e3 ? "" : o2(e3) || f(e3) && (e3.toString === h || !u(e3.toString)) ? JSON.stringify(e3, Y, 2) : String(e3), t2.toHandlerKey = P, t2.toNumber = (e3) => {
    const t3 = p(e3) ? Number(e3) : NaN;
    return isNaN(t3) ? e3 : t3;
  }, t2.toRawType = (e3) => m(e3).slice(8, -1), t2.toTypeString = m;
}, (e2, t2, r2) => {
  r2(12), Object.defineProperty(t2, "__esModule", { value: true }), t2.default = new Uint16Array('<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(e3) {
    return e3.charCodeAt(0);
  }));
}, (e2, t2, r2) => {
  r2(12), Object.defineProperty(t2, "__esModule", { value: true }), t2.default = new Uint16Array("aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(e3) {
    return e3.charCodeAt(0);
  }));
}, () => {
}, () => {
}, (e2, t2, r2) => {
  var n2 = r2(157);
  function s2() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  var i2 = /^([a-z0-9.+-]+:)/i, o2 = /:[0-9]*$/, a2 = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, l = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]), c = ["'"].concat(l), u = ["%", "/", "?", ";", "#"].concat(c), p = ["/", "?", "#"], d = /^[+a-z0-9A-Z_-]{0,63}$/, f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, h = { javascript: true, "javascript:": true }, m = { javascript: true, "javascript:": true }, y = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, g = r2(310);
  function b(e3, t3, r3) {
    if (e3 && "object" == typeof e3 && e3 instanceof s2) return e3;
    var n3 = new s2();
    return n3.parse(e3, t3, r3), n3;
  }
  s2.prototype.parse = function(e3, t3, r3) {
    if ("string" != typeof e3) throw new TypeError("Parameter 'url' must be a string, not " + typeof e3);
    var s3 = e3.indexOf("?"), o3 = -1 !== s3 && s3 < e3.indexOf("#") ? "?" : "#", l2 = e3.split(o3);
    l2[0] = l2[0].replace(/\\/g, "/");
    var b2 = e3 = l2.join(o3);
    if (b2 = b2.trim(), !r3 && 1 === e3.split("#").length) {
      var v = a2.exec(b2);
      if (v) return this.path = b2, this.href = b2, this.pathname = v[1], v[2] ? (this.search = v[2], this.query = t3 ? g.parse(this.search.substr(1)) : this.search.substr(1)) : t3 && (this.search = "", this.query = {}), this;
    }
    var E = i2.exec(b2);
    if (E) {
      var S = (E = E[0]).toLowerCase();
      this.protocol = S, b2 = b2.substr(E.length);
    }
    if (r3 || E || b2.match(/^\/\/[^@/]+@[^@/]+/)) {
      var x = "//" === b2.substr(0, 2);
      !x || E && m[E] || (b2 = b2.substr(2), this.slashes = true);
    }
    if (!m[E] && (x || E && !y[E])) {
      for (var T, w, P = -1, A = 0; A < p.length; A++) -1 !== (C = b2.indexOf(p[A])) && (-1 === P || C < P) && (P = C);
      for (-1 !== (w = -1 === P ? b2.lastIndexOf("@") : b2.lastIndexOf("@", P)) && (T = b2.slice(0, w), b2 = b2.slice(w + 1), this.auth = decodeURIComponent(T)), P = -1, A = 0; A < u.length; A++) {
        var C;
        -1 !== (C = b2.indexOf(u[A])) && (-1 === P || C < P) && (P = C);
      }
      -1 === P && (P = b2.length), this.host = b2.slice(0, P), b2 = b2.slice(P), this.parseHost(), this.hostname = this.hostname || "";
      var O = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
      if (!O) for (var I = this.hostname.split(/\./), _ = (A = 0, I.length); A < _; A++) {
        var k = I[A];
        if (k && !k.match(d)) {
          for (var N = "", D = 0, j = k.length; D < j; D++) k.charCodeAt(D) > 127 ? N += "x" : N += k[D];
          if (!N.match(d)) {
            var L = I.slice(0, A), M = I.slice(A + 1), B = k.match(f);
            B && (L.push(B[1]), M.unshift(B[2])), M.length && (b2 = "/" + M.join(".") + b2), this.hostname = L.join(".");
            break;
          }
        }
      }
      this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), O || (this.hostname = n2.toASCII(this.hostname));
      var R = this.port ? ":" + this.port : "", F = this.hostname || "";
      this.host = F + R, this.href += this.host, O && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== b2[0] && (b2 = "/" + b2));
    }
    if (!h[S]) for (A = 0, _ = c.length; A < _; A++) {
      var U = c[A];
      if (-1 !== b2.indexOf(U)) {
        var $ = encodeURIComponent(U);
        $ === U && ($ = escape(U)), b2 = b2.split(U).join($);
      }
    }
    var V = b2.indexOf("#");
    -1 !== V && (this.hash = b2.substr(V), b2 = b2.slice(0, V));
    var q = b2.indexOf("?");
    if (-1 !== q ? (this.search = b2.substr(q), this.query = b2.substr(q + 1), t3 && (this.query = g.parse(this.query)), b2 = b2.slice(0, q)) : t3 && (this.search = "", this.query = {}), b2 && (this.pathname = b2), y[S] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
      R = this.pathname || "";
      var W = this.search || "";
      this.path = R + W;
    }
    return this.href = this.format(), this;
  }, s2.prototype.format = function() {
    var e3 = this.auth || "";
    e3 && (e3 = (e3 = encodeURIComponent(e3)).replace(/%3A/i, ":"), e3 += "@");
    var t3 = this.protocol || "", r3 = this.pathname || "", n3 = this.hash || "", s3 = false, i3 = "";
    this.host ? s3 = e3 + this.host : this.hostname && (s3 = e3 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (s3 += ":" + this.port)), this.query && "object" == typeof this.query && Object.keys(this.query).length && (i3 = g.stringify(this.query, { arrayFormat: "repeat", addQueryPrefix: false }));
    var o3 = this.search || i3 && "?" + i3 || "";
    return t3 && ":" !== t3.substr(-1) && (t3 += ":"), this.slashes || (!t3 || y[t3]) && false !== s3 ? (s3 = "//" + (s3 || ""), r3 && "/" !== r3.charAt(0) && (r3 = "/" + r3)) : s3 || (s3 = ""), n3 && "#" !== n3.charAt(0) && (n3 = "#" + n3), o3 && "?" !== o3.charAt(0) && (o3 = "?" + o3), t3 + s3 + (r3 = r3.replace(/[?#]/g, function(e4) {
      return encodeURIComponent(e4);
    })) + (o3 = o3.replace("#", "%23")) + n3;
  }, s2.prototype.resolve = function(e3) {
    return this.resolveObject(b(e3, false, true)).format();
  }, s2.prototype.resolveObject = function(e3) {
    if ("string" == typeof e3) {
      var t3 = new s2();
      t3.parse(e3, false, true), e3 = t3;
    }
    for (var r3 = new s2(), n3 = Object.keys(this), i3 = 0; i3 < n3.length; i3++) {
      var o3 = n3[i3];
      r3[o3] = this[o3];
    }
    if (r3.hash = e3.hash, "" === e3.href) return r3.href = r3.format(), r3;
    if (e3.slashes && !e3.protocol) {
      for (var a3 = Object.keys(e3), l2 = 0; l2 < a3.length; l2++) {
        var c2 = a3[l2];
        "protocol" !== c2 && (r3[c2] = e3[c2]);
      }
      return y[r3.protocol] && r3.hostname && !r3.pathname && (r3.pathname = "/", r3.path = r3.pathname), r3.href = r3.format(), r3;
    }
    if (e3.protocol && e3.protocol !== r3.protocol) {
      if (!y[e3.protocol]) {
        for (var u2 = Object.keys(e3), p2 = 0; p2 < u2.length; p2++) {
          var d2 = u2[p2];
          r3[d2] = e3[d2];
        }
        return r3.href = r3.format(), r3;
      }
      if (r3.protocol = e3.protocol, e3.host || m[e3.protocol]) r3.pathname = e3.pathname;
      else {
        for (var f2 = (e3.pathname || "").split("/"); f2.length && !(e3.host = f2.shift()); ) ;
        e3.host || (e3.host = ""), e3.hostname || (e3.hostname = ""), "" !== f2[0] && f2.unshift(""), f2.length < 2 && f2.unshift(""), r3.pathname = f2.join("/");
      }
      if (r3.search = e3.search, r3.query = e3.query, r3.host = e3.host || "", r3.auth = e3.auth, r3.hostname = e3.hostname || e3.host, r3.port = e3.port, r3.pathname || r3.search) {
        var h2 = r3.pathname || "", g2 = r3.search || "";
        r3.path = h2 + g2;
      }
      return r3.slashes = r3.slashes || e3.slashes, r3.href = r3.format(), r3;
    }
    var b2 = r3.pathname && "/" === r3.pathname.charAt(0), v = e3.host || e3.pathname && "/" === e3.pathname.charAt(0), E = v || b2 || r3.host && e3.pathname, S = E, x = r3.pathname && r3.pathname.split("/") || [], T = (f2 = e3.pathname && e3.pathname.split("/") || [], r3.protocol && !y[r3.protocol]);
    if (T && (r3.hostname = "", r3.port = null, r3.host && ("" === x[0] ? x[0] = r3.host : x.unshift(r3.host)), r3.host = "", e3.protocol && (e3.hostname = null, e3.port = null, e3.host && ("" === f2[0] ? f2[0] = e3.host : f2.unshift(e3.host)), e3.host = null), E = E && ("" === f2[0] || "" === x[0])), v) r3.host = e3.host || "" === e3.host ? e3.host : r3.host, r3.hostname = e3.hostname || "" === e3.hostname ? e3.hostname : r3.hostname, r3.search = e3.search, r3.query = e3.query, x = f2;
    else if (f2.length) x || (x = []), x.pop(), x = x.concat(f2), r3.search = e3.search, r3.query = e3.query;
    else if (null != e3.search) return T && (r3.host = x.shift(), r3.hostname = r3.host, (O = !!(r3.host && r3.host.indexOf("@") > 0) && r3.host.split("@")) && (r3.auth = O.shift(), r3.hostname = O.shift(), r3.host = r3.hostname)), r3.search = e3.search, r3.query = e3.query, null === r3.pathname && null === r3.search || (r3.path = (r3.pathname ? r3.pathname : "") + (r3.search ? r3.search : "")), r3.href = r3.format(), r3;
    if (!x.length) return r3.pathname = null, r3.search ? r3.path = "/" + r3.search : r3.path = null, r3.href = r3.format(), r3;
    for (var w = x.slice(-1)[0], P = (r3.host || e3.host || x.length > 1) && ("." === w || ".." === w) || "" === w, A = 0, C = x.length; C >= 0; C--) "." === (w = x[C]) ? x.splice(C, 1) : ".." === w ? (x.splice(C, 1), A++) : A && (x.splice(C, 1), A--);
    if (!E && !S) for (; A--; A) x.unshift("..");
    !E || "" === x[0] || x[0] && "/" === x[0].charAt(0) || x.unshift(""), P && "/" !== x.join("/").substr(-1) && x.push("");
    var O, I = "" === x[0] || x[0] && "/" === x[0].charAt(0);
    return T && (r3.hostname = I ? "" : x.length ? x.shift() : "", r3.host = r3.hostname, (O = !!(r3.host && r3.host.indexOf("@") > 0) && r3.host.split("@")) && (r3.auth = O.shift(), r3.hostname = O.shift(), r3.host = r3.hostname)), (E = E || r3.host && x.length) && !I && x.unshift(""), x.length > 0 ? r3.pathname = x.join("/") : (r3.pathname = null, r3.path = null), null === r3.pathname && null === r3.search || (r3.path = (r3.pathname ? r3.pathname : "") + (r3.search ? r3.search : "")), r3.auth = e3.auth || r3.auth, r3.slashes = r3.slashes || e3.slashes, r3.href = r3.format(), r3;
  }, s2.prototype.parseHost = function() {
    var e3 = this.host, t3 = o2.exec(e3);
    t3 && (":" !== (t3 = t3[0]) && (this.port = t3.substr(1)), e3 = e3.substr(0, e3.length - t3.length)), e3 && (this.hostname = e3);
  }, t2.parse = b, t2.resolve = function(e3, t3) {
    return b(e3, false, true).resolve(t3);
  }, t2.resolveObject = function(e3, t3) {
    return e3 ? b(e3, false, true).resolveObject(t3) : t3;
  }, t2.format = function(e3) {
    return "string" == typeof e3 && (e3 = b(e3)), e3 instanceof s2 ? e3.format() : s2.prototype.format.call(e3);
  }, t2.Url = s2;
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, () => {
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
  var n2 = r2(16);
  t2.default = (0, n2.declare)((e3) => (e3.assertVersion(7), { name: "syntax-jsx", manipulateOptions(e4, t3) {
    t3.plugins.some((e5) => "typescript" === (Array.isArray(e5) ? e5[0] : e5)) || t3.plugins.push("jsx");
  } }));
}, (e2, t2, r2) => {
  e2.exports = r2(559);
}, (e2) => {
  e2.exports = JSON.parse('["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","label","legend","li","link","main","map","mark","math","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rb","rp","rt","rtc","ruby","s","samp","script","search","section","select","slot","small","source","span","strong","style","sub","summary","sup","svg","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr"]');
}, (e2, t2, r2) => {
  e2.exports = r2(561);
}, (e2) => {
  e2.exports = JSON.parse('["a","altGlyph","altGlyphDef","altGlyphItem","animate","animateColor","animateMotion","animateTransform","circle","clipPath","color-profile","cursor","defs","desc","ellipse","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","filter","font","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignObject","g","glyph","glyphRef","hkern","image","line","linearGradient","marker","mask","metadata","missing-glyph","mpath","path","pattern","polygon","polyline","radialGradient","rect","script","set","stop","style","svg","switch","symbol","text","textPath","title","tref","tspan","use","view","vkern"]');
}, (e2, t2, r2) => {
  t2.a = void 0;
  var n2 = (0, r2(16).declare)((e3) => (e3.assertVersion(7), { name: "syntax-class-static-block", manipulateOptions(e4, t3) {
    t3.plugins.push("classStaticBlock");
  } }));
  t2.a = n2;
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, c) {
    const u = e3.get("params");
    if (u.every((e4) => e4.isIdentifier())) return false;
    const { node: p, scope: d } = e3, f = [], h = /* @__PURE__ */ new Set();
    for (const e4 of u) (0, s2.collectShadowedParamsNames)(e4, d, h);
    const m = { needsOuterBinding: false, scope: d };
    if (0 === h.size) {
      for (const e4 of u) if (e4.isIdentifier() || e4.traverse(s2.iifeVisitor, m), m.needsOuterBinding) break;
    }
    let y = null;
    for (let s3 = 0; s3 < u.length; s3++) {
      const h2 = u[s3];
      if (r3 && !r3(s3)) continue;
      const m2 = [];
      c && c(e3, h2, m2);
      const g2 = h2.isAssignmentPattern();
      if (g2 && (t3 || n2.types.isMethod(p, { kind: "set" }))) {
        const e4 = h2.get("left"), t4 = h2.get("right"), r4 = d.buildUndefinedNode();
        if (e4.isIdentifier()) f.push(o2({ ASSIGNMENT_IDENTIFIER: n2.types.cloneNode(e4.node), DEFAULT_VALUE: t4.node, UNDEFINED: r4 })), h2.replaceWith(e4.node);
        else if (e4.isObjectPattern() || e4.isArrayPattern()) {
          const s4 = d.generateUidIdentifier();
          f.push(a2({ ASSIGNMENT_IDENTIFIER: e4.node, DEFAULT_VALUE: t4.node, PARAMETER_NAME: n2.types.cloneNode(s4), UNDEFINED: r4 })), h2.replaceWith(s4);
        }
      } else if (g2) {
        null === y && (y = s3);
        const e4 = h2.get("left"), t4 = h2.get("right"), r4 = i2({ VARIABLE_NAME: e4.node, DEFAULT_VALUE: t4.node, ARGUMENT_KEY: n2.types.numericLiteral(s3) });
        f.push(r4);
      } else if (null !== y) {
        const e4 = l([h2.node, n2.types.numericLiteral(s3)]);
        f.push(e4);
      } else if (h2.isObjectPattern() || h2.isArrayPattern()) {
        const t4 = e3.scope.generateUidIdentifier("ref");
        t4.typeAnnotation = h2.node.typeAnnotation;
        const r4 = n2.types.variableDeclaration("let", [n2.types.variableDeclarator(h2.node, t4)]);
        f.push(r4), h2.replaceWith(n2.types.cloneNode(t4));
      }
      if (m2) for (const e4 of m2) f.push(e4);
    }
    null !== y && (p.params = p.params.slice(0, y)), e3.ensureBlock();
    const { async: g, generator: b } = p;
    if (b || m.needsOuterBinding || h.size > 0) {
      f.push((0, s2.buildScopeIIFE)(h, e3.node.body)), e3.set("body", n2.types.blockStatement(f));
      const t4 = e3.get("body.body"), r4 = t4[t4.length - 1].get("argument.callee");
      r4.arrowFunctionToExpression(), r4.node.generator = b, r4.node.async = g, p.generator = false, p.async = false, g && (e3.node.body = n2.template.statement.ast`{
        try {
          ${e3.node.body.body}
        } catch (e) {
          return Promise.reject(e);
        }
      }`);
    } else e3.get("body").unshiftContainer("body", f);
    return true;
  };
  var n2 = r2(1), s2 = r2(327);
  const i2 = n2.template.statement("\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n"), o2 = n2.template.statement("\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n"), a2 = n2.template.statement("\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n"), l = n2.template.statement("\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n");
}, (e2, t2, r2) => {
  Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
    const { node: t3, scope: r3 } = e3;
    if (!function(e4) {
      const t4 = e4.params.length;
      return t4 > 0 && n2.types.isRestElement(e4.params[t4 - 1]);
    }(t3)) return false;
    const o3 = e3.get(`params.${t3.params.length - 1}.argument`);
    if (!o3.isIdentifier()) {
      const t4 = /* @__PURE__ */ new Set();
      (0, s2.collectShadowedParamsNames)(o3, e3.scope, t4);
      let i3 = t4.size > 0;
      if (!i3) {
        const e4 = { needsOuterBinding: false, scope: r3 };
        o3.traverse(s2.iifeVisitor, e4), i3 = e4.needsOuterBinding;
      }
      i3 && (e3.ensureBlock(), e3.set("body", n2.types.blockStatement([(0, s2.buildScopeIIFE)(t4, e3.node.body)])));
    }
    let a3 = o3.node;
    if (t3.params.pop(), n2.types.isPattern(a3)) {
      const s3 = a3;
      a3 = r3.generateUidIdentifier("ref");
      const i3 = n2.types.variableDeclaration("let", [n2.types.variableDeclarator(s3, a3)]);
      e3.ensureBlock(), t3.body.body.unshift(i3);
    } else "arguments" === a3.name && r3.rename(a3.name);
    const l2 = n2.types.identifier("arguments"), c2 = function(e4) {
      let t4 = e4.params.length;
      return t4 > 0 && n2.types.isIdentifier(e4.params[0], { name: "this" }) && (t4 -= 1), t4;
    }(t3), f = { references: [], offset: c2, argumentsNode: l2, outerBinding: r3.getBindingIdentifier(a3.name), candidates: [], name: a3.name, deopted: false };
    if (e3.traverse(u, f), !f.deopted && !f.references.length) {
      for (const { path: e4, cause: t4 } of f.candidates) {
        const r4 = n2.types.cloneNode(l2);
        switch (t4) {
          case "indexGetter":
            p(e4, r4, f.offset);
            break;
          case "lengthGetter":
            d(e4, r4, f.offset);
            break;
          default:
            e4.replaceWith(r4);
        }
      }
      return true;
    }
    f.references.push(...f.candidates.map((e4) => {
      let { path: t4 } = e4;
      return t4;
    }));
    const h = n2.types.numericLiteral(c2), m = r3.generateUidIdentifier("key"), y = r3.generateUidIdentifier("len");
    let g, b;
    c2 ? (g = n2.types.binaryExpression("-", n2.types.cloneNode(m), n2.types.cloneNode(h)), b = n2.types.conditionalExpression(n2.types.binaryExpression(">", n2.types.cloneNode(y), n2.types.cloneNode(h)), n2.types.binaryExpression("-", n2.types.cloneNode(y), n2.types.cloneNode(h)), n2.types.numericLiteral(0))) : (g = n2.types.identifier(m.name), b = n2.types.identifier(y.name));
    const v = i2({ ARGUMENTS: l2, ARRAY_KEY: g, ARRAY_LEN: b, START: h, ARRAY: a3, KEY: m, LEN: y });
    if (f.deopted) t3.body.body.unshift(v);
    else {
      let t4 = e3.getEarliestCommonAncestorFrom(f.references).getStatementParent();
      t4.findParent((e4) => {
        if (!e4.isLoop()) return e4.isFunction();
        t4 = e4;
      }), t4.insertBefore(v);
    }
    return true;
  };
  var n2 = r2(1), s2 = r2(327);
  const i2 = n2.template.statement("\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n"), o2 = n2.template.expression("\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n"), a2 = n2.template.expression("\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n"), l = n2.template.expression("\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n");
  function c(e3, t3) {
    return e3.node.name === t3.name && e3.scope.bindingIdentifierEquals(t3.name, t3.outerBinding);
  }
  const u = { Scope(e3, t3) {
    e3.scope.bindingIdentifierEquals(t3.name, t3.outerBinding) || e3.skip();
  }, Flow(e3) {
    e3.isTypeCastExpression() || e3.skip();
  }, Function(e3, t3) {
    const r3 = t3.noOptimise;
    t3.noOptimise = true, e3.traverse(u, t3), t3.noOptimise = r3, e3.skip();
  }, ReferencedIdentifier(e3, t3) {
    const { node: r3 } = e3;
    if ("arguments" === r3.name && (t3.deopted = true), c(e3, t3)) if (t3.noOptimise) t3.deopted = true;
    else {
      const { parentPath: n3 } = e3;
      if ("params" === n3.listKey && n3.key < t3.offset) return;
      if (n3.isMemberExpression({ object: r3 })) {
        const r4 = n3.parentPath;
        if (!t3.deopted && !(r4.isAssignmentExpression() && n3.node === r4.node.left || r4.isLVal() || r4.isForXStatement() || r4.isUpdateExpression() || r4.isUnaryExpression({ operator: "delete" }) || (r4.isCallExpression() || r4.isNewExpression()) && n3.node === r4.node.callee)) {
          if (n3.node.computed) {
            if (n3.get("property").isBaseType("number")) return void t3.candidates.push({ cause: "indexGetter", path: e3 });
          } else if ("length" === n3.node.property.name) return void t3.candidates.push({ cause: "lengthGetter", path: e3 });
        }
      }
      if (0 === t3.offset && n3.isSpreadElement()) {
        const r4 = n3.parentPath;
        if (r4.isCallExpression() && 1 === r4.node.arguments.length) return void t3.candidates.push({ cause: "argSpread", path: e3 });
      }
      t3.references.push(e3);
    }
  }, BindingIdentifier(e3, t3) {
    c(e3, t3) && (t3.deopted = true);
  } };
  function p(e3, t3, r3) {
    const s3 = n2.types.numericLiteral(r3);
    let i3;
    const l2 = e3.parent;
    i3 = n2.types.isNumericLiteral(l2.property) ? n2.types.numericLiteral(l2.property.value + r3) : 0 === r3 ? l2.property : n2.types.binaryExpression("+", l2.property, n2.types.cloneNode(s3));
    const { scope: c2, parentPath: u2 } = e3;
    if (c2.isPure(i3)) {
      u2.replaceWith(o2({ ARGUMENTS: t3, OFFSET: s3, INDEX: i3 }));
      const e4 = u2, r4 = e4.get("test"), n3 = r4.get("left").evaluate();
      n3.confident && (true === n3.value ? e4.replaceWith(c2.buildUndefinedNode()) : r4.replaceWith(r4.get("right")));
    } else {
      const e4 = c2.generateUidIdentifierBasedOnNode(i3);
      c2.push({ id: e4, kind: "var" }), u2.replaceWith(a2({ ARGUMENTS: t3, OFFSET: s3, INDEX: i3, REF: n2.types.cloneNode(e4) }));
    }
  }
  function d(e3, t3, r3) {
    r3 ? e3.parentPath.replaceWith(l({ ARGUMENTS: t3, OFFSET: n2.types.numericLiteral(r3) })) : e3.replaceWith(t3);
  }
}];
var t = {};
function r(n2) {
  var s2 = t[n2];
  if (void 0 !== s2) return s2.exports;
  var i2 = t[n2] = { id: n2, loaded: false, exports: {} };
  return e[n2].call(i2.exports, i2, i2.exports, r), i2.loaded = true, i2.exports;
}
r.c = t, r.n = (e2) => {
  var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
  return r.d(t2, { a: t2 }), t2;
}, r.d = (e2, t2) => {
  for (var n2 in t2) r.o(t2, n2) && !r.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: true, get: t2[n2] });
}, r.g = function() {
  if ("object" == typeof globalThis) return globalThis;
  try {
    return this || new Function("return this")();
  } catch (e2) {
    if ("object" == typeof window) return window;
  }
}(), r.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r.nmd = (e2) => (e2.paths = [], e2.children || (e2.children = []), e2), r(346);
var n = r(347);
var s = n.a;
var i = n.b;
var o = n.c;
var a = n.d;
export {
  s as buildTemplateProcessor,
  i as loadModule,
  o as version,
  a as vueVersion
};
/*! Bundled license information:

vue3-sfc-loader/dist/vue3-sfc-loader.esm.js:
  (*!
   * vue3-sfc-loader v0.9.5 for vue3
   *
   * @description Vue3 Single File Component loader.
   * @author      Franck FREIBURGER <franck.freiburger@gmail.com>
   * @license     MIT
   * @sources     https://github.com/FranckFreiburger/vue3-sfc-loader
   *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (**
  * @vue/compiler-dom v3.4.15
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*! https://mths.be/punycode v1.4.1 by @mathias *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
  (**
  * @vue/compiler-sfc v3.4.15
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (**
  * @vue/compiler-core v3.4.15
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (**
  * @vue/shared v3.4.15
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
*/
//# sourceMappingURL=vue3-sfc-loader.js.map
